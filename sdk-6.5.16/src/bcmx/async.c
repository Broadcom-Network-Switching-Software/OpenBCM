/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * File:	xasync.c
 * Purpose:	Asynchronous BCMX API routines
 * Generator:	mkdispatch 1.54
 */

#include <bcm/types.h>
#include <bcmx/async.h>
#include <bcmx/auth.h>
#include <bcmx/bcmx.h>
#include <bcmx/cosq.h>
#include <bcmx/custom.h>
#include <bcmx/failover.h>
#include <bcmx/field.h>
#include <bcmx/ipfix.h>
#include <bcmx/ipmc.h>
#include <bcmx/l2.h>
#include <bcmx/l3.h>
#include <bcmx/link.h>
#include <bcmx/mcast.h>
#include <bcmx/mim.h>
#include <bcmx/mirror.h>
#include <bcmx/mpls.h>
#include <bcmx/multicast.h>
#include <bcmx/niv.h>
#include <bcmx/oam.h>
#include <bcmx/policer.h>
#include <bcmx/port.h>
#include <bcmx/proxy.h>
#include <bcmx/qos.h>
#include <bcmx/rate.h>
#include <bcmx/rx.h>
#include <bcmx/stat.h>
#include <bcmx/stg.h>
#include <bcmx/subport.h>
#include <bcmx/switch.h>
#include <bcmx/trill.h>
#include <bcmx/trunk.h>
#include <bcmx/tunnel.h>
#include <bcmx/tx.h>
#include <bcmx/vlan.h>
#include <bcmx/wlan.h>

#include <bcm_int/xasync_req.h>
#include <bcm_int/async_server.h>
#include <shared/alloc.h>

#ifdef	BCM_ASYNC_SUPPORT

extern void bcmx_async_run(bcmx_async_req_t *);

void
bcmx_auth_egress_get_async(
	bcmx_lport_t port,
	int * enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_AUTH_EGRESS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_egress_get.port = port;
	async->args.auth_egress_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_auth_egress_set_async(
	bcmx_lport_t port,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_AUTH_EGRESS_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_egress_set.port = port;
	async->args.auth_egress_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_auth_mac_add_async(
	bcmx_lport_t port,
	bcm_mac_t mac,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_AUTH_MAC_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_mac_add.port = port;
	async->args.auth_mac_add.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_auth_mac_delete_async(
	bcmx_lport_t port,
	bcm_mac_t mac,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_AUTH_MAC_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_mac_delete.port = port;
	async->args.auth_mac_delete.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_auth_mac_delete_all_async(
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_AUTH_MAC_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_mac_delete_all.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_auth_mode_get_async(
	bcmx_lport_t port,
	uint32 * modep,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_AUTH_MODE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_mode_get.port = port;
	async->args.auth_mode_get.modep = modep;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_auth_mode_set_async(
	bcmx_lport_t port,
	uint32 mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_AUTH_MODE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_mode_set.port = port;
	async->args.auth_mode_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_auth_unauth_callback_async(
	bcmx_auth_cb_t func,
	void * cookie,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_AUTH_UNAUTH_CALLBACK;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.auth_unauth_callback.func = func;
	async->args.auth_unauth_callback.cookie = cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_config_get_async(
	int * numq,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_CONFIG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_config_get.numq = numq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_config_set_async(
	int numq,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_CONFIG_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_config_set.numq = numq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_control_get_async(
	bcm_gport_t port,
	bcm_cos_queue_t cosq,
	bcm_cosq_control_t type,
	int * arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_CONTROL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_control_get.port = port;
	async->args.cosq_control_get.cosq = cosq;
	async->args.cosq_control_get.type = type;
	async->args.cosq_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_control_set_async(
	bcm_gport_t port,
	bcm_cos_queue_t cosq,
	bcm_cosq_control_t type,
	int arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_CONTROL_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_control_set.port = port;
	async->args.cosq_control_set.cosq = cosq;
	async->args.cosq_control_set.type = type;
	async->args.cosq_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_detach_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_discard_get_async(
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_DISCARD_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_discard_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_discard_port_get_async(
	bcmx_lport_t port,
	bcm_cos_queue_t cosq,
	uint32 color,
	int * drop_start,
	int * drop_slope,
	int * average_time,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_DISCARD_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_discard_port_get.port = port;
	async->args.cosq_discard_port_get.cosq = cosq;
	async->args.cosq_discard_port_get.color = color;
	async->args.cosq_discard_port_get.drop_start = drop_start;
	async->args.cosq_discard_port_get.drop_slope = drop_slope;
	async->args.cosq_discard_port_get.average_time = average_time;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_discard_port_set_async(
	bcmx_lport_t port,
	bcm_cos_queue_t cosq,
	uint32 color,
	int drop_start,
	int drop_slope,
	int average_time,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_DISCARD_PORT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_discard_port_set.port = port;
	async->args.cosq_discard_port_set.cosq = cosq;
	async->args.cosq_discard_port_set.color = color;
	async->args.cosq_discard_port_set.drop_start = drop_start;
	async->args.cosq_discard_port_set.drop_slope = drop_slope;
	async->args.cosq_discard_port_set.average_time = average_time;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_discard_set_async(
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_DISCARD_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_discard_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_gport_add_async(
	bcm_gport_t port,
	int numq,
	uint32 flags,
	bcm_gport_t * gport,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_GPORT_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_add.port = port;
	async->args.cosq_gport_add.numq = numq;
	async->args.cosq_gport_add.flags = flags;
	async->args.cosq_gport_add.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_gport_attach_async(
	bcm_gport_t sched_port,
	bcm_gport_t input_port,
	bcm_cos_queue_t cosq,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_GPORT_ATTACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_attach.sched_port = sched_port;
	async->args.cosq_gport_attach.input_port = input_port;
	async->args.cosq_gport_attach.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_gport_attach_get_async(
	bcm_gport_t sched_port,
	bcm_gport_t * input_port,
	bcm_cos_queue_t * cosq,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_GPORT_ATTACH_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_attach_get.sched_port = sched_port;
	async->args.cosq_gport_attach_get.input_port = input_port;
	async->args.cosq_gport_attach_get.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_gport_bandwidth_get_async(
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	uint32 * kbits_sec_min,
	uint32 * kbits_sec_max,
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_GPORT_BANDWIDTH_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_bandwidth_get.gport = gport;
	async->args.cosq_gport_bandwidth_get.cosq = cosq;
	async->args.cosq_gport_bandwidth_get.kbits_sec_min = kbits_sec_min;
	async->args.cosq_gport_bandwidth_get.kbits_sec_max = kbits_sec_max;
	async->args.cosq_gport_bandwidth_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_gport_bandwidth_set_async(
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	uint32 kbits_sec_min,
	uint32 kbits_sec_max,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_GPORT_BANDWIDTH_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_bandwidth_set.gport = gport;
	async->args.cosq_gport_bandwidth_set.cosq = cosq;
	async->args.cosq_gport_bandwidth_set.kbits_sec_min = kbits_sec_min;
	async->args.cosq_gport_bandwidth_set.kbits_sec_max = kbits_sec_max;
	async->args.cosq_gport_bandwidth_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_gport_delete_async(
	bcm_gport_t gport,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_GPORT_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_delete.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_gport_destmod_attach_async(
	bcm_gport_t gport,
	bcm_gport_t ingress_port,
	bcm_module_t dest_modid,
	int fabric_egress_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_GPORT_DESTMOD_ATTACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_destmod_attach.gport = gport;
	async->args.cosq_gport_destmod_attach.ingress_port = ingress_port;
	async->args.cosq_gport_destmod_attach.dest_modid = dest_modid;
	async->args.cosq_gport_destmod_attach.fabric_egress_port = fabric_egress_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_gport_destmod_detach_async(
	bcm_gport_t gport,
	bcm_gport_t ingress_port,
	bcm_module_t dest_modid,
	int fabric_egress_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_GPORT_DESTMOD_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_destmod_detach.gport = gport;
	async->args.cosq_gport_destmod_detach.ingress_port = ingress_port;
	async->args.cosq_gport_destmod_detach.dest_modid = dest_modid;
	async->args.cosq_gport_destmod_detach.fabric_egress_port = fabric_egress_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_gport_detach_async(
	bcm_gport_t sched_port,
	bcm_gport_t input_port,
	bcm_cos_queue_t cosq,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_GPORT_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_detach.sched_port = sched_port;
	async->args.cosq_gport_detach.input_port = input_port;
	async->args.cosq_gport_detach.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_gport_discard_get_async(
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcmx_cosq_gport_discard_t * discard,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_GPORT_DISCARD_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_discard_get.gport = gport;
	async->args.cosq_gport_discard_get.cosq = cosq;
	async->args.cosq_gport_discard_get.discard = discard;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_gport_discard_set_async(
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcmx_cosq_gport_discard_t * discard,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_GPORT_DISCARD_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_discard_set.gport = gport;
	async->args.cosq_gport_discard_set.cosq = cosq;
	async->args.cosq_gport_discard_set.discard = discard;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_gport_sched_get_async(
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	int * mode,
	int * weight,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_GPORT_SCHED_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_sched_get.gport = gport;
	async->args.cosq_gport_sched_get.cosq = cosq;
	async->args.cosq_gport_sched_get.mode = mode;
	async->args.cosq_gport_sched_get.weight = weight;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_gport_sched_set_async(
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	int mode,
	int weight,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_GPORT_SCHED_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_gport_sched_set.gport = gport;
	async->args.cosq_gport_sched_set.cosq = cosq;
	async->args.cosq_gport_sched_set.mode = mode;
	async->args.cosq_gport_sched_set.weight = weight;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_mapping_get_async(
	bcm_cos_t priority,
	bcm_cos_queue_t * cosq,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_MAPPING_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_mapping_get.priority = priority;
	async->args.cosq_mapping_get.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_mapping_set_async(
	bcm_cos_t priority,
	bcm_cos_queue_t cosq,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_MAPPING_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_mapping_set.priority = priority;
	async->args.cosq_mapping_set.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_port_bandwidth_get_async(
	bcmx_lport_t port,
	bcm_cos_queue_t cosq,
	uint32 * kbits_sec_min,
	uint32 * kbits_sec_max,
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_PORT_BANDWIDTH_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_bandwidth_get.port = port;
	async->args.cosq_port_bandwidth_get.cosq = cosq;
	async->args.cosq_port_bandwidth_get.kbits_sec_min = kbits_sec_min;
	async->args.cosq_port_bandwidth_get.kbits_sec_max = kbits_sec_max;
	async->args.cosq_port_bandwidth_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_port_bandwidth_set_async(
	bcmx_lport_t port,
	bcm_cos_queue_t cosq,
	uint32 kbits_sec_min,
	uint32 kbits_sec_max,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_PORT_BANDWIDTH_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_bandwidth_set.port = port;
	async->args.cosq_port_bandwidth_set.cosq = cosq;
	async->args.cosq_port_bandwidth_set.kbits_sec_min = kbits_sec_min;
	async->args.cosq_port_bandwidth_set.kbits_sec_max = kbits_sec_max;
	async->args.cosq_port_bandwidth_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_port_mapping_get_async(
	bcmx_lport_t port,
	bcm_cos_t priority,
	bcm_cos_queue_t * cosq,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_PORT_MAPPING_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_mapping_get.port = port;
	async->args.cosq_port_mapping_get.priority = priority;
	async->args.cosq_port_mapping_get.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_port_mapping_set_async(
	bcmx_lport_t port,
	bcm_cos_t priority,
	bcm_cos_queue_t cosq,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_PORT_MAPPING_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_mapping_set.port = port;
	async->args.cosq_port_mapping_set.priority = priority;
	async->args.cosq_port_mapping_set.cosq = cosq;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_port_sched_get_async(
	bcmx_lplist_t lplist,
	int * mode,
	int weights[BCM_COS_COUNT],
	int * delay,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_PORT_SCHED_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_sched_get.lplist = lplist;
	async->args.cosq_port_sched_get.mode = mode;
	async->args.cosq_port_sched_get.weights = (int *)weights;
	async->args.cosq_port_sched_get.delay = delay;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_port_sched_set_async(
	bcmx_lplist_t lplist,
	int mode,
	const int weights[BCM_COS_COUNT],
	int delay,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_PORT_SCHED_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_port_sched_set.lplist = lplist;
	async->args.cosq_port_sched_set.mode = mode;
	async->args.cosq_port_sched_set.weights = (int *)weights;
	async->args.cosq_port_sched_set.delay = delay;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_sched_get_async(
	int * mode,
	int weights[BCM_COS_COUNT],
	int * delay,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_SCHED_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_sched_get.mode = mode;
	async->args.cosq_sched_get.weights = (int *)weights;
	async->args.cosq_sched_get.delay = delay;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_sched_set_async(
	int mode,
	const int weights[BCM_COS_COUNT],
	int delay,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_SCHED_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_sched_set.mode = mode;
	async->args.cosq_sched_set.weights = (int *)weights;
	async->args.cosq_sched_set.delay = delay;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_sched_weight_max_get_async(
	int mode,
	int * weight_max,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_SCHED_WEIGHT_MAX_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_sched_weight_max_get.mode = mode;
	async->args.cosq_sched_weight_max_get.weight_max = weight_max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_stat_get_async(
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_stat_t stat,
	uint64 * value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_STAT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_stat_get.gport = gport;
	async->args.cosq_stat_get.cosq = cosq;
	async->args.cosq_stat_get.stat = stat;
	async->args.cosq_stat_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_stat_get32_async(
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_stat_t stat,
	uint32 * value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_STAT_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_stat_get32.gport = gport;
	async->args.cosq_stat_get32.cosq = cosq;
	async->args.cosq_stat_get32.stat = stat;
	async->args.cosq_stat_get32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_stat_set_async(
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_stat_t stat,
	uint64 value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_STAT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_stat_set.gport = gport;
	async->args.cosq_stat_set.cosq = cosq;
	async->args.cosq_stat_set.stat = stat;
	async->args.cosq_stat_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_cosq_stat_set32_async(
	bcm_gport_t gport,
	bcm_cos_queue_t cosq,
	bcm_cosq_stat_t stat,
	uint32 value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_COSQ_STAT_SET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.cosq_stat_set32.gport = gport;
	async->args.cosq_stat_set32.cosq = cosq;
	async->args.cosq_stat_set32.stat = stat;
	async->args.cosq_stat_set32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_custom_port_get_async(
	bcmx_lport_t port,
	int type,
	int max_len,
	uint32 * args,
	int * actual_len,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_CUSTOM_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.custom_port_get.port = port;
	async->args.custom_port_get.type = type;
	async->args.custom_port_get.max_len = max_len;
	async->args.custom_port_get.args = args;
	async->args.custom_port_get.actual_len = actual_len;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_custom_port_set_async(
	bcmx_lport_t port,
	int type,
	int len,
	uint32 * args,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_CUSTOM_PORT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.custom_port_set.port = port;
	async->args.custom_port_set.type = type;
	async->args.custom_port_set.len = len;
	async->args.custom_port_set.args = args;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_custom_unit_get_async(
	int type,
	int max_len,
	uint32 * args,
	int * actual_len,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_CUSTOM_UNIT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.custom_unit_get.type = type;
	async->args.custom_unit_get.max_len = max_len;
	async->args.custom_unit_get.args = args;
	async->args.custom_unit_get.actual_len = actual_len;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_custom_unit_set_async(
	int type,
	int len,
	uint32 * args,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_CUSTOM_UNIT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.custom_unit_set.type = type;
	async->args.custom_unit_set.len = len;
	async->args.custom_unit_set.args = args;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_device_attach_async(
	int unit,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_DEVICE_ATTACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.device_attach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_device_detach_async(
	int unit,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_DEVICE_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.device_detach.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_failover_cleanup_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FAILOVER_CLEANUP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_failover_create_async(
	uint32 flags,
	bcm_failover_t * failover_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FAILOVER_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_create.flags = flags;
	async->args.failover_create.failover_id = failover_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_failover_destroy_async(
	bcm_failover_t failover_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FAILOVER_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_destroy.failover_id = failover_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_failover_get_async(
	bcm_failover_t failover_id,
	int * enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FAILOVER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_get.failover_id = failover_id;
	async->args.failover_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_failover_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FAILOVER_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_failover_set_async(
	bcm_failover_t failover_id,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FAILOVER_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.failover_set.failover_id = failover_id;
	async->args.failover_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_action_add_async(
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	uint32 param0,
	uint32 param1,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ACTION_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_add.entry = entry;
	async->args.field_action_add.action = action;
	async->args.field_action_add.param0 = param0;
	async->args.field_action_add.param1 = param1;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_action_delete_async(
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	uint32 param0,
	uint32 param1,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ACTION_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_delete.entry = entry;
	async->args.field_action_delete.action = action;
	async->args.field_action_delete.param0 = param0;
	async->args.field_action_delete.param1 = param1;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_action_get_async(
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	uint32 * param0,
	uint32 * param1,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ACTION_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_get.entry = entry;
	async->args.field_action_get.action = action;
	async->args.field_action_get.param0 = param0;
	async->args.field_action_get.param1 = param1;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_action_mac_add_async(
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	bcm_mac_t mac,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ACTION_MAC_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_mac_add.entry = entry;
	async->args.field_action_mac_add.action = action;
	async->args.field_action_mac_add.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_action_mac_get_async(
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	bcm_mac_t * mac,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ACTION_MAC_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_mac_get.entry = entry;
	async->args.field_action_mac_get.action = action;
	async->args.field_action_mac_get.mac = mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_action_ports_add_async(
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	bcmx_lplist_t lplist,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ACTION_PORTS_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_ports_add.entry = entry;
	async->args.field_action_ports_add.action = action;
	async->args.field_action_ports_add.lplist = lplist;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_action_ports_get_async(
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	bcmx_lplist_t * lplist,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ACTION_PORTS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_ports_get.entry = entry;
	async->args.field_action_ports_get.action = action;
	async->args.field_action_ports_get.lplist = lplist;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_action_remove_async(
	bcm_field_entry_t entry,
	bcm_field_action_t action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ACTION_REMOVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_remove.entry = entry;
	async->args.field_action_remove.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_action_remove_all_async(
	bcm_field_entry_t entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ACTION_REMOVE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_action_remove_all.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_control_get_async(
	bcm_field_control_t control,
	uint32 * state,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_CONTROL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_control_get.control = control;
	async->args.field_control_get.state = state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_control_set_async(
	bcm_field_control_t control,
	uint32 state,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_CONTROL_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_control_set.control = control;
	async->args.field_control_set.state = state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_data_qualifier_create_async(
	bcmx_field_data_qualifier_t * data_qualifier,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_create.data_qualifier = data_qualifier;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_data_qualifier_destroy_async(
	int qual_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_destroy.qual_id = qual_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_data_qualifier_destroy_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_DESTROY_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_data_qualifier_ethertype_add_async(
	int qual_id,
	bcmx_field_data_ethertype_t * etype,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_ETHERTYPE_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_ethertype_add.qual_id = qual_id;
	async->args.field_data_qualifier_ethertype_add.etype = etype;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_data_qualifier_ethertype_delete_async(
	int qual_id,
	bcmx_field_data_ethertype_t * etype,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_ETHERTYPE_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_ethertype_delete.qual_id = qual_id;
	async->args.field_data_qualifier_ethertype_delete.etype = etype;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_data_qualifier_get_async(
	int qual_id,
	bcmx_field_data_qualifier_t * qual,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_get.qual_id = qual_id;
	async->args.field_data_qualifier_get.qual = qual;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_data_qualifier_ip_protocol_add_async(
	int qual_id,
	bcmx_field_data_ip_protocol_t * ip_protocol,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_IP_PROTOCOL_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_ip_protocol_add.qual_id = qual_id;
	async->args.field_data_qualifier_ip_protocol_add.ip_protocol = ip_protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_data_qualifier_ip_protocol_delete_async(
	int qual_id,
	bcmx_field_data_ip_protocol_t * ip_protocol,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_IP_PROTOCOL_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_ip_protocol_delete.qual_id = qual_id;
	async->args.field_data_qualifier_ip_protocol_delete.ip_protocol = ip_protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_data_qualifier_multi_get_async(
	int qual_size,
	int * qual_array,
	int * qual_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_MULTI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_multi_get.qual_size = qual_size;
	async->args.field_data_qualifier_multi_get.qual_array = qual_array;
	async->args.field_data_qualifier_multi_get.qual_count = qual_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_data_qualifier_packet_format_add_async(
	int qual_id,
	bcmx_field_data_packet_format_t * packet_format,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_PACKET_FORMAT_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_packet_format_add.qual_id = qual_id;
	async->args.field_data_qualifier_packet_format_add.packet_format = packet_format;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_data_qualifier_packet_format_delete_async(
	int qual_id,
	bcmx_field_data_packet_format_t * packet_format,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_PACKET_FORMAT_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_data_qualifier_packet_format_delete.qual_id = qual_id;
	async->args.field_data_qualifier_packet_format_delete.packet_format = packet_format;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_copy_async(
	bcm_field_entry_t src_entry,
	bcm_field_entry_t * dst_entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_COPY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_copy.src_entry = src_entry;
	async->args.field_entry_copy.dst_entry = dst_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_create_async(
	bcm_field_group_t group,
	bcm_field_entry_t * entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_create.group = group;
	async->args.field_entry_create.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_create_id_async(
	bcm_field_group_t group,
	bcm_field_entry_t entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_CREATE_ID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_create_id.group = group;
	async->args.field_entry_create_id.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_destroy_async(
	bcm_field_entry_t entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_destroy.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_destroy_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_DESTROY_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_install_async(
	bcm_field_entry_t entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_INSTALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_install.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_multi_get_async(
	bcm_field_group_t group,
	int entry_size,
	bcm_field_entry_t * entry_array,
	int * entry_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_MULTI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_multi_get.group = group;
	async->args.field_entry_multi_get.entry_size = entry_size;
	async->args.field_entry_multi_get.entry_array = entry_array;
	async->args.field_entry_multi_get.entry_count = entry_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_policer_attach_async(
	bcm_field_entry_t entry_id,
	int level,
	bcm_policer_t policer_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_POLICER_ATTACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_policer_attach.entry_id = entry_id;
	async->args.field_entry_policer_attach.level = level;
	async->args.field_entry_policer_attach.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_policer_detach_async(
	bcm_field_entry_t entry_id,
	int level,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_POLICER_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_policer_detach.entry_id = entry_id;
	async->args.field_entry_policer_detach.level = level;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_policer_detach_all_async(
	bcm_field_entry_t entry_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_POLICER_DETACH_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_policer_detach_all.entry_id = entry_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_policer_get_async(
	bcm_field_entry_t entry_id,
	int level,
	bcm_policer_t * policer_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_POLICER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_policer_get.entry_id = entry_id;
	async->args.field_entry_policer_get.level = level;
	async->args.field_entry_policer_get.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_prio_get_async(
	bcm_field_entry_t entry,
	int * prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_PRIO_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_prio_get.entry = entry;
	async->args.field_entry_prio_get.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_prio_set_async(
	bcm_field_entry_t entry,
	int prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_PRIO_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_prio_set.entry = entry;
	async->args.field_entry_prio_set.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_reinstall_async(
	bcm_field_entry_t entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_REINSTALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_reinstall.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_remove_async(
	bcm_field_entry_t entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_REMOVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_remove.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_stat_attach_async(
	bcm_field_entry_t entry,
	int stat_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_STAT_ATTACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_stat_attach.entry = entry;
	async->args.field_entry_stat_attach.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_stat_detach_async(
	bcm_field_entry_t entry,
	int stat_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_STAT_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_stat_detach.entry = entry;
	async->args.field_entry_stat_detach.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_entry_stat_get_async(
	bcm_field_entry_t entry,
	int * stat_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_ENTRY_STAT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_entry_stat_get.entry = entry;
	async->args.field_entry_stat_get.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_compress_async(
	bcm_field_group_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_COMPRESS;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_compress.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_create_async(
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_t * group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_create.qset = qset;
	async->args.field_group_create.pri = pri;
	async->args.field_group_create.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_create_id_async(
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_CREATE_ID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_create_id.qset = qset;
	async->args.field_group_create_id.pri = pri;
	async->args.field_group_create_id.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_create_mode_async(
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t * group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_CREATE_MODE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_create_mode.qset = qset;
	async->args.field_group_create_mode.pri = pri;
	async->args.field_group_create_mode.mode = mode;
	async->args.field_group_create_mode.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_create_mode_id_async(
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_CREATE_MODE_ID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_create_mode_id.qset = qset;
	async->args.field_group_create_mode_id.pri = pri;
	async->args.field_group_create_mode_id.mode = mode;
	async->args.field_group_create_mode_id.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_destroy_async(
	bcm_field_group_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_destroy.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_enable_get_async(
	bcm_field_group_t group,
	int * enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_ENABLE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_enable_get.group = group;
	async->args.field_group_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_enable_set_async(
	bcm_field_group_t group,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_ENABLE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_enable_set.group = group;
	async->args.field_group_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_get_async(
	bcm_field_group_t group,
	bcm_field_qset_t * qset,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_get.group = group;
	async->args.field_group_get.qset = qset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_install_async(
	bcm_field_group_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_INSTALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_install.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_mode_get_async(
	bcm_field_group_t group,
	bcm_field_group_mode_t * mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_MODE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_mode_get.group = group;
	async->args.field_group_mode_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_port_create_mode_async(
	bcmx_lport_t port,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t * group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_PORT_CREATE_MODE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_port_create_mode.port = port;
	async->args.field_group_port_create_mode.qset = qset;
	async->args.field_group_port_create_mode.pri = pri;
	async->args.field_group_port_create_mode.mode = mode;
	async->args.field_group_port_create_mode.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_port_create_mode_id_async(
	bcmx_lport_t port,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_PORT_CREATE_MODE_ID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_port_create_mode_id.port = port;
	async->args.field_group_port_create_mode_id.qset = qset;
	async->args.field_group_port_create_mode_id.pri = pri;
	async->args.field_group_port_create_mode_id.mode = mode;
	async->args.field_group_port_create_mode_id.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_ports_create_mode_async(
	bcmx_lplist_t lplist,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t * group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_PORTS_CREATE_MODE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_ports_create_mode.lplist = lplist;
	async->args.field_group_ports_create_mode.qset = qset;
	async->args.field_group_ports_create_mode.pri = pri;
	async->args.field_group_ports_create_mode.mode = mode;
	async->args.field_group_ports_create_mode.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_ports_create_mode_id_async(
	bcmx_lplist_t lplist,
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_PORTS_CREATE_MODE_ID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_ports_create_mode_id.lplist = lplist;
	async->args.field_group_ports_create_mode_id.qset = qset;
	async->args.field_group_ports_create_mode_id.pri = pri;
	async->args.field_group_ports_create_mode_id.mode = mode;
	async->args.field_group_ports_create_mode_id.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_priority_get_async(
	bcm_field_group_t group,
	int * priority,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_PRIORITY_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_priority_get.group = group;
	async->args.field_group_priority_get.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_priority_set_async(
	bcm_field_group_t group,
	int priority,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_PRIORITY_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_priority_set.group = group;
	async->args.field_group_priority_set.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_remove_async(
	bcm_field_group_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_REMOVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_remove.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_set_async(
	bcm_field_group_t group,
	bcm_field_qset_t qset,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_set.group = group;
	async->args.field_group_set.qset = qset;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_traverse_async(
	bcm_field_group_traverse_cb callback,
	void * user_data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_TRAVERSE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_traverse.callback = callback;
	async->args.field_group_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_wlan_create_mode_async(
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t * group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_WLAN_CREATE_MODE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_wlan_create_mode.qset = qset;
	async->args.field_group_wlan_create_mode.pri = pri;
	async->args.field_group_wlan_create_mode.mode = mode;
	async->args.field_group_wlan_create_mode.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_group_wlan_create_mode_id_async(
	bcm_field_qset_t qset,
	int pri,
	bcm_field_group_mode_t mode,
	bcm_field_group_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_GROUP_WLAN_CREATE_MODE_ID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_group_wlan_create_mode_id.qset = qset;
	async->args.field_group_wlan_create_mode_id.pri = pri;
	async->args.field_group_wlan_create_mode_id.mode = mode;
	async->args.field_group_wlan_create_mode_id.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qset_data_qualifier_add_async(
	bcm_field_qset_t * qset,
	int qual_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QSET_DATA_QUALIFIER_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qset_data_qualifier_add.qset = qset;
	async->args.field_qset_data_qualifier_add.qual_id = qual_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qset_data_qualifier_get_async(
	bcm_field_qset_t * qset,
	int qual_max,
	int * qual_arr,
	int * qual_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QSET_DATA_QUALIFIER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qset_data_qualifier_get.qset = qset;
	async->args.field_qset_data_qualifier_get.qual_max = qual_max;
	async->args.field_qset_data_qualifier_get.qual_arr = qual_arr;
	async->args.field_qset_data_qualifier_get.qual_count = qual_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualifier_delete_async(
	bcm_field_entry_t entry,
	bcm_field_qualify_t qual_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFIER_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualifier_delete.entry = entry;
	async->args.field_qualifier_delete.qual_id = qual_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_CnTag_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_CNTAG;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CnTag.entry = entry;
	async->args.field_qualify_CnTag.data = data;
	async->args.field_qualify_CnTag.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_CnTag_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_CNTAG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_CnTag_get.entry = entry;
	async->args.field_qualify_CnTag_get.data = data;
	async->args.field_qualify_CnTag_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Color_async(
	bcm_field_entry_t entry,
	uint8 color,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_COLOR;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Color.entry = entry;
	async->args.field_qualify_Color.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Color_get_async(
	bcm_field_entry_t entry,
	uint8 * color,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_COLOR_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Color_get.entry = entry;
	async->args.field_qualify_Color_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DSCP_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSCP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DSCP.entry = entry;
	async->args.field_qualify_DSCP.data = data;
	async->args.field_qualify_DSCP.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DSCP_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSCP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DSCP_get.entry = entry;
	async->args.field_qualify_DSCP_get.data = data;
	async->args.field_qualify_DSCP_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Decap_async(
	bcm_field_entry_t entry,
	bcm_field_decap_t decap,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DECAP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Decap.entry = entry;
	async->args.field_qualify_Decap.decap = decap;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DosAttack_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DOSATTACK;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DosAttack.entry = entry;
	async->args.field_qualify_DosAttack.data = data;
	async->args.field_qualify_DosAttack.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DosAttack_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DOSATTACK_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DosAttack_get.entry = entry;
	async->args.field_qualify_DosAttack_get.data = data;
	async->args.field_qualify_DosAttack_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Drop_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DROP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Drop.entry = entry;
	async->args.field_qualify_Drop.data = data;
	async->args.field_qualify_Drop.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Drop_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DROP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Drop_get.entry = entry;
	async->args.field_qualify_Drop_get.data = data;
	async->args.field_qualify_Drop_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstClassField_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSFIELD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstClassField.entry = entry;
	async->args.field_qualify_DstClassField.data = data;
	async->args.field_qualify_DstClassField.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstClassField_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSFIELD_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstClassField_get.entry = entry;
	async->args.field_qualify_DstClassField_get.data = data;
	async->args.field_qualify_DstClassField_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstClassL2_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSL2;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstClassL2.entry = entry;
	async->args.field_qualify_DstClassL2.data = data;
	async->args.field_qualify_DstClassL2.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstClassL2_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSL2_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstClassL2_get.entry = entry;
	async->args.field_qualify_DstClassL2_get.data = data;
	async->args.field_qualify_DstClassL2_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstClassL3_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSL3;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstClassL3.entry = entry;
	async->args.field_qualify_DstClassL3.data = data;
	async->args.field_qualify_DstClassL3.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstClassL3_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSL3_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstClassL3_get.entry = entry;
	async->args.field_qualify_DstClassL3_get.data = data;
	async->args.field_qualify_DstClassL3_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstHiGig_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTHIGIG;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstHiGig.entry = entry;
	async->args.field_qualify_DstHiGig.data = data;
	async->args.field_qualify_DstHiGig.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstHiGig_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTHIGIG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstHiGig_get.entry = entry;
	async->args.field_qualify_DstHiGig_get.data = data;
	async->args.field_qualify_DstHiGig_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstIp_async(
	bcm_field_entry_t entry,
	bcm_ip_t data,
	bcm_ip_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp.entry = entry;
	async->args.field_qualify_DstIp.data = data;
	async->args.field_qualify_DstIp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstIp6_async(
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6.entry = entry;
	async->args.field_qualify_DstIp6.data = (uint8 *)data;
	async->args.field_qualify_DstIp6.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstIp6High_async(
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6HIGH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6High.entry = entry;
	async->args.field_qualify_DstIp6High.data = (uint8 *)data;
	async->args.field_qualify_DstIp6High.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstIp6High_get_async(
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6HIGH_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6High_get.entry = entry;
	async->args.field_qualify_DstIp6High_get.data = data;
	async->args.field_qualify_DstIp6High_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstIp6Low_async(
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6LOW;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6Low.entry = entry;
	async->args.field_qualify_DstIp6Low.data = (uint8 *)data;
	async->args.field_qualify_DstIp6Low.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstIp6Low_get_async(
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6LOW_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6Low_get.entry = entry;
	async->args.field_qualify_DstIp6Low_get.data = data;
	async->args.field_qualify_DstIp6Low_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstIp6_get_async(
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp6_get.entry = entry;
	async->args.field_qualify_DstIp6_get.data = data;
	async->args.field_qualify_DstIp6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstIp_get_async(
	bcm_field_entry_t entry,
	bcm_ip_t * data,
	bcm_ip_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstIp_get.entry = entry;
	async->args.field_qualify_DstIp_get.data = data;
	async->args.field_qualify_DstIp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstL3Egress_async(
	bcm_field_entry_t entry,
	bcm_if_t if_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTL3EGRESS;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstL3Egress.entry = entry;
	async->args.field_qualify_DstL3Egress.if_id = if_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstL3Egress_get_async(
	bcm_field_entry_t entry,
	bcm_if_t * if_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTL3EGRESS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstL3Egress_get.entry = entry;
	async->args.field_qualify_DstL3Egress_get.if_id = if_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstMac_async(
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTMAC;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMac.entry = entry;
	async->args.field_qualify_DstMac.data = (uint8 *)data;
	async->args.field_qualify_DstMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstMac_get_async(
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTMAC_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMac_get.entry = entry;
	async->args.field_qualify_DstMac_get.data = data;
	async->args.field_qualify_DstMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstMimGport_async(
	bcm_field_entry_t entry,
	bcm_gport_t mim_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTMIMGPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMimGport.entry = entry;
	async->args.field_qualify_DstMimGport.mim_port_id = mim_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstMimGport_get_async(
	bcm_field_entry_t entry,
	bcm_gport_t * mim_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTMIMGPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMimGport_get.entry = entry;
	async->args.field_qualify_DstMimGport_get.mim_port_id = mim_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstMplsGport_async(
	bcm_field_entry_t entry,
	bcm_gport_t mpls_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTMPLSGPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMplsGport.entry = entry;
	async->args.field_qualify_DstMplsGport.mpls_port_id = mpls_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstMplsGport_get_async(
	bcm_field_entry_t entry,
	bcm_gport_t * mpls_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTMPLSGPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMplsGport_get.entry = entry;
	async->args.field_qualify_DstMplsGport_get.mpls_port_id = mpls_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstMulticastGroup_async(
	bcm_field_entry_t entry,
	bcm_gport_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTICASTGROUP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMulticastGroup.entry = entry;
	async->args.field_qualify_DstMulticastGroup.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstMulticastGroup_get_async(
	bcm_field_entry_t entry,
	bcm_gport_t * group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTICASTGROUP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMulticastGroup_get.entry = entry;
	async->args.field_qualify_DstMulticastGroup_get.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstMultipath_async(
	bcm_field_entry_t entry,
	bcm_if_t mpintf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTIPATH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMultipath.entry = entry;
	async->args.field_qualify_DstMultipath.mpintf = mpintf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstMultipath_get_async(
	bcm_field_entry_t entry,
	bcm_if_t * mpintf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTIPATH_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstMultipath_get.entry = entry;
	async->args.field_qualify_DstMultipath_get.mpintf = mpintf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstPort_async(
	bcm_field_entry_t entry,
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPort.entry = entry;
	async->args.field_qualify_DstPort.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstPort_get_async(
	bcm_field_entry_t entry,
	bcm_module_t * data_modid,
	bcm_module_t * mask_modid,
	bcm_port_t * data_port,
	bcm_port_t * mask_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstPort_get.entry = entry;
	async->args.field_qualify_DstPort_get.data_modid = data_modid;
	async->args.field_qualify_DstPort_get.mask_modid = mask_modid;
	async->args.field_qualify_DstPort_get.data_port = data_port;
	async->args.field_qualify_DstPort_get.mask_port = mask_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstTrunk_async(
	bcm_field_entry_t entry,
	bcm_trunk_t tid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTTRUNK;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstTrunk.entry = entry;
	async->args.field_qualify_DstTrunk.tid = tid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstTrunk_get_async(
	bcm_field_entry_t entry,
	bcm_trunk_t * data,
	bcm_trunk_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTTRUNK_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstTrunk_get.entry = entry;
	async->args.field_qualify_DstTrunk_get.data = data;
	async->args.field_qualify_DstTrunk_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstWlanGport_async(
	bcm_field_entry_t entry,
	bcm_gport_t wlan_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTWLANGPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstWlanGport.entry = entry;
	async->args.field_qualify_DstWlanGport.wlan_port_id = wlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_DstWlanGport_get_async(
	bcm_field_entry_t entry,
	bcm_gport_t * wlan_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DSTWLANGPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_DstWlanGport_get.entry = entry;
	async->args.field_qualify_DstWlanGport_get.wlan_port_id = wlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_EtherType_async(
	bcm_field_entry_t entry,
	uint16 data,
	uint16 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_ETHERTYPE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EtherType.entry = entry;
	async->args.field_qualify_EtherType.data = data;
	async->args.field_qualify_EtherType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_EtherType_get_async(
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_ETHERTYPE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_EtherType_get.entry = entry;
	async->args.field_qualify_EtherType_get.data = data;
	async->args.field_qualify_EtherType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_ExtensionHeader2Type_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADER2TYPE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExtensionHeader2Type.entry = entry;
	async->args.field_qualify_ExtensionHeader2Type.data = data;
	async->args.field_qualify_ExtensionHeader2Type.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_ExtensionHeader2Type_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADER2TYPE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExtensionHeader2Type_get.entry = entry;
	async->args.field_qualify_ExtensionHeader2Type_get.data = data;
	async->args.field_qualify_ExtensionHeader2Type_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_ExtensionHeaderSubCode_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADERSUBCODE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExtensionHeaderSubCode.entry = entry;
	async->args.field_qualify_ExtensionHeaderSubCode.data = data;
	async->args.field_qualify_ExtensionHeaderSubCode.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_ExtensionHeaderSubCode_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADERSUBCODE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExtensionHeaderSubCode_get.entry = entry;
	async->args.field_qualify_ExtensionHeaderSubCode_get.data = data;
	async->args.field_qualify_ExtensionHeaderSubCode_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_ExtensionHeaderType_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADERTYPE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExtensionHeaderType.entry = entry;
	async->args.field_qualify_ExtensionHeaderType.data = data;
	async->args.field_qualify_ExtensionHeaderType.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_ExtensionHeaderType_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADERTYPE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ExtensionHeaderType_get.entry = entry;
	async->args.field_qualify_ExtensionHeaderType_get.data = data;
	async->args.field_qualify_ExtensionHeaderType_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_FabricQueueTag_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_FABRICQUEUETAG;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FabricQueueTag.entry = entry;
	async->args.field_qualify_FabricQueueTag.data = data;
	async->args.field_qualify_FabricQueueTag.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_FabricQueueTag_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_FABRICQUEUETAG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FabricQueueTag_get.entry = entry;
	async->args.field_qualify_FabricQueueTag_get.data = data;
	async->args.field_qualify_FabricQueueTag_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_FibreChanInner_async(
	bcm_field_entry_t entry,
	bcm_field_FibreChan_t fibre_chan_type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANINNER;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanInner.entry = entry;
	async->args.field_qualify_FibreChanInner.fibre_chan_type = fibre_chan_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_FibreChanInner_get_async(
	bcm_field_entry_t entry,
	bcm_field_FibreChan_t * fibre_chan_type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANINNER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanInner_get.entry = entry;
	async->args.field_qualify_FibreChanInner_get.fibre_chan_type = fibre_chan_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_FibreChanOuter_async(
	bcm_field_entry_t entry,
	bcm_field_FibreChan_t fibre_chan_type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANOUTER;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanOuter.entry = entry;
	async->args.field_qualify_FibreChanOuter.fibre_chan_type = fibre_chan_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_FibreChanOuter_get_async(
	bcm_field_entry_t entry,
	bcm_field_FibreChan_t * fibre_chan_type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_FIBRECHANOUTER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_FibreChanOuter_get.entry = entry;
	async->args.field_qualify_FibreChanOuter_get.fibre_chan_type = fibre_chan_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_ForwardingType_async(
	bcm_field_entry_t entry,
	bcm_field_ForwardingType_t type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGTYPE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingType.entry = entry;
	async->args.field_qualify_ForwardingType.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_ForwardingType_get_async(
	bcm_field_entry_t entry,
	bcm_field_ForwardingType_t * type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGTYPE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingType_get.entry = entry;
	async->args.field_qualify_ForwardingType_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_ForwardingVlanId_async(
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGVLANID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingVlanId.entry = entry;
	async->args.field_qualify_ForwardingVlanId.data = data;
	async->args.field_qualify_ForwardingVlanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_ForwardingVlanId_get_async(
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGVLANID_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingVlanId_get.entry = entry;
	async->args.field_qualify_ForwardingVlanId_get.data = data;
	async->args.field_qualify_ForwardingVlanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_ForwardingVlanValid_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGVLANVALID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingVlanValid.entry = entry;
	async->args.field_qualify_ForwardingVlanValid.data = data;
	async->args.field_qualify_ForwardingVlanValid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_ForwardingVlanValid_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGVLANVALID_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_ForwardingVlanValid_get.entry = entry;
	async->args.field_qualify_ForwardingVlanValid_get.data = data;
	async->args.field_qualify_ForwardingVlanValid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_HiGig_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_HIGIG;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGig.entry = entry;
	async->args.field_qualify_HiGig.data = data;
	async->args.field_qualify_HiGig.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_HiGig_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_HIGIG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_HiGig_get.entry = entry;
	async->args.field_qualify_HiGig_get.data = data;
	async->args.field_qualify_HiGig_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IcmpTypeCode_get_async(
	bcm_field_entry_t entry,
	uint16 * data,
	uint16 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_ICMPTYPECODE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IcmpTypeCode_get.entry = entry;
	async->args.field_qualify_IcmpTypeCode_get.data = data;
	async->args.field_qualify_IcmpTypeCode_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InPort_async(
	bcm_field_entry_t entry,
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InPort.entry = entry;
	async->args.field_qualify_InPort.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InPort_get_async(
	bcm_field_entry_t entry,
	bcm_port_t * data,
	bcm_port_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InPort_get.entry = entry;
	async->args.field_qualify_InPort_get.data = data;
	async->args.field_qualify_InPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InPorts_async(
	bcm_field_entry_t entry,
	bcmx_lplist_t lplist,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INPORTS;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InPorts.entry = entry;
	async->args.field_qualify_InPorts.lplist = lplist;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InPorts_get_async(
	bcm_field_entry_t entry,
	bcm_pbmp_t * data,
	bcm_pbmp_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INPORTS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InPorts_get.entry = entry;
	async->args.field_qualify_InPorts_get.data = data;
	async->args.field_qualify_InPorts_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IngressStpState_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSSTPSTATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressStpState.entry = entry;
	async->args.field_qualify_IngressStpState.data = data;
	async->args.field_qualify_IngressStpState.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IngressStpState_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSSTPSTATE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IngressStpState_get.entry = entry;
	async->args.field_qualify_IngressStpState_get.data = data;
	async->args.field_qualify_IngressStpState_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerDSCP_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSCP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDSCP.entry = entry;
	async->args.field_qualify_InnerDSCP.data = data;
	async->args.field_qualify_InnerDSCP.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerDSCP_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSCP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDSCP_get.entry = entry;
	async->args.field_qualify_InnerDSCP_get.data = data;
	async->args.field_qualify_InnerDSCP_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerDstIp_async(
	bcm_field_entry_t entry,
	bcm_ip_t data,
	bcm_ip_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstIp.entry = entry;
	async->args.field_qualify_InnerDstIp.data = data;
	async->args.field_qualify_InnerDstIp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerDstIp6_async(
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP6;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstIp6.entry = entry;
	async->args.field_qualify_InnerDstIp6.data = (uint8 *)data;
	async->args.field_qualify_InnerDstIp6.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerDstIp6High_async(
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP6HIGH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstIp6High.entry = entry;
	async->args.field_qualify_InnerDstIp6High.data = (uint8 *)data;
	async->args.field_qualify_InnerDstIp6High.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerDstIp6High_get_async(
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP6HIGH_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstIp6High_get.entry = entry;
	async->args.field_qualify_InnerDstIp6High_get.data = data;
	async->args.field_qualify_InnerDstIp6High_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerDstIp6_get_async(
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP6_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstIp6_get.entry = entry;
	async->args.field_qualify_InnerDstIp6_get.data = data;
	async->args.field_qualify_InnerDstIp6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerDstIp_get_async(
	bcm_field_entry_t entry,
	bcm_ip_t * data,
	bcm_ip_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerDstIp_get.entry = entry;
	async->args.field_qualify_InnerDstIp_get.data = data;
	async->args.field_qualify_InnerDstIp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerIp6FlowLabel_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERIP6FLOWLABEL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIp6FlowLabel.entry = entry;
	async->args.field_qualify_InnerIp6FlowLabel.data = data;
	async->args.field_qualify_InnerIp6FlowLabel.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerIp6FlowLabel_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERIP6FLOWLABEL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIp6FlowLabel_get.entry = entry;
	async->args.field_qualify_InnerIp6FlowLabel_get.data = data;
	async->args.field_qualify_InnerIp6FlowLabel_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerIpFrag_async(
	bcm_field_entry_t entry,
	bcm_field_IpFrag_t frag_info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPFRAG;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpFrag.entry = entry;
	async->args.field_qualify_InnerIpFrag.frag_info = frag_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerIpFrag_get_async(
	bcm_field_entry_t entry,
	bcm_field_IpFrag_t * frag_info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPFRAG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpFrag_get.entry = entry;
	async->args.field_qualify_InnerIpFrag_get.frag_info = frag_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerIpProtocol_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPPROTOCOL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpProtocol.entry = entry;
	async->args.field_qualify_InnerIpProtocol.data = data;
	async->args.field_qualify_InnerIpProtocol.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerIpProtocolCommon_async(
	bcm_field_entry_t entry,
	bcm_field_IpProtocolCommon_t protocol,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPPROTOCOLCOMMON;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpProtocolCommon.entry = entry;
	async->args.field_qualify_InnerIpProtocolCommon.protocol = protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerIpProtocolCommon_get_async(
	bcm_field_entry_t entry,
	bcm_field_IpProtocolCommon_t * protocol,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPPROTOCOLCOMMON_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpProtocolCommon_get.entry = entry;
	async->args.field_qualify_InnerIpProtocolCommon_get.protocol = protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerIpProtocol_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPPROTOCOL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpProtocol_get.entry = entry;
	async->args.field_qualify_InnerIpProtocol_get.data = data;
	async->args.field_qualify_InnerIpProtocol_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerIpType_async(
	bcm_field_entry_t entry,
	bcm_field_IpType_t type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPTYPE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpType.entry = entry;
	async->args.field_qualify_InnerIpType.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerIpType_get_async(
	bcm_field_entry_t entry,
	bcm_field_IpType_t * type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPTYPE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerIpType_get.entry = entry;
	async->args.field_qualify_InnerIpType_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerL4DstPort_async(
	bcm_field_entry_t entry,
	bcm_l4_port_t data,
	bcm_l4_port_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERL4DSTPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerL4DstPort.entry = entry;
	async->args.field_qualify_InnerL4DstPort.data = data;
	async->args.field_qualify_InnerL4DstPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerL4DstPort_get_async(
	bcm_field_entry_t entry,
	bcm_l4_port_t * data,
	bcm_l4_port_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERL4DSTPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerL4DstPort_get.entry = entry;
	async->args.field_qualify_InnerL4DstPort_get.data = data;
	async->args.field_qualify_InnerL4DstPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerL4SrcPort_async(
	bcm_field_entry_t entry,
	bcm_l4_port_t data,
	bcm_l4_port_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERL4SRCPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerL4SrcPort.entry = entry;
	async->args.field_qualify_InnerL4SrcPort.data = data;
	async->args.field_qualify_InnerL4SrcPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerL4SrcPort_get_async(
	bcm_field_entry_t entry,
	bcm_l4_port_t * data,
	bcm_l4_port_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERL4SRCPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerL4SrcPort_get.entry = entry;
	async->args.field_qualify_InnerL4SrcPort_get.data = data;
	async->args.field_qualify_InnerL4SrcPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerSrcIp_async(
	bcm_field_entry_t entry,
	bcm_ip_t data,
	bcm_ip_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcIp.entry = entry;
	async->args.field_qualify_InnerSrcIp.data = data;
	async->args.field_qualify_InnerSrcIp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerSrcIp6_async(
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP6;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcIp6.entry = entry;
	async->args.field_qualify_InnerSrcIp6.data = (uint8 *)data;
	async->args.field_qualify_InnerSrcIp6.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerSrcIp6High_async(
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP6HIGH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcIp6High.entry = entry;
	async->args.field_qualify_InnerSrcIp6High.data = (uint8 *)data;
	async->args.field_qualify_InnerSrcIp6High.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerSrcIp6High_get_async(
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP6HIGH_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcIp6High_get.entry = entry;
	async->args.field_qualify_InnerSrcIp6High_get.data = data;
	async->args.field_qualify_InnerSrcIp6High_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerSrcIp6_get_async(
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP6_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcIp6_get.entry = entry;
	async->args.field_qualify_InnerSrcIp6_get.data = data;
	async->args.field_qualify_InnerSrcIp6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerSrcIp_get_async(
	bcm_field_entry_t entry,
	bcm_ip_t * data,
	bcm_ip_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerSrcIp_get.entry = entry;
	async->args.field_qualify_InnerSrcIp_get.data = data;
	async->args.field_qualify_InnerSrcIp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerTos_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERTOS;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerTos.entry = entry;
	async->args.field_qualify_InnerTos.data = data;
	async->args.field_qualify_InnerTos.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerTos_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERTOS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerTos_get.entry = entry;
	async->args.field_qualify_InnerTos_get.data = data;
	async->args.field_qualify_InnerTos_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerTpid_async(
	bcm_field_entry_t entry,
	uint16 tpid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERTPID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerTpid.entry = entry;
	async->args.field_qualify_InnerTpid.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerTpid_get_async(
	bcm_field_entry_t entry,
	uint16 * tpid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERTPID_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerTpid_get.entry = entry;
	async->args.field_qualify_InnerTpid_get.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerTtl_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERTTL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerTtl.entry = entry;
	async->args.field_qualify_InnerTtl.data = data;
	async->args.field_qualify_InnerTtl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerTtl_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERTTL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerTtl_get.entry = entry;
	async->args.field_qualify_InnerTtl_get.data = data;
	async->args.field_qualify_InnerTtl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerVlan_async(
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLAN;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlan.entry = entry;
	async->args.field_qualify_InnerVlan.data = data;
	async->args.field_qualify_InnerVlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerVlanCfi_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANCFI;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanCfi.entry = entry;
	async->args.field_qualify_InnerVlanCfi.data = data;
	async->args.field_qualify_InnerVlanCfi.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerVlanCfi_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANCFI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanCfi_get.entry = entry;
	async->args.field_qualify_InnerVlanCfi_get.data = data;
	async->args.field_qualify_InnerVlanCfi_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerVlanId_async(
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanId.entry = entry;
	async->args.field_qualify_InnerVlanId.data = data;
	async->args.field_qualify_InnerVlanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerVlanId_get_async(
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANID_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanId_get.entry = entry;
	async->args.field_qualify_InnerVlanId_get.data = data;
	async->args.field_qualify_InnerVlanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerVlanPri_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANPRI;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanPri.entry = entry;
	async->args.field_qualify_InnerVlanPri.data = data;
	async->args.field_qualify_InnerVlanPri.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerVlanPri_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANPRI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlanPri_get.entry = entry;
	async->args.field_qualify_InnerVlanPri_get.data = data;
	async->args.field_qualify_InnerVlanPri_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InnerVlan_get_async(
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLAN_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InnerVlan_get.entry = entry;
	async->args.field_qualify_InnerVlan_get.data = data;
	async->args.field_qualify_InnerVlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IntPriority_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INTPRIORITY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IntPriority.entry = entry;
	async->args.field_qualify_IntPriority.data = data;
	async->args.field_qualify_IntPriority.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IntPriority_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INTPRIORITY_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IntPriority_get.entry = entry;
	async->args.field_qualify_IntPriority_get.data = data;
	async->args.field_qualify_IntPriority_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InterfaceClassL2_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSL2;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassL2.entry = entry;
	async->args.field_qualify_InterfaceClassL2.data = data;
	async->args.field_qualify_InterfaceClassL2.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InterfaceClassL2_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSL2_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassL2_get.entry = entry;
	async->args.field_qualify_InterfaceClassL2_get.data = data;
	async->args.field_qualify_InterfaceClassL2_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InterfaceClassL3_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSL3;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassL3.entry = entry;
	async->args.field_qualify_InterfaceClassL3.data = data;
	async->args.field_qualify_InterfaceClassL3.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InterfaceClassL3_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSL3_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassL3_get.entry = entry;
	async->args.field_qualify_InterfaceClassL3_get.data = data;
	async->args.field_qualify_InterfaceClassL3_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InterfaceClassPort_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassPort.entry = entry;
	async->args.field_qualify_InterfaceClassPort.data = data;
	async->args.field_qualify_InterfaceClassPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_InterfaceClassPort_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_InterfaceClassPort_get.entry = entry;
	async->args.field_qualify_InterfaceClassPort_get.data = data;
	async->args.field_qualify_InterfaceClassPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Ip6FlowLabel_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IP6FLOWLABEL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6FlowLabel.entry = entry;
	async->args.field_qualify_Ip6FlowLabel.data = data;
	async->args.field_qualify_Ip6FlowLabel.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Ip6FlowLabel_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IP6FLOWLABEL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6FlowLabel_get.entry = entry;
	async->args.field_qualify_Ip6FlowLabel_get.data = data;
	async->args.field_qualify_Ip6FlowLabel_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Ip6HopLimit_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IP6HOPLIMIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6HopLimit.entry = entry;
	async->args.field_qualify_Ip6HopLimit.data = data;
	async->args.field_qualify_Ip6HopLimit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Ip6HopLimit_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IP6HOPLIMIT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6HopLimit_get.entry = entry;
	async->args.field_qualify_Ip6HopLimit_get.data = data;
	async->args.field_qualify_Ip6HopLimit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Ip6NextHeader_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IP6NEXTHEADER;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6NextHeader.entry = entry;
	async->args.field_qualify_Ip6NextHeader.data = data;
	async->args.field_qualify_Ip6NextHeader.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Ip6NextHeader_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IP6NEXTHEADER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6NextHeader_get.entry = entry;
	async->args.field_qualify_Ip6NextHeader_get.data = data;
	async->args.field_qualify_Ip6NextHeader_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Ip6TrafficClass_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IP6TRAFFICCLASS;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6TrafficClass.entry = entry;
	async->args.field_qualify_Ip6TrafficClass.data = data;
	async->args.field_qualify_Ip6TrafficClass.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Ip6TrafficClass_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IP6TRAFFICCLASS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ip6TrafficClass_get.entry = entry;
	async->args.field_qualify_Ip6TrafficClass_get.data = data;
	async->args.field_qualify_Ip6TrafficClass_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpFlags_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPFLAGS;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpFlags.entry = entry;
	async->args.field_qualify_IpFlags.data = data;
	async->args.field_qualify_IpFlags.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpFlags_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPFLAGS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpFlags_get.entry = entry;
	async->args.field_qualify_IpFlags_get.data = data;
	async->args.field_qualify_IpFlags_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpFrag_async(
	bcm_field_entry_t entry,
	bcm_field_IpFrag_t frag_info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPFRAG;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpFrag.entry = entry;
	async->args.field_qualify_IpFrag.frag_info = frag_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpFrag_get_async(
	bcm_field_entry_t entry,
	bcm_field_IpFrag_t * frag_info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPFRAG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpFrag_get.entry = entry;
	async->args.field_qualify_IpFrag_get.frag_info = frag_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpInfo_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPINFO;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpInfo.entry = entry;
	async->args.field_qualify_IpInfo.data = data;
	async->args.field_qualify_IpInfo.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpInfo_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPINFO_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpInfo_get.entry = entry;
	async->args.field_qualify_IpInfo_get.data = data;
	async->args.field_qualify_IpInfo_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpProtocol_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpProtocol.entry = entry;
	async->args.field_qualify_IpProtocol.data = data;
	async->args.field_qualify_IpProtocol.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpProtocolCommon_async(
	bcm_field_entry_t entry,
	bcm_field_IpProtocolCommon_t protocol,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOLCOMMON;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpProtocolCommon.entry = entry;
	async->args.field_qualify_IpProtocolCommon.protocol = protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpProtocolCommon_get_async(
	bcm_field_entry_t entry,
	bcm_field_IpProtocolCommon_t * protocol,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOLCOMMON_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpProtocolCommon_get.entry = entry;
	async->args.field_qualify_IpProtocolCommon_get.protocol = protocol;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpProtocol_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpProtocol_get.entry = entry;
	async->args.field_qualify_IpProtocol_get.data = data;
	async->args.field_qualify_IpProtocol_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpType_async(
	bcm_field_entry_t entry,
	bcm_field_IpType_t type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPTYPE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpType.entry = entry;
	async->args.field_qualify_IpType.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpType_get_async(
	bcm_field_entry_t entry,
	bcm_field_IpType_t * type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPTYPE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpType_get.entry = entry;
	async->args.field_qualify_IpType_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpmcStarGroupHit_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPMCSTARGROUPHIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpmcStarGroupHit.entry = entry;
	async->args.field_qualify_IpmcStarGroupHit.data = data;
	async->args.field_qualify_IpmcStarGroupHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_IpmcStarGroupHit_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_IPMCSTARGROUPHIT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_IpmcStarGroupHit_get.entry = entry;
	async->args.field_qualify_IpmcStarGroupHit_get.data = data;
	async->args.field_qualify_IpmcStarGroupHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2CacheHit_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2CACHEHIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2CacheHit.entry = entry;
	async->args.field_qualify_L2CacheHit.data = data;
	async->args.field_qualify_L2CacheHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2CacheHit_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2CACHEHIT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2CacheHit_get.entry = entry;
	async->args.field_qualify_L2CacheHit_get.data = data;
	async->args.field_qualify_L2CacheHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2DestHit_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2DESTHIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2DestHit.entry = entry;
	async->args.field_qualify_L2DestHit.data = data;
	async->args.field_qualify_L2DestHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2DestHit_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2DESTHIT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2DestHit_get.entry = entry;
	async->args.field_qualify_L2DestHit_get.data = data;
	async->args.field_qualify_L2DestHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2Format_async(
	bcm_field_entry_t entry,
	bcm_field_L2Format_t type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2FORMAT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2Format.entry = entry;
	async->args.field_qualify_L2Format.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2Format_get_async(
	bcm_field_entry_t entry,
	bcm_field_L2Format_t * type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2FORMAT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2Format_get.entry = entry;
	async->args.field_qualify_L2Format_get.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2PayloadFirstEightBytes_async(
	bcm_field_entry_t entry,
	uint32 data1,
	uint32 data2,
	uint32 mask1,
	uint32 mask2,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2PAYLOADFIRSTEIGHTBYTES;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2PayloadFirstEightBytes.entry = entry;
	async->args.field_qualify_L2PayloadFirstEightBytes.data1 = data1;
	async->args.field_qualify_L2PayloadFirstEightBytes.data2 = data2;
	async->args.field_qualify_L2PayloadFirstEightBytes.mask1 = mask1;
	async->args.field_qualify_L2PayloadFirstEightBytes.mask2 = mask2;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2PayloadFirstEightBytes_get_async(
	bcm_field_entry_t entry,
	uint32 * data1,
	uint32 * data2,
	uint32 * mask1,
	uint32 * mask2,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2PAYLOADFIRSTEIGHTBYTES_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2PayloadFirstEightBytes_get.entry = entry;
	async->args.field_qualify_L2PayloadFirstEightBytes_get.data1 = data1;
	async->args.field_qualify_L2PayloadFirstEightBytes_get.data2 = data2;
	async->args.field_qualify_L2PayloadFirstEightBytes_get.mask1 = mask1;
	async->args.field_qualify_L2PayloadFirstEightBytes_get.mask2 = mask2;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2SrcHit_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCHIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2SrcHit.entry = entry;
	async->args.field_qualify_L2SrcHit.data = data;
	async->args.field_qualify_L2SrcHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2SrcHit_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCHIT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2SrcHit_get.entry = entry;
	async->args.field_qualify_L2SrcHit_get.data = data;
	async->args.field_qualify_L2SrcHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2SrcStatic_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCSTATIC;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2SrcStatic.entry = entry;
	async->args.field_qualify_L2SrcStatic.data = data;
	async->args.field_qualify_L2SrcStatic.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2SrcStatic_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCSTATIC_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2SrcStatic_get.entry = entry;
	async->args.field_qualify_L2SrcStatic_get.data = data;
	async->args.field_qualify_L2SrcStatic_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2StationMove_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2STATIONMOVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2StationMove.entry = entry;
	async->args.field_qualify_L2StationMove.data = data;
	async->args.field_qualify_L2StationMove.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L2StationMove_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L2STATIONMOVE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L2StationMove_get.entry = entry;
	async->args.field_qualify_L2StationMove_get.data = data;
	async->args.field_qualify_L2StationMove_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L3DestHostHit_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTHOSTHIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3DestHostHit.entry = entry;
	async->args.field_qualify_L3DestHostHit.data = data;
	async->args.field_qualify_L3DestHostHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L3DestHostHit_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTHOSTHIT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3DestHostHit_get.entry = entry;
	async->args.field_qualify_L3DestHostHit_get.data = data;
	async->args.field_qualify_L3DestHostHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L3DestRouteHit_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTROUTEHIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3DestRouteHit.entry = entry;
	async->args.field_qualify_L3DestRouteHit.data = data;
	async->args.field_qualify_L3DestRouteHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L3DestRouteHit_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTROUTEHIT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3DestRouteHit_get.entry = entry;
	async->args.field_qualify_L3DestRouteHit_get.data = data;
	async->args.field_qualify_L3DestRouteHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L3Ingress_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L3INGRESS;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3Ingress.entry = entry;
	async->args.field_qualify_L3Ingress.data = data;
	async->args.field_qualify_L3Ingress.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L3Ingress_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L3INGRESS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3Ingress_get.entry = entry;
	async->args.field_qualify_L3Ingress_get.data = data;
	async->args.field_qualify_L3Ingress_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L3Routable_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L3ROUTABLE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3Routable.entry = entry;
	async->args.field_qualify_L3Routable.data = data;
	async->args.field_qualify_L3Routable.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L3Routable_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L3ROUTABLE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3Routable_get.entry = entry;
	async->args.field_qualify_L3Routable_get.data = data;
	async->args.field_qualify_L3Routable_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L3SrcHostHit_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L3SRCHOSTHIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3SrcHostHit.entry = entry;
	async->args.field_qualify_L3SrcHostHit.data = data;
	async->args.field_qualify_L3SrcHostHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L3SrcHostHit_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L3SRCHOSTHIT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L3SrcHostHit_get.entry = entry;
	async->args.field_qualify_L3SrcHostHit_get.data = data;
	async->args.field_qualify_L3SrcHostHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L4DstPort_async(
	bcm_field_entry_t entry,
	bcm_l4_port_t data,
	bcm_l4_port_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L4DSTPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4DstPort.entry = entry;
	async->args.field_qualify_L4DstPort.data = data;
	async->args.field_qualify_L4DstPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L4DstPort_get_async(
	bcm_field_entry_t entry,
	bcm_l4_port_t * data,
	bcm_l4_port_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L4DSTPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4DstPort_get.entry = entry;
	async->args.field_qualify_L4DstPort_get.data = data;
	async->args.field_qualify_L4DstPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L4Ports_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L4PORTS;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4Ports.entry = entry;
	async->args.field_qualify_L4Ports.data = data;
	async->args.field_qualify_L4Ports.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L4Ports_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L4PORTS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4Ports_get.entry = entry;
	async->args.field_qualify_L4Ports_get.data = data;
	async->args.field_qualify_L4Ports_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L4SrcPort_async(
	bcm_field_entry_t entry,
	bcm_l4_port_t data,
	bcm_l4_port_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L4SRCPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4SrcPort.entry = entry;
	async->args.field_qualify_L4SrcPort.data = data;
	async->args.field_qualify_L4SrcPort.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_L4SrcPort_get_async(
	bcm_field_entry_t entry,
	bcm_l4_port_t * data,
	bcm_l4_port_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_L4SRCPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_L4SrcPort_get.entry = entry;
	async->args.field_qualify_L4SrcPort_get.data = data;
	async->args.field_qualify_L4SrcPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Llc_async(
	bcm_field_entry_t entry,
	bcm_field_llc_header_t data,
	bcm_field_llc_header_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_LLC;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Llc.entry = entry;
	async->args.field_qualify_Llc.data = data;
	async->args.field_qualify_Llc.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Llc_get_async(
	bcm_field_entry_t entry,
	bcm_field_llc_header_t * data,
	bcm_field_llc_header_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_LLC_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Llc_get.entry = entry;
	async->args.field_qualify_Llc_get.data = data;
	async->args.field_qualify_Llc_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Loopback_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACK;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Loopback.entry = entry;
	async->args.field_qualify_Loopback.data = data;
	async->args.field_qualify_Loopback.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_LoopbackType_async(
	bcm_field_entry_t entry,
	bcm_field_LoopbackType_t loopback_type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKTYPE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopbackType.entry = entry;
	async->args.field_qualify_LoopbackType.loopback_type = loopback_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_LoopbackType_get_async(
	bcm_field_entry_t entry,
	bcm_field_LoopbackType_t * loopback_type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKTYPE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_LoopbackType_get.entry = entry;
	async->args.field_qualify_LoopbackType_get.loopback_type = loopback_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Loopback_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACK_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Loopback_get.entry = entry;
	async->args.field_qualify_Loopback_get.data = data;
	async->args.field_qualify_Loopback_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_MHOpcode_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_MHOPCODE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MHOpcode.entry = entry;
	async->args.field_qualify_MHOpcode.data = data;
	async->args.field_qualify_MHOpcode.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_MHOpcode_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_MHOPCODE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MHOpcode_get.entry = entry;
	async->args.field_qualify_MHOpcode_get.data = data;
	async->args.field_qualify_MHOpcode_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_MirrorCopy_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_MIRRORCOPY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MirrorCopy.entry = entry;
	async->args.field_qualify_MirrorCopy.data = data;
	async->args.field_qualify_MirrorCopy.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_MirrorCopy_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_MIRRORCOPY_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MirrorCopy_get.entry = entry;
	async->args.field_qualify_MirrorCopy_get.data = data;
	async->args.field_qualify_MirrorCopy_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_MplsTerminated_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_MPLSTERMINATED;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsTerminated.entry = entry;
	async->args.field_qualify_MplsTerminated.data = data;
	async->args.field_qualify_MplsTerminated.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_MplsTerminated_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_MPLSTERMINATED_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MplsTerminated_get.entry = entry;
	async->args.field_qualify_MplsTerminated_get.data = data;
	async->args.field_qualify_MplsTerminated_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_MyStationHit_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_MYSTATIONHIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MyStationHit.entry = entry;
	async->args.field_qualify_MyStationHit.data = data;
	async->args.field_qualify_MyStationHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_MyStationHit_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_MYSTATIONHIT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_MyStationHit_get.entry = entry;
	async->args.field_qualify_MyStationHit_get.data = data;
	async->args.field_qualify_MyStationHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OutPort_async(
	bcm_field_entry_t entry,
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OutPort.entry = entry;
	async->args.field_qualify_OutPort.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OutPort_get_async(
	bcm_field_entry_t entry,
	bcm_port_t * data,
	bcm_port_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OutPort_get.entry = entry;
	async->args.field_qualify_OutPort_get.data = data;
	async->args.field_qualify_OutPort_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OutPorts_async(
	bcm_field_entry_t entry,
	bcmx_lplist_t lplist,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTPORTS;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OutPorts.entry = entry;
	async->args.field_qualify_OutPorts.lplist = lplist;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OutPorts_get_async(
	bcm_field_entry_t entry,
	bcm_pbmp_t * data,
	bcm_pbmp_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTPORTS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OutPorts_get.entry = entry;
	async->args.field_qualify_OutPorts_get.data = data;
	async->args.field_qualify_OutPorts_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OuterTpid_async(
	bcm_field_entry_t entry,
	uint16 tpid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTERTPID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterTpid.entry = entry;
	async->args.field_qualify_OuterTpid.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OuterTpid_get_async(
	bcm_field_entry_t entry,
	uint16 * tpid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTERTPID_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterTpid_get.entry = entry;
	async->args.field_qualify_OuterTpid_get.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OuterVlan_async(
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLAN;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlan.entry = entry;
	async->args.field_qualify_OuterVlan.data = data;
	async->args.field_qualify_OuterVlan.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OuterVlanCfi_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANCFI;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanCfi.entry = entry;
	async->args.field_qualify_OuterVlanCfi.data = data;
	async->args.field_qualify_OuterVlanCfi.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OuterVlanCfi_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANCFI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanCfi_get.entry = entry;
	async->args.field_qualify_OuterVlanCfi_get.data = data;
	async->args.field_qualify_OuterVlanCfi_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OuterVlanId_async(
	bcm_field_entry_t entry,
	bcm_vlan_t data,
	bcm_vlan_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanId.entry = entry;
	async->args.field_qualify_OuterVlanId.data = data;
	async->args.field_qualify_OuterVlanId.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OuterVlanId_get_async(
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANID_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanId_get.entry = entry;
	async->args.field_qualify_OuterVlanId_get.data = data;
	async->args.field_qualify_OuterVlanId_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OuterVlanPri_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANPRI;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanPri.entry = entry;
	async->args.field_qualify_OuterVlanPri.data = data;
	async->args.field_qualify_OuterVlanPri.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OuterVlanPri_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANPRI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlanPri_get.entry = entry;
	async->args.field_qualify_OuterVlanPri_get.data = data;
	async->args.field_qualify_OuterVlanPri_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_OuterVlan_get_async(
	bcm_field_entry_t entry,
	bcm_vlan_t * data,
	bcm_vlan_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLAN_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_OuterVlan_get.entry = entry;
	async->args.field_qualify_OuterVlan_get.data = data;
	async->args.field_qualify_OuterVlan_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_PacketRes_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_PACKETRES;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PacketRes.entry = entry;
	async->args.field_qualify_PacketRes.data = data;
	async->args.field_qualify_PacketRes.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_PacketRes_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_PACKETRES_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_PacketRes_get.entry = entry;
	async->args.field_qualify_PacketRes_get.data = data;
	async->args.field_qualify_PacketRes_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_RangeCheck_async(
	bcm_field_entry_t entry,
	int range,
	int result,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_RANGECHECK;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RangeCheck.entry = entry;
	async->args.field_qualify_RangeCheck.range = range;
	async->args.field_qualify_RangeCheck.result = result;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_RangeCheck_get_async(
	bcm_field_entry_t entry,
	int max_count,
	bcm_field_range_t * range,
	int * invert,
	int * count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_RANGECHECK_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_RangeCheck_get.entry = entry;
	async->args.field_qualify_RangeCheck_get.max_count = max_count;
	async->args.field_qualify_RangeCheck_get.range = range;
	async->args.field_qualify_RangeCheck_get.invert = invert;
	async->args.field_qualify_RangeCheck_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Snap_async(
	bcm_field_entry_t entry,
	bcm_field_snap_header_t data,
	bcm_field_snap_header_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SNAP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Snap.entry = entry;
	async->args.field_qualify_Snap.data = data;
	async->args.field_qualify_Snap.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Snap_get_async(
	bcm_field_entry_t entry,
	bcm_field_snap_header_t * data,
	bcm_field_snap_header_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SNAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Snap_get.entry = entry;
	async->args.field_qualify_Snap_get.data = data;
	async->args.field_qualify_Snap_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcClassField_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSFIELD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcClassField.entry = entry;
	async->args.field_qualify_SrcClassField.data = data;
	async->args.field_qualify_SrcClassField.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcClassField_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSFIELD_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcClassField_get.entry = entry;
	async->args.field_qualify_SrcClassField_get.data = data;
	async->args.field_qualify_SrcClassField_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcClassL2_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSL2;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcClassL2.entry = entry;
	async->args.field_qualify_SrcClassL2.data = data;
	async->args.field_qualify_SrcClassL2.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcClassL2_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSL2_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcClassL2_get.entry = entry;
	async->args.field_qualify_SrcClassL2_get.data = data;
	async->args.field_qualify_SrcClassL2_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcClassL3_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSL3;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcClassL3.entry = entry;
	async->args.field_qualify_SrcClassL3.data = data;
	async->args.field_qualify_SrcClassL3.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcClassL3_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSL3_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcClassL3_get.entry = entry;
	async->args.field_qualify_SrcClassL3_get.data = data;
	async->args.field_qualify_SrcClassL3_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcIp_async(
	bcm_field_entry_t entry,
	bcm_ip_t data,
	bcm_ip_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp.entry = entry;
	async->args.field_qualify_SrcIp.data = data;
	async->args.field_qualify_SrcIp.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcIp6_async(
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6.entry = entry;
	async->args.field_qualify_SrcIp6.data = (uint8 *)data;
	async->args.field_qualify_SrcIp6.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcIp6High_async(
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6HIGH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6High.entry = entry;
	async->args.field_qualify_SrcIp6High.data = (uint8 *)data;
	async->args.field_qualify_SrcIp6High.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcIp6High_get_async(
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6HIGH_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6High_get.entry = entry;
	async->args.field_qualify_SrcIp6High_get.data = data;
	async->args.field_qualify_SrcIp6High_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcIp6Low_async(
	bcm_field_entry_t entry,
	bcm_ip6_t data,
	bcm_ip6_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6LOW;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6Low.entry = entry;
	async->args.field_qualify_SrcIp6Low.data = (uint8 *)data;
	async->args.field_qualify_SrcIp6Low.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcIp6Low_get_async(
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6LOW_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6Low_get.entry = entry;
	async->args.field_qualify_SrcIp6Low_get.data = data;
	async->args.field_qualify_SrcIp6Low_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcIp6_get_async(
	bcm_field_entry_t entry,
	bcm_ip6_t * data,
	bcm_ip6_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp6_get.entry = entry;
	async->args.field_qualify_SrcIp6_get.data = data;
	async->args.field_qualify_SrcIp6_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcIp_get_async(
	bcm_field_entry_t entry,
	bcm_ip_t * data,
	bcm_ip_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcIp_get.entry = entry;
	async->args.field_qualify_SrcIp_get.data = data;
	async->args.field_qualify_SrcIp_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcMac_async(
	bcm_field_entry_t entry,
	bcm_mac_t data,
	bcm_mac_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCMAC;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMac.entry = entry;
	async->args.field_qualify_SrcMac.data = (uint8 *)data;
	async->args.field_qualify_SrcMac.mask = (uint8 *)mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcMac_get_async(
	bcm_field_entry_t entry,
	bcm_mac_t * data,
	bcm_mac_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCMAC_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMac_get.entry = entry;
	async->args.field_qualify_SrcMac_get.data = data;
	async->args.field_qualify_SrcMac_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcMimGport_async(
	bcm_field_entry_t entry,
	bcm_gport_t mim_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCMIMGPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMimGport.entry = entry;
	async->args.field_qualify_SrcMimGport.mim_port_id = mim_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcMimGport_get_async(
	bcm_field_entry_t entry,
	bcm_gport_t * mim_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCMIMGPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMimGport_get.entry = entry;
	async->args.field_qualify_SrcMimGport_get.mim_port_id = mim_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcModPortGport_async(
	bcm_field_entry_t entry,
	bcm_gport_t data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODPORTGPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcModPortGport.entry = entry;
	async->args.field_qualify_SrcModPortGport.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcModPortGport_get_async(
	bcm_field_entry_t entry,
	bcm_gport_t * data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODPORTGPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcModPortGport_get.entry = entry;
	async->args.field_qualify_SrcModPortGport_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcModuleGport_async(
	bcm_field_entry_t entry,
	bcm_gport_t data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODULEGPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcModuleGport.entry = entry;
	async->args.field_qualify_SrcModuleGport.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcModuleGport_get_async(
	bcm_field_entry_t entry,
	bcm_gport_t * data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODULEGPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcModuleGport_get.entry = entry;
	async->args.field_qualify_SrcModuleGport_get.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcMplsGport_async(
	bcm_field_entry_t entry,
	bcm_gport_t mpls_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCMPLSGPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMplsGport.entry = entry;
	async->args.field_qualify_SrcMplsGport.mpls_port_id = mpls_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcMplsGport_get_async(
	bcm_field_entry_t entry,
	bcm_gport_t * mpls_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCMPLSGPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcMplsGport_get.entry = entry;
	async->args.field_qualify_SrcMplsGport_get.mpls_port_id = mpls_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcPort_async(
	bcm_field_entry_t entry,
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPort.entry = entry;
	async->args.field_qualify_SrcPort.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcPort_get_async(
	bcm_field_entry_t entry,
	bcm_module_t * data_modid,
	bcm_module_t * mask_modid,
	bcm_port_t * data_port,
	bcm_port_t * mask_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcPort_get.entry = entry;
	async->args.field_qualify_SrcPort_get.data_modid = data_modid;
	async->args.field_qualify_SrcPort_get.mask_modid = mask_modid;
	async->args.field_qualify_SrcPort_get.data_port = data_port;
	async->args.field_qualify_SrcPort_get.mask_port = mask_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcTrunk_async(
	bcm_field_entry_t entry,
	bcm_trunk_t tid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCTRUNK;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcTrunk.entry = entry;
	async->args.field_qualify_SrcTrunk.tid = tid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcTrunk_get_async(
	bcm_field_entry_t entry,
	bcm_trunk_t * data,
	bcm_trunk_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCTRUNK_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcTrunk_get.entry = entry;
	async->args.field_qualify_SrcTrunk_get.data = data;
	async->args.field_qualify_SrcTrunk_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcVirtualPortValid_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCVIRTUALPORTVALID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcVirtualPortValid.entry = entry;
	async->args.field_qualify_SrcVirtualPortValid.data = data;
	async->args.field_qualify_SrcVirtualPortValid.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcVirtualPortValid_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCVIRTUALPORTVALID_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcVirtualPortValid_get.entry = entry;
	async->args.field_qualify_SrcVirtualPortValid_get.data = data;
	async->args.field_qualify_SrcVirtualPortValid_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcWlanGport_async(
	bcm_field_entry_t entry,
	bcm_gport_t wlan_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCWLANGPORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcWlanGport.entry = entry;
	async->args.field_qualify_SrcWlanGport.wlan_port_id = wlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_SrcWlanGport_get_async(
	bcm_field_entry_t entry,
	bcm_gport_t * wlan_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_SRCWLANGPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_SrcWlanGport_get.entry = entry;
	async->args.field_qualify_SrcWlanGport_get.wlan_port_id = wlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_TcpControl_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TCPCONTROL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpControl.entry = entry;
	async->args.field_qualify_TcpControl.data = data;
	async->args.field_qualify_TcpControl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_TcpControl_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TCPCONTROL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpControl_get.entry = entry;
	async->args.field_qualify_TcpControl_get.data = data;
	async->args.field_qualify_TcpControl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_TcpHeaderSize_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TCPHEADERSIZE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpHeaderSize.entry = entry;
	async->args.field_qualify_TcpHeaderSize.data = data;
	async->args.field_qualify_TcpHeaderSize.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_TcpHeaderSize_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TCPHEADERSIZE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpHeaderSize_get.entry = entry;
	async->args.field_qualify_TcpHeaderSize_get.data = data;
	async->args.field_qualify_TcpHeaderSize_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_TcpSequenceZero_async(
	bcm_field_entry_t entry,
	uint32 flag,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TCPSEQUENCEZERO;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpSequenceZero.entry = entry;
	async->args.field_qualify_TcpSequenceZero.flag = flag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_TcpSequenceZero_get_async(
	bcm_field_entry_t entry,
	uint32 * flag,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TCPSEQUENCEZERO_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TcpSequenceZero_get.entry = entry;
	async->args.field_qualify_TcpSequenceZero_get.flag = flag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Tos_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TOS;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Tos.entry = entry;
	async->args.field_qualify_Tos.data = data;
	async->args.field_qualify_Tos.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Tos_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TOS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Tos_get.entry = entry;
	async->args.field_qualify_Tos_get.data = data;
	async->args.field_qualify_Tos_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_TranslatedVlanFormat_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDVLANFORMAT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedVlanFormat.entry = entry;
	async->args.field_qualify_TranslatedVlanFormat.data = data;
	async->args.field_qualify_TranslatedVlanFormat.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_TranslatedVlanFormat_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDVLANFORMAT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TranslatedVlanFormat_get.entry = entry;
	async->args.field_qualify_TranslatedVlanFormat_get.data = data;
	async->args.field_qualify_TranslatedVlanFormat_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Ttl_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TTL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ttl.entry = entry;
	async->args.field_qualify_Ttl.data = data;
	async->args.field_qualify_Ttl.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Ttl_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TTL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Ttl_get.entry = entry;
	async->args.field_qualify_Ttl_get.data = data;
	async->args.field_qualify_Ttl_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_TunnelTerminated_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTERMINATED;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelTerminated.entry = entry;
	async->args.field_qualify_TunnelTerminated.data = data;
	async->args.field_qualify_TunnelTerminated.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_TunnelTerminated_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTERMINATED_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelTerminated_get.entry = entry;
	async->args.field_qualify_TunnelTerminated_get.data = data;
	async->args.field_qualify_TunnelTerminated_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_TunnelType_async(
	bcm_field_entry_t entry,
	bcm_field_TunnelType_t tunnel_type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTYPE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelType.entry = entry;
	async->args.field_qualify_TunnelType.tunnel_type = tunnel_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_TunnelType_get_async(
	bcm_field_entry_t entry,
	bcm_field_TunnelType_t * tunnel_type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTYPE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_TunnelType_get.entry = entry;
	async->args.field_qualify_TunnelType_get.tunnel_type = tunnel_type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_VlanFormat_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_VLANFORMAT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanFormat.entry = entry;
	async->args.field_qualify_VlanFormat.data = data;
	async->args.field_qualify_VlanFormat.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_VlanFormat_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_VLANFORMAT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanFormat_get.entry = entry;
	async->args.field_qualify_VlanFormat_get.data = data;
	async->args.field_qualify_VlanFormat_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_VlanTranslationHit_async(
	bcm_field_entry_t entry,
	uint8 data,
	uint8 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_VLANTRANSLATIONHIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanTranslationHit.entry = entry;
	async->args.field_qualify_VlanTranslationHit.data = data;
	async->args.field_qualify_VlanTranslationHit.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_VlanTranslationHit_get_async(
	bcm_field_entry_t entry,
	uint8 * data,
	uint8 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_VLANTRANSLATIONHIT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VlanTranslationHit_get.entry = entry;
	async->args.field_qualify_VlanTranslationHit_get.data = data;
	async->args.field_qualify_VlanTranslationHit_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_VnTag_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_VNTAG;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VnTag.entry = entry;
	async->args.field_qualify_VnTag.data = data;
	async->args.field_qualify_VnTag.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_VnTag_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_VNTAG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_VnTag_get.entry = entry;
	async->args.field_qualify_VnTag_get.data = data;
	async->args.field_qualify_VnTag_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Vpn_async(
	bcm_field_entry_t entry,
	bcm_vpn_t data,
	bcm_vpn_t mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_VPN;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Vpn.entry = entry;
	async->args.field_qualify_Vpn.data = data;
	async->args.field_qualify_Vpn.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Vpn_get_async(
	bcm_field_entry_t entry,
	bcm_vpn_t * data,
	bcm_vpn_t * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_VPN_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Vpn_get.entry = entry;
	async->args.field_qualify_Vpn_get.data = data;
	async->args.field_qualify_Vpn_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Vrf_async(
	bcm_field_entry_t entry,
	uint32 data,
	uint32 mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_VRF;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Vrf.entry = entry;
	async->args.field_qualify_Vrf.data = data;
	async->args.field_qualify_Vrf.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_Vrf_get_async(
	bcm_field_entry_t entry,
	uint32 * data,
	uint32 * mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_VRF_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_Vrf_get.entry = entry;
	async->args.field_qualify_Vrf_get.data = data;
	async->args.field_qualify_Vrf_get.mask = mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_clear_async(
	bcm_field_entry_t entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_CLEAR;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_clear.entry = entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_qualify_data_async(
	bcm_field_entry_t eid,
	int qual_id,
	uint8 * data,
	uint8 * mask,
	uint16 length,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_QUALIFY_DATA;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_qualify_data.eid = eid;
	async->args.field_qualify_data.qual_id = qual_id;
	async->args.field_qualify_data.data = data;
	async->args.field_qualify_data.mask = mask;
	async->args.field_qualify_data.length = length;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_range_create_async(
	bcm_field_range_t * range,
	uint32 flags,
	bcm_l4_port_t min,
	bcm_l4_port_t max,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_RANGE_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_create.range = range;
	async->args.field_range_create.flags = flags;
	async->args.field_range_create.min = min;
	async->args.field_range_create.max = max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_range_create_id_async(
	bcm_field_range_t range,
	uint32 flags,
	bcm_l4_port_t min,
	bcm_l4_port_t max,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_RANGE_CREATE_ID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_create_id.range = range;
	async->args.field_range_create_id.flags = flags;
	async->args.field_range_create_id.min = min;
	async->args.field_range_create_id.max = max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_range_destroy_async(
	bcm_field_range_t range,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_RANGE_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_destroy.range = range;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_range_get_async(
	bcm_field_range_t range,
	uint32 * flags,
	bcm_l4_port_t * min,
	bcm_l4_port_t * max,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_RANGE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_get.range = range;
	async->args.field_range_get.flags = flags;
	async->args.field_range_get.min = min;
	async->args.field_range_get.max = max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_range_group_create_async(
	bcm_field_range_t * range,
	uint32 flags,
	bcm_l4_port_t min,
	bcm_l4_port_t max,
	bcm_if_group_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_RANGE_GROUP_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_group_create.range = range;
	async->args.field_range_group_create.flags = flags;
	async->args.field_range_group_create.min = min;
	async->args.field_range_group_create.max = max;
	async->args.field_range_group_create.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_range_group_create_id_async(
	bcm_field_range_t range,
	uint32 flags,
	bcm_l4_port_t min,
	bcm_l4_port_t max,
	bcm_if_group_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_RANGE_GROUP_CREATE_ID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_range_group_create_id.range = range;
	async->args.field_range_group_create_id.flags = flags;
	async->args.field_range_group_create_id.min = min;
	async->args.field_range_group_create_id.max = max;
	async->args.field_range_group_create_id.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_resync_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_RESYNC;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_stat_all_set_async(
	int stat_id,
	uint64 value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_STAT_ALL_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_all_set.stat_id = stat_id;
	async->args.field_stat_all_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_stat_all_set32_async(
	int stat_id,
	uint32 value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_STAT_ALL_SET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_all_set32.stat_id = stat_id;
	async->args.field_stat_all_set32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_stat_config_get_async(
	int stat_id,
	int nstat,
	bcm_field_stat_t * stat_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_STAT_CONFIG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_config_get.stat_id = stat_id;
	async->args.field_stat_config_get.nstat = nstat;
	async->args.field_stat_config_get.stat_arr = stat_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_stat_create_async(
	bcm_field_group_t group,
	int nstat,
	bcm_field_stat_t * stat_arr,
	int * stat_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_STAT_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_create.group = group;
	async->args.field_stat_create.nstat = nstat;
	async->args.field_stat_create.stat_arr = stat_arr;
	async->args.field_stat_create.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_stat_create_id_async(
	bcm_field_group_t group,
	int nstat,
	bcm_field_stat_t * stat_arr,
	int stat_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_STAT_CREATE_ID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_create_id.group = group;
	async->args.field_stat_create_id.nstat = nstat;
	async->args.field_stat_create_id.stat_arr = stat_arr;
	async->args.field_stat_create_id.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_stat_destroy_async(
	int stat_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_STAT_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_destroy.stat_id = stat_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_stat_get_async(
	int stat_id,
	bcm_field_stat_t stat,
	uint64 * value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_STAT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_get.stat_id = stat_id;
	async->args.field_stat_get.stat = stat;
	async->args.field_stat_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_stat_get32_async(
	int stat_id,
	bcm_field_stat_t stat,
	uint32 * value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_STAT_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_get32.stat_id = stat_id;
	async->args.field_stat_get32.stat = stat;
	async->args.field_stat_get32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_stat_multi_get_async(
	int stat_id,
	int nstat,
	bcm_field_stat_t * stat_arr,
	uint64 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_STAT_MULTI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_multi_get.stat_id = stat_id;
	async->args.field_stat_multi_get.nstat = nstat;
	async->args.field_stat_multi_get.stat_arr = stat_arr;
	async->args.field_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_stat_multi_get32_async(
	int stat_id,
	int nstat,
	bcm_field_stat_t * stat_arr,
	uint32 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_STAT_MULTI_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_multi_get32.stat_id = stat_id;
	async->args.field_stat_multi_get32.nstat = nstat;
	async->args.field_stat_multi_get32.stat_arr = stat_arr;
	async->args.field_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_stat_set_async(
	int stat_id,
	bcm_field_stat_t stat,
	uint64 value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_STAT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_set.stat_id = stat_id;
	async->args.field_stat_set.stat = stat;
	async->args.field_stat_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_stat_set32_async(
	int stat_id,
	bcm_field_stat_t stat,
	uint32 value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_STAT_SET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_set32.stat_id = stat_id;
	async->args.field_stat_set32.stat = stat;
	async->args.field_stat_set32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_field_stat_size_async(
	int stat_id,
	int * stat_size,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_FIELD_STAT_SIZE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.field_stat_size.stat_id = stat_id;
	async->args.field_stat_size.stat_size = stat_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_config_get_async(
	bcm_ipfix_stage_t stage,
	bcmx_lport_t port,
	bcmx_ipfix_config_t * config,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_CONFIG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_config_get.stage = stage;
	async->args.ipfix_config_get.port = port;
	async->args.ipfix_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_config_set_async(
	bcm_ipfix_stage_t stage,
	bcmx_lport_t port,
	bcmx_ipfix_config_t * config,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_CONFIG_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_config_set.stage = stage;
	async->args.ipfix_config_set.port = port;
	async->args.ipfix_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_mirror_config_get_async(
	bcm_ipfix_stage_t stage,
	bcm_gport_t port,
	bcmx_ipfix_mirror_config_t * config,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_MIRROR_CONFIG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_mirror_config_get.stage = stage;
	async->args.ipfix_mirror_config_get.port = port;
	async->args.ipfix_mirror_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_mirror_config_set_async(
	bcm_ipfix_stage_t stage,
	bcm_gport_t port,
	bcmx_ipfix_mirror_config_t * config,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_MIRROR_CONFIG_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_mirror_config_set.stage = stage;
	async->args.ipfix_mirror_config_set.port = port;
	async->args.ipfix_mirror_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_mirror_port_dest_add_async(
	bcm_ipfix_stage_t stage,
	bcm_gport_t port,
	bcm_gport_t mirror_dest_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_MIRROR_PORT_DEST_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_mirror_port_dest_add.stage = stage;
	async->args.ipfix_mirror_port_dest_add.port = port;
	async->args.ipfix_mirror_port_dest_add.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_mirror_port_dest_delete_async(
	bcm_ipfix_stage_t stage,
	bcm_gport_t port,
	bcm_gport_t mirror_dest_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_MIRROR_PORT_DEST_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_mirror_port_dest_delete.stage = stage;
	async->args.ipfix_mirror_port_dest_delete.port = port;
	async->args.ipfix_mirror_port_dest_delete.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_mirror_port_dest_delete_all_async(
	bcm_ipfix_stage_t stage,
	bcm_gport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_MIRROR_PORT_DEST_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_mirror_port_dest_delete_all.stage = stage;
	async->args.ipfix_mirror_port_dest_delete_all.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_mirror_port_dest_get_async(
	bcm_ipfix_stage_t stage,
	bcm_gport_t port,
	int mirror_dest_size,
	bcm_gport_t * mirror_dest_id,
	int * mirror_dest_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_MIRROR_PORT_DEST_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_mirror_port_dest_get.stage = stage;
	async->args.ipfix_mirror_port_dest_get.port = port;
	async->args.ipfix_mirror_port_dest_get.mirror_dest_size = mirror_dest_size;
	async->args.ipfix_mirror_port_dest_get.mirror_dest_id = mirror_dest_id;
	async->args.ipfix_mirror_port_dest_get.mirror_dest_count = mirror_dest_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_rate_create_async(
	bcmx_ipfix_rate_t * rate_info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_RATE_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_create.rate_info = rate_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_rate_destroy_async(
	bcm_ipfix_rate_id_t rate_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_RATE_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_destroy.rate_id = rate_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_rate_destroy_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_RATE_DESTROY_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_rate_get_async(
	bcmx_ipfix_rate_t * rate_info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_RATE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_get.rate_info = rate_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_rate_mirror_add_async(
	bcm_ipfix_rate_id_t rate_id,
	bcm_gport_t mirror_dest_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_RATE_MIRROR_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_mirror_add.rate_id = rate_id;
	async->args.ipfix_rate_mirror_add.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_rate_mirror_delete_async(
	bcm_ipfix_rate_id_t rate_id,
	bcm_gport_t mirror_dest_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_RATE_MIRROR_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_mirror_delete.rate_id = rate_id;
	async->args.ipfix_rate_mirror_delete.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_rate_mirror_delete_all_async(
	bcm_ipfix_rate_id_t rate_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_RATE_MIRROR_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_mirror_delete_all.rate_id = rate_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipfix_rate_mirror_get_async(
	bcm_ipfix_rate_id_t rate_id,
	int mirror_dest_size,
	bcm_gport_t * mirror_dest_id,
	int * mirror_dest_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPFIX_RATE_MIRROR_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipfix_rate_mirror_get.rate_id = rate_id;
	async->args.ipfix_rate_mirror_get.mirror_dest_size = mirror_dest_size;
	async->args.ipfix_rate_mirror_get.mirror_dest_id = mirror_dest_id;
	async->args.ipfix_rate_mirror_get.mirror_dest_count = mirror_dest_count;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcmx_ipmc_add_async(
	bcmx_ipmc_addr_t * data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPMC_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_add.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipmc_age_async(
	uint32 flags,
	bcm_ipmc_traverse_cb age_cb,
	void * user_data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPMC_AGE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_age.flags = flags;
	async->args.ipmc_age.age_cb = age_cb;
	async->args.ipmc_age.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipmc_counters_get_async(
	bcmx_lport_t port,
	bcm_ipmc_counters_t * counters,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPMC_COUNTERS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_counters_get.port = port;
	async->args.ipmc_counters_get.counters = counters;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipmc_detach_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPMC_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipmc_egress_port_get_async(
	bcmx_lport_t port,
	bcm_mac_t mac,
	int * untag,
	bcm_vlan_t * vid,
	int * ttl_threshold,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPMC_EGRESS_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_egress_port_get.port = port;
	async->args.ipmc_egress_port_get.mac = (uint8 *)mac;
	async->args.ipmc_egress_port_get.untag = untag;
	async->args.ipmc_egress_port_get.vid = vid;
	async->args.ipmc_egress_port_get.ttl_threshold = ttl_threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipmc_egress_port_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPMC_EGRESS_PORT_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipmc_egress_port_set_async(
	bcmx_lport_t port,
	const bcm_mac_t mac,
	int untag,
	bcm_vlan_t vid,
	int ttl_threshold,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPMC_EGRESS_PORT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_egress_port_set.port = port;
	async->args.ipmc_egress_port_set.mac = (uint8 *)mac;
	async->args.ipmc_egress_port_set.untag = untag;
	async->args.ipmc_egress_port_set.vid = vid;
	async->args.ipmc_egress_port_set.ttl_threshold = ttl_threshold;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipmc_enable_async(
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPMC_ENABLE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_enable.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipmc_find_async(
	bcmx_ipmc_addr_t * data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPMC_FIND;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_find.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipmc_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPMC_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipmc_remove_async(
	bcmx_ipmc_addr_t * data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPMC_REMOVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_remove.data = data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipmc_remove_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPMC_REMOVE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_ipmc_traverse_async(
	uint32 flags,
	bcm_ipmc_traverse_cb cb,
	void * user_data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_IPMC_TRAVERSE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.ipmc_traverse.flags = flags;
	async->args.ipmc_traverse.cb = cb;
	async->args.ipmc_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcmx_l2_addr_add_async(
	bcmx_l2_addr_t * l2addr,
	bcmx_lplist_t * port_block,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_add.l2addr = l2addr;
	async->args.l2_addr_add.port_block = port_block;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_delete_async(
	bcm_mac_t mac,
	bcm_vlan_t vid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete.mac = (uint8 *)mac;
	async->args.l2_addr_delete.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_delete_by_mac_async(
	bcm_mac_t mac,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_DELETE_BY_MAC;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_mac.mac = (uint8 *)mac;
	async->args.l2_addr_delete_by_mac.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_delete_by_mac_port_async(
	bcm_mac_t mac,
	bcmx_lport_t port,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_DELETE_BY_MAC_PORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_mac_port.mac = (uint8 *)mac;
	async->args.l2_addr_delete_by_mac_port.port = port;
	async->args.l2_addr_delete_by_mac_port.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_delete_by_port_async(
	bcmx_lport_t port,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_DELETE_BY_PORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_port.port = port;
	async->args.l2_addr_delete_by_port.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_delete_by_trunk_async(
	bcm_trunk_t tid,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_DELETE_BY_TRUNK;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_trunk.tid = tid;
	async->args.l2_addr_delete_by_trunk.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_delete_by_vlan_async(
	bcm_vlan_t vid,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_DELETE_BY_VLAN;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_vlan.vid = vid;
	async->args.l2_addr_delete_by_vlan.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_delete_by_vlan_port_async(
	bcm_vlan_t vid,
	bcmx_lport_t port,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_DELETE_BY_VLAN_PORT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_vlan_port.vid = vid;
	async->args.l2_addr_delete_by_vlan_port.port = port;
	async->args.l2_addr_delete_by_vlan_port.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_delete_by_vlan_trunk_async(
	bcm_vlan_t vid,
	bcm_trunk_t tid,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_DELETE_BY_VLAN_TRUNK;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_delete_by_vlan_trunk.vid = vid;
	async->args.l2_addr_delete_by_vlan_trunk.tid = tid;
	async->args.l2_addr_delete_by_vlan_trunk.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_freeze_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_FREEZE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_from_bcm_async(
	bcmx_l2_addr_t * dest,
	bcmx_lplist_t * port_block,
	bcm_l2_addr_t * source,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_FROM_BCM;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_from_bcm.dest = dest;
	async->args.l2_addr_from_bcm.port_block = port_block;
	async->args.l2_addr_from_bcm.source = source;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_get_async(
	bcm_mac_t mac_addr,
	bcm_vlan_t vid,
	bcmx_l2_addr_t * l2addr,
	bcmx_lplist_t * port_block,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_get.mac_addr = (uint8 *)mac_addr;
	async->args.l2_addr_get.vid = vid;
	async->args.l2_addr_get.l2addr = l2addr;
	async->args.l2_addr_get.port_block = port_block;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_native_get_async(
	bcm_mac_t mac_addr,
	bcm_vlan_t vid,
	bcmx_l2_addr_t * l2addr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_NATIVE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_native_get.mac_addr = (uint8 *)mac_addr;
	async->args.l2_addr_native_get.vid = vid;
	async->args.l2_addr_native_get.l2addr = l2addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_port_get_async(
	bcmx_lport_t port,
	bcm_mac_t mac_addr,
	bcm_vlan_t vid,
	bcmx_l2_addr_t * l2addr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_port_get.port = port;
	async->args.l2_addr_port_get.mac_addr = (uint8 *)mac_addr;
	async->args.l2_addr_port_get.vid = vid;
	async->args.l2_addr_port_get.l2addr = l2addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_refresh_async(
	bcmx_l2_addr_t * l2addr,
	bcmx_lplist_t * port_block,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_REFRESH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_refresh.l2addr = l2addr;
	async->args.l2_addr_refresh.port_block = port_block;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_thaw_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_THAW;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_addr_to_bcm_async(
	int bcm_unit,
	bcm_l2_addr_t * dest,
	bcmx_l2_addr_t * source,
	bcmx_lplist_t * port_block,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_ADDR_TO_BCM;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_addr_to_bcm.bcm_unit = bcm_unit;
	async->args.l2_addr_to_bcm.dest = dest;
	async->args.l2_addr_to_bcm.source = source;
	async->args.l2_addr_to_bcm.port_block = port_block;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_age_timer_get_async(
	int * age_seconds,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_AGE_TIMER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_age_timer_get.age_seconds = age_seconds;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_age_timer_set_async(
	int age_seconds,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_AGE_TIMER_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_age_timer_set.age_seconds = age_seconds;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_cache_delete_async(
	int index,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_CACHE_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_delete.index = index;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_cache_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_CACHE_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_cache_get_async(
	int index,
	bcmx_l2_cache_addr_t * addr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_CACHE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_get.index = index;
	async->args.l2_cache_get.addr = addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_cache_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_CACHE_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_cache_set_async(
	int index,
	bcmx_l2_cache_addr_t * addr,
	int * index_used,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_CACHE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_set.index = index;
	async->args.l2_cache_set.addr = addr;
	async->args.l2_cache_set.index_used = index_used;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_cache_size_get_async(
	int * size,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_CACHE_SIZE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_cache_size_get.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_conflict_get_async(
	bcmx_l2_addr_t * addr,
	bcmx_l2_addr_t * cf_array,
	int cf_max,
	int * cf_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_CONFLICT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_conflict_get.addr = addr;
	async->args.l2_conflict_get.cf_array = cf_array;
	async->args.l2_conflict_get.cf_max = cf_max;
	async->args.l2_conflict_get.cf_count = cf_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_device_add_async(
	int bcm_unit,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_DEVICE_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_device_add.bcm_unit = bcm_unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_device_remove_async(
	int bcm_unit,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_DEVICE_REMOVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_device_remove.bcm_unit = bcm_unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_learn_class_get_async(
	int lclass,
	int * lclass_prio,
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_LEARN_CLASS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_class_get.lclass = lclass;
	async->args.l2_learn_class_get.lclass_prio = lclass_prio;
	async->args.l2_learn_class_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_learn_class_set_async(
	int lclass,
	int lclass_prio,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_LEARN_CLASS_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_class_set.lclass = lclass;
	async->args.l2_learn_class_set.lclass_prio = lclass_prio;
	async->args.l2_learn_class_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_learn_limit_get_async(
	bcmx_l2_learn_limit_t * limit,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_LEARN_LIMIT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_limit_get.limit = limit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_learn_limit_set_async(
	bcmx_l2_learn_limit_t * limit,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_LEARN_LIMIT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_limit_set.limit = limit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_learn_port_class_get_async(
	bcmx_lport_t port,
	int * lclass,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_LEARN_PORT_CLASS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_port_class_get.port = port;
	async->args.l2_learn_port_class_get.lclass = lclass;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_learn_port_class_set_async(
	bcmx_lport_t port,
	int lclass,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_LEARN_PORT_CLASS_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_learn_port_class_set.port = port;
	async->args.l2_learn_port_class_set.lclass = lclass;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_notify_register_async(
	bcmx_l2_notify_f callback,
	void * userdata,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_NOTIFY_REGISTER;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_notify_register.callback = callback;
	async->args.l2_notify_register.userdata = userdata;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_notify_start_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_NOTIFY_START;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_notify_stop_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_NOTIFY_STOP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_notify_unregister_async(
	bcmx_l2_notify_f callback,
	void * userdata,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_NOTIFY_UNREGISTER;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_notify_unregister.callback = callback;
	async->args.l2_notify_unregister.userdata = userdata;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_replace_async(
	uint32 flags,
	bcmx_l2_addr_t * match_addr,
	bcmx_lport_t new_port,
	bcm_trunk_t new_trunk,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_REPLACE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_replace.flags = flags;
	async->args.l2_replace.match_addr = match_addr;
	async->args.l2_replace.new_port = new_port;
	async->args.l2_replace.new_trunk = new_trunk;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_tunnel_add_async(
	bcm_mac_t mac,
	bcm_vlan_t vlan,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_TUNNEL_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_tunnel_add.mac = (uint8 *)mac;
	async->args.l2_tunnel_add.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_tunnel_delete_async(
	bcm_mac_t mac,
	bcm_vlan_t vlan,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_TUNNEL_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l2_tunnel_delete.mac = (uint8 *)mac;
	async->args.l2_tunnel_delete.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l2_tunnel_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L2_TUNNEL_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcmx_l3_cleanup_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_CLEANUP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_egress_create_async(
	uint32 flags,
	bcmx_l3_egress_t * egr,
	bcm_if_t * intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_EGRESS_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_create.flags = flags;
	async->args.l3_egress_create.egr = egr;
	async->args.l3_egress_create.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_egress_destroy_async(
	bcm_if_t intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_EGRESS_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_destroy.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_egress_find_async(
	bcmx_l3_egress_t * egr,
	bcm_if_t * intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_EGRESS_FIND;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_find.egr = egr;
	async->args.l3_egress_find.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_egress_get_async(
	bcm_if_t intf,
	bcmx_l3_egress_t * egr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_EGRESS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_get.intf = intf;
	async->args.l3_egress_get.egr = egr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_egress_multipath_add_async(
	bcm_if_t mpintf,
	bcm_if_t intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_add.mpintf = mpintf;
	async->args.l3_egress_multipath_add.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_egress_multipath_create_async(
	uint32 flags,
	int intf_count,
	bcm_if_t * intf_array,
	bcm_if_t * mpintf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_create.flags = flags;
	async->args.l3_egress_multipath_create.intf_count = intf_count;
	async->args.l3_egress_multipath_create.intf_array = intf_array;
	async->args.l3_egress_multipath_create.mpintf = mpintf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_egress_multipath_delete_async(
	bcm_if_t mpintf,
	bcm_if_t intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_delete.mpintf = mpintf;
	async->args.l3_egress_multipath_delete.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_egress_multipath_destroy_async(
	bcm_if_t mpintf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_destroy.mpintf = mpintf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_egress_multipath_find_async(
	int intf_count,
	bcm_if_t * intf_array,
	bcm_if_t * mpintf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_FIND;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_find.intf_count = intf_count;
	async->args.l3_egress_multipath_find.intf_array = intf_array;
	async->args.l3_egress_multipath_find.mpintf = mpintf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_egress_multipath_get_async(
	bcm_if_t mpintf,
	int intf_size,
	bcm_if_t * intf_array,
	int * intf_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_get.mpintf = mpintf;
	async->args.l3_egress_multipath_get.intf_size = intf_size;
	async->args.l3_egress_multipath_get.intf_array = intf_array;
	async->args.l3_egress_multipath_get.intf_count = intf_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_egress_multipath_max_create_async(
	uint32 flags,
	int max_paths,
	int intf_count,
	bcm_if_t * intf_array,
	bcm_if_t * mpintf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_MAX_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_max_create.flags = flags;
	async->args.l3_egress_multipath_max_create.max_paths = max_paths;
	async->args.l3_egress_multipath_max_create.intf_count = intf_count;
	async->args.l3_egress_multipath_max_create.intf_array = intf_array;
	async->args.l3_egress_multipath_max_create.mpintf = mpintf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_egress_multipath_traverse_async(
	bcm_l3_egress_multipath_traverse_cb trav_fn,
	void * user_data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_TRAVERSE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_multipath_traverse.trav_fn = trav_fn;
	async->args.l3_egress_multipath_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_egress_traverse_async(
	bcm_l3_egress_traverse_cb trav_fn,
	void * user_data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_EGRESS_TRAVERSE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_egress_traverse.trav_fn = trav_fn;
	async->args.l3_egress_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_enable_set_async(
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_ENABLE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_host_add_async(
	bcmx_l3_host_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_HOST_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_host_age_async(
	uint32 flags,
	bcm_l3_host_traverse_cb age_cb,
	void * user_data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_HOST_AGE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_age.flags = flags;
	async->args.l3_host_age.age_cb = age_cb;
	async->args.l3_host_age.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_host_conflict_get_async(
	bcm_l3_key_t * ipkey,
	bcm_l3_key_t * cf_array,
	int cf_max,
	int * cf_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_HOST_CONFLICT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_conflict_get.ipkey = ipkey;
	async->args.l3_host_conflict_get.cf_array = cf_array;
	async->args.l3_host_conflict_get.cf_max = cf_max;
	async->args.l3_host_conflict_get.cf_count = cf_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_host_delete_async(
	bcmx_l3_host_t * ip_addr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_HOST_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_delete.ip_addr = ip_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_host_delete_all_async(
	bcmx_l3_host_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_HOST_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_delete_all.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_host_delete_by_interface_async(
	bcmx_l3_host_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_HOST_DELETE_BY_INTERFACE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_delete_by_interface.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_host_delete_by_network_async(
	bcmx_l3_route_t * ip_addr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_HOST_DELETE_BY_NETWORK;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_delete_by_network.ip_addr = ip_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_host_find_async(
	bcmx_l3_host_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_HOST_FIND;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_find.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_host_invalidate_entry_async(
	bcm_ip_t info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_HOST_INVALIDATE_ENTRY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_invalidate_entry.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_host_traverse_async(
	uint32 flags,
	uint32 start,
	uint32 end,
	bcm_l3_host_traverse_cb cb,
	void * user_data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_HOST_TRAVERSE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_traverse.flags = flags;
	async->args.l3_host_traverse.start = start;
	async->args.l3_host_traverse.end = end;
	async->args.l3_host_traverse.cb = cb;
	async->args.l3_host_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_host_validate_entry_async(
	bcm_ip_t info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_HOST_VALIDATE_ENTRY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_host_validate_entry.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_info_async(
	bcm_l3_info_t * l3info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_INFO;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_info.l3info = l3info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_ingress_create_async(
	bcmx_l3_ingress_t * ing_intf,
	bcm_if_t * intf_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_INGRESS_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_create.ing_intf = ing_intf;
	async->args.l3_ingress_create.intf_id = intf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_ingress_destroy_async(
	bcm_if_t intf_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_INGRESS_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_destroy.intf_id = intf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_ingress_find_async(
	bcmx_l3_ingress_t * ing_intf,
	bcm_if_t * intf_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_INGRESS_FIND;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_find.ing_intf = ing_intf;
	async->args.l3_ingress_find.intf_id = intf_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_ingress_get_async(
	bcm_if_t intf,
	bcmx_l3_ingress_t * ing_intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_INGRESS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ingress_get.intf = intf;
	async->args.l3_ingress_get.ing_intf = ing_intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_intf_create_async(
	bcm_l3_intf_t * intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_INTF_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_intf_create.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_intf_delete_async(
	bcm_l3_intf_t * intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_INTF_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_intf_delete.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_intf_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_INTF_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_intf_find_async(
	bcm_l3_intf_t * intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_INTF_FIND;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_intf_find.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_intf_find_vlan_async(
	bcm_l3_intf_t * intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_INTF_FIND_VLAN;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_intf_find_vlan.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_intf_get_async(
	bcm_l3_intf_t * intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_INTF_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_intf_get.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_ip6_prefix_map_add_async(
	bcm_ip6_t ip6_addr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_IP6_PREFIX_MAP_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ip6_prefix_map_add.ip6_addr = (uint8 *)ip6_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_ip6_prefix_map_delete_async(
	bcm_ip6_t ip6_addr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_IP6_PREFIX_MAP_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ip6_prefix_map_delete.ip6_addr = (uint8 *)ip6_addr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_ip6_prefix_map_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_IP6_PREFIX_MAP_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_ip6_prefix_map_get_async(
	int map_size,
	bcm_ip6_t * ip6_array,
	int * ip6_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_IP6_PREFIX_MAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_ip6_prefix_map_get.map_size = map_size;
	async->args.l3_ip6_prefix_map_get.ip6_array = ip6_array;
	async->args.l3_ip6_prefix_map_get.ip6_count = ip6_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_route_add_async(
	bcmx_l3_route_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_ROUTE_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_route_age_async(
	uint32 flags,
	bcm_l3_route_traverse_cb age_out,
	void * user_data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_ROUTE_AGE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_age.flags = flags;
	async->args.l3_route_age.age_out = age_out;
	async->args.l3_route_age.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_route_delete_async(
	bcmx_l3_route_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_ROUTE_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_delete.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_route_delete_all_async(
	bcmx_l3_route_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_ROUTE_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_delete_all.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_route_delete_by_interface_async(
	bcmx_l3_route_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_ROUTE_DELETE_BY_INTERFACE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_delete_by_interface.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_route_get_async(
	bcmx_l3_route_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_ROUTE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_route_max_ecmp_get_async(
	int * max,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_ROUTE_MAX_ECMP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_max_ecmp_get.max = max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_route_max_ecmp_set_async(
	int max,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_ROUTE_MAX_ECMP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_max_ecmp_set.max = max;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_route_multipath_get_async(
	bcmx_l3_route_t * the_route,
	bcmx_l3_route_t * path_array,
	int max_path,
	int * path_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_ROUTE_MULTIPATH_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_multipath_get.the_route = the_route;
	async->args.l3_route_multipath_get.path_array = path_array;
	async->args.l3_route_multipath_get.max_path = max_path;
	async->args.l3_route_multipath_get.path_count = path_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_route_traverse_async(
	uint32 flags,
	uint32 start,
	uint32 end,
	bcm_l3_route_traverse_cb trav_fn,
	void * user_data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_ROUTE_TRAVERSE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_route_traverse.flags = flags;
	async->args.l3_route_traverse.start = start;
	async->args.l3_route_traverse.end = end;
	async->args.l3_route_traverse.trav_fn = trav_fn;
	async->args.l3_route_traverse.user_data = user_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_source_bind_add_async(
	bcmx_l3_source_bind_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_SOURCE_BIND_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_source_bind_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_source_bind_delete_async(
	bcmx_l3_source_bind_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_SOURCE_BIND_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_source_bind_delete.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_source_bind_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_SOURCE_BIND_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_source_bind_enable_get_async(
	bcm_gport_t port,
	int * enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_SOURCE_BIND_ENABLE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_source_bind_enable_get.port = port;
	async->args.l3_source_bind_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_source_bind_enable_set_async(
	bcm_gport_t port,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_SOURCE_BIND_ENABLE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_source_bind_enable_set.port = port;
	async->args.l3_source_bind_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_source_bind_get_async(
	bcmx_l3_source_bind_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_SOURCE_BIND_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_source_bind_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_vrf_stat_enable_set_async(
	bcm_vrf_t vrf,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_VRF_STAT_ENABLE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_enable_set.vrf = vrf;
	async->args.l3_vrf_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_vrf_stat_get_async(
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint64 * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_VRF_STAT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_get.vrf = vrf;
	async->args.l3_vrf_stat_get.stat = stat;
	async->args.l3_vrf_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_vrf_stat_get32_async(
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint32 * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_VRF_STAT_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_get32.vrf = vrf;
	async->args.l3_vrf_stat_get32.stat = stat;
	async->args.l3_vrf_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_vrf_stat_multi_get_async(
	bcm_vrf_t vrf,
	int nstat,
	bcm_l3_vrf_stat_t * stat_arr,
	uint64 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_VRF_STAT_MULTI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_multi_get.vrf = vrf;
	async->args.l3_vrf_stat_multi_get.nstat = nstat;
	async->args.l3_vrf_stat_multi_get.stat_arr = stat_arr;
	async->args.l3_vrf_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_vrf_stat_multi_get32_async(
	bcm_vrf_t vrf,
	int nstat,
	bcm_l3_vrf_stat_t * stat_arr,
	uint32 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_VRF_STAT_MULTI_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_multi_get32.vrf = vrf;
	async->args.l3_vrf_stat_multi_get32.nstat = nstat;
	async->args.l3_vrf_stat_multi_get32.stat_arr = stat_arr;
	async->args.l3_vrf_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_vrf_stat_multi_set_async(
	bcm_vrf_t vrf,
	int nstat,
	bcm_l3_vrf_stat_t * stat_arr,
	uint64 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_VRF_STAT_MULTI_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_multi_set.vrf = vrf;
	async->args.l3_vrf_stat_multi_set.nstat = nstat;
	async->args.l3_vrf_stat_multi_set.stat_arr = stat_arr;
	async->args.l3_vrf_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_vrf_stat_multi_set32_async(
	bcm_vrf_t vrf,
	int nstat,
	bcm_l3_vrf_stat_t * stat_arr,
	uint32 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_VRF_STAT_MULTI_SET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_multi_set32.vrf = vrf;
	async->args.l3_vrf_stat_multi_set32.nstat = nstat;
	async->args.l3_vrf_stat_multi_set32.stat_arr = stat_arr;
	async->args.l3_vrf_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_vrf_stat_set_async(
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint64 val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_VRF_STAT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_set.vrf = vrf;
	async->args.l3_vrf_stat_set.stat = stat;
	async->args.l3_vrf_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_vrf_stat_set32_async(
	bcm_vrf_t vrf,
	bcm_l3_vrf_stat_t stat,
	uint32 val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_VRF_STAT_SET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrf_stat_set32.vrf = vrf;
	async->args.l3_vrf_stat_set32.stat = stat;
	async->args.l3_vrf_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_vrrp_add_async(
	bcm_vlan_t vlan,
	uint32 vrid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_VRRP_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrrp_add.vlan = vlan;
	async->args.l3_vrrp_add.vrid = vrid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_vrrp_delete_async(
	bcm_vlan_t vlan,
	uint32 vrid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_VRRP_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrrp_delete.vlan = vlan;
	async->args.l3_vrrp_delete.vrid = vrid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_vrrp_delete_all_async(
	bcm_vlan_t vlan,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_VRRP_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrrp_delete_all.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_l3_vrrp_get_async(
	bcm_vlan_t vlan,
	int alloc_size,
	int * vrid_array,
	int * count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_L3_VRRP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.l3_vrrp_get.vlan = vlan;
	async->args.l3_vrrp_get.alloc_size = alloc_size;
	async->args.l3_vrrp_get.vrid_array = vrid_array;
	async->args.l3_vrrp_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcmx_linkscan_device_add_async(
	int bcm_unit,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_LINKSCAN_DEVICE_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_device_add.bcm_unit = bcm_unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_linkscan_device_remove_async(
	int bcm_unit,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_LINKSCAN_DEVICE_REMOVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_device_remove.bcm_unit = bcm_unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_linkscan_enable_get_async(
	int * us,
	int * consistent,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_LINKSCAN_ENABLE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_enable_get.us = us;
	async->args.linkscan_enable_get.consistent = consistent;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_linkscan_enable_port_get_async(
	bcmx_lport_t lport,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_LINKSCAN_ENABLE_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_enable_port_get.lport = lport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_linkscan_enable_set_async(
	int us,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_LINKSCAN_ENABLE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_enable_set.us = us;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_linkscan_register_async(
	bcmx_link_notify_f ln_cb,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_LINKSCAN_REGISTER;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_register.ln_cb = ln_cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_linkscan_unregister_async(
	bcmx_link_notify_f ln_cb,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_LINKSCAN_UNREGISTER;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.linkscan_unregister.ln_cb = ln_cb;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mcast_addr_add_async(
	bcmx_mcast_addr_t * mcaddr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MCAST_ADDR_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_addr_add.mcaddr = mcaddr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mcast_addr_remove_async(
	bcm_mac_t mac,
	bcm_vlan_t vid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MCAST_ADDR_REMOVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_addr_remove.mac = (uint8 *)mac;
	async->args.mcast_addr_remove.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mcast_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MCAST_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mcast_join_async(
	bcm_mac_t mac,
	bcm_vlan_t vid,
	bcmx_lport_t port,
	bcmx_mcast_addr_t * mcaddr,
	bcmx_lplist_t * allrtr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MCAST_JOIN;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_join.mac = (uint8 *)mac;
	async->args.mcast_join.vid = vid;
	async->args.mcast_join.port = port;
	async->args.mcast_join.mcaddr = mcaddr;
	async->args.mcast_join.allrtr = allrtr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mcast_leave_async(
	bcm_mac_t mac,
	bcm_vlan_t vid,
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MCAST_LEAVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_leave.mac = (uint8 *)mac;
	async->args.mcast_leave.vid = vid;
	async->args.mcast_leave.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mcast_port_add_async(
	bcmx_mcast_addr_t * mcaddr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MCAST_PORT_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_port_add.mcaddr = mcaddr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mcast_port_get_async(
	bcm_mac_t mac,
	bcm_vlan_t vid,
	bcmx_mcast_addr_t * mcaddr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MCAST_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_port_get.mac = (uint8 *)mac;
	async->args.mcast_port_get.vid = vid;
	async->args.mcast_port_get.mcaddr = mcaddr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mcast_port_remove_async(
	bcmx_mcast_addr_t * mcaddr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MCAST_PORT_REMOVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mcast_port_remove.mcaddr = mcaddr;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcmx_mim_detach_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIM_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mim_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIM_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mim_port_add_async(
	bcm_mim_vpn_t vpn,
	bcmx_mim_port_t * mim_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIM_PORT_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_port_add.vpn = vpn;
	async->args.mim_port_add.mim_port = mim_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mim_port_delete_async(
	bcm_mim_vpn_t vpn,
	bcm_gport_t mim_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIM_PORT_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_port_delete.vpn = vpn;
	async->args.mim_port_delete.mim_port_id = mim_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mim_port_delete_all_async(
	bcm_mim_vpn_t vpn,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIM_PORT_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_port_delete_all.vpn = vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mim_port_get_async(
	bcm_mim_vpn_t vpn,
	bcmx_mim_port_t * mim_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIM_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_port_get.vpn = vpn;
	async->args.mim_port_get.mim_port = mim_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mim_port_get_all_async(
	bcm_mim_vpn_t vpn,
	int port_max,
	bcmx_mim_port_t * port_array,
	int * port_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIM_PORT_GET_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_port_get_all.vpn = vpn;
	async->args.mim_port_get_all.port_max = port_max;
	async->args.mim_port_get_all.port_array = port_array;
	async->args.mim_port_get_all.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mim_vpn_create_async(
	bcmx_mim_vpn_config_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIM_VPN_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mim_vpn_destroy_async(
	bcm_mim_vpn_t vpn,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIM_VPN_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_destroy.vpn = vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mim_vpn_destroy_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIM_VPN_DESTROY_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mim_vpn_get_async(
	bcm_mim_vpn_t vpn,
	bcmx_mim_vpn_config_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIM_VPN_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mim_vpn_get.vpn = vpn;
	async->args.mim_vpn_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcmx_mirror_destination_create_async(
	bcmx_mirror_destination_t * mirror_dest,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_DESTINATION_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_destination_create.mirror_dest = mirror_dest;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_destination_destroy_async(
	bcm_gport_t mirror_dest_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_DESTINATION_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_destination_destroy.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_destination_get_async(
	bcm_gport_t mirror_dest_id,
	bcmx_mirror_destination_t * mirror_dest,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_DESTINATION_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_destination_get.mirror_dest_id = mirror_dest_id;
	async->args.mirror_destination_get.mirror_dest = mirror_dest;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_egress_get_async(
	bcmx_lport_t port,
	int * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_EGRESS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_egress_get.port = port;
	async->args.mirror_egress_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_egress_set_async(
	bcmx_lport_t port,
	int val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_EGRESS_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_egress_set.port = port;
	async->args.mirror_egress_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_fabric_list_get_async(
	bcmx_lport_t port,
	bcmx_lplist_t * lplist,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_FABRIC_LIST_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_fabric_list_get.port = port;
	async->args.mirror_fabric_list_get.lplist = lplist;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_fabric_list_set_async(
	bcmx_lport_t port,
	bcmx_lplist_t lplist,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_FABRIC_LIST_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_fabric_list_set.port = port;
	async->args.mirror_fabric_list_set.lplist = lplist;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_ingress_get_async(
	bcmx_lport_t port,
	int * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_INGRESS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_ingress_get.port = port;
	async->args.mirror_ingress_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_ingress_set_async(
	bcmx_lport_t port,
	int val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_INGRESS_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_ingress_set.port = port;
	async->args.mirror_ingress_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_mode_get_async(
	int * mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_MODE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_mode_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_mode_set_async(
	int mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_MODE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_mode_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_port_dest_add_async(
	bcmx_lport_t port,
	uint32 flags,
	bcm_gport_t mirror_dest_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_PORT_DEST_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_dest_add.port = port;
	async->args.mirror_port_dest_add.flags = flags;
	async->args.mirror_port_dest_add.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_port_dest_delete_async(
	bcmx_lport_t port,
	uint32 flags,
	bcm_gport_t mirror_dest_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_PORT_DEST_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_dest_delete.port = port;
	async->args.mirror_port_dest_delete.flags = flags;
	async->args.mirror_port_dest_delete.mirror_dest_id = mirror_dest_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_port_dest_delete_all_async(
	bcmx_lport_t port,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_PORT_DEST_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_dest_delete_all.port = port;
	async->args.mirror_port_dest_delete_all.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_port_dest_get_async(
	bcmx_lport_t port,
	uint32 flags,
	int mirror_dest_size,
	bcm_gport_t * mirror_dest,
	int * mirror_dest_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_PORT_DEST_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_dest_get.port = port;
	async->args.mirror_port_dest_get.flags = flags;
	async->args.mirror_port_dest_get.mirror_dest_size = mirror_dest_size;
	async->args.mirror_port_dest_get.mirror_dest = mirror_dest;
	async->args.mirror_port_dest_get.mirror_dest_count = mirror_dest_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_port_get_async(
	bcmx_lport_t port,
	bcmx_lport_t * dest_port,
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_get.port = port;
	async->args.mirror_port_get.dest_port = dest_port;
	async->args.mirror_port_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_port_set_async(
	bcmx_lport_t port,
	bcmx_lport_t dest_port,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_PORT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_port_set.port = port;
	async->args.mirror_port_set.dest_port = dest_port;
	async->args.mirror_port_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_to_get_async(
	bcmx_lport_t * port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_TO_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_to_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_to_set_async(
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_TO_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_to_set.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_vlan_get_async(
	bcmx_lport_t port,
	uint16 * tpid,
	uint16 * vlan,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_VLAN_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_vlan_get.port = port;
	async->args.mirror_vlan_get.tpid = tpid;
	async->args.mirror_vlan_get.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mirror_vlan_set_async(
	bcmx_lport_t port,
	uint16 tpid,
	uint16 vlan,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MIRROR_VLAN_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mirror_vlan_set.port = port;
	async->args.mirror_vlan_set.tpid = tpid;
	async->args.mirror_vlan_set.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcmx_mpls_cleanup_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_CLEANUP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_exp_map_create_async(
	uint32 flags,
	int * exp_map_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_EXP_MAP_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_exp_map_create.flags = flags;
	async->args.mpls_exp_map_create.exp_map_id = exp_map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_exp_map_destroy_async(
	int exp_map_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_EXP_MAP_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_exp_map_destroy.exp_map_id = exp_map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_exp_map_get_async(
	int exp_map_id,
	bcm_mpls_exp_map_t * exp_map,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_EXP_MAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_exp_map_get.exp_map_id = exp_map_id;
	async->args.mpls_exp_map_get.exp_map = exp_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_exp_map_set_async(
	int exp_map_id,
	bcm_mpls_exp_map_t * exp_map,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_EXP_MAP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_exp_map_set.exp_map_id = exp_map_id;
	async->args.mpls_exp_map_set.exp_map = exp_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_label_stat_clear_async(
	bcm_mpls_label_t label,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_LABEL_STAT_CLEAR;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_clear.label = label;
	async->args.mpls_label_stat_clear.port = port;
	async->args.mpls_label_stat_clear.stat = stat;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_label_stat_get_async(
	bcm_mpls_label_t label,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint64 * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_LABEL_STAT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_get.label = label;
	async->args.mpls_label_stat_get.port = port;
	async->args.mpls_label_stat_get.stat = stat;
	async->args.mpls_label_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_label_stat_get32_async(
	bcm_mpls_label_t label,
	bcm_gport_t port,
	bcm_mpls_stat_t stat,
	uint32 * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_LABEL_STAT_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_label_stat_get32.label = label;
	async->args.mpls_label_stat_get32.port = port;
	async->args.mpls_label_stat_get32.stat = stat;
	async->args.mpls_label_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_port_add_async(
	bcm_vpn_t vpn,
	bcmx_mpls_port_t * mpls_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_PORT_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_add.vpn = vpn;
	async->args.mpls_port_add.mpls_port = mpls_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_port_delete_async(
	bcm_vpn_t vpn,
	bcm_gport_t mpls_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_PORT_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_delete.vpn = vpn;
	async->args.mpls_port_delete.mpls_port_id = mpls_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_port_delete_all_async(
	bcm_vpn_t vpn,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_PORT_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_delete_all.vpn = vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_port_get_async(
	bcm_vpn_t vpn,
	bcmx_mpls_port_t * mpls_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_get.vpn = vpn;
	async->args.mpls_port_get.mpls_port = mpls_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_port_get_all_async(
	bcm_vpn_t vpn,
	int port_max,
	bcmx_mpls_port_t * port_array,
	int * port_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_PORT_GET_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_port_get_all.vpn = vpn;
	async->args.mpls_port_get_all.port_max = port_max;
	async->args.mpls_port_get_all.port_array = port_array;
	async->args.mpls_port_get_all.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_tunnel_initiator_clear_async(
	bcm_if_t intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_TUNNEL_INITIATOR_CLEAR;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_initiator_clear.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_tunnel_initiator_clear_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_TUNNEL_INITIATOR_CLEAR_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_tunnel_initiator_get_async(
	bcm_if_t intf,
	int label_max,
	bcmx_mpls_egress_label_t * label_array,
	int * label_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_TUNNEL_INITIATOR_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_initiator_get.intf = intf;
	async->args.mpls_tunnel_initiator_get.label_max = label_max;
	async->args.mpls_tunnel_initiator_get.label_array = label_array;
	async->args.mpls_tunnel_initiator_get.label_count = label_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_tunnel_initiator_set_async(
	bcm_if_t intf,
	int num_labels,
	bcmx_mpls_egress_label_t * label_array,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_TUNNEL_INITIATOR_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_initiator_set.intf = intf;
	async->args.mpls_tunnel_initiator_set.num_labels = num_labels;
	async->args.mpls_tunnel_initiator_set.label_array = label_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_tunnel_switch_add_async(
	bcmx_mpls_tunnel_switch_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_switch_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_tunnel_switch_delete_async(
	bcmx_mpls_tunnel_switch_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_switch_delete.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_tunnel_switch_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_tunnel_switch_get_async(
	bcmx_mpls_tunnel_switch_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_tunnel_switch_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_vpn_id_create_async(
	bcmx_mpls_vpn_config_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_VPN_ID_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_vpn_id_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_vpn_id_destroy_async(
	bcm_vpn_t vpn,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_VPN_ID_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_vpn_id_destroy.vpn = vpn;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_vpn_id_destroy_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_VPN_ID_DESTROY_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_mpls_vpn_id_get_async(
	bcm_vpn_t vpn,
	bcmx_mpls_vpn_config_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MPLS_VPN_ID_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.mpls_vpn_id_get.vpn = vpn;
	async->args.mpls_vpn_id_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcmx_multicast_control_get_async(
	bcm_multicast_t group,
	bcm_multicast_control_t type,
	int * arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_CONTROL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_control_get.group = group;
	async->args.multicast_control_get.type = type;
	async->args.multicast_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_control_set_async(
	bcm_multicast_t group,
	bcm_multicast_control_t type,
	int arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_CONTROL_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_control_set.group = group;
	async->args.multicast_control_set.type = type;
	async->args.multicast_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_create_async(
	uint32 flags,
	bcm_multicast_t * group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_create.flags = flags;
	async->args.multicast_create.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_destroy_async(
	bcm_multicast_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_destroy.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_detach_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_egress_add_async(
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_if_t encap_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_EGRESS_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_add.group = group;
	async->args.multicast_egress_add.port = port;
	async->args.multicast_egress_add.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_egress_delete_async(
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_if_t encap_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_EGRESS_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_delete.group = group;
	async->args.multicast_egress_delete.port = port;
	async->args.multicast_egress_delete.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_egress_delete_all_async(
	bcm_multicast_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_EGRESS_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_delete_all.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_egress_get_async(
	bcm_multicast_t group,
	int port_max,
	bcm_gport_t * port_array,
	bcm_if_t * encap_id_array,
	int * port_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_EGRESS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_get.group = group;
	async->args.multicast_egress_get.port_max = port_max;
	async->args.multicast_egress_get.port_array = port_array;
	async->args.multicast_egress_get.encap_id_array = encap_id_array;
	async->args.multicast_egress_get.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_egress_set_async(
	bcm_multicast_t group,
	int port_count,
	bcm_gport_t * port_array,
	bcm_if_t * encap_id_array,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_EGRESS_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_egress_set.group = group;
	async->args.multicast_egress_set.port_count = port_count;
	async->args.multicast_egress_set.port_array = port_array;
	async->args.multicast_egress_set.encap_id_array = encap_id_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_group_get_async(
	bcm_multicast_t group,
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_GROUP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_group_get.group = group;
	async->args.multicast_group_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_l2_encap_get_async(
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_vlan_t vlan,
	bcm_if_t * encap_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_L2_ENCAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_l2_encap_get.group = group;
	async->args.multicast_l2_encap_get.port = port;
	async->args.multicast_l2_encap_get.vlan = vlan;
	async->args.multicast_l2_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_l3_encap_get_async(
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_if_t intf,
	bcm_if_t * encap_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_L3_ENCAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_l3_encap_get.group = group;
	async->args.multicast_l3_encap_get.port = port;
	async->args.multicast_l3_encap_get.intf = intf;
	async->args.multicast_l3_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_mim_encap_get_async(
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t mim_port_id,
	bcm_if_t * encap_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_MIM_ENCAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_mim_encap_get.group = group;
	async->args.multicast_mim_encap_get.port = port;
	async->args.multicast_mim_encap_get.mim_port_id = mim_port_id;
	async->args.multicast_mim_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_niv_encap_get_async(
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t niv_port_id,
	bcm_if_t * encap_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_NIV_ENCAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_niv_encap_get.group = group;
	async->args.multicast_niv_encap_get.port = port;
	async->args.multicast_niv_encap_get.niv_port_id = niv_port_id;
	async->args.multicast_niv_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_repl_get_async(
	int index,
	bcmx_lport_t port,
	bcm_vlan_vector_t vlan_vec,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_REPL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_repl_get.index = index;
	async->args.multicast_repl_get.port = port;
	async->args.multicast_repl_get.vlan_vec = (uint32 *)vlan_vec;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_repl_set_async(
	int index,
	bcmx_lport_t port,
	bcm_vlan_vector_t vlan_vec,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_REPL_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_repl_set.index = index;
	async->args.multicast_repl_set.port = port;
	async->args.multicast_repl_set.vlan_vec = (uint32 *)vlan_vec;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_subport_encap_get_async(
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t subport,
	bcm_if_t * encap_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_SUBPORT_ENCAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_subport_encap_get.group = group;
	async->args.multicast_subport_encap_get.port = port;
	async->args.multicast_subport_encap_get.subport = subport;
	async->args.multicast_subport_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_trill_encap_get_async(
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_if_t intf,
	bcm_if_t * encap_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_TRILL_ENCAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_trill_encap_get.group = group;
	async->args.multicast_trill_encap_get.port = port;
	async->args.multicast_trill_encap_get.intf = intf;
	async->args.multicast_trill_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_vlan_encap_get_async(
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t vlan_port_id,
	bcm_if_t * encap_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_VLAN_ENCAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_vlan_encap_get.group = group;
	async->args.multicast_vlan_encap_get.port = port;
	async->args.multicast_vlan_encap_get.vlan_port_id = vlan_port_id;
	async->args.multicast_vlan_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_vpls_encap_get_async(
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t mpls_port_id,
	bcm_if_t * encap_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_VPLS_ENCAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_vpls_encap_get.group = group;
	async->args.multicast_vpls_encap_get.port = port;
	async->args.multicast_vpls_encap_get.mpls_port_id = mpls_port_id;
	async->args.multicast_vpls_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_multicast_wlan_encap_get_async(
	bcm_multicast_t group,
	bcm_gport_t port,
	bcm_gport_t wlan_port_id,
	bcm_if_t * encap_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_MULTICAST_WLAN_ENCAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.multicast_wlan_encap_get.group = group;
	async->args.multicast_wlan_encap_get.port = port;
	async->args.multicast_wlan_encap_get.wlan_port_id = wlan_port_id;
	async->args.multicast_wlan_encap_get.encap_id = encap_id;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcmx_niv_cleanup_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_NIV_CLEANUP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_niv_forward_add_async(
	bcmx_niv_forward_t * iv_fwd_entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_NIV_FORWARD_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_forward_add.iv_fwd_entry = iv_fwd_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_niv_forward_delete_async(
	bcmx_niv_forward_t * iv_fwd_entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_NIV_FORWARD_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_forward_delete.iv_fwd_entry = iv_fwd_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_niv_forward_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_NIV_FORWARD_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_niv_forward_get_async(
	bcmx_niv_forward_t * iv_fwd_entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_NIV_FORWARD_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_forward_get.iv_fwd_entry = iv_fwd_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_niv_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_NIV_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_niv_port_add_async(
	bcmx_niv_port_t * niv_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_NIV_PORT_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_port_add.niv_port = niv_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_niv_port_delete_async(
	bcm_gport_t niv_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_NIV_PORT_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_port_delete.niv_port_id = niv_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_niv_port_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_NIV_PORT_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_niv_port_get_async(
	bcmx_niv_port_t * niv_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_NIV_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.niv_port_get.niv_port = niv_port;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcmx_oam_detach_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_OAM_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_oam_endpoint_create_async(
	bcmx_oam_endpoint_info_t * endpoint_info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_OAM_ENDPOINT_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_create.endpoint_info = endpoint_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_oam_endpoint_destroy_async(
	bcm_oam_endpoint_t endpoint,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_OAM_ENDPOINT_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_destroy.endpoint = endpoint;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_oam_endpoint_destroy_all_async(
	bcm_oam_group_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_OAM_ENDPOINT_DESTROY_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_destroy_all.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_oam_endpoint_get_async(
	bcm_oam_endpoint_t endpoint,
	bcmx_oam_endpoint_info_t * endpoint_info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_OAM_ENDPOINT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_endpoint_get.endpoint = endpoint;
	async->args.oam_endpoint_get.endpoint_info = endpoint_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_oam_group_create_async(
	bcmx_oam_group_info_t * group_info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_OAM_GROUP_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_group_create.group_info = group_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_oam_group_destroy_async(
	bcm_oam_group_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_OAM_GROUP_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_group_destroy.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_oam_group_destroy_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_OAM_GROUP_DESTROY_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_oam_group_get_async(
	bcm_oam_group_t group,
	bcmx_oam_group_info_t * group_info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_OAM_GROUP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.oam_group_get.group = group;
	async->args.oam_group_get.group_info = group_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_oam_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_OAM_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_policer_create_async(
	bcmx_policer_config_t * pol_cfg,
	bcm_policer_t * policer_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_POLICER_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_create.pol_cfg = pol_cfg;
	async->args.policer_create.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_policer_destroy_async(
	bcm_policer_t policer_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_POLICER_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_destroy.policer_id = policer_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_policer_destroy_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_POLICER_DESTROY_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_policer_get_async(
	bcm_policer_t policer_id,
	bcmx_policer_config_t * pol_cfg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_POLICER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_get.policer_id = policer_id;
	async->args.policer_get.pol_cfg = pol_cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_policer_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_POLICER_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_policer_set_async(
	bcm_policer_t policer_id,
	bcmx_policer_config_t * pol_cfg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_POLICER_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.policer_set.policer_id = policer_id;
	async->args.policer_set.pol_cfg = pol_cfg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_ability_advert_get_async(
	bcmx_lport_t port,
	bcmx_port_ability_t * ability_mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ABILITY_ADVERT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ability_advert_get.port = port;
	async->args.port_ability_advert_get.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_ability_advert_set_async(
	bcmx_lport_t port,
	bcmx_port_ability_t * ability_mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ABILITY_ADVERT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ability_advert_set.port = port;
	async->args.port_ability_advert_set.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_ability_get_async(
	bcmx_lport_t port,
	bcm_port_abil_t * local_ability_mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ABILITY_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ability_get.port = port;
	async->args.port_ability_get.local_ability_mask = local_ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_ability_local_get_async(
	bcmx_lport_t port,
	bcmx_port_ability_t * local_ability_mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ABILITY_LOCAL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ability_local_get.port = port;
	async->args.port_ability_local_get.local_ability_mask = local_ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_ability_remote_get_async(
	bcmx_lport_t port,
	bcmx_port_ability_t * ability_mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ABILITY_REMOTE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ability_remote_get.port = port;
	async->args.port_ability_remote_get.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_advert_get_async(
	bcmx_lport_t port,
	bcm_port_abil_t * ability_mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ADVERT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_advert_get.port = port;
	async->args.port_advert_get.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_advert_remote_get_async(
	bcmx_lport_t port,
	bcm_port_abil_t * ability_mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ADVERT_REMOTE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_advert_remote_get.port = port;
	async->args.port_advert_remote_get.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_advert_set_async(
	bcmx_lport_t port,
	bcm_port_abil_t ability_mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ADVERT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_advert_set.port = port;
	async->args.port_advert_set.ability_mask = ability_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_autoneg_get_async(
	bcmx_lport_t port,
	int * autoneg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_AUTONEG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_autoneg_get.port = port;
	async->args.port_autoneg_get.autoneg = autoneg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_autoneg_set_async(
	bcmx_lport_t port,
	int autoneg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_AUTONEG_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_autoneg_set.port = port;
	async->args.port_autoneg_set.autoneg = autoneg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_bpdu_enable_get_async(
	bcmx_lport_t port,
	int * enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_BPDU_ENABLE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_bpdu_enable_get.port = port;
	async->args.port_bpdu_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_bpdu_enable_set_async(
	bcmx_lport_t port,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_BPDU_ENABLE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_bpdu_enable_set.port = port;
	async->args.port_bpdu_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_cable_diag_async(
	bcmx_lport_t port,
	bcm_port_cable_diag_t * status,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_CABLE_DIAG;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_cable_diag.port = port;
	async->args.port_cable_diag.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_cfi_color_get_async(
	bcmx_lport_t port,
	int cfi,
	bcm_color_t * color,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_CFI_COLOR_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_cfi_color_get.port = port;
	async->args.port_cfi_color_get.cfi = cfi;
	async->args.port_cfi_color_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_cfi_color_set_async(
	bcmx_lport_t port,
	int cfi,
	bcm_color_t color,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_CFI_COLOR_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_cfi_color_set.port = port;
	async->args.port_cfi_color_set.cfi = cfi;
	async->args.port_cfi_color_set.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_class_get_async(
	bcmx_lport_t port,
	bcm_port_class_t pclass,
	uint32 * class_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_CLASS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_class_get.port = port;
	async->args.port_class_get.pclass = pclass;
	async->args.port_class_get.class_id = class_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_class_set_async(
	bcmx_lport_t port,
	bcm_port_class_t pclass,
	uint32 class_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_CLASS_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_class_set.port = port;
	async->args.port_class_set.pclass = pclass;
	async->args.port_class_set.class_id = class_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_config_get_async(
	bcmx_port_config_t * config,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_CONFIG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_congestion_config_get_async(
	bcm_gport_t port,
	bcmx_port_congestion_config_t * config,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_CONGESTION_CONFIG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_congestion_config_get.port = port;
	async->args.port_congestion_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_congestion_config_set_async(
	bcm_gport_t port,
	bcmx_port_congestion_config_t * config,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_CONGESTION_CONFIG_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_congestion_config_set.port = port;
	async->args.port_congestion_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_control_get_async(
	bcmx_lport_t port,
	bcm_port_control_t type,
	int * value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_CONTROL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_control_get.port = port;
	async->args.port_control_get.type = type;
	async->args.port_control_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_control_phy_timesync_get_async(
	bcm_gport_t port,
	bcm_port_control_phy_timesync_t type,
	uint64 * value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_CONTROL_PHY_TIMESYNC_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_control_phy_timesync_get.port = port;
	async->args.port_control_phy_timesync_get.type = type;
	async->args.port_control_phy_timesync_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_control_phy_timesync_set_async(
	bcm_gport_t port,
	bcm_port_control_phy_timesync_t type,
	uint64 value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_CONTROL_PHY_TIMESYNC_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_control_phy_timesync_set.port = port;
	async->args.port_control_phy_timesync_set.type = type;
	async->args.port_control_phy_timesync_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_control_set_async(
	bcmx_lport_t port,
	bcm_port_control_t type,
	int value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_CONTROL_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_control_set.port = port;
	async->args.port_control_set.type = type;
	async->args.port_control_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_discard_get_async(
	bcmx_lport_t port,
	int * mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_DISCARD_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_discard_get.port = port;
	async->args.port_discard_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_discard_set_async(
	bcmx_lport_t port,
	int mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_DISCARD_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_discard_set.port = port;
	async->args.port_discard_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_dscp_map_get_async(
	bcmx_lport_t port,
	int srccp,
	int * mapcp,
	int * prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_DSCP_MAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dscp_map_get.port = port;
	async->args.port_dscp_map_get.srccp = srccp;
	async->args.port_dscp_map_get.mapcp = mapcp;
	async->args.port_dscp_map_get.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_dscp_map_mode_get_async(
	bcmx_lport_t port,
	int * mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_DSCP_MAP_MODE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dscp_map_mode_get.port = port;
	async->args.port_dscp_map_mode_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_dscp_map_mode_set_async(
	bcmx_lport_t port,
	int mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_DSCP_MAP_MODE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dscp_map_mode_set.port = port;
	async->args.port_dscp_map_mode_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_dscp_map_set_async(
	bcmx_lport_t port,
	int srccp,
	int mapcp,
	int prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_DSCP_MAP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dscp_map_set.port = port;
	async->args.port_dscp_map_set.srccp = srccp;
	async->args.port_dscp_map_set.mapcp = mapcp;
	async->args.port_dscp_map_set.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_dtag_mode_get_async(
	bcmx_lport_t port,
	int * mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_DTAG_MODE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dtag_mode_get.port = port;
	async->args.port_dtag_mode_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_dtag_mode_set_async(
	bcmx_lport_t port,
	int mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_DTAG_MODE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_dtag_mode_set.port = port;
	async->args.port_dtag_mode_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_duplex_get_async(
	bcmx_lport_t port,
	int * duplex,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_DUPLEX_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_duplex_get.port = port;
	async->args.port_duplex_get.duplex = duplex;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_duplex_set_async(
	bcmx_lport_t port,
	int duplex,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_DUPLEX_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_duplex_set.port = port;
	async->args.port_duplex_set.duplex = duplex;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_egress_get_async(
	bcmx_lport_t port,
	int modid,
	bcmx_lplist_t * lplist,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_EGRESS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_egress_get.port = port;
	async->args.port_egress_get.modid = modid;
	async->args.port_egress_get.lplist = lplist;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_egress_set_async(
	bcmx_lport_t port,
	int modid,
	bcmx_lplist_t lplist,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_EGRESS_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_egress_set.port = port;
	async->args.port_egress_set.modid = modid;
	async->args.port_egress_set.lplist = lplist;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_enable_get_async(
	bcmx_lport_t port,
	int * enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ENABLE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_enable_get.port = port;
	async->args.port_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_enable_set_async(
	bcmx_lport_t port,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ENABLE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_enable_set.port = port;
	async->args.port_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_encap_config_get_async(
	bcm_gport_t gport,
	bcmx_port_encap_config_t * encap_config,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ENCAP_CONFIG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_encap_config_get.gport = gport;
	async->args.port_encap_config_get.encap_config = encap_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_encap_config_set_async(
	bcm_gport_t gport,
	bcmx_port_encap_config_t * encap_config,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ENCAP_CONFIG_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_encap_config_set.gport = gport;
	async->args.port_encap_config_set.encap_config = encap_config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_encap_get_async(
	bcmx_lport_t port,
	int * mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ENCAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_encap_get.port = port;
	async->args.port_encap_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_encap_set_async(
	bcmx_lport_t port,
	int mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_ENCAP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_encap_set.port = port;
	async->args.port_encap_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_fault_get_async(
	bcmx_lport_t port,
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_FAULT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_fault_get.port = port;
	async->args.port_fault_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_flood_block_get_async(
	bcmx_lport_t ingress_port,
	bcmx_lport_t egress_port,
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_FLOOD_BLOCK_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_flood_block_get.ingress_port = ingress_port;
	async->args.port_flood_block_get.egress_port = egress_port;
	async->args.port_flood_block_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_flood_block_set_async(
	bcmx_lport_t ingress_port,
	bcmx_lport_t egress_port,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_FLOOD_BLOCK_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_flood_block_set.ingress_port = ingress_port;
	async->args.port_flood_block_set.egress_port = egress_port;
	async->args.port_flood_block_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_force_vlan_get_async(
	bcmx_lport_t port,
	bcm_vlan_t * vlan,
	int * pkt_prio,
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_FORCE_VLAN_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_force_vlan_get.port = port;
	async->args.port_force_vlan_get.vlan = vlan;
	async->args.port_force_vlan_get.pkt_prio = pkt_prio;
	async->args.port_force_vlan_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_force_vlan_set_async(
	bcmx_lport_t port,
	bcm_vlan_t vlan,
	int pkt_prio,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_FORCE_VLAN_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_force_vlan_set.port = port;
	async->args.port_force_vlan_set.vlan = vlan;
	async->args.port_force_vlan_set.pkt_prio = pkt_prio;
	async->args.port_force_vlan_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_frame_max_get_async(
	bcmx_lport_t port,
	int * size,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_FRAME_MAX_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_frame_max_get.port = port;
	async->args.port_frame_max_get.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_frame_max_set_async(
	bcmx_lport_t port,
	int size,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_FRAME_MAX_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_frame_max_set.port = port;
	async->args.port_frame_max_set.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_gport_get_async(
	bcmx_lport_t port,
	bcm_gport_t * gport,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_GPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_gport_get.port = port;
	async->args.port_gport_get.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_ifg_get_async(
	bcmx_lport_t port,
	int speed,
	bcm_port_duplex_t duplex,
	int * bit_times,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_IFG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ifg_get.port = port;
	async->args.port_ifg_get.speed = speed;
	async->args.port_ifg_get.duplex = duplex;
	async->args.port_ifg_get.bit_times = bit_times;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_ifg_set_async(
	bcmx_lport_t port,
	int speed,
	bcm_port_duplex_t duplex,
	int bit_times,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_IFG_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ifg_set.port = port;
	async->args.port_ifg_set.speed = speed;
	async->args.port_ifg_set.duplex = duplex;
	async->args.port_ifg_set.bit_times = bit_times;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_ifilter_get_async(
	bcmx_lport_t port,
	int * mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_IFILTER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ifilter_get.port = port;
	async->args.port_ifilter_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_ifilter_set_async(
	bcmx_lport_t port,
	int mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_IFILTER_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ifilter_set.port = port;
	async->args.port_ifilter_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_info_get_async(
	bcmx_lport_t port,
	bcm_port_info_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_INFO_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_info_get.port = port;
	async->args.port_info_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_info_restore_async(
	bcmx_lport_t port,
	bcm_port_info_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_INFO_RESTORE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_info_restore.port = port;
	async->args.port_info_restore.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_info_save_async(
	bcmx_lport_t port,
	bcm_port_info_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_INFO_SAVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_info_save.port = port;
	async->args.port_info_save.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_info_set_async(
	bcmx_lport_t port,
	bcm_port_info_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_INFO_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_info_set.port = port;
	async->args.port_info_set.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_inner_tpid_get_async(
	bcmx_lport_t port,
	uint16 * tpid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_INNER_TPID_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_inner_tpid_get.port = port;
	async->args.port_inner_tpid_get.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_inner_tpid_set_async(
	bcmx_lport_t port,
	uint16 tpid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_INNER_TPID_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_inner_tpid_set.port = port;
	async->args.port_inner_tpid_set.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_interface_get_async(
	bcmx_lport_t port,
	bcm_port_if_t * intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_INTERFACE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_interface_get.port = port;
	async->args.port_interface_get.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_interface_set_async(
	bcmx_lport_t port,
	bcm_port_if_t intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_INTERFACE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_interface_set.port = port;
	async->args.port_interface_set.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_ipmc_modify_get_async(
	bcmx_lport_t port,
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_IPMC_MODIFY_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ipmc_modify_get.port = port;
	async->args.port_ipmc_modify_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_ipmc_modify_set_async(
	bcmx_lport_t port,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_IPMC_MODIFY_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_ipmc_modify_set.port = port;
	async->args.port_ipmc_modify_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_jam_get_async(
	bcmx_lport_t port,
	int * enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_JAM_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_jam_get.port = port;
	async->args.port_jam_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_jam_set_async(
	bcmx_lport_t port,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_JAM_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_jam_set.port = port;
	async->args.port_jam_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_l3_enable_get_async(
	bcmx_lport_t port,
	int * enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_L3_ENABLE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_enable_get.port = port;
	async->args.port_l3_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_l3_enable_set_async(
	bcmx_lport_t port,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_L3_ENABLE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_enable_set.port = port;
	async->args.port_l3_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_l3_modify_get_async(
	bcmx_lport_t port,
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_L3_MODIFY_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_modify_get.port = port;
	async->args.port_l3_modify_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_l3_modify_set_async(
	bcmx_lport_t port,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_L3_MODIFY_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_modify_set.port = port;
	async->args.port_l3_modify_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_l3_mtu_get_async(
	bcmx_lport_t port,
	int * size,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_L3_MTU_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_mtu_get.port = port;
	async->args.port_l3_mtu_get.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_l3_mtu_set_async(
	bcmx_lport_t port,
	int size,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_L3_MTU_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_l3_mtu_set.port = port;
	async->args.port_l3_mtu_set.size = size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_learn_get_async(
	bcmx_lport_t port,
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_LEARN_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_learn_get.port = port;
	async->args.port_learn_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_learn_modify_async(
	bcmx_lport_t port,
	uint32 add,
	uint32 remove,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_LEARN_MODIFY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_learn_modify.port = port;
	async->args.port_learn_modify.add = add;
	async->args.port_learn_modify.remove = remove;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_learn_set_async(
	bcmx_lport_t port,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_LEARN_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_learn_set.port = port;
	async->args.port_learn_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_link_failed_clear_async(
	bcm_gport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_LINK_FAILED_CLEAR;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_link_failed_clear.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_link_status_get_async(
	bcmx_lport_t port,
	int * status,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_LINK_STATUS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_link_status_get.port = port;
	async->args.port_link_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_linkscan_get_async(
	bcmx_lport_t port,
	int * linkscan,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_LINKSCAN_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_linkscan_get.port = port;
	async->args.port_linkscan_get.linkscan = linkscan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_linkscan_set_async(
	bcmx_lport_t port,
	int linkscan,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_LINKSCAN_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_linkscan_set.port = port;
	async->args.port_linkscan_set.linkscan = linkscan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_loopback_get_async(
	bcmx_lport_t port,
	int * loopback,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_LOOPBACK_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_loopback_get.port = port;
	async->args.port_loopback_get.loopback = loopback;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_loopback_set_async(
	bcmx_lport_t port,
	int loopback,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_LOOPBACK_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_loopback_set.port = port;
	async->args.port_loopback_set.loopback = loopback;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_lplist_populate_async(
	bcmx_lplist_t * list,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_LPLIST_POPULATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_lplist_populate.list = list;
	async->args.port_lplist_populate.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_master_get_async(
	bcmx_lport_t port,
	int * ms,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MASTER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_master_get.port = port;
	async->args.port_master_get.ms = ms;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_master_set_async(
	bcmx_lport_t port,
	int ms,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MASTER_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_master_set.port = port;
	async->args.port_master_set.ms = ms;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_match_add_async(
	bcm_gport_t port,
	bcmx_port_match_info_t * match,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MATCH_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_match_add.port = port;
	async->args.port_match_add.match = match;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_match_delete_async(
	bcm_gport_t port,
	bcmx_port_match_info_t * match,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MATCH_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_match_delete.port = port;
	async->args.port_match_delete.match = match;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_match_delete_all_async(
	bcm_gport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MATCH_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_match_delete_all.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_match_multi_get_async(
	bcm_gport_t port,
	int size,
	bcmx_port_match_info_t * match_array,
	int * count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MATCH_MULTI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_match_multi_get.port = port;
	async->args.port_match_multi_get.size = size;
	async->args.port_match_multi_get.match_array = match_array;
	async->args.port_match_multi_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_match_replace_async(
	bcm_gport_t port,
	bcmx_port_match_info_t * old_match,
	bcmx_port_match_info_t * new_match,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MATCH_REPLACE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_match_replace.port = port;
	async->args.port_match_replace.old_match = old_match;
	async->args.port_match_replace.new_match = new_match;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_match_set_async(
	bcm_gport_t port,
	int size,
	bcmx_port_match_info_t * match_array,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MATCH_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_match_set.port = port;
	async->args.port_match_set.size = size;
	async->args.port_match_set.match_array = match_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_mdix_get_async(
	bcmx_lport_t port,
	bcm_port_mdix_t * mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MDIX_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_mdix_get.port = port;
	async->args.port_mdix_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_mdix_set_async(
	bcmx_lport_t port,
	bcm_port_mdix_t mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MDIX_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_mdix_set.port = port;
	async->args.port_mdix_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_mdix_status_get_async(
	bcmx_lport_t port,
	bcm_port_mdix_status_t * status,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MDIX_STATUS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_mdix_status_get.port = port;
	async->args.port_mdix_status_get.status = status;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_medium_config_get_async(
	bcmx_lport_t port,
	bcm_port_medium_t medium,
	bcm_phy_config_t * config,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MEDIUM_CONFIG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_medium_config_get.port = port;
	async->args.port_medium_config_get.medium = medium;
	async->args.port_medium_config_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_medium_config_set_async(
	bcmx_lport_t port,
	bcm_port_medium_t medium,
	bcm_phy_config_t * config,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MEDIUM_CONFIG_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_medium_config_set.port = port;
	async->args.port_medium_config_set.medium = medium;
	async->args.port_medium_config_set.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_medium_get_async(
	bcmx_lport_t port,
	bcm_port_medium_t * medium,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MEDIUM_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_medium_get.port = port;
	async->args.port_medium_get.medium = medium;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_modid_enable_get_async(
	bcmx_lport_t port,
	int modid,
	int * enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MODID_ENABLE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_modid_enable_get.port = port;
	async->args.port_modid_enable_get.modid = modid;
	async->args.port_modid_enable_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_modid_enable_set_async(
	bcmx_lport_t port,
	int modid,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_MODID_ENABLE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_modid_enable_set.port = port;
	async->args.port_modid_enable_set.modid = modid;
	async->args.port_modid_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_pause_addr_get_async(
	bcmx_lport_t port,
	bcm_mac_t mac,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PAUSE_ADDR_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pause_addr_get.port = port;
	async->args.port_pause_addr_get.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_pause_addr_set_async(
	bcmx_lport_t port,
	bcm_mac_t mac,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PAUSE_ADDR_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pause_addr_set.port = port;
	async->args.port_pause_addr_set.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_pause_get_async(
	bcmx_lport_t port,
	int * pause_tx,
	int * pause_rx,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PAUSE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pause_get.port = port;
	async->args.port_pause_get.pause_tx = pause_tx;
	async->args.port_pause_get.pause_rx = pause_rx;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_pause_set_async(
	bcmx_lport_t port,
	int pause_tx,
	int pause_rx,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PAUSE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pause_set.port = port;
	async->args.port_pause_set.pause_tx = pause_tx;
	async->args.port_pause_set.pause_rx = pause_rx;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_pause_sym_get_async(
	bcmx_lport_t port,
	int * pause,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PAUSE_SYM_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pause_sym_get.port = port;
	async->args.port_pause_sym_get.pause = pause;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_pause_sym_set_async(
	bcmx_lport_t port,
	int pause,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PAUSE_SYM_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pause_sym_set.port = port;
	async->args.port_pause_sym_set.pause = pause;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_pfm_get_async(
	bcmx_lport_t port,
	int * mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PFM_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pfm_get.port = port;
	async->args.port_pfm_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_pfm_set_async(
	bcmx_lport_t port,
	int mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PFM_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_pfm_set.port = port;
	async->args.port_pfm_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_phy_control_get_async(
	bcmx_lport_t port,
	bcm_port_phy_control_t type,
	uint32 * value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PHY_CONTROL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_control_get.port = port;
	async->args.port_phy_control_get.type = type;
	async->args.port_phy_control_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_phy_control_set_async(
	bcmx_lport_t port,
	bcm_port_phy_control_t type,
	uint32 value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PHY_CONTROL_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_control_set.port = port;
	async->args.port_phy_control_set.type = type;
	async->args.port_phy_control_set.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_phy_get_async(
	bcmx_lport_t port,
	uint32 flags,
	uint32 phy_reg_addr,
	uint32 * phy_data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PHY_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_get.port = port;
	async->args.port_phy_get.flags = flags;
	async->args.port_phy_get.phy_reg_addr = phy_reg_addr;
	async->args.port_phy_get.phy_data = phy_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_phy_modify_async(
	bcmx_lport_t port,
	uint32 flags,
	uint32 phy_reg_addr,
	uint32 phy_data,
	uint32 phy_mask,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PHY_MODIFY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_modify.port = port;
	async->args.port_phy_modify.flags = flags;
	async->args.port_phy_modify.phy_reg_addr = phy_reg_addr;
	async->args.port_phy_modify.phy_data = phy_data;
	async->args.port_phy_modify.phy_mask = phy_mask;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_phy_set_async(
	bcmx_lport_t port,
	uint32 flags,
	uint32 phy_reg_addr,
	uint32 phy_data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PHY_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_set.port = port;
	async->args.port_phy_set.flags = flags;
	async->args.port_phy_set.phy_reg_addr = phy_reg_addr;
	async->args.port_phy_set.phy_data = phy_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_phy_timesync_config_get_async(
	bcm_gport_t port,
	bcmx_port_phy_timesync_config_t * conf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PHY_TIMESYNC_CONFIG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_timesync_config_get.port = port;
	async->args.port_phy_timesync_config_get.conf = conf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_phy_timesync_config_set_async(
	bcm_gport_t port,
	bcmx_port_phy_timesync_config_t * conf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PHY_TIMESYNC_CONFIG_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_timesync_config_set.port = port;
	async->args.port_phy_timesync_config_set.conf = conf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_phy_timesync_enhanced_capture_get_async(
	bcm_gport_t port,
	bcmx_port_phy_timesync_enhanced_capture_t * conf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PHY_TIMESYNC_ENHANCED_CAPTURE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_phy_timesync_enhanced_capture_get.port = port;
	async->args.port_phy_timesync_enhanced_capture_get.conf = conf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_priority_color_get_async(
	bcmx_lport_t port,
	int prio,
	bcm_color_t * color,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PRIORITY_COLOR_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_priority_color_get.port = port;
	async->args.port_priority_color_get.prio = prio;
	async->args.port_priority_color_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_priority_color_set_async(
	bcmx_lport_t port,
	int prio,
	bcm_color_t color,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PRIORITY_COLOR_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_priority_color_set.port = port;
	async->args.port_priority_color_set.prio = prio;
	async->args.port_priority_color_set.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_protocol_vlan_add_async(
	bcmx_lport_t port,
	bcm_port_frametype_t frame,
	bcm_port_ethertype_t ether,
	bcm_vlan_t vid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PROTOCOL_VLAN_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_protocol_vlan_add.port = port;
	async->args.port_protocol_vlan_add.frame = frame;
	async->args.port_protocol_vlan_add.ether = ether;
	async->args.port_protocol_vlan_add.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_protocol_vlan_delete_async(
	bcmx_lport_t port,
	bcm_port_frametype_t frame,
	bcm_port_ethertype_t ether,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PROTOCOL_VLAN_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_protocol_vlan_delete.port = port;
	async->args.port_protocol_vlan_delete.frame = frame;
	async->args.port_protocol_vlan_delete.ether = ether;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_protocol_vlan_delete_all_async(
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_PROTOCOL_VLAN_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_protocol_vlan_delete_all.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_queued_count_get_async(
	bcmx_lport_t port,
	uint32 * count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_QUEUED_COUNT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_queued_count_get.port = port;
	async->args.port_queued_count_get.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_rate_egress_get_async(
	bcmx_lport_t port,
	uint32 * kbits_sec,
	uint32 * kbits_burst,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_RATE_EGRESS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_egress_get.port = port;
	async->args.port_rate_egress_get.kbits_sec = kbits_sec;
	async->args.port_rate_egress_get.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_rate_egress_set_async(
	bcmx_lport_t port,
	uint32 kbits_sec,
	uint32 kbits_burst,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_RATE_EGRESS_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_egress_set.port = port;
	async->args.port_rate_egress_set.kbits_sec = kbits_sec;
	async->args.port_rate_egress_set.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_rate_ingress_get_async(
	bcmx_lport_t port,
	uint32 * kbits_sec,
	uint32 * kbits_burst,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_RATE_INGRESS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_ingress_get.port = port;
	async->args.port_rate_ingress_get.kbits_sec = kbits_sec;
	async->args.port_rate_ingress_get.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_rate_ingress_set_async(
	bcmx_lport_t port,
	uint32 kbits_sec,
	uint32 kbits_burst,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_RATE_INGRESS_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_ingress_set.port = port;
	async->args.port_rate_ingress_set.kbits_sec = kbits_sec;
	async->args.port_rate_ingress_set.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_rate_pause_get_async(
	bcmx_lport_t port,
	uint32 * kbits_pause,
	uint32 * kbits_resume,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_RATE_PAUSE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_pause_get.port = port;
	async->args.port_rate_pause_get.kbits_pause = kbits_pause;
	async->args.port_rate_pause_get.kbits_resume = kbits_resume;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_rate_pause_set_async(
	bcmx_lport_t port,
	uint32 kbits_pause,
	uint32 kbits_resume,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_RATE_PAUSE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_rate_pause_set.port = port;
	async->args.port_rate_pause_set.kbits_pause = kbits_pause;
	async->args.port_rate_pause_set.kbits_resume = kbits_resume;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_sample_rate_get_async(
	bcm_port_t port,
	int * ingress_rate,
	int * egress_rate,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_SAMPLE_RATE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_sample_rate_get.port = port;
	async->args.port_sample_rate_get.ingress_rate = ingress_rate;
	async->args.port_sample_rate_get.egress_rate = egress_rate;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_sample_rate_set_async(
	bcm_port_t port,
	int ingress_rate,
	int egress_rate,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_SAMPLE_RATE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_sample_rate_set.port = port;
	async->args.port_sample_rate_set.ingress_rate = ingress_rate;
	async->args.port_sample_rate_set.egress_rate = egress_rate;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_selective_get_async(
	bcmx_lport_t port,
	bcm_port_info_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_SELECTIVE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_selective_get.port = port;
	async->args.port_selective_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_selective_set_async(
	bcmx_lport_t port,
	bcm_port_info_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_SELECTIVE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_selective_set.port = port;
	async->args.port_selective_set.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_speed_get_async(
	bcmx_lport_t port,
	int * speed,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_SPEED_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_speed_get.port = port;
	async->args.port_speed_get.speed = speed;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_speed_max_async(
	bcmx_lport_t port,
	int * speed,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_SPEED_MAX;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_speed_max.port = port;
	async->args.port_speed_max.speed = speed;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_speed_set_async(
	bcmx_lport_t port,
	int speed,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_SPEED_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_speed_set.port = port;
	async->args.port_speed_set.speed = speed;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_stat_enable_set_async(
	bcm_gport_t port,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_STAT_ENABLE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_enable_set.port = port;
	async->args.port_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_stat_get_async(
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint64 * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_STAT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_get.port = port;
	async->args.port_stat_get.stat = stat;
	async->args.port_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_stat_get32_async(
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint32 * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_STAT_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_get32.port = port;
	async->args.port_stat_get32.stat = stat;
	async->args.port_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_stat_multi_get_async(
	bcm_gport_t port,
	int nstat,
	bcm_port_stat_t * stat_arr,
	uint64 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_STAT_MULTI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_multi_get.port = port;
	async->args.port_stat_multi_get.nstat = nstat;
	async->args.port_stat_multi_get.stat_arr = stat_arr;
	async->args.port_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_stat_multi_get32_async(
	bcm_gport_t port,
	int nstat,
	bcm_port_stat_t * stat_arr,
	uint32 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_STAT_MULTI_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_multi_get32.port = port;
	async->args.port_stat_multi_get32.nstat = nstat;
	async->args.port_stat_multi_get32.stat_arr = stat_arr;
	async->args.port_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_stat_multi_set_async(
	bcm_gport_t port,
	int nstat,
	bcm_port_stat_t * stat_arr,
	uint64 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_STAT_MULTI_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_multi_set.port = port;
	async->args.port_stat_multi_set.nstat = nstat;
	async->args.port_stat_multi_set.stat_arr = stat_arr;
	async->args.port_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_stat_multi_set32_async(
	bcm_gport_t port,
	int nstat,
	bcm_port_stat_t * stat_arr,
	uint32 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_STAT_MULTI_SET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_multi_set32.port = port;
	async->args.port_stat_multi_set32.nstat = nstat;
	async->args.port_stat_multi_set32.stat_arr = stat_arr;
	async->args.port_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_stat_set_async(
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint64 val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_STAT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_set.port = port;
	async->args.port_stat_set.stat = stat;
	async->args.port_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_stat_set32_async(
	bcm_gport_t port,
	bcm_port_stat_t stat,
	uint32 val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_STAT_SET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stat_set32.port = port;
	async->args.port_stat_set32.stat = stat;
	async->args.port_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_stp_get_async(
	bcmx_lport_t port,
	int * state,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_STP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stp_get.port = port;
	async->args.port_stp_get.state = state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_stp_set_async(
	bcmx_lport_t port,
	int state,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_STP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_stp_set.port = port;
	async->args.port_stp_set.state = state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_subsidiary_ports_get_async(
	bcm_gport_t port,
	bcmx_lplist_t * lplist,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_SUBSIDIARY_PORTS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_subsidiary_ports_get.port = port;
	async->args.port_subsidiary_ports_get.lplist = lplist;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_tgid_get_async(
	bcmx_lport_t port,
	int * tgid,
	int * psc,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_TGID_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tgid_get.port = port;
	async->args.port_tgid_get.tgid = tgid;
	async->args.port_tgid_get.psc = psc;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_tgid_set_async(
	bcmx_lport_t port,
	int tgid,
	int psc,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_TGID_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tgid_set.port = port;
	async->args.port_tgid_set.tgid = tgid;
	async->args.port_tgid_set.psc = psc;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_tpid_add_async(
	bcmx_lport_t port,
	uint16 tpid,
	int color_select,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_TPID_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tpid_add.port = port;
	async->args.port_tpid_add.tpid = tpid;
	async->args.port_tpid_add.color_select = color_select;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_tpid_delete_async(
	bcmx_lport_t port,
	uint16 tpid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_TPID_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tpid_delete.port = port;
	async->args.port_tpid_delete.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_tpid_delete_all_async(
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_TPID_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tpid_delete_all.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_tpid_get_async(
	bcmx_lport_t port,
	uint16 * tpid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_TPID_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tpid_get.port = port;
	async->args.port_tpid_get.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_tpid_set_async(
	bcmx_lport_t port,
	uint16 tpid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_TPID_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_tpid_set.port = port;
	async->args.port_tpid_set.tpid = tpid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_untagged_priority_get_async(
	bcmx_lport_t port,
	int * priority,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_UNTAGGED_PRIORITY_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_untagged_priority_get.port = port;
	async->args.port_untagged_priority_get.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_untagged_priority_set_async(
	bcmx_lport_t port,
	int priority,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_UNTAGGED_PRIORITY_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_untagged_priority_set.port = port;
	async->args.port_untagged_priority_set.priority = priority;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_untagged_vlan_get_async(
	bcmx_lport_t port,
	bcm_vlan_t * vid_ptr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_UNTAGGED_VLAN_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_untagged_vlan_get.port = port;
	async->args.port_untagged_vlan_get.vid_ptr = vid_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_untagged_vlan_set_async(
	bcmx_lport_t port,
	bcm_vlan_t vid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_UNTAGGED_VLAN_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_untagged_vlan_set.port = port;
	async->args.port_untagged_vlan_set.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_update_async(
	bcmx_lport_t port,
	int link,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_UPDATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_update.port = port;
	async->args.port_update.link = link;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_vlan_inner_tag_get_async(
	bcmx_lport_t port,
	uint16 * inner_tag,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_VLAN_INNER_TAG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_inner_tag_get.port = port;
	async->args.port_vlan_inner_tag_get.inner_tag = inner_tag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_vlan_inner_tag_set_async(
	bcmx_lport_t port,
	uint16 inner_tag,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_VLAN_INNER_TAG_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_inner_tag_set.port = port;
	async->args.port_vlan_inner_tag_set.inner_tag = inner_tag;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_vlan_member_get_async(
	bcmx_lport_t port,
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_VLAN_MEMBER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_member_get.port = port;
	async->args.port_vlan_member_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_vlan_member_set_async(
	bcmx_lport_t port,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_VLAN_MEMBER_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_member_set.port = port;
	async->args.port_vlan_member_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_vlan_priority_map_get_async(
	bcmx_lport_t port,
	int pkt_pri,
	int cfi,
	int * internal_pri,
	bcm_color_t * color,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_VLAN_PRIORITY_MAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_priority_map_get.port = port;
	async->args.port_vlan_priority_map_get.pkt_pri = pkt_pri;
	async->args.port_vlan_priority_map_get.cfi = cfi;
	async->args.port_vlan_priority_map_get.internal_pri = internal_pri;
	async->args.port_vlan_priority_map_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_vlan_priority_map_set_async(
	bcmx_lport_t port,
	int pkt_pri,
	int cfi,
	int internal_pri,
	bcm_color_t color,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_VLAN_PRIORITY_MAP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_priority_map_set.port = port;
	async->args.port_vlan_priority_map_set.pkt_pri = pkt_pri;
	async->args.port_vlan_priority_map_set.cfi = cfi;
	async->args.port_vlan_priority_map_set.internal_pri = internal_pri;
	async->args.port_vlan_priority_map_set.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_vlan_priority_unmap_get_async(
	bcmx_lport_t port,
	int internal_pri,
	bcm_color_t color,
	int * pkt_pri,
	int * cfi,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_VLAN_PRIORITY_UNMAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_priority_unmap_get.port = port;
	async->args.port_vlan_priority_unmap_get.internal_pri = internal_pri;
	async->args.port_vlan_priority_unmap_get.color = color;
	async->args.port_vlan_priority_unmap_get.pkt_pri = pkt_pri;
	async->args.port_vlan_priority_unmap_get.cfi = cfi;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_port_vlan_priority_unmap_set_async(
	bcmx_lport_t port,
	int internal_pri,
	bcm_color_t color,
	int pkt_pri,
	int cfi,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PORT_VLAN_PRIORITY_UNMAP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.port_vlan_priority_unmap_set.port = port;
	async->args.port_vlan_priority_unmap_set.internal_pri = internal_pri;
	async->args.port_vlan_priority_unmap_set.color = color;
	async->args.port_vlan_priority_unmap_set.pkt_pri = pkt_pri;
	async->args.port_vlan_priority_unmap_set.cfi = cfi;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcmx_proxy_cleanup_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PROXY_CLEANUP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_proxy_client_set_async(
	bcmx_lport_t client_port,
	bcm_proxy_proto_type_t proto_type,
	bcmx_lport_t server_lport,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PROXY_CLIENT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_client_set.client_port = client_port;
	async->args.proxy_client_set.proto_type = proto_type;
	async->args.proxy_client_set.server_lport = server_lport;
	async->args.proxy_client_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_proxy_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PROXY_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_proxy_server_get_async(
	bcmx_lport_t server_lport,
	bcm_proxy_mode_t mode,
	int * enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PROXY_SERVER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_server_get.server_lport = server_lport;
	async->args.proxy_server_get.mode = mode;
	async->args.proxy_server_get.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_proxy_server_set_async(
	bcmx_lport_t server_lport,
	bcm_proxy_mode_t mode,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_PROXY_SERVER_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.proxy_server_set.server_lport = server_lport;
	async->args.proxy_server_set.mode = mode;
	async->args.proxy_server_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcmx_qos_detach_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_QOS_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_qos_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_QOS_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_qos_map_add_async(
	uint32 flags,
	bcmx_qos_map_t * map,
	int map_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_QOS_MAP_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_map_add.flags = flags;
	async->args.qos_map_add.map = map;
	async->args.qos_map_add.map_id = map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_qos_map_create_async(
	uint32 flags,
	int * map_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_QOS_MAP_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_map_create.flags = flags;
	async->args.qos_map_create.map_id = map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_qos_map_delete_async(
	uint32 flags,
	bcmx_qos_map_t * map,
	int map_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_QOS_MAP_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_map_delete.flags = flags;
	async->args.qos_map_delete.map = map;
	async->args.qos_map_delete.map_id = map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_qos_map_destroy_async(
	int map_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_QOS_MAP_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_map_destroy.map_id = map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_qos_map_multi_get_async(
	uint32 flags,
	int map_id,
	int array_size,
	bcmx_qos_map_t * array,
	int * array_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_QOS_MAP_MULTI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_map_multi_get.flags = flags;
	async->args.qos_map_multi_get.map_id = map_id;
	async->args.qos_map_multi_get.array_size = array_size;
	async->args.qos_map_multi_get.array = array;
	async->args.qos_map_multi_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_qos_multi_get_async(
	int array_size,
	int * map_ids_array,
	int * flags_array,
	int * array_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_QOS_MULTI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_multi_get.array_size = array_size;
	async->args.qos_multi_get.map_ids_array = map_ids_array;
	async->args.qos_multi_get.flags_array = flags_array;
	async->args.qos_multi_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_qos_port_map_get_async(
	bcm_gport_t port,
	int * ing_map,
	int * egr_map,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_QOS_PORT_MAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_port_map_get.port = port;
	async->args.qos_port_map_get.ing_map = ing_map;
	async->args.qos_port_map_get.egr_map = egr_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_qos_port_map_set_async(
	bcm_gport_t port,
	int ing_map,
	int egr_map,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_QOS_PORT_MAP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_port_map_set.port = port;
	async->args.qos_port_map_set.ing_map = ing_map;
	async->args.qos_port_map_set.egr_map = egr_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_qos_port_vlan_map_get_async(
	bcm_gport_t port,
	bcm_vlan_t vid,
	int * ing_map,
	int * egr_map,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_QOS_PORT_VLAN_MAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_port_vlan_map_get.port = port;
	async->args.qos_port_vlan_map_get.vid = vid;
	async->args.qos_port_vlan_map_get.ing_map = ing_map;
	async->args.qos_port_vlan_map_get.egr_map = egr_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_qos_port_vlan_map_set_async(
	bcm_gport_t port,
	bcm_vlan_t vid,
	int ing_map,
	int egr_map,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_QOS_PORT_VLAN_MAP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.qos_port_vlan_map_set.port = port;
	async->args.qos_port_vlan_map_set.vid = vid;
	async->args.qos_port_vlan_map_set.ing_map = ing_map;
	async->args.qos_port_vlan_map_set.egr_map = egr_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rate_bandwidth_get_async(
	bcmx_lport_t port,
	int flags,
	uint32 * kbits_sec,
	uint32 * kbits_burst,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RATE_BANDWIDTH_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_bandwidth_get.port = port;
	async->args.rate_bandwidth_get.flags = flags;
	async->args.rate_bandwidth_get.kbits_sec = kbits_sec;
	async->args.rate_bandwidth_get.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rate_bandwidth_set_async(
	bcmx_lport_t port,
	int flags,
	uint32 kbits_sec,
	uint32 kbits_burst,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RATE_BANDWIDTH_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_bandwidth_set.port = port;
	async->args.rate_bandwidth_set.flags = flags;
	async->args.rate_bandwidth_set.kbits_sec = kbits_sec;
	async->args.rate_bandwidth_set.kbits_burst = kbits_burst;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rate_bcast_get_async(
	int * limit,
	int * flags,
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RATE_BCAST_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_bcast_get.limit = limit;
	async->args.rate_bcast_get.flags = flags;
	async->args.rate_bcast_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rate_bcast_set_async(
	int limit,
	int flags,
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RATE_BCAST_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_bcast_set.limit = limit;
	async->args.rate_bcast_set.flags = flags;
	async->args.rate_bcast_set.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rate_dlfbc_get_async(
	int * limit,
	int * flags,
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RATE_DLFBC_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_dlfbc_get.limit = limit;
	async->args.rate_dlfbc_get.flags = flags;
	async->args.rate_dlfbc_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rate_dlfbc_set_async(
	int limit,
	int flags,
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RATE_DLFBC_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_dlfbc_set.limit = limit;
	async->args.rate_dlfbc_set.flags = flags;
	async->args.rate_dlfbc_set.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rate_get_async(
	int * val,
	int * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RATE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_get.val = val;
	async->args.rate_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rate_mcast_get_async(
	int * limit,
	int * flags,
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RATE_MCAST_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_mcast_get.limit = limit;
	async->args.rate_mcast_get.flags = flags;
	async->args.rate_mcast_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rate_mcast_set_async(
	int limit,
	int flags,
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RATE_MCAST_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_mcast_set.limit = limit;
	async->args.rate_mcast_set.flags = flags;
	async->args.rate_mcast_set.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rate_set_async(
	int val,
	int flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RATE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_set.val = val;
	async->args.rate_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rate_type_get_async(
	bcm_rate_limit_t * rl,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RATE_TYPE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_type_get.rl = rl;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rate_type_set_async(
	bcm_rate_limit_t * rl,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RATE_TYPE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rate_type_set.rl = rl;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rx_control_get_async(
	bcm_rx_control_t type,
	int * arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RX_CONTROL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_control_get.type = type;
	async->args.rx_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rx_control_set_async(
	bcm_rx_control_t type,
	int arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RX_CONTROL_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_control_set.type = type;
	async->args.rx_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rx_device_add_async(
	int unit,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RX_DEVICE_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_device_add.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rx_device_remove_async(
	int unit,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RX_DEVICE_REMOVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_device_remove.unit = unit;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rx_register_async(
	const char * name,
	bcm_rx_cb_f fn,
	int priority,
	void * cookie,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RX_REGISTER;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_register.name = (char *)name;
	async->args.rx_register.fn = fn;
	async->args.rx_register.priority = priority;
	async->args.rx_register.cookie = cookie;
	async->args.rx_register.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rx_running_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RX_RUNNING;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rx_start_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RX_START;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rx_stop_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RX_STOP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_rx_unregister_async(
	bcm_rx_cb_f fn,
	int pri,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_RX_UNREGISTER;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.rx_unregister.fn = fn;
	async->args.rx_unregister.pri = pri;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stat_clear_async(
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STAT_CLEAR;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_clear.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stat_custom_add_async(
	bcmx_lport_t port,
	bcm_stat_val_t type,
	bcm_custom_stat_trigger_t trigger,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STAT_CUSTOM_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_custom_add.port = port;
	async->args.stat_custom_add.type = type;
	async->args.stat_custom_add.trigger = trigger;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stat_custom_check_async(
	bcmx_lport_t port,
	bcm_stat_val_t type,
	bcm_custom_stat_trigger_t trigger,
	int * result,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STAT_CUSTOM_CHECK;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_custom_check.port = port;
	async->args.stat_custom_check.type = type;
	async->args.stat_custom_check.trigger = trigger;
	async->args.stat_custom_check.result = result;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stat_custom_delete_async(
	bcmx_lport_t port,
	bcm_stat_val_t type,
	bcm_custom_stat_trigger_t trigger,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STAT_CUSTOM_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_custom_delete.port = port;
	async->args.stat_custom_delete.type = type;
	async->args.stat_custom_delete.trigger = trigger;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stat_custom_delete_all_async(
	bcmx_lport_t port,
	bcm_stat_val_t type,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STAT_CUSTOM_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_custom_delete_all.port = port;
	async->args.stat_custom_delete_all.type = type;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stat_custom_get_async(
	bcmx_lport_t port,
	bcm_stat_val_t type,
	uint32 * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STAT_CUSTOM_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_custom_get.port = port;
	async->args.stat_custom_get.type = type;
	async->args.stat_custom_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stat_custom_set_async(
	bcmx_lport_t port,
	bcm_stat_val_t type,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STAT_CUSTOM_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_custom_set.port = port;
	async->args.stat_custom_set.type = type;
	async->args.stat_custom_set.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stat_get_async(
	bcmx_lport_t port,
	bcm_stat_val_t type,
	uint64 * value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STAT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_get.port = port;
	async->args.stat_get.type = type;
	async->args.stat_get.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stat_get32_async(
	bcmx_lport_t port,
	bcm_stat_val_t type,
	uint32 * value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STAT_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_get32.port = port;
	async->args.stat_get32.type = type;
	async->args.stat_get32.value = value;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stat_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STAT_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stat_multi_get_async(
	bcm_gport_t port,
	int nstat,
	bcm_stat_val_t * stat_arr,
	uint64 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STAT_MULTI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_multi_get.port = port;
	async->args.stat_multi_get.nstat = nstat;
	async->args.stat_multi_get.stat_arr = stat_arr;
	async->args.stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stat_multi_get32_async(
	bcm_gport_t port,
	int nstat,
	bcm_stat_val_t * stat_arr,
	uint32 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STAT_MULTI_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stat_multi_get32.port = port;
	async->args.stat_multi_get32.nstat = nstat;
	async->args.stat_multi_get32.stat_arr = stat_arr;
	async->args.stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stat_sync_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STAT_SYNC;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_count_get_async(
	int * max_stg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_COUNT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_count_get.max_stg = max_stg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_create_async(
	bcm_stg_t * stg_ptr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_create.stg_ptr = stg_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_create_id_async(
	bcm_stg_t stg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_CREATE_ID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_create_id.stg = stg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_default_get_async(
	bcm_stg_t * stg_ptr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_DEFAULT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_default_get.stg_ptr = stg_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_default_set_async(
	bcm_stg_t stg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_DEFAULT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_default_set.stg = stg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_destroy_async(
	bcm_stg_t stg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_destroy.stg = stg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_list_async(
	bcm_stg_t ** list,
	int * count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_LIST;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_list.list = (bcm_stg_t * *)list;
	async->args.stg_list.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_list_destroy_async(
	bcm_stg_t * list,
	int count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_LIST_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_list_destroy.list = list;
	async->args.stg_list_destroy.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_stp_get_async(
	bcm_stg_t stg,
	bcmx_lport_t port,
	int * stp_state,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_STP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_stp_get.stg = stg;
	async->args.stg_stp_get.port = port;
	async->args.stg_stp_get.stp_state = stp_state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_stp_set_async(
	bcm_stg_t stg,
	bcmx_lport_t port,
	int stp_state,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_STP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_stp_set.stg = stg;
	async->args.stg_stp_set.port = port;
	async->args.stg_stp_set.stp_state = stp_state;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_vlan_add_async(
	bcm_stg_t stg,
	bcm_vlan_t vid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_VLAN_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_vlan_add.stg = stg;
	async->args.stg_vlan_add.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_vlan_list_async(
	bcm_stg_t stg,
	bcm_vlan_t ** list,
	int * count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_VLAN_LIST;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_vlan_list.stg = stg;
	async->args.stg_vlan_list.list = (bcm_vlan_t * *)list;
	async->args.stg_vlan_list.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_vlan_list_destroy_async(
	bcm_vlan_t * list,
	int count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_VLAN_LIST_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_vlan_list_destroy.list = list;
	async->args.stg_vlan_list_destroy.count = count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_vlan_remove_async(
	bcm_stg_t stg,
	bcm_vlan_t vid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_VLAN_REMOVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_vlan_remove.stg = stg;
	async->args.stg_vlan_remove.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_stg_vlan_remove_all_async(
	bcm_stg_t stg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_STG_VLAN_REMOVE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.stg_vlan_remove_all.stg = stg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_subport_cleanup_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SUBPORT_CLEANUP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_subport_group_create_async(
	bcmx_subport_group_config_t * config,
	bcm_gport_t * group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SUBPORT_GROUP_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_group_create.config = config;
	async->args.subport_group_create.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_subport_group_destroy_async(
	bcm_gport_t group,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SUBPORT_GROUP_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_group_destroy.group = group;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_subport_group_get_async(
	bcm_gport_t group,
	bcmx_subport_group_config_t * config,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SUBPORT_GROUP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_group_get.group = group;
	async->args.subport_group_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_subport_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SUBPORT_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_subport_port_add_async(
	bcmx_subport_config_t * config,
	bcm_gport_t * port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SUBPORT_PORT_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_port_add.config = config;
	async->args.subport_port_add.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_subport_port_delete_async(
	bcm_gport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SUBPORT_PORT_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_port_delete.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_subport_port_get_async(
	bcm_gport_t port,
	bcmx_subport_config_t * config,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SUBPORT_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.subport_port_get.port = port;
	async->args.subport_port_get.config = config;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_switch_control_get_async(
	bcm_switch_control_t type,
	int * arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SWITCH_CONTROL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_control_get.type = type;
	async->args.switch_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_switch_control_port_get_async(
	bcmx_lport_t port,
	bcm_switch_control_t type,
	int * arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SWITCH_CONTROL_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_control_port_get.port = port;
	async->args.switch_control_port_get.type = type;
	async->args.switch_control_port_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_switch_control_port_set_async(
	bcmx_lport_t port,
	bcm_switch_control_t type,
	int arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SWITCH_CONTROL_PORT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_control_port_set.port = port;
	async->args.switch_control_port_set.type = type;
	async->args.switch_control_port_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_switch_control_set_async(
	bcm_switch_control_t type,
	int arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SWITCH_CONTROL_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_control_set.type = type;
	async->args.switch_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_switch_rcpu_encap_priority_map_get_async(
	uint32 flags,
	int internal_cpu_pri,
	int * encap_pri,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SWITCH_RCPU_ENCAP_PRIORITY_MAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_rcpu_encap_priority_map_get.flags = flags;
	async->args.switch_rcpu_encap_priority_map_get.internal_cpu_pri = internal_cpu_pri;
	async->args.switch_rcpu_encap_priority_map_get.encap_pri = encap_pri;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_switch_rcpu_encap_priority_map_set_async(
	uint32 flags,
	int internal_cpu_pri,
	int encap_pri,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_SWITCH_RCPU_ENCAP_PRIORITY_MAP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.switch_rcpu_encap_priority_map_set.flags = flags;
	async->args.switch_rcpu_encap_priority_map_set.internal_cpu_pri = internal_cpu_pri;
	async->args.switch_rcpu_encap_priority_map_set.encap_pri = encap_pri;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcmx_trill_cleanup_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_CLEANUP;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_multicast_delete_all_async(
	bcm_trill_name_t root_name,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_MULTICAST_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_delete_all.root_name = root_name;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_multicast_entry_add_async(
	bcm_trill_multicast_entry_t * trill_mc_entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_MULTICAST_ENTRY_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_entry_add.trill_mc_entry = trill_mc_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_multicast_entry_delete_async(
	bcm_trill_multicast_entry_t * trill_mc_entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_MULTICAST_ENTRY_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_entry_delete.trill_mc_entry = trill_mc_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_multicast_entry_get_async(
	bcm_trill_multicast_entry_t * trill_mc_entry,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_MULTICAST_ENTRY_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_entry_get.trill_mc_entry = trill_mc_entry;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_multicast_source_add_async(
	bcm_trill_name_t root_name,
	bcm_trill_name_t source_rbridge_name,
	bcm_gport_t port,
	bcm_if_t encap_intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_MULTICAST_SOURCE_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_source_add.root_name = root_name;
	async->args.trill_multicast_source_add.source_rbridge_name = source_rbridge_name;
	async->args.trill_multicast_source_add.port = port;
	async->args.trill_multicast_source_add.encap_intf = encap_intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_multicast_source_delete_async(
	bcm_trill_name_t root_name,
	bcm_trill_name_t source_rbridge_name,
	bcm_gport_t port,
	bcm_if_t encap_intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_MULTICAST_SOURCE_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_source_delete.root_name = root_name;
	async->args.trill_multicast_source_delete.source_rbridge_name = source_rbridge_name;
	async->args.trill_multicast_source_delete.port = port;
	async->args.trill_multicast_source_delete.encap_intf = encap_intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_multicast_source_get_async(
	bcm_trill_name_t root_name,
	bcm_trill_name_t source_rbridge_name,
	bcm_gport_t * port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_MULTICAST_SOURCE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_multicast_source_get.root_name = root_name;
	async->args.trill_multicast_source_get.source_rbridge_name = source_rbridge_name;
	async->args.trill_multicast_source_get.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_port_add_async(
	bcmx_trill_port_t * trill_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_PORT_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_port_add.trill_port = trill_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_port_delete_async(
	bcm_gport_t trill_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_PORT_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_port_delete.trill_port_id = trill_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_port_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_PORT_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_port_get_async(
	bcmx_trill_port_t * trill_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_port_get.trill_port = trill_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_port_get_all_async(
	int port_max,
	bcmx_trill_port_t * port_array,
	int * port_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_PORT_GET_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_port_get_all.port_max = port_max;
	async->args.trill_port_get_all.port_array = port_array;
	async->args.trill_port_get_all.port_count = port_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_stat_clear_async(
	bcm_gport_t port,
	bcm_trill_stat_t stat,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_STAT_CLEAR;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_stat_clear.port = port;
	async->args.trill_stat_clear.stat = stat;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_stat_get_async(
	bcm_gport_t port,
	bcm_trill_stat_t stat,
	uint64 * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_STAT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_stat_get.port = port;
	async->args.trill_stat_get.stat = stat;
	async->args.trill_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trill_stat_get32_async(
	bcm_gport_t port,
	bcm_trill_stat_t stat,
	uint32 * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRILL_STAT_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trill_stat_get32.port = port;
	async->args.trill_stat_get32.stat = stat;
	async->args.trill_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcmx_trunk_chip_info_get_async(
	bcm_trunk_chip_info_t * ta_info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_CHIP_INFO_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_chip_info_get.ta_info = ta_info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_create_async(
	bcm_trunk_t * tid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_create.tid = tid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_create_id_async(
	bcm_trunk_t tid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_CREATE_ID;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_create_id.tid = tid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_destroy_async(
	bcm_trunk_t tid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_destroy.tid = tid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_detach_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_egress_get_async(
	bcm_trunk_t tid,
	bcmx_lplist_t * lplist,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_EGRESS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_egress_get.tid = tid;
	async->args.trunk_egress_get.lplist = lplist;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_egress_set_async(
	bcm_trunk_t tid,
	bcmx_lplist_t lplist,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_EGRESS_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_egress_set.tid = tid;
	async->args.trunk_egress_set.lplist = lplist;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_failover_get_async(
	bcm_trunk_t tid,
	bcm_gport_t failport,
	int * psc,
	uint32 * flags,
	int array_size,
	bcm_gport_t * fail_to_array,
	int * array_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_FAILOVER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_failover_get.tid = tid;
	async->args.trunk_failover_get.failport = failport;
	async->args.trunk_failover_get.psc = psc;
	async->args.trunk_failover_get.flags = flags;
	async->args.trunk_failover_get.array_size = array_size;
	async->args.trunk_failover_get.fail_to_array = fail_to_array;
	async->args.trunk_failover_get.array_count = array_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_failover_set_async(
	bcm_trunk_t tid,
	bcm_gport_t failport,
	int psc,
	uint32 flags,
	int count,
	bcm_gport_t * fail_to_array,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_FAILOVER_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_failover_set.tid = tid;
	async->args.trunk_failover_set.failport = failport;
	async->args.trunk_failover_set.psc = psc;
	async->args.trunk_failover_set.flags = flags;
	async->args.trunk_failover_set.count = count;
	async->args.trunk_failover_set.fail_to_array = fail_to_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_find_async(
	bcmx_lport_t port,
	bcm_trunk_t * tid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_FIND;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_find.port = port;
	async->args.trunk_find.tid = tid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_get_async(
	bcm_trunk_t tid,
	bcmx_trunk_add_info_t * t_data,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_get.tid = tid;
	async->args.trunk_get.t_data = t_data;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_mcast_join_async(
	bcm_trunk_t tid,
	bcm_vlan_t vid,
	bcm_mac_t mac,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_MCAST_JOIN;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_mcast_join.tid = tid;
	async->args.trunk_mcast_join.vid = vid;
	async->args.trunk_mcast_join.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_member_add_async(
	bcm_trunk_t tid,
	bcmx_trunk_member_t * member,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_MEMBER_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_member_add.tid = tid;
	async->args.trunk_member_add.member = member;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_member_delete_async(
	bcm_trunk_t tid,
	bcmx_trunk_member_t * member,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_MEMBER_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_member_delete.tid = tid;
	async->args.trunk_member_delete.member = member;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_member_delete_all_async(
	bcm_trunk_t tid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_MEMBER_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_member_delete_all.tid = tid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_member_get_async(
	bcm_trunk_t tid,
	int member_max,
	bcmx_trunk_member_t * member_array,
	int * member_count,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_MEMBER_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_member_get.tid = tid;
	async->args.trunk_member_get.member_max = member_max;
	async->args.trunk_member_get.member_array = member_array;
	async->args.trunk_member_get.member_count = member_count;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_member_set_async(
	bcm_trunk_t tid,
	int member_count,
	bcmx_trunk_member_t * member_array,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_MEMBER_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_member_set.tid = tid;
	async->args.trunk_member_set.member_count = member_count;
	async->args.trunk_member_set.member_array = member_array;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_psc_get_async(
	bcm_trunk_t tid,
	int * psc,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_PSC_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_psc_get.tid = tid;
	async->args.trunk_psc_get.psc = psc;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_psc_set_async(
	bcm_trunk_t tid,
	int psc,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_PSC_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_psc_set.tid = tid;
	async->args.trunk_psc_set.psc = psc;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_trunk_set_async(
	bcm_trunk_t tid,
	bcmx_trunk_add_info_t * add_info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TRUNK_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.trunk_set.tid = tid;
	async->args.trunk_set.add_info = add_info;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcmx_tunnel_config_get_async(
	bcmx_tunnel_config_t * tconfig,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_CONFIG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_config_get.tconfig = tconfig;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_config_set_async(
	bcmx_tunnel_config_t * tconfig,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_CONFIG_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_config_set.tconfig = tconfig;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_dscp_map_create_async(
	uint32 flags,
	int * dscp_map_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_DSCP_MAP_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_dscp_map_create.flags = flags;
	async->args.tunnel_dscp_map_create.dscp_map_id = dscp_map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_dscp_map_destroy_async(
	int dscp_map_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_DSCP_MAP_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_dscp_map_destroy.dscp_map_id = dscp_map_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_dscp_map_get_async(
	int dscp_map_id,
	bcm_tunnel_dscp_map_t * dscp_map,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_DSCP_MAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_dscp_map_get.dscp_map_id = dscp_map_id;
	async->args.tunnel_dscp_map_get.dscp_map = dscp_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_dscp_map_port_get_async(
	bcmx_lport_t port,
	bcm_tunnel_dscp_map_t * dscp_map,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_DSCP_MAP_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_dscp_map_port_get.port = port;
	async->args.tunnel_dscp_map_port_get.dscp_map = dscp_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_dscp_map_port_set_async(
	bcmx_lport_t port,
	bcm_tunnel_dscp_map_t * dscp_map,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_DSCP_MAP_PORT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_dscp_map_port_set.port = port;
	async->args.tunnel_dscp_map_port_set.dscp_map = dscp_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_dscp_map_set_async(
	int dscp_map_id,
	bcm_tunnel_dscp_map_t * dscp_map,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_DSCP_MAP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_dscp_map_set.dscp_map_id = dscp_map_id;
	async->args.tunnel_dscp_map_set.dscp_map = dscp_map;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_initiator_clear_async(
	bcmx_l3_intf_t * intf,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_INITIATOR_CLEAR;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_initiator_clear.intf = intf;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_initiator_get_async(
	bcmx_l3_intf_t * intf,
	bcmx_tunnel_initiator_t * tunnel,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_INITIATOR_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_initiator_get.intf = intf;
	async->args.tunnel_initiator_get.tunnel = tunnel;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_initiator_set_async(
	bcmx_l3_intf_t * intf,
	bcmx_tunnel_initiator_t * tunnel,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_INITIATOR_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_initiator_set.intf = intf;
	async->args.tunnel_initiator_set.tunnel = tunnel;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_terminator_add_async(
	bcmx_tunnel_terminator_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_TERMINATOR_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_terminator_delete_async(
	bcmx_tunnel_terminator_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_TERMINATOR_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_delete.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_terminator_get_async(
	bcmx_tunnel_terminator_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_TERMINATOR_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_terminator_update_async(
	bcmx_tunnel_terminator_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_TERMINATOR_UPDATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_update.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_terminator_vlan_get_async(
	bcm_gport_t tunnel,
	bcm_vlan_vector_t * vlan_vec,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_TERMINATOR_VLAN_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_vlan_get.tunnel = tunnel;
	async->args.tunnel_terminator_vlan_get.vlan_vec = vlan_vec;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tunnel_terminator_vlan_set_async(
	bcm_gport_t tunnel,
	bcm_vlan_vector_t vlan_vec,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TUNNEL_TERMINATOR_VLAN_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tunnel_terminator_vlan_set.tunnel = tunnel;
	async->args.tunnel_terminator_vlan_set.vlan_vec = (uint32 *)vlan_vec;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */

void
bcmx_tx_async(
	bcm_pkt_t * pkt,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TX;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx.pkt = pkt;
	async->args.tx.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tx_flood_async(
	bcm_pkt_t * pkt,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TX_FLOOD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_flood.pkt = pkt;
	async->args.tx_flood.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tx_lplist_async(
	bcm_pkt_t * pkt,
	bcmx_lplist_t * tx_ports,
	bcmx_lplist_t * untagged_ports,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TX_LPLIST;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_lplist.pkt = pkt;
	async->args.tx_lplist.tx_ports = tx_ports;
	async->args.tx_lplist.untagged_ports = untagged_ports;
	async->args.tx_lplist.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tx_pkt_l3_set_async(
	bcm_pkt_t * pkt,
	int l3,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TX_PKT_L3_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_pkt_l3_set.pkt = pkt;
	async->args.tx_pkt_l3_set.l3 = l3;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tx_pkt_untagged_set_async(
	bcm_pkt_t * pkt,
	int untagged,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TX_PKT_UNTAGGED_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_pkt_untagged_set.pkt = pkt;
	async->args.tx_pkt_untagged_set.untagged = untagged;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tx_port_list_async(
	bcmx_lplist_t * lplist,
	bcm_pkt_t * pkt,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TX_PORT_LIST;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_port_list.lplist = lplist;
	async->args.tx_port_list.pkt = pkt;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_tx_uc_async(
	bcm_pkt_t * pkt,
	bcmx_lport_t d_port,
	uint32 flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_TX_UC;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.tx_uc.pkt = pkt;
	async->args.tx_uc.d_port = d_port;
	async->args.tx_uc.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_uport_create_callback_set_async(
	bcmx_uport_create_f create_callback,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_UPORT_CREATE_CALLBACK_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.uport_create_callback_set.create_callback = create_callback;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_block_get_async(
	bcm_vlan_t vlan,
	bcmx_vlan_block_t * vlan_block,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_BLOCK_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_block_get.vlan = vlan;
	async->args.vlan_block_get.vlan_block = vlan_block;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_block_set_async(
	bcm_vlan_t vlan,
	bcmx_vlan_block_t * vlan_block,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_BLOCK_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_block_set.vlan = vlan;
	async->args.vlan_block_set.vlan_block = vlan_block;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_control_get_async(
	bcm_vlan_control_t type,
	int * arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_CONTROL_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_get.type = type;
	async->args.vlan_control_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_control_port_get_async(
	bcmx_lport_t port,
	bcm_vlan_control_port_t type,
	int * arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_CONTROL_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_port_get.port = port;
	async->args.vlan_control_port_get.type = type;
	async->args.vlan_control_port_get.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_control_port_set_async(
	bcmx_lport_t port,
	bcm_vlan_control_port_t type,
	int arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_CONTROL_PORT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_port_set.port = port;
	async->args.vlan_control_port_set.type = type;
	async->args.vlan_control_port_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_control_set_async(
	bcm_vlan_control_t type,
	int arg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_CONTROL_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_set.type = type;
	async->args.vlan_control_set.arg = arg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_control_vlan_get_async(
	bcm_vlan_t vlan,
	bcm_vlan_control_vlan_t * control,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_CONTROL_VLAN_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_vlan_get.vlan = vlan;
	async->args.vlan_control_vlan_get.control = control;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_control_vlan_set_async(
	bcm_vlan_t vlan,
	bcm_vlan_control_vlan_t control,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_CONTROL_VLAN_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_control_vlan_set.vlan = vlan;
	async->args.vlan_control_vlan_set.control = control;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_create_async(
	bcm_vlan_t vid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_create.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_cross_connect_add_async(
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_gport_t port_1,
	bcm_gport_t port_2,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_CROSS_CONNECT_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_cross_connect_add.outer_vlan = outer_vlan;
	async->args.vlan_cross_connect_add.inner_vlan = inner_vlan;
	async->args.vlan_cross_connect_add.port_1 = port_1;
	async->args.vlan_cross_connect_add.port_2 = port_2;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_cross_connect_delete_async(
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_CROSS_CONNECT_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_cross_connect_delete.outer_vlan = outer_vlan;
	async->args.vlan_cross_connect_delete.inner_vlan = inner_vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_cross_connect_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_CROSS_CONNECT_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_default_get_async(
	bcm_vlan_t * vid_ptr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_DEFAULT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_default_get.vid_ptr = vid_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_default_set_async(
	bcm_vlan_t vid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_DEFAULT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_default_set.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_destroy_async(
	bcm_vlan_t vid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_destroy.vid = vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_destroy_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_DESTROY_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_dtag_add_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid,
	bcm_vlan_t new_vid,
	int prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_DTAG_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_add.port = port;
	async->args.vlan_dtag_add.old_vid = old_vid;
	async->args.vlan_dtag_add.new_vid = new_vid;
	async->args.vlan_dtag_add.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_dtag_delete_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_DTAG_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_delete.port = port;
	async->args.vlan_dtag_delete.old_vid = old_vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_dtag_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_DTAG_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_dtag_get_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid,
	bcm_vlan_t * new_vid,
	int * prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_DTAG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_get.port = port;
	async->args.vlan_dtag_get.old_vid = old_vid;
	async->args.vlan_dtag_get.new_vid = new_vid;
	async->args.vlan_dtag_get.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_dtag_range_add_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid_low,
	bcm_vlan_t old_vid_high,
	bcm_vlan_t new_vid,
	int int_prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_DTAG_RANGE_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_range_add.port = port;
	async->args.vlan_dtag_range_add.old_vid_low = old_vid_low;
	async->args.vlan_dtag_range_add.old_vid_high = old_vid_high;
	async->args.vlan_dtag_range_add.new_vid = new_vid;
	async->args.vlan_dtag_range_add.int_prio = int_prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_dtag_range_delete_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid_low,
	bcm_vlan_t old_vid_high,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_DTAG_RANGE_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_range_delete.port = port;
	async->args.vlan_dtag_range_delete.old_vid_low = old_vid_low;
	async->args.vlan_dtag_range_delete.old_vid_high = old_vid_high;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_dtag_range_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_DTAG_RANGE_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_dtag_range_get_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid_low,
	bcm_vlan_t old_vid_high,
	bcm_vlan_t * new_vid,
	int * prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_DTAG_RANGE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_dtag_range_get.port = port;
	async->args.vlan_dtag_range_get.old_vid_low = old_vid_low;
	async->args.vlan_dtag_range_get.old_vid_high = old_vid_high;
	async->args.vlan_dtag_range_get.new_vid = new_vid;
	async->args.vlan_dtag_range_get.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_gport_add_async(
	bcm_vlan_t vlan,
	bcm_gport_t port,
	int flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_GPORT_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_gport_add.vlan = vlan;
	async->args.vlan_gport_add.port = port;
	async->args.vlan_gport_add.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_gport_delete_async(
	bcm_vlan_t vlan,
	bcm_gport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_GPORT_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_gport_delete.vlan = vlan;
	async->args.vlan_gport_delete.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_gport_delete_all_async(
	bcm_vlan_t vlan,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_GPORT_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_gport_delete_all.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_gport_get_async(
	bcm_vlan_t vlan,
	bcm_gport_t port,
	int * flags,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_GPORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_gport_get.vlan = vlan;
	async->args.vlan_gport_get.port = port;
	async->args.vlan_gport_get.flags = flags;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_gport_get_all_async(
	bcm_vlan_t vlan,
	int array_max,
	bcm_gport_t * gport_array,
	int * flags_array,
	int * array_size,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_GPORT_GET_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_gport_get_all.vlan = vlan;
	async->args.vlan_gport_get_all.array_max = array_max;
	async->args.vlan_gport_get_all.gport_array = gport_array;
	async->args.vlan_gport_get_all.flags_array = flags_array;
	async->args.vlan_gport_get_all.array_size = array_size;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_ip_action_add_async(
	bcm_vlan_ip_t * vlan_ip,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_IP_ACTION_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_ip_action_add.vlan_ip = vlan_ip;
	async->args.vlan_ip_action_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_ip_action_delete_async(
	bcm_vlan_ip_t * vlan_ip,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_IP_ACTION_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_ip_action_delete.vlan_ip = vlan_ip;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_ip_action_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_IP_ACTION_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_ip_action_get_async(
	bcm_vlan_ip_t * vlan_ip,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_IP_ACTION_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_ip_action_get.vlan_ip = vlan_ip;
	async->args.vlan_ip_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_ip_add_async(
	bcm_vlan_ip_t * vlan_ip,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_IP_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_ip_add.vlan_ip = vlan_ip;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_ip_delete_async(
	bcm_vlan_ip_t * vlan_ip,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_IP_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_ip_delete.vlan_ip = vlan_ip;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_ip_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_IP_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_mac_action_add_async(
	bcm_mac_t mac,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_MAC_ACTION_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mac_action_add.mac = (uint8 *)mac;
	async->args.vlan_mac_action_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_mac_action_delete_async(
	bcm_mac_t mac,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_MAC_ACTION_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mac_action_delete.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_mac_action_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_MAC_ACTION_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_mac_action_get_async(
	bcm_mac_t mac,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_MAC_ACTION_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mac_action_get.mac = (uint8 *)mac;
	async->args.vlan_mac_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_mac_add_async(
	bcm_mac_t mac,
	bcm_vlan_t vid,
	int prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_MAC_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mac_add.mac = (uint8 *)mac;
	async->args.vlan_mac_add.vid = vid;
	async->args.vlan_mac_add.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_mac_delete_async(
	bcm_mac_t mac,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_MAC_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mac_delete.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_mac_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_MAC_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_mcast_flood_get_async(
	bcm_vlan_t vlan,
	bcm_vlan_mcast_flood_t * mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_MCAST_FLOOD_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mcast_flood_get.vlan = vlan;
	async->args.vlan_mcast_flood_get.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_mcast_flood_set_async(
	bcm_vlan_t vlan,
	bcm_vlan_mcast_flood_t mode,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_MCAST_FLOOD_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_mcast_flood_set.vlan = vlan;
	async->args.vlan_mcast_flood_set.mode = mode;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_add_async(
	bcm_vlan_t vid,
	bcmx_lplist_t lplist,
	bcmx_lplist_t ubmp,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_add.vid = vid;
	async->args.vlan_port_add.lplist = lplist;
	async->args.vlan_port_add.ubmp = ubmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_create_async(
	bcmx_vlan_port_t * vlan_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_create.vlan_port = vlan_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_default_action_delete_async(
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_DEFAULT_ACTION_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_default_action_delete.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_default_action_get_async(
	bcmx_lport_t port,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_DEFAULT_ACTION_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_default_action_get.port = port;
	async->args.vlan_port_default_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_default_action_set_async(
	bcmx_lport_t port,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_DEFAULT_ACTION_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_default_action_set.port = port;
	async->args.vlan_port_default_action_set.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_destroy_async(
	bcm_gport_t gport,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_destroy.gport = gport;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_egress_default_action_delete_async(
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_EGRESS_DEFAULT_ACTION_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_egress_default_action_delete.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_egress_default_action_get_async(
	bcmx_lport_t port,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_EGRESS_DEFAULT_ACTION_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_egress_default_action_get.port = port;
	async->args.vlan_port_egress_default_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_egress_default_action_set_async(
	bcmx_lport_t port,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_EGRESS_DEFAULT_ACTION_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_egress_default_action_set.port = port;
	async->args.vlan_port_egress_default_action_set.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_find_async(
	bcmx_vlan_port_t * vlan_port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_FIND;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_find.vlan_port = vlan_port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_get_async(
	bcm_vlan_t vid,
	bcmx_lplist_t * lplist,
	bcmx_lplist_t * ubmp,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_get.vid = vid;
	async->args.vlan_port_get.lplist = lplist;
	async->args.vlan_port_get.ubmp = ubmp;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_protocol_action_add_async(
	bcmx_lport_t port,
	bcm_port_frametype_t frame,
	bcm_port_ethertype_t ether,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_protocol_action_add.port = port;
	async->args.vlan_port_protocol_action_add.frame = frame;
	async->args.vlan_port_protocol_action_add.ether = ether;
	async->args.vlan_port_protocol_action_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_protocol_action_delete_async(
	bcmx_lport_t port,
	bcm_port_frametype_t frame,
	bcm_port_ethertype_t ether,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_protocol_action_delete.port = port;
	async->args.vlan_port_protocol_action_delete.frame = frame;
	async->args.vlan_port_protocol_action_delete.ether = ether;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_protocol_action_delete_all_async(
	bcmx_lport_t port,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_protocol_action_delete_all.port = port;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_protocol_action_get_async(
	bcmx_lport_t port,
	bcm_port_frametype_t frame,
	bcm_port_ethertype_t ether,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_protocol_action_get.port = port;
	async->args.vlan_port_protocol_action_get.frame = frame;
	async->args.vlan_port_protocol_action_get.ether = ether;
	async->args.vlan_port_protocol_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_port_remove_async(
	bcm_vlan_t vid,
	bcmx_lplist_t lplist,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_PORT_REMOVE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_port_remove.vid = vid;
	async->args.vlan_port_remove.lplist = lplist;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_queue_map_attach_async(
	bcm_vlan_t vlan,
	int qmid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_QUEUE_MAP_ATTACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_attach.vlan = vlan;
	async->args.vlan_queue_map_attach.qmid = qmid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_queue_map_attach_get_async(
	bcm_vlan_t vlan,
	int * qmid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_QUEUE_MAP_ATTACH_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_attach_get.vlan = vlan;
	async->args.vlan_queue_map_attach_get.qmid = qmid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_queue_map_create_async(
	uint32 flags,
	int * qmid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_QUEUE_MAP_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_create.flags = flags;
	async->args.vlan_queue_map_create.qmid = qmid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_queue_map_destroy_async(
	int qmid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_QUEUE_MAP_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_destroy.qmid = qmid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_queue_map_destroy_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_QUEUE_MAP_DESTROY_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_queue_map_detach_async(
	bcm_vlan_t vlan,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_QUEUE_MAP_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_detach.vlan = vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_queue_map_detach_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_QUEUE_MAP_DETACH_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_queue_map_get_async(
	int qmid,
	int pkt_pri,
	int cfi,
	int * queue,
	int * color,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_QUEUE_MAP_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_get.qmid = qmid;
	async->args.vlan_queue_map_get.pkt_pri = pkt_pri;
	async->args.vlan_queue_map_get.cfi = cfi;
	async->args.vlan_queue_map_get.queue = queue;
	async->args.vlan_queue_map_get.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_queue_map_set_async(
	int qmid,
	int pkt_pri,
	int cfi,
	int queue,
	int color,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_QUEUE_MAP_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_queue_map_set.qmid = qmid;
	async->args.vlan_queue_map_set.pkt_pri = pkt_pri;
	async->args.vlan_queue_map_set.cfi = cfi;
	async->args.vlan_queue_map_set.queue = queue;
	async->args.vlan_queue_map_set.color = color;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_stat_enable_set_async(
	bcm_vlan_t vlan,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_STAT_ENABLE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_enable_set.vlan = vlan;
	async->args.vlan_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_stat_multi_get_async(
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_STAT_MULTI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_multi_get.vlan = vlan;
	async->args.vlan_stat_multi_get.cos = cos;
	async->args.vlan_stat_multi_get.nstat = nstat;
	async->args.vlan_stat_multi_get.stat_arr = stat_arr;
	async->args.vlan_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_stat_multi_get32_async(
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_STAT_MULTI_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_multi_get32.vlan = vlan;
	async->args.vlan_stat_multi_get32.cos = cos;
	async->args.vlan_stat_multi_get32.nstat = nstat;
	async->args.vlan_stat_multi_get32.stat_arr = stat_arr;
	async->args.vlan_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_stat_multi_set_async(
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_STAT_MULTI_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_multi_set.vlan = vlan;
	async->args.vlan_stat_multi_set.cos = cos;
	async->args.vlan_stat_multi_set.nstat = nstat;
	async->args.vlan_stat_multi_set.stat_arr = stat_arr;
	async->args.vlan_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_stat_multi_set32_async(
	bcm_vlan_t vlan,
	bcm_cos_t cos,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_STAT_MULTI_SET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stat_multi_set32.vlan = vlan;
	async->args.vlan_stat_multi_set32.cos = cos;
	async->args.vlan_stat_multi_set32.nstat = nstat;
	async->args.vlan_stat_multi_set32.stat_arr = stat_arr;
	async->args.vlan_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_stg_get_async(
	bcm_vlan_t vid,
	bcm_stg_t * stg_ptr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_STG_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stg_get.vid = vid;
	async->args.vlan_stg_get.stg_ptr = stg_ptr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_stg_set_async(
	bcm_vlan_t vid,
	bcm_stg_t stg,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_STG_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_stg_set.vid = vid;
	async->args.vlan_stg_set.stg = stg;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_action_add_async(
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_add.port = port;
	async->args.vlan_translate_action_add.key_type = key_type;
	async->args.vlan_translate_action_add.outer_vlan = outer_vlan;
	async->args.vlan_translate_action_add.inner_vlan = inner_vlan;
	async->args.vlan_translate_action_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_action_delete_async(
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_delete.port = port;
	async->args.vlan_translate_action_delete.key_type = key_type;
	async->args.vlan_translate_action_delete.outer_vlan = outer_vlan;
	async->args.vlan_translate_action_delete.inner_vlan = inner_vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_action_get_async(
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_get.port = port;
	async->args.vlan_translate_action_get.key_type = key_type;
	async->args.vlan_translate_action_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_action_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_action_range_add_async(
	bcm_gport_t port,
	bcm_vlan_t outer_vlan_low,
	bcm_vlan_t outer_vlan_high,
	bcm_vlan_t inner_vlan_low,
	bcm_vlan_t inner_vlan_high,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_range_add.port = port;
	async->args.vlan_translate_action_range_add.outer_vlan_low = outer_vlan_low;
	async->args.vlan_translate_action_range_add.outer_vlan_high = outer_vlan_high;
	async->args.vlan_translate_action_range_add.inner_vlan_low = inner_vlan_low;
	async->args.vlan_translate_action_range_add.inner_vlan_high = inner_vlan_high;
	async->args.vlan_translate_action_range_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_action_range_delete_async(
	bcm_gport_t port,
	bcm_vlan_t outer_vlan_low,
	bcm_vlan_t outer_vlan_high,
	bcm_vlan_t inner_vlan_low,
	bcm_vlan_t inner_vlan_high,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_range_delete.port = port;
	async->args.vlan_translate_action_range_delete.outer_vlan_low = outer_vlan_low;
	async->args.vlan_translate_action_range_delete.outer_vlan_high = outer_vlan_high;
	async->args.vlan_translate_action_range_delete.inner_vlan_low = inner_vlan_low;
	async->args.vlan_translate_action_range_delete.inner_vlan_high = inner_vlan_high;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_action_range_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_action_range_get_async(
	bcm_gport_t port,
	bcm_vlan_t outer_vlan_low,
	bcm_vlan_t outer_vlan_high,
	bcm_vlan_t inner_vlan_low,
	bcm_vlan_t inner_vlan_high,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_action_range_get.port = port;
	async->args.vlan_translate_action_range_get.outer_vlan_low = outer_vlan_low;
	async->args.vlan_translate_action_range_get.outer_vlan_high = outer_vlan_high;
	async->args.vlan_translate_action_range_get.inner_vlan_low = inner_vlan_low;
	async->args.vlan_translate_action_range_get.inner_vlan_high = inner_vlan_high;
	async->args.vlan_translate_action_range_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_add_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid,
	bcm_vlan_t new_vid,
	int prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_add.port = port;
	async->args.vlan_translate_add.old_vid = old_vid;
	async->args.vlan_translate_add.new_vid = new_vid;
	async->args.vlan_translate_add.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_delete_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_delete.port = port;
	async->args.vlan_translate_delete.old_vid = old_vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_action_add_async(
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ACTION_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_action_add.port_class = port_class;
	async->args.vlan_translate_egress_action_add.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_action_add.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_action_add.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_action_delete_async(
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ACTION_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_action_delete.port_class = port_class;
	async->args.vlan_translate_egress_action_delete.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_action_delete.inner_vlan = inner_vlan;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_action_get_async(
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_action_set_t * action,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ACTION_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_action_get.port_class = port_class;
	async->args.vlan_translate_egress_action_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_action_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_action_get.action = action;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_add_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid,
	bcm_vlan_t new_vid,
	int prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_add.port = port;
	async->args.vlan_translate_egress_add.old_vid = old_vid;
	async->args.vlan_translate_egress_add.new_vid = new_vid;
	async->args.vlan_translate_egress_add.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_delete_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_delete.port = port;
	async->args.vlan_translate_egress_delete.old_vid = old_vid;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_get_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid,
	bcm_vlan_t * new_vid,
	int * prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_get.port = port;
	async->args.vlan_translate_egress_get.old_vid = old_vid;
	async->args.vlan_translate_egress_get.new_vid = new_vid;
	async->args.vlan_translate_egress_get.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_stat_enable_set_async(
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_ENABLE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_enable_set.port_class = port_class;
	async->args.vlan_translate_egress_stat_enable_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_enable_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_stat_get_async(
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint64 * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_get.port_class = port_class;
	async->args.vlan_translate_egress_stat_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_get.stat = stat;
	async->args.vlan_translate_egress_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_stat_get32_async(
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_get32.port_class = port_class;
	async->args.vlan_translate_egress_stat_get32.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_get32.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_get32.stat = stat;
	async->args.vlan_translate_egress_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_stat_multi_get_async(
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_MULTI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_multi_get.port_class = port_class;
	async->args.vlan_translate_egress_stat_multi_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_multi_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_multi_get.nstat = nstat;
	async->args.vlan_translate_egress_stat_multi_get.stat_arr = stat_arr;
	async->args.vlan_translate_egress_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_stat_multi_get32_async(
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_MULTI_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_multi_get32.port_class = port_class;
	async->args.vlan_translate_egress_stat_multi_get32.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_multi_get32.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_multi_get32.nstat = nstat;
	async->args.vlan_translate_egress_stat_multi_get32.stat_arr = stat_arr;
	async->args.vlan_translate_egress_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_stat_multi_set_async(
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_MULTI_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_multi_set.port_class = port_class;
	async->args.vlan_translate_egress_stat_multi_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_multi_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_multi_set.nstat = nstat;
	async->args.vlan_translate_egress_stat_multi_set.stat_arr = stat_arr;
	async->args.vlan_translate_egress_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_stat_multi_set32_async(
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_MULTI_SET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_multi_set32.port_class = port_class;
	async->args.vlan_translate_egress_stat_multi_set32.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_multi_set32.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_multi_set32.nstat = nstat;
	async->args.vlan_translate_egress_stat_multi_set32.stat_arr = stat_arr;
	async->args.vlan_translate_egress_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_stat_set_async(
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint64 val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_set.port_class = port_class;
	async->args.vlan_translate_egress_stat_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_set.stat = stat;
	async->args.vlan_translate_egress_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_egress_stat_set32_async(
	int port_class,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_STAT_SET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_egress_stat_set32.port_class = port_class;
	async->args.vlan_translate_egress_stat_set32.outer_vlan = outer_vlan;
	async->args.vlan_translate_egress_stat_set32.inner_vlan = inner_vlan;
	async->args.vlan_translate_egress_stat_set32.stat = stat;
	async->args.vlan_translate_egress_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_get_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid,
	bcm_vlan_t * new_vid,
	int * prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_get.port = port;
	async->args.vlan_translate_get.old_vid = old_vid;
	async->args.vlan_translate_get.new_vid = new_vid;
	async->args.vlan_translate_get.prio = prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_range_add_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid_low,
	bcm_vlan_t old_vid_high,
	bcm_vlan_t new_vid,
	int int_prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_range_add.port = port;
	async->args.vlan_translate_range_add.old_vid_low = old_vid_low;
	async->args.vlan_translate_range_add.old_vid_high = old_vid_high;
	async->args.vlan_translate_range_add.new_vid = new_vid;
	async->args.vlan_translate_range_add.int_prio = int_prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_range_delete_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid_low,
	bcm_vlan_t old_vid_high,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_range_delete.port = port;
	async->args.vlan_translate_range_delete.old_vid_low = old_vid_low;
	async->args.vlan_translate_range_delete.old_vid_high = old_vid_high;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_range_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_range_get_async(
	bcmx_lport_t port,
	bcm_vlan_t old_vid_low,
	bcm_vlan_t old_vid_high,
	bcm_vlan_t * new_vid,
	int * int_prio,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_range_get.port = port;
	async->args.vlan_translate_range_get.old_vid_low = old_vid_low;
	async->args.vlan_translate_range_get.old_vid_high = old_vid_high;
	async->args.vlan_translate_range_get.new_vid = new_vid;
	async->args.vlan_translate_range_get.int_prio = int_prio;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_stat_enable_set_async(
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int enable,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_ENABLE_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_enable_set.port = port;
	async->args.vlan_translate_stat_enable_set.key_type = key_type;
	async->args.vlan_translate_stat_enable_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_enable_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_enable_set.enable = enable;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_stat_get_async(
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint64 * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_get.port = port;
	async->args.vlan_translate_stat_get.key_type = key_type;
	async->args.vlan_translate_stat_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_get.stat = stat;
	async->args.vlan_translate_stat_get.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_stat_get32_async(
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 * val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_get32.port = port;
	async->args.vlan_translate_stat_get32.key_type = key_type;
	async->args.vlan_translate_stat_get32.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_get32.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_get32.stat = stat;
	async->args.vlan_translate_stat_get32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_stat_multi_get_async(
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_MULTI_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_multi_get.port = port;
	async->args.vlan_translate_stat_multi_get.key_type = key_type;
	async->args.vlan_translate_stat_multi_get.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_multi_get.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_multi_get.nstat = nstat;
	async->args.vlan_translate_stat_multi_get.stat_arr = stat_arr;
	async->args.vlan_translate_stat_multi_get.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_stat_multi_get32_async(
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_MULTI_GET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_multi_get32.port = port;
	async->args.vlan_translate_stat_multi_get32.key_type = key_type;
	async->args.vlan_translate_stat_multi_get32.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_multi_get32.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_multi_get32.nstat = nstat;
	async->args.vlan_translate_stat_multi_get32.stat_arr = stat_arr;
	async->args.vlan_translate_stat_multi_get32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_stat_multi_set_async(
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint64 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_MULTI_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_multi_set.port = port;
	async->args.vlan_translate_stat_multi_set.key_type = key_type;
	async->args.vlan_translate_stat_multi_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_multi_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_multi_set.nstat = nstat;
	async->args.vlan_translate_stat_multi_set.stat_arr = stat_arr;
	async->args.vlan_translate_stat_multi_set.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_stat_multi_set32_async(
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	int nstat,
	bcm_vlan_stat_t * stat_arr,
	uint32 * value_arr,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_MULTI_SET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_multi_set32.port = port;
	async->args.vlan_translate_stat_multi_set32.key_type = key_type;
	async->args.vlan_translate_stat_multi_set32.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_multi_set32.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_multi_set32.nstat = nstat;
	async->args.vlan_translate_stat_multi_set32.stat_arr = stat_arr;
	async->args.vlan_translate_stat_multi_set32.value_arr = value_arr;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_stat_set_async(
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint64 val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_set.port = port;
	async->args.vlan_translate_stat_set.key_type = key_type;
	async->args.vlan_translate_stat_set.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_set.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_set.stat = stat;
	async->args.vlan_translate_stat_set.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_translate_stat_set32_async(
	bcm_gport_t port,
	bcm_vlan_translate_key_t key_type,
	bcm_vlan_t outer_vlan,
	bcm_vlan_t inner_vlan,
	bcm_vlan_stat_t stat,
	uint32 val,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_TRANSLATE_STAT_SET32;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_translate_stat_set32.port = port;
	async->args.vlan_translate_stat_set32.key_type = key_type;
	async->args.vlan_translate_stat_set32.outer_vlan = outer_vlan;
	async->args.vlan_translate_stat_set32.inner_vlan = inner_vlan;
	async->args.vlan_translate_stat_set32.stat = stat;
	async->args.vlan_translate_stat_set32.val = val;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_vlan_vector_flags_set_async(
	bcm_vlan_vector_t vlan_vector,
	uint32 flags_mask,
	uint32 flags_value,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_VLAN_VECTOR_FLAGS_SET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.vlan_vector_flags_set.vlan_vector = (uint32 *)vlan_vector;
	async->args.vlan_vector_flags_set.flags_mask = flags_mask;
	async->args.vlan_vector_flags_set.flags_value = flags_value;
	bcm_async_add((bcm_async_req_t *)async);
}

#ifdef	INCLUDE_L3

void
bcmx_wlan_client_add_async(
	bcmx_wlan_client_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_WLAN_CLIENT_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_client_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_wlan_client_delete_async(
	bcm_mac_t mac,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_WLAN_CLIENT_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_client_delete.mac = (uint8 *)mac;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_wlan_client_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_WLAN_CLIENT_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_wlan_client_get_async(
	bcm_mac_t mac,
	bcmx_wlan_client_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_WLAN_CLIENT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_client_get.mac = (uint8 *)mac;
	async->args.wlan_client_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_wlan_detach_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_WLAN_DETACH;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_wlan_init_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_WLAN_INIT;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_wlan_port_add_async(
	bcmx_wlan_port_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_WLAN_PORT_ADD;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_port_add.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_wlan_port_delete_async(
	bcm_gport_t wlan_port_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_WLAN_PORT_DELETE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_port_delete.wlan_port_id = wlan_port_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_wlan_port_delete_all_async(
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_WLAN_PORT_DELETE_ALL;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_wlan_port_get_async(
	bcm_gport_t wlan_port_id,
	bcmx_wlan_port_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_WLAN_PORT_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_port_get.wlan_port_id = wlan_port_id;
	async->args.wlan_port_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_wlan_tunnel_initiator_create_async(
	bcmx_tunnel_initiator_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_WLAN_TUNNEL_INITIATOR_CREATE;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_tunnel_initiator_create.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_wlan_tunnel_initiator_destroy_async(
	bcm_gport_t wlan_tunnel_id,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_WLAN_TUNNEL_INITIATOR_DESTROY;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_tunnel_initiator_destroy.wlan_tunnel_id = wlan_tunnel_id;
	bcm_async_add((bcm_async_req_t *)async);
}

void
bcmx_wlan_tunnel_initiator_get_async(
	bcmx_tunnel_initiator_t * info,
	bcmx_async_cb_t async_callback,
	void *async_cookie)
{
	bcmx_async_req_t *async;

	async = sal_alloc(sizeof(*async), "bcmx_async");
	if (async == NULL) {
		if (async_callback != NULL) {
			(*async_callback)(async_cookie, BCM_E_MEMORY);
		}
		return;
	}
	async->next = NULL;
	async->type = BCMX_ASYNC_ENTRY_WLAN_TUNNEL_INITIATOR_GET;
	async->run = bcmx_async_run;
	async->callback = async_callback;
	async->cookie = async_cookie;
	async->args.wlan_tunnel_initiator_get.info = info;
	bcm_async_add((bcm_async_req_t *)async);
}

#endif	/* INCLUDE_L3 */
#endif	/* BCM_ASYNC_SUPPORT */
