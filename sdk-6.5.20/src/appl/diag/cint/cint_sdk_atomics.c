/*
 * 
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */
#include "cint_sdk_atomics.h"
#include <cint_porting.h>
#include <cint_internal.h>

typedef int cint_sdk_atomics_not_empty; /* Make ISO compilers happy. */

#ifdef INCLUDE_LIB_CINT

#include <sal/core/alloc.h>
#include <sal/core/libc.h>
#include <sal/appl/io.h>
#include <appl/diag/shell.h>
#include <appl/diag/parse.h>
#include <soc/drv.h>
#include <appl/diag/system.h>
#include <bcm/types.h>
#include <shared/util.h>
#ifdef INCLUDE_FCMAP
#include <shared/fcmap.h>
#endif
#include <bcm/error.h>
#include <bcm/stack.h>
#include <cint_error.h>

#include <bcm/rx.h>
#include <bcm/pktio.h>
#include <bcm/port.h>
#include <bcm/switch.h> 
#ifdef CPRIMOD_SUPPORT
#include <shared/cpri.h>
#endif

/***********************************************************************
 *
 * These are the atomic hand-coded type handlers for the SDK datatypes
 * 
 * These structures are fed into the core cint library along
 * with the autogenerated API data. 
 */

static int
__cint_set_pbmp_t(void* p, const char* expr)
{
    char tmp[64];     
    char * s = tmp; 
    int port;
    int c;
    int open_brace, close_brace;
    char *end;
    bcm_pbmp_t* pp = (bcm_pbmp_t*)p;

    BCM_PBMP_CLEAR(*pp);
    s = tmp;
    open_brace = close_brace = 0;
    while((c=*expr++) != 0) {
        switch (c) {
        case '{':
            open_brace++;
            break;
            
        case '}':
            close_brace++;
            /* fall through */
        case ' ':
            /* convert non-empty integer port expression */
            *s = 0;
            if (tmp[0]) {
                port = sal_ctoi(tmp, &end);
                if (*end != 0 || tmp == end ||
                    port < 0 || port >= BCM_PBMP_PORT_MAX) {
                    return 1;
                }
                BCM_PBMP_PORT_ADD(*pp,port); 
                s = tmp;
            }
            break;

        default:
            /* copy */
            if ((s-tmp) < (sizeof(tmp)-1)) {
                *s++ = c;
            } else {
                /* tmp overflow */
                return 1;
            }
            break;
        }
    }
    return !(open_brace == 1 && close_brace == 1); 
}

static int
__cint_format_pbmp_t(void* p, char* dst, int size, cint_atomic_format_t format)
{
    bcm_pbmp_t* pp = (bcm_pbmp_t*)p; 
    int port; 

    cint_snprintf_ex(&dst, &size, "{ "); 
    BCM_PBMP_ITER((*pp), port) {
        cint_snprintf_ex(&dst, &size, "%d ", port); 
    }
    cint_snprintf_ex(&dst, &size, "}"); 
    return 0; 
}

static int
__cint_set_bcm_mac_t(void* p, const char* expr)
{
    bcm_mac_t m = { 0, 0, 0, 0, 0, 0 }; 
    char buffer[16] = "0x"; 
    
    const char* s = expr; 
    char* d = buffer+2; 
    int i = 0; 
    char *end;

    for(s = expr;; s++) {
        if(*s == ':' || *s == 0) {            
            if(i <= 5) {
                m[i++] = sal_ctoi(buffer, &end); 
                if (*end != 0 || buffer == end) {
                    return 1;
                }
            }   
            d = buffer+2; 
            if(*s == 0) {
                break; 
            }   
        }       
        else {
            *d++ = *s; 
        }       
    } 
    
    
    CINT_MEMCPY(p, m, sizeof(m)); 
    return 0; 
}

static int
__cint_format_bcm_mac_t(void* p, char* dst, int size, cint_atomic_format_t format)
{
    unsigned char* m = (unsigned char*) p;     
    cint_snprintf_ex(&dst, &size, "%.2X:%.2X:%.2X:%.2X:%.2X:%.2X", 
                     m[0], m[1], m[2], m[3], m[4], m[5]); 
    return 0; 
}


static int
__cint_set_uint64(void* p, const char* expr)
{
    uint64* u64 = (uint64*)p; 
    char slo[16] = { 0 }; 
    char shi[16] = { 0 }; 

    const char* s; 
    char* d; 
    char *end;

    /*
     * Format: "number" -- sets low
     * Format: "number:number" -- sets hi and low
     */
    uint32 lo = 0; 
    uint32 hi = 0; 
    
    d = shi;
    for(s = expr; *s; s++) {
        if(*s == ':' || *s == ',' || *s == ' ') {
            *d = 0; 
            d = slo; 
        }
        else {
            *d++ = *s;
        }       
    }
    *d = 0; 

    if(slo[0] && shi[0]) {
        /* Both specifier */
        lo = sal_ctoi(slo, &end);
        if (*end != 0 || slo == end) {
            return 1;
        }
        hi = sal_ctoi(shi, &end); 
        if (*end != 0 || shi == end) {
            return 1;
        }
    }   
    else {
        lo = sal_ctoi(shi, &end); 
        if (*end != 0 || shi == end) {
            return 1;
        }
        hi = 0; 
    }

    COMPILER_64_SET(*u64, hi, lo); 
    return 0;
}

static int
__cint_format_uint64(void* p, char* dst, int size, cint_atomic_format_t format)
{
    uint64* u64 = (uint64*)p; 
    uint32 hi; 
    uint32 lo;
    COMPILER_64_TO_32_LO(lo, *u64); 
    COMPILER_64_TO_32_HI(hi, *u64); 
    cint_snprintf_ex(&dst, &size, "{0x%.8X 0x%.8X}", hi, lo); 
    return 0; 
}

static int
__cint_format_bcm_rx_reasons_t(void* p, char* dst, int size, cint_atomic_format_t format)
{
    bcm_rx_reason_t r; 
    bcm_rx_reasons_t* rs = (bcm_rx_reasons_t*) p;     
    static char* rnames[] = BCM_RX_REASON_NAMES_INITIALIZER; 
    
    if(BCM_RX_REASON_IS_NULL(*rs)) {
        cint_snprintf_ex(&dst, &size, "None"); 
    }   
    else {
        /* coverity [mixed_enums] */
        BCM_RX_REASON_ITER((*rs), r) {
            cint_snprintf_ex(&dst, &size, "%s ", rnames[r]); 
        }
    }   
    return 0; 
}

static int
__cint_set_bcm_rx_reasons_t(void* p, const char* expr)
{
    return -1; 
}

static int
__cint_format_bcm_ip_t(void *p, char *dst, int size,
                       cint_atomic_format_t format)
{
    bcm_ip_t *ipp = (bcm_ip_t *)p;

    cint_snprintf_ex(&dst, &size, "%d.%d.%d.%d",
                     (*ipp >> 24) & 0xFF,
                     (*ipp >> 16) & 0xFF,
                     (*ipp >>  8) & 0xFF,
                      *ipp        & 0xFF);
    return 0;
}

static int
__cint_set_bcm_ip_t(void *p, const char *expr)
{
    ip_addr_t *ipp = (ip_addr_t *)p;

    return parse_ipaddr((char *)expr, ipp);
}

static int
__cint_format_bcm_ip6_t(void *p, char *dst, int size,
                        cint_atomic_format_t format)
{
    uint8 *ipaddr = p;

    cint_snprintf_ex(&dst, &size, "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",
                     (((uint16)ipaddr[0] << 8) | ipaddr[1]),
                     (((uint16)ipaddr[2] << 8) | ipaddr[3]),
                     (((uint16)ipaddr[4] << 8) | ipaddr[5]),
                     (((uint16)ipaddr[6] << 8) | ipaddr[7]),
                     (((uint16)ipaddr[8] << 8) | ipaddr[9]),
                     (((uint16)ipaddr[10] << 8) | ipaddr[11]),
                     (((uint16)ipaddr[12] << 8) | ipaddr[13]),
                     (((uint16)ipaddr[14] << 8) | ipaddr[15]));
    return 0;
}

static int
__cint_set_bcm_ip6_t(void *p, const char *expr)
{
    return parse_ip6addr((char *)expr, p);
}

/*
 * This is the exported table for our datatypes
 */
cint_atomic_type_t cint_sdk_atomics[] = 
    {
        {
            "uint64", 
            sizeof(uint64), 
            0, 
            __cint_format_uint64,
            __cint_set_uint64
        },
        {
            "int64", 
            sizeof(uint64), 
            0, 
            __cint_format_uint64,
            __cint_set_uint64
        },
        {
            "bcm_pbmp_t", 
            sizeof(bcm_pbmp_t),
            0, 
            __cint_format_pbmp_t, 
            __cint_set_pbmp_t,
        },      
        {
            "bcm_mac_t", 
            sizeof(bcm_mac_t),
            CINT_ATOMIC_TYPE_F_CAP_ONLY, 
            __cint_format_bcm_mac_t, 
            __cint_set_bcm_mac_t,
        },      
        {
            "bcm_rx_reasons_t", 
            sizeof(bcm_rx_reasons_t), 
            0, 
            __cint_format_bcm_rx_reasons_t, 
            __cint_set_bcm_rx_reasons_t, 
        },
        {
            "bcm_ip_t",
            sizeof(bcm_ip_t),
            CINT_ATOMIC_TYPE_F_CAP_ONLY,
            __cint_format_bcm_ip_t,
            __cint_set_bcm_ip_t,
        },
        {
            "bcm_ip6_t",
            sizeof(bcm_ip6_t),
            CINT_ATOMIC_TYPE_F_CAP_ONLY,
            __cint_format_bcm_ip6_t,
            __cint_set_bcm_ip6_t,
        },
        { NULL }, 
    }; 


static char* __macro__bcm_errmsg(int rc) 
{ 
    return bcm_errmsg(rc); 
}
CINT_FWRAPPER_CREATE_RP1(char*,char,1,0,
                         __macro__bcm_errmsg,
                         int,int,rc,0,0); 

static cint_function_t __cint_sdk_functions[] = 
    {
        CINT_FWRAPPER_NENTRY("bcm_errmsg", __macro__bcm_errmsg), 
        CINT_ENTRY_LAST
    }; 



static cint_parameter_desc_t __cint_sdk_typedefs[] = 
    {
        { "int", "bcm_port_mdix_t", 0, 0 }, 
        { "unsigned char", "uint8", 0, 0 }, 
        { "char", "int8", 0, 0 }, 
        { "char", "int8_t", 0, 0 }, 
        { "short", "int16", 0, 0 },
        { "short", "int16_t", 0, 0 },
        { "unsigned short", "uint16", 0, 0 },
        { "unsigned int", "uint32", 0, 0 },
        { "int", "int32", 0, 0 }, 
        { "uint32", "SHR_BITDCL", 0, 0 }, 
        { "bcm_pbmp_t", "soc_pbmp_t", 0, 0 }, 
        { "bcm_cos_t", "soc_cos_t", 0, 0 }, 
        { "bcm_mac_t", "const bcm_mac_t", 0, 0 }, 

        /* 
         * These are "broken" API definitions. 
         * Enumerations and structures are defined in <shared> and 
         * #defined or typedef'ed to the BCM API equivalents. 
         *
         * The structures are defined here by hand. 
         * The enumerations are just typed as "int". The enumeration names are not available. 
 */           
        { "int", "_shr_module_t", 0, 0 }, 
        { "int", "_shr_port_mode_t", 0, 0 }, 
        { "int", "_shr_pa_encap_t", 0, 0 }, 
        { "int", "_shr_port_mdix_t", 0, 0 }, 
        { "int", "_shr_port_mdix_status_t", 0, 0 }, 
        { "int", "_shr_dma_chan_t", 0, 0 }, 
        { "int", "_shr_port_stp_t", 0, 0 }, 
        { "int", "_shr_port_phy_control_t", 0, 0 }, 
        { "int", "_shr_port_cable_state_t", 0, 0 }, 
        { "int", "_shr_port_encap_t", 0, 0 }, 
        { "int", "_shr_port_mcast_flood_t", 0, 0 }, 
        { "int", "_shr_port_medium_t", 0, 0 }, 
        { "int", "_shr_port_duplex_t", 0, 0 }, 
        { "int", "_shr_port_if_t", 0, 0 }, 
        { "int", "_shr_port_ms_t", 0, 0 },
        { "int", "_shr_port_prbs_polynomial_t", 0, 0 },
#ifdef INCLUDE_FCMAP
        { "int", "_SHR_BFCMAP_DIR_EGRESS", 0, 0 },
        { "int", "_SHR_BFCMAP_DIR_INGRESS", 0, 0 },
        { "int", "_SHR_BFCMAP_CORE_UNKNOWN", 0, 0 },
        { "int", "_SHR_BFCMAP_CORE_OCTAL_GIG", 0, 0 },
        { "int", "_SHR_BFCMAP_CORE_BCM5458X", 0, 0 },
        { "int", "_SHR_BFCMAP_CORE_BCM5458X_B0", 0, 0 },
        { "int", "_SHR_BFCMAP_CORE_BCM8729", 0, 0 },
        { "int", "_SHR_BFCMAP_CORE_BCM8483X", 0, 0 },
        { "int", "_SHR_BFCMAP_CORE_BCM5438X", 0, 0 },
        { "int", "_SHR_BFCMAP_CORE_BCM84756", 0, 0 },
        { "int", "_SHR_BFCMAP_CORE_BCM88060_A0", 0, 0 },
        { "int", "_SHR_BFCMAP_CORE_BCM88061_A0", 0, 0 },
        { "int", "_SHR_BFCMAP_FCOE_TO_FC_MODE", 0, 0 },
        { "int", "_SHR_BFCMAP_FCOE_TO_FCOE_MODE", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_SPEED_AN", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_SPEED_2GBPS", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_SPEED_4GBPS", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_SPEED_8GBPS", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_SPEED_16GBPS", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_SPEED_32GBPS", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_SPEED_AN_2GBPS", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_SPEED_AN_4GBPS", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_SPEED_AN_8GBPS", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_SPEED_AN_16GBPS", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_SPEED_AN_32GBPS", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_SPEED_MAX_COUNT", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_STATE_INIT", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_STATE_RESET", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_STATE_ACTIVE", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_STATE_LINKDOWN", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_STATE_DISABLE", 0, 0 },
        { "int", "_SHR_BFCMAP_PORT_STATE_MAX_COUNT", 0, 0 },
        { "int", "_SHR_BFCMAP_EVENT_FC_LINK_INIT", 0, 0 },
        { "int", "_SHR_BFCMAP_EVENT_FC_LINK_RESET", 0, 0 },
        { "int", "_SHR_BFCMAP_EVENT_FC_LINK_DOWN", 0, 0 },
        { "int", "_SHR_BFCMAP_EVENT_FC_R_T_TIMEOUT", 0, 0 },
        { "int", "_SHR_BFCMAP_EVENT_FC_E_D_TIMEOUT", 0, 0 },
        { "int", "_SHR_BFCMAP_EVENT__COUNT", 0, 0 },
        { "int", "_SHR_BFCMAP_ENCAP_FCOE_FPMA", 0, 0 },
        { "int", "_SHR_BFCMAP_ENCAP_FCOE_ETH_ADDRESS_NULL", 0, 0 },
        { "int", "_SHR_BFCMAP_ENCAP_FCOE_ETH_ADDRESS_USER", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_NONE", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_PORT_INIT", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_OPEN_LINK", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_LINK_FAILURE", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_OLS_RCVD", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_NOS_RCVD", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_SYNC_LOSS", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_BOUCELINK_FROM_ADMIN", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_CHGSPEED_FROM_ADMIN", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_DISABLE_FROM_ADMIN", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_RESET_FROM_ADMIN", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_LR_RCVD", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_LRR_RCVD", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_ED_TOV", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_TR_SYS_LNK_FAILURE", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_RC_NONE", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_RC_PORT_INIT", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_RC_OPEN_LINK", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_RC_LINK_FAILURE", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_RC_OLS_RCVD", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_RC_NOS_RCVD", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_RC_SYNC_LOSS", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_RC_BOUCELINK_FROM_ADMIN", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_RC_CHGSPEED_FROM_ADMIN", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_RC_DISABLE_FROM_ADMIN", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_RC_RESET_FAILURE", 0, 0 },
        { "int", "_SHR_BFCMAP_LF_RC_SYS_LINK_FAILURE", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_OK", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_PORT_INIT", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_OPEN_LINK", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_LINK_FAILURE", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_OLS_RCVD", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_NOS_RCVD", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_SYNC_LOSS", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_BOUCELINK_FROM_ADMIN", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_CHGSPEED_FROM_ADMIN", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_DISABLE_FROM_ADMIN", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_AN_NO_SIGNAL", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_AN_TIMEOUT", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_PROTO_TIMEOUT", 0, 0 },
        { "int", "_SHR_BFCMAP_DIAG_SYS_LNK_FAILURE", 0, 0 },
        { "int", "_SHR_FCMAP_PORT_ABILITY_SPEED_AN", 0, 0 },
        { "int", "_SHR_FCMAP_PORT_ABILITY_SPEED_2GBPS", 0, 0 },
        { "int", "_SHR_FCMAP_PORT_ABILITY_SPEED_4GBPS", 0, 0 },
        { "int", "_SHR_FCMAP_PORT_ABILITY_SPEED_8GBPS", 0, 0 },
        { "int", "_SHR_FCMAP_PORT_ABILITY_SPEED_16GBPS", 0, 0 },
        { "int", "_SHR_FCMAP_PORT_ABILITY_SPEED_32GBPS", 0, 0 },
        { "int", "_SHR_FCMAP_PORT_SCRAMBLING_SPEED_2GBPS", 0, 0 },
        { "int", "_SHR_FCMAP_PORT_SCRAMBLING_SPEED_4GBPS", 0, 0 },
        { "int", "_SHR_FCMAP_PORT_SCRAMBLING_SPEED_8GBPS", 0, 0 },
        { "int", "_SHR_FCMAP_PORT_SCRAMBLING_SPEED_16GBPS", 0, 0 },
        { "int", "_SHR_FCMAP_PORT_SCRAMBLING_SPEED_32GBPS", 0, 0 },
        { "int", "_shr_bfcmap_dir_t", 0, 0 },
        { "int", "_shr_bfcmap_core_t", 0, 0 },
        { "int", "_shr_bfcmap_port_mode_t", 0, 0 },
        { "int", "_shr_bfcmap_port_speed_t", 0, 0 },
        { "int", "_shr_bfcmap_port_state_t", 0, 0 },
        { "int", "_shr_bfcmap_8g_fw_on_active_t", 0, 0 },
        { "int", "_shr_bfcmap_map_table_input_t", 0, 0 },
        { "int", "_shr_bfcmap_map_table_input_t", 0, 0 },
        { "int", "_shr_bfcmap_fc_crc_mode_t", 0, 0 },
        { "int", "_shr_bfcmap_fc_crc_mode_t", 0, 0 },
        { "int", "_shr_bfcmap_vfthdr_proc_mode_t", 0, 0 },
        { "int", "_shr_bfcmap_vfthdr_proc_mode_t", 0, 0 },
        { "int", "_shr_bfcmap_vlantag_proc_mode_t", 0, 0 },
        { "int", "_shr_bfcmap_vlantag_proc_mode_t", 0, 0 },
        { "int", "_shr_bfcmap_vfid_mapsrc_t", 0, 0 },
        { "int", "_shr_bfcmap_vfid_mapsrc_t", 0, 0 },
        { "int", "_shr_bfcmap_vid_mapsrc_t", 0, 0 },
        { "int", "_shr_bfcmap_vid_mapsrc_t", 0, 0 },
        { "int", "_shr_bfcmap_vlan_pri_map_mode_t", 0, 0 },
        { "int", "_shr_bfcmap_vlan_pri_map_mode_t", 0, 0 },
        { "int", "_shr_bfcmap_hopcnt_check_mode_t", 0, 0 },
        { "uint32", "_shr_bfcmap_dev_addr_t", 0, 0 },
        { "uint8", "_shr_bmac_addr_t", 6, 1 },
        { "uint8", "_shr_bfcmap_wwn_t", 6, 1 },
        { "uint8", "_shr_bfcmap_nportid_t", 0, 0 },
        { "uint32", "_shr_bfcmap_pa_speed_t", 0, 0 },
#endif
#if _SHR_PBMP_WIDTH == 0
        { "uint32", "_shr_pbmp_t", 0, 0 },
#endif
        { "uint8", "uint8_t", 0, 0 }, 
        { "uint16", "uint16_t", 0, 0 }, 
        { "uint32", "uint32_t", 0, 0 }, 
        { "int32", "int32_t", 0, 0 }, 
#ifdef CPRIMOD_SUPPORT
        { "int", "_shr_cpri_hdlc_crc_byte_order_t", 0, 0 },
        { "int", "_shr_cpri_hdlc_fcs_err_check_t", 0, 0 },
        { "int", "_shr_cpri_hdlc_fcs_size_t", 0, 0 },
        { "int", "_shr_cpri_hdlc_filling_flag_pattern_t", 0, 0 },
        { "int", "_shr_cpri_hdlc_flag_size_t", 0, 0 },
        { "int", "_shr_cpri_hdlc_crc_mode_t", 0, 0 },
        { "int", "_shr_cpri_hdlc_crc_init_val_t", 0, 0 },
        { "int", "_shr_cpri_vsd_control_subchan_num_bytes_t", 0, 0 },
        { "int", "_shr_cpri_vsd_control_flow_num_bytes_t", 0, 0 },
        { "int", "_shr_cpri_vsd_control_subchan_size_t", 0, 0 },
        { "int", "_shr_cpri_cw_filter_mode_t", 0, 0 },
        { "int", "_shr_vsd_raw_map_mode_t", 0, 0 },
        { "int", "_shr_cpri_gcw_mask_t", 0, 0 },
        { "int", "_shr_rsvd4_control_msg_proc_type_t", 0, 0 },
        { "int", "_shr_cpri_tag_option_t", 0, 0 },
        { "int", "_shr_rsvd4_sync_count_cycle_t", 0, 0 },
        { "int", "_shr_rsvd4_crc_option_t", 0, 0 },
        { "int", "_shr_rsvd4_msg_ts_mode_t", 0, 0 },
        { "int", "_shr_cpri_1588_capture_mode_t", 0, 0 },
        { "int", "_shr_cpri_dir_t", 0, 0 },
        { "int", "_shr_cpri_interrupt_type_t", 0, 0 },
        { "int", "_shr_cpri_roe_payload_multiple_t", 0, 0 },
        { "int", "_shr_cpri_presentation_ts_attribute_t", 0, 0 },
        { "int", "_shr_cpri_frame_sync_mode_t", 0, 0 },
        { "int", "_shr_cpri_1588_ts_type_t", 0, 0 },
        { "int", "_shr_cpri_fec_ts_source_t", 0, 0 },
        { "int", "_shr_cpri_fec_aux_config_para_t", 0, 0 },
        { "int", "_shr_cpri_roe_frame_format_t", 0, 0 },
        { "int", "_shr_cpri_roe_ordering_info_option_t", 0, 0 },
        { "int", "_shr_cpri_roe_header_field_t", 0, 0 },
        { "int", "_shr_cpri_ecpri_header_field_t", 0, 0 },
        { "int", "_shr_rsvd4_sync_mode_t", 0, 0 },
        { "int", "_shr_cpri_fec_aux_config_t", 0, 0 },
        { "int", "_shr_cpri_port_speed_t", 0, 0 },
        { "int", "_shr_rsvd4_tx_config_t", 0, 0 },
        { "int", "_shr_rsvd4_rx_config_t", 0, 0 },
        { "int", "_shr_cpri_fec_stat_type_t", 0, 0 },
        { "int", "_shr_cpri_deubg_attr_t", 0, 0 },
#endif
        { NULL }, 
    }; 

/*
 * Custom Language extensions for BCM macros
 */
cint_ast_t* 
__BCM_PBMP_ITER_HANDLER(const char* name, cint_ast_t* arguments, cint_ast_t* statements)
{
    cint_ast_t* _for; 
    cint_ast_t* _if; 
    cint_ast_t* _condition;
    cint_ast_t* arg1; 

    /*
     * We only take two arguments
     */
    if(cint_ast_count(arguments) != 2) {
        cint_ast_error(arguments, CINT_E_BAD_AST, "wrong number of arguments to %s() -- expected 2, recieved %d", 
                       name, cint_ast_count(arguments)); 
        return NULL;
    }   
    arg1 = arguments->next; 

    /*
     * This returns the following code tree:
     *
     * for(arg1 = 0; arg1 < BCM_PBMP_PORT_MAX; arg1++) {
     *    if(BCM_PBMP_MEMBER(arg0, arg1) 
     *       [statements]
     *
     * to simulate BCM_PBMP_ITER()
 */
    

    /* Function call "BCM_PBMP_MEMBER(arg0, arg1)" */
    _condition = cint_ast_function(cint_ast_identifier("BCM_PBMP_MEMBER"), arguments); 
              
    /* if(BCM_PBMP_MEMBER(pbmp,port)) { statements } */
    _if = cint_ast_if(_condition, statements, 0); 
              
    /* for(arg1 = 0; arg1 < BCM_PBMP_PORT_MAX; arg1++) (condition) */
    _for = cint_ast_for( /* arg1 = 0 */       
                        cint_ast_operator(cintOpAssign,      
                                          arg1, 
                                          cint_ast_integer(0)), 
                        /* arg1 < BCM_PBMP_PORT_MAX */
                        cint_ast_operator(cintOpLessThan, 
                                          arg1,
                                          cint_ast_identifier("BCM_PBMP_PORT_MAX")), 

                        /* arg1++ */
                        cint_ast_operator(cintOpAssign, 
                                          arg1, 
                                          cint_ast_operator(cintOpAdd, 
                                                            arg1, 
                                                            cint_ast_integer(1))),

                        /* statements */
                        _if); 
    
    return _for; 
}

cint_ast_t*
__BCM_PKTIO_FID_SUPPORT_ITER_HANDLER(const char* name, cint_ast_t* arguments, cint_ast_t* statements)
{
    cint_ast_t* _for;
    cint_ast_t* _if;
    cint_ast_t* _condition;
    cint_ast_t* arg1;

    /*
     * We only take two arguments
     */
    if(cint_ast_count(arguments) != 2) {
        cint_ast_error(arguments, CINT_E_BAD_AST, "wrong number of arguments to %s() -- expected 2, recieved %d",
                       name, cint_ast_count(arguments));
        return NULL;
    }
    arg1 = arguments->next;

    /*
     * This returns the following code tree:
     *
     * for(arg1 = BCM_PKTIO_FID_INVALID + 1; arg1 < BCM_PKTIO_FID_COUNT; arg1++) {
     *    if(BCM_PKTIO_FID_SUPPORT_GET(arg0, arg1)
     *       [statements]
     *
     * to simulate BCM_PKTIO_FID_SUPPORT_ITER()
 */


    /* Function call "BCM_PKTIO_FID_SUPPORT_GET(arg0, arg1)" */
    _condition = cint_ast_function(cint_ast_identifier("BCM_PKTIO_FID_SUPPORT_GET"), arguments);

    /* if(BCM_PKTIO_FID_SUPPORT_GET(arg0,arg1)) { statements } */
    _if = cint_ast_if(_condition, statements, 0);

    /* for(arg1 = BCM_PKTIO_FID_INVALID + 1; arg1 < BCM_PKTIO_FID_COUNT; arg1++) (condition) */
    _for = cint_ast_for( /* arg1 = BCM_PKTIO_FID_INVALID + 1 */
                        cint_ast_operator(cintOpAssign,
                                          arg1,
                                          cint_ast_integer(BCM_PKTIO_FID_INVALID + 1)),
                        /* arg1 < BCM_PKTIO_FID_COUNT */
                        cint_ast_operator(cintOpLessThan,
                                          arg1,
                                          cint_ast_integer(BCM_PKTIO_FID_COUNT)),

                        /* arg1++ */
                        cint_ast_operator(cintOpAssign,
                                          arg1,
                                          cint_ast_operator(cintOpAdd,
                                                            arg1,
                                                            cint_ast_integer(1))),

                        /* statements */
                        _if);

    return _for;
}

cint_ast_t*
__BCM_PKTIO_REASON_ITER_HANDLER(const char* name, cint_ast_t* arguments, cint_ast_t* statements)
{
    cint_ast_t* _for;
    cint_ast_t* _if;
    cint_ast_t* _condition;
    cint_ast_t* arg1;

    /*
     * We only take two arguments
     */
    if(cint_ast_count(arguments) != 2) {
        cint_ast_error(arguments, CINT_E_BAD_AST, "wrong number of arguments to %s() -- expected 2, recieved %d",
                       name, cint_ast_count(arguments));
        return NULL;
    }
    arg1 = arguments->next;

    /*
     * This returns the following code tree:
     *
     * for(arg1 = BCM_PKTIO_REASON_NONE; arg1 < BCM_PKTIO_REASON_COUNTS; arg1++) {
     *    if(BCM_PKTIO_REASON_GET(arg0, arg1)
     *       [statements]
     *
     * to simulate BCM_PKTIO_REASON_ITER()
 */


    /* Function call "BCM_PKTIO_REASON_GET(arg0, arg1)" */
    _condition = cint_ast_function(cint_ast_identifier("BCM_PKTIO_REASON_GET"), arguments);

    /* if(BCM_PKTIO_REASON_GET(arg0,arg1)) { statements } */
    _if = cint_ast_if(_condition, statements, 0);

    /* for(arg1 = BCM_PKTIO_REASON_NONE; arg1 < BCM_PKTIO_REASON_COUNTS; arg1++) (condition) */
    _for = cint_ast_for( /* arg1 = BCM_PKTIO_REASON_NONE*/
                        cint_ast_operator(cintOpAssign,
                                          arg1,
                                          cint_ast_integer(BCM_PKTIO_REASON_NONE)),
                        /* arg1 < BCM_PKTIO_REASON_COUNTS*/
                        cint_ast_operator(cintOpLessThan,
                                          arg1,
                                          cint_ast_integer(BCM_PKTIO_REASON_COUNTS)),

                        /* arg1++ */
                        cint_ast_operator(cintOpAssign,
                                          arg1,
                                          cint_ast_operator(cintOpAdd,
                                                            arg1,
                                                            cint_ast_integer(1))),

                        /* statements */
                        _if);

    return _for;
}

cint_ast_t*
__BCM_PKTIO_MATCH_ID_ITER_HANDLER(const char* name, cint_ast_t* arguments, cint_ast_t* statements)
{
    cint_ast_t* _for;
    cint_ast_t* _if;
    cint_ast_t* _condition;
    cint_ast_t* arg1;

    /*
     * We only take two arguments
     */
    if(cint_ast_count(arguments) != 2) {
        cint_ast_error(arguments, CINT_E_BAD_AST, "wrong number of arguments to %s() -- expected 2, recieved %d",
                       name, cint_ast_count(arguments));
        return NULL;
    }
    arg1 = arguments->next;

    /*
     * This returns the following code tree:
     *
     * for(arg1 = BCM_PKTIO_MATCH_ID_NONE; arg1 < BCM_PKTIO_REASON_COUNT; arg1++) {
     *    if(BCM_PKTIO_MATCH_ID_GET(arg0, arg1)
     *       [statements]
     *
     * to simulate BCM_PKTIO_MATCH_ID_ITER()
 */


    /* Function call "BCM_PKTIO_MATCH_ID_GET(arg0, arg1)" */
    _condition = cint_ast_function(cint_ast_identifier("BCM_PKTIO_MATCH_ID_GET"), arguments);

    /* if(BCM_PKTIO_MATCH_ID_GET(arg0,arg1)) { statements } */
    _if = cint_ast_if(_condition, statements, 0);

    /* for(arg1 = BCM_PKTIO_MATCH_ID_NONE; arg1 < BCM_PKTIO_MATCH_ID_COUNT; arg1++) (condition) */
    _for = cint_ast_for( /* arg1 = BCM_PKTIO_MATCH_ID_NONE*/
                        cint_ast_operator(cintOpAssign,
                                          arg1,
                                          cint_ast_integer(BCM_PKTIO_MATCH_ID_NONE)),
                        /* arg1 < BCM_PKTIO_MATCH_ID_COUNT*/
                        cint_ast_operator(cintOpLessThan,
                                          arg1,
                                          cint_ast_integer(BCM_PKTIO_MATCH_ID_COUNT)),

                        /* arg1++ */
                        cint_ast_operator(cintOpAssign,
                                          arg1,
                                          cint_ast_operator(cintOpAdd,
                                                            arg1,
                                                            cint_ast_integer(1))),

                        /* statements */
                        _if);

    return _for;
}

cint_ast_t* 
__BCM_RX_REASON_ITER_HANDLER(const char* name, cint_ast_t* arguments, cint_ast_t* statements)
{
    cint_ast_t* _for; 
    cint_ast_t* _if; 
    cint_ast_t* _condition;
    cint_ast_t* arg1; 

    /*
     * We only take two arguments
     */
    if(cint_ast_count(arguments) != 2) {
        cint_ast_error(arguments, CINT_E_BAD_AST, "wrong number of arguments to %s() -- expected 2, recieved %d", 
                       name, cint_ast_count(arguments)); 
        return NULL;
    }   
    arg1 = arguments->next; 

    /*
     * This returns the following code tree:
     *
     * for(arg1 = bcmRxReasonInvalid; arg1 < bcmRxReasonCount; arg1++) {
     *    if(BCM_RX_REASON_GET(arg0, arg1) 
     *       [statements]
     *
     * to simulate BCM_RX_REASON_ITER()
 */
    

    /* Function call "BCM_PBMP_MEMBER(arg0, arg1)" */
    _condition = cint_ast_function(cint_ast_identifier("BCM_RX_REASON_GET"), arguments); 
              
    /* if(BCM_RX_REASON_GET(arg0,arg1)) { statements } */
    _if = cint_ast_if(_condition, statements, 0); 
              
    /* for(arg1 = bcmRxReasonInvalid; arg1 < bcmRxReasonCount; arg1++) (condition) */
    _for = cint_ast_for( /* arg1 = bcmRxReasonInvalid */       
                        cint_ast_operator(cintOpAssign,      
                                          arg1, 
                                          cint_ast_integer(bcmRxReasonInvalid)), 
                        /* arg1 < bcmRxReasonCount */
                        cint_ast_operator(cintOpLessThan, 
                                          arg1,
                                          cint_ast_integer(bcmRxReasonCount)), 

                        /* arg1++ */
                        cint_ast_operator(cintOpAssign, 
                                          arg1, 
                                          cint_ast_operator(cintOpAdd, 
                                                            arg1, 
                                                            cint_ast_integer(1))),

                        /* statements */
                        _if); 
    
    return _for; 
}

static cint_ast_t*
__BCM_IF_ERROR_RETURN_HANDLER(const char* name, cint_ast_t* arguments)
{
    /* Inserts the following code:
       
    do { int __rv__; if ((__rv__ = (arguments)) < 0) return(__rv__); } while(0)

       This is equivalent to the BCM_IF_ERROR_RETURN() macro 
    */
    cint_ast_t* _while; 
    cint_ast_t* __rv__ = cint_ast_identifier("__rv__"); 
    cint_ast_t* _decl_rv = cint_ast_declaration(); 
    cint_ast_t* _if; 
    cint_ast_t* _statements; 

    /* Declare __rv__ = (arguments) */
    _decl_rv->utype.declaration.type = cint_ast_type("int"); 
    _decl_rv->utype.declaration.pcount = 0; 
    _decl_rv->utype.declaration.num_dimension_initializers = 0; 
    _decl_rv->utype.declaration.identifier = __rv__; 
    _decl_rv->utype.declaration.init = arguments; 
    
    _if = cint_ast_if(cint_ast_operator(cintOpLessThan, 
                                        __rv__, 
                                        cint_ast_integer(0)), 
                      cint_ast_return(__rv__), 
                      NULL); 

    /* Make the if statement come after the declaration */
    cint_ast_append(_decl_rv, _if); 
                      
    /* Need braces around statement list */
    _statements = cint_ast_operator(cintOpOpenBrace, 0, 0); 
    _statements->next = _decl_rv; 
    cint_ast_append(_statements, cint_ast_operator(cintOpCloseBrace, 0, 0)); 

    _while = cint_ast_while(/* while(0) */
                            cint_ast_integer(0), 
                            
                            /* statements */
                            _statements, 

                            /* order */
                            1); 
    return _while; 
}

static cint_custom_iterator_t __sdk_custom_iterators[] = 
    {
        { "BCM_PBMP_ITER", __BCM_PBMP_ITER_HANDLER },
        { "BCM_PKTIO_FID_SUPPORT_ITER", __BCM_PKTIO_FID_SUPPORT_ITER_HANDLER},
        { "BCM_PKTIO_REASON_ITER", __BCM_PKTIO_REASON_ITER_HANDLER},
        { "BCM_PKTIO_MATCH_ID_ITER", __BCM_PKTIO_MATCH_ID_ITER_HANDLER},
        { "BCM_RX_REASON_ITER", __BCM_RX_REASON_ITER_HANDLER }, 
        { NULL }
    }; 

static cint_custom_macro_t __sdk_custom_macros[] = 
    {
        { "BCM_IF_ERROR_RETURN", __BCM_IF_ERROR_RETURN_HANDLER }, 
        { NULL }
    }; 



/*
 * Structures defined in <shared> which are #defined or typedef'ed to BCM datatypes. 
 * These have to be handled manually. 
 */
static void*
__cint_maddr__shr_port_ability_t(void* p, int mnum, cint_struct_type_t* parent)
{
    void* rv;
    _shr_port_ability_t* s = (_shr_port_ability_t*) p;
    
    switch(mnum)
        {
        case 0: rv = &(s->speed_half_duplex); break;
        case 1: rv = &(s->speed_full_duplex); break;
        case 2: rv = &(s->pause); break;
        case 3: rv = &(s->interface); break;
        case 4: rv = &(s->medium); break;
        case 5: rv = &(s->loopback); break;
        case 6: rv = &(s->flags); break;
        case 7: rv = &(s->eee); break;
        case 8: rv = &(s->rsvd); break;
        case 9: rv = &(s->encap); break;
        case 10: rv = &(s->fec); break;
        case 11: rv = &(s->channel);break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t __cint_struct_members__shr_port_ability_t[] = 
    {
        { "_shr_port_mode_t", "speed_half_duplex", 0, 0 },
        { "_shr_port_mode_t", "speed_full_duplex", 0, 0 },
        { "_shr_port_mode_t", "pause", 0, 0 },
        { "_shr_port_mode_t", "interface", 0, 0 },
        { "_shr_port_mode_t", "medium", 0, 0 }, 
        { "_shr_port_mode_t", "loopback", 0, 0 },
        { "_shr_port_mode_t", "flags", 0, 0 },
        { "_shr_port_mode_t", "eee", 0, 0 },
        { "_shr_port_mode_t", "rsvd", 0, 0 },
        { "_shr_port_mode_t", "encap", 0, 0 },
        { "_shr_port_mode_t", "fec", 0, 0 },
        { "_shr_port_mode_t", "channel", 0, 0 },
        { NULL }
    }; 

static void*
__cint_maddr__shr_port_timestamp_adjust_t(void* p, int mnum, cint_struct_type_t* parent)
{
    void* rv;
    _shr_port_timestamp_adjust_t* s = (_shr_port_timestamp_adjust_t*) p;

    switch(mnum)
        {
        case 0: rv = &(s->osts_adjust); break;
        case 1: rv = &(s->tsts_adjust); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t __cint_struct_members__shr_port_timestamp_adjust_t[] =
    {
        { "uint32", "osts_adjust", 0, 0 },
        { "uint32", "tsts_adjust", 0, 0 },
        { NULL }
    };

static void*
__cint_maddr__shr_rx_reasons_t(void* p, int mnum, cint_struct_type_t* parent)
{
    void* rv;
    _shr_rx_reasons_t* s = (_shr_rx_reasons_t*) p;
    
    switch(mnum)
        {
        case 0: rv = &(s->pbits); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t __cint_struct_members__shr_rx_reasons_t[] = 
    {
        { "SHR_BITDCL", "pbits", 0, _SHR_BITDCLSIZE(_SHR_RX_REASON_COUNT)},
        { NULL }
    }; 

#if _SHR_PBMP_WIDTH != 0		/* new style */
static void*
__cint_maddr__shr_pbmp_t(void* p, int mnum, cint_struct_type_t* parent)
{
    void* rv;
    _shr_pbmp_t* s = (_shr_pbmp_t*) p;
    
    switch(mnum)
        {
        case 0: rv = &(s->pbits); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t __cint_struct_members__shr_pbmp_t[] = 
    {
        { "uint32", "pbits", 0, _SHR_PBMP_WORD_MAX},
        { NULL }
    }; 

#endif


#ifdef INCLUDE_FCMAP

static cint_parameter_desc_t __cint_struct_members___shr_bfcmap_cos_to_pri_t[] = 
    {
	{ "uint16",   "cos", 0, 0 },
	{ "uint16",   "pri", 0, 0 },
        { NULL }
   };

static void*
__cint_maddr__shr_bfcmap_cos_to_pri_t(void* p, int mnum, cint_struct_type_t* parent)
{
    void* rv;
    _shr_bfcmap_cos_to_pri_t* s = (_shr_bfcmap_cos_to_pri_t*) p;
    
    switch(mnum)
        {
        case 0: rv = &(s->cos); break;
        case 1: rv = &(s->pri); break;
        default: rv = NULL; break;
    }

    return rv;
}
#endif

#ifdef INCLUDE_FCMAP
static cint_parameter_desc_t __cint_struct_members__shr_bfcmap_port_config_t[] = 
    {
        { "uint32", "action_mask", 0, 0},
        { "uint32", "action_mask2", 0, 0},
        { "_shr_bfcmap_port_mode_t",  "port_mode", 0, 0 },
        { "_shr_bfcmap_port_speed_t", "speed", 0, 0 },
        { "int", "tx_buffer_to_buffer_credits", 0, 0 },
        { "int", "rx_buffer_to_buffer_credits", 0, 0 },
        { "int", "max_frame_length", 0, 0 },
        { "int", "bb_sc_n", 0, 0 },
        { "_shr_bfcmap_port_state_t", "port_state", 0, 0 },
        { "int", "r_t_tov", 0, 0 },
        { "int", "interrupt_enable", 0, 0 },
        { "_shr_bfcmap_8g_fw_on_active_t", "fw_on_active_8g", 0, 0 },
        { "int", "src_mac_construct", 0, 0 },
        { "bcm_mac_t", "src_mac_addr", 0, 0 },
        { "uint32", "src_fcmap_prefix", 0, 0 },
        { "int", "dst_mac_construct", 0, 0 },
        { "bcm_mac_t", "dst_mac_addr", 0, 0 },
        { "uint32", "dst_fcmap_prefix", 0, 0 },
        { "uint32", "vlan_tag", 0, 0 },
        { "uint32", "vft_tag", 0, 0 },
        { "int", "mapper_len", 0, 0 },
        { "int", "ingress_mapper_bypass", 0, 0 },
        { "int", "egress_mapper_bypass", 0, 0 },
        { "_shr_bfcmap_map_table_input_t", "ingress_map_table_input", 0, 0 },
        { "_shr_bfcmap_map_table_input_t", "egress_map_table_input", 0, 0 },
        { "_shr_bfcmap_fc_crc_mode_t", "ingress_fc_crc_mode", 0, 0 },
        { "_shr_bfcmap_fc_crc_mode_t", "egress_fc_crc_mode", 0, 0 },
        { "_shr_bfcmap_vfthdr_proc_mode_t", "ingress_vfthdr_proc_mode", 0, 0 },
        { "_shr_bfcmap_vfthdr_proc_mode_t", "egress_vfthdr_proc_mode", 0, 0 },
        { "_shr_bfcmap_vlantag_proc_mode_t", "ingress_vlantag_proc_mode", 0, 0 },
        { "_shr_bfcmap_vlantag_proc_mode_t", "egress_vlantag_proc_mode", 0, 0 },
        { "_shr_bfcmap_vfid_mapsrc_t", "ingress_vfid_mapsrc", 0, 0 },
        { "_shr_bfcmap_vfid_mapsrc_t", "egress_vfid_mapsrc", 0, 0 },
        { "_shr_bfcmap_vid_mapsrc_t", "ingress_vid_mapsrc", 0, 0 },
        { "_shr_bfcmap_vid_mapsrc_t", "egress_vid_mapsrc", 0, 0 },
        { "_shr_bfcmap_vlan_pri_map_mode_t", "ingress_vlan_pri_map_mode", 0, 0 },
        { "_shr_bfcmap_vlan_pri_map_mode_t", "egress_vlan_pri_map_mode", 0, 0 },
        { "_shr_bfcmap_hopcnt_check_mode_t", "ingress_hopCnt_check_mode", 0, 0 },
        { "int", "egress_hopCnt_dec_enable", 0, 0 },
        { "int", "use_tts_pcs_16G", 0, 0 },
        { "int", "use_tts_pcs_32G", 0, 0 },
        { "int", "training_enable_16G", 0, 0 },
        { "int", "training_enable_32G", 0, 0 },
        { "int", "fec_enable_16G", 0, 0 },
        { "int", "fec_enable_32G", 0, 0 },
        { "int", "ingress_fcs_crrpt_eof_enable", 0, 0 },
        { "int", "ingress_vlantag_presence_enable", 0, 0 },
        { "_shr_bfcmap_hopcnt_check_mode_t", "egress_hopcnt_check_mode", 0, 0 },
        { "int", "ingress_hopcnt_dec_enable", 0, 0 },
        { "int", "egress_pass_ctrl_frame_enable", 0, 0 },
        { "int", "egress_pass_pfc_frame_enable", 0, 0 },
        { "int", "egress_pass_pause_frame_enable", 0, 0 },
        { "int", "egress_fcoe_version_chk_disable", 0, 0 },
        { "int", "egress_default_cos_value", 0, 0 },
        { "int", "egress_use_ip_cos_map", 0, 0 },
        { "uint32", "scrambling_enable_mask", 0, 0 },
        { "uint32", "scrambling_enable_value", 0, 0 },
        { "int", "egress_pause_enable", 0, 0 },
        { "int", "egress_pfc_enable", 0, 0 },
        { "int", "stat_interval", 0, 0 },
        { "uint32", "trcm_attribs", 0, 0 },
        { "_shr_bfcmap_cos_to_pri_t", "cos_to_pri", 0, 0 },
        { NULL }
   };

static void*
__cint_maddr__shr_bfcmap_port_config_t(void* p, int mnum, cint_struct_type_t* parent)
{
    void* rv;
    _shr_bfcmap_port_config_t* s = (_shr_bfcmap_port_config_t*) p;
    
    switch(mnum)
        {
        case 0: rv = &(s->action_mask); break;
        case 1: rv = &(s->action_mask2); break;
        case 2: rv = &(s->port_mode); break;
        case 3: rv = &(s->speed); break;
        case 4: rv = &(s->tx_buffer_to_buffer_credits); break;
        case 5: rv = &(s->rx_buffer_to_buffer_credits); break;
        case 6: rv = &(s->max_frame_length); break;
        case 7: rv = &(s->bb_sc_n); break;
        case 8: rv = &(s->port_state); break;
        case 9: rv = &(s->r_t_tov); break;
        case 10: rv = &(s->interrupt_enable); break;
        case 11: rv = &(s->fw_on_active_8g); break;
        case 12: rv = &(s->src_mac_construct); break;
        case 13: rv = &(s->src_mac_addr[0]); break;
        case 14: rv = &(s->src_fcmap_prefix); break;
        case 15: rv = &(s->dst_mac_construct); break;
        case 16: rv = &(s->dst_mac_addr[0]); break;
        case 17: rv = &(s->dst_fcmap_prefix); break;
        case 18: rv = &(s->vlan_tag); break;
        case 19: rv = &(s->vft_tag); break;
        case 20: rv = &(s->mapper_len); break;
        case 21: rv = &(s->ingress_mapper_bypass); break;
        case 22: rv = &(s->egress_mapper_bypass); break;
        case 23: rv = &(s->ingress_map_table_input); break;
        case 24: rv = &(s->egress_map_table_input); break;
        case 25: rv = &(s->ingress_fc_crc_mode); break;
        case 26: rv = &(s->egress_fc_crc_mode); break;
        case 27: rv = &(s->ingress_vfthdr_proc_mode); break;
        case 28: rv = &(s->egress_vfthdr_proc_mode); break;
        case 29: rv = &(s->ingress_vlantag_proc_mode); break;
        case 30: rv = &(s->egress_vlantag_proc_mode); break;
        case 31: rv = &(s->ingress_vfid_mapsrc); break;
        case 32: rv = &(s->egress_vfid_mapsrc); break;
        case 33: rv = &(s->ingress_vid_mapsrc); break;
        case 34: rv = &(s->egress_vid_mapsrc); break;
        case 35: rv = &(s->ingress_vlan_pri_map_mode); break;
        case 36: rv = &(s->egress_vlan_pri_map_mode); break;
        case 37: rv = &(s->ingress_hopCnt_check_mode); break;
        case 38: rv = &(s->egress_hopCnt_dec_enable); break;
        case 39: rv = &(s->use_tts_pcs_16G); break;
        case 40: rv = &(s->use_tts_pcs_32G); break;
        case 41: rv = &(s->training_enable_16G); break;
        case 42: rv = &(s->training_enable_32G); break;
        case 43: rv = &(s->fec_enable_16G); break;
        case 44: rv = &(s->fec_enable_32G); break;
        case 45: rv = &(s->ingress_fcs_crrpt_eof_enable); break;
        case 46: rv = &(s->ingress_vlantag_presence_enable); break;
        case 47: rv = &(s->egress_hopcnt_check_mode); break;
        case 48: rv = &(s->ingress_hopcnt_dec_enable); break;
        case 49: rv = &(s->egress_pass_ctrl_frame_enable); break;
        case 50: rv = &(s->egress_pass_pfc_frame_enable); break;
        case 51: rv = &(s->egress_pass_pause_frame_enable); break;
        case 52: rv = &(s->egress_fcoe_version_chk_disable); break;
        case 53: rv = &(s->egress_default_cos_value); break;
        case 54: rv = &(s->egress_use_ip_cos_map); break;
        case 55: rv = &(s->scrambling_enable_mask); break;
        case 56: rv = &(s->scrambling_enable_value); break;
        case 57: rv = &(s->egress_pause_enable); break;
        case 58: rv = &(s->egress_pfc_enable); break;
        case 59: rv = &(s->stat_interval); break;
        case 60: rv = &(s->trcm_attribs); break;
        case 61: rv = &(s->cos_to_pri); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t __cint_struct_members___shr_bfcmap_vlan_vsan_map_t[] = 
    {
	{ "uint16",   "vlan_vid", 0, 0 },
	{ "uint16",   "vsan_vfid", 0, 0 },
        { NULL }
   };

static void*
__cint_maddr__shr_bfcmap_vlan_vsan_map_t(void* p, int mnum, cint_struct_type_t* parent)
{
    void* rv;
    _shr_bfcmap_vlan_vsan_map_t* s = (_shr_bfcmap_vlan_vsan_map_t*) p;
    
    switch(mnum)
        {
        case 0: rv = &(s->vlan_vid); break;
        case 1: rv = &(s->vsan_vfid); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t __cint_struct_members___shr_bfcmap_port_ability_t[] = 
    {
	{ "_shr_bfcmap_pa_speed_t",   "port_ability_speed", 0, 0 },
        { NULL }
   };

static void*
__cint_maddr__shr_bfcmap_port_ability_t(void* p, int mnum, cint_struct_type_t* parent)
{
    void* rv;
    _shr_bfcmap_port_ability_t* s = (_shr_bfcmap_port_ability_t*) p;
    
    switch(mnum)
        {
        case 0: rv = &(s->port_ability_speed); break;
        default: rv = NULL; break;
    }

    return rv;
}
#endif



static void*
__cint_maddr__shr_port_cable_diag_t(void* p, int mnum, cint_struct_type_t* parent)
{
    void* rv;
    _shr_port_cable_diag_t* s = (_shr_port_cable_diag_t*) p;
    
    switch(mnum)
        {
        case 0: rv = &(s->state); break;
        case 1: rv = &(s->npairs); break;
        case 2: rv = &(s->pair_state); break;
        case 3: rv = &(s->pair_len); break;
        case 4: rv = &(s->fuzz_len); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t __cint_struct_members__shr_phy_config_t[] = 
    {
        { "int", "enable", 0, 0 }, 
        { "int", "preferred", 0, 0 }, 
        { "int", "autoneg_enable", 0, 0 }, 
        { "_shr_port_mode_t", "autoneg_advert", 0, 0 }, 
        { "_shr_port_ability_t", "advert_ability", 0, 0 }, 
        { "int", "force_speed", 0, 0 }, 
        { "int", "force_duplex", 0, 0 },
        { "int", "master", 0, 0 }, 
        { "_shr_port_mdix_t", "mdix", 0, 0 },         
        { NULL }
    }; 

static void*
__cint_maddr__shr_phy_config_t(void* p, int mnum, cint_struct_type_t* parent)
{
    void* rv;
    _shr_phy_config_t* s = (_shr_phy_config_t*) p;
    
    switch(mnum)
        {
        case 0: rv = &(s->enable); break;
        case 1: rv = &(s->preferred); break;
        case 2: rv = &(s->autoneg_enable); break;
        case 3: rv = &(s->autoneg_advert); break;
        case 4: rv = &(s->advert_ability); break;
        case 5: rv = &(s->force_speed); break;
        case 6: rv = &(s->force_duplex); break;
        case 7: rv = &(s->master); break;
        case 8: rv = &(s->mdix); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t __cint_struct_members__shr_port_cable_diag_t[] = 
    {
        { "_shr_port_cable_state_t", "state", 0, 0 },
        { "int", "npairs", 0, 0 },
        { "_shr_port_cable_state_t", "pair_state", 0, 4 },
        { "int", "pair_len", 0, 4 },
        { "int", "fuzz_len", 0, 0 }, 
        { NULL }
}; 

static void*
__cint_maddr__shr_switch_temperature_monitor_t(void* p, int mnum, cint_struct_type_t* parent)
{
    void* rv;
    _shr_switch_temperature_monitor_t* s = (_shr_switch_temperature_monitor_t*) p;

    switch(mnum)
        {
        case 0: rv = &(s->curr); break;
        case 1: rv = &(s->peak); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t __cint_struct_members__shr_switch_temperature_monitor_t[] =
    {
        { "int", "curr", 0, 0 },
        { "int", "peak", 0, 0 },
        { NULL }
};

#ifdef CPRIMOD_SUPPORT

static void*
__cint_maddr__shr_cpri_presentation_time_t(void* p, int mnum,
                                          cint_struct_type_t* parent)
{
    void* rv;
    _shr_cpri_presentation_time_t* s = (_shr_cpri_presentation_time_t*) p;

    switch(mnum)
        {
        case 0: rv = &(s->time); break;
        default: rv = NULL; break;
    }

    return rv;
}


static cint_parameter_desc_t
       __cint_struct_members__shr_cpri_presentation_time_t[] =
{
    { "uint32", "time", 0, 0 },
    { NULL }
};

static void*
__cint_maddr__shr_cpri_decap_presentation_config_t(void* p, int mnum,
                                          cint_struct_type_t* parent)
{
    void* rv;
    _shr_cpri_decap_presentation_config_t* s =
                                   (_shr_cpri_decap_presentation_config_t*) p;

    switch(mnum)
        {
        case 0: rv = &(s->time_mod_offset); break;
        case 1: rv = &(s->mod_count); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t
       __cint_struct_members__shr_cpri_decap_presentation_config_t[] =
{
    { "uint32", "time_mod_offset", 0, 0 },
    { "uint32", "mod_count", 0, 0 },
    { NULL }
};

static void*
__cint_maddr__shr_cpri_fast_eth_config_t(void* p, int mnum, cint_struct_type_t* parent)
{
    void* rv;
    _shr_cpri_fast_eth_config_t* s = (_shr_cpri_fast_eth_config_t*) p;

    switch(mnum)
        {
        case 0: rv = &(s->queue_num); break;
        case 1: rv = &(s->no_fcs_err_check); break;
        case 2: rv = &(s->min_packet_size); break;
        case 3: rv = &(s->max_packet_size); break;
        case 4: rv = &(s->min_packet_drop); break;
        case 5: rv = &(s->max_packet_drop); break;
        case 6: rv = &(s->strip_crc); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t __cint_struct_members__shr_cpri_fast_eth_config_t[] =
{
    { "uint32", "queue_num", 0, 0 },
    { "uint32", "no_fcs_err_check", 0, 0 },
    { "uint32", "min_packet_size", 0, 0 },
    { "uint32", "max_packet_size", 0, 0 },
    { "int", "min_packet_drop", 0, 0 },
    { "int", "max_packet_drop", 0, 0 },
    { "int", "strip_crc[p", 0, 0 },
    { NULL }
};

static void*
__cint_maddr__shr_cpri_tag_gen_entry_t(void* p, int mnum, cint_struct_type_t* parent)
{
    void* rv;
    _shr_cpri_tag_gen_entry_t* s = (_shr_cpri_tag_gen_entry_t*) p;

    switch(mnum)
        {
        case 0: rv = &(s->tag_id); break;
        case 1: rv = &(s->mask); break;
        case 2: rv = &(s->header); break;
        case 3: rv = &(s->word_count); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t __cint_struct_members__shr_cpri_tag_gen_entry_t[] =
{
    { "uint32", "tag_id", 0, 0 },
    { "uint32", "mask", 0, 0 },
    { "uint32", "header", 0, 0 },
    { "uint32", "word_count", 0, 0 },
    { NULL }
};

static void*
__cint_maddr__shr_cpri_rx_vsd_flow_info_t(void* p, int mnum,
                                          cint_struct_type_t* parent)
{
    void* rv;
    _shr_cpri_rx_vsd_flow_info_t* s = (_shr_cpri_rx_vsd_flow_info_t*) p;

    switch(mnum)
        {
        case 0: rv = &(s->hyper_frame_number); break;
        case 1: rv = &(s->hyper_frame_modulo); break;
        case 2: rv = &(s->filter_zero_data); break;
        case 3: rv = &(s->section_num); break;
        case 4: rv = &(s->num_sector); break;
        case 5: rv = &(s->tag_id); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t
       __cint_struct_members__shr_cpri_rx_vsd_flow_info_t[] =
{
    { "uint32", "hyper_frame_number", 0, 0 },
    { "uint32", "hyper_frame_modulo", 0, 0 },
    { "int", "filter_zero_data", 0, 0 },
    { "uint32", "section_num", 0, 4 },
    { "uint32", "num_sector", 0, 0 },
    { "uint32", "tag_id", 0, 0 },
    { NULL }
};

static void*
__cint_maddr__shr_cpri_tx_vsd_flow_info_t(void* p, int mnum,
                                          cint_struct_type_t* parent)
{
    void* rv;
    _shr_cpri_tx_vsd_flow_info_t* s = (_shr_cpri_tx_vsd_flow_info_t*) p;

    switch(mnum)
        {
        case 0: rv = &(s->hyper_frame_number); break;
        case 1: rv = &(s->hyper_frame_modulo); break;
        case 2: rv = &(s->repeat_mode); break;
        case 3: rv = &(s->section_num); break;
        case 4: rv = &(s->num_sector); break;
        case 5: rv = &(s->roe_flow_id); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t
       __cint_struct_members__shr_cpri_tx_vsd_flow_info_t[] =
{
    { "uint32", "hyper_frame_number", 0, 0 },
    { "uint32", "hyper_frame_modulo", 0, 0 },
    { "int", "repeat_mode", 0, 0 },
    { "uint32", "section_num", 0, 4 },
    { "uint32", "num_sector", 0, 0 },
    { "uint32", "roe_flow_id", 0, 0 },
    { NULL }
};

static void*
__cint_maddr__shr_cpri_1588_timestamp_ts_config_t(void* p, int mnum,
                                          cint_struct_type_t* parent)
{
    void* rv;
    _shr_cpri_1588_timestamp_ts_config_t* s =
                                     (_shr_cpri_1588_timestamp_ts_config_t*) p;

    switch(mnum)
        {
        case 0: rv = &(s->enable); break;
        case 1: rv = &(s->modulo_count); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t
       __cint_struct_members__shr_cpri_1588_timestamp_ts_config_t[] =
{
    { "int", "enable", 0, 0 },
    { "uint32", "modulo_count", 0, 0 },
    { NULL }
};

static void*
__cint_maddr__shr_cpri_intr_info_t(void* p, int mnum,
                                   cint_struct_type_t* parent)
{
    void* rv;
    _shr_cpri_intr_info_t* s =
                           (_shr_cpri_intr_info_t*) p;

    switch(mnum)
        {
        case 0: rv = &(s->cpri_intr_type); break;
        case 1: rv = &(s->axc_id); break;
        case 2: rv = &(s->queue_num); break;
        case 3: rv = &(s->data); break;
        case 4: rv = &(s->data64); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t
       __cint_struct_members__shr_cpri_intr_info_t[] =
{
    { "_shr_cpri_interrupt_type_t", "cpri_intr_type", 0, 0 },
    { "int", "axc_id", 0, 0 },
    { "int", "queue_num", 0, 0 },
    { "int", "data", 0, 0 },
    { "uint64", "data64", 0, _shrIntrDataNumOfData64},
    { NULL }
};


static void*
__cint_maddr__shr_cpri_fec_timestamp_config_t(void* p, int mnum,
                                   cint_struct_type_t* parent)
{
    void* rv;
    _shr_cpri_fec_timestamp_config_t* s =
                           (_shr_cpri_fec_timestamp_config_t*) p;

    switch(mnum)
        {
        case 0: rv = &(s->enable); break;
        case 1: rv = &(s->fec_fifo_ts_source_select); break;
        case 2: rv = &(s->fec_cmic_ts_source_select); break;
        case 3: rv = &(s->control_bit_offset_0); break;
        case 4: rv = &(s->control_bit_offset_1); break;
        case 5: rv = &(s->control_bit_offset_2); break;
        case 6: rv = &(s->control_bit_offset_3); break;
        default: rv = NULL; break;
    }

    return rv;
}

static cint_parameter_desc_t
       __cint_struct_members__shr_cpri_fec_timestamp_config_t[] =
{
    { "int", "enable", 0, 0 },
    { "_shr_cpri_fec_ts_source_t", "fec_fifo_ts_source_select", 0, 0 },
    { "_shr_cpri_fec_ts_source_t", "fec_cmic_ts_source_select", 0, 0 },
    { "uint32", "control_bit_offset_0", 0, 0 },
    { "uint32", "control_bit_offset_1", 0, 0 },
    { "uint32", "control_bit_offset_2", 0, 0 },
    { "uint32", "control_bit_offset_0", 0, 0 },
    { NULL }
};

#endif

cint_struct_type_t __cint_sdk_structures[] = 
    {
        {
            "_shr_port_ability_t",
            sizeof(_shr_port_ability_t), 
            __cint_struct_members__shr_port_ability_t, 
            __cint_maddr__shr_port_ability_t
        },
        {
            "_shr_port_cable_diag_t", 
            sizeof(_shr_port_cable_diag_t), 
            __cint_struct_members__shr_port_cable_diag_t,
            __cint_maddr__shr_port_cable_diag_t
        }, 
        {
            "_shr_phy_config_t", 
            sizeof(_shr_phy_config_t), 
            __cint_struct_members__shr_phy_config_t, 
            __cint_maddr__shr_phy_config_t, 
        },
#ifdef INCLUDE_FCMAP
        {
            "_shr_bfcmap_port_config_t",
            sizeof(_shr_bfcmap_port_config_t), 
            __cint_struct_members__shr_bfcmap_port_config_t, 
            __cint_maddr__shr_bfcmap_port_config_t,
        },
        {
            "_shr_bfcmap_vlan_vsan_map_t",
            sizeof(_shr_bfcmap_vlan_vsan_map_t), 
            __cint_struct_members___shr_bfcmap_vlan_vsan_map_t, 
            __cint_maddr__shr_bfcmap_vlan_vsan_map_t,
        },
        {
            "_shr_bfcmap_port_ability_t",
            sizeof(_shr_bfcmap_port_ability_t), 
            __cint_struct_members___shr_bfcmap_port_ability_t, 
            __cint_maddr__shr_bfcmap_port_ability_t,
        },
        {
            "_shr_bfcmap_cos_to_pri_t",
            sizeof(_shr_bfcmap_cos_to_pri_t), 
            __cint_struct_members___shr_bfcmap_cos_to_pri_t, 
            __cint_maddr__shr_bfcmap_cos_to_pri_t,
        },
#endif
        {
            "_shr_rx_reasons_t",
            sizeof(_shr_rx_reasons_t), 
            __cint_struct_members__shr_rx_reasons_t, 
            __cint_maddr__shr_rx_reasons_t
        },
#if _SHR_PBMP_WIDTH != 0		/* new style */
        {
            "_shr_pbmp_t",
            sizeof(_shr_pbmp_t), 
            __cint_struct_members__shr_pbmp_t, 
            __cint_maddr__shr_pbmp_t
        },
#endif
        {
            "_shr_switch_temperature_monitor_t",
            sizeof(_shr_switch_temperature_monitor_t),
            __cint_struct_members__shr_switch_temperature_monitor_t,
            __cint_maddr__shr_switch_temperature_monitor_t
        },
#ifdef CPRIMOD_SUPPORT
        {
            "_shr_cpri_fast_eth_config_t",
            sizeof(_shr_cpri_fast_eth_config_t),
            __cint_struct_members__shr_cpri_fast_eth_config_t,
            __cint_maddr__shr_cpri_fast_eth_config_t,
        },
        {
            "_shr_cpri_tag_gen_entry_t",
            sizeof(_shr_cpri_tag_gen_entry_t),
            __cint_struct_members__shr_cpri_tag_gen_entry_t,
            __cint_maddr__shr_cpri_tag_gen_entry_t,
        },
        {
            "_shr_cpri_rx_vsd_flow_info_t",
            sizeof(_shr_cpri_rx_vsd_flow_info_t),
            __cint_struct_members__shr_cpri_rx_vsd_flow_info_t,
            __cint_maddr__shr_cpri_rx_vsd_flow_info_t,
        },
        {
            "_shr_cpri_presentation_time_t",
            sizeof(_shr_cpri_presentation_time_t),
            __cint_struct_members__shr_cpri_presentation_time_t,
            __cint_maddr__shr_cpri_presentation_time_t,
        },
        {
            "_shr_cpri_decap_presentation_config_t",
            sizeof(_shr_cpri_decap_presentation_config_t),
            __cint_struct_members__shr_cpri_decap_presentation_config_t,
            __cint_maddr__shr_cpri_decap_presentation_config_t,
        },
        {
            "_shr_cpri_tx_vsd_flow_info_t",
            sizeof(_shr_cpri_tx_vsd_flow_info_t),
            __cint_struct_members__shr_cpri_tx_vsd_flow_info_t,
            __cint_maddr__shr_cpri_tx_vsd_flow_info_t,
        },
        {
            "_shr_cpri_1588_timestamp_ts_config_t",
            sizeof(_shr_cpri_1588_timestamp_ts_config_t),
            __cint_struct_members__shr_cpri_1588_timestamp_ts_config_t,
            __cint_maddr__shr_cpri_1588_timestamp_ts_config_t,
        },
        {
            "_shr_cpri_intr_info_t",
            sizeof(_shr_cpri_intr_info_t),
            __cint_struct_members__shr_cpri_intr_info_t,
            __cint_maddr__shr_cpri_intr_info_t,
        },
        {
            "_shr_cpri_fec_timestamp_config_t",
            sizeof(_shr_cpri_fec_timestamp_config_t),
            __cint_struct_members__shr_cpri_fec_timestamp_config_t,
            __cint_maddr__shr_cpri_fec_timestamp_config_t,
        },
#endif
        {
            "_shr_port_timestamp_adjust_t",
            sizeof(_shr_port_timestamp_adjust_t),
            __cint_struct_members__shr_port_timestamp_adjust_t,
            __cint_maddr__shr_port_timestamp_adjust_t
        },
        { NULL }
    }; 


/*
 * Function pointers in <shared>
 */

static cint_function_pointer_t __cint_sdk_function_pointers[4];

static int
__cint_fpointer__shr_port_phy_reset_cb(int unit, _shr_port_t port, void* user_data)
{
    int rc = 0; 
    cint_interpreter_callback(__cint_sdk_function_pointers+0, 3, 1, &unit, &port, &user_data, &rc); 
    return rc; 
}
static cint_parameter_desc_t __cint_parameters__shr_port_phy_reset_cb[] = 
    {
        { "int", "rc", 0, 0 }, 
        { "int", "unit", 0, 0 }, 
        { "int", "port", 0, 0 }, 
        { "void", "user_data", 1, 0 }, 
        { NULL }
    }; 

static void
__cint_fpointer__shr_port_medium_status_cb(int unit, int port, _shr_port_medium_t medium, void* user_arg)
{
    cint_interpreter_callback(__cint_sdk_function_pointers+1, 4, 0, &unit, &port, &medium, &user_arg);
}
static cint_parameter_desc_t __cint_parameters__shr_port_medium_status_cb[] = 
    {
        { "void", "r", 0, 0 }, 
        { "int", "unit", 0, 0 }, 
        { "int", "port", 0, 0 }, 
        { "_shr_port_medium_t", "medium", 0, 0 }, 
        { "void", "user_arg", 1, 0 }, 
        { NULL }
    }; 

#ifdef CPRIMOD_SUPPORT
static void
__cint_fpointer__shr_cpri_port_interrupt_callback(int unit, int port, _shr_cpri_intr_info_t* data , void* user_data)
{
    cint_interpreter_callback(__cint_sdk_function_pointers+2, 4, 0, &unit, &port, &data, &user_data);
}
static cint_parameter_desc_t __cint_parameters__shr_cpri_port_interrupt_callback[] =
    {
        { "void", "r", 0, 0 },
        { "int", "unit", 0, 0 },
        { "int", "port", 0, 0 },
        { "_shr_cpri_intr_info_t", "data", 1, 0 },
        { "void", "user_data", 1, 0 },
        { NULL }
    };
#endif

static cint_function_pointer_t __cint_sdk_function_pointers[4] =
    {
        {
            "_shr_port_phy_reset_cb_t", 
            (cint_fpointer_t) __cint_fpointer__shr_port_phy_reset_cb, 
            __cint_parameters__shr_port_phy_reset_cb
        },
        {
            "_shr_port_medium_status_cb_t", 
            (cint_fpointer_t) __cint_fpointer__shr_port_medium_status_cb, 
            __cint_parameters__shr_port_medium_status_cb
        },
#ifdef CPRIMOD_SUPPORT
        {
            "_shr_cpri_port_interrupt_callback_t",
            (cint_fpointer_t) __cint_fpointer__shr_cpri_port_interrupt_callback,
             __cint_parameters__shr_cpri_port_interrupt_callback
        },
#endif
        { NULL }
    };

cint_data_t cint_sdk_data = 
    {
        NULL, 
        __cint_sdk_functions,
        __cint_sdk_structures, 
        NULL, 
        __cint_sdk_typedefs, 
        NULL, 
        __cint_sdk_function_pointers,
        __sdk_custom_iterators, 
        __sdk_custom_macros, 
    }; 

#endif /* INCLUDE_LIB_CINT */
