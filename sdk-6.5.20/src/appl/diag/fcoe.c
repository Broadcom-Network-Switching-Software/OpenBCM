/*
 * 
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */
#define FIP_VERSION_1  0 

#include <sal/appl/sal.h>
#include <sal/appl/config.h>
#include <sal/appl/io.h>
#include <sal/core/alloc.h>
#include <sal/core/thread.h>
#include <shared/bsl.h>
#include <bcm/error.h>
#include <bcm/tx.h>
#include <bcm/rx.h>
#include <bcm/link.h>
#include <bcm/vlan.h>
#include <bcm/stat.h>
#include <bcm/field.h>
#include <bcm/port.h>
#include <bcm/fcmap.h>
#include <soc/enet.h>
#include <soc/debug.h>
#include <soc/cm.h>
#include <appl/diag/shell.h>
#include <appl/diag/system.h>
#include <appl/diag/dport.h>

#include <sal/core/dpc.h>
#include <sal/core/time.h>
#include <soc/phy/phyctrl.h>

#ifdef INCLUDE_FCMAP
#ifdef BCM_WARM_BOOT_SUPPORT
extern void bfcmap_warmboot_recover(void);
#endif
extern int phy_is_8806x(phy_ctrl_t *pc);
typedef struct fip_flogi_s {
    char used;
    sal_mac_addr_t sa;
    int unit;
    int port;
    uint16 oxid;
    uint16 rxid;
}fip_flogi_t;

#define FCOE_MAX_FIP_FLOGI 256
fip_flogi_t fip_flogi_pending[FCOE_MAX_FIP_FLOGI];


bcm_mac_t  fcf_sa_mac = {0x00,0x10,0x18,0x01,0x02,0x03};
static volatile sal_thread_t fcoe_thread_id = SAL_THREAD_ERROR;

static int fcoe_fc_port; /* FC port */
STATIC void _print_fcmap_cfg(bcm_fcmap_port_config_t *cfg);
STATIC void fcoe_fip_thread(void *cookie);
int is_mt2 = 0; /* Flag to indicate MT2 present */

unsigned char lldp[] = {
0x01, 0x80, 0xC2, 0x00, 0x00, 0x0E, 0x00, 0x10, 
0x18, 0x01, 0x02, 0x03, 0x88, 0xCC, 0x02, 0x07, 
0x04, 0x00, 0x10, 0x18, 0x01, 0x02, 0x03, 0x04, 
0x07, 0x05, 0x45, 0x74, 0x68, 0x31, 0x2F, 0x39, 
0x06, 0x02, 0x00, 0x78, 0x08, 0x09, 0x4E, 0x35, 
0x4B, 0x2D, 0x50, 0x6F, 0x72, 0x74, 0x00, 0x0A, 
0x07, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x00, 
0x0C, 0x0A, 0x4E, 0x35, 0x4B, 0x2D, 0x53, 0x77, 
0x69, 0x74, 0x63, 0x68, 0x0E, 0x04, 0x00, 0x04, 
0x00, 0x04, 0x10, 0x0E, 0x07, 0x06, 0x00, 0x0D, 
0xEC, 0xCD, 0xFD, 0x00, 0x02, 0x1A, 0x00, 0x80, 
0x00, 0x00, 0xFE, 0x37, 0x00, 0x1B, 0x21, 0x02, 
0x02, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
0x00, 0x00, 0x00, 0x01, 0x06, 0x06, 0x00, 0x00, 
0x80, 0x00, 0x08, 0x08, 0x08, 0x0A, 0x00, 0x00, 
0x80, 0x00, 0x89, 0x06, 0x00, 0x1B, 0x21, 0x08, 
0x04, 0x11, 0x00, 0x00, 0x80, 0x00, 0x00, 0x01, 
0x00, 0x00, 0x32, 0x32, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x02, 0xFE, 0x05, 0x00, 0x01, 0x42, 
0x01, 0x01, 0xFE, 0x06, 0x00, 0x80, 0xC2, 0x01, 
0x00, 0x01, 0x00, 0x00, 0xBC, 0x2A, 0x44, 0x0A, 
0xFD, 0x07, 0x07, 0x07};

unsigned char FLOGI_Request[] = 
{0x00, 0x0D, 0xEC, 0xCD, 0xFD, 0x00, 0x00, 0xC0, 0xDD, 0x12, 0xAB, 0x1D, 0x81,
0x00, 0x60, 0x04, 0x89, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x22, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00,
0x00, 0x01, 0x29, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x19, 0xFF, 0xFF,
0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x0f, 0x80,
0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
0x00, 0x10, 0x18, 0x44, 0x2f, 0x55, 0x20, 0x00, 0x00, 0x10, 0x18, 0x44, 0x2f,
0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
0xFF, 0x00, 0x0C, 0x00, 0x01, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00,
0x08, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0xf0, 0xc3, 0x3c, 0x2b, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00};

unsigned char FIP_VLAN_Response[] = {
0x00, 0xc0, 0xdd, 0x12, 0xab, 0x1d, 0x00, 0x10, 
#if FIP_VERSION_1
0x18, 0x01, 0x02, 0x03, 0x89, 0x14, 0x10, 0x00, 
#else
0x18, 0x01, 0x02, 0x03, 0x89, 0x14, 0x00, 0x00, 
#endif
0x00, 0x04, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00, 
0x02, 0x02, 0x00, 0x10, 0x18, 0x01, 0x02, 0x03, 
0x0e, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x50, 0x82, 0x96, 0x32 };

#if FIP_VERSION_1
unsigned char FIP_Advertisement[] = {
0x00, 0xC0, 0xDD, 0x12, 0xAB, 0x1D, 0x00, 0x10, 0x18, 0x01, 0x02, 0x03, 0x81, 0x00, 0x60, 0x04,
0x89, 0x14, 0x10, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x0d, 0x80, 0x07, 0x01, 0x01, 0x00, 0x80,
0x02, 0x02, 0x00, 0x10, 0x18, 0x01, 0x02, 0x03, 0x04, 0x03, 0x00, 0x00, 0x20, 0x00, 0x00, 0x10,
0xEC, 0xCD, 0xFD, 0x01, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x20, 0x00, 0x00, 0x10,
0xEC, 0xCD, 0xFD, 0x01, 0x0C, 0x02, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x40, 0x06, 0x01, 0x08, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xFD, 0x07, 0x07, 0x07};
#else
unsigned char FIP_Advertisement[] = {
0x00, 0xC0, 0xDD, 0x12, 0xAB, 0x1D, 0x00, 0x10, 0x18, 0x01, 0x02, 0x03, 0x81, 0x00, 0x60, 0x04,
0x89, 0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x0C, 0x80, 0x07, 0x01, 0x01, 0x00, 0x80,
0x02, 0x02, 0x00, 0x10, 0x18, 0x01, 0x02, 0x03, 0x04, 0x03, 0x00, 0x00, 0x20, 0x00, 0x00, 0x10,
0xEC, 0xCD, 0xFD, 0x01, 0x05, 0x04, 0x00, 0x00, 0x00, 0x0E, 0xFC, 0x00, 0x20, 0x00, 0x00, 0x10,
0xEC, 0xCD, 0xFD, 0x01, 0x0C, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xFD, 0x07, 0x07, 0x07};
/* 0x6B, 0x7A, 0x56, 0xD3, 0xFD, 0x07, 0x07, 0x07}; */
#endif

unsigned char FIP_FLOGI_Response[] = {
0x00, 0x10, 0x18, 0x44, 0x2f, 0x55, 0x00, 0x0d, 
0xec, 0xca, 0x05, 0x40, 0x81, 0x00, 0x60, 0x04, 
#if FIP_VERSION_1
0x89, 0x14, 0x10, 0x00, 0x00, 0x02, 0x00, 0x02, 
#else
0x89, 0x14, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 
#endif
0x00, 0x26, 0x80, 0x00, 0x07, 0x24, 0x00, 0x00, 
0x23, 0xb8, 0x02, 0x3c, 0x00, 0xff, 0xff, 0xfe, 
0x01, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x05, 0x55, 0xd3, 0xc8, 0x00, 0x00, 0x00, 0x00, 
0x02, 0x00, 0x00, 0x00, 0x20, 0x06, 0x00, 0x00, 
0x33, 0x00, 0x08, 0x40, 0x00, 0x00, 0x27, 0x10, 
0x00, 0x00, 0x07, 0xd0, 0x20, 0x13, 0x00, 0x0d, 
0xec, 0xca, 0x05, 0x7f, 0x20, 0x01, 0x00, 0x0d, 
0xec, 0xc9, 0x03, 0x41, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
#if FIP_VERSION_1
0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0xfc, 
#else
0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x0e, 0xfc, 
#endif
0x00, 0xb8, 0x02, 0x3c, 0x2e, 0x53, 0xe3, 0xe3 };

unsigned char FDISC_Request[] = {
0x00, 0x0D, 0xEC, 0xCD, 0xFD, 0x00, 0x00, 0xC0, 
0xDD, 0x12, 0xAB, 0x1D, 0x81, 0x00, 0x60, 0x04, 
0x89, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 
0x22, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 
0x01, 0x29, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 
0x00, 0x19, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 
0x51, 0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x28, 
0x80, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x10, 
0x18, 0x44, 0x2f, 0x56, 0x20, 0x00, 0x00, 0x10, 
0x18, 0x44, 0x2f, 0x55, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x01, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x08, 0x00, 0x00, 0xFF, 0x00, 0x0C, 
0x00, 0x01, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x08, 0x00, 0x00, 0xFF, 0x00, 0x00, 
0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xa0, 0x5c, 0x1e, 0xff, 
0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

#define FIP_OPCODE_DISCOVERY 0x1
#define FIP_SUBCODE_DISCOVERY_SOLICITION   0x1
#define FIP_SUBCODE_DISCOVERY_ADVERTISMENT 0x2


#define FIP_OPCODE_FLOGI 0x2
#define FIP_SUBCODE_FLOGI_REQUEST 0x1
#define FIP_SUBCODE_FLOGI_REPLY   0x2

#define FIP_OPCODE_VLAN 0x4
#define FIP_SUBCODE_VLAN_REQUEST 0x1
#define FIP_SUBCODE_VLAN_REPLY 0x2

#if FIP_VERSION_1
#define FIP_OPCODE_KEEPALIVE 0x3
#define FIP_SUBCODE_KEEPALIVE_REQUEST 0x1
#define FIP_SUBCODE_KEEPALIVE_REPLY 0x2
#endif

#define FCOE_FIP_OPCODE(pkt) \
    ((uint16) ((BCM_PKT_VLAN_PTR(pkt)[8] << 8) | (BCM_PKT_VLAN_PTR(pkt)[9])))

#define FCOE_FIP_SUBCODE(pkt) \
    ((uint8)(BCM_PKT_VLAN_PTR(pkt)[11]))

#define FCOE_FIP_DESC_LEN(pkt) \
    ((uint16) ((BCM_PKT_VLAN_PTR(pkt)[13] << 8) | (BCM_PKT_VLAN_PTR(pkt)[12])))


#define FCOE_R_CTL(pkt) \
    ((uint8)(BCM_PKT_VLAN_PTR(pkt)[20]))

/* 
 * 1> All FCOE frames origniation from Source NPort Id, will be routed to dest fc
 * port.
 * 2> All FCOE frames from dest_fc port with src nport ID will be routed to
 * src_eth_port
 */
STATIC int
fcoe_add_nport_route(int unit, int src_eth_port, int src_nport_id, int dest_fc_port)
{
    bcm_field_qset_t qset;
    bcm_field_group_t group;
    bcm_field_entry_t entry;
    bcm_field_action_t action = bcmFieldActionRedirect;
    bcm_field_stat_t stat_entry = bcmFieldStatPackets;
    int stat_id;
    bcm_gport_t gport[2] = {0x8000007, 0x8000009}; /* xe2, xe4 */

#if FIP_VERSION_1
    bcm_mac_t mac1 = {0x00, 0xfc, 0x00, 0x00, 0x00, 0x00};
#else
    bcm_mac_t mac1 = {0x0e, 0xfc, 0x00, 0x00, 0x00, 0x00};
#endif
    bcm_mac_t mac2 = {0x00, 0x10, 0x18, 0x01, 0x02, 0x03};
    bcm_mac_t mac_mask = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    bcm_port_gport_get(unit, dest_fc_port, &gport[0]);
    bcm_port_gport_get(unit, src_eth_port, &gport[1]);

    mac1[3] = (src_nport_id & 0xff0000) >> 16; 
    mac1[4] = (src_nport_id & 0x00ff00) >> 8; 
    mac1[5] = (src_nport_id & 0x0000ff); 

    cli_out("fcoe_add_nport_route: src_eth_port = %d, src_nport_id = %x, dest_fc_port = %d\n",  src_eth_port, src_nport_id, dest_fc_port);

    BCM_FIELD_QSET_INIT(qset);
    BCM_FIELD_QSET_ADD(qset, bcmFieldQualifySrcMac);
    BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyDstMac);

    /* group create */
    bcm_field_group_create(unit, qset, 1, &group);

    /* Entry1: Redirect to xe4 */
    bcm_field_entry_create(unit, group, &entry);
    bcm_field_qualify_DstMac(0, entry, mac1, mac_mask);
    bcm_field_qualify_SrcMac(0, entry, mac2, mac_mask);
    bcm_field_action_add(unit, entry, action, -1, gport[1]); 
    bcm_field_stat_create(0, group, 1, &stat_entry, &stat_id);
    bcm_field_entry_stat_attach(0, entry, stat_id);
    cli_out("EID:%d STATID:%d\n", entry, stat_id);
    bcm_field_entry_install(unit, entry);

    /* Entry2: Redirect to xe2 */
    bcm_field_entry_create(unit, group, &entry);
    bcm_field_qualify_SrcMac(0, entry, mac1, mac_mask);
    bcm_field_qualify_DstMac(0, entry, mac2, mac_mask);
    bcm_field_action_add(unit, entry, action, -1, gport[0]);
    bcm_field_stat_create(0, group, 1, &stat_entry, &stat_id);
    bcm_field_entry_stat_attach(0, entry, stat_id);
    cli_out("EID:%d STATID:%d\n", entry, stat_id);
    bcm_field_entry_install(unit, entry);

    return BCM_E_NONE;
}

STATIC int
fcoe_tx_pkt_helper(int unit, int port, unsigned char *pkt_data, int len)
{
    bcm_pkt_t pkt;
    int rv = BCM_E_FAIL;
    pbmp_t  tx_pbmp, tx_upbmp;
    int pktSize;

    bcm_pkt_t_init(&pkt);
    pktSize = len;
  
    BCM_PBMP_PORT_SET(tx_pbmp, port);
    BCM_PBMP_PORT_SET(tx_upbmp, port);

    /* alloc packet body */    
    pkt.alloc_ptr = (uint8 *)soc_cm_salloc(unit, pktSize, "LLDP"); 
  
    if (pkt.alloc_ptr == NULL) {        
        cli_out("WARNING: Could not alloc tx buffer. Memory error.\n");    
        return rv;
    } else {        
        pkt._pkt_data.data = pkt.alloc_ptr;        
        pkt.pkt_data = &pkt._pkt_data;        
        pkt.blk_count = 1;        
        pkt._pkt_data.len = pktSize;
    }
    /* packet re-init */    
    sal_memset(pkt.pkt_data[0].data, 0, pkt.pkt_data[0].len);        
  
    /* setup the packet */    
    pkt.flags &= ~BCM_TX_CRC_FLD;    
    pkt.flags |= BCM_TX_CRC_REGEN; 
    pkt.flags |= BCM_PKT_F_NO_VTAG; 
  
    /* assign pbmp */    
    sal_memcpy((uint8 *)&pkt.tx_pbmp, (uint8 *)&tx_pbmp, sizeof(bcm_pbmp_t));    
    sal_memcpy((uint8 *)&pkt.tx_upbmp, (uint8 *)&tx_upbmp, sizeof(bcm_pbmp_t));
  
    sal_memcpy(pkt.pkt_data[0].data, pkt_data, pktSize );
    if ((rv = bcm_tx(unit, &pkt, NULL)) != BCM_E_NONE) {        
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "bcm_tx failed: Unit %d: %s\n"),
                              unit, bcm_errmsg(rv)));        
        return rv;
     }
     soc_cm_sfree(unit, pkt.alloc_ptr );
     return BCM_E_NONE; 
}

/* Send VLAN response */
STATIC int
fip_tx_vlan_response(bcm_pkt_t *info)
{
    int rv = 0;
    enet_hdr_t   *ep = NULL;    
    ep = (enet_hdr_t *)(info->pkt_data[0].data);
    ENET_SET_MACADDR(FIP_VLAN_Response, ep->en_shost);
    if ((rv = fcoe_tx_pkt_helper(info->unit, info->src_port, 
                           FIP_VLAN_Response, sizeof(FIP_VLAN_Response))) !=
                           BCM_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(info->unit,
                              "bcm_tx failed: Unit %d: %s\n"),
                              info->unit, bcm_errmsg(rv)));
        return BCM_E_FAIL;
    }
    return BCM_E_NONE; 
}


STATIC int
fip_tx_advertisement(bcm_pkt_t *info)
{
    int rv = 0;
    enet_hdr_t   *ep = NULL;    
    ep = (enet_hdr_t *)(info->pkt_data[0].data);
    ENET_SET_MACADDR(FIP_Advertisement, ep->en_shost);
    FIP_Advertisement[27] = 0x07; /* response to solicit */
    if ((rv = fcoe_tx_pkt_helper(info->unit, info->src_port, 
                           FIP_Advertisement, sizeof(FIP_Advertisement))) !=
                           BCM_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(info->unit,
                              "bcm_tx failed: Unit %d: %s\n"),
                              info->unit, bcm_errmsg(rv)));
        return BCM_E_FAIL;
    }
    return BCM_E_NONE; 
}



STATIC int 
fcoe_get_unused_fip_flogi_entry(int *entry)
{
    int i;
    for (i = 0; i < FCOE_MAX_FIP_FLOGI; i++) {
        if (fip_flogi_pending[i].used == 0) {
            break;
        }
    }
    if (i < FCOE_MAX_FIP_FLOGI) {
        *entry = i;
        return BCM_E_NONE;
    }
    return BCM_E_FAIL;
}


STATIC int 
fcoe_get_fip_flogi_entry(uint16 oxid, int *entry)
{
    int i;
    for (i = 0; i < FCOE_MAX_FIP_FLOGI; i++) {
        if ((fip_flogi_pending[i].used == 1) &&
            (oxid == fip_flogi_pending[i].oxid)) {
            break;
        }
    }
    if (i < FCOE_MAX_FIP_FLOGI) {
        *entry = i;
        return BCM_E_NONE;
    }
    return BCM_E_FAIL;
}



STATIC int
fip_handle_flogi(bcm_pkt_t *info)
{
    enet_hdr_t   *ep = NULL;    
    int rv = 0;
    int entry;

    unsigned char *fdisc_req;

    fdisc_req = sal_alloc(sizeof(FDISC_Request), "Fdisc copy");
    if (fdisc_req == NULL) {
        cli_out("unable to allocate memory for FDISC\n");
        return BCM_E_FAIL;
    }

    /* Update pending FIP FLOGI */
    /* Store SMAC, port on which FIP was received */
    if (fcoe_get_unused_fip_flogi_entry(&entry) != BCM_E_NONE) {
        cli_out("fip_handle_flogi: Failed to get unused entry \n");
        return BCM_E_FAIL;
    }
    
    ep = (enet_hdr_t *)(info->pkt_data[0].data);    

    /* Make a copy of FDISC */
    sal_memcpy(fdisc_req, FDISC_Request, sizeof(FDISC_Request)); 

    /* Copy the FIP FLOGI to the FDISC Request before sending */
    sal_memcpy(fdisc_req + 32, info->pkt_data[0].data + 32,   /* Where FCframe starts */
                                   info->tot_len - 32 - 16);
    FDISC_Request[56] = 0x51; /* FDISC request */
    fdisc_req[56] = 0x51;

    ENET_SET_MACADDR(fip_flogi_pending[entry].sa, ep->en_shost);
    fip_flogi_pending[entry].unit = info->unit;
    fip_flogi_pending[entry].port = info->src_port;
    fip_flogi_pending[entry].oxid = *(uint16 *)(fdisc_req + 48); /* mark entry as used */
    fip_flogi_pending[entry].used = 1; /* mark entry as used */

    cli_out("FIP FLOGI packet: time=0x%x, OXID=0x%4x, CNA port=%d\n", 
            sal_time_usecs(), fip_flogi_pending[entry].oxid, fip_flogi_pending[entry].port);
    cli_out("SRCMAC: 0x%04x%04x%04x \n",
            *(uint16 *)(fip_flogi_pending[entry].sa + 0),
            *(uint16 *)(fip_flogi_pending[entry].sa + 2),
            *(uint16 *)(fip_flogi_pending[entry].sa + 4));


    
    /* send FDISC to FC port */
    if ((rv = fcoe_tx_pkt_helper(info->unit, fcoe_fc_port, 
                           fdisc_req, sizeof(FDISC_Request))) !=
                           BCM_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(info->unit,
                              "bcm_tx failed: Unit %d: %s\n"),
                              info->unit, bcm_errmsg(rv)));
        sal_free(fdisc_req);
        return BCM_E_FAIL;
    }
    
    sal_free(fdisc_req);
    return BCM_E_NONE; 
}


/* Handle FIP packet */
STATIC int
fcoe_handle_fip_packet(bcm_pkt_t *info)
{
    uint16 opcode;
    opcode = FCOE_FIP_OPCODE(info);
    /* received a VLAN discovery */
    if (opcode == FIP_OPCODE_VLAN) {
        if (FCOE_FIP_SUBCODE(info) != FIP_SUBCODE_VLAN_REQUEST) {
            cli_out("Invalid FIP-VLAN Packet received \n");
        } else {
            fip_tx_vlan_response(info);
        }
    }

    /* received a Solicitation */
    if (opcode == FIP_OPCODE_DISCOVERY) {
        if (FCOE_FIP_SUBCODE(info) != FIP_SUBCODE_DISCOVERY_SOLICITION) {
            cli_out("Invalid FIP-Discovery Packet received \n");
        } else {
            fip_tx_advertisement(info);
        }
    }

    /* Received a FLOGI frame */
    if (opcode == FIP_OPCODE_FLOGI) {
        fip_handle_flogi(info);
    }

    return BCM_E_NONE;
}

#define FCOE_CMD_CODE(pkt) \
    ((uint8)(BCM_PKT_VLAN_PTR(pkt)[44]))

#define FCOE_FC_BB_CREDIT(pkt) \
    ((uint16) ((BCM_PKT_VLAN_PTR(pkt)[51] << 8) | (BCM_PKT_VLAN_PTR(pkt)[50])))

/* char fcf_nport_id[3];  NPV nport ID to use */
uint16 bb_credit;      /* FC credit of remote link */
int fc_nport_init = 0; /* NPV port is not initailized */

STATIC int
fip_tx_els_reply(int unit, bcm_pkt_t *info)
{
    bcm_pkt_t pkt;
    enet_hdr_t   *ep = NULL;    
    int rv = 0;
    int pktSize;
    int entry;
    uint16 oxid;
    int nport_id; 

    bcm_pkt_t_init(&pkt);
    pktSize = sizeof(FIP_FLOGI_Response); /* Size of the above packet */
  
    /* alloc packet body */    
    pkt.alloc_ptr = (uint8 *)soc_cm_salloc(info->unit, pktSize, "FIP_FLOGI_Response"); 
  
    if (pkt.alloc_ptr == NULL) {        
        cli_out("WARNING: Could not alloc tx buffer. Memory error.\n");    
    } else {        
        pkt._pkt_data.data = pkt.alloc_ptr;        
        pkt.pkt_data = &pkt._pkt_data;        
        pkt.blk_count = 1;        
        pkt._pkt_data.len = pktSize;
    }
    /* packet re-init */    
    sal_memset(pkt.pkt_data[0].data, 0, pkt.pkt_data[0].len);        
    ep = (enet_hdr_t *)(pkt.pkt_data[0].data);    
  
    /* setup the packet */    
    pkt.flags &= ~BCM_TX_CRC_FLD;    
    pkt.flags |= BCM_TX_CRC_REGEN; 
    pkt.flags |= BCM_PKT_F_NO_VTAG; 

    oxid = *(uint16 *)(info->pkt_data[0].data + 48); /* mark entry as used */
    if (fcoe_get_fip_flogi_entry(oxid, &entry) != BCM_E_NONE) {
        cli_out("Unknown OXID = %x\n", oxid);
        return BCM_E_FAIL;
    }
    cli_out("ELS reply packet: time=0x%x, OXID=0x%4x, CNA port=%d\n", sal_time_usecs(), oxid, fip_flogi_pending[entry].port);
    cli_out("DSTMAC: 0x%04x%04x%04x \n",
            *(uint16 *)(fip_flogi_pending[entry].sa + 0),
            *(uint16 *)(fip_flogi_pending[entry].sa + 2),
            *(uint16 *)(fip_flogi_pending[entry].sa + 4));

    /* assign pbmp */    
    BCM_PBMP_PORT_SET(pkt.tx_pbmp, fip_flogi_pending[entry].port);
    BCM_PBMP_PORT_SET(pkt.tx_upbmp, fip_flogi_pending[entry].port);

    sal_memcpy(pkt.pkt_data[0].data, FIP_FLOGI_Response, pktSize);

    /* assign mac addr */    
    ENET_SET_MACADDR(ep->en_dhost, fip_flogi_pending[entry].sa);    
    ENET_SET_MACADDR(ep->en_shost, fcf_sa_mac);    
    /* Overwrite the response */
    /* Copy only FC frame; FIP header = 16bytes. 
     * FCoE Header = 16 Bytes, + Eth Header + VLAN = 16 bytes.
     */
    sal_memcpy(pkt.pkt_data[0].data + 32, BCM_PKT_VLAN_PTR(info) + 20, info->tot_len - 32 - 12);

    /* Construct FPMA */
    sal_memcpy(pkt.pkt_data[0].data + info->tot_len - 7, pkt.pkt_data[0].data + 33, 3);

    if ((rv = bcm_tx(info->unit, &pkt, NULL)) != BCM_E_NONE) {        
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "bcm_tx failed: Unit %d: %s\n"),
                              info->unit, bcm_errmsg(rv)));
        return rv;
    }

    /* Add route in FP */
    nport_id = 0;
    sal_memcpy(((char *)&nport_id)+1, pkt.pkt_data[0].data + 33, 3);
    fcoe_add_nport_route(unit, fip_flogi_pending[entry].port,
                               nport_id, 
                               info->src_port);

    fip_flogi_pending[entry].used = 0;
    soc_cm_sfree(info->unit, pkt.alloc_ptr);
    return BCM_E_NONE; 
}

STATIC int
fcoe_handle_flogi_response(int unit, bcm_pkt_t *info)
{
    uint16 oxid; 
    bcm_mac_t  fcf_sa_mac = {0x00,0x10,0x18,0x01,0x02,0x03};
    int entry;
    int bbc;
    bcm_fcmap_port_config_t cfg;

    /* Get OXID */
    oxid = *(uint16 *)((info->pkt_data[0].data) + 48);    
    if (fcoe_get_fip_flogi_entry(oxid, &entry) != BCM_E_NONE) {
        cli_out("Unknown OXID = %x\n", oxid);
        return BCM_E_FAIL;
    }
    if (ENET_CMP_MACADDR(fip_flogi_pending[entry].sa, fcf_sa_mac) == 0) {
        /* Flogi reply from FC switch to my originated FLOGI */
        /* store the nport ID to use */
        /* BB Credit of the link partner */
        if (FCOE_CMD_CODE(info) == 0x02) { /* Accept */
            /* sal_memcpy(fcf_nport_id, BCM_PKT_VLAN_PTR(info) + 21, 3); */
            bb_credit = FCOE_FC_BB_CREDIT(info);
        } else {  /* Reject */
        }
        cli_out("ACC for FLOGI \n");
        fip_flogi_pending[entry].used = 0;

        /* Retrive BB Credits and program to into the device */
        bbc = *((info->pkt_data[0].data) + 63);    
        cli_out("BBC = %x\n", bbc);

        /* Get FC port Configuration details */
        memset(&cfg, 0, sizeof(cfg));
        if (bcm_fcmap_port_config_get(unit, info->src_port, &cfg) != BCM_E_NONE) {
            cli_out("Port Configuration retrive failed\n");
            return BCM_E_FAIL;
        }

        if (is_mt2) {
            /* FIP Server running on MT2 */
            /* Clear action mask and set only required parameters */
            cfg.action_mask &= ~BCM_FCMAP_ATTR_ALL_MASK;

            cfg.action_mask |= BCM_FCMAP_ATTR_TX_BB_CREDITS_MASK;
        } else {
            cfg.action_mask |= BCM_FCMAP_ATTR_ALL_MASK;
            cfg.action_mask2 |= BCM_FCMAP_ATTR2_ALL_MASK;
        }

        cfg.tx_buffer_to_buffer_credits = bbc;
        if (bcm_fcmap_port_config_selective_set(unit, info->src_port, &cfg) != BCM_E_NONE) {
            cli_out("Port Configuration Set failed\n");
            return BCM_E_FAIL;
        }

        /* FC port Configurations */
        _print_fcmap_cfg(&cfg);

    } else {
        /* 
         * The FLOGI response is for a CNA initiated FLOGI.
         * Package the FLOGI response and send back to CNA
         */
        /* Extract only FC frame from the response */
        /* DA + SA + VLAN + FCOEHdr = 32 */
        /* FC crc + FCoE trailer + FCS  = 12 */
        /* sal_memcpy(pdata, BCM_PKT_VLAN_PTR(info) + 20, info->tot_len - 32 - * 12); */

        if (fip_tx_els_reply(unit, info) != BCM_E_NONE) {
            return BCM_E_FAIL;
        }

        /* Initialize PFC on all ports */
        if (bcm_port_control_set(0, fip_flogi_pending[0].port, 
                                 bcmPortControlPFCReceive, 1) != BCM_E_NONE)
        {  
            cli_out("Enabling PFC Receive failed...\n");
            return BCM_E_FAIL;
        }
        if (bcm_port_control_set(0, fip_flogi_pending[0].port, 
                                 bcmPortControlPFCTransmit, 1) != BCM_E_NONE)
        {  
            cli_out("Enabling PFC Transmit failed...\n");
            return BCM_E_FAIL;
        }
    }
    return BCM_E_NONE;
}


STATIC int
fcoe_handle_fcoe_packet(int unit, bcm_pkt_t *info)
{
    /* we should only receive Accept/Reject in FCoE all other are invlaid */
    if (FCOE_R_CTL(info) == 0x23) {  /* ELS reply */
        /* If DMAC is my DA then save the Nport ID */
        fcoe_handle_flogi_response(unit, info);
    } else {
        cli_out("Error: fcoe_handle_fcoe_packet: Received FCoE Packet which is not ELS reply...\n");
        return BCM_E_FAIL;
    }
    return BCM_E_NONE;
}

/* Transmit LLDP to CNA */
STATIC int 
fcoe_transmit_LLDP(bcm_pkt_t *info)
{
    int rv = 0;
    if ((rv = fcoe_tx_pkt_helper(info->unit, info->src_port, lldp, sizeof(lldp))) !=
                           BCM_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(info->unit,
                              "bcm_tx failed: Unit %d: %s\n"),
                              info->unit, bcm_errmsg(rv)));
        return BCM_E_FAIL;
    }
    return BCM_E_NONE; 
}

STATIC int
fcoe_handle_lldp_packet(bcm_pkt_t *info)
{
    /* Transmit LLDP to CNA */
    if (fcoe_transmit_LLDP(info) != BCM_E_NONE) {
        cli_out("LLDP to CNA failed \n");
        return BCM_E_FAIL;
    }
    return BCM_E_NONE;
}

bcm_rx_t
fcoe_rx_callback(int unit, bcm_pkt_t *info, void *cookie)
/*
 * Function:    fcoe_rx_callback
 * Purpose:     This is the callback handler for the packets forwarded to
 *              the CMIC.
 * Parameters:
 *              unit - device code.
 *              info - received packet description structure.
 *              cookie - lw - pointer to lb work.
 * Returns:     0 - success, -1 failed.
 * Notes:
 *       Called in INTERRUPT CONTEXT
 */
{
    uint8 *pkt_data;
    uint16 eth_type = 0;

    pkt_data = BCM_PKT_DMAC(info); /* Pointer to Destination MAC */

    if (BCM_PKT_TAG_PROTOCOL(info) != 0x8100) { 
        cli_out("Untagged packet ...\n");
        /* untagged packet */
        if (BCM_PKT_TAG_PROTOCOL(info) == 0x8906) { /* FCoE Packet */
            cli_out("fcoe packet \n");
            fcoe_handle_fcoe_packet(unit, info);
        }
        if (BCM_PKT_TAG_PROTOCOL(info) == 0x8914) { /* FIP Packet */
            cli_out("FIP packet \n");
            fcoe_handle_fip_packet(info);
        }
        if (BCM_PKT_TAG_PROTOCOL(info) == 0x88cc) { /* LLDP Packet */
            cli_out("lldp packet \n");
            fcoe_handle_lldp_packet(info);
        }
    } else {
        eth_type = *(uint16 *)(pkt_data + 16);
        if (eth_type == 0x8906) { /* FCoE Packet */
            fcoe_handle_fcoe_packet(unit, info);
        }
        if (eth_type == 0x8914) { /* FIP Packet */
            fcoe_handle_fip_packet(info);
        }
        if (eth_type == 0x88cc) { /* LLDP Packet */
            fcoe_handle_lldp_packet(info);
        }

    }
    return BCM_RX_HANDLED;
}

/* RX Init */
STATIC int 
fcoe_rx_init(int unit)
{
    int rv = BCM_E_NONE;
    bcm_rx_cfg_t rx_cfg;

    if (BCM_RX_INIT_DONE(unit)) {
        cli_out("fcoe_rx_init:  RX already running (u=%d)\n", unit);
        return BCM_E_INIT;
    }

    /* Get current configuration */
    bcm_rx_cfg_init(unit);   /* Re-init in case in bad state */
    bcm_rx_cfg_get(unit, &rx_cfg);
    rx_cfg.global_pps = BCM_RX_RATE_NOLIMIT;
    rx_cfg.chan_cfg[BCM_RX_CHAN_DFLT].rate_pps = BCM_RX_RATE_NOLIMIT;
    rv = bcm_rx_start(unit, &rx_cfg);

    if (BCM_E_NONE != rv) {
        cli_out("fcoe_rx_init:" "rx_start failed: %s\n", bcm_errmsg(rv));
        return rv;
    }

    rv = bcm_rx_register(unit, "FCOE NPV Diag", fcoe_rx_callback,
                         BCM_RX_PRIO_MAX, (void *)&unit,
                         BCM_RCO_F_ALL_COS);
    if (BCM_E_NONE != rv) {
        cli_out("fcoe_rx_init:"
                "rx_register failed: %s\n", bcm_errmsg(rv));
        return rv;
    }
    return BCM_E_NONE;
}


static void
fcoe_flogi_timer(void *p_owner, void *p2, void *p3, void *p4, void *p5)
{
    fip_flogi_t *p_fip_flogi = (fip_flogi_t *)p_owner;
    int rv = 0;

    if (p_fip_flogi->used) {
        cli_out("fcoe_flogi_timer: OXID = %x\n", p_fip_flogi->oxid);
        if ((rv = fcoe_tx_pkt_helper(p_fip_flogi->unit, p_fip_flogi->port, 
                               FLOGI_Request, sizeof(FLOGI_Request))) !=
                               BCM_E_NONE) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META("Couldn't send FLOGI Unit %d: %s\n"),                   
                       p_fip_flogi->unit, bcm_errmsg(rv)));
            return;
        }
        
        sal_dpc_time(SECOND_USEC, fcoe_flogi_timer, p_owner, 0, 0, 0, 0);
    }
}

/* Transmit FLOGI to the FC switch */
STATIC int 
fcoe_transmit_FLOGI(int unit, int port)
{
    int rv = 0;
    int entry;

    if (fcoe_get_unused_fip_flogi_entry(&entry) != BCM_E_NONE) {
        cli_out("fcoe_transmit_FLOGI: Failed to get unused entry \n");
        return BCM_E_FAIL;
    }

    ENET_SET_MACADDR(fip_flogi_pending[entry].sa, fcf_sa_mac);   
    fip_flogi_pending[entry].unit = unit;
    fip_flogi_pending[entry].port = port;
    fip_flogi_pending[entry].oxid = *(uint16 *)(FLOGI_Request + 48); /* mark entry as used */
    fip_flogi_pending[entry].used = 1; /* mark entry as used */

    cli_out("OXID = %x\n", fip_flogi_pending[entry].oxid);
    if ((rv = fcoe_tx_pkt_helper(unit, port, 
                           FLOGI_Request, sizeof(FLOGI_Request))) !=
                           BCM_E_NONE) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Couldn't send FLOGI Unit %d: %s\n"),
                              unit, bcm_errmsg(rv)));
        return rv;
    }

    sal_dpc_time(SECOND_USEC, fcoe_flogi_timer, &fip_flogi_pending[entry], 0, 0, 0, 0);
    return BCM_E_NONE; 
}




STATIC int 
fcoe_add_donot_learn_fcoe(int unit, int port)
{
    bcm_field_qset_t qset;
    bcm_field_group_t group;
    bcm_field_entry_t entry;
    bcm_field_stat_t stat_entry = bcmFieldStatPackets;
    int stat_id;

    /* qset */
    BCM_FIELD_QSET_INIT(qset);
    BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyStageLookup);
    BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyEtherType);

    /* group create */
    BCM_IF_ERROR_RETURN(
        bcm_field_group_create(unit, qset, BCM_FIELD_GROUP_PRIO_ANY, &group));

    /* EtherType == 0x8914 */
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_create(unit, group, &entry));
    BCM_IF_ERROR_RETURN(
        bcm_field_qualify_EtherType(0, entry, 0x8914, 0xffff));
    BCM_IF_ERROR_RETURN(
        bcm_field_action_add(unit, entry, bcmFieldActionDoNotLearn, 0,0)); 
    BCM_IF_ERROR_RETURN(
        bcm_field_action_add(unit, entry, bcmFieldActionCopyToCpu, 0,0)); 
    BCM_IF_ERROR_RETURN(
        bcm_field_stat_create(0, group, 1, &stat_entry, &stat_id));
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_stat_attach(0, entry, stat_id));
    cli_out("EID:%d STATID:%d\n", entry, stat_id);
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_install(unit, entry));

    /* EtherType == 0x8906 */
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_create(unit, group, &entry));
    BCM_IF_ERROR_RETURN(
        bcm_field_qualify_EtherType(0, entry, 0x8906, 0xffff));
    BCM_IF_ERROR_RETURN(
        bcm_field_action_add(unit, entry, bcmFieldActionDoNotLearn, 0,0)); 
    BCM_IF_ERROR_RETURN(
        bcm_field_stat_create(0, group, 1, &stat_entry, &stat_id));
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_stat_attach(0, entry, stat_id));
    cli_out("EID:%d STATID:%d\n", entry, stat_id);

    BCM_IF_ERROR_RETURN(
        bcm_field_entry_install(unit, entry));
    return BCM_E_NONE;
}

STATIC int
fcoe_fabric_trans(int unit, int port)
{
    int qual_id;
    bcm_field_qset_t qset;                                                                                               
    bcm_field_group_t group;                                                                                             
    bcm_field_entry_t entry;                                                                                             
    bcm_field_action_t action;                                                                                           
    bcm_field_data_qualifier_t data_qualifier;                                                                           
    bcm_field_data_packet_format_t packet_format;                                                                        
    uint8 data[3] = {0xff, 0xff, 0xfe};
    uint8 mask[3] = {0xff, 0xff, 0xff};                                                                                  
    int length = sizeof(data);                                                                                           
    bcm_field_stat_t stat_entry = bcmFieldStatPackets;
    int stat_id;

    action = bcmFieldActionCopyToCpu;
    BCM_FIELD_QSET_INIT(qset);                                                                                           

    bcm_field_data_qualifier_t_init(&data_qualifier);

    data_qualifier.offset_base = bcmFieldDataOffsetBaseFcoeHeader;
    data_qualifier.offset = 19;
    data_qualifier.length = 3;                                                                                           

    BCM_IF_ERROR_RETURN(
        bcm_field_data_qualifier_create(unit, &data_qualifier));                                                        
    qual_id = data_qualifier.qual_id;                                                                                    

   
    bcm_field_data_packet_format_t_init(&packet_format);                                                                 

    packet_format.relative_offset = 0;                                                                                   
    packet_format.l2 = BCM_FIELD_DATA_FORMAT_L2_ETH_II;                                                                  
    packet_format.vlan_tag = BCM_FIELD_DATA_FORMAT_VLAN_SINGLE_TAGGED;
    packet_format.tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_NONE;
    packet_format.fibre_chan_outer = BCM_FIELD_DATA_FORMAT_FIBRE_CHAN;

    BCM_IF_ERROR_RETURN(
        bcm_field_data_qualifier_packet_format_add(unit, qual_id, &packet_format));                                     

    BCM_IF_ERROR_RETURN(
        bcm_field_qset_data_qualifier_add(unit, &qset, qual_id));                                                        
    BCM_IF_ERROR_RETURN(
        bcm_field_group_create(unit, qset, 1, &group));                                                                 
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_create(unit, group, &entry));                                                                   
    BCM_IF_ERROR_RETURN(
        bcm_field_qualify_data(unit, entry, qual_id, data, mask, length));                                            
    BCM_IF_ERROR_RETURN(
        bcm_field_action_add(unit, entry, action, 0, 0));                                                             

    action = bcmFieldActionDrop;
    BCM_IF_ERROR_RETURN(
        bcm_field_action_add(unit, entry, action, 0, 0));                                                             
    BCM_IF_ERROR_RETURN(
        bcm_field_stat_create(0, group, 1, &stat_entry, &stat_id));
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_stat_attach(0, entry, stat_id));
    cli_out("EID:%d STATID:%d\n", entry, stat_id);
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_install(unit, entry));                                                                          

    return BCM_E_NONE;
}



#define PRINT_MAC(addr) \
do {  \
   int i; \
   for (i = 0; i < 6; i++) { \
       cli_out("%x ", addr[i]); \
   } \
   cli_out("\n"); \
}while(0)

STATIC void 
_print_fcmap_cfg(bcm_fcmap_port_config_t *cfg) 
{
    if (cfg != NULL) {
        cli_out("Port configuration\n");
        cli_out("------------------\n");
        cli_out("Port Mode => %d\n", cfg->port_mode);
        cli_out("Port Speed => %d\n", cfg->speed);
        cli_out("TX BBC     => %d\n", cfg->tx_buffer_to_buffer_credits);
        cli_out("RX BBC     => %d\n", cfg->rx_buffer_to_buffer_credits);
        cli_out("R_T_TOV    => %d\n", cfg->r_t_tov);
        cli_out("SRC MAC    => "); PRINT_MAC(cfg->src_mac_addr);
        cli_out("DST MAC    => "); PRINT_MAC(cfg->dst_mac_addr);
        cli_out("VLAN Tag   => %x\n", cfg->vlan_tag);
        cli_out("SRC FPMA Prefix => %x\n", cfg->src_fcmap_prefix);
        cli_out("DST FPMA Prefix => %x\n", cfg->dst_fcmap_prefix);

        cli_out("Mapper Length => %d\n", cfg->mapper_len);

        cli_out("Ingress Mapper Bypass => %d\n", cfg->ingress_mapper_bypass);
        cli_out("Ingress FC Mapper Table Input => %d\n", cfg->ingress_map_table_input);
        cli_out("Ingress FC CRC Mode => %d\n", cfg->ingress_fc_crc_mode);
        cli_out("Ingress VFT Hdr Processing mode => %d\n", cfg->ingress_vfthdr_proc_mode);
        cli_out("Ingress VLAN TAG Processing mode => %d\n", cfg->ingress_vlantag_proc_mode);

        cli_out("Egress Mapper Bypass => %d\n", cfg->egress_mapper_bypass);
        cli_out("Egress FC Mapper Table Input => %d\n", cfg->egress_map_table_input);
        cli_out("Egress FC CRC Mode => %d\n", cfg->egress_fc_crc_mode);
        cli_out("Egress VFT Hdr Processing mode => %d\n", cfg->egress_vfthdr_proc_mode);
        cli_out("Egress VLAN TAG Processing mode => %d\n", cfg->egress_vlantag_proc_mode);

        cli_out("SRC MAC Construct Mode => %d\n", cfg->src_mac_construct);
        cli_out("DST MAC Construct Mode => %d\n", cfg->dst_mac_construct);
    }
}

STATIC void
fcoe_fip_thread(void *cookie)
{
    int i, rv;
    bcm_mac_t  fcf_all = {0x01,0x10,0x18,0x01,0x00,0x01}; 
    cli_out("Thread started to send advertisements \n");
    /* Send FIP Discovery Advertisement to all VN_ports */
    while (1) {
        sal_sleep(5);
        /* Loop through all the VN ports */
        for (i = 0; i < FCOE_MAX_FIP_FLOGI; i++) {
            if (fip_flogi_pending[i].used == 0) {
                continue;
            }
            
            if (ENET_CMP_MACADDR(fip_flogi_pending[i].sa, fcf_sa_mac) == 0) {
                continue;
            }
                 
            ENET_SET_MACADDR(FIP_Advertisement, fcf_all);
            FIP_Advertisement[27] = 0x05; /* Plain Advertisement */
            /* cli_out("sending advertisements to port %d\n", fip_flogi_pending[i].port); */
            if ((rv = fcoe_tx_pkt_helper(0, fip_flogi_pending[i].port, 
                                   FIP_Advertisement, sizeof(FIP_Advertisement))) !=
                                   BCM_E_NONE) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META("Periodic DISC bcm_tx failed: port %d: %s\n"),
                           fip_flogi_pending[i].port, bcm_errmsg(rv)));
            }
        }
    }
}


int fcoe_start(int unit, int fc_port)
{
    bcm_fcmap_port_config_t cfg;
    phy_ctrl_t *pc = NULL;

    fcoe_fc_port = fc_port;

    pc = EXT_PHY_SW_STATE(unit, fc_port);
    if (pc == NULL) {
        return BCM_E_FAIL;
    }

    if (phy_is_8806x(pc) == SOC_E_NONE) {
        is_mt2 = 1;
    }

    /* Start thread to send advertisements */
    fcoe_thread_id = sal_thread_create("bcmFCOE", SAL_THREAD_STKSZ,
				     100,
				     fcoe_fip_thread, NULL);
    if (fcoe_thread_id == SAL_THREAD_ERROR) {
        cli_out("Thread create failed \n");
        return BCM_E_RESOURCE;
    }
    /* Don't learn L2 address for FIP and FCoE frames */
    /* Initialize switch to route FIP frames to CPU */
    cli_out("Adding Do Not Learn L2 for FIP and FCoE Frames\n");
    if (fcoe_add_donot_learn_fcoe(unit, fc_port) != BCM_E_NONE) {
        cli_out("Failed to add donot learn rules\n");
        return BCM_E_FAIL;
    }

    /*  All FCoE transactions from 0xFFFFFE go to cpu */
    cli_out("Transactions to Fabric Controller handled by CPU\n");
    if (fcoe_fabric_trans(unit, fc_port) != BCM_E_NONE) {
        cli_out("Failed to add fabric transactions rules....\n");
        return BCM_E_FAIL;
    }

    /* Create VLAN on which FCOE/FIP traffic for a given FC port */
    /* Get FC port Configuration details */
    memset(&cfg, 0, sizeof(cfg));
    if (bcm_fcmap_port_config_get(unit, fc_port, &cfg) != BCM_E_NONE) {
        cli_out("Port Configuration retrive failed\n");
        return BCM_E_FAIL;
    }

    /* FC port Configurations */
    _print_fcmap_cfg(&cfg);

    if (is_mt2) {
        /* FIP Server running on MT2 */
        /* Clear action mask and set only required parameters */
        cfg.action_mask &= ~BCM_FCMAP_ATTR_ALL_MASK;
        cfg.action_mask |= BCM_FCMAP_ATTR_EGRESS_FC_CRC_MODE_MASK |
                           BCM_FCMAP_ATTR_VLAN_TAG_MASK |
                           BCM_FCMAP_ATTR_SRC_MAC_CONSTRUCT_MASK |
                           BCM_FCMAP_ATTR_DST_MAC_CONSTRUCT_MASK ;
    } else {
        /* FIP Server running on MT1 */
        cfg.action_mask = BCM_FCMAP_ATTR_ALL_MASK;
        cfg.action_mask2 |= BCM_FCMAP_ATTR2_ALL_MASK;
        
        cfg.port_mode = BCM_FCMAP_FCOE_TO_FC_MODE;
        cfg.ingress_fc_crc_mode = 1;
    }

    cfg.egress_fc_crc_mode = 1;
    cfg.vlan_tag = 0x81006004;
#if FIP_VERSION_1
    cfg.src_fcmap_prefix = 0x00fc00;
    cfg.dst_fcmap_prefix = 0x00fc00;
#else
    cfg.src_fcmap_prefix = 0x0efc00;
    cfg.dst_fcmap_prefix = 0x0efc00;
#endif	
   
    ENET_SET_MACADDR(cfg.src_mac_addr, fcf_sa_mac);
    cfg.src_mac_construct = BCM_FCMAP_ENCAP_FCOE_ETH_ADDRESS_USER;
    cfg.dst_mac_construct = BCM_FCMAP_ENCAP_FCOE_FPMA;
    if (bcm_fcmap_port_config_selective_set(unit, fc_port, &cfg) != BCM_E_NONE) {
        cli_out("Port Configuration Set failed\n");
        return BCM_E_FAIL;
    }
    
    /* Initialize RX (FIP and FCoE packets rx)*/
    cli_out("fcoe: Initializing RX ...");
    if (fcoe_rx_init(unit) != BCM_E_NONE) {
        /* goto clean_up; */
        cli_out("fcoe: Failed \n");
    } else {
        cli_out("Done\n");
    }

    cli_out("fcoe: FLogi to FC Switch ...");
    /* Transmit FLOGI to FC switch */
    if (fcoe_transmit_FLOGI(unit, fc_port) != BCM_E_NONE) {
        cli_out("FLOGI to Switch failed \n");
        return BCM_E_FAIL;
    }
    cli_out("Done\n");

    return BCM_E_NONE;
}

int fcoe_pcs(int unit, int fc_port)
{
    int rv;
    bcm_fcmap_port_config_t cfg;

    memset(&cfg, 0, sizeof(cfg));
    if ((rv = bcm_fcmap_port_config_get(unit, fc_port, &cfg)) != BCM_E_NONE) {
        cli_out("Port Configuration retrive before apply failed\n");
        return rv;
    }

    /* Update config structure */
    cfg.speed = BCM_FCMAP_PORT_SPEED_AN_2GBPS;

    if ((rv = bcm_fcmap_port_config_set(unit, fc_port, &cfg)) != BCM_E_NONE) {
        cli_out("Port Configuration apply failed\n");
        return rv;
    }

    memset(&cfg, 0, sizeof(cfg));
    if ((rv = bcm_fcmap_port_config_get(unit, fc_port, &cfg)) != BCM_E_NONE) {
        cli_out("Port Configuration retrive after apply failed\n");
        return rv;
    }

    /* FC port Configurations */
    _print_fcmap_cfg(&cfg);


    return BCM_E_NONE;
}

int fcoe_pcg(int unit, int fc_port)
{
    int rv;
    bcm_fcmap_port_config_t cfg;


    /* Get FC port Configuration details */
    memset(&cfg, 0, sizeof(cfg));
    if ((rv = bcm_fcmap_port_config_get(unit, fc_port, &cfg)) != BCM_E_NONE) {
        cli_out("Port Configuration retrive failed\n");
        return rv;
    }

    /* FC port Configurations */
    _print_fcmap_cfg(&cfg);


    return BCM_E_NONE;
}

int fcoe_vms(int unit, int fc_port)
{
    int rv;
    int i = 0;
    bcm_fcmap_vlan_vsan_map_t vlan[] = { { 0x101, 0x201 },
                                         { 0x102, 0x202 },
                                         { 0x103, 0x203 },
                                         { 0x104, 0x204 },
                                         { 0x105, 0x205 },
                                         { 0x106, 0x206 },
                                         { 0x107, 0x207 },
                                         { 0x108, 0x208 },
                                         { 0, 0 },
                                       };

    while(vlan[i].vlan_vid) {
        if ((rv = bcm_fcmap_vlan_map_add(unit, fc_port, &vlan[i])) != BCM_E_NONE) {
            cli_out("Vlan Map Configuration failed\n");
            return rv;
        }
        i++;
    }


    return BCM_E_NONE;
}

int fcoe_vmg(int unit, int fc_port)
{
    int rv;
    int i = 0;
    bcm_fcmap_vlan_vsan_map_t vlan = { 0xffff, 0xffff };

    while ((rv = bcm_fcmap_vlan_map_get(unit, fc_port, &vlan)) == BCM_E_NONE) {
        cli_out("Vlan Map %u : vid=0x%x vfid=0x%x \n", 
                i++,  vlan.vlan_vid, vlan.vsan_vfid);
    }

    if (rv == BFCMAP_E_UNAVAIL) {
        return rv;
    }

    return BCM_E_NONE;
}

int fcoe_vmd(int unit, int fc_port)
{
    int rv;
    int i = 0;
    bcm_fcmap_vlan_vsan_map_t vlan = { 0xffff, 0xffff };

    while ((rv = bcm_fcmap_vlan_map_get(unit, fc_port, &vlan)) == BCM_E_NONE) {
        cli_out("Deleting Vlan Map %u : vid=0x%x vfid=0x%x \n", 
                i++,  vlan.vlan_vid, vlan.vsan_vfid);

        if (bcm_fcmap_vlan_map_delete(unit, fc_port, &vlan) != BCM_E_NONE) {
            cli_out("Deleting Attempt Failed \n");
            continue;
        }
    }

    if (rv == BFCMAP_E_UNAVAIL) {
        return rv;
    }

    return BCM_E_NONE;
}

int fcoe_psc(int unit, int fc_port)
{
    int rv;

    if ((rv = bcm_fcmap_stat_clear(unit, fc_port)) != BCM_E_NONE) {
        cli_out("Stat clear failed \n");
        return rv;
    }

    return BCM_E_NONE;
}

int fcoe_psg(int unit, int fc_port)
{
    int rv;
    int i = 0;
    buint64_t  val;

    while ((rv = bcm_fcmap_stat_get(unit, fc_port, i,  &val)) == BCM_E_NONE) {
        cli_out("Stat %03u : val = 0x%08x %08x\n",
                i++, COMPILER_64_HI(val), COMPILER_64_LO(val));
    }

    if (rv == BFCMAP_E_UNAVAIL) {
        return rv;
    }

    return BCM_E_NONE;
}

int fcoe_reset(int unit, int fc_port)
{
    int rv;

    if ((rv = bcm_fcmap_port_link_reset(unit, fc_port)) != BCM_E_NONE) {
        cli_out("Port reset failed \n");
        return rv;
    }

    return BCM_E_NONE;
}

int fcoe_shutdown(int unit, int fc_port)
{
    int rv;

    if ((rv = bcm_fcmap_port_shutdown(unit, fc_port)) != BCM_E_NONE) {
        cli_out("Port shutdown failed \n");
        return rv;
    }

    return BCM_E_NONE;
}

int fcoe_link_enable(int unit, int fc_port)
{
    int rv;

    if ((rv = bcm_fcmap_port_enable(unit, fc_port)) != BCM_E_NONE) {
        cli_out("Port link enable failed \n");
        return rv;
    }

    return BCM_E_NONE;
}

/*
 * Function: 	if_fcoe
 * Purpose:	Start or stop fcoe NPV
 * Parameters:	u - SOC unit #
 *		a - pointer to args
 * Returns:	CMD_OK/CMD_FAIL/
 */
cmd_result_t
if_esw_fcoe(int u, args_t *a)
{
    int rv;
    soc_pbmp_t pbm ;
    soc_port_t p, dport;
    char *c;

    if (!sh_check_attached(ARG_CMD(a), u)) {
        return CMD_FAIL;
    }

    c = ARG_GET(a);
    if (c != NULL && sal_strcasecmp(c, "start") == 0) {
        if (((c = ARG_GET(a)) == NULL) || (parse_bcm_pbmp(u, c, &pbm) < 0)) {
            cli_out("%s: ERROR: unrecognized port bitmap: %s\n", ARG_CMD(a), c);
            return CMD_FAIL;
        }

        if ((c = ARG_CUR(a)) != NULL) {
            cli_out("Extra arguments ignored\n");
        }
        DPORT_SOC_PBMP_ITER(u, pbm, dport, p) {
           if (fcoe_start(u, p) != BCM_E_NONE) {
               cli_out("FCoE NPV start failed\n");
               return CMD_FAIL;
           } else {
               cli_out("FCoE NPV Started\n");
           }
        }
        return CMD_OK;
    }

    if (c != NULL && sal_strcasecmp(c, "stop") == 0) {
        /* fcoe_stop(unit) */
    }

#define  FCOE_PORT_FUNCION_INVOKE( _cmd, _func )\
        if (sal_strcasecmp(c, _cmd ) == 0) {                        \
            DPORT_SOC_PBMP_ITER(u, pbm, dport, p) {                 \
                if ((rv = _func(u, p)) != BCM_E_NONE) {             \
                    if (rv == BCM_E_UNAVAIL) {                      \
                        cli_out("No FCOE warmboot recovery done."    \
                           " Please run: warmboot command first\n");\
                    } else {                                        \
                        cli_out("FCoE " _cmd " failed\n");           \
                    }                                               \
                    return CMD_FAIL;                                \
                } else {                                            \
                    cli_out("FCoE " _cmd " done\n");                 \
                }                                                   \
            }                                                       \
        }

    if (c != NULL && sal_strcasecmp(c, "port") == 0) {
        if (((c = ARG_GET(a)) == NULL) || (parse_bcm_pbmp(u, c, &pbm) < 0)) {
            cli_out("%s: ERROR: unrecognized port bitmap: %s\n", ARG_CMD(a), c);
            return CMD_FAIL;
        }

        if ((c = ARG_GET(a)) == NULL) {
            cli_out("Action requested is missing\n");
            return CMD_FAIL;
        }

        FCOE_PORT_FUNCION_INVOKE( "cset" , fcoe_pcs );
        FCOE_PORT_FUNCION_INVOKE( "cget" , fcoe_pcg );
        FCOE_PORT_FUNCION_INVOKE( "vmset" , fcoe_vms );
        FCOE_PORT_FUNCION_INVOKE( "vmget" , fcoe_vmg );
        FCOE_PORT_FUNCION_INVOKE( "vmdel" , fcoe_vmd );
        FCOE_PORT_FUNCION_INVOKE( "statc" , fcoe_psc );
        FCOE_PORT_FUNCION_INVOKE( "statg" , fcoe_psg );
        FCOE_PORT_FUNCION_INVOKE( "reset" , fcoe_reset );
        FCOE_PORT_FUNCION_INVOKE( "shutdown" , fcoe_shutdown );
        FCOE_PORT_FUNCION_INVOKE( "enable" , fcoe_link_enable );

        return CMD_OK;
    }
#ifdef BCM_WARM_BOOT_SUPPORT
    if (c != NULL && sal_strcasecmp(c, "warmboot") == 0) {
        bfcmap_warmboot_recover();
        return CMD_OK;
    }
#endif
    return CMD_OK;
}

#endif /*INCLUDE_FCMAP */
