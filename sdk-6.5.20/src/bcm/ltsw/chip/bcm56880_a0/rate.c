/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/rate.h>

#include <bcm_int/ltsw/mbcm/rate.h>
#include <bcm_int/ltsw/xfs/rate.h>
#include <bcm_int/ltsw/port.h>

#include <shr/shr_debug.h>
#include <shr/shr_bitop.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_RATE

/*! Maxium number of METER_L2_IIF_STORM_CONTROL_ID. */
#define RATE_SC_METER_ID_MAX 64

/*! Default METER_L2_IIF_STORM_CONTROL_ID reserved for non storm control. */
#define RATE_SC_METER_ID_DEFAULT 0

/*! Reserved METER_L2_IIF_STORM_CONTROL_ID for all ports storm control. */
#define RATE_SC_METER_ID_ALL_PORT 1

/*! Maxium number of PORT_ID. */
#define RATE_PORT_ID_MAX 160

/******************************************************************************
 * Private functions
 */


/*! Bitmap of Fields to be operated. */
SHR_BITDCLNAME(midx_bmp, RATE_SC_METER_ID_MAX);

/*!
 * \brief Allocate a free storm control id.
 *
 * \param [in] unit Unit number.
 * \param [out] id Storm control id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56880_a0_ltsw_rate_alloc_midx(
    int unit,
    uint32_t *sc_id)
{
    int i;

    /* Skip reserved sc_id */
    for (i = RATE_SC_METER_ID_ALL_PORT + 1;
         i < RATE_SC_METER_ID_MAX; i++) {
        if (SHR_BITGET(midx_bmp, i)) continue;
        SHR_BITSET(midx_bmp, i);
        *sc_id = i;
        return SHR_E_NONE;
    }
    return SHR_E_RESOURCE;
}

/*!
 * \brief Free an allocated storm control id.
 *
 * \param [in] unit Unit number.
 * \param [in] id Storm control id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
bcm56880_a0_ltsw_rate_free_midx(
    int unit,
    uint32_t id)
{
    SHR_BITCLR(midx_bmp, id);
    return SHR_E_NONE;
}


static int
bcm56880_a0_ltsw_rate_init(int unit)
{
    uint32_t sc_id;
    bcm_port_t port, gport;
    SHR_FUNC_ENTER(unit);

    for (sc_id = 0; sc_id < RATE_SC_METER_ID_MAX; sc_id++) {
        if (sc_id == RATE_SC_METER_ID_DEFAULT ||
            sc_id == RATE_SC_METER_ID_ALL_PORT) {
            SHR_BITSET(midx_bmp, sc_id);
        } else {
            SHR_BITCLR(midx_bmp, sc_id);
        }
    }

    for (port = 0; port < RATE_PORT_ID_MAX; port++) {
        if (bcmi_ltsw_port_gport_validate(unit, port, &gport) == SHR_E_NONE) {
            /* Get storm ctrl id from HW. */
            SHR_IF_ERR_VERBOSE_EXIT
                (xfs_ltsw_rate_l2_iif_get(unit, port, &sc_id, NULL));
            SHR_BITSET(midx_bmp, sc_id);
        }
    }
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_rate_deinit(int unit)
{
    int i;
    for (i = 0; i < RATE_SC_METER_ID_MAX; i++) {
        SHR_BITCLR(midx_bmp, i);
    }
    return SHR_E_NONE;
}

static int
bcm56880_a0_ltsw_rate_clear(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_rate_clear(unit));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_rate_set(
    int unit,
    bcm_port_t port,
    bcmint_rate_info_t *rate_info)
{
    bcmint_rate_hw_info_t tmp_hw_info;
    uint32_t sc_id;

    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(rate_info, SHR_E_PARAM);

    if (rate_info->all_port) {
        /* Get storm ctrl id from HW. */
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_rate_l2_iif_get(unit, port, &sc_id, NULL));

        if (sc_id != RATE_SC_METER_ID_DEFAULT &&
            sc_id != RATE_SC_METER_ID_ALL_PORT) {
            /* Free the storm ctrl id */
            bcm56880_a0_ltsw_rate_free_midx(unit, sc_id);
        }

        /*
         * All ports use single storm control entry.
         * Since TD4 got only 64 entries, so no enough hw entries to do 1-1
         * mapping for all ports.
         */
        if ((rate_info->fmask) &
             (BCM_RATE_BCAST |
              BCM_RATE_MCAST | BCM_RATE_KNOWN_MCAST | BCM_RATE_UNKNOWN_MCAST |
              BCM_RATE_DLF)) {
            sc_id = RATE_SC_METER_ID_ALL_PORT;
        }
    } else {
        /* Get storm ctrl id from HW. */
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_rate_l2_iif_get(unit, port, &sc_id, NULL));

        if (sc_id == RATE_SC_METER_ID_DEFAULT ||
            sc_id == RATE_SC_METER_ID_ALL_PORT) {
            /* Allocate a free storm ctrl id. */
            SHR_IF_ERR_VERBOSE_EXIT
                (bcm56880_a0_ltsw_rate_alloc_midx(unit, &sc_id));
        }
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_rate_meter_set(unit, sc_id, rate_info));

    /* Get enable status of the storm ctrl id. */
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_rate_status(unit, port, sc_id, &tmp_hw_info));

    if (!tmp_hw_info.enable) {
        /* Free and reset the L2_IIF's storm ctrl id to 0. */
        bcm56880_a0_ltsw_rate_free_midx(unit, sc_id);
        sc_id = RATE_SC_METER_ID_DEFAULT;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_rate_l2_iif_set(unit, port, sc_id, rate_info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_rate_get(
    int unit,
    bcm_port_t port,
    bcmint_rate_info_t *rate_info)
{
    uint32_t sc_id;
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(rate_info, SHR_E_PARAM);

    if (rate_info->all_port) {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_rate_l2_iif_get(unit, port, NULL, rate_info));
        /*
         * All ports use single storm control entry.
         * Since TD4 got only 64 entries, so no enough hw entries to do 1-1
         * mapping for all ports.
         */
        if ((rate_info->fmask) &
             (BCM_RATE_BCAST |
              BCM_RATE_MCAST | BCM_RATE_KNOWN_MCAST | BCM_RATE_UNKNOWN_MCAST |
              BCM_RATE_DLF)) {
            sc_id = RATE_SC_METER_ID_ALL_PORT;
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT
            (xfs_ltsw_rate_l2_iif_get(unit, port, &sc_id, rate_info));
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_rate_meter_get(unit, sc_id, rate_info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_rate_dev_set(
    int unit,
    bcmint_rate_dev_info_t *dev_info)
{
    SHR_FUNC_ENTER(unit);
    SHR_NULL_CHECK(dev_info, SHR_E_PARAM);

    /* TD4 combines known L2MC and IPMC into one HW field. */
    assert(dev_info->map_idx[LT_RATE_MAP_KNOWN_L2MC] ==
           dev_info->map_idx[LT_RATE_MAP_KNOWN_IPMC]);

    /* TD4 combines unknown L2MC and IPMC into one HW field. */
    assert(dev_info->map_idx[LT_RATE_MAP_UNKNOWN_L2MC] ==
           dev_info->map_idx[LT_RATE_MAP_UNKNOWN_IPMC]);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_rate_dev_set(unit, dev_info));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_rate_dev_get(
    int unit,
    bcmint_rate_dev_info_t *dev_info)
{
    SHR_FUNC_ENTER(unit);

    SHR_NULL_CHECK(dev_info, SHR_E_PARAM);
    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_rate_dev_get(unit, dev_info));

    dev_info->meter_adjust = TRUE;
    dev_info->shaper_adjust = TRUE;

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_rate_meter_adjust_set(
    int unit,
    bcm_port_t port,
    int value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_rate_meter_adjust_set(unit, port, value));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_rate_meter_adjust_get(
    int unit,
    bcm_port_t port,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_rate_meter_adjust_get(unit, port, value));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_rate_shaper_adjust_set(
    int unit,
    bcm_port_t port,
    int value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_rate_shaper_adjust_set(unit, port, value));

exit:
    SHR_FUNC_EXIT();
}

static int
bcm56880_a0_ltsw_rate_shaper_adjust_get(
    int unit,
    bcm_port_t port,
    int *value)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (xfs_ltsw_rate_shaper_adjust_get(unit, port, value));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Rate driver function variable for bcm56880_a0 device.
 */
static mbcm_ltsw_rate_drv_t bcm56880_a0_ltsw_rate_drv = {
    .rate_init = bcm56880_a0_ltsw_rate_init,
    .rate_deinit = bcm56880_a0_ltsw_rate_deinit,
    .rate_clear = bcm56880_a0_ltsw_rate_clear,
    .rate_set = bcm56880_a0_ltsw_rate_set,
    .rate_get = bcm56880_a0_ltsw_rate_get,
    .rate_dev_set = bcm56880_a0_ltsw_rate_dev_set,
    .rate_dev_get = bcm56880_a0_ltsw_rate_dev_get,
    .rate_meter_adjust_set = bcm56880_a0_ltsw_rate_meter_adjust_set,
    .rate_meter_adjust_get = bcm56880_a0_ltsw_rate_meter_adjust_get,
    .rate_shaper_adjust_set = bcm56880_a0_ltsw_rate_shaper_adjust_set,
    .rate_shaper_adjust_get = bcm56880_a0_ltsw_rate_shaper_adjust_get
};

/******************************************************************************
 * Public functions
 */

int
bcm56880_a0_ltsw_rate_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_rate_drv_set(unit, &bcm56880_a0_ltsw_rate_drv));

exit:
    SHR_FUNC_EXIT();
}

