  /*
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * File:        field.c
 * Purpose:     Field Processor module routines specific to BCM56960
 */

#include <shared/bsl.h>
#include <soc/defs.h>
#if defined(BCM_TOMAHAWK_SUPPORT) && defined(BCM_FIELD_SUPPORT)
#include <soc/drv.h>
#include <soc/scache.h>
#include <soc/trident2.h>
#include <soc/tomahawk.h>
#include <soc/format.h>

#if defined (BCM_UTT_SUPPORT)
#include <soc/esw/utt.h>
#endif

#include <bcm/error.h>
#include <bcm/l3.h>
#include <bcm/field.h>
#include <bcm/tunnel.h>
#include <bcm/stat.h>
#include <shared/bsl.h>

#include <bcm_int/common/multicast.h>
#include <bcm_int/esw_dispatch.h>
#include <bcm_int/esw/field.h>
#include <bcm_int/esw/l3.h>
#include <bcm_int/esw/nat.h>
#include <bcm_int/esw/policer.h>
#include <bcm_int/esw/trx.h>
#include <bcm_int/esw/triumph.h>
#include <bcm_int/esw/trident.h>
#include <bcm_int/esw/trident2.h>
#include <bcm_int/esw/tomahawk.h>
#include <bcm_int/esw/tomahawk3.h>
#include <bcm_int/esw/mirror.h>
#include <bcm_int/esw/trunk.h>
#include <bcm_int/esw/xgs4.h>
#include <bcm_int/esw/range.h>
#include <bcm_int/esw/virtual.h>
#if defined(BCM_TRIDENT3_SUPPORT)
#include <bcm_int/esw/trident3.h>
#include <bcm_int/esw/udf.h>
#endif
#if defined(BCM_TOMAHAWK2_SUPPORT)
#include <soc/tomahawk2.h>
#endif
#if defined(BCM_TOMAHAWK3_SUPPORT)
#include <soc/tomahawk3.h>
#endif
#if defined(BCM_HELIX5_SUPPORT)
#include <bcm_int/esw/helix5.h>
#endif
#include <soc/esw/cancun.h>
#if defined(BCM_FIREBOLT6_SUPPORT)
#include <bcm_int/esw/firebolt6.h>
#endif

#ifndef ALIGN32
#define ALIGN32(x)      (((x) + 31) & ~31)
#endif

#ifndef BIT
#define BIT(n)          (1U << (n))
#endif

static char *action_name[bcmFieldActionCount] = BCM_FIELD_ACTION_STRINGS;

/* IFP_TCAM modes */
#define _IFP_SLICE_MODE_NARROW  0    /* 80-bit Mode  */
#define _IFP_SLICE_MODE_WIDE    1    /* 160-bit Mode */
#define _FP_LT_ID_BASE 0
#define _FP_LT_ID_MAX (0x1F)

/* IFP meter types */
#define _FIELD_METER_TYPE_EVEN 0x1
#define _FIELD_METER_TYPE_ODD  0x2

/* Valid PortBitmap */
#define _BCM_FIELD_VALID_PIPE_PBMP_GET(_unit_, _inst_, _pbm_)                  \
        {                                                                      \
           int _ct_;                                                           \
           int _min_p_, _max_p_;                                               \
           if (_inst_ == _BCM_FIELD_GLOBAL_GROUP) {                            \
             _max_p_ = (_FP_MAX_NUM_PIPES * _FP_TCAM_IPBMP_SIZE(_unit_));      \
             _min_p_ = 0;                                                      \
           } else {                                                            \
             _max_p_ = ((_inst_ + 1) * _FP_TCAM_IPBMP_SIZE(_unit_));           \
             _min_p_ = (_inst_ * _FP_TCAM_IPBMP_SIZE(_unit_));                 \
           }                                                                   \
           for (_ct_ = _min_p_; _ct_ < _max_p_; _ct_++) {                      \
              BCM_PBMP_PORT_ADD(_pbm_, _ct_);                                  \
           }                                                                   \
        }

#define _UDF_CHUNK_WIDTH_ 16

#define _FIELD_UDF_START_CHUNK_OFFSET_GET(_chunk1_, _chunk2_)          do {                       \
             start_second_chunk = 0;                                                        \
             if ((NULL != qset) && (SHR_BITGET(qset->udf_map, _chunk1_))                   \
                                && (SHR_BITGET(qset->udf_map, _chunk2_))) {                   \
                if ((0 == (chunk_bmap & (1 << _chunk1_))) && ((chunk_bmap & (1 << _chunk2_)))) { \
                    start_bit = hint_node->hint->start_bit%(_UDF_CHUNK_WIDTH_);             \
                    start_width = (_UDF_CHUNK_WIDTH_) - start_bit;                          \
                    start_second_chunk = 1;                                                 \
                } else if ((chunk_bmap & (1 << _chunk1_)) && (0 == (chunk_bmap & (1 << _chunk2_)))) { \
                    start_bit = hint_node->hint->start_bit%(_UDF_CHUNK_WIDTH_);             \
                    start_bit = _UDF_CHUNK_WIDTH_ + start_bit;                              \
                    start_second_chunk = 1;                                                 \
                } else {                                                                    \
                    start_bit = hint_node->hint->start_bit%(2 * _UDF_CHUNK_WIDTH_);         \
                    start_width = (2 * _UDF_CHUNK_WIDTH_) - start_bit;                      \
                }                                                                           \
             } else {                                                                       \
                if ((0 == (chunk_bmap & (1 << _chunk1_))) && ((chunk_bmap & (1 << _chunk2_)))) { \
                    start_bit = hint_node->hint->start_bit%(_UDF_CHUNK_WIDTH_);             \
                    start_width = (_UDF_CHUNK_WIDTH_) - start_bit;                          \
                } else if ((chunk_bmap & (1 << _chunk1_)) && (0 == (chunk_bmap & (1 << _chunk2_)))) { \
                    start_bit = hint_node->hint->start_bit%(_UDF_CHUNK_WIDTH_);             \
                    start_bit = _UDF_CHUNK_WIDTH_ + start_bit;                              \
                    start_width = (2 * _UDF_CHUNK_WIDTH_) - start_bit;                      \
                } else {                                                                    \
                    start_bit = hint_node->hint->start_bit%(2 * _UDF_CHUNK_WIDTH_);         \
                    start_width = (2 * _UDF_CHUNK_WIDTH_) - start_bit;                      \
                }                                                                           \
             }                                                                              \
          } while(0);

#define _FIELD_UDF_END_CHUNK_OFFSET_GET(_chunk1_, _chunk2_)      do {                       \
             end_second_chunk = 0;                                                          \
             if ((NULL != qset) && (SHR_BITGET(qset->udf_map, _chunk1_))                   \
                                && (SHR_BITGET(qset->udf_map, _chunk2_))) {                   \
                if ((0 == (chunk_bmap & (1 << _chunk1_))) && ((chunk_bmap & (1 << _chunk2_)))) { \
                    end_bit = 0;                                                            \
                    end_width = hint_node->hint->end_bit%(_UDF_CHUNK_WIDTH_);               \
                    end_second_chunk = 1;                                                   \
                } else if ((chunk_bmap & (1 << _chunk1_)) && (0 == (chunk_bmap & (1 << _chunk2_)))) { \
                    end_bit = _UDF_CHUNK_WIDTH_;                                            \
                    end_width = hint_node->hint->end_bit%(_UDF_CHUNK_WIDTH_);               \
                    end_width = end_width + _UDF_CHUNK_WIDTH_;                              \
                    end_second_chunk = 1;                                                   \
                } else {                                                                    \
                    end_bit = 0;                                                            \
                    end_width = hint_node->hint->end_bit%(2 * _UDF_CHUNK_WIDTH_);           \
                }                                                                           \
             } else {                   \
                if ((0 == (chunk_bmap & (1 << _chunk1_))) && ((chunk_bmap & (1 << _chunk2_)))) { \
                    end_bit = 0;                                                            \
                    end_width = hint_node->hint->end_bit%(_UDF_CHUNK_WIDTH_);               \
                } else if ((chunk_bmap & (1 << _chunk1_)) && (0 == (chunk_bmap & (1 << _chunk2_)))) { \
                    end_bit = _UDF_CHUNK_WIDTH_;                                            \
                    end_width = hint_node->hint->end_bit%(_UDF_CHUNK_WIDTH_);               \
                    end_width = end_width + _UDF_CHUNK_WIDTH_;                              \
                } else {                                                                    \
                    end_bit = 0;                                                            \
                    end_width = hint_node->hint->end_bit%(2 * _UDF_CHUNK_WIDTH_);           \
                }                                                                           \
             }                                                                              \
          } while(0);

static soc_field_t _th_efp_slice_mode[4][2] =  {
          {SLICE_0_MODEf, SLICE_0_IPV6_KEY_MODEf},
          {SLICE_1_MODEf, SLICE_1_IPV6_KEY_MODEf},
          {SLICE_2_MODEf, SLICE_2_IPV6_KEY_MODEf},
          {SLICE_3_MODEf, SLICE_3_IPV6_KEY_MODEf}
       };
static soc_field_t classfldtbl[][7] = {
                       {SLICE_0_F1f, SLICE_0_F2f, SLICE_0_F3f, SLICE_0_F4f,
                                     SLICE_0_F6f, SLICE_0_F7f, SLICE_0_F8f},
                       {SLICE_1_F1f, SLICE_1_F2f, SLICE_1_F3f, SLICE_1_F4f,
                                     SLICE_1_F6f, SLICE_1_F7f, SLICE_1_F8f},
                       {SLICE_2_F1f, SLICE_2_F2f, SLICE_2_F3f, SLICE_2_F4f,
                                     SLICE_2_F6f, SLICE_2_F7f, SLICE_2_F8f},
                       {SLICE_3_F1f, SLICE_3_F2f, SLICE_3_F3f, SLICE_3_F4f,
                                     SLICE_3_F6f, SLICE_3_F7f, SLICE_3_F8f}
};
#if defined (BCM_TRIDENT3_SUPPORT) || defined (BCM_TOMAHAWK3_SUPPORT)
static soc_field_t classIdBfldtbl[4] =
                       { SLICE_0f, SLICE_1f, SLICE_2f, SLICE_3f };
#endif
static soc_field_t dvpfldtbl[4] =
                       { SLICE_0f, SLICE_1f, SLICE_2f, SLICE_3f };

static soc_field_t mdlfldtbl[4] =
                       { SLICE_0f, SLICE_1f, SLICE_2f, SLICE_3f };


static const uint32 vfp_efp_virtual_to_physical_map[] = {
        VIRTUAL_SLICE_0_PHYSICAL_SLICE_NUMBERf,
        VIRTUAL_SLICE_1_PHYSICAL_SLICE_NUMBERf,
        VIRTUAL_SLICE_2_PHYSICAL_SLICE_NUMBERf,
        VIRTUAL_SLICE_3_PHYSICAL_SLICE_NUMBERf};
static const int32 vfp_efp_virtual_to_group_map[] = {
        VIRTUAL_SLICE_0_VIRTUAL_SLICE_GROUPf,
        VIRTUAL_SLICE_1_VIRTUAL_SLICE_GROUPf,
        VIRTUAL_SLICE_2_VIRTUAL_SLICE_GROUPf,
        VIRTUAL_SLICE_3_VIRTUAL_SLICE_GROUPf};
static const soc_field_t vfp_slice_wide_mode_flds[] = {
        SLICE_0_DOUBLE_WIDE_MODEf,
        SLICE_1_DOUBLE_WIDE_MODEf,
        SLICE_2_DOUBLE_WIDE_MODEf,
        SLICE_3_DOUBLE_WIDE_MODEf
    };
static const soc_field_t vfp_slice_pairing_flds[] = {
        SLICE1_0_PAIRINGf,
        SLICE3_2_PAIRINGf
    };

#if defined(BCM_FIREBOLT6_SUPPORT)
_bcm_field_action_set_t bcm_field_fb6_ifp_action_set[_FieldActionSetCount] = {
  { 0, 0, 0}, /* for the actions which doesnt support aset */
  { 1, 0, PROTECTION_SWITCHING_DROP_OVERIDE_SETf},
  /* _FieldActionProtectionSwitchingDropOverrideSet */
  {10, 0, IFP_DLB_ALTERNATE_PATH_CONTROL_SETf},
  /* _FieldActionIfpDlbAlternatePathControlSet */
  { 2, 0, ECMP_DLB_ACTION_SETf},
  /* _FieldActionEcmpDlbActionSet */
  { 2, 0, HGT_LAG_DLB_ACTION_SETf},
  /* _FieldActionHgtLagDlbActionSet */
  { 2, 0, ECMP2_RH_ACTION_SETf},
  /* _FieldActionEcmp2RhActionSet */
  { 2, 0, ECMP1_RH_ACTION_SETf},
  /* _FieldActionEcmp1RhActionSet */
  { 2, 0, LAG_RH_ACTION_SETf},
  /* _FieldActionLagRhActionSet */
  { 2, 0, HGT_RH_ACTION_SETf},
  /* _FieldActionHgtRhActionSet */
  { 4, 0, LOOPBACK_PROFILE_ACTION_SETf},
  /* _FieldActionLoopbackProfileSet */
  {16, 0, EXTRACTION_CTRL_ID_ACTION_SETf}, /*  _FieldActionExtractionCtrlId */
  {16, 0, OPAQUE_4_ACTION_SETf}, /*  _FieldActionOpaque4Set */
  {16, 0, OPAQUE_3_ACTION_SETf}, /*  _FieldActionOpaque3Set */
  {16, 0, OPAQUE_2_ACTION_SETf}, /*  _FieldActionOpaque2Set */
  {16, 0, OPAQUE_1_ACTION_SETf}, /*  _FieldActionOpaque1Set */
  { 2, 0, TX_TIMESTAMP_INSERTION_SETf},
  /*_FieldActionTxTimestampInsertionSet */
  { 2, 0, RX_TIMESTAMP_INSERTION_SETf},
  /*_FieldActionRxTimestampInsertionSet */
  { 1, 0, IGNORE_FCOE_ZONE_CHECK_SETf},
  /*_FieldActionIgnoreFCOEZoneCheckSet */
  { 1, 1, GREEN_TO_PID_SETf},
  /*  _FieldActionGreenToPidSet */
  { 1, 0, MIRROR_OVERRIDE_SETf},
  /*  _FieldActionMirrorOverrideSet */
  { 1, 0, NAT_OVERRIDE_SETf},
  /*  _FieldActionNatOverrideSet*/
  { 1, 0, SFLOW_SETf},
  /*  _FieldActionSflowSet */
  { 1, 0, CUT_THRU_OVERRIDE_SETf},
  /*  _FieldActionCutThrOverrideSet */
  { 1, 0, URPF_OVERRIDE_SETf},
  /* _FieldActionUrpfOverrideSet */
  { 1, 0, TTL_OVERRIDE_SETf},
  /* _FieldActionTtlOverrideSet */
  { 3, 0, LB_CONTROLS_SETf},
  /* _FieldActionLbControlSet */
  { 6, 1, DROP_SETf},
  /* _FieldActionDropSet */
  { 8, 0, CHANGE_CPU_COS_SETf},
  /* _FieldActionChangeCpuCosSet */
  {12, 0, MIRROR_SETf},
  /* _FieldActionMirrorSet */
  {12, 0, NAT_SETf},
  /* _FieldActionNatSet ,*/
  {17, 1, COPY_TO_CPU_SETf},
  /* _FieldActionCopyToCpuSet */
  {23, 1, L3SW_CHANGE_L2_SETf},
  /* _FieldActionL3SwChangeL2Set */
  {38, 1, REDIRECT_SETf},
  /*  IFP  _FieldActionRedirectSet */
  {26, 1, COUNTER_SETf},
  /* _FieldActionCounterSet */
  { 9, 1, CHANGE_ECN_SETf},
  /* _FieldActionChangeEcnSet */
  {18, 1, CHANGE_PKT_PRI_SETf},
  /* _FieldActionChangePktPriSet */
  {25, 1, CHANGE_DSCP_TOS_SETf},
  /* _FieldActionChangeDscpTosSet */
  { 6, 1, CHANGE_DROP_PRECEDENCE_SETf},
  /*_FieldActionChangeDropPrecendenceSet */
  {42, 1, CHANGE_COS_OR_INT_PRI_SETf},
  /* _FieldActionChangeCosOrIntPriSet */
  { 9, 1, CHANGE_INT_CN_SETf},
  /* _FieldActionChangeIntCNSet */
  { 5, 0, CHANGE_INPUT_PRIORITY_SETf},
  /* _FieldActionChangeInputPrioritySet */
  { 1, 0, INSTRUMENTATION_SETf},
  /* _FieldActionInstrumentationSet */
  {16, 0, EDIT_CTRL_ID_ACTION_SETf},  /* _FieldActionEditCtrlIdSet */
  {16, 0, FCOE_VSAN_SETf},  /* _FieldActionFcoeVsanSet */
  {23, 1, METER_SETf}, /*_FieldActionMeterSet */
  { 0, 0, 0},  /* _FieldActionTimestampInsertionSet */
  { 0, 0, 0}, /* _FieldActionDelayedDropSet */
  { 0, 0, 0}, /* _FieldActionDelayedRedirectSet */
  { 0, 0, 0}, /* _FieldActionEcmpDlbMonitorSet */
  { 0, 0, 0}, /* _FieldActionElephantTrapSet */
  { 0, 0, 0}, /* _FieldActionInbandTelemetrySet */
  { 1, 0, USE_IFP_MODID_BASE_SETf}, /* _FieldActionMacSecModidBase */
  { 1, 0, TS0_SOURCE_SETf}, /* _FieldActionTimestampTypeSet */
  { 2, 0, TS0_TYPE_SETf}, /* _FieldActionTimestampSource0Set */
  { 2, 0, TS1_TYPE_SETf} /* _FieldActionTimestampSource1Set */
};
#endif
#if defined(BCM_HURRICANE4_SUPPORT)
_bcm_field_action_set_t bcm_field_hr4_ifp_action_set[_FieldActionSetCount] = {
  { 0, 0, 0}, /* for the actions which doesnt support aset */
  { 1, 0, PROTECTION_SWITCHING_DROP_OVERIDE_SETf},
  /* _FieldActionProtectionSwitchingDropOverrideSet */
  {10, 0, IFP_DLB_ALTERNATE_PATH_CONTROL_SETf},
  /* _FieldActionIfpDlbAlternatePathControlSet */
  { 2, 0, ECMP_DLB_ACTION_SETf},
  /* _FieldActionEcmpDlbActionSet */
  { 2, 0, HGT_LAG_DLB_ACTION_SETf},
  /* _FieldActionHgtLagDlbActionSet */
  { 2, 0, ECMP2_RH_ACTION_SETf},
  /* _FieldActionEcmp2RhActionSet */
  { 2, 0, ECMP1_RH_ACTION_SETf},
  /* _FieldActionEcmp1RhActionSet */
  { 2, 0, LAG_RH_ACTION_SETf},
  /* _FieldActionLagRhActionSet */
  { 2, 0, HGT_RH_ACTION_SETf},
  /* _FieldActionHgtRhActionSet */
  { 4, 0, LOOPBACK_PROFILE_ACTION_SETf},
  /* _FieldActionLoopbackProfileSet */
  {16, 0, EXTRACTION_CTRL_ID_ACTION_SETf}, /*  _FieldActionExtractionCtrlId */
  {16, 0, OPAQUE_4_ACTION_SETf}, /*  _FieldActionOpaque4Set */
  {16, 0, OPAQUE_3_ACTION_SETf}, /*  _FieldActionOpaque3Set */
  {16, 0, OPAQUE_2_ACTION_SETf}, /*  _FieldActionOpaque2Set */
  {16, 0, OPAQUE_1_ACTION_SETf}, /*  _FieldActionOpaque1Set */
  { 2, 0, TX_TIMESTAMP_INSERTION_SETf},
  /*_FieldActionTxTimestampInsertionSet */
  { 2, 0, RX_TIMESTAMP_INSERTION_SETf},
  /*_FieldActionRxTimestampInsertionSet */
  { 1, 0, IGNORE_FCOE_ZONE_CHECK_SETf},
  /*_FieldActionIgnoreFCOEZoneCheckSet */
  { 1, 1, GREEN_TO_PID_SETf},
  /*  _FieldActionGreenToPidSet */
  { 1, 0, MIRROR_OVERRIDE_SETf},
  /*  _FieldActionMirrorOverrideSet */
  { 1, 0, NAT_OVERRIDE_SETf},
  /*  _FieldActionNatOverrideSet*/
  { 1, 0, SFLOW_SETf},
  /*  _FieldActionSflowSet */
  { 1, 0, CUT_THRU_OVERRIDE_SETf},
  /*  _FieldActionCutThrOverrideSet */
  { 1, 0, URPF_OVERRIDE_SETf},
  /* _FieldActionUrpfOverrideSet */
  { 1, 0, TTL_OVERRIDE_SETf},
  /* _FieldActionTtlOverrideSet */
  { 3, 0, LB_CONTROLS_SETf},
  /* _FieldActionLbControlSet */
  { 6, 1, DROP_SETf},
  /* _FieldActionDropSet */
  { 8, 0, CHANGE_CPU_COS_SETf},
  /* _FieldActionChangeCpuCosSet */
  {12, 0, MIRROR_SETf},
  /* _FieldActionMirrorSet */
  {12, 0, NAT_SETf},
  /* _FieldActionNatSet ,*/
  {17, 1, COPY_TO_CPU_SETf},
  /* _FieldActionCopyToCpuSet */
  {23, 1, L3SW_CHANGE_L2_SETf},
  /* _FieldActionL3SwChangeL2Set */
  {38, 1, REDIRECT_SETf},
  /*  IFP  _FieldActionRedirectSet */
  {26, 1, COUNTER_SETf},
  /* _FieldActionCounterSet */
  { 9, 1, CHANGE_ECN_SETf},
  /* _FieldActionChangeEcnSet */
  {18, 1, CHANGE_PKT_PRI_SETf},
  /* _FieldActionChangePktPriSet */
  {25, 1, CHANGE_DSCP_TOS_SETf},
  /* _FieldActionChangeDscpTosSet */
  { 6, 1, CHANGE_DROP_PRECEDENCE_SETf},
  /*_FieldActionChangeDropPrecendenceSet */
  {42, 1, CHANGE_COS_OR_INT_PRI_SETf},
  /* _FieldActionChangeCosOrIntPriSet */
  { 9, 1, CHANGE_INT_CN_SETf},
  /* _FieldActionChangeIntCNSet */
  { 5, 0, CHANGE_INPUT_PRIORITY_SETf},
  /* _FieldActionChangeInputPrioritySet */
  { 1, 0, INSTRUMENTATION_SETf},
  /* _FieldActionInstrumentationSet */
  {16, 0, EDIT_CTRL_ID_ACTION_SETf},  /* _FieldActionEditCtrlIdSet */
  {16, 0, FCOE_VSAN_SETf},  /* _FieldActionFcoeVsanSet */
  {21, 1, METER_SETf}, /*_FieldActionMeterSet */
  { 0, 0, 0},  /* _FieldActionTimestampInsertionSet */
  { 0, 0, 0}, /* _FieldActionDelayedDropSet */
  { 0, 0, 0}, /* _FieldActionDelayedRedirectSet */
  { 0, 0, 0}, /* _FieldActionEcmpDlbMonitorSet */
  { 0, 0, 0}, /* _FieldActionElephantTrapSet */
  { 0, 0, 0}, /* _FieldActionInbandTelemetrySet */
  { 1, 0, USE_IFP_MODID_BASE_SETf}, /* _FieldActionMacSecModidBase */
  { 1, 0, TS0_SOURCE_SETf}, /* _FieldActionTimestampTypeSet */
  { 2, 0, TS0_TYPE_SETf}, /* _FieldActionTimestampSource0Set */
  { 2, 0, TS1_TYPE_SETf} /* _FieldActionTimestampSource1Set */
};
#endif

_bcm_field_action_set_t bcm_field_hx5_ifp_action_set[_FieldActionSetCount] = {
  { 0, 0, 0}, /* for the actions which doesnt support aset */
  { 1, 0, PROTECTION_SWITCHING_DROP_OVERIDE_SETf},
  /* _FieldActionProtectionSwitchingDropOverrideSet */
  {10, 0, IFP_DLB_ALTERNATE_PATH_CONTROL_SETf},
  /* _FieldActionIfpDlbAlternatePathControlSet */
  { 2, 0, ECMP_DLB_ACTION_SETf},
  /* _FieldActionEcmpDlbActionSet */
  { 2, 0, HGT_LAG_DLB_ACTION_SETf},
  /* _FieldActionHgtLagDlbActionSet */
  { 2, 0, ECMP2_RH_ACTION_SETf},
  /* _FieldActionEcmp2RhActionSet */
  { 2, 0, ECMP1_RH_ACTION_SETf},
  /* _FieldActionEcmp1RhActionSet */
  { 2, 0, LAG_RH_ACTION_SETf},
  /* _FieldActionLagRhActionSet */
  { 2, 0, HGT_RH_ACTION_SETf},
  /* _FieldActionHgtRhActionSet */
  { 4, 0, LOOPBACK_PROFILE_ACTION_SETf},
  /* _FieldActionLoopbackProfileSet */
  {16, 0, EXTRACTION_CTRL_ID_ACTION_SETf}, /*  _FieldActionExtractionCtrlId */
  {16, 0, OPAQUE_4_ACTION_SETf}, /*  _FieldActionOpaque4Set */
  {16, 0, OPAQUE_3_ACTION_SETf}, /*  _FieldActionOpaque3Set */
  {16, 0, OPAQUE_2_ACTION_SETf}, /*  _FieldActionOpaque2Set */
  {16, 0, OPAQUE_1_ACTION_SETf}, /*  _FieldActionOpaque1Set */
  { 2, 0, TX_TIMESTAMP_INSERTION_SETf},
  /*_FieldActionTxTimestampInsertionSet */
  { 2, 0, RX_TIMESTAMP_INSERTION_SETf},
  /*_FieldActionRxTimestampInsertionSet */
  { 1, 0, IGNORE_FCOE_ZONE_CHECK_SETf},
  /*_FieldActionIgnoreFCOEZoneCheckSet */
  { 1, 1, GREEN_TO_PID_SETf},
  /*  _FieldActionGreenToPidSet */
  { 1, 0, MIRROR_OVERRIDE_SETf},
  /*  _FieldActionMirrorOverrideSet */
  { 1, 0, NAT_OVERRIDE_SETf},
  /*  _FieldActionNatOverrideSet*/
  { 1, 0, SFLOW_SETf},
  /*  _FieldActionSflowSet */
  { 1, 0, CUT_THRU_OVERRIDE_SETf},
  /*  _FieldActionCutThrOverrideSet */
  { 1, 0, URPF_OVERRIDE_SETf},
  /* _FieldActionUrpfOverrideSet */
  { 1, 0, TTL_OVERRIDE_SETf},
  /* _FieldActionTtlOverrideSet */
  { 3, 0, LB_CONTROLS_SETf},
  /* _FieldActionLbControlSet */
  { 6, 1, DROP_SETf},
  /* _FieldActionDropSet */
  { 8, 0, CHANGE_CPU_COS_SETf},
  /* _FieldActionChangeCpuCosSet */
  {12, 0, MIRROR_SETf},
  /* _FieldActionMirrorSet */
  {12, 0, NAT_SETf},
  /* _FieldActionNatSet ,*/
  {17, 1, COPY_TO_CPU_SETf},
  /* _FieldActionCopyToCpuSet */
  {23, 1, L3SW_CHANGE_L2_SETf},
  /* _FieldActionL3SwChangeL2Set */
  {38, 1, REDIRECT_SETf},
  /*  IFP  _FieldActionRedirectSet */
  {26, 1, COUNTER_SETf},
  /* _FieldActionCounterSet */
  { 9, 1, CHANGE_ECN_SETf},
  /* _FieldActionChangeEcnSet */
  {18, 1, CHANGE_PKT_PRI_SETf},
  /* _FieldActionChangePktPriSet */
  {25, 1, CHANGE_DSCP_TOS_SETf},
  /* _FieldActionChangeDscpTosSet */
  { 6, 1, CHANGE_DROP_PRECEDENCE_SETf},
  /*_FieldActionChangeDropPrecendenceSet */
  {42, 1, CHANGE_COS_OR_INT_PRI_SETf},
  /* _FieldActionChangeCosOrIntPriSet */
  { 9, 1, CHANGE_INT_CN_SETf},
  /* _FieldActionChangeIntCNSet */
  { 5, 0, CHANGE_INPUT_PRIORITY_SETf},
  /* _FieldActionChangeInputPrioritySet */
  { 1, 0, INSTRUMENTATION_SETf},
  /* _FieldActionInstrumentationSet */
  {16, 0, EDIT_CTRL_ID_ACTION_SETf},  /* _FieldActionEditCtrlIdSet */
  {16, 0, FCOE_VSAN_SETf},  /* _FieldActionFcoeVsanSet */
  {20, 1, METER_SETf}, /*_FieldActionMeterSet */
  { 0, 0, 0},  /* _FieldActionTimestampInsertionSet */
  { 0, 0, 0}, /* _FieldActionDelayedDropSet */
  { 0, 0, 0}, /* _FieldActionDelayedRedirectSet */
  { 0, 0, 0}, /* _FieldActionEcmpDlbMonitorSet */
  { 0, 0, 0}, /* _FieldActionElephantTrapSet */
  { 0, 0, 0}, /* _FieldActionInbandTelemetrySet */
  { 0, 0, 0}, /* _FieldActionMacSecModidBase */
  { 0, 0, 0}, /* _FieldActionTimestampTypeSet */
  { 0, 0, 0}, /* _FieldActionTimestampSource0Set */
  { 0, 0, 0} /* _FieldActionTimestampSource1Set */
};

_bcm_field_action_set_t bcm_field_td3_ifp_action_set[_FieldActionSetCount] = {
  { 0, 0, 0}, /* for the actions which doesnt support aset */
  { 1, 0, PROTECTION_SWITCHING_DROP_OVERIDE_SETf},
  /* _FieldActionProtectionSwitchingDropOverrideSet */
  {10, 0, IFP_DLB_ALTERNATE_PATH_CONTROL_SETf},
  /* _FieldActionIfpDlbAlternatePathControlSet */
  { 2, 0, ECMP_DLB_ACTION_SETf},
  /* _FieldActionEcmpDlbActionSet */
  { 2, 0, HGT_LAG_DLB_ACTION_SETf},
  /* _FieldActionHgtLagDlbActionSet */
  { 2, 0, ECMP2_RH_ACTION_SETf},
  /* _FieldActionEcmp2RhActionSet */
  { 2, 0, ECMP1_RH_ACTION_SETf},
  /* _FieldActionEcmp1RhActionSet */
  { 2, 0, LAG_RH_ACTION_SETf},
  /* _FieldActionLagRhActionSet */
  { 2, 0, HGT_RH_ACTION_SETf},
  /* _FieldActionHgtRhActionSet */
  { 4, 0, LOOPBACK_PROFILE_ACTION_SETf},
  /* _FieldActionLoopbackProfileSet */
  {16, 0, EXTRACTION_CTRL_ID_ACTION_SETf}, /*  _FieldActionExtractionCtrlId */
  {16, 0, OPAQUE_4_ACTION_SETf}, /*  _FieldActionOpaque4Set */
  {16, 0, OPAQUE_3_ACTION_SETf}, /*  _FieldActionOpaque3Set */
  {16, 0, OPAQUE_2_ACTION_SETf}, /*  _FieldActionOpaque2Set */
  {16, 0, OPAQUE_1_ACTION_SETf}, /*  _FieldActionOpaque1Set */
  { 2, 0, TX_TIMESTAMP_INSERTION_SETf},
  /*_FieldActionTxTimestampInsertionSet */
  { 2, 0, RX_TIMESTAMP_INSERTION_SETf},
  /*_FieldActionRxTimestampInsertionSet */
  { 1, 0, IGNORE_FCOE_ZONE_CHECK_SETf},
  /*_FieldActionIgnoreFCOEZoneCheckSet */
  { 1, 1, GREEN_TO_PID_SETf},
  /*  _FieldActionGreenToPidSet */
  { 1, 0, MIRROR_OVERRIDE_SETf},
  /*  _FieldActionMirrorOverrideSet */
  { 1, 0, NAT_OVERRIDE_SETf},
  /*  _FieldActionNatOverrideSet*/
  { 1, 0, SFLOW_SETf},
  /*  _FieldActionSflowSet */
  { 1, 0, CUT_THRU_OVERRIDE_SETf},
  /*  _FieldActionCutThrOverrideSet */
  { 1, 0, URPF_OVERRIDE_SETf},
  /* _FieldActionUrpfOverrideSet */
  { 1, 0, TTL_OVERRIDE_SETf},
  /* _FieldActionTtlOverrideSet */
  { 3, 0, LB_CONTROLS_SETf},
  /* _FieldActionLbControlSet */
  { 6, 1, DROP_SETf},
  /* _FieldActionDropSet */
  { 8, 0, CHANGE_CPU_COS_SETf},
  /* _FieldActionChangeCpuCosSet */
  {12, 0, MIRROR_SETf},
  /* _FieldActionMirrorSet */
  {12, 0, NAT_SETf},
  /* _FieldActionNatSet ,*/
  {17, 1, COPY_TO_CPU_SETf},
  /* _FieldActionCopyToCpuSet */
  {23, 1, L3SW_CHANGE_L2_SETf},
  /* _FieldActionL3SwChangeL2Set */
  {38, 1, REDIRECT_SETf},
  /*  IFP  _FieldActionRedirectSet */
  {26, 1, COUNTER_SETf},
  /* _FieldActionCounterSet */
  { 9, 1, CHANGE_ECN_SETf},
  /* _FieldActionChangeEcnSet */
  {18, 1, CHANGE_PKT_PRI_SETf},
  /* _FieldActionChangePktPriSet */
  {25, 1, CHANGE_DSCP_TOS_SETf},
  /* _FieldActionChangeDscpTosSet */
  { 6, 1, CHANGE_DROP_PRECEDENCE_SETf},
  /*_FieldActionChangeDropPrecendenceSet */
  {36, 1, CHANGE_COS_OR_INT_PRI_SETf},
  /* _FieldActionChangeCosOrIntPriSet */
  { 9, 1, CHANGE_INT_CN_SETf},
  /* _FieldActionChangeIntCNSet */
  { 5, 0, CHANGE_INPUT_PRIORITY_SETf},
  /* _FieldActionChangeInputPrioritySet */
  { 1, 0, INSTRUMENTATION_SETf},
  /* _FieldActionInstrumentationSet */
  {16, 0, EDIT_CTRL_ID_ACTION_SETf},  /* _FieldActionEditCtrlIdSet */
  {16, 0, FCOE_VSAN_SETf},  /* _FieldActionFcoeVsanSet */
  {20, 1, METER_SETf}, /*_FieldActionMeterSet */
  { 0, 0, 0}, /* _FieldActionTimestampInsertionSet */
  { 0, 0, 0}, /* _FieldActionDelayedDropSet */
  { 0, 0, 0}, /* _FieldActionDelayedRedirectSet */
  { 0, 0, 0}, /* _FieldActionEcmpDlbMonitorSet */
  { 0, 0, 0}, /* _FieldActionElephantTrapSet */
  { 0, 0, 0}, /* _FieldActionInbandTelemetrySet */
  { 0, 0, 0}, /* _FieldActionMacSecModidBase */
  { 0, 0, 0}, /* _FieldActionTimestampTypeSet */
  { 0, 0, 0}, /* _FieldActionTimestampSource0Set */
  { 0, 0, 0} /* _FieldActionTimestampSource1Set */
};

_bcm_field_action_set_t bcm_field_td3_em_action_set[_FieldActionSetCount] = {
  { 0, 0, 0}, /* for the actions which doesnt support aset */
  { 1, 0, PROTECTION_SWITCHING_DROP_OVERIDE_SETf},
  /* _FieldActionProtectionSwitchingDropOverrideSet */
  {10, 0, IFP_DLB_ALTERNATE_PATH_CONTROL_SETf},
  /* _FieldActionIfpDlbAlternatePathControlSet */
  { 2, 0, ECMP_DLB_ACTION_SETf},
  /* _FieldActionEcmpDlbActionSet */
  { 2, 0, HGT_LAG_DLB_ACTION_SETf},
  /* _FieldActionHgtLagDlbActionSet */
  { 2, 0, ECMP2_RH_ACTION_SETf},
  /* _FieldActionEcmp2RhActionSet */
  { 2, 0, ECMP1_RH_ACTION_SETf},
  /* _FieldActionEcmp1RhActionSet */
  { 2, 0, LAG_RH_ACTION_SETf},
  /* _FieldActionLagRhActionSet */
  { 2, 0, HGT_RH_ACTION_SETf},
  /* _FieldActionHgtRhActionSet */
  { 4, 0, LOOPBACK_PROFILE_ACTION_SETf},
  /* _FieldActionLoopbackProfileSet */
  {16, 0, EXTRACTION_CTRL_ID_ACTION_SETf}, /*  _FieldActionExtractionCtrlId */
  {16, 0, OPAQUE_4_ACTION_SETf}, /*  _FieldActionOpaque4Set */
  {16, 0, OPAQUE_3_ACTION_SETf}, /*  _FieldActionOpaque3Set */
  {16, 0, OPAQUE_2_ACTION_SETf}, /*  _FieldActionOpaque2Set */
  {16, 0, OPAQUE_1_ACTION_SETf}, /*  _FieldActionOpaque1Set */
  { 2, 0, TX_TIMESTAMP_INSERTION_SETf}, /*_FieldActionTxTimestampInsertionSet */
  { 2, 0, RX_TIMESTAMP_INSERTION_SETf}, /*_FieldActionRxTimestampInsertionSet */
  { 1, 0, IGNORE_FCOE_ZONE_CHECK_SETf}, /*_FieldActionIgnoreFCOEZoneCheckSet */
  { 1, 1, GREEN_TO_PID_SETf},
  /*  _FieldActionGreenToPidSet */
  { 1, 0, MIRROR_OVERRIDE_SETf},
  /*  _FieldActionMirrorOverrideSet */
  { 1, 0, NAT_OVERRIDE_SETf},
  /*  _FieldActionNatOverrideSet */
  { 1, 0, SFLOW_SETf},
  /*  _FieldActionSflowSet */
  { 1, 0, CUT_THRU_OVERRIDE_SETf},
  /*  _FieldActionCutThrOverrideSet */
  { 1, 0, URPF_OVERRIDE_SETf},
  /* _FieldActionUrpfOverrideSet */
  { 1, 0, TTL_OVERRIDE_SETf},
  /* _FieldActionTtlOverrideSet */
  { 3, 0, LB_CONTROLS_SETf},
  /* _FieldActionLbControlSet */
  { 6, 1, DROP_SETf},
  /* _FieldActionDropSet */
  { 8, 0, CHANGE_CPU_COS_SETf},
  /* _FieldActionChangeCpuCosSet */
  {12, 0, MIRROR_SETf},
  /* _FieldActionMirrorSet */
  {12, 0, NAT_SETf},
  /* _FieldActionNatSet */
  {17, 1, COPY_TO_CPU_SETf},
  /* _FieldActionCopyToCpuSet */
  {23, 1, L3SW_CHANGE_L2_SETf},
  /* _FieldActionL3SwChangeL2Set */
  {25, 1, EXACT_MATCH_REDIRECT_SETf},
  /*  EP  _FieldActionRedirectSet */
  {26, 1, COUNTER_SETf},
  /* _FieldActionCounterSet */
  { 0, 0, 0}, /* _FieldActionChangeEcnSet */
  { 0, 0, 0}, /* _FieldActionChangePktPriSet */
  { 0, 0, 0}, /* _FieldActionChangeDscpTosSet */
  { 0, 0, 0}, /* _FieldActionChangeDropPrecendenceSet */
  { 0, 0, 0}, /* _FieldActionChangeCosOrIntPriSet */
  { 0, 0, 0}, /* _FieldActionChangeIntCNSet */
  { 0, 0, 0}, /* _FieldActionChangeInputPrioritySet */
  { 1, 0, INSTRUMENTATION_SETf}, /* _FieldActionInstrumentationSet */
  {16, 0, EDIT_CTRL_ID_ACTION_SETf}, /* _FieldActionEditCtrlIdSet */
  { 1, 0, FCOE_VSAN_SETf}, /* _FieldActionFcoeVsanSet */
  {20, 1, METER_SETf}, /*_FieldActionMeterSet */
  { 0, 0, 0}, /* _FieldActionTimestampInsertionSet */
  { 0, 0, 0}, /* _FieldActionDelayedDropSet */
  { 0, 0, 0}, /* _FieldActionDelayedRedirectSet */
  { 0, 0, 0}, /* _FieldActionEcmpDlbMonitorSet */
  { 0, 0, 0}, /* _FieldActionElephantTrapSet */
  { 0, 0, 0}, /* _FieldActionInbandTelemetrySet */
  { 0, 0, 0}, /* _FieldActionMacSecModidBase */
  { 0, 0, 0}, /* _FieldActionTimestampTypeSet */
  { 0, 0, 0}, /* _FieldActionTimestampSource0Set */
  { 0, 0, 0} /* _FieldActionTimestampSource1Set */
};


_bcm_field_action_set_t bcm_field_fb6_em_action_set[_FieldActionSetCount] = {
  { 0, 0, 0}, /* for the actions which doesnt support aset */
  { 1, 0, PROTECTION_SWITCHING_DROP_OVERIDE_SETf},
  /* _FieldActionProtectionSwitchingDropOverrideSet */
  {10, 0, IFP_DLB_ALTERNATE_PATH_CONTROL_SETf},
  /* _FieldActionIfpDlbAlternatePathControlSet */
  { 2, 0, ECMP_DLB_ACTION_SETf},
  /* _FieldActionEcmpDlbActionSet */
  { 2, 0, HGT_LAG_DLB_ACTION_SETf},
  /* _FieldActionHgtLagDlbActionSet */
  { 2, 0, ECMP2_RH_ACTION_SETf},
  /* _FieldActionEcmp2RhActionSet */
  { 2, 0, ECMP1_RH_ACTION_SETf},
  /* _FieldActionEcmp1RhActionSet */
  { 2, 0, LAG_RH_ACTION_SETf},
  /* _FieldActionLagRhActionSet */
  { 2, 0, HGT_RH_ACTION_SETf},
  /* _FieldActionHgtRhActionSet */
  { 4, 0, LOOPBACK_PROFILE_ACTION_SETf},
  /* _FieldActionLoopbackProfileSet */
  {16, 0, EXTRACTION_CTRL_ID_ACTION_SETf}, /*  _FieldActionExtractionCtrlId */
  {16, 0, OPAQUE_4_ACTION_SETf}, /*  _FieldActionOpaque4Set */
  {16, 0, OPAQUE_3_ACTION_SETf}, /*  _FieldActionOpaque3Set */
  {16, 0, OPAQUE_2_ACTION_SETf}, /*  _FieldActionOpaque2Set */
  {16, 0, OPAQUE_1_ACTION_SETf}, /*  _FieldActionOpaque1Set */
  { 2, 0, TX_TIMESTAMP_INSERTION_SETf}, /*_FieldActionTxTimestampInsertionSet */
  { 2, 0, RX_TIMESTAMP_INSERTION_SETf}, /*_FieldActionRxTimestampInsertionSet */
  { 1, 0, IGNORE_FCOE_ZONE_CHECK_SETf}, /*_FieldActionIgnoreFCOEZoneCheckSet */
  { 1, 1, GREEN_TO_PID_SETf},
  /*  _FieldActionGreenToPidSet */
  { 1, 0, MIRROR_OVERRIDE_SETf},
  /*  _FieldActionMirrorOverrideSet */
  { 1, 0, NAT_OVERRIDE_SETf},
  /*  _FieldActionNatOverrideSet */
  { 1, 0, SFLOW_SETf},
  /*  _FieldActionSflowSet */
  { 1, 0, CUT_THRU_OVERRIDE_SETf},
  /*  _FieldActionCutThrOverrideSet */
  { 1, 0, URPF_OVERRIDE_SETf},
  /* _FieldActionUrpfOverrideSet */
  { 1, 0, TTL_OVERRIDE_SETf},
  /* _FieldActionTtlOverrideSet */
  { 3, 0, LB_CONTROLS_SETf},
  /* _FieldActionLbControlSet */
  { 6, 1, DROP_SETf},
  /* _FieldActionDropSet */
  { 8, 0, CHANGE_CPU_COS_SETf},
  /* _FieldActionChangeCpuCosSet */
  {12, 0, MIRROR_SETf},
  /* _FieldActionMirrorSet */
  {12, 0, NAT_SETf},
  /* _FieldActionNatSet */
  {17, 1, COPY_TO_CPU_SETf},
  /* _FieldActionCopyToCpuSet */
  {23, 1, L3SW_CHANGE_L2_SETf},
  /* _FieldActionL3SwChangeL2Set */
  {25, 1, EXACT_MATCH_REDIRECT_SETf},
  /*  EP  _FieldActionRedirectSet */
  {26, 1, COUNTER_SETf},
  /* _FieldActionCounterSet */
  { 0, 0, 0}, /* _FieldActionChangeEcnSet */
  { 0, 0, 0}, /* _FieldActionChangePktPriSet */
  { 0, 0, 0}, /* _FieldActionChangeDscpTosSet */
  { 0, 0, 0}, /* _FieldActionChangeDropPrecendenceSet */
  { 0, 0, 0}, /* _FieldActionChangeCosOrIntPriSet */
  { 0, 0, 0}, /* _FieldActionChangeIntCNSet */
  { 0, 0, 0}, /* _FieldActionChangeInputPrioritySet */
  { 1, 0, INSTRUMENTATION_SETf}, /* _FieldActionInstrumentationSet */
  {16, 0, EDIT_CTRL_ID_ACTION_SETf}, /* _FieldActionEditCtrlIdSet */
  { 1, 0, FCOE_VSAN_SETf}, /* _FieldActionFcoeVsanSet */
  {23, 1, METER_SETf}, /*_FieldActionMeterSet */
  { 0, 0, 0}, /* _FieldActionTimestampInsertionSet */
  { 0, 0, 0}, /* _FieldActionDelayedDropSet */
  { 0, 0, 0}, /* _FieldActionDelayedRedirectSet */
  { 0, 0, 0}, /* _FieldActionEcmpDlbMonitorSet */
  { 0, 0, 0}, /* _FieldActionElephantTrapSet */
  { 0, 0, 0}, /* _FieldActionInbandTelemetrySet */
  { 0, 0, 0}, /* _FieldActionMacSecModidBase */
  { 0, 0, 0}, /* _FieldActionTimestampTypeSet */
  { 0, 0, 0}, /* _FieldActionTimestampSource0Set */
  { 0, 0, 0} /* _FieldActionTimestampSource1Set */
};

_bcm_field_action_set_t bcm_field_th_em_action_set[_FieldActionSetCount] = {
  { 0, 0, 0}, /* for the actions which doesnt support aset */
  { 0, 0, 0},
  /* _FieldActionProtectionSwitchingDropOverrideSet */
  { 0, 0, 0},
  /* _FieldActionIfpDlbAlternatePathControlSet */
  { 0, 0, 0},
  /* _FieldActionEcmpDlbActionSet */
  { 0, 0, 0},
  /* _FieldActionHgtLagDlbActionSet */
  { 0, 0, 0},
  /* _FieldActionEcmp2RhActionSet */
  { 0, 0, 0},
  /* _FieldActionEcmp1RhActionSet */
  { 0, 0, 0},
  /* _FieldActionLagRhActionSet */
  { 0, 0, 0},
  /* _FieldActionHgtRhActionSet */
  { 0, 0, 0}, /* _FieldActionLoopbackProfileSet = 1,*/
  { 0, 0, 0}, /*  _FieldActionExtractionCtrlId = 2,*/
  { 0, 0, 0}, /*  _FieldActionOpaque4Set = 3,*/
  { 0, 0, 0}, /*  _FieldActionOpaque3Set = 4,*/
  { 0, 0, 0}, /*  _FieldActionOpaque2Set = 5,*/
  { 0, 0, 0}, /*  _FieldActionOpaque1Set = 6,*/
  { 0, 0, 0}, /*  _FieldActionTxTimestampInsertionSet = 7,*/
  { 0, 0, 0}, /*  _FieldActionRxTimestampInsertionSet = 8,*/
  { 0, 0, 0}, /*  _FieldActionIgnoreFCOEZoneCheckSet = 9,*/
  { 1, 1, GREEN_TO_PID_SET_ENABLEf},
  /*  _FieldActionGreenToPidSet = 10, */
  { 1, 0, MIRROR_OVERRIDE_SET_ENABLEf},
  /*  _FieldActionMirrorOverrideSet = 11,*/
  { 1, 0, NAT_OVERRIDE_SET_ENABLEf},
  /*  _FieldActionNatOverrideSet = 12,*/
  { 1, 0, SFLOW_SET_ENABLEf},
  /*  _FieldActionSflowSet = 13,*/
  { 1, 0, CUT_THRU_OVERRIDE_SET_ENABLEf},
  /*  _FieldActionCutThrOverrideSet = 14,*/
  { 1, 0, URPF_OVERRIDE_SET_ENABLEf},
  /* _FieldActionUrpfOverrideSet = 15, */
  { 1, 0, TTL_OVERRIDE_SET_ENABLEf},
  /* _FieldActionTtlOverrideSet = 16,*/
  { 3, 0, LB_CONTROLS_SET_ENABLEf},
  /* _FieldActionLbControlSet = 17,*/
  { 6, 1, DROP_SET_ENABLEf},
  /* _FieldActionDropSet = 18, */
  { 8, 0, CHANGE_CPU_COS_SET_ENABLEf},
  /* _FieldActionChangeCpuCosSet = 19, */
  {12, 0, MIRROR_SET_ENABLEf},
  /* _FieldActionMirrorSet = 20, */
  {12, 0, NAT_SET_ENABLEf},
  /* _FieldActionNatSet = 21,*/
  {17, 1, COPY_TO_CPU_SET_ENABLEf},
  /* _FieldActionCopyToCpuSet = 22,*/
  {23, 1, L3SW_CHANGE_L2_SET_ENABLEf},
  /* _FieldActionL3SwChangeL2Set = 23,*/
  {25, 1, EXACT_MATCH_REDIRECT_SET_ENABLEf},
  /*  EM _FieldActionRedirectSet = 24,*/
  {25, 1, COUNTER_SET_ENABLEf},
  /* _FieldActionCounterSet */
  { 0, 0, 0}, /* _FieldActionChangeEcnSet */
  { 0, 0, 0}, /* _FieldActionChangePktPriSet */
  { 0, 0, 0}, /* _FieldActionChangeDscpTosSet */
  { 0, 0, 0}, /* _FieldActionChangeDropPrecendenceSet */
  { 0, 0, 0}, /* _FieldActionChangeCosOrIntPriSet */
  { 0, 0, 0}, /* _FieldActionChangeIntCNSet */
  { 0, 0, 0}, /* _FieldActionChangeInputPrioritySet */
  { 0, 0, 0}, /* _FieldActionInstrumentationSet */
  { 0, 0, 0}, /* _FieldActionEditCtrlIdSet */
  { 0, 0, 0}, /* _FieldActionFcoeVsanSet */
  {18, 1, METER_SET_ENABLEf}, /*_FieldActionMeterSet */
  { 0, 0, 0}, /* _FieldActionTimestampInsertionSet */
  { 0, 0, 0}, /* _FieldActionDelayedDropSet */
  { 0, 0, 0}, /* _FieldActionDelayedRedirectSet */
  { 0, 0, 0}, /* _FieldActionEcmpDlbMonitorSet */
  { 0, 0, 0}, /* _FieldActionElephantTrapSet */
  { 0, 0, 0}, /* _FieldActionInbandTelemetrySet */
  { 0, 0, 0}, /* _FieldActionMacSecModidBase */
  { 0, 0, 0}, /* _FieldActionTimestampTypeSet */
  { 0, 0, 0}, /* _FieldActionTimestampSource0Set */
  { 0, 0, 0} /* _FieldActionTimestampSource1Set */
};

_bcm_field_action_set_t bcm_field_th2_em_action_set[_FieldActionSetCount] = {
  { 0, 0, 0}, /* for the actions which doesnt support aset */
  { 1, 0, PROTECTION_SWITCHING_SET_ENABLEf}, /* _FieldActionProtectionSwitchingDropOverrideSet */
  { 10, 0, DLB_ALTERNATE_PATH_CONTROL_SET_ENABLEf},
  /* _FieldActionIfpDlbAlternatePathControlSet */
  { 2, 0, DLB_ECMP_SET_ENABLEf},
  /* _FieldActionEcmpDlbActionSet */
  { 2, 0, DLB_HGT_LAG_SET_ENABLEf},
  /* _FieldActionHgtLagDlbActionSet */
  { 0, 0, 0},
  /* _FieldActionEcmp2RhActionSet */
  { 0, 0, 0},
  /* _FieldActionEcmp1RhActionSet */
  { 0, 0, 0},
  /* _FieldActionLagRhActionSet */
  { 0, 0, 0},
  /* _FieldActionHgtRhActionSet */
  { 0, 0, 0}, /* _FieldActionLoopbackProfileSet = 1,*/
  { 0, 0, 0}, /*  _FieldActionExtractionCtrlId = 2,*/
  { 0, 0, 0}, /*  _FieldActionOpaque4Set = 3,*/
  { 0, 0, 0}, /*  _FieldActionOpaque3Set = 4,*/
  { 0, 0, 0}, /*  _FieldActionOpaque2Set = 5,*/
  { 0, 0, 0}, /*  _FieldActionOpaque1Set = 6,*/
  { 0, 0, 0}, /*  _FieldActionTxTimestampInsertionSet = 7,*/
  { 0, 0, 0}, /*  _FieldActionRxTimestampInsertionSet = 8,*/
  { 0, 0, 0}, /*  _FieldActionIgnoreFCOEZoneCheckSet = 9,*/
  { 1, 1, GREEN_TO_PID_SET_ENABLEf},
  /*  _FieldActionGreenToPidSet = 10, */
  { 1, 0, MIRROR_OVERRIDE_SET_ENABLEf},
  /*  _FieldActionMirrorOverrideSet = 11,*/
  { 1, 0, NAT_OVERRIDE_SET_ENABLEf},
  /*  _FieldActionNatOverrideSet = 12,*/
  { 1, 0, SFLOW_SET_ENABLEf},
  /*  _FieldActionSflowSet = 13,*/
  { 1, 0, CUT_THRU_OVERRIDE_SET_ENABLEf},
  /*  _FieldActionCutThrOverrideSet = 14,*/
  { 1, 0, URPF_OVERRIDE_SET_ENABLEf},
  /* _FieldActionUrpfOverrideSet = 15, */
  { 1, 0, TTL_OVERRIDE_SET_ENABLEf},
  /* _FieldActionTtlOverrideSet = 16,*/
  { 3, 0, LB_CONTROLS_SET_ENABLEf},
  /* _FieldActionLbControlSet = 17,*/
  { 6, 1, DROP_SET_ENABLEf},
  /* _FieldActionDropSet = 18, */
  { 8, 0, CHANGE_CPU_COS_SET_ENABLEf},
  /* _FieldActionChangeCpuCosSet = 19, */
  {12, 0, MIRROR_SET_ENABLEf},
  /* _FieldActionMirrorSet = 20, */
  {12, 0, NAT_SET_ENABLEf},
  /* _FieldActionNatSet = 21,*/
  {17, 1, COPY_TO_CPU_SET_ENABLEf},
  /* _FieldActionCopyToCpuSet = 22,*/
  {23, 1, L3SW_CHANGE_L2_SET_ENABLEf},
  /* _FieldActionL3SwChangeL2Set = 23,*/
  {25, 1, EXACT_MATCH_REDIRECT_SET_ENABLEf},
  /*  EM _FieldActionRedirectSet = 24,*/
  {26, 1, COUNTER_SET_ENABLEf},
  /* _FieldActionCounterSet */
  { 0, 0, 0}, /* _FieldActionChangeEcnSet */
  { 0, 0, 0}, /* _FieldActionChangePktPriSet */
  { 0, 0, 0}, /* _FieldActionChangeDscpTosSet */
  { 0, 0, 0}, /* _FieldActionChangeDropPrecendenceSet */
  { 0, 0, 0}, /* _FieldActionChangeCosOrIntPriSet */
  { 0, 0, 0}, /* _FieldActionChangeIntCNSet */
  { 0, 0, 0}, /* _FieldActionChangeInputPrioritySet */
  { 1, 0, INSTRUMENTATION_SET_ENABLEf}, /* _FieldActionInstrumentationSet */
  { 0, 0, 0}, /* _FieldActionEditCtrlIdSet */
  { 0, 0, 0}, /* _FieldActionFcoeVsanSet */
  {18, 1, METER_SET_ENABLEf}, /*_FieldActionMeterSet */
  { 4, 0, TIMESTAMP_SET_ENABLEf}, /*_FieldActionTimestampInsertionSet*/
  { 0, 0, 0}, /* _FieldActionDelayedDropSet */
  { 0, 0, 0}, /* _FieldActionDelayedRedirectSet */
  { 0, 0, 0}, /* _FieldActionEcmpDlbMonitorSet */
  { 0, 0, 0}, /* _FieldActionElephantTrapSet */
  { 0, 0, 0}, /* _FieldActionInbandTelemetrySet */
  { 0, 0, 0}, /* _FieldActionMacSecModidBase */
  { 0, 0, 0}, /* _FieldActionTimestampTypeSet */
  { 0, 0, 0}, /* _FieldActionTimestampSource0Set */
  { 0, 0, 0} /* _FieldActionTimestampSource1Set */
};

_bcm_field_action_set_t bcm_field_th3_em_action_set[_FieldActionSetCount] = {
    { 0, 0, 0}, /* for the actions which doesnt support aset */
    { 1, 0, PROTECTION_SWITCHING_SET_ENABLEf},
    /* _FieldActionProtectionSwitchingDropOverrideSet = 1 */
    { 10, 0, DLB_ALTERNATE_PATH_CONTROL_SET_ENABLEf},
    /* _FieldActionIfpDlbAlternatePathControlSet = 2 */
    { 2, 0, DLB_ECMP_SET_ENABLEf},
    /* _FieldActionEcmpDlbActionSet =3 */
    { 0, 0, 0},
    /* _FieldActionHgtLagDlbActionSet = 4 */
    { 0, 0, 0},
    /* _FieldActionEcmp2RhActionSet = 5 */
    { 0, 0, 0},
    /* _FieldActionEcmp1RhActionSet = 6 */
    { 0, 0, 0},
    /* _FieldActionLagRhActionSet = 7 */
    { 0, 0, 0},
    /* _FieldActionHgtRhActionSet = 8 */
    { 0, 0, 0}, /* _FieldActionLoopbackProfileSet = 9,*/
    { 0, 0, 0}, /*  _FieldActionExtractionCtrlId = 10,*/
    { 0, 0, 0}, /*  _FieldActionOpaque4Set = 11,*/
    { 0, 0, 0}, /*  _FieldActionOpaque3Set = 12,*/
    { 0, 0, 0}, /*  _FieldActionOpaque2Set = 13,*/
    { 0, 0, 0}, /*  _FieldActionOpaque1Set = 14,*/
    { 0, 0, 0}, /*  _FieldActionTxTimestampInsertionSet = 15,*/
    { 0, 0, 0}, /*  _FieldActionRxTimestampInsertionSet = 16,*/
    { 0, 0, 0}, /*  _FieldActionIgnoreFCOEZoneCheckSet = 17,*/
    { 1, 1, GREEN_TO_PID_SET_ENABLEf},
    /*  _FieldActionGreenToPidSet = 18, */
    { 1, 0, MIRROR_OVERRIDE_SET_ENABLEf},
    /*  _FieldActionMirrorOverrideSet = 19,*/
    { 0, 0, 0},
    /*  _FieldActionNatOverrideSet = 20,*/
    { 1, 0, SFLOW_SET_ENABLEf},
    /*  _FieldActionSflowSet = 21,*/
    { 1, 0, CUT_THRU_OVERRIDE_SET_ENABLEf},
    /*  _FieldActionCutThrOverrideSet = 22,*/
    { 0, 0, 0},
    /* _FieldActionUrpfOverrideSet = 23, */
    { 1, 0, TTL_OVERRIDE_SET_ENABLEf},
    /* _FieldActionTtlOverrideSet = 24,*/
    { 2, 0, LB_CONTROLS_SET_ENABLEf},
    /* _FieldActionLbControlSet = 25,*/
    { 6, 1, DROP_SET_ENABLEf},
    /* _FieldActionDropSet = 26, */
    { 8, 0, CHANGE_CPU_COS_SET_ENABLEf},
    /* _FieldActionChangeCpuCosSet = 27, */
    {15, 0, MIRROR_SET_ENABLEf},
    /* _FieldActionMirrorSet = 28, */
    { 0, 0, 0},
    /* _FieldActionNatSet = 29,*/
    {17, 1, COPY_TO_CPU_SET_ENABLEf},
    /* _FieldActionCopyToCpuSet = 30,*/
    {23, 1, L3SW_CHANGE_L2_SET_ENABLEf},
    /* _FieldActionL3SwChangeL2Set = 31,*/
    {25, 1, EXACT_MATCH_REDIRECT_SET_ENABLEf},
    /*  EM _FieldActionRedirectSet = 32,*/
    {25, 1, COUNTER_SET_ENABLEf},
    /* _FieldActionCounterSet = 33 */
    { 0, 0, 0}, /* _FieldActionChangeEcnSet = 34 */
    { 0, 0, 0}, /* _FieldActionChangePktPriSet = 35 */
    { 0, 0, 0}, /* _FieldActionChangeDscpTosSet = 36 */
    { 0, 0, 0}, /* _FieldActionChangeDropPrecendenceSet = 37 */
    { 0, 0, 0}, /* _FieldActionChangeCosOrIntPriSet = 38 */
    { 0, 0, 0}, /* _FieldActionChangeIntCNSet = 39 */
    { 0, 0, 0}, /* _FieldActionChangeInputPrioritySet = 40 */
    { 1, 0, INSTRUMENTATION_SET_ENABLEf},
    /* _FieldActionInstrumentationSet = 41 */
    { 0, 0, 0}, /* _FieldActionEditCtrlIdSet = 42 */
    { 0, 0, 0}, /* _FieldActionFcoeVsanSet = 43 */
    {16, 1, METER_SET_ENABLEf}, /*_FieldActionMeterSet = 44 */
    { 4, 0, TIMESTAMP_SET_ENABLEf}, /*_FieldActionTimestampInsertionSet = 45 */
    { 8, 0, DELAYED_DROP_SET_ENABLEf}, /* _FieldActionDelayedDropSet = 46 */
    {16, 0, DELAYED_REDIRECT_SET_ENABLEf}, /* _FieldActionDelayedRedirectSet = 47 */
    { 2, 0, DLB_ECMP_MONITOR_SET_ENABLEf}, /* _FieldActionEcmpDlbMonitorSet = 48 */
    { 6, 0, ELEPHANT_TRAP_SET_ENABLEf}, /* _FieldActionElephantTrapSet = 49 */
    { 2, 0, INBAND_TELEMETRY_SET_ENABLEf}, /* _FieldActionInbandTelemetrySet = 50 */
    { 0, 0, 0}, /* _FieldActionMacSecModidBase */
    { 0, 0, 0}, /* _FieldActionTimestampTypeSet */
    { 0, 0, 0}, /* _FieldActionTimestampSource0Set */
    { 0, 0, 0} /* _FieldActionTimestampSource1Set */
};


/* Function declarations */
STATIC int _field_th_stage_quals_ibus_map_init(int unit,
                                             _field_stage_t *stage_fc);

STATIC int _field_th_stage_extractors_init(int unit, _field_stage_t *stage_fc);

STATIC int _field_ser_oper_mode_init(int unit,
                                     int stage_id,
                                     bcm_field_group_oper_mode_t mode);
STATIC int
_field_th_ingress_tcam_policy_clear(int unit, _field_entry_t *f_ent,
                                    int tcam_idx);

extern int
_bcm_field_th_control_get(int unit, _field_control_t *fc,
                          bcm_field_control_t control, uint32 *state);
/*
 * Function: _bcm_field_th_control_set
 *
 * Purpose:
 *     Set control status.
 *
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     control  - (IN) Control element to set.
 *     state    - (IN) State (0/1).
 *
 * Returns:
 *     BCM_E_NONE    - Success
 *     BCM_E_INIT    - BCM unit not initialized
 *     BCM_E_PARAM   - Flag state not valid on device
 */
int
_bcm_field_th_control_set(int unit, _field_control_t *fc,
                          bcm_field_control_t control, uint32 state)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.   */
    uint32              reg_values[2];    /* Register value buffer.     */
    soc_field_t         reg_fields[2];    /* Register fields to modify. */
    int                 field_count = 2;  /* Number of updated fields.  */
    soc_reg_t           ifp_dst_action_reg;

    reg_values[0] = reg_values[1] = (state == TRUE) ? 1: 0;

    if (NULL == fc) {
        return BCM_E_PARAM;
    }

#if defined (BCM_TOMAHAWK3_SUPPORT)
    if (SOC_IS_TOMAHAWK3(unit)) {
        ifp_dst_action_reg = SW_IFP_DST_ACTION_CONTROLr;
    } else
#endif
    {
        ifp_dst_action_reg = SW2_IFP_DST_ACTION_CONTROLr;
    }

    switch (control) {
        case bcmFieldControlRedirectIngressVlanCheck:
            reg_fields[0] = VLAN_CHECK_ENf;
            field_count = 1;
            rv = soc_reg_fields32_modify(unit, ifp_dst_action_reg,
                                         REG_PORT_ANY, field_count,
                                         reg_fields, reg_values);
            break;
        case bcmFieldControlRedirectNonUcastTrunkResolve:
            reg_fields[0] = LAG_RES_ENf;
            reg_fields[1] = HGTRUNK_RES_ENf;
            field_count = 2;
            rv = soc_reg_fields32_modify(unit, ifp_dst_action_reg,
                                         REG_PORT_ANY, field_count,
                                         reg_fields, reg_values);
            break;
        case bcmFieldControlRedirectNonUcastEtherTrunkResolve:
            reg_fields[0] = LAG_RES_ENf;
            field_count = 1;
            rv = soc_reg_fields32_modify(unit, ifp_dst_action_reg,
                                         REG_PORT_ANY, field_count,
                                         reg_fields, reg_values);
            break;
        case bcmFieldControlRedirectNonUcastFabricTrunkResolve:
            if (SOC_IS_TOMAHAWK3(unit)) {
               return BCM_E_UNAVAIL;
            }
            reg_fields[0] = HGTRUNK_RES_ENf;
            field_count = 1;
            rv = soc_reg_fields32_modify(unit, ifp_dst_action_reg,
                                         REG_PORT_ANY, field_count,
                                         reg_fields, reg_values);
            break;
        case bcmFieldControlRedirectExcludeSrcPort:
            reg_fields[0] = HG_SRC_REMOVAL_ENf;
            reg_fields[1] = SRC_REMOVAL_ENf;
            field_count = 2;
            rv = soc_reg_fields32_modify(unit, ifp_dst_action_reg,
                                         REG_PORT_ANY, field_count,
                                         reg_fields, reg_values);
            break;
        case bcmFieldControlRedirectExcludeEtherSrcPort:
            reg_fields[0] = SRC_REMOVAL_ENf;
            field_count = 1;
            rv = soc_reg_fields32_modify(unit, ifp_dst_action_reg,
                                         REG_PORT_ANY, field_count,
                                         reg_fields, reg_values);
            break;
        case bcmFieldControlRedirectExcludeHiGigSrcPort:
            reg_fields[0] = HG_SRC_REMOVAL_ENf;
            field_count = 1;
            rv = soc_reg_fields32_modify(unit, ifp_dst_action_reg,
                                         REG_PORT_ANY, field_count,
                                         reg_fields, reg_values);
            break;
        case bcmFieldControlRedirectPortFloodBlock:
            reg_fields[0] = PORT_BLOCK_ENf;
            field_count = 1;
            rv = soc_reg_fields32_modify(unit, ifp_dst_action_reg,
                                         REG_PORT_ANY, field_count,
                                         reg_fields, reg_values);
            break;
        case bcmFieldControlRedirectVlanFloodBlock:
            reg_fields[0] = VLAN_BLOCK_ENf;
            field_count = 1;
            rv = soc_reg_fields32_modify(unit, ifp_dst_action_reg,
                                         REG_PORT_ANY, field_count,
                                         reg_fields, reg_values);
            break;
        case bcmFieldControlRedirectNextHopExcludeSrcPort:
            reg_fields[0] = SRC_REMOVAL_EN_FOR_REDIRECT_TO_NHIf;
            field_count = 1;
            rv = soc_reg_fields32_modify(unit, ifp_dst_action_reg,
                                         REG_PORT_ANY, field_count,
                                         reg_fields, reg_values);
            break;
        case bcmFieldControlEcmpHashOffset:
            if ((SOC_IS_TOMAHAWKPLUS(unit)) || (SOC_IS_TOMAHAWK3(unit))) {
               return BCM_E_UNAVAIL;
            }
            rv = soc_reg_field32_modify(unit, IFP_ECMP_HASH_CONTROLr,
                                          REG_PORT_ANY,
                                          ECMP_HASH_SALTf, state);
            break;
        case bcmFieldControlEcmpHashUseCrc:
            if ((SOC_IS_TOMAHAWKPLUS(unit)) || (SOC_IS_TOMAHAWK3(unit))) {
               return BCM_E_UNAVAIL;
            }
            rv = soc_reg_field32_modify(unit, IFP_ECMP_HASH_CONTROLr,
                                          REG_PORT_ANY,
                                          USE_CRCf, state);
            break;
        case bcmFieldControlEcmpHashUseUpper5Bits:
            if ((SOC_IS_TOMAHAWKPLUS(unit)) || (SOC_IS_TOMAHAWK3(unit))) {
               return BCM_E_UNAVAIL;
            }
            rv = soc_reg_field32_modify(unit, IFP_ECMP_HASH_CONTROLr,
                                          REG_PORT_ANY,
                                          USE_UPPERf, state);
            break;
        case bcmFieldControlEcmpHashEnable:
            if ((SOC_IS_TOMAHAWKPLUS(unit)) || (SOC_IS_TOMAHAWK3(unit))) {
               return BCM_E_UNAVAIL;
            }
            rv = soc_reg_field32_modify(unit, IFP_ECMP_HASH_CONTROLr,
                                          REG_PORT_ANY,
                                          ENABLEf, state);
            break;

        case bcmFieldControlDlbMonitorIngressRandomSeed:
            if(SOC_REG_IS_VALID(unit, DLB_ECMP_MONITOR_IFP_CONTROLr)) {
                uint32 seed;
                seed = (1 << soc_reg_field_length(unit,
                                DLB_ECMP_MONITOR_IFP_CONTROLr, SEEDf)) - 1;
                if (state >= seed) {
                    return BCM_E_PARAM;
                }
                if (0 == state) {
                    /* Restore to default */
                    BCM_IF_ERROR_RETURN(_bcm_field_th_control_get(unit, fc, control, &seed));
                    if (seed == 0) {
                        return BCM_E_PARAM;
                    }
                }
                rv = WRITE_DLB_ECMP_MONITOR_IFP_CONTROLr(unit, state);
            }
            break;
            case bcmFieldControlGbpSrcMacMcastBitSet:
#if defined(BCM_TRIDENT3_SUPPORT)
            if (SOC_REG_FIELD_VALID(unit, EGR_GBP_CONTROLr,
                                    GBP_SID_DID_CHECK_POLICYf)) {
                if (state > BCM_FIELD_GBP_SRC_ID_EQ_DST_ID) {
                    return BCM_E_PARAM;
                }
                rv = soc_reg_field32_modify(unit, EGR_GBP_CONTROLr,
                                              REG_PORT_ANY,
                                              GBP_SID_DID_CHECK_POLICYf, state);
            }
#endif /* (BCM_TRIDENT3_SUPPORT) */
            break;
        default:
            rv = _bcm_field_control_set(unit, fc, control, state);
    }

    return rv;
}
/*
 * Function: _bcm_field_th_control_get
 *
 * Purpose:
 *     Get control status info.
 *
 * Parameters:
 *     unit     - (IN)  BCM device number.
 *     control  - (IN)  Control element to get.
 *     status   - (OUT) Status of field element.
 *
 * Returns:
 *     BCM_E_UNAVAIL - field control is not available
 *     BCM_E_PARAM   - *state pointing to NULL
 *     BCM_E_NONE    - Success
 */
int
_bcm_field_th_control_get(int unit, _field_control_t *fc,
                          bcm_field_control_t control, uint32 *state)
{

    uint32 reg_val;          /* Register value buffer. */
    int    rv = BCM_E_UNAVAIL;  /* Operation return status.   */
    soc_reg_t           ifp_dst_action_reg;

    if (NULL == state || NULL == fc) {
        return BCM_E_PARAM;
    }

#if defined (BCM_TOMAHAWK3_SUPPORT)
    if (SOC_IS_TOMAHAWK3(unit)) {
        ifp_dst_action_reg = SW_IFP_DST_ACTION_CONTROLr;
    } else
#endif
    {
        ifp_dst_action_reg = SW2_IFP_DST_ACTION_CONTROLr;
    }

    switch (control) {
        case bcmFieldControlRedirectIngressVlanCheck:
#if defined (BCM_TOMAHAWK3_SUPPORT)
            if (SOC_IS_TOMAHAWK3(unit)) {
                rv = READ_SW_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            } else
#endif
            {
                rv = READ_SW2_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            }
            if (BCM_SUCCESS(rv)) {
                *state = soc_reg_field_get(unit,
                                       ifp_dst_action_reg,
                                       reg_val,
                                       VLAN_CHECK_ENf);
            }
            break;
        case bcmFieldControlRedirectNonUcastTrunkResolve:
#if defined (BCM_TOMAHAWK3_SUPPORT)
            if (SOC_IS_TOMAHAWK3(unit)) {
                rv = READ_SW_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            } else
#endif
            {
                rv = READ_SW2_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            }
            if (BCM_SUCCESS(rv)) {
                *state = soc_reg_field_get(unit,
                                       ifp_dst_action_reg,
                                       reg_val,
                                       LAG_RES_ENf);
            }
            break;
        case bcmFieldControlRedirectNonUcastEtherTrunkResolve:
#if defined (BCM_TOMAHAWK3_SUPPORT)
            if (SOC_IS_TOMAHAWK3(unit)) {
                rv = READ_SW_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            } else
#endif
            {
                rv = READ_SW2_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            }
            if (BCM_SUCCESS(rv)) {
                *state = soc_reg_field_get(unit,
                                       ifp_dst_action_reg,
                                       reg_val,
                                       LAG_RES_ENf);
            }
            break;
        case bcmFieldControlRedirectNonUcastFabricTrunkResolve:
            if (SOC_IS_TOMAHAWK3(unit)) {
               return BCM_E_UNAVAIL;
            }
            rv = READ_SW2_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            if (BCM_SUCCESS(rv)) {
                *state = soc_reg_field_get(unit,
                                       ifp_dst_action_reg,
                                       reg_val,
                                       HGTRUNK_RES_ENf);
            }
            break;
        case bcmFieldControlRedirectExcludeSrcPort:
#if defined (BCM_TOMAHAWK3_SUPPORT)
            if (SOC_IS_TOMAHAWK3(unit)) {
                rv = READ_SW_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            } else
#endif
            {
                rv = READ_SW2_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            }
            if (BCM_SUCCESS(rv)) {
                *state = soc_reg_field_get(unit,
                                       ifp_dst_action_reg,
                                       reg_val,
                                       SRC_REMOVAL_ENf);
            }
            break;
        case bcmFieldControlRedirectExcludeEtherSrcPort:
#if defined (BCM_TOMAHAWK3_SUPPORT)
            if (SOC_IS_TOMAHAWK3(unit)) {
                rv = READ_SW_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            } else
#endif
            {
                rv = READ_SW2_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            }
            if (BCM_SUCCESS(rv)) {
                *state = soc_reg_field_get(unit,
                                       ifp_dst_action_reg,
                                       reg_val,
                                       SRC_REMOVAL_ENf);
            }
            break;
        case bcmFieldControlRedirectExcludeHiGigSrcPort:
#if defined (BCM_TOMAHAWK3_SUPPORT)
            if (SOC_IS_TOMAHAWK3(unit)) {
                rv = READ_SW_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            } else
#endif
            {
                rv = READ_SW2_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            }
            if (BCM_SUCCESS(rv)) {
                *state = soc_reg_field_get(unit,
                                       ifp_dst_action_reg,
                                       reg_val,
                                       HG_SRC_REMOVAL_ENf);
            }
            break;
        case bcmFieldControlRedirectPortFloodBlock:
#if defined (BCM_TOMAHAWK3_SUPPORT)
            if (SOC_IS_TOMAHAWK3(unit)) {
                rv = READ_SW_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            } else
#endif
            {
                rv = READ_SW2_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            }
            if (BCM_SUCCESS(rv)) {
                *state = soc_reg_field_get(unit,
                                       ifp_dst_action_reg,
                                       reg_val,
                                       PORT_BLOCK_ENf);
            }
            break;
        case bcmFieldControlRedirectVlanFloodBlock:
#if defined (BCM_TOMAHAWK3_SUPPORT)
            if (SOC_IS_TOMAHAWK3(unit)) {
                rv = READ_SW_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            } else
#endif
            {
                rv = READ_SW2_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            }
            if (BCM_SUCCESS(rv)) {
                *state = soc_reg_field_get(unit,
                                       ifp_dst_action_reg,
                                       reg_val,
                                       VLAN_BLOCK_ENf);
            }
            break;
        case bcmFieldControlRedirectNextHopExcludeSrcPort:
#if defined (BCM_TOMAHAWK3_SUPPORT)
            if (SOC_IS_TOMAHAWK3(unit)) {
                rv = READ_SW_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            } else
#endif
            {
                rv = READ_SW2_IFP_DST_ACTION_CONTROLr(unit, &reg_val);
            }
            if (BCM_SUCCESS(rv)) {
                *state = soc_reg_field_get(unit,
                                       ifp_dst_action_reg,
                                       reg_val,
                                       SRC_REMOVAL_EN_FOR_REDIRECT_TO_NHIf);
            }
            break;
       case bcmFieldControlEcmpHashOffset:
           if ((SOC_IS_TOMAHAWKPLUS(unit)) || (SOC_IS_TOMAHAWK3(unit))) {
               return BCM_E_UNAVAIL;
           }
           rv = READ_IFP_ECMP_HASH_CONTROLr(unit, &reg_val);
           if (BCM_SUCCESS(rv)) {
              *state = soc_reg_field_get(unit, IFP_ECMP_HASH_CONTROLr,
                                             reg_val, ECMP_HASH_SALTf);
           }
           break;
       case bcmFieldControlEcmpHashUseCrc:
           if ((SOC_IS_TOMAHAWKPLUS(unit)) || (SOC_IS_TOMAHAWK3(unit))) {
               return BCM_E_UNAVAIL;
           }
           rv = READ_IFP_ECMP_HASH_CONTROLr(unit, &reg_val);
           if (BCM_SUCCESS(rv)) {
              *state = soc_reg_field_get(unit, IFP_ECMP_HASH_CONTROLr,
                                             reg_val, USE_CRCf);
           }
           break;
       case bcmFieldControlEcmpHashUseUpper5Bits:
           if ((SOC_IS_TOMAHAWKPLUS(unit)) || (SOC_IS_TOMAHAWK3(unit))) {
               return BCM_E_UNAVAIL;
           }
           rv = READ_IFP_ECMP_HASH_CONTROLr(unit, &reg_val);
           if (BCM_SUCCESS(rv)) {
              *state = soc_reg_field_get(unit, IFP_ECMP_HASH_CONTROLr,
                                             reg_val, USE_UPPERf);
           }
           break;
       case bcmFieldControlEcmpHashEnable:
           if ((SOC_IS_TOMAHAWKPLUS(unit)) || (SOC_IS_TOMAHAWK3(unit))) {
               return BCM_E_UNAVAIL;
           }
           rv = READ_IFP_ECMP_HASH_CONTROLr(unit, &reg_val);
           if (BCM_SUCCESS(rv)) {
              *state = soc_reg_field_get(unit, IFP_ECMP_HASH_CONTROLr,
                                             reg_val, ENABLEf);
           }
           break;

    case bcmFieldControlDlbMonitorIngressRandomSeed:
           if(SOC_REG_IS_VALID(unit, DLB_ECMP_MONITOR_IFP_CONTROLr)) {
               rv = READ_DLB_ECMP_MONITOR_IFP_CONTROLr(unit, &reg_val);
               if (BCM_SUCCESS(rv)) {
                   *state = soc_reg_field_get(unit, DLB_ECMP_MONITOR_IFP_CONTROLr,
                                                   reg_val, SEEDf);
               }
           }
           break;
    case bcmFieldControlGbpSrcMacMcastBitSet:
#if defined(BCM_TRIDENT3_SUPPORT)
           if (SOC_REG_FIELD_VALID(unit, EGR_GBP_CONTROLr,
                                   GBP_SID_DID_CHECK_POLICYf)) {
               rv = READ_EGR_GBP_CONTROLr(unit, &reg_val);
               if (BCM_SUCCESS(rv)) {
                   *state = soc_reg_field_get(unit, EGR_GBP_CONTROLr,
                                                   reg_val, GBP_SID_DID_CHECK_POLICYf);
               }
           }
#endif /* (BCM_TRIDENT3_SUPPORT) */
           break;
       default:
            rv = _bcm_field_control_get(unit, fc, control, state);
    }

    return rv;

}
/*
 * Function:
 *    _field_th_instance_counters_deinit
 *
 * Purpose:
 *    Free instance counter usage bitmap resource.
 *
 * Parameters:
 *    unit     - (IN) BCM device number.
 *    stage_fc - (IN/OUT) Stage field control structure.
 *    inst     - (IN) Device stage instance information.
 *
 * Returns:
 *    BCM_E_PARAM  - Invalid instance number.
 *    BCM_E_NONE   - Success.
 */
STATIC int
_field_th_instance_counters_deinit(int unit, _field_stage_t *stage_fc, int inst)
{
    int slice; /* Slice iterator. */

    /* Input parameter check. */
    if (NULL == stage_fc) {
        return (BCM_E_NONE);
    }

    /* Validate instance value. */
    if (inst < 0 || inst >= stage_fc->num_instances) {
        return (BCM_E_PARAM);
    }

    /* Make sure slices array is initialized.*/
    if (NULL == stage_fc->slices[inst]) {
        return (BCM_E_NONE);
    }

    /* Destroy 64 bit counters. */
    _bcm_field_counter_collect_deinit(unit, stage_fc);

    if (_BCM_FIELD_STAGE_EGRESS == stage_fc->stage_id) {
        if (NULL != stage_fc->slices[inst][0].counter_bmp.w) {
            sal_free(stage_fc->slices[inst][0].counter_bmp.w);
        }

        for (slice = 0; slice < stage_fc->tcam_slices; slice++) {
            stage_fc->slices[inst][slice].counter_bmp.w = NULL;
        }
    }

    return (BCM_E_NONE);
}

_field_counter_hw_mode_t th_ingress_cntr_hw_mode_tbl[] = {
    /* (R_COUNTER_OFS = 0, Y_COUNTER_OFS = 0, G_COUNTER_OFS = 1) */
    { BIT(bcmFieldStatGreenPackets) | BIT(bcmFieldStatGreenBytes),
      1, _bcmFieldStatColorGreen
    },
    /* (R_COUNTER_OFS = 0, Y_COUNTER_OFS = 1, G_COUNTER_OFS = 0) */
    { BIT(bcmFieldStatYellowPackets) | BIT(bcmFieldStatYellowBytes),
      1, _bcmFieldStatColorYellow
    },
    /* (R_COUNTER_OFS = 0, Y_COUNTER_OFS = 1, G_COUNTER_OFS = 1) */
    { BIT(bcmFieldStatNotRedPackets) | BIT(bcmFieldStatNotRedBytes),
      1, _bcmFieldStatColorNotRed
    },
    /* (R_COUNTER_OFS = 0, Y_COUNTER_OFS = 2, G_COUNTER_OFS = 1) */
    { BIT(bcmFieldStatYellowPackets) | BIT(bcmFieldStatYellowBytes)
      | BIT(bcmFieldStatGreenPackets) | BIT(bcmFieldStatGreenBytes)
      | BIT(bcmFieldStatNotRedPackets) | BIT(bcmFieldStatNotRedBytes),
      2, _bcmFieldStatColorGreenYellow
    },
    /* (R_COUNTER_OFS = 1, Y_COUNTER_OFS = 0, G_COUNTER_OFS = 0) */
    { BIT(bcmFieldStatRedPackets) | BIT(bcmFieldStatRedBytes),
      1, _bcmFieldStatColorRed
    },
    /* (R_COUNTER_OFS = 1, Y_COUNTER_OFS = 0, G_COUNTER_OFS = 1) */
    { BIT(bcmFieldStatNotYellowPackets) | BIT(bcmFieldStatNotYellowBytes),
      1, _bcmFieldStatColorNotYellow
    },
    /* (R_COUNTER_OFS = 1, Y_COUNTER_OFS = 0, G_COUNTER_OFS = 2) */
    { BIT(bcmFieldStatRedPackets) | BIT(bcmFieldStatRedBytes)
      | BIT(bcmFieldStatGreenPackets) | BIT(bcmFieldStatGreenBytes)
      | BIT(bcmFieldStatNotYellowPackets) | BIT(bcmFieldStatNotYellowBytes),
      2, _bcmFieldStatColorGreenRed
    },
    /* (R_COUNTER_OFS = 1, Y_COUNTER_OFS = 1, G_COUNTER_OFS = 0) */
    { BIT(bcmFieldStatNotGreenPackets) | BIT(bcmFieldStatNotGreenBytes),
      1, _bcmFieldStatColorNotGreen
    },
    /* (R_COUNTER_OFS = 1, Y_COUNTER_OFS = 1, G_COUNTER_OFS = 1) */
    { BIT(bcmFieldStatPackets) | BIT(bcmFieldStatBytes),
      1, _bcmFieldStatColorNoColor
    },
    /* (R_COUNTER_OFS = 1, Y_COUNTER_OFS = 1, G_COUNTER_OFS = 2) */
    { BIT(bcmFieldStatNotGreenPackets) | BIT(bcmFieldStatNotGreenBytes)
      | BIT(bcmFieldStatGreenPackets) | BIT(bcmFieldStatGreenBytes)
      | BIT(bcmFieldStatPackets) | BIT(bcmFieldStatBytes),
      2, _bcmFieldStatColorGreenNotGreen
    },
    /* (R_COUNTER_OFS = 1, Y_COUNTER_OFS = 2, G_COUNTER_OFS = 0) */
    { BIT(bcmFieldStatRedPackets) | BIT(bcmFieldStatRedBytes)
      | BIT(bcmFieldStatYellowPackets) | BIT(bcmFieldStatYellowBytes)
      | BIT(bcmFieldStatNotGreenPackets) | BIT(bcmFieldStatNotGreenBytes),
      2, _bcmFieldStatColorYellowRed
    },
    /* (R_COUNTER_OFS = 1, Y_COUNTER_OFS = 2, G_COUNTER_OFS = 1) */
    { BIT(bcmFieldStatNotYellowPackets) | BIT(bcmFieldStatNotYellowBytes)
      | BIT(bcmFieldStatYellowPackets) | BIT(bcmFieldStatYellowBytes)
      | BIT(bcmFieldStatPackets) | BIT(bcmFieldStatBytes),
      2, _bcmFieldStatColorYellowNotYellow
    },
    /* (R_COUNTER_OFS = 1, Y_COUNTER_OFS = 2, G_COUNTER_OFS = 2) */
    { BIT(bcmFieldStatRedPackets) | BIT(bcmFieldStatRedBytes)
      | BIT(bcmFieldStatNotRedPackets) | BIT(bcmFieldStatNotRedBytes)
      | BIT(bcmFieldStatPackets) | BIT(bcmFieldStatBytes),
      2, _bcmFieldStatColorRedNotRed
    },
    /* (R_COUNTER_OFS = 1, Y_COUNTER_OFS = 2, G_COUNTER_OFS = 3) */
    { BIT(bcmFieldStatRedPackets) | BIT(bcmFieldStatRedBytes)
      | BIT(bcmFieldStatYellowPackets) | BIT(bcmFieldStatYellowBytes)
      | BIT(bcmFieldStatGreenPackets) | BIT(bcmFieldStatGreenBytes)
      | BIT(bcmFieldStatNotRedPackets) | BIT(bcmFieldStatNotRedBytes)
      | BIT(bcmFieldStatNotYellowPackets) | BIT(bcmFieldStatNotYellowBytes)
      | BIT(bcmFieldStatNotGreenPackets) | BIT(bcmFieldStatNotGreenBytes)
      | BIT(bcmFieldStatPackets) | BIT(bcmFieldStatBytes),
      3, _bcmFieldStatColorGreenYellowRed
    }
};

int th_ingress_cntr_hw_mode_tbl_size = COUNTOF(th_ingress_cntr_hw_mode_tbl);

#ifdef BCM_TOMAHAWK_SUPPORT
STATIC int
_field_stage_meter_pool_clean(int unit, _field_stage_id_t stage_id,
                              int pipe, int pool) {

    _field_stage_t *stage_ptr = NULL;
    int meter_pairs_per_pool = 0;
    int size = 0;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        meter_pairs_per_pool = BCM_FIELD_INGRESS_TD3_NUM_METER_PAIRS_PER_POOL;
    } else {
        meter_pairs_per_pool = BCM_FIELD_INGRESS_TH_NUM_METER_PAIRS_PER_POOL;
    }

    /* Initialize number of meter per pool.*/
    size = SHR_BITALLOCSIZE(meter_pairs_per_pool << 1);

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                        stage_id , &stage_ptr));

    sal_memset(stage_ptr->meter_pool[pipe][pool]->meter_bmp.w,
               0, size);
    stage_ptr->meter_pool[pipe][pool]->level = 0;
    stage_ptr->meter_pool[pipe][pool]->slice_id = 0;
    stage_ptr->meter_pool[pipe][pool]->size = 0;
    stage_ptr->meter_pool[pipe][pool]->pool_size = 0;
    stage_ptr->meter_pool[pipe][pool]->free_meters = 0;
    stage_ptr->meter_pool[pipe][pool]->num_meter_pairs = 0;

    return BCM_E_NONE;

}

STATIC int
_field_stage_meter_pool_copy(int unit,  _field_stage_id_t stage_id_from,
                            _field_stage_t *stage_ptr_to, int pipe,
                             int pool) {

    _field_stage_t *stage_ptr_from = NULL;
    int meter_pairs_per_pool = 0;
    int size = 0;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        meter_pairs_per_pool = BCM_FIELD_INGRESS_TD3_NUM_METER_PAIRS_PER_POOL;
    } else {
        meter_pairs_per_pool = BCM_FIELD_INGRESS_TH_NUM_METER_PAIRS_PER_POOL;
    }

    /* Initialize number of meter per pool.*/
    size = SHR_BITALLOCSIZE(meter_pairs_per_pool << 1);

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                        stage_id_from , &stage_ptr_from));

    sal_memcpy(stage_ptr_to->meter_pool[pipe][pool]->meter_bmp.w,
               stage_ptr_from->meter_pool[pipe][pool]->meter_bmp.w,
               size);
    stage_ptr_to->meter_pool[pipe][pool]->level =
     stage_ptr_from->meter_pool[pipe][pool]->level;
    stage_ptr_to->meter_pool[pipe][pool]->slice_id =
     stage_ptr_from->meter_pool[pipe][pool]->slice_id;
    stage_ptr_to->meter_pool[pipe][pool]->size =
     stage_ptr_from->meter_pool[pipe][pool]->size;
    stage_ptr_to->meter_pool[pipe][pool]->pool_size =
     stage_ptr_from->meter_pool[pipe][pool]->pool_size;
    stage_ptr_to->meter_pool[pipe][pool]->free_meters =
     stage_ptr_from->meter_pool[pipe][pool]->free_meters;
    stage_ptr_to->meter_pool[pipe][pool]->num_meter_pairs =
     stage_ptr_from->meter_pool[pipe][pool]->num_meter_pairs;

    return BCM_E_NONE;

 }
#endif

/*
 * Function:
 *    _field_th_instance_global_meters_deinit
 *
 * Purpose:
 *    Free instance meters usage bitmap.
 *
 * Parameters:
 *    unit     - (IN) BCM device number.
 *    stage_fc - (IN/OUT) Stage field control structure.
 *    inst     - (IN) Device stage instance information.
 *
 * Returns:
 *    BCM_E_PARAM  - Invalid instance number.
 *    BCM_E_NONE   - Success.
 */
STATIC int
_field_th_instance_global_meters_deinit(int unit, _field_stage_t *stage_fc, int inst)
{
    int pipe = -1;
    int pool = -1;
    int rv = 0;
    _field_meter_pool_t *mp; /* Meter pool structure pointer. */
    _field_control_t *fc; /* Field Control Structure */

    for (pipe = 0; pipe < _FP_MAX_NUM_PIPES; pipe++) {

       if ((stage_fc->oper_mode == bcmFieldGroupOperModePipeLocal)
            && (pipe != inst)) {
            continue;
       }
       for (pool = 0; pool < stage_fc->num_meter_pools; pool++) {
            /* Get the pipeance meter pool structure pointer. */
            mp = stage_fc->meter_pool[pipe][pool];
            if (NULL != mp) {
                if (NULL != mp->meter_bmp.w) {
                    sal_free(mp->meter_bmp.w);
                }
                sal_free(mp);
                stage_fc->meter_pool[pipe][pool] = NULL;
            }
        }

        /* Get field control structure. */
        BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

        for (pool = 0; pool < _FIELD_MAX_METER_POOLS; pool++) {

            if ((stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) &&
                (fc->ifp_em_meter_in_use[pipe][pool] == 
                 BCM_FIELD_METER_POOL_USED_BY_IFP)) {
                 /* Clean up meter pools used by IFP */
                 rv = (_field_stage_meter_pool_clean
                                     (unit, _BCM_FIELD_STAGE_EXACTMATCH,
                                     pipe, pool));
                 if (BCM_SUCCESS(rv) && (!(SOC_WARM_BOOT(unit)))) {
                     fc->ifp_em_meter_in_use[pipe][pool] =
                     BCM_FIELD_METER_POOL_USED_BY_NONE;
                 } else {
                     return rv;
                 }
            } else if ((stage_fc->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) &&
                 (fc->ifp_em_meter_in_use[pipe][pool] == 
                 BCM_FIELD_METER_POOL_USED_BY_EM)) {
                 /* Clean up meter pools used by EM */
                 rv = (_field_stage_meter_pool_clean
                                    (unit, _BCM_FIELD_STAGE_INGRESS,
                                     pipe, pool));
                 if (BCM_SUCCESS(rv) && (!(SOC_WARM_BOOT(unit)))) {
                     fc->ifp_em_meter_in_use[pipe][pool] =
                     BCM_FIELD_METER_POOL_USED_BY_NONE;
                 } else {
                     return rv;
                 }
            }
        }
     }
     return (BCM_E_NONE);
    
}


/*
 * Function:
 *    _field_th_instance_meters_deinit
 *
 * Purpose:
 *    Free instance meters usage bitmap.
 *
 * Parameters:
 *    unit     - (IN) BCM device number.
 *    stage_fc - (IN/OUT) Stage field control structure.
 *    inst     - (IN) Device stage instance information.
 *
 * Returns:
 *    BCM_E_PARAM  - Invalid instance number.
 *    BCM_E_NONE   - Success.
 */
STATIC int
_field_th_instance_meters_deinit(int unit, _field_stage_t *stage_fc, int inst)
{
    int slice; /* Slice iterator. */
    _field_slice_t *fs; /* Slice configuration structure. */

    /* Input parameter check. */
    if (NULL == stage_fc) {
        return (BCM_E_NONE);
    }

    /* Validate instance value. */
    if (inst < 0 || inst >= stage_fc->num_instances) {
        return (BCM_E_PARAM);
    }

    /* Make sure slices array is initialized.*/
    if (NULL == stage_fc->slices[inst]) {
        return (BCM_E_NONE);
    }

    /* Free IFP meter pools belonging to instance. */
    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        return (_field_th_instance_global_meters_deinit(unit,
                                                        stage_fc,
                                                        inst));
    }

    /* Free EFP meter usage bitmap resources belonging to an instance. */
    for (slice = 0; slice < stage_fc->tcam_slices; slice++) {
        fs = stage_fc->slices[inst] + slice;
        if (NULL != fs->meter_bmp.w) {
            sal_free(fs->meter_bmp.w);
        }
        fs->meter_bmp.w = NULL;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_instance_entries_free
 *
 * Purpose:
 *    Free entries array for all slices in an instance.
 *
 * Parameters:
 *    unit     - (IN) BCM device number.
 *    stage_fc - (IN) Stage field control structure.
 *    inst - (IN) Device stage instance number information.
 *
 * Returns:
 *    BCM_E_PARAM - Device stage control information is NULL.
 *    BCM_E_NONE  - Success.
 */
STATIC int
_field_th_instance_entries_free(int unit,
                                _field_stage_t *stage_fc,
                                int inst)
{
    _field_slice_t *fs; /* Field Slice Pointer. */
    int slice; /* Slice iterator. */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Validate instance value. */
    if (inst < 0 || inst >= stage_fc->num_instances) {
        return (BCM_E_PARAM);
    }

    /* Deallocate instance entry pointers. */
    for (slice = 0; slice < stage_fc->tcam_slices; slice++) {
        fs = stage_fc->slices[inst] + slice;
        if (NULL != fs->entries) {
            sal_free(fs->entries);
            fs->entries = NULL;
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_instance_prio_mgmt_deinit
 *
 * Purpose:
 *    Free memory used by priority management in an instance.
 *
 * Parameters:
 *    unit     - (IN) BCM device number.
 *    stage_fc - (IN) Stage field control structure.
 *    inst     - (IN) Device stage instance number information.
 *
 * Returns:
 *     BCM_E_PARAM - Stage control null or invalid instance.
 *     BCM_E_NONE - Success.
 */
STATIC int
_field_th_instance_prio_mgmt_deinit(int unit,
                                    _field_stage_t *stage_fc,
                                    int inst)
{
    int slice; /* Slice iterator. */
    _field_prio_mgmt_t *prio1, *prio2;

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Validate instance value. */
    if (inst < 0 || inst >= stage_fc->num_instances) {
        return (BCM_E_PARAM);
    }

    if (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) {
        /* To be handled as part of IFP Group implementation. */
        return (BCM_E_NONE);
    }

    for (slice = 0; slice < stage_fc->tcam_slices; slice++) {
        prio1 = stage_fc->slices[inst][slice].prio_mgmt;
        while (prio1 != NULL) {
            prio2 = prio1->next;
            sal_free(prio1);
            prio1 = prio2;
        }
        stage_fc->slices[inst][slice].prio_mgmt = NULL;
    }

    return (BCM_E_NONE);
}
/*
 * Function:
 *     _bcm_field_th_eh_mask_profile_hw_alloc
 *
 * Purpose:
 *     Allocate hw resources for HiGiG2 extended header mask.
 *
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     f_ent      - (IN) Field entry control structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_eh_mask_profile_hw_alloc(int unit, _field_entry_t *f_ent)
{
    int rv = BCM_E_NONE; /* Operational Status. */
    int ref_count; /* eh mask profile reference count. */
    _field_action_t *fa; /* Field actions pointer */
    void *entry_ptr; /* pointer to EH_MASK_PROFILE table entry. */
    _field_control_t *fc = NULL; /* Field Control Structure */

    /* parameters check. */
    if (NULL == f_ent) {
        return BCM_E_PARAM;
    }

    /* HiGiG2 extended header mask profile table isonly valid for IFP. */
    if (_BCM_FIELD_STAGE_INGRESS != f_ent->group->stage_id) {
        return BCM_E_NONE;
    }

    /* Go through all the actions in field entry. */
    for (fa = f_ent->actions;
         NULL != fa && _FP_ACTION_VALID & fa->flags;
         fa = fa->next) {

        if (bcmFieldActionFabricEHAddOrUpdate == fa->action) {

            /*
             * Store previous hardware index value in old_index.
             */
            fa->old_index = fa->hw_index;

            /* Get field control structure. */
            rv = _field_control_get(unit, &fc);
            BCM_IF_ERROR_RETURN(rv);

            /* EH mask will come as action parameter 1 for which
             * profile entry needs to be created. */
            entry_ptr = fa->param + 1;

            rv = soc_profile_mem_add(unit,
                                    &fc->eh_mask_profile,
                                    &entry_ptr, 1,
                                    (uint32 *)&fa->hw_index);
            if ((BCM_E_RESOURCE == rv) &&
                (_FP_INVALID_INDEX != fa->old_index)) {
                /* Destroy old profile ONLY
                 * if it is not used by other entries.
                 */

                rv = soc_profile_mem_ref_count_get(unit,
                                                   &fc->eh_mask_profile,
                                                   fa->old_index, &ref_count);

                BCM_IF_ERROR_RETURN(rv);

                if (ref_count > 1) {
                    return (BCM_E_RESOURCE);
                }

                rv = soc_profile_mem_delete(unit,
                                            &fc->eh_mask_profile,
                                            fa->old_index);
                BCM_IF_ERROR_RETURN(rv);

                /* Destroy old profile is no longer required. */
                fa->old_index = _FP_INVALID_INDEX;

                /* Reallocate profile for new action. */
                rv = soc_profile_mem_add(unit,
                                         &fc->eh_mask_profile,
                                         &entry_ptr, 1,
                                         (uint32*)&fa->hw_index);
                BCM_IF_ERROR_RETURN(rv);
            }
            break;
        }
    }

    return rv;
}
/*
 * Function:
 *     _bcm_field_th_eh_mask_profile_hw_free
 *
 * Purpose:
 *     Free hw resources created for HiGiG2 extended header mask used in
 *     bcmFieldActionFabricEHAddOrUpdate action.
 *
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     f_ent      - (IN) field entry control.
 *     fflags     - (IN) field entry action flags to free the h/w resources.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_eh_mask_profile_hw_free(int unit,
                                      _field_entry_t *f_ent, uint32 flags)
{
    int rv = BCM_E_NONE; /*  Operational Status */
    _field_action_t *fa;   /* Field actions pointer */
    _field_control_t *fc = NULL; /* Field Control Structure */

    /* Parameters check. */
    if (NULL == f_ent) {
        return BCM_E_PARAM;
    }

    /* HiGiG2 extended header mask profile table isonly valid for IFP. */
    if (_BCM_FIELD_STAGE_INGRESS != f_ent->group->stage_id) {
        return BCM_E_NONE;
    }

    /* Go through all actions in the entry. */
    for (fa = f_ent->actions; NULL != fa; fa = fa->next) {
        /* Clear h/w resource only if the action is
         * bcmFieldActionFabricEHAddOrUpdate */
        if (bcmFieldActionFabricEHAddOrUpdate == fa->action) {

            /* Get field control structure. */
            rv = _field_control_get(unit, &fc);
            BCM_IF_ERROR_RETURN(rv);

            /* Free current resources. */
            if ((flags & _FP_ACTION_RESOURCE_FREE) &&
                (_FP_INVALID_INDEX != fa->hw_index)) {
                rv = soc_profile_mem_delete(unit,
                                            &fc->eh_mask_profile,
                                            fa->hw_index);
                BCM_IF_ERROR_RETURN(rv);
                fa->hw_index = _FP_INVALID_INDEX;
            }

            /* Free Old resources. */
            if ((flags & _FP_ACTION_OLD_RESOURCE_FREE) &&
                (_FP_INVALID_INDEX != fa->old_index)) {
                rv = soc_profile_mem_delete(unit,
                                            &fc->eh_mask_profile,
                                            fa->old_index);
                BCM_IF_ERROR_RETURN(rv);
                fa->old_index = _FP_INVALID_INDEX;
            }
            break;
        }
    }

    return rv;
}
/*
 * Function:
 *     _bcm_field_th_data_qualifier_hw_alloc
 *
 * Purpose:
 *     Allocate hw resources for data qualifier installation
 *
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     stage_fc   - (IN) Stage field control.
 *     f_dq       - (IN) Field data qualifier descriptor.
 * Returns:
 *     BCM_E_XXX
 */

int
_bcm_field_th_data_qualifier_hw_alloc(int unit,
                                      _field_stage_t *stage_fc,
                                      _field_data_qualifier_t *f_dq)
{
    int         idx;                            /* Data qualifier word iterator.            */
    int         elem_count;                     /* Number of elements allocated.            */
    int         temp_elem_count = 0;            /* Number of elements allocated.            */
    uint32      *usage_bmap;                    /* Offset usage bitmap.                     */
    SHR_BITDCL  bit16_chunks_free;              /* Bitmap of free 16 bit chunks             */
    SHR_BITDCL  bit32_chunks_free;              /* Bitmap of free 32 bit chunks             */
    SHR_BITDCL  bit32_chunks_free_partially;    /* Bitmap of 32 bit chunks free partially   */

    /* Input parameters check. */
    if ((NULL == f_dq) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

     memset(&bit16_chunks_free, 0x0, sizeof(bit16_chunks_free));
     memset(&bit32_chunks_free, 0x0, sizeof(bit32_chunks_free));
     memset(&bit32_chunks_free_partially, 0x0, sizeof(bit32_chunks_free_partially));

    elem_count = 0;
    /* coverity[assign]: FALSE*/
    usage_bmap = &stage_fc->data_ctrl->usage_bmap;

    /* Loop through the usage_bmap and calculate the number of elements
     * which are free to be allocated*/
    for (idx = 0; idx <= 15; idx++) {
        if (0 == ((*usage_bmap) & (1 << idx))) {
            elem_count++;
        }
    }

    /* Loop through the usage_bmap and identify which of the 16_bit(Chunks 0,1,8,9)
     * chunks are free to be allocated and set the corresponding idx in
     * bit16_chunks_free*/

    for (idx =0; idx <= 15; idx++) {
        if (idx == 0x0 || idx == 0x1 || idx == 0x8 || idx == 0x9) {
            if (SHR_BITGET(usage_bmap, idx) == 0) {
                /* coverity[ptr_arith] we check only from 0 to 15 idx and
                 * there are only 16 elements in UDF currently*/
                 SHR_BITSET(&bit16_chunks_free, idx);
            }
        }
    }

    /* Loop through the usage_bmap and identify which of the 32_bit chunks (Chunks
     * other than 0,1,8,9) are free to be allocated. For a 32 bit chunk to be free fully
     * both elems in idx and idx+1 should be free. If either one of them is free, then
     * it is taken as a partially free 32 bit chunk*/

    for (idx =0; idx < 15; idx += 2) {
        if (idx != 0x0 && idx != 0x1 && idx != 0x8 && idx != 0x9) {
            if ((SHR_BITGET(usage_bmap, idx) == 0) &&
                (SHR_BITGET(usage_bmap, idx + 1) == 0)) {
                /* coverity[ptr_arith] we check only from 0 to 15 idx and
                 * there are only 16 elements in UDF currently*/
                 SHR_BITSET(&bit32_chunks_free, idx);
                /* coverity[ptr_arith] we check only from 0 to 15 idx and
                 * there are only 16 elements in UDF currently*/
                 SHR_BITSET(&bit32_chunks_free, (idx+1));
            } else if (SHR_BITGET(usage_bmap, idx) == 0) {
                /* coverity[ptr_arith] we check only from 0 to 15 idx and
                 * there are only 16 elements in UDF currently*/
                SHR_BITSET(&bit32_chunks_free_partially, idx);
            } else if (SHR_BITGET(usage_bmap, idx + 1) == 0) {
                /* coverity[ptr_arith] we check only from 0 to 15 idx and
                 * there are only 16 elements in UDF currently*/
                SHR_BITSET(&bit32_chunks_free_partially, (idx+1));
            }
        }
    }

    /* Check whether the requested elem count is available. Only if the count
     * requested can be allocated, proceed. */
    if (elem_count >= f_dq->elem_count) {

        if (1 == f_dq->elem_count) {

            /*Only UDF2.4 through UDF2.7 chunks are specific to Flex Hash Rtag7.
             *Hence only the data qualifiers - Data8 and Data9 can be allocated for
             *Flex Hash. If only one element is requested, the order
             *of allocation is as follows:
             * 1. If any 32 bit chunk is partially free, allocate it.
             * 2. If any 32 bit chunk is free as a whole, allocate it. */

            if (f_dq->flags == BCM_FIELD_DATA_QUALIFIER_OFFSET_FLEX_HASH) {
                for (idx = 12; idx <= 15; idx++) {
                    if (0 != ((bit32_chunks_free_partially) & (1 << idx))) {
                        f_dq->hw_bmap |= (1 << idx);
                        (*usage_bmap) |= (1 << idx);
                         return BCM_E_NONE;
                    }
                }

                for (idx = 12; idx <= 15; idx++) {
                    if (0 != ((bit32_chunks_free) & (1 << idx))) {
                        f_dq->hw_bmap |= (1 << idx);
                        (*usage_bmap) |= (1 << idx);
                        return BCM_E_NONE;
                    }
                }
                return BCM_E_RESOURCE;
            }

            /*If only one element is requested, then the order of allocation is as follows:
             * 1. If any 16_bit chunk is free, allocate it.
             * 2. Else If any 32 bit chunk is partially free, allocate it.
             * 3. Else If any 32 bit chunk is free as a whole, allocate it.
             * (UDF2.4 thro UDF2.7 chunks are specific to RTAG7). Hence, in  all the above
             * cases, give first preference to chunks other than those used for RTAGS.
             */

            for (idx = 0; idx <= 15; idx++) {
                 if (0 != ((bit16_chunks_free) & (1 << idx))) {
                     f_dq->hw_bmap |= (1 << idx);
                     (*usage_bmap) |= (1 << idx);
                     return BCM_E_NONE;
                 }

            }

            for (idx = 0; idx <= 11; idx++) {
                 if (0 != ((bit32_chunks_free_partially) & (1 << idx))) {
                     f_dq->hw_bmap |= (1 << idx);
                     (*usage_bmap) |= (1 << idx);
                     return BCM_E_NONE;
                 }
            }

            for (idx = 0; idx <= 11; idx++) {
                 if (0 != ((bit32_chunks_free) & (1 << idx))) {
                     f_dq->hw_bmap |= (1 << idx);
                     (*usage_bmap) |= (1 << idx);
                     return BCM_E_NONE;
                 }
            }

            for (idx = 12; idx <= 15; idx++) {
                 if (0 != ((bit32_chunks_free_partially) & (1 << idx))) {
                     f_dq->hw_bmap |= (1 << idx);
                     (*usage_bmap) |= (1 << idx);
                     return BCM_E_NONE;
                 }
            }

            for (idx = 12; idx <= 15; idx++) {
                 if (0 != ((bit32_chunks_free) & (1 << idx))) {
                     f_dq->hw_bmap |= (1 << idx);
                     (*usage_bmap) |= (1 << idx);
                     return BCM_E_NONE;
                 }
            }

        } else {

            temp_elem_count = f_dq->elem_count;

            /*Only UDF2.4 through UDF2.7 chunks are specific to Flex Hash Rtag7.
             *Hence only the data qualifiers - Data8 and Data9 can be allocated for
             *Flex Hash. */

            if (f_dq->flags == BCM_FIELD_DATA_QUALIFIER_OFFSET_FLEX_HASH) {
            /*If more than one element is requested, then the order of allocation is as follows:
             * Save elem_count requested in temp_elem_count and keep decreasing it as we allocate
             *1. Until temp_elem_count is not 1, allocate 32_bit chunks as much as possible
             *2. If more chunks are needed, allocate from 32_bit chunks partially free
             *3. If more chunks are needed, allocate partially from 32_bit chunks fully free
             */
                for (idx = 12; idx < 15; idx += 2) {
                    if (1 != temp_elem_count) {
                        if ((0 != ((bit32_chunks_free) & (1 << idx))) &&
                            (0 != ((bit32_chunks_free) & (1 << (idx + 1))))) {
                            f_dq->hw_bmap |= (1 << idx);
                            (*usage_bmap) |= (1 << idx);
                            f_dq->hw_bmap |= (1 << (idx + 1));
                            (*usage_bmap) |= (1 << (idx + 1));
                            SHR_BITCLR(&bit32_chunks_free, idx);
                            SHR_BITCLR(&bit32_chunks_free, idx+1);
                            temp_elem_count = temp_elem_count - 2;
                        }
                    }

                    if (0 == temp_elem_count) {
                        return BCM_E_NONE;
                    }
                }

                for (idx = 12; idx <= 15; idx++) {
                    if (0 != ((bit32_chunks_free_partially) & (1 << idx))) {
                        f_dq->hw_bmap |= (1 << idx);
                        (*usage_bmap) |= (1 << idx);
                        temp_elem_count = temp_elem_count - 1;
                    }

                    if (0 == temp_elem_count) {
                        return BCM_E_NONE;
                    }
                }

                for (idx = 12; idx <= 15; idx++) {
                    if (0 != ((bit32_chunks_free) & (1 << idx))) {
                        f_dq->hw_bmap |= (1 << idx);
                        (*usage_bmap) |= (1 << idx);
                        temp_elem_count = temp_elem_count - 1;
                    }

                    if (0 == temp_elem_count) {
                        return BCM_E_NONE;
                    }
                }
                return BCM_E_RESOURCE;
            }

            /*If more than one element is requested, then the order of allocation is as follows:
             * Save elem_count requested in temp_elem_count and keep decreasing it as we allocate
             *1. Until temp_elem_count is not 1, allocate 32_bit chunks as much as possible
             *2. If more chunks are needed, allocate from 16_bit chunks
             *3. If more chunks are needed, allocate from 32_bit chunks partially free
             *4. If more chunks are needed, allocate partially from 32_bit chunks fully free
             */

            for (idx = 0; idx < 11; idx += 2) {
                if (1 != temp_elem_count) {
                    if ((0 != ((bit32_chunks_free) & (1 << idx))) &&
                        (0 != ((bit32_chunks_free) & (1 << (idx + 1))))) {
                        f_dq->hw_bmap |= (1 << idx);
                        (*usage_bmap) |= (1 << idx);
                        f_dq->hw_bmap |= (1 << (idx + 1));
                        (*usage_bmap) |= (1 << (idx + 1));
                        SHR_BITCLR(&bit32_chunks_free, idx);
                        SHR_BITCLR(&bit32_chunks_free, idx+1);
                        temp_elem_count = temp_elem_count - 2;
                    }

                    if (0 == temp_elem_count) {
                        return BCM_E_NONE;
                    }
                }
            }

            for (idx = 0; idx <= 15; idx++) {
                if (0 != ((bit16_chunks_free) & (1 << idx))) {
                    f_dq->hw_bmap |= (1 << idx);
                    (*usage_bmap) |= (1 << idx);
                    temp_elem_count = temp_elem_count - 1;
                }

                if (0 == temp_elem_count) {
                    return BCM_E_NONE;
                }
            }

            for (idx = 0; idx <= 11; idx++) {
                if (0 != ((bit32_chunks_free_partially) & (1 << idx))) {
                    f_dq->hw_bmap |= (1 << idx);
                    (*usage_bmap) |= (1 << idx);
                    temp_elem_count = temp_elem_count - 1;
                }

                if (0 == temp_elem_count) {
                    return BCM_E_NONE;
                }
            }

            for (idx = 0; idx <= 11; idx++) {
                if (0 != ((bit32_chunks_free) & (1 << idx))) {
                    f_dq->hw_bmap |= (1 << idx);
                    (*usage_bmap) |= (1 << idx);
                    temp_elem_count = temp_elem_count - 1;
                }

                if (0 == temp_elem_count) {
                    return BCM_E_NONE;
                }
            }

            /*Give last preference to data qualifiers Data8 and Data9 (marking UDF2.4
             *through UDF2.7) chunks as they are specific to RTAG7*/
            for (idx = 12; idx < 15; idx += 2) {
                if (1 != temp_elem_count) {
                    if ((0 != ((bit32_chunks_free) & (1 << idx))) &&
                        (0 != ((bit32_chunks_free) & (1 << (idx + 1))))) {
                        f_dq->hw_bmap |= (1 << idx);
                        (*usage_bmap) |= (1 << idx);
                        f_dq->hw_bmap |= (1 << (idx + 1));
                        (*usage_bmap) |= (1 << (idx + 1));
                        SHR_BITCLR(&bit32_chunks_free, idx);
                        SHR_BITCLR(&bit32_chunks_free, idx+1);
                        temp_elem_count = temp_elem_count - 2;
                    }

                    if (0 == temp_elem_count) {
                        return BCM_E_NONE;
                    }
                }
            }

            for (idx = 12; idx <= 15; idx++) {
                if (0 != ((bit32_chunks_free_partially) & (1 << idx))) {
                    f_dq->hw_bmap |= (1 << idx);
                    (*usage_bmap) |= (1 << idx);
                    temp_elem_count = temp_elem_count - 1;
                }

                if (0 == temp_elem_count) {
                    return BCM_E_NONE;
                }
            }

            for (idx = 12; idx <= 15; idx++) {
                if (0 != ((bit32_chunks_free) & (1 << idx))) {
                    f_dq->hw_bmap |= (1 << idx);
                    (*usage_bmap) |= (1 << idx);
                    temp_elem_count = temp_elem_count - 1;
                }

                if (0 == temp_elem_count) {
                    return BCM_E_NONE;
                }
            }
        }
    }

    return (BCM_E_RESOURCE);

}

/*
 * Function:
 *     _bcm_field_th_field_qset_data_qualifier_add
 *
 * Purpose:
 *     Add field data qualifier to group qset.
 *
 * Parameters:
 *      unit          - (IN) bcm device.
 *      qset          - (IN/OUT) Group qualifier set.
 *      qualifier_id  - (IN) Data qualifier id.
 *
 * Returns:
 *      BCM_E_XXX
 */
int _bcm_field_th_field_qset_data_qualifier_add(int unit,
                                                bcm_field_qset_t *qset,
                                                int qual_id)
{
    _field_stage_t          *stage_fc;      /* Stage field control.       */
    _field_data_qualifier_t *f_dq;          /* Data qualifier descriptor. */
    int                     idx;            /* HW bitmap iteration index. */
    int                     rv;             /* Operation return status.   */
    int                     offset_2_3 = 0;  /* HW offset 0 and 1 usage status. */
    int                     offset_4_5 = 0;  /* HW offset 2 and 3 usage status. */
    int                     offset_6_7 = 0;  /* HW offset 4 and 5 usage status. */
    int                     offset_a_b = 0;  /* HW offset 8 and 9 usage status. */
    int                     offset_c_d = 0;  /* HW offset a and b usage status. */
    int                     offset_e_f = 0;  /* HW offset c and d usage status. */
    int                     byte_index;
    int                     byte_count;

    FP_LOCK(unit);

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /*Get data qualifier info. */
    rv = _bcm_field_data_qualifier_get(unit, stage_fc, qual_id,  &f_dq);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }


    /*--------------------------------------------------------------------------------------*
     * Each chunk or chunk pair corresponds to the data qualifier as marked below:
     *
     * 15 -- 14   13 -- 12    11 -- 10    9    8     7 -- 6    5 -- 4   3 -- 2   1     0
     *{________}  {_______}   {_______} {___}{___}  {______}  {______}  {_____} {___}{___}
     *   Data9      Data8       Data7   Data6 Data5   Data4    Data3     Data2  Data1 Data0
     *  (32bit)    (32bit)    (32bit)  (16bit)(16bit) (32bit) (32bit)   (32bit)(16bit)(16bit)
     * {_________________________________________}   {___________________________________}
     *                     ||                                          ||
     *                    UDF_2                                       UDF_1
     *--------------------------------------------------------------------------------------*/

    /* Loop through the hw_map and set the correspoding bit in qset's udf_map*/

    for (idx = 0; idx <= 15; idx++) {
        if (f_dq->hw_bmap & (1 << idx)) {
            SHR_BITSET(qset->udf_map, idx);
        }
    }

    /* Add the qualifiers corresponding to the bit in qset->udf_map. Like,
     * 16_bit qualifiers are _bcmFieldQualifyData0, _bcmFieldQualifyData1,
     *_bcmFieldQualifyData5,_bcmFieldQualifyData6 and map 0,1,8,9 respectively*/

    if (SHR_BITGET(qset->udf_map, 0x0)) {
        BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData0);
    }
    if (SHR_BITGET(qset->udf_map, 0x1)) {
        BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData1);
    }
    if (SHR_BITGET(qset->udf_map, 0x8)) {
        BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData5);
    }
    if (SHR_BITGET(qset->udf_map, 0x9)) {
        BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData6);
    }

    /* 32_bit qualifiers are over a range of udf_map and hence
     * get HW offsets usage status. */

    SHR_BITTEST_RANGE(qset->udf_map, 0x2, 2, offset_2_3);
    SHR_BITTEST_RANGE(qset->udf_map, 0x4, 2, offset_4_5);
    SHR_BITTEST_RANGE(qset->udf_map, 0x6, 2, offset_6_7);
    SHR_BITTEST_RANGE(qset->udf_map, 0xa, 2, offset_a_b);
    SHR_BITTEST_RANGE(qset->udf_map, 0xc, 2, offset_c_d);
    SHR_BITTEST_RANGE(qset->udf_map, 0xe, 2, offset_e_f);

    if (offset_2_3) {
        BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
    }
    if (offset_4_5) {
        BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData3);
    }
    if (offset_6_7) {
        BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData4);
    }
    if (offset_a_b) {
        BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData7);
    }
    if (offset_c_d) {
        BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData8);
    }
    if (offset_e_f) {
        BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData9);
    }

    /* SDK builds key gen mask for exact match group during group create.
     * group control structure has information only about data qualifiers
     * (_bcmFieldQualifyData0 - _bcmFieldQualifyData9) and chunks allocated
     * in groups qset.But no information is available about which bytes of
     * the chunk is actually allocated.
     * But we need which bytes of chunk is allocated for the data qualifier to
     * properly build the EM key gen mask, in case of partially allocated chunks.
     * So updating the unused bits of udf_map in bcm_field_qset_t to hold the
     * bytes allocated in chunks allocated for the data qualifier.*/

    byte_count = f_dq->length;
    for (idx = 0; idx <= stage_fc->data_ctrl->num_elems * 2; idx++) {
        if (f_dq->hw_bmap & (1 << idx)) {
            byte_index = (stage_fc->data_ctrl->num_elems * 2) + (idx * 2);
            if (byte_count) {
                if (byte_count > 1) {
                    SHR_BITSET_RANGE(qset->udf_map, byte_index, 2);
                    byte_count = byte_count - 2;
                } else {
                    SHR_BITSET_RANGE(qset->udf_map, byte_index, 1);
                    byte_count = byte_count - 1;
                }
            }
        }
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_th_field_qset_data_qualifier_delete
 * Purpose:
 *      Delete field data qualifier from group qset.
 * Parameters:
 *      unit          - (IN) bcm device.
 *      qset          - (IN/OUT) Group qualifier set.
 *      qualifier_id  - (IN) Data qualifier id.
 * Returns:
 *      BCM_E_XXX
 */
int _bcm_field_th_field_qset_data_qualifier_delete (int unit, bcm_field_qset_t *qset,
                                                int qual_id)
{
    _field_stage_t          *stage_fc;  /* Stage field control.       */
    _field_data_qualifier_t *f_dq;      /* Data qualifier descriptor. */
    int                     idx;        /* HW bitmap iteration index. */
    int                     rv;         /* Operation return status.   */
    int                     offset_2_3 = 0;  /* HW offset 0 and 1 usage status. */
    int                     offset_4_5 = 0;  /* HW offset 2 and 3 usage status. */
    int                     offset_6_7 = 0;  /* HW offset 4 and 5 usage status. */
    int                     offset_a_b = 0;  /* HW offset 8 and 9 usage status. */
    int                     offset_c_d = 0;  /* HW offset a and b usage status. */
    int                     offset_e_f = 0;  /* HW offset c and d usage status. */

    FP_LOCK(unit);

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /*Get data qualifier info. */
    rv = _bcm_field_data_qualifier_get(unit, stage_fc, qual_id,  &f_dq);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Loop through the hw_map and clear the correspoding bit in qset's udf_map*/
    for (idx = 0; idx <= 15; idx++)
    {
        if (f_dq->hw_bmap & (1 << idx)) {
            SHR_BITCLR(qset->udf_map, idx);
        }
    }

    if (!SHR_BITGET(qset->udf_map, 0x0)) {
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData0);
    }

    if (!SHR_BITGET(qset->udf_map, 0x1)) {
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData1);
    }

    if (!SHR_BITGET(qset->udf_map, 0x8)) {
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData5);
    }

    if (!SHR_BITGET(qset->udf_map, 0x9)) {
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData6);
    }

    /* Get HW offsets usage status. */
    SHR_BITTEST_RANGE(qset->udf_map, 0x2, 2, offset_2_3);
    SHR_BITTEST_RANGE(qset->udf_map, 0x4, 2, offset_4_5);
    SHR_BITTEST_RANGE(qset->udf_map, 0x6, 2, offset_6_7);
    SHR_BITTEST_RANGE(qset->udf_map, 0xa, 2, offset_a_b);
    SHR_BITTEST_RANGE(qset->udf_map, 0xc, 2, offset_c_d);
    SHR_BITTEST_RANGE(qset->udf_map, 0xe, 2, offset_e_f);

    if (!offset_2_3) {
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData2);
    }
    if (!offset_4_5) {
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData3);
    }
    if (!offset_6_7) {
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData4);
    }
    if (!offset_a_b) {
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData7);
    }
    if (!offset_c_d) {
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData8);
    }
    if (!offset_e_f) {
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData9);
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_th_field_qset_data_qualifier_get
 * Purpose:
 *      Fetch the data qualifier that maps the index
 * Parameters:
 *      idx           - (IN) Index of the element
 *      qset          - (IN) Group qualifier set.
 *      qualifier_id  - (OUT) Data qualifier id.
 * Returns:
 *      BCM_E_XXX
 */
int _bcm_field_th_field_qset_data_qualifier_get(int idx,
        bcm_field_qset_t qset,
        bcm_field_qualify_t *qid)
{
    if (idx < 0 || idx > 15) {
        return (BCM_E_PARAM);
    }

    if (NULL == qid) {
        return (BCM_E_PARAM);
    }

    /* Return the qualifier id, if the qualifier_id is set in the Qset
     * and its corresponding index value is the same mapped with it*/
    if ((idx == 0) &&
            BCM_FIELD_QSET_TEST_INTERNAL(qset,
                _bcmFieldQualifyData0)) {
        *qid = _bcmFieldQualifyData0;
    } else if ((idx == 1) &&
            BCM_FIELD_QSET_TEST_INTERNAL(qset,
                _bcmFieldQualifyData1)) {
        *qid     = _bcmFieldQualifyData1;
    } else if (((idx == 2) || (idx == 3)) &&
            BCM_FIELD_QSET_TEST_INTERNAL(qset,
                _bcmFieldQualifyData2)) {
        *qid = _bcmFieldQualifyData2;
    } else if (((idx == 4) || (idx == 5)) &&
            BCM_FIELD_QSET_TEST_INTERNAL(qset,
                _bcmFieldQualifyData3)) {
        *qid = _bcmFieldQualifyData3;
    } else if (((idx == 6) || (idx == 7)) &&
            BCM_FIELD_QSET_TEST_INTERNAL(qset,
                _bcmFieldQualifyData4)) {
        *qid = _bcmFieldQualifyData4;
    } else if ((idx == 8) &&
            BCM_FIELD_QSET_TEST_INTERNAL(qset,
                _bcmFieldQualifyData5)) {
        *qid = _bcmFieldQualifyData5;
    } else if ((idx == 9) &&
            BCM_FIELD_QSET_TEST_INTERNAL(qset,
                _bcmFieldQualifyData6)) {
        *qid = _bcmFieldQualifyData6;
    } else if (((idx == 0xa) || (idx == 0xb)) &&
            BCM_FIELD_QSET_TEST_INTERNAL(qset,
                _bcmFieldQualifyData7)) {
        *qid = _bcmFieldQualifyData7;
    } else if (((idx == 0xc) || (idx == 0xd)) &&
            BCM_FIELD_QSET_TEST_INTERNAL(qset,
                _bcmFieldQualifyData8)) {
        *qid = _bcmFieldQualifyData8;
    } else if (((idx == 0xe) || (idx == 0xf)) &&
            BCM_FIELD_QSET_TEST_INTERNAL(qset,
                _bcmFieldQualifyData9)) {
        *qid = _bcmFieldQualifyData9;
    } else {
        return (BCM_E_INTERNAL);
    }

    return BCM_E_NONE;
}
/*
 * Function: _bcm_field_th_field_qualify_data_elem
 *
 * Purpose:
 *
 * Parameters:
 *     unit          - (IN) BCM device number.
 *     eid           - (IN) Entry ID.
 *     f_dq          - (IN) Data qualifier descriptor.
 *     qual_elem_idx - (IN) Data qualifier element index.
 *     data          - (IN) Data bytes for the indicated data qualifier.
 *                Network byte ordered.
 *     mask     - Mask bytes for the indicated data qualifier.
 *                Network byte ordered.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_field_qualify_data_elem(int unit, bcm_field_entry_t eid,
                         _field_data_qualifier_t *f_dq,
                         uint8 qual_elem_idx,
                         uint32 data, uint32 mask)
{
    _field_stage_t           *stage_fc;         /* Stage field control.       */
    _field_entry_t           *f_ent = NULL;     /* Field entry structure.     */
    int                      idx;               /* HW bitmap iteration index. */
    int                      rv;                /* Operation return status.   */
    int                      elem_idx = 0;      /* Qualifier Element Index.   */
    bcm_field_qualify_t      qid = 0;           /* Qualifier id.              */
    uint32                   q_data = 0;        /* Qualifier data             */
    uint32                   q_mask = 0;        /* Qualifier mask             */
    int                      bit32_chunk = 0;   /* Chunk is 32bit or 16bit    */

    /* Input parameters check. */
    if (NULL == f_dq) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc));

    /* Find a proper element to insert the data. */
    for (idx = 0; idx <= 15; idx ++) {
        if (f_dq->hw_bmap & (1 << idx)) {
            if (elem_idx == qual_elem_idx) {
                break;
            } else {
                elem_idx++;
            }
        }
    }

    if (idx != 0x0 && idx != 0x1 && idx != 0x8 && idx != 0x9)
    {
        bit32_chunk = 1;
    }

    /* Get entry info. */
    BCM_IF_ERROR_RETURN
        (_field_entry_get(unit, eid, _FP_ENTRY_PRIMARY, &f_ent));

    BCM_IF_ERROR_RETURN(_bcm_field_th_field_qset_data_qualifier_get(idx, f_ent->group->qset,&qid));

    if(bit32_chunk) {
        /*Since a 32 bit chunk can be allocated even partially,
          do not overwrite existing data in 32bit chunk.*/
        rv = _bcm_field_entry_qualifier_uint32_get(unit, f_ent->eid, qid, &q_data, &q_mask);

        if ((rv != BCM_E_NOT_FOUND) && (BCM_FAILURE(rv))) {
            return rv;
        }

        if (rv == BCM_E_NONE) {
            if((idx % 2) == 0) {
                /* Idx is even => Upper 16 bits need to be written.Hence,mask the lower
                 *16 bits of the q_data fetched from tcam and add the data*/
                q_data &= ((1 << 16) - 1);
                q_mask &= ((1 << 16) - 1);

                data = data << 16 | q_data;
                mask = mask << 16 | q_mask;
            } else {
                /* Idx is odd => Lower 16 bits need to be written.Hence,mask the upper
                 *16 bits of the q_data fetched from tcam and add the data*/
                q_data &= ~((1 << 16) - 1);
                q_mask &= ~((1 << 16) - 1);

                data |= q_data;
                mask |= q_mask;
            }
        }
    }

    /* If device supports per-pipe FP configuration, */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
         (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
        /* coverity[callee_ptr_arith : FALSE] */
        return (_bcm_field_th_qualify_set(unit, eid, qid,
                    &data, &mask, _FP_QUALIFIER_ADD));
    } else if ((f_ent->group->stage_id == _BCM_FIELD_STAGE_LOOKUP)) {
        _bcm_field_qual_offset_t *q_offset;
        int rv_sec = BCM_E_NONE;
        /* Get entry qualifier offset in tcam. */
        rv = _field_qual_offset_get(unit, f_ent, qid, &q_offset);
        if (BCM_E_NOT_FOUND == rv) {
            /* If offset is not found in first */
            rv_sec = (_field_entry_get(unit, eid, _FP_ENTRY_SECONDARY, &f_ent));
            if (BCM_FAILURE(rv_sec)) {
                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                                "Entry %d Second part get failed with error %d\n "),
                                eid, rv_sec));
                return rv;
            }
            rv_sec = _field_qual_offset_get(unit, f_ent, qid, &q_offset);
            if (BCM_SUCCESS(rv_sec)) {
                rv = BCM_E_NONE;
            } else {
                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                                "Entry %d Qual %d Offset get failed with error %d\n "),
                                eid, qid, rv_sec));
            }
        }
        BCM_IF_ERROR_RETURN(rv);
        rv = _bcm_field_qual_value_set(unit, q_offset, f_ent, &data, &mask);
        BCM_IF_ERROR_RETURN(rv);

        f_ent->flags |= _FP_ENTRY_DIRTY;
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_field_th_field_qualify_data_get
 * Purpose:
 *      Get data/mask in the search engine for entry field data qualifier.
 * Parameters:
 *      unit          - (IN) bcm device.
 *      eid           - (IN) Entry id.
 *      qual_id       - (IN) Data qualifier id.
 *      length_max    - (IN) Length of data & mask arrays.
 *      data          - (OUT) Match data.
 *      mask          - (OUT) Match mask.
 *      length        - (OUT) Length of data & mask arrays.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_th_field_qualify_data_get(int unit, bcm_field_entry_t eid, int qual_id,
                               uint16 length_max,  uint8 *data, uint8 *mask,
                               uint16 *length)
{
    _field_stage_t          *stage_fc;                      /* Stage field control.       */
    _field_data_qualifier_t *f_dq;                          /* Data qualifier descriptor. */
    _field_entry_t          *f_ent = NULL;                  /* Field entry structure.     */
    uint32                  data1;                          /* 32 bit qualifier data.     */
    uint32                  mask1;                          /* 32 bit qualifier mask.     */
    uint16                  data2;                          /* 16 bit qualifier data.     */
    uint16                  mask2;                          /* 16 bit qualifier mask.     */
    uint8                   *p_data1 = (uint8 *) &data1;    /* 32bit qualifier data pointer */
    uint8                   *p_mask1 = (uint8 *) &mask1;    /* 32bit qualifier mask pointer */
    uint8                   *p_data2 = (uint8 *) &data2;    /* 16bit qualifier data pointer */
    uint8                   *p_mask2 = (uint8 *) &mask2;    /* 16bit qualifier mask pointer */
    int                     bit32_chunk = 0;                /* Chunk is 32bit or 16bit    */
    bcm_field_qualify_t     qid = 0;                        /* Qualifier id.              */
    int                     idx;                            /* HW bitmap iteration index. */
    int                     rv;                             /* Operation return status.   */
    int                     shift = 0;
    int                     copy_len;
    int                     len = 0;
    #ifdef LE_HOST
    uint32 data_swap, mask_swap;
    #endif /* LE_HOST */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask) ||
        (NULL == length) || (length_max == 0)) {
        return (BCM_E_PARAM);
    }

    memset(&data1, 0, sizeof(data1));
    memset(&mask1, 0, sizeof(mask1));

    FP_LOCK(unit);

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Get data qualifier info. */
    rv = _bcm_field_data_qualifier_get(unit, stage_fc, qual_id,  &f_dq);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /*
     * If provided entry data length is greater than data length used
     * to create qualifier then return error
     */

    if (length_max > f_dq->length) {
        FP_UNLOCK(unit);
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_get_by_id(unit, eid, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    for (idx = 0; idx <= 15; idx++) {
        if (!(f_dq->hw_bmap & (1 << idx))) {
            continue;
        }

        if (idx != 0x0 && idx != 0x1 && idx != 0x8 && idx != 0x9) {
            bit32_chunk = 1;
        } else {
            bit32_chunk = 0;
        }

        /*Get the qualifier id matching the idx from the Group's qset*/
        rv = _bcm_field_th_field_qset_data_qualifier_get(idx, f_ent->group->qset,&qid);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

        /*Fetch the data from the Tcam.*/
        if(bit32_chunk) {
            rv = _bcm_field_entry_qualifier_uint32_get(unit, eid, qid,
                    &data1, &mask1);
        } else {
            rv = _bcm_field_entry_qualifier_uint16_get(unit, eid, qid,
                    &data2, &mask2);
        }
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
#ifdef LE_HOST
        data_swap = _shr_swap32(data1);
        data1 = data_swap;
        mask_swap = _shr_swap32(mask1);
        mask1 = mask_swap;
        data_swap = _shr_swap16(data2);
        data2 = data_swap;
        mask_swap = _shr_swap16(mask2);
        mask2 = mask_swap;
#endif /* LE_HOST */

        if (len < f_dq->length) {
            if(bit32_chunk) {
                /* Idx is even => Lower 16 bits need to be copied. Hence,
                 * start from offset 0. Idx is odd => Upper 16 bits need to be
                 * copied, hence start from offset 2 of the 32bit chunk's data.*/
                shift = (idx % 2 == 0) ? 0 : 2 ;
                copy_len = ((f_dq->length - len) == 1)? 1 : 2;
                sal_memcpy((data + len), p_data1 + shift, copy_len);
                sal_memcpy((mask + len), p_mask1 + shift, copy_len);
                len+= copy_len;
            } else {
                copy_len = ((f_dq->length - len) == 1)? 1 : 2;
                sal_memcpy((data + len), p_data2, copy_len);
                sal_memcpy((mask + len), p_mask2, copy_len);
                len+= copy_len;
            }
        }
    }

    *length = f_dq->length;

    FP_UNLOCK(unit);
    return BCM_E_NONE;
}
/*
 * Function:
 *    _field_th_data_qualifier_destroy_all
 *
 * Purpose:
 *    Destroy all data/offset  based qualifiers.
 *
 * Parameters:
 *    unit - (IN) BCM device number
 *
 * Returns:
 *    BCM_E_INIT    - Stage is not initialized.
 *    BCM_E_UNAVAIL - function not supported for this stage.
 *    BCM_E_NONE    - Success.
 */
STATIC int
_field_th_data_qualifier_destroy_all(int unit)
{
    _field_data_qualifier_t *f_dq; /* Internal data qualifier descriptor. */
    _field_stage_t *stage_fc; /* Stage field control. */

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
        _BCM_FIELD_STAGE_INGRESS, &stage_fc));

    while (NULL != stage_fc->data_ctrl->data_qual) {
        f_dq = stage_fc->data_ctrl->data_qual;
        BCM_IF_ERROR_RETURN(_bcm_field_data_qualifier_destroy(unit, f_dq->qid));
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_stage_data_ctrl_deinit
 *
 * Purpose:
 *    De-allocate data qualifiers control structure.
 *
 * Parameters:
 *    unit      - (IN) BCM device number
 *    stage_fc  - (IN/OUT) Stage for which data qualifier need to be freed.
 *
 * Returns:
 *     BCM_E_PARAM  - NULL Stage control data structure pointer.
 *     BCM_E_NONE   - Success
 */
STATIC int
_field_th_stage_data_ctrl_deinit(int unit, _field_stage_t *stage_fc)
{
    _field_data_control_t *data_ctrl; /* Data qualifiers control structure
                                         pointer. */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Free the data qualifiers control structure only for IFP. */
    if (_BCM_FIELD_STAGE_INGRESS != stage_fc->stage_id) {
        return (BCM_E_NONE);
    }

    /* If data qualifiers control structure is already freed, return SUCCESS. */
    data_ctrl = stage_fc->data_ctrl;
    if (NULL == data_ctrl) {
        return (BCM_E_NONE);
    }

    /* Delete all data qualifiers. */
    _field_th_data_qualifier_destroy_all(unit);

    /* Free control structures. */
    if (NULL != data_ctrl->tcam_entry_arr) {
        sal_free(data_ctrl->tcam_entry_arr);
    }

    /* Free data qualifiers control structure memory. */
    if (NULL != data_ctrl) {
        sal_free(data_ctrl);
    }

    /* Initialize stage data qualifier control structure pointer to NULL. */
    stage_fc->data_ctrl = NULL;
    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_stage_keygen_extractors_deinit
 *
 * Purpose:
 *    Deinitialize field stage keygen extractors information.
 *
 * Parameters:
 *    unit     - (IN) BCM device number
 *    stage_fc - (IN) stage control structure.
 *
 * Returns:
 *    BCM_E_PARAM - Device Stage field control structure pointer is NULL.
 *    BCM_E_NONE  - Success
 */
STATIC int
_field_th_stage_keygen_extractors_deinit(int unit, _field_stage_t *stage_fc)
{
    bcm_error_t rv = BCM_E_NONE;
    bcmi_keygen_mode_t emode;             /* Extractor mode.              */
    bcmi_keygen_ext_cfg_db_t *ext_cfg_db; /* Extractor configuration.     */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Do nothing for Non-IFP stages. */
    if ((_BCM_FIELD_STAGE_INGRESS != stage_fc->stage_id) &&
        (_BCM_FIELD_STAGE_FLOWTRACKER != stage_fc->stage_id)) {
        return (BCM_E_NONE);
    }

    /* Do nothing if it's already freed. */
    if (NULL == stage_fc->ext_cfg_db_arr) {
        return (BCM_E_NONE);
    }

    for (emode = 0; emode < BCMI_KEYGEN_MODE_COUNT; emode++) {

        /* Get extractor config array pointer. */
        ext_cfg_db = stage_fc->ext_cfg_db_arr[emode];
        if (NULL == ext_cfg_db) {
            continue;
        }

        rv = bcmi_keygen_ext_cfg_db_free(unit, ext_cfg_db);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
        stage_fc->ext_cfg_db_arr[emode] = NULL;
    }

    sal_free(stage_fc->ext_cfg_db_arr);
    /* Mark extractor configuration array as unused. */
    stage_fc->ext_cfg_db_arr = NULL;

    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_stage_keygen_qual_db_deinit
 *
 * Purpose:
 *    Deinitialize field stage keygen qualifiers config information database.
 *
 * Parameters:
 *    unit     - (IN) BCM device number
 *    stage_fc - (IN) stage control structure.
 *
 * Returns:
 *    BCM_E_PARAM - Device Stage field control structure pointer is NULL.
 *    BCM_E_NONE  - Success
 */
STATIC int
_field_th_stage_keygen_qual_db_deinit(int unit, _field_stage_t *stage_fc)
{
    bcm_error_t rv = BCM_E_NONE;

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Do nothing for Non-IFP stages. */
    if ((_BCM_FIELD_STAGE_INGRESS != stage_fc->stage_id) &&
        (_BCM_FIELD_STAGE_FLOWTRACKER != stage_fc->stage_id)) {
        return (BCM_E_NONE);
    }

    /* Do nothing if already freed. */
    if (NULL == stage_fc->qual_cfg_info_db) {
        return (BCM_E_NONE);
    }

    rv = bcmi_keygen_qual_cfg_info_db_free(unit, stage_fc->qual_cfg_info_db);
    if (BCM_FAILURE(rv)) {
        return rv;
    }

    /* Deallocate qualifiers sections pointers memory. */
    sal_free(stage_fc->qual_cfg_info_db);

    /* Mark qualifier list as unused. */
    stage_fc->qual_cfg_info_db = NULL;

    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_stage_actions_deinit
 *
 * Purpose:
 *    Deinitialize field stage actions configuration array.
 *
 * Parameters:
 *    unit     - (IN) BCM device number
 *    stage_fc - (IN) stage control structure.
 *
 * Returns:
 *    BCM_E_PARAM - Device Stage field control structure pointer is NULL.
 *    BCM_E_NONE  - Success
 */
STATIC int
_field_th_stage_actions_deinit(int unit, _field_stage_t *stage_fc)
{
    int idx;                 /* Index to loop through  all field actions */
    _bcm_field_action_offset_t *offset;       /* Offset Information.     */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Do nothing for Non-IFP stages. */
    if ((_BCM_FIELD_STAGE_INGRESS != stage_fc->stage_id) &&
        (_BCM_FIELD_STAGE_EXACTMATCH != stage_fc->stage_id)) {
        return (BCM_E_NONE);
    }


    if (NULL != stage_fc->f_action_arr) {

        for (idx = 0; idx < _bcmFieldActionCount; idx++) {
            if (NULL != stage_fc->f_action_arr[idx]) {

                if (NULL != stage_fc->f_action_arr[idx]->offset) {
                    do {
                        offset = stage_fc->f_action_arr[idx]->offset;
                        stage_fc->f_action_arr[idx]->offset =
                                   stage_fc->f_action_arr[idx]->offset->next;
                        /* Deallocate different offset information for same action. */
                        sal_free(offset);
                    } while(stage_fc->f_action_arr[idx]->offset);
                }
                /* Deallocate action configuration */
                sal_free(stage_fc->f_action_arr[idx]);
            }
        }

        /* Deallocate action configuration pointer array */
        sal_free(stage_fc->f_action_arr);
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *    _field_th_stage_delete
 *
 * Purpose:
 *    Deinitialize a field stage.
 *
 * Parameters:
 *    unit     - (IN) BCM device number
 *    fc       - (IN/OUT) Field control info of device.
 *    stage_fc - (IN) stage control structure.
 *
 * Returns:
 *    BCM_E_PARAM - Device field control information is NULL.
 *    BCM_E_NONE  - Success
 */
STATIC int
_field_th_stage_delete(int unit, _field_control_t *fc, _field_stage_t *stage_fc)
{
    _field_stage_t *stage_iter; /* Device stages iterator. */
    int inst; /* Stage instance iterator. */

    /* Input parameters check. */
    if (NULL == fc) {
        return (BCM_E_PARAM);
    }

    /* Stage already destroyed. */
    if (NULL == stage_fc) {
        return (BCM_E_NONE);
    }


    /* First Exact Match Stage Specific delete */
    if (_BCM_FIELD_STAGE_EXACTMATCH == stage_fc->stage_id) {
        _field_th_emstage_deinit(unit, stage_fc);
    }
#if defined(BCM_FLOWTRACKER_SUPPORT)
    if ((soc_feature(unit, soc_feature_field_flowtracker_support)) &&
            (_BCM_FIELD_STAGE_FLOWTRACKER == stage_fc->stage_id)) {
        _field_hx5_ftstage_deinit(unit, stage_fc);
    }
#endif
#if defined(BCM_FIREBOLT6_SUPPORT)
    if (soc_feature(unit, soc_feature_field_aacl_compression) &&
        _BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) {
        BCM_IF_ERROR_RETURN(_field_fb6_compress_deinit(unit, stage_fc));
    }
#endif
    /* Destroy data qualifiers control structure. */
    if (!soc_feature(unit, soc_feature_td3_style_fp)) {
        _field_th_stage_data_ctrl_deinit(unit, stage_fc);
    }

    /* Free memory alloacted for stage qualifiers */
    _bcm_field_stage_qualifiers_free(unit, stage_fc);

    /* Free memory allocated for extractors configuration table. */
    _field_th_stage_keygen_extractors_deinit(unit, stage_fc);

    /* Free memory allocated for qualifiers input bus mapping table. */
    _field_th_stage_keygen_qual_db_deinit(unit, stage_fc);

    /* Free memory allocated for actions configurations. */
    _field_th_stage_actions_deinit(unit, stage_fc);

    if (_BCM_FIELD_STAGE_LOOKUP == stage_fc->stage_id) {
        soc_profile_mem_destroy(unit, &stage_fc->hash_select[0]);
        soc_profile_mem_destroy(unit, &stage_fc->hash_select[1]);
    }

    /* Free stage per-instance information. */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {
             continue;
        }
        /*
         * Check if slices were initialized for current instance in the
         * stage.
         */
        if (NULL != stage_fc->slices[inst]) {
            /* Deallocate counters usage bitmap. */
            _field_th_instance_counters_deinit(unit, stage_fc, inst);

            /* Deallocate instance meters usage bitmap. */
            _field_th_instance_meters_deinit(unit, stage_fc, inst);

            /* Deallocate instance entry pointers. */
            _field_th_instance_entries_free(unit, stage_fc, inst);

            /* Deallocate instance priority management structures. */
            _field_th_instance_prio_mgmt_deinit(unit, stage_fc, inst);

            sal_free(stage_fc->slices[inst]);
            stage_fc->slices[inst] = NULL;
        }

        /* Destroy keygen program profiles for valid instances. */
        if ((_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) ||
            (_BCM_FIELD_STAGE_EXACTMATCH == stage_fc->stage_id)) {
            soc_profile_mem_destroy(unit,
                &stage_fc->keygen_profile[inst].profile);
        }

        /* Destroy action profiles for TD3 Ingress */
         if (soc_feature(unit, soc_feature_ifp_action_profiling) &&
             (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {
             soc_profile_mem_destroy(unit,
                    &stage_fc->action_profile[inst]);
        }
        /* Destroy action profiles for valid instances. */
        if (_BCM_FIELD_STAGE_EXACTMATCH == stage_fc->stage_id) {
            soc_profile_mem_destroy(unit,
                    &stage_fc->action_profile[inst]);
            soc_profile_mem_destroy(unit,
                    &stage_fc->qos_action_profile[inst]);
        }
    }

    /* Deallocate Preselector resources for IFP and EM Stage. */
    _bcm_field_th_preselector_deinit(unit, fc, stage_fc);

    /* Destroy all valid range checkers. */
    while (stage_fc->ranges != NULL) {
        bcm_esw_field_range_destroy(unit, stage_fc->ranges->rid);
    }

    /* Destroy class status info struct */
    if (stage_fc->stage_id == _BCM_FIELD_STAGE_CLASS) {
        _bcm_field_th_class_stage_status_deinit(unit, stage_fc);
    }

    /* Remove stage from stages linked list. */
    stage_iter = fc->stages;
    while (NULL != stage_iter) {
        if (stage_iter == stage_fc) {
            fc->stages = stage_fc->next;
            break;
        } else if (stage_iter->next == stage_fc) {
            stage_iter->next = stage_fc->next;
            break;
        }
        stage_iter = stage_iter->next;
    }

    /* Free stage info. */
    sal_free(stage_fc);
    stage_fc = NULL;

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_th_instance_slices_init
 *
 * Purpose:
 *    Allocate memory for slices and initialize slice specific flags &
 *    parameters for a specific instance.
 *
 * Parameters:
 *    unit      - (IN) BCM device number.
 *    stage_fc  - (IN/OUT) Stage field control structure.
 *    inst      - (IN) Stage instance information.
 *
 * Returns:
 *     BCM_E_PARAM  - NULL stage control pointer.
 *     BCM_E_MEMORY - Allocation failure.
 *     BCM_E_NONE   - Success.
 */
STATIC int
_field_th_instance_slices_init(int unit, _field_stage_t *stage_fc, int inst)
{
    struct _field_slice_s *fs; /* Slice info. */
    int slice; /* Slice iterator. */
    int mem_sz; /* Memory allocation buffer size. */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Validate instance value. */
    if (inst < 0 || inst >= stage_fc->num_instances) {
        return (BCM_E_PARAM);
    }

    /* Allocate slices info. */
    mem_sz = stage_fc->tcam_slices * sizeof(_field_slice_t);
    fs = sal_alloc(mem_sz, "stage slices info");
    if (NULL == fs) {
        return (BCM_E_MEMORY);
    }

    /* Initialze stage slice data structure. */
    sal_memset(fs, 0, mem_sz);

    /* Initialize stage instance slices pointer. */
    stage_fc->slices[inst] = fs;

    /* Initialize stage slices info. */
    for (slice = 0; slice < stage_fc->tcam_slices; slice++) {
        fs[slice].slice_number = slice;
        fs[slice].stage_id = stage_fc->stage_id;
        fs[slice].next = NULL;
        fs[slice].prev = NULL;

        /* Set legacy slice selector settings to don't care. */
        fs[slice].doublewide_key_select = _FP_SELCODE_DONT_CARE;
        fs[slice].src_class_sel = _FP_SELCODE_DONT_CARE;
        fs[slice].dst_class_sel = _FP_SELCODE_DONT_CARE;
        fs[slice].intf_class_sel = _FP_SELCODE_DONT_CARE;
        fs[slice].loopback_type_sel = _FP_SELCODE_DONT_CARE;
        fs[slice].ingress_entity_sel = _FP_SELCODE_DONT_CARE;
        fs[slice].src_entity_sel = _FP_SELCODE_DONT_CARE;
        fs[slice].dst_fwd_entity_sel = _FP_SELCODE_DONT_CARE;
        fs[slice].fwd_field_sel = _FP_SELCODE_DONT_CARE;

        /* Both IFP and VFP support Intra Slice Double Wide mode. */
        if ((_BCM_FIELD_STAGE_EGRESS != stage_fc->stage_id) &&
            (_BCM_FIELD_STAGE_EXACTMATCH != stage_fc->stage_id) &&
            (_BCM_FIELD_STAGE_FLOWTRACKER != stage_fc->stage_id)) {
            fs[slice].slice_flags |= _BCM_FIELD_SLICE_INTRASLICE_CAPABLE;
        }
#if defined(BCM_FLOWTRACKER_SUPPORT)
        if (_BCM_FIELD_STAGE_FLOWTRACKER == stage_fc->stage_id) {
            fs[slice].slice_flags |= _BCM_FIELD_SLICE_MULTIMODE_ENTRIES;
        }
#endif
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
        if (soc_feature(unit, soc_feature_field_flowtracker_v3_support) &&
                (_BCM_FIELD_STAGE_FLOWTRACKER == stage_fc->stage_id)) {
            fs[slice].slice_flags |= _BCM_FIELD_SLICE_INDEPENDENT;
        }
#endif
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_slices_init
 *
 * Purpose:
 *    Allocate memory for slices per-instance in a stage.
 *
 * Parameters:
 *    unit - (IN) BCM device number.
 *    stage_fc - (IN/OUT) Stage field control structure.
 *    fc - (IN/OUT) Field control structure.
 *
 * Returns:
 *     BCM_E_PARAM  - NULL stage control pointer or field control.
 *     BCM_E_MEMORY - Allocation failure.
 *     BCM_E_NONE   - Success.
 */
STATIC int
_field_th_slices_init(int unit, _field_stage_t *stage_fc, _field_control_t *fc)
{
    int inst; /* Stage instance iterator. */
    int rv; /* Operation return value. */

    /* Input parameters check. */
    if (NULL == fc || NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* For all valid instances, initialize slices information. */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {
             continue;
        }
        rv = _field_th_instance_slices_init(unit, stage_fc, inst);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                "FP(unit %d) Error: _field_th_instance_slices_init=%d\n"),
                 unit, rv));
            return (rv);
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_stage_entries_free
 *
 * Purpose:
 *    Free entries array for all stage slices for all instances.
 *
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     stage_fc - (IN/OUT) Stage field control.
 *
 * Returns:
 *     BCM_E_PARAM  - NULL stage control pointer
 *     BCM_E_NONE   - Success.
 */
STATIC int
_field_th_stage_entries_free(int unit, _field_stage_t *stage_fc)
{
    _field_slice_t *fs; /* Field slice pointer. */
    int slice; /* Slice iterator. */
    int inst; /* Instance iterator. */
    _field_control_t    *fc;  /* Field control structure.       */

    /* Input prameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Deallocate instance entry pointers. */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {
             continue;
        }
        for (slice = 0; slice < stage_fc->tcam_slices; slice++) {
            fs = stage_fc->slices[inst] + slice;
            if (NULL != fs->entries) {
                sal_free(fs->entries);
                fs->entries = NULL;
            }
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_th_instance_entries_init
 * Purpose:
 *     Initialize Logical Table slice entries for a StageIngress instance.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     stage_fc - (IN) stage control structure pointer.
 *     inst     - (IN) Field Pipe Instance for which Logical tables must be
 *                     deinitialized.
 * Returns:
 *     BCM_E_PARAM - Device stage field control information is NULL
 *                   or Invalid instance specified.
 *     BCM_E_NONE  - Success
 */
STATIC int
_field_th_instance_entries_init(int unit, _field_stage_t *stage_fc, int inst)
{
    int rv =  BCM_E_NONE; /* return value. */
    int slice; /* Slice iterator. */
    int tcam_idx; /* Slice first entry tcam index tracker. */
    int mem_sz; /* Allocation size. */
    _field_slice_t *fs; /* Slice config structure. */
    int entry_ratio = 1;  /* Valid entries ratio.*/
#if defined(BCM_UTT_SUPPORT)
    int *slice_depth = NULL; /* Slice depth array */
    int depth_small  = 0;    /* Slice depth array */
#endif

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Check if instance is in valid range. */
    if (inst < 0 || inst >= stage_fc->num_instances) {
        return (BCM_E_PARAM);
    }

    /* Make sure slices array is initialized. */
    if (NULL == stage_fc->slices[inst]) {
        return (BCM_E_INTERNAL);
    }
    if (soc_feature(unit, soc_feature_field_stage_half_slice)) {
        entry_ratio = 2;
    } else if (soc_feature(unit, soc_feature_field_stage_quarter_slice)) {
        entry_ratio = 4;
    }

#if defined(BCM_UTT_SUPPORT)
    if ((_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)
        && (soc_feature(unit, soc_feature_utt_ver1_5)
        && soc_feature(unit, soc_feature_utt))) {
        _FP_XGS3_ALLOC(slice_depth, stage_fc->tcam_slices * sizeof(int), "array of slice depth.");
        if (NULL == slice_depth) {
            LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META(
               "slice_depth memory resource error\n")));
            return (BCM_E_MEMORY);
        }

        rv = soc_utt_ifp_lookup_depth_get(unit, stage_fc->tcam_slices, slice_depth);
        BCM_IF_ERROR_CLEANUP(rv);
        if (soc_feature(unit, soc_feature_field_ingress_two_slice_types)) {
            depth_small = slice_depth[0];
            for (slice = 0; slice < stage_fc->tcam_slices; slice++) {
                /* Continue if current slice has depth same as depth_small */
                if (slice_depth[slice] == depth_small) {
                    continue;
                }

                if (slice_depth[slice] > depth_small) {
                    /*
                     * Different Slice depth is found and it is bigger than
                     * the current depth_small slice depth. depth_small contains
                     * smallest slice size. So nothing to do much.
                     * Go for slice size update and marking two slice types.
                     */
                     break;
                }
                /* Older value is large slice size. So update with smaller and break */
                depth_small = slice_depth[slice];
                break;
            }
        }
    }
#endif /* BCM_UTT_SUPPORT */

    /* Iterate over all stage's slices and allocate entries for each slice. */
    for (slice = 0, tcam_idx = 0; slice < stage_fc->tcam_slices; slice++) {
        /* Get Pipe slice control structure pointer. */
        fs = stage_fc->slices[inst] + slice;

#if defined(BCM_UTT_SUPPORT)
        if ((_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)
            && (soc_feature(unit, soc_feature_utt_ver1_5)
            && soc_feature(unit, soc_feature_utt))) {
            fs->entry_count = slice_depth[slice] * 2;
            if (soc_feature(unit, soc_feature_field_ingress_two_slice_types)) {
                fs->slice_flags |= (slice_depth[slice] == depth_small) \
                                   ? _BCM_FIELD_SLICE_SIZE_SMALL : _BCM_FIELD_SLICE_SIZE_LARGE;
            }
        } else
#endif /* BCM_UTT_SUPPORT */
#if defined(BCM_TOMAHAWK3_SUPPORT)
        /*  Initialize entries per-slice count. */
        if ((SOC_IS_TOMAHAWK3(unit)) &&
            (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS)) {
            if (slice < _BCM_FIELD_TH3_INGRESS_MAX_SMALL_SLICES) {
                fs->entry_count = _BCM_FIELD_TH3_INGRESS_SMALL_SLICE_SZ;
                if (soc_feature(unit, soc_feature_field_ingress_two_slice_types)) {
                    fs->slice_flags |= _BCM_FIELD_SLICE_SIZE_SMALL;
                }
            } else {
                fs->entry_count = _BCM_FIELD_TH3_INGRESS_LARGE_SLICE_SZ;
                if (soc_feature(unit, soc_feature_field_ingress_two_slice_types)) {
                    fs->slice_flags |= _BCM_FIELD_SLICE_SIZE_LARGE;
                }
            }
        } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
        if ((SOC_IS_FIREBOLT6(unit)) &&
            (stage_fc->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER)) {
            if (slice < _BCM_FIELD_FB6_INGRESS_FLOWTRACKER_MAX_SMALL_SLICES) {
                fs->entry_count = _BCM_FIELD_FB6_INGRESS_FLOWTRACKER_SMALL_SLICE_SZ;
                fs->slice_flags |= _BCM_FIELD_SLICE_SIZE_SMALL;
            } else {
                fs->entry_count = _BCM_FIELD_FB6_INGRESS_FLOWTRACKER_LARGE_SLICE_SZ;
                fs->slice_flags |= _BCM_FIELD_SLICE_SIZE_LARGE;
            }
        } else
#endif /* BCM_FLOWTRACKER_V3_SUPPORT */
        {
            fs->entry_count = stage_fc->tcam_sz / stage_fc->tcam_slices;
        }
        /* Calculate size for total entry pointers. */
        mem_sz = fs->entry_count * sizeof(void *);

        /* Allocate slice entries pointers array. */
        _FP_XGS3_ALLOC(fs->entries, mem_sz, "array of entry pointers.");
        if (NULL == fs->entries) {
            /* Allocation failed free all previously allocated entries. */
            _field_th_stage_entries_free(unit, stage_fc);
            rv = (BCM_E_MEMORY);
            BCM_IF_ERROR_CLEANUP(rv);
        }

        fs->start_tcam_idx = tcam_idx;
        tcam_idx += fs->entry_count * entry_ratio;
        fs->free_count = fs->entry_count;
    }

cleanup:
#if defined(BCM_UTT_SUPPORT)
    if (slice_depth) {
        sal_free(slice_depth);
    }
#endif

    return (rv);
}

/*
 * Function:
 *    _field_th_entries_init
 *
 * Purpose:
 *    Allocate the memory for entries in all the slices in all instances for a
 *    stage.
 *
 * Parameters:
 *    unit - (IN) BCM device number.
 *    stage_fc - (IN/OUT) Stage field control.
 *
 * Returns:
 *    BCM_E_PARAM   - NULL stage control pointer
 *    BCM_E_MEMORY  - Allocation failure
 *    BCM_E_NONE    - Success
 */
STATIC int
_field_th_entries_init(int unit, _field_stage_t *stage_fc,
                       _field_control_t *fc)
{
    int inst; /* Instance iterator. */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Iterate over all instances. */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {
             continue;
        }
        BCM_IF_ERROR_RETURN(_field_th_instance_entries_init(unit, stage_fc,
            inst));
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_meters_deinit
 *
 * Purpose:
 *    Deinitialize merter usage bitmap for all instances in a stage.
 *
 * Parameters:
 *    unit - (IN) BCM device number.
 *    stage_fc - (IN/OUT) Stage field control.
 *
 * Returns:
 *    BCM_E_PARAM  - NULL stage control pointer.
 *    BCM_E_NONE   - Success.
 */
STATIC int
_field_th_meters_deinit(int unit, _field_stage_t *stage_fc)
{
    int inst; /* Instance iterator. */
    _field_control_t    *fc;            /* Field control structure.       */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Free instance meter resources. */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {
             continue;
        }
        _field_th_instance_meters_deinit(unit, stage_fc, inst);
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *   _field_th_meter_pools_init
 *
 * Purpose:
 *    Initialize field meter pools usage bitmap for all instances in a stage.
 *
 * Parameters:
 *     unit - (IN) BCM device number
 *     stage_fc - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *    BCM_E_PARAM   - NULL stage control pointer.
 *    BCM_E_MEMORY  - Allocation failure.
 *    BCM_E_NONE    - Success.
 */
STATIC int
_field_th_meter_pools_init(int unit, _field_stage_t *stage_fc,
                           _field_control_t *fc)
{
    int inst; /* Instance iterator. */
    int pool_idx; /* Meter pools iterator. */
    int size; /* Number of meters in a pool. */
    _field_meter_pool_t *mp; /* Meter pool pointer. */
    int meter_pairs_per_pool =0;
    int pipe = -1, pool = -1;
    int rv = 0;

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Initialize number of meter pools. */
    if (SOC_IS_TOMAHAWK3(unit)) {
        stage_fc->num_meter_pools = BCM_FIELD_INGRESS_TH3_NUM_METER_POOLS;
    } else {
        stage_fc->num_meter_pools = BCM_FIELD_INGRESS_TH_NUM_METER_POOLS;
    }

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        meter_pairs_per_pool = BCM_FIELD_INGRESS_TD3_NUM_METER_PAIRS_PER_POOL;
    } else {
        meter_pairs_per_pool = BCM_FIELD_INGRESS_TH_NUM_METER_PAIRS_PER_POOL;
    }
    /* Initialize number of meter per pool.*/
    size = SHR_BITALLOCSIZE(meter_pairs_per_pool << 1);

    /* Initialize meter pools in all instances. */
    for (inst = 0; inst < _FP_MAX_NUM_PIPES; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {
             continue;
        }
        for (pool_idx = 0; pool_idx < stage_fc->num_meter_pools; pool_idx++) {
            /* Allocate Pipe meter pool memory. */
            stage_fc->meter_pool[inst][pool_idx] =
                sal_alloc(sizeof(_field_meter_pool_t), "fp_meter_pool");
            if (NULL == stage_fc->meter_pool[inst][pool_idx]) {
                _field_th_meters_deinit(unit, stage_fc);
                return (BCM_E_MEMORY);
            }

            /* Initialize stage instance meter pool info. */
            mp = stage_fc->meter_pool[inst][pool_idx];
            mp->slice_id = -1;
            mp->level = -1;
            mp->pool_size = (meter_pairs_per_pool * 2);
            mp->size = (meter_pairs_per_pool * 2);
            mp->free_meters = (meter_pairs_per_pool * 2);
            mp->num_meter_pairs = (meter_pairs_per_pool);

            /* Allocate instance Per-Pool meter usage bitmap memory. */
            mp->meter_bmp.w = sal_alloc(size, "fp_meters_map");
            if (NULL == mp->meter_bmp.w) {
                _field_th_meters_deinit(unit, stage_fc);
                return (BCM_E_MEMORY);
            }
            /* Clear pool meter usage bitmap. */
            sal_memset(mp->meter_bmp.w, 0, size);
        }
    }

    if (!(SOC_WARM_BOOT(unit))) {
        for (pipe = 0; pipe < _FP_MAX_NUM_PIPES; pipe++) {
             for (pool = 0; pool < _FIELD_MAX_METER_POOLS; pool++) {
                 if ((stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) &&
                     (fc->ifp_em_meter_in_use[pipe][pool] == 
                     BCM_FIELD_METER_POOL_USED_BY_EM)) {
                     /* Copy from EM to IFP */
                     rv = (_field_stage_meter_pool_copy
                                        (unit, _BCM_FIELD_STAGE_EXACTMATCH,
                                         stage_fc, pipe, pool));
                     BCM_IF_ERROR_RETURN(rv);
                 } else if ((stage_fc->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) &&
                     (fc->ifp_em_meter_in_use[pipe][pool] == 
                     BCM_FIELD_METER_POOL_USED_BY_IFP)) {
                     /* Copy from IFP to EM */
                     rv = (_field_stage_meter_pool_copy
                                        (unit, _BCM_FIELD_STAGE_INGRESS,
                                         stage_fc, pipe, pool));
                     BCM_IF_ERROR_RETURN(rv);
                 }
             }
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_slice_meters_init
 *
 * Purpose:
 *    Initialize field slice meters usage bitmap for all instances in a stage.
 *
 * Parameters:
 *    unit - (IN) BCM device number
 *    stage_fc - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *    BCM_E_PARAM   - NULL stage control pointer.
 *    BCM_E_MEMORY  - Allocation failure.
 *    BCM_E_NONE    - Success.
 */
STATIC int
_field_th_slice_meters_init(int unit, _field_stage_t *stage_fc,
                            _field_control_t *fc)
{
    _field_slice_t *fs; /* Slice config structure. */
    int inst; /* Instance iterator. */
    int size; /* Allocation size. */
    int slice; /* Slice iterator. */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Iterate over all instances and slices and initialize meter information.*/
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {
             continue;
        }
        for (slice = 0; slice <stage_fc->tcam_slices; slice++) {

            /* Get the slice pointer. */
            fs = stage_fc->slices[inst] + slice;

            size = SHR_BITALLOCSIZE(_BCM_FIELD_SLICE_SIZE(stage_fc, inst, 0));
            /* Allocate meter usage bitmap. */
            fs->meter_bmp.w = sal_alloc(size, "fp_meters_map");
            if (NULL == fs->meter_bmp.w) {
                _field_th_meters_deinit(unit, stage_fc);
                return (BCM_E_MEMORY);
            }

            /* Set slice meter count and clear usage bitmap. */
            fs->meters_count = _BCM_FIELD_SLICE_SIZE(stage_fc, inst, 0);
            sal_memset(fs->meter_bmp.w, 0, size);
        }
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *   _field_th_meters_init
 *
 * Purpose:
 *    Initialize field meter usage bitmap for the sage.
 *
 * Parameters:
 *    unit - (IN) BCM device number
 *    stage_fc - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *    BCM_E_PARAM   - NULL stage control pointer.
 *    BCM_E_MEMORY  - Allocation failure.
 *    BCM_E_NONE    - Success.
 */
STATIC int
_field_th_meters_init(int unit, _field_stage_t *stage_fc,
                       _field_control_t *fc)
{
    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Lookup stage has no dedicated meter support.
     * Exact stage uses IFP meter table.
     */
    if ((_BCM_FIELD_STAGE_LOOKUP == stage_fc->stage_id) ||
        (_BCM_FIELD_STAGE_FLOWTRACKER == stage_fc->stage_id) ||
        (_BCM_FIELD_STAGE_AMFTFP == stage_fc->stage_id) ||
        (_BCM_FIELD_STAGE_AEFTFP == stage_fc->stage_id)) {
        return (BCM_E_NONE);
    }

    /* Initialize Global meter pools information for IFP. */
    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        return (_field_th_meter_pools_init(unit, stage_fc, fc));
    }

    /* Initialize slice meters for EFP. */
    return (_field_th_slice_meters_init(unit, stage_fc, fc));
}

/*
 * Function:
 *   _field_th_stage_data_ctrl_init
 *
 * Purpose:
 *    Allocate and initialize data qualifiers control structure.
 *
 * Parameters:
 *    unit - (IN) BCM device number.
 *    stage_fc - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *    BCM_E_PARAM   - NULL stage control pointer.
 *    BCM_E_MEMORY  - Allocation failure.
 *    BCM_E_NONE    - Success.
 */
STATIC int
_field_th_stage_data_ctrl_init(int unit, _field_stage_t *stage_fc)
{
    int mem_sz; /* Memory size. */
    _field_data_control_t *data_ctrl = NULL;

    /* Input prameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Allocate data control structure. */
    mem_sz = sizeof(_field_data_control_t);
    _FP_XGS3_ALLOC(data_ctrl, mem_sz, "Data qualification control");
    if (NULL == data_ctrl) {
        return (BCM_E_MEMORY);
    }

    /* Allocate data TCAM entry control structure. */
    mem_sz = sizeof(_field_data_tcam_entry_t) *
                soc_mem_index_count(unit, FP_UDF_TCAMm);
    _FP_XGS3_ALLOC(data_ctrl->tcam_entry_arr, mem_sz, "UDF tcam entry array");
    if (NULL == data_ctrl->tcam_entry_arr) {
        sal_free(data_ctrl);
        return (BCM_E_MEMORY);
    }

    /* Initialize UDF offset geometry. */
    data_ctrl->elem_size = 2;
    data_ctrl->num_elems = 8;

    /* Initialize stage data control structure. */
    stage_fc->data_ctrl = data_ctrl;
    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_instance_slice_counters_alloc
 *
 * Purpose:
 *    Allocate counters usage bitmap for a slice in an instance.
 *
 * Parameters:
 *     unit - (IN) BCM device number.
 *     fs - (IN/OUT) Slice control structure.
 *
 * Returns:
 *    BCM_E_PARAM   - NULL slice structure pointer.
 *    BCM_E_MEMORY  - Allocation failure.
 *    BCM_E_NONE    - Success.
 */
STATIC int
_field_th_instance_slice_counters_alloc(int unit, _field_slice_t *fs)
{
    int size; /* Allocation size. */

    /* Input parameters check. */
    if (NULL == fs) {
        return (BCM_E_PARAM);
    }

    /* Determine the counter bit array size. */
    size = SHR_BITALLOCSIZE(fs->counters_count);

    /* Allocate counter usage map memory. */
    fs->counter_bmp.w = sal_alloc(size, "fp_counter_map");
    if (NULL == fs->counter_bmp.w) {
        return (BCM_E_MEMORY);
    }
    sal_memset(fs->counter_bmp.w, 0, size);
    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_counters_deinit
 *
 * Purpose:
 *    Deinitialize slice counter usage bitmap for all instances in a stage.
 *
 * Parameters:
 *    unit - (IN) BCM device number
 *    stage_fc - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *     BCM_E_NONE - Success
 */
STATIC int
_field_th_counters_deinit(int unit, _field_stage_t *stage_fc)
{
    int slice; /* Slice iterator. */
    int inst; /* Instance iterator. */
    _field_control_t    *fc;            /* Field control structure.       */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_NONE);
    }

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /*
     * VFP and IFP use Flex counter pools, skip per-slice
     * counter bitmap allocation.
     */
    if (_BCM_FIELD_STAGE_LOOKUP == stage_fc->stage_id
        || _BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) {
        return (BCM_E_NONE);
    }

    /* Counters usage bitmap is maintained only for slice_0 in EFP. */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {
             continue;
        }
        /* Free counter usage bitmap in slice_0 for each instance. */
        if (NULL != stage_fc->slices[inst][0].counter_bmp.w) {
            sal_free(stage_fc->slices[inst][0].counter_bmp.w);
        }

        /* Initialize counter usage bitmap pointer value to NULL. */
        for (slice = 0; slice < stage_fc->tcam_slices; slice++) {
            stage_fc->slices[inst][slice].counter_bmp.w = NULL;
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_counters_init
 *
 * Purpose:
 *    Initialize slice counter usage bitmap for all slices in a stage.
 *
 * Parameters:
 *     unit - (IN) BCM device number.
 *     fc - (IN) Field control structure.
 *     stage_fc - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *    BCM_E_PARAM - Null field control structure or stage control parameter.
 *    BCM_E_INTERNAL - Null stage slice control structure.
 *    BCM_E_MEMORY - Allocation failure.
 *    BCM_E_NONE - Success.
 */
STATIC int
_field_th_counters_init(int unit,
                        _field_control_t *fc,
                        _field_stage_t *stage_fc)
{
    _field_slice_t *fs; /* Slice config structure. */
    int slice; /* Slice iterator. */
    int inst; /* Instance iterator. */
    int rv; /* Operation return value. */
    int cntr_share = FALSE; /* Share counter with slice_0 */


    /* Input parameters check. */
    if (NULL == stage_fc || NULL == fc) {
        return (BCM_E_PARAM);
    }

    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {
             continue;
        }
        for (slice = 0; slice < stage_fc->tcam_slices; slice++) {

            /* Get the slice pointer. */
            fs = stage_fc->slices[inst] + slice;

            /*
             * VFP and IFP use flex counter resources hence slice
             * counters count is zero.
             */
            if ((_BCM_FIELD_STAGE_LOOKUP == stage_fc->stage_id)
                || (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)
                || (_BCM_FIELD_STAGE_EXACTMATCH == stage_fc->stage_id)
                || (_BCM_FIELD_STAGE_FLOWTRACKER == stage_fc->stage_id)
                || (_BCM_FIELD_STAGE_AMFTFP == stage_fc->stage_id)
                || (_BCM_FIELD_STAGE_AEFTFP == stage_fc->stage_id)) {
                fs->counters_count = 0;
                continue;
            }

            /* Initialize counters for EFP stage. */
            fs->counters_count = soc_mem_index_count(unit, EFP_COUNTER_TABLEm);

            /*
             * All EFP slices share the same global counter pool.
             * For slices > 0, counter sharing is TRUE.
             */
            if (slice) {
                cntr_share = TRUE;
            }

            /* Share counters with slice zero (Global counter pool). */
            if (cntr_share) {
                stage_fc->slices[inst][slice].counter_bmp.w =
                    stage_fc->slices[inst][0].counter_bmp.w;
            } else {
                /* Allocate new set of counters for the slice. */
                rv = _field_th_instance_slice_counters_alloc(unit, fs);
                if (BCM_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "FP(unit %d) Error: "
                        "_field_th_instance_slice_counters_alloc=%d\n"),
                         unit, rv));
                    _field_th_counters_deinit(unit, stage_fc);
                    return (rv);
                }
            }
        }
        cntr_share = FALSE;
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_keygen_profiles_init
 * Purpose:
 *   Initialize keygen program profiles based on group operational mode.
 * Parameters:
 *     unit - (IN) BCM device number.
 *     stage_fc - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *    BCM_E_PARAM - Null field control structure or stage control parameter.
 *    BCM_E_INTERNAL - Null stage slice control structure.
 *    BCM_E_MEMORY - Allocation failure.
 *    BCM_E_NONE - Success.
 */
int
_field_th_keygen_profiles_init(int unit, _field_stage_t *stage_fc,
                               _field_control_t *fc)
{
    soc_mem_t mem[2];               /* SOC memory names.                  */
    int entry_words[2];             /* Entry size in words.               */
    int inst;                       /* Instance iterator.                 */
    int rv;                         /* Operation return status.           */

    /* Input parameter check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    switch (stage_fc->oper_mode) {
        /* Field Groups operational in Global mode. */
        case bcmFieldGroupOperModeGlobal:

            if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
                /* Initialize profile1 memory name. */
                mem[0] = IFP_KEY_GEN_PROGRAM_PROFILEm;

                /* Initialize profile2 memory name. */
                mem[1] = IFP_KEY_GEN_PROGRAM_PROFILE2m;

                /* Determine keygen profile entry size in number of words. */
                entry_words[0] = soc_mem_entry_words(unit, mem[0]);

                /* Determine post mux profile entry size in number of words. */
                entry_words[1] = soc_mem_entry_words(unit, mem[1]);

                /* Create keygen program profile table. */
                rv = soc_profile_mem_create(unit, mem, entry_words, 2,
                        &stage_fc->keygen_profile[_FP_DEF_INST].profile);
                if (BCM_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "FP(unit %d) Error: Ingress "
                        "Keygen profile creation failed."
                        "=%d\n"), unit, rv));
                    return (rv);
                }
            } else if (stage_fc->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {

                /* Initialize profile memory name. */
                mem[0] = EXACT_MATCH_KEY_GEN_PROGRAM_PROFILEm;

                /* Initialize keygen mask profile memory name */
                mem[1] = EXACT_MATCH_KEY_GEN_MASKm;

                /* Determine keygen profile entry size in number of words. */
                entry_words[0] = soc_mem_entry_words(unit, mem[0]);

                /* Determine keygen mask profile entry size in words. */
                entry_words[1] = soc_mem_entry_words(unit, mem[1]);

                /* Create keygen program profile table. */
                rv = soc_profile_mem_create(unit, mem, entry_words, 2,
                        &stage_fc->keygen_profile[_FP_DEF_INST].profile);

                if (BCM_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "FP(unit %d) Error: Exact Match "
                        "Keygen profile creation failed."
                        "=%d\n"), unit, rv));
                    return (rv);
                }
            } else {
                /* Invalid stage id */
                return (BCM_E_INTERNAL);
            }
            break;

        /* Field Groups operational in Per-Pipe mode. */
        case bcmFieldGroupOperModePipeLocal:

            if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
                /* Determine keygen profiles entry size in number of words. */
                entry_words[0] = soc_mem_entry_words(unit,
                        IFP_KEY_GEN_PROGRAM_PROFILE_PIPE0m);
                entry_words[1] = soc_mem_entry_words(unit,
                        IFP_KEY_GEN_PROGRAM_PROFILE2_PIPE0m);

                for (inst = 0; inst < stage_fc->num_instances; inst++) {
                    if (!(fc->pipe_map & (1 << inst))) {
                         continue;
                    }
                    /* Initialize keygen program profile1 memory name. */
                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                               IFP_KEY_GEN_PROGRAM_PROFILEm,
                                               inst,
                                               &mem[0]));
                    /* Initialize keygen program profile2 memory name. */
                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                               IFP_KEY_GEN_PROGRAM_PROFILE2m,
                                               inst,
                                               &mem[1]));

                    /* Create keygen program profile table. */
                    rv = soc_profile_mem_create(unit, mem, entry_words, 2,
                            &stage_fc->keygen_profile[inst].profile);
                    if (BCM_FAILURE(rv)) {
                        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                           "FP(unit %d) Error: Ingress "
                           "KeyGen profile creation failed."
                           "=%d\n"), unit, rv));
                        return (rv);
                    }
                }
            } else if (stage_fc->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {

                /* Determine keygen profiles entry size in number of words. */
                entry_words[0] = soc_mem_entry_words(unit,
                        EXACT_MATCH_KEY_GEN_PROGRAM_PROFILE_PIPE0m);
                entry_words[1] = soc_mem_entry_words(unit,
                        EXACT_MATCH_KEY_GEN_MASK_PIPE0m);

                for (inst = 0; inst < stage_fc->num_instances; inst++) {
                    if (!(fc->pipe_map & (1 << inst))) {
                         continue;
                    }
                    /* Initialize keygen program profile memory name. */
                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                         EXACT_MATCH_KEY_GEN_PROGRAM_PROFILEm,
                                         inst,
                                         &mem[0]));
                    /* Initialize keygen mask memory name. */
                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                               EXACT_MATCH_KEY_GEN_MASKm,
                                               inst,
                                               &mem[1]));
                    /* Create keygen program profile table. */
                    rv = soc_profile_mem_create(unit, mem, entry_words, 2,
                            &stage_fc->keygen_profile[inst].profile);

                    if (BCM_FAILURE(rv)) {
                        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                           "FP(unit %d) Error: Exact Match "
                           "KeyGen profile creation failed."
                           "=%d\n"), unit, rv));
                        return (rv);
                    }
                }
            } else {
                /* Invalid stage id */
                return (BCM_E_INTERNAL);
            }
            break;

        default:
            /*
             * Invalid Group Operational mode, should never hit this condition.
             */
            return (BCM_E_INTERNAL);
    }

    return (BCM_E_NONE);
}

/*
 *  Function:
 *     _field_th_stage_core_init
 * Purpose:
 *    Initialize all data structures related to a Field Pipeline stage.
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     fc           - (IN/OUT) Field control structure.
 *     stage_fc     - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *    BCM_E_PARAM - Null field control structure or stage control parameter.
 *    BCM_E_INTERNAL - Invalid CAP stage detected.
 *    BCM_E_MEMORY - Allocation failure.
 *    BCM_E_NONE - Success.
 */
STATIC int
_field_th_stage_core_init(int unit,
                          _field_control_t *fc,
                          _field_stage_t *stage_fc)
{
    int rv = BCM_E_INTERNAL; /* Operation return value. */
    int entry_words; /* Redirection profile entry size. */
    soc_mem_t mem; /* SOC Memory name variable. */
    int map_id; /* Virtual Group entry iterator. */
    int idx; /* Virtual priority iterator. */
    int inst; /* Pipe Instance. */

    /* Input prameters check. */
    if ((NULL == fc) || (NULL == stage_fc)) {
        return (BCM_E_PARAM);
    }

    /* Initialize stage slices information. */
    rv = _field_th_slices_init(unit, stage_fc, fc);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "FP(unit %d) Error: _field_th_slices_init=%d\n"), unit, rv));
        _field_th_stage_delete(unit, fc, stage_fc);
        return (rv);
    }

    /* Initialize stage slices entries information. */
    rv = _field_th_entries_init(unit, stage_fc, fc);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "FP(unit %d) Error: _field_th_entries_init=%d\n"), unit, rv));
        _field_th_stage_delete(unit, fc, stage_fc);
        return (rv);
    }

    /* Initialize Meters. */
    rv = _field_th_meters_init(unit, stage_fc, fc);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "FP(unit %d) Error: _field_th_meters_init=%d\n"), unit, rv));
        _field_th_stage_delete(unit, fc, stage_fc);
        return (rv);
    }

    /* Initialize counters usage bitmap. */
    rv = _field_th_counters_init(unit, fc, stage_fc);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "FP(unit %d) Error: _field_th_counters_init=%d\n"), unit, rv));
        _field_th_stage_delete(unit, fc, stage_fc);
        return (rv);
    }

    /* Action profile; will be setup in chip-specific init */
    soc_profile_mem_t_init(&stage_fc->ext_act_profile);

    /* Redirection action profile table initialization. */
    if (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) {

        /* Initialize regular keygen and post mux keygen program profiles. */
        rv = _field_th_keygen_profiles_init(unit, stage_fc, fc);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                "FP(unit %d) Error: _field_th_keygen_profiles_init=%d\n"),
                 unit, rv));
            _field_th_stage_delete(unit, fc, stage_fc);
            return (rv);
        }

        /* Initialize range checker seed ID value. */
        stage_fc->range_id = 1;
        if (soc_feature(unit, soc_feature_udf_support)) {
            /* Initialize stage data control information. */
            rv = _field_th_stage_data_ctrl_init(unit, stage_fc);
            if (BCM_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                    "FP(unit %d) Error: _field_th_stage_data_ctrl_init=%d\n"),
                     unit, rv));
                 _field_th_stage_delete(unit, fc, stage_fc);
                 return (rv);
             }
         }
    }

    switch (stage_fc->stage_id) {

        case _BCM_FIELD_STAGE_LOOKUP:
            /* hash select action memory profile initialization. */
            soc_profile_mem_t_init(&stage_fc->hash_select[0]);
            soc_profile_mem_t_init(&stage_fc->hash_select[1]);

            /* Hash select 0 action profile table initialization. */
            if (SOC_MEM_IS_VALID(unit, VFP_HASH_FIELD_BMAP_TABLE_Am)) {
                mem = VFP_HASH_FIELD_BMAP_TABLE_Am;
                entry_words = sizeof(vfp_hash_field_bmap_table_a_entry_t) /
                                 sizeof(uint32);
                rv = soc_profile_mem_create(unit, &mem, &entry_words, 1,
                                             &stage_fc->hash_select[0]);

                if (BCM_FAILURE(rv)) {
                    _field_th_stage_delete(unit, fc, stage_fc);
                    return (rv);
                }
            }
            /* Hash select 1 action profile table initialization. */
            if (SOC_MEM_IS_VALID(unit, VFP_HASH_FIELD_BMAP_TABLE_Bm)) {
                mem = VFP_HASH_FIELD_BMAP_TABLE_Bm;
                entry_words = sizeof(vfp_hash_field_bmap_table_a_entry_t) /
                                 sizeof(uint32);
                rv = soc_profile_mem_create(unit, &mem, &entry_words, 1,
                                             &stage_fc->hash_select[1]);

                if (BCM_FAILURE(rv)) {
                    _field_th_stage_delete(unit, fc, stage_fc);
                    return (rv);
                }
            }
            /*
             * Index 0 of vfp_hash_field_bmap_table_a/b is invalid as the
             * hardware will consider hash bitmap selection from VFP only
             * if HASH_FIELD_BITMAP_PTR_A and HASH_FIELD_BITMAP_PTR_B are non-zero.
             * Making the entry to NULL.
             */
            rv = _bcm_field_td2_hash_select_profile_alloc_reserve_entry(unit,
                                                                    stage_fc);
            if (BCM_FAILURE(rv)) {
                _field_th_stage_delete(unit, fc, stage_fc);
                return (rv);
            }
        /* passthru */
        /* coverity[MISSING_BREAK: FALSE] */
        case _BCM_FIELD_STAGE_EGRESS:
            /* Initializing supported Qset*/
            sal_memset(&stage_fc->_field_supported_qset, 0, sizeof(bcm_field_qset_t));
            /*
             * Initialize the FP_SLICE_MAP for VFP and EFP.
             *     Physical_slice and virtual_group are H/W initial values
             */
            for (inst = 0; inst < stage_fc->num_instances; inst++) {
               if (!(fc->pipe_map & (1 << inst))) {
                    continue;
               }
               for (map_id = 0; map_id < _FP_VMAP_CNT; map_id++) {
                   for (idx = 0; idx < _FP_VMAP_SIZE; idx++) {
                       stage_fc->vmap[inst][map_id][idx].valid = FALSE;
                       stage_fc->vmap[inst][map_id][idx].vmap_key = idx;
                       stage_fc->vmap[inst][map_id][idx].virtual_group = idx;
                       stage_fc->vmap[inst][map_id][idx].flags = 0;
                   }
               }
            }
            break;

        case _BCM_FIELD_STAGE_INGRESS:
            /* Initialize group running priority */ 
            stage_fc->group_running_prio = BCM_FIELD_GROUP_PRIO_ANY;

            /* Initializing supported Qset*/
            sal_memset(&stage_fc->_field_supported_qset, 0, sizeof(bcm_field_qset_t));
            /* Initialize stage Preselector information. */
            rv = _bcm_field_th_stage_preselector_init(unit, fc, stage_fc);
            if (BCM_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                    "FP(unit %d) Error: _bcm_field_th_stage_preselector_init=%d"
                    "\n"), unit, rv));
                _field_th_stage_delete(unit, fc, stage_fc);
                return (rv);
            }

            /*
             * Initialize stage's extractor configuration for various slice
             * modes.
             */
#if defined (BCM_TOMAHAWK3_SUPPORT)
            if (soc_feature(unit, soc_feature_th3_style_fp)) {
                rv = _bcm_field_th3_extractors_init(unit, stage_fc);
            } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
            {
                rv = _field_th_stage_extractors_init(unit, stage_fc);
            }

            if (BCM_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                    "FP(unit %d) Error: _field_th_stage_extractors_init=%d\n"),
                    unit, rv));
                _field_th_stage_delete(unit, fc, stage_fc);
                return (rv);
            }
#if defined(BCM_TRIDENT3_SUPPORT)
            if (soc_feature(unit, soc_feature_td3_style_fp)) {
                /* Intialize IFP_EM_DROP_VECTOR_MASK with default value */
                rv = _bcm_field_td3_drop_vector_mask_init(unit);
                if (BCM_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "FP(unit %d) Error: _bcm_field_td3_drop_vector_mask_init=%d\n"),
                         unit, rv));
                    _field_th_stage_delete(unit, fc, stage_fc);
                    return (rv);
                }

                /* Initialize InPorts flex support. */
                rv = _bcm_field_td3_inports_flex_init(unit);
                if (BCM_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "FP(unit %d) Error: _bcm_field_td3_inports_flex_init=%d\n"),
                         unit, rv));
                    _field_th_stage_delete(unit, fc, stage_fc);
                    return (rv);
                }
                /* Initialize IFP qualifers to HW input bus fields & offsets. */
                rv = _field_td3_stage_quals_ibus_map_init(unit, stage_fc);
            } else
#endif
#if defined(BCM_TOMAHAWK3_SUPPORT)
            if (soc_feature(unit, soc_feature_th3_style_fp)) {
                rv = _bcm_field_th3_qualifiers_init(unit, stage_fc);
            } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
            {
                rv = _field_th_stage_quals_ibus_map_init(unit, stage_fc);
            }

            if (BCM_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                    "FP(unit %d) Error: _field_th_stage_extractors_init=%d\n"),
                    unit, rv));
                _field_th_stage_delete(unit, fc, stage_fc);
                return (rv);
            }
#if defined(BCM_TRIDENT3_SUPPORT)
            /* Initialize action profiles */
            if (soc_feature(unit, soc_feature_ifp_action_profiling)) {
                _field_td3_ingress_action_profiles_init(unit, stage_fc);
            }
#endif
#if defined(BCM_FIREBOLT6_SUPPORT)
            if (soc_feature(unit, soc_feature_field_aacl_compression)) {
                rv = _field_fb6_compress_init(unit, stage_fc);

                if (BCM_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "FP(unit %d) Error: _field_fb6_compress_init=%d\n"),
                        unit, rv));
                    _field_th_stage_delete(unit, fc, stage_fc);
                    return (rv);
                }
            }
#endif
            break;
        case _BCM_FIELD_STAGE_EXACTMATCH:
            /* Initialize stage control for exact match */
            rv = _field_th_emstage_init(unit, fc, stage_fc);
            if (BCM_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                          "FP(unit %d) Error: _field_th_emstage_init=%d\n"),
                          unit, rv));
                _field_th_stage_delete(unit, fc, stage_fc);
                return (rv);
            }
            break;
#if defined(BCM_FLOWTRACKER_SUPPORT)
        case _BCM_FIELD_STAGE_FLOWTRACKER:
            /* Initalize stage control for Flowtracker */
            rv = _field_hx5_ftstage_init(unit, fc, stage_fc);
            if (BCM_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                    "FP(unit %d) Error: _field_hx5_ftstage_init=%d"
                    "\n"), unit, rv));
                _field_th_stage_delete(unit, fc, stage_fc);
                return (rv);
            }
            break;
#endif
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
        case _BCM_FIELD_STAGE_AMFTFP:
            /* Initalize stage control for Aggregate Mmu Flowtracker */
            rv = _field_fb6_amftstage_init(unit, fc, stage_fc);
            if (BCM_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                    "FP(unit %d) Error: _field_fb6_amftstage_init=%d"
                    "\n"), unit, rv));
                _field_th_stage_delete(unit, fc, stage_fc);
                return (rv);
            }
            break;
        case _BCM_FIELD_STAGE_AEFTFP:
            /* Initalize stage control for Aggregate Egress Flowtracker */
            rv = _field_fb6_aeftstage_init(unit, fc, stage_fc);
            if (BCM_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                    "FP(unit %d) Error: _field_fb6_aeftstage_init=%d"
                    "\n"), unit, rv));
                _field_th_stage_delete(unit, fc, stage_fc);
                return (rv);
            }
            break;
#endif
        default:
            /* Should never hit this condition. */
            return (BCM_E_INTERNAL);
    }

    FP_LOCK(unit);

    /* Add stage to Field Control structure. */
    stage_fc->next = fc->stages;
    fc->stages = stage_fc;

    FP_UNLOCK(unit);

    return (rv);
}

/*
 * Function:
 *    _field_th_stage_add
 *
 * Purpose:
 *    Initialize all data structures related to a field stage.
 *
 * Parameters:
 *     unit - (IN) BCM device number.
 *     fc - (IN/OUT) Field control structure.
 *     stage_id - (IN) Field processor stage ID.
 *
 * Returns:
 *    BCM_E_PARAM - Null field control structure.
 *    BCM_E_INTERNAL - Null stage slice control structure.
 *    BCM_E_MEMORY - Allocation failure.
 *    BCM_E_NONE - Success.
 */
STATIC int
_field_th_stage_add(int unit,
                    _field_control_t *fc,
                    _field_stage_id_t stage_id,
                    bcm_field_group_oper_mode_t mode)
{
    int rv = BCM_E_INTERNAL; /* Operation return value. */
    _field_stage_t *stage_fc; /* Stage information. */
    int entry_ratio = 1;  /* Valid entries ratio.*/

    /* Input parameter check. */
    if (NULL == fc) {
        return (BCM_E_PARAM);
    }

    /* Allocate field stage structure instance memory. */
    stage_fc = sal_alloc(sizeof(_field_stage_t), "FP stage info.");
    if (NULL == stage_fc) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "FP(unit %d) Error: Allocation failure for stage info\n"), unit));
        return (BCM_E_MEMORY);
    }

    /* Clear contents of allocated buffer. */
    sal_memset(stage_fc, 0, sizeof(_field_stage_t));

    /* Initialize FP stage. */
    stage_fc->stage_id = stage_id;

    /* By default all CAP stages come up in Global mode (Legacy TD2). */
    if (bcmFieldGroupOperModeCount == mode) {
        if ((stage_id == _BCM_FIELD_STAGE_INGRESS) ||
            (stage_id == _BCM_FIELD_STAGE_LOOKUP) ||
            (stage_id == _BCM_FIELD_STAGE_EGRESS)) {
           /* Initialize the SER during init for the given default mode. */
           rv = (_field_ser_oper_mode_init(unit, stage_id,
                                        bcmFieldGroupOperModeGlobal));
           if (BCM_FAILURE(rv)) {
               if (NULL != stage_fc) {
                   sal_free(stage_fc);
               }
               return (rv);
           }
        }
        stage_fc->oper_mode = bcmFieldGroupOperModeGlobal;
    } else {
        /* Default Group oper mode modified using Group oper mode API. */
        stage_fc->oper_mode = mode;
    }

    /*
     * Initialize number of FP data structure instances to be supported
     * per-stage.
     */
    stage_fc->num_pipes = NUM_PIPE(unit);

    if (bcmFieldGroupOperModePipeLocal == stage_fc->oper_mode) {
        /*
         * Initialize number of FP instances to number of pipes supported in
         * hardware.
         */
        stage_fc->num_instances = stage_fc->num_pipes;
    } else {
        /* Initialize to legacy TD2 mode - Global mode (single instance). */
        stage_fc->num_instances = 1;
    }

    switch (stage_fc->stage_id) {
        case _BCM_FIELD_STAGE_LOOKUP:
            /* Flags */
            stage_fc->flags |= (_FP_STAGE_SLICE_ENABLE
                                | _FP_STAGE_AUTO_EXPANSION
                                | _FP_STAGE_GLOBAL_COUNTERS);
            /* Slice geometry */
            stage_fc->tcam_sz     = soc_mem_index_count(unit, VFP_TCAMm);
            stage_fc->tcam_slices = 4;
            break;

        case _BCM_FIELD_STAGE_INGRESS:
            /* Flags */
            stage_fc->flags |= (_FP_STAGE_SLICE_ENABLE
                                | _FP_STAGE_AUTO_EXPANSION
                                | _FP_STAGE_GLOBAL_METER_POOLS
                                | _FP_STAGE_GLOBAL_COUNTERS
                                | _FP_STAGE_MULTI_PIPE_COUNTERS);
#ifdef BCM_FIREBOLT6_SUPPORT
            if (soc_feature(unit, soc_feature_field_aacl_compression)) {
                stage_fc->flags |=  _FP_STAGE_COMPRESSION;
            }
#endif
            /*
             * Initialize Slice geometry.
             *     Number of entries in TCAM remains the same for both duplicate
             *     and unique views. Use duplicate view to calculate TCAM size.
             *     Initialize to maximum entries supported per-slice (80bit
             *     mode).
             */
            if (soc_feature(unit, soc_feature_field_stage_half_slice)) {
                entry_ratio = 2;
            } else if (soc_feature(unit, soc_feature_field_stage_quarter_slice)) {
                entry_ratio = 4;
            }
            stage_fc->tcam_sz = soc_mem_index_count(unit, IFP_TCAMm) / entry_ratio;

            /* Number of hardware slices is equal to maximum number of LT parts. */
            stage_fc->tcam_slices = _FP_MAX_LT_PARTS(unit);

            /* Initialize number of logical tables supported by device. */
            if (SOC_IS_TOMAHAWK3(unit)) {
                stage_fc->num_logical_tables = 16;
            } else {
                stage_fc->num_logical_tables = 32;
            }

            /*
             * Initialize number of valid entries in Logical Table selection
             * TCAM.
             */
            stage_fc->lt_tcam_sz = stage_fc->tcam_slices
                                    * stage_fc->num_logical_tables;
            /* Initialize number of extractor levels */
            stage_fc->num_ext_levels = 4;
            /* Initialize the action set pointer. */
            if (soc_feature(unit, soc_feature_ifp_action_profiling)) {
                stage_fc->action_set_ptr = bcm_field_td3_ifp_action_set;
#if defined(BCM_FIREBOLT6_SUPPORT)
                if (SOC_IS_FIREBOLT6(unit)) {
                    stage_fc->action_set_ptr = bcm_field_fb6_ifp_action_set;
                } else
#endif
#if defined(BCM_HURRICANE4_SUPPORT)
                if (SOC_IS_HURRICANE4(unit)) {
                    stage_fc->action_set_ptr = bcm_field_hr4_ifp_action_set;
                } else
#endif
#if defined(BCM_HELIX5_SUPPORT)
                if (SOC_IS_HELIX5(unit)) {
                    stage_fc->action_set_ptr = bcm_field_hx5_ifp_action_set;
                }
#endif
            }
            break;

        case _BCM_FIELD_STAGE_EGRESS:
            /* Flags */
            stage_fc->flags |= (_FP_STAGE_SLICE_ENABLE
                                | _FP_STAGE_GLOBAL_COUNTERS
                                | _FP_STAGE_SEPARATE_PACKET_BYTE_COUNTERS
                                | _FP_STAGE_AUTO_EXPANSION
                                | _FP_STAGE_MULTI_PIPE_COUNTERS);
            /* Slice geometry */
            stage_fc->tcam_sz = soc_mem_index_count(unit, EFP_TCAMm);
            stage_fc->tcam_slices = 4;
            break;
        case _BCM_FIELD_STAGE_CLASS:
            rv = _bcm_field_th_class_stage_add(unit, fc, stage_fc);
            if (BCM_FAILURE(rv)) {
                sal_free(stage_fc);
            }
            return (rv);
        case _BCM_FIELD_STAGE_EXACTMATCH:
            stage_fc->flags |= (_FP_STAGE_SLICE_ENABLE
                                | _FP_STAGE_GLOBAL_METER_POOLS
                                | _FP_STAGE_GLOBAL_COUNTERS
                                | _FP_STAGE_MULTI_PIPE_COUNTERS);
            stage_fc->tcam_sz = soc_mem_index_count(unit, EXACT_MATCH_2m);
            stage_fc->tcam_slices = 2;
            if (SOC_IS_TOMAHAWK3(unit)) {
                stage_fc->num_logical_tables = 16;
            } else {
                stage_fc->num_logical_tables = _FP_MAX_NUM_LT;
            }
            stage_fc->lt_tcam_sz = stage_fc->tcam_slices
                * stage_fc->num_logical_tables;
            stage_fc->num_ext_levels = 4;
            /* Initialize the action set pointer. */
            if (soc_feature(unit, soc_feature_ifp_action_profiling)) {
                if (SOC_IS_FIREBOLT6(unit)) {
                    stage_fc->action_set_ptr = bcm_field_fb6_em_action_set;
                } else {
                    stage_fc->action_set_ptr = bcm_field_td3_em_action_set;
                }
            } else if (soc_feature(unit, soc_feature_th3_style_fp)) {
                stage_fc->action_set_ptr = bcm_field_th3_em_action_set;
            } else if (soc_feature(unit, soc_feature_field_multi_pipe_enhanced)) {
                stage_fc->action_set_ptr = bcm_field_th2_em_action_set;
            } else {
                stage_fc->action_set_ptr = bcm_field_th_em_action_set;
            }
        break;
#if defined(BCM_FLOWTRACKER_SUPPORT)
        case _BCM_FIELD_STAGE_FLOWTRACKER:
            if (soc_feature(unit, soc_feature_field_flowtracker_support)) {
                stage_fc->flags |= (_FP_STAGE_SLICE_ENABLE);
                stage_fc->tcam_slices = 1;
                stage_fc->num_logical_tables = 1;
                stage_fc->tcam_sz =
                    soc_mem_index_max(unit, BSK_FTFP_TCAMm) -
                    soc_mem_index_min(unit, BSK_FTFP_TCAMm) + 1;
                stage_fc->lt_tcam_sz =
                    soc_mem_index_max(unit, BSK_FTFP_LTS_LOGICAL_TBL_SEL_TCAMm) -
                    soc_mem_index_min(unit, BSK_FTFP_LTS_LOGICAL_TBL_SEL_TCAMm) + 1;
            }
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
            if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
                stage_fc->tcam_slices++;
                stage_fc->num_logical_tables++;
                stage_fc->tcam_sz +=
                    soc_mem_index_max(unit, BSK_FTFP2_TCAMm) -
                    soc_mem_index_min(unit, BSK_FTFP2_TCAMm) + 1;
                stage_fc->lt_tcam_sz +=
                    soc_mem_index_max(unit, BSK_FTFP2_LTS_LOGICAL_TBL_SEL_TCAMm) -
                    soc_mem_index_min(unit, BSK_FTFP2_LTS_LOGICAL_TBL_SEL_TCAMm) + 1;
            }
#endif
        break;
#endif
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
        case _BCM_FIELD_STAGE_AMFTFP:
            if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
                stage_fc->flags |= (_FP_STAGE_SLICE_ENABLE);
                stage_fc->tcam_slices = 1;
                stage_fc->num_logical_tables = 0;
                stage_fc->tcam_sz = soc_mem_index_max(unit, BSK_AMFP_TCAMm) -
                    soc_mem_index_min(unit, BSK_AMFP_TCAMm) + 1;
                stage_fc->lt_tcam_sz = 0;
            }
            break;
        case _BCM_FIELD_STAGE_AEFTFP:
            if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
                stage_fc->flags |= (_FP_STAGE_SLICE_ENABLE);
                stage_fc->tcam_slices = 1;
                stage_fc->num_logical_tables = 0;
                stage_fc->tcam_sz = soc_mem_index_max(unit, BSK_AEFP_TCAMm) -
                    soc_mem_index_min(unit, BSK_AEFP_TCAMm) + 1;
                stage_fc->lt_tcam_sz = 0;
            }
            break;
#endif

        default:
            if (NULL != stage_fc) {
                sal_free(stage_fc);
            }
            return (rv);
    }

    /*
     * Initialize Field Stage attributes. On error condition, memory location
     * pointed by "stage_fc" pointer is freed inside this routine in error
     * return section. So, no need to free again in the error return section.
     * No need to do stage core init for stage class as it is a pseudo stage.
     */
    rv = _field_th_stage_core_init(unit, fc, stage_fc);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "FP(unit %d) Error: _field_th_stage_core_init=%d\n"), unit, rv));
    }

    return (rv);
}

/*
 * Function:
 *    _bcm_field_th_stages_delete
 *
 * Purpose:
 *    Deinitialize a field stage.
 *
 * Parameters:
 *    unit - (IN) BCM device number.
 *    fc - (IN/OUT)Field control info for device.
 *
 * Returns:
 *    BCM_E_PARAM - Null field control structure.
 *    BCM_E_NONE - Success.
 */
int
_bcm_field_th_stages_delete(int unit, _field_control_t *fc)
{
    int rv = BCM_E_NONE;
    _field_stage_t *stage_fc      = NULL; /* Stage field control structure. */
    _field_stage_t *stage_fc_next = NULL; /* Stage field control structure. */

    /* Input parameters check. */
    if (NULL == fc) {
        return (BCM_E_PARAM);
    }

    FP_LOCK(unit);

    stage_fc = fc->stages;
    /* Free stages slices structures. */
    while (NULL != stage_fc) {
        stage_fc_next = stage_fc->next;
        /*
         * Retaining retaining ExactMatch stage during bcm_field_init.
         */
        if ((fc->flags & _FP_EXACTMATCH_STAGE_SKIP_DETACH) &&
            (_BCM_FIELD_STAGE_EXACTMATCH == stage_fc->stage_id)) {
            stage_fc = stage_fc_next;
            continue;
        }
        _field_th_stage_delete(unit, fc, stage_fc);
        stage_fc = stage_fc_next;
    }

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       rv = (_bcm_field_td3_flex_qual_ceh_db_clear(unit));
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *    _bcm_field_th_stages_add
 *
 * Purpose:
 *    Initialize all Field Processor stages of the device.
 *
 * Parameters:
 *    unit - (IN) BCM device number
 *    fc - (IN/OUT) Field control structure.
 *
 * Returns:
 *    BCM_E_PARAM - Null field control structure.
 *    BCM_E_NONE - Success.
 */
int
_bcm_field_th_stages_add(int unit, _field_control_t *fc)
{
    int rv; /* Operation return value. */

    /* Input parameters check. */
    if (NULL == fc) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        BCM_IF_ERROR_RETURN(_bcm_field_td3_flex_qual_ceh_db_init(unit));
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    /* Initialize CAP stages. */
    if (soc_feature(unit, soc_feature_field_multi_stage)) {
        int latency;

        /* Add VFP Stage. */
        rv = _field_th_stage_add(unit, fc, _BCM_FIELD_STAGE_LOOKUP,
                bcmFieldGroupOperModeCount);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "FP(unit %d) Error: _field_th_stage_add(Lookup)=%d\n"), unit, rv));
            _bcm_field_th_stages_delete(unit, fc);
            return (rv);
        }

        /* Add EFP Stage. */
        latency = soc_property_get(unit, spn_SWITCH_BYPASS_MODE,
                                   SOC_SWITCH_BYPASS_MODE_NONE);
        if (SOC_SWITCH_BYPASS_MODE_EFP != latency) {
            rv = _field_th_stage_add(unit, fc, _BCM_FIELD_STAGE_EGRESS,
                                        bcmFieldGroupOperModeCount);
            if (BCM_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                                "FP(unit %d) Error: _field_th_stage_add(Egress)=%d\n"), unit, rv));
                _bcm_field_th_stages_delete(unit, fc);
                return (rv);
            }
        }
    }

    /* Add IFP Stage. */
    rv = _field_th_stage_add(unit, fc, _BCM_FIELD_STAGE_INGRESS,
                                    bcmFieldGroupOperModeCount);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "FP(unit %d) Error: _field_th_stage_add(Ingress)=%d\n"), unit, rv));
        /*
         * Delete all previous stages initialized on this device in case of
         * error.
         */
        _bcm_field_th_stages_delete(unit, fc);
        return (rv);
    }

    /* Add Class Stage. */
    if (soc_feature(unit, soc_feature_field_compression)) {
        rv = _field_th_stage_add(unit, fc, _BCM_FIELD_STAGE_CLASS,
                bcmFieldGroupOperModeCount);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                            "FP(unit %d) Error: "
                            "_field_th_stage_add(Class)=%d\n"), unit, rv));
            /*
             * Delete all previous stages initialized on this device in case of
             * error.
             */
            _bcm_field_th_stages_delete(unit, fc);
            return (rv);
        }
    }

    /*
     * _field_detach doesn't clear Exact Match groups created by Flow Tracker.
     * As ExactMatch stage is not freed no need to initialize it again.
     */
    if (0 == (fc->flags & _FP_EXACTMATCH_STAGE_SKIP_DETACH)) {
        if (soc_feature(unit, soc_feature_field_exact_match_support)) {
            /* Add Exact Match Stage */
            rv = _field_th_stage_add(unit, fc, _BCM_FIELD_STAGE_EXACTMATCH,
                                     bcmFieldGroupOperModeCount);
            if (BCM_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                                "FP(unit %d) Error: "
                                "_field_th_stage_add(Exact Match)=%d\n"), unit, rv));
                _bcm_field_th_stages_delete(unit, fc);
                return (rv);
            }
        }
    } else {
        _field_stage_t *stage_ing = NULL;

        /* Get IFP stage structure */
        for (stage_ing = fc->stages;
            (NULL != stage_ing) && (_BCM_FIELD_STAGE_INGRESS != stage_ing->stage_id);
            stage_ing = stage_ing->next);

        if ((NULL != stage_ing) && soc_feature(unit, soc_feature_field_exact_match_support)) {
            /*
             * ExactMatch Ibus database points to the Ibus database of IFP.
             * Update ExactMacth Ibus database as IFP has been reinitialized
             */
            rv = _field_th_emstage_update(unit, stage_ing);
            if (BCM_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                                "FP(unit %d) Error: "
                                "_field_th_stage_add(Exact Match)=%d\n"), unit, rv));
                _bcm_field_th_stages_delete(unit, fc);
                return (rv);
            }
        }
    }

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_support)) {
        rv = _field_th_stage_add(unit, fc, _BCM_FIELD_STAGE_FLOWTRACKER,
                bcmFieldGroupOperModeCount);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                            "FP(unit %d) Error: "
                            "_field_th_stage_add(Flowtracker)=%d\n"), unit, rv));
            _bcm_field_th_stages_delete(unit, fc);
            return (rv);
        }
    }
#endif

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
        rv = _field_th_stage_add(unit, fc, _BCM_FIELD_STAGE_AMFTFP,
                bcmFieldGroupOperModeCount);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                            "FP(unit %d) Error: "
                            "_field_th_stage_add(Flowtracker)=%d\n"), unit, rv));
            _bcm_field_th_stages_delete(unit, fc);
            return (rv);
        }

        rv = _field_th_stage_add(unit, fc, _BCM_FIELD_STAGE_AEFTFP,
                bcmFieldGroupOperModeCount);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                            "FP(unit %d) Error: "
                            "_field_th_stage_add(Flowtracker)=%d\n"), unit, rv));
            _bcm_field_th_stages_delete(unit, fc);
            return (rv);
        }
    }
#endif

    /* Initialize field control color independent flag by default. */
    fc->flags |= _FP_COLOR_INDEPENDENT;

    /* Initialize device LT entry allocation ID variable. */
    fc->last_allocated_lt_eid = 0;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       rv = (_bcm_field_td3_flex_qual_ceh_db_clear(unit));
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *     _bcm_field_action_insert
 * Purpose:
 *     Add action to stage actions list.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     stage_fc - (IN) Stage field control strucutre.
 *     action   - (IN) Field Action.
 *     ptr      - (IN) FP action info.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_action_insert(int unit, _field_stage_t *stage_fc,
                         int action, _bcm_field_action_offset_t *ptr)
{
    int flag_first;                                /* action allocation flag. */
    int alloc_size;                                /* Memory allocation size. */
    uint32 i = 0;
    uint32 encode_bmp[1] = {0};
    uint32 param_bmp[1] = {0};
    _bcm_field_action_conf_t *f_action;            /* Action configuration.   */
    _bcm_field_action_offset_t *offset_info;       /* Offset Information.     */
    _bcm_field_action_offset_t *new_offset_info;   /* New Offset Information. */

    /* Input parameters check. */
    if ((NULL == ptr) || (NULL == stage_fc) ||
        (action < 0) || (action > _bcmFieldActionCount)) {
        return BCM_E_PARAM;
    }

    if ((_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) &&
        (ptr->flags & _BCM_FIELD_ACTION_NO_IFP_SUPPORT)) {
        return BCM_E_NONE;
    }
    if ((_BCM_FIELD_STAGE_EXACTMATCH == stage_fc->stage_id) &&
        (ptr->flags & _BCM_FIELD_ACTION_NO_EM_SUPPORT)) {
         return BCM_E_NONE;
    }

    f_action = NULL;
    offset_info = NULL;
    new_offset_info = NULL;

    f_action = stage_fc->f_action_arr[action];
    /* Allocate Action descriptor. */
    flag_first = 0;
    if (NULL == f_action) {
        alloc_size = sizeof(_bcm_field_action_conf_t);
        _FP_XGS3_ALLOC(f_action, alloc_size, "FP Action info");
        if (NULL == f_action) {
            return (BCM_E_MEMORY);
        }
        f_action->action = action;
        flag_first = 1;
    } else {
        offset_info = f_action->offset;
        while (NULL != offset_info) {
            if (offset_info->flags & ptr->flags) {
                return BCM_E_EXISTS;
            }
            offset_info = offset_info->next;
        }
    }

    alloc_size = sizeof(_bcm_field_action_offset_t);
    _FP_XGS3_ALLOC(new_offset_info, alloc_size, "FP Action offset info");
    if (NULL == new_offset_info) {
        if (flag_first) {
            if (NULL != f_action) {
                sal_free(f_action);
            }
        }
        return (BCM_E_MEMORY);
    }

    /* Copy new configuration to configuration array. */
    new_offset_info->flags  |= ptr->flags;
    new_offset_info->offset[0] = ptr->offset[0];
    new_offset_info->width[0]  = ptr->width[0];
    new_offset_info->value[0]  = ptr->value[0];
    new_offset_info->offset[1] = ptr->offset[1];
    new_offset_info->width[1]  = ptr->width[1];
    new_offset_info->value[1]  = ptr->value[1];
    new_offset_info->offset[2] = ptr->offset[2];
    new_offset_info->width[2]  = ptr->width[2];
    new_offset_info->value[2]  = ptr->value[2];
    new_offset_info->offset[3] = ptr->offset[3];
    new_offset_info->width[3]  = ptr->width[3];
    new_offset_info->value[3]  = ptr->value[3];
    /* Update the bitmap of offsets which hold encodings */
    for (i = 0; (i < _FP_ACTION_MAX_PARAM_ENC) && (ptr->width[i]); i++) {
        if (-1 != ptr->value[i]) {
            SHR_BITSET(encode_bmp, i);
        } else {
            SHR_BITSET(param_bmp, i);
        }
    }
    /* Single index array is needed to prevent ARRAY_VS_SINGLETON coverity warning */
    new_offset_info->encode_bmp = encode_bmp[0];
    new_offset_info->param_bmp = param_bmp[0];
    new_offset_info->aset      = ptr->aset;
    new_offset_info->next    = f_action->offset;
    f_action->offset = new_offset_info;

    /* Install Action configuration into stage actions array. */
    stage_fc->f_action_arr[action] = f_action;

    return (BCM_E_NONE);
}
/*
 * Function:
 *     _bcm_field_th_action_conflict_check
 * Purpose:
 *     Check if action is conflicted with any other action in the entry.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     f_ent    - (IN) Field entry structure to get policy info from.
 *     action1  - (IN) Action to check(bcmFieldActionXXX)
 *     action   - (IN) Action to check(bcmFieldActionXXX)
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_action_conflict_check(int                unit,
                                    _field_entry_t     *f_ent,
                                    bcm_field_action_t action1,
                                    bcm_field_action_t action)
{
    /* Input parameters check */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }
    if (NULL == f_ent->group) {
        return (BCM_E_PARAM);
    }

    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS ||
        f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        switch (action1) {
            case bcmFieldActionUntaggedPacketPriorityNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionPfcClassNew);
                break;
            case bcmFieldActionPfcClassNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionUntaggedPacketPriorityNew);
                break;
            case bcmFieldActionCosMapNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosMapNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosMapNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosMapNew);
                break;
            case bcmFieldActionGpCosMapNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCopy);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntTos);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpPrioIntCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpUcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpMcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpCosMapNew);
                break;
            case bcmFieldActionYpCosMapNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCopy);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntTos);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpPrioIntCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpUcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpMcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpCosMapNew);
                break;
            case bcmFieldActionRpCosMapNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCopy);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCopy);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntTos);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntTos);
                _FP_ACTIONS_CONFLICT(bcmFieldActionPrioIntCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpPrioIntCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionUcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpUcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpMcastCosQNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionCosMapNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpCosMapNew);
                break;
            case bcmFieldActionGpIntCongestionNotificationNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionGpIntCongestionNotificationNew);
                break;
            case bcmFieldActionYpIntCongestionNotificationNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionYpIntCongestionNotificationNew);
                break;
            case bcmFieldActionRpIntCongestionNotificationNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRpIntCongestionNotificationNew);
                break;
            case bcmFieldActionFabricEHAddOrUpdate:
            case bcmFieldActionRedirect:
            case bcmFieldActionRedirectTrunk:
            case bcmFieldActionRedirectPbmp:
            case bcmFieldActionRedirectVlan:
            case bcmFieldActionUnmodifiedPacketRedirectPort:
            case bcmFieldActionRedirectCancel:
            case bcmFieldActionRedirectBcastPbmp:
            case bcmFieldActionRedirectMcast:
            case bcmFieldActionEgressMask:
            case bcmFieldActionEgressPortsAdd:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirect);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectTrunk);
                _FP_ACTIONS_CONFLICT(bcmFieldActionUnmodifiedPacketRedirectPort);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectVlan);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectBcastPbmp);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectMcast);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressMask);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressPortsAdd);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricEHAddOrUpdate);
                if (!((action1 == bcmFieldActionRedirectPbmp) ||
                      (action1 == bcmFieldActionRedirectBcastPbmp) ||
                      (action1 == bcmFieldActionEgressMask) ||
                      (action1 == bcmFieldActionEgressPortsAdd))) {
                    if (action1 != bcmFieldActionRedirectCancel) {
                        _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                    }
                }
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectPbmp);
                break;
            case bcmFieldActionRedirectIpmc:
            case bcmFieldActionRedirectEgrNextHop:
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirect);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectTrunk);
                _FP_ACTIONS_CONFLICT(bcmFieldActionUnmodifiedPacketRedirectPort);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectVlan);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectBcastPbmp);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectMcast);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressMask);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressPortsAdd);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricEHAddOrUpdate);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlan);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeVlanCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDa);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3ChangeMacDaCancel);
                if (action1 != bcmFieldActionRedirectIpmc) {
                    _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                }
                break;
            case bcmFieldActionChangeL2Fields:
            case bcmFieldActionChangeL2FieldsCancel:
            case bcmFieldActionFabricQueue:
            case bcmFieldActionBFDSessionIdNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2FieldsCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMultipathHash);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionBFDSessionIdNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
                if (action1 != bcmFieldActionFabricQueue) {
                    _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
                }
                if (SOC_INFO(unit).th_ctc_replace_enabled) {
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
                }
                break;
            case bcmFieldActionAddClassTag:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2FieldsCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMultipathHash);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionBFDSessionIdNew);
                if (SOC_INFO(unit).th_ctc_replace_enabled) {
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
                }
                break;
            case bcmFieldActionL3SwitchCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2FieldsCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMultipathHash);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionBFDSessionIdNew);
                if (SOC_INFO(unit).th_ctc_replace_enabled) {
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
                }
                break;
            case bcmFieldActionNewClassId:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2FieldsCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMultipathHash);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionBFDSessionIdNew);
                if (SOC_INFO(unit).th_ctc_replace_enabled) {
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
                }
                break;
            case bcmFieldActionEgressClassSelect:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2FieldsCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMultipathHash);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
                _FP_ACTIONS_CONFLICT(bcmFieldActionBFDSessionIdNew);
                if (SOC_INFO(unit).th_ctc_replace_enabled) {
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
                }
                break;
            case bcmFieldActionL3Switch:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2FieldsCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionBFDSessionIdNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
                if (SOC_INFO(unit).th_ctc_replace_enabled) {
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
                }
                break;
            case bcmFieldActionMultipathHash:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2FieldsCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMultipathHash);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionBFDSessionIdNew);
                if (SOC_INFO(unit).th_ctc_replace_enabled) {
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
                }
                break;
            case bcmFieldActionDstMacNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDstMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2FieldsCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMultipathHash);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionBFDSessionIdNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
                if (SOC_INFO(unit).th_ctc_replace_enabled) {
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
                }
                break;
            case bcmFieldActionSrcMacNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionSrcMacNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2FieldsCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMultipathHash);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionBFDSessionIdNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
                if (SOC_INFO(unit).th_ctc_replace_enabled) {
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
                }
                break;
            case bcmFieldActionOuterVlanNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionOuterVlanNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2FieldsCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMultipathHash);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionBFDSessionIdNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
                if (SOC_INFO(unit).th_ctc_replace_enabled) {
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
                }
                break;
            case bcmFieldActionVnTagNew:
            case bcmFieldActionVnTagDelete:
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2FieldsCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMultipathHash);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionBFDSessionIdNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionVnTagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
                if (SOC_INFO(unit).th_ctc_replace_enabled) {
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
                }
                break;
            case bcmFieldActionEtagNew:
            case bcmFieldActionEtagDelete:
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEtagDelete);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2FieldsCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                _FP_ACTIONS_CONFLICT(bcmFieldActionMultipathHash);
                _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionBFDSessionIdNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectEgrNextHop);
                _FP_ACTIONS_CONFLICT(bcmFieldActionRedirectIpmc);
                if (SOC_INFO(unit).th_ctc_replace_enabled) {
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
                }
                break;
            case bcmFieldActionMirrorEgress:
                if (SOC_INFO(unit).th_ctc_replace_enabled) {
                   _FP_ACTIONS_CONFLICT(bcmFieldActionEtagNew);
                   _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2Fields);
                   _FP_ACTIONS_CONFLICT(bcmFieldActionChangeL2FieldsCancel);
                   _FP_ACTIONS_CONFLICT(bcmFieldActionFabricQueue);
                   _FP_ACTIONS_CONFLICT(bcmFieldActionAddClassTag);
                   _FP_ACTIONS_CONFLICT(bcmFieldActionL3Switch);
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMultipathHash);
                   _FP_ACTIONS_CONFLICT(bcmFieldActionL3SwitchCancel);
                   _FP_ACTIONS_CONFLICT(bcmFieldActionEgressClassSelect);
                   _FP_ACTIONS_CONFLICT(bcmFieldActionNewClassId);
                   _FP_ACTIONS_CONFLICT(bcmFieldActionBFDSessionIdNew);
                   _FP_ACTIONS_CONFLICT(bcmFieldActionMirrorEgress);
                }
                break;
#ifdef	INCLUDE_L3
            case bcmFieldActionDynamicEcmpEnable:
            case bcmFieldActionDynamicEcmpCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDynamicEcmpEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionDynamicEcmpCancel);
                break;
#endif /*INCLUDE_L3*/
            case bcmFieldActionDynamicTrunkEnable:
            case bcmFieldActionDynamicTrunkCancel:
            case bcmFieldActionDynamicHgTrunkEnable:
            case bcmFieldActionDynamicHgTrunkCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionDynamicTrunkEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionDynamicTrunkCancel);
                _FP_ACTIONS_CONFLICT(bcmFieldActionDynamicHgTrunkEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionDynamicHgTrunkCancel);
                break;
            case bcmFieldActionEgressTimeStampInsert:
            case bcmFieldActionEgressTimeStampInsertCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressTimeStampInsert);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressTimeStampInsertCancel);
                break;
            case bcmFieldActionIngressTimeStampInsert:
            case bcmFieldActionIngressTimeStampInsertCancel:
                _FP_ACTIONS_CONFLICT(bcmFieldActionIngressTimeStampInsert);
                _FP_ACTIONS_CONFLICT(bcmFieldActionIngressTimeStampInsertCancel);
                break;
            case bcmFieldActionIntTurnAround:
                _FP_ACTIONS_CONFLICT(bcmFieldActionAssignEditCtrlId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressFlowEncapEnable);
                break;

            case bcmFieldActionIntEncapEnable:
            case bcmFieldActionNshEncapEnable:
                _FP_ACTIONS_CONFLICT(bcmFieldActionAssignEditCtrlId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressFlowEncapEnable);
                /* Intentional fall through for Conflict check */
                /* Fall through */
            case bcmFieldActionIntEncapDisable:
            case bcmFieldActionIntEncapUpdate:
            case bcmFieldActionAddIngOuterVlanToEgrOuterVlan:
            case bcmFieldActionErspan3HdrVlanCosPktCopy:
            case bcmFieldActionGbpClassifierAdd:
            case bcmFieldActionGbpSrcMacMcastBitSet:
            case bcmFieldActionAssignExtractionCtrlId:
            case bcmFieldActionEgressFlowControlEnable:
                _FP_ACTIONS_CONFLICT(bcmFieldActionIntEncapEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNshEncapEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionIntEncapDisable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionIntEncapUpdate);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAddIngOuterVlanToEgrOuterVlan);
                _FP_ACTIONS_CONFLICT(bcmFieldActionErspan3HdrVlanCosPktCopy);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGbpClassifierAdd);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGbpSrcMacMcastBitSet);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAssignExtractionCtrlId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressFlowControlEnable);
                break;
            case bcmFieldActionHiGigTrunkResilientHashEnable:
            case bcmFieldActionHiGigTrunkResilientHashDisable:
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigTrunkResilientHashEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionHiGigTrunkResilientHashDisable);
                break;
            case bcmFieldActionTrunkResilientHashEnable:
            case bcmFieldActionTrunkResilientHashDisable:
                _FP_ACTIONS_CONFLICT(bcmFieldActionTrunkResilientHashEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionTrunkResilientHashDisable);
                break;
            case bcmFieldActionEcmpResilientHashEnable:
            case bcmFieldActionEcmpResilientHashDisable:
                _FP_ACTIONS_CONFLICT(bcmFieldActionEcmpResilientHashEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEcmpResilientHashDisable);
                break;
            case bcmFieldActionElephantLookupEnable:
            case bcmFieldActionElephantLookupDisable:
                _FP_ACTIONS_CONFLICT(bcmFieldActionElephantLookupEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionElephantLookupDisable);
                break;
            case bcmFieldActionElephantQueueEnable:
            case bcmFieldActionElephantQueueDisable:
                _FP_ACTIONS_CONFLICT(bcmFieldActionElephantQueueEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionElephantQueueDisable);
                break;
            case bcmFieldActionElephantColorEnable:
            case bcmFieldActionElephantColorDisable:
                _FP_ACTIONS_CONFLICT(bcmFieldActionElephantColorEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionElephantColorDisable);
                break;
            case bcmFieldActionNshServiceIndex:
                _FP_ACTIONS_CONFLICT(bcmFieldActionAssignOpaqueObject2);
                break;
            case bcmFieldActionNshServicePathId:
                _FP_ACTIONS_CONFLICT(bcmFieldActionAssignOpaqueObject2);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAssignOpaqueObject1);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGbpSrcIdNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAssignNatClassId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGbpDstIdNew);
                break;
            case bcmFieldActionAssignOpaqueObject1:
            case bcmFieldActionGbpSrcIdNew:
            case bcmFieldActionAssignNatClassId:
                _FP_ACTIONS_CONFLICT(bcmFieldActionGbpSrcIdNew);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAssignNatClassId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNshServicePathId);
                break;
            case bcmFieldActionAssignOpaqueObject2:
            case bcmFieldActionGbpDstIdNew:
                _FP_ACTIONS_CONFLICT(bcmFieldActionAssignOpaqueObject2);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNshServicePathId);
                _FP_ACTIONS_CONFLICT(bcmFieldActionNshServiceIndex);
                _FP_ACTIONS_CONFLICT(bcmFieldActionGbpDstIdNew);
                break;
            case bcmFieldActionAssignOpaqueObject3:
            case bcmFieldActionLoopbackSubtype:
            case bcmFieldActionAssignChangeL2FieldsClassId:
                _FP_ACTIONS_CONFLICT(bcmFieldActionAssignOpaqueObject3);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLoopbackSubtype);
                _FP_ACTIONS_CONFLICT(bcmFieldActionAssignChangeL2FieldsClassId);
                break;
            case bcmFieldActionAssignOpaqueObject4:
                _FP_ACTIONS_CONFLICT(bcmFieldActionAssignOpaqueObject4);
                break;
            case bcmFieldActionAssignEditCtrlId:
                _FP_ACTIONS_CONFLICT(bcmFieldActionNshEncapEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionIntEncapEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionIntTurnAround);
                _FP_ACTIONS_CONFLICT(bcmFieldActionEgressFlowEncapEnable);
                break;
            default:
                return  _bcm_field_td2_action_conflict_check(unit,
                                                             f_ent,
                                                             action1,
                                                             action);
                break;
        }
#if defined(BCM_FLOWTRACKER_SUPPORT)
    } else if (f_ent->group->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER) {
        switch(action1) {
            case bcmFieldActionFlowtrackerGroupId:
                _FP_ACTIONS_CONFLICT(bcmFieldActionFlowtrackerGroupId);
                break;
            case bcmFieldActionFlowtrackerEnable:
                _FP_ACTIONS_CONFLICT(bcmFieldActionFlowtrackerEnable);
                break;
            case bcmFieldActionFlowtrackerNewLearnEnable:
                _FP_ACTIONS_CONFLICT(bcmFieldActionFlowtrackerNewLearnEnable);
                break;
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
            case bcmFieldActionFlowtrackerAggregateIngressGroupId:
                _FP_ACTIONS_CONFLICT(bcmFieldActionFlowtrackerAggregateIngressGroupId);
                break;
            case bcmFieldActionFlowtrackerAggregateClass:
                _FP_ACTIONS_CONFLICT(bcmFieldActionFlowtrackerAggregateClass);
                break;
            case bcmFieldActionFlowtrackerAggregateIngressFlowIndex:
                _FP_ACTIONS_CONFLICT(bcmFieldActionFlowtrackerAggregateIngressFlowIndex);
#endif
            default:
                break;
        }
#endif
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    } else if (f_ent->group->stage_id == _BCM_FIELD_STAGE_AMFTFP) {
        switch(action1) {
            case bcmFieldActionFlowtrackerAggregateMmuGroupId:
                _FP_ACTIONS_CONFLICT(bcmFieldActionFlowtrackerAggregateMmuGroupId);
                break;
            case bcmFieldActionFlowtrackerAggregateMmuFlowIndex:
                _FP_ACTIONS_CONFLICT(bcmFieldActionFlowtrackerAggregateMmuFlowIndex);
                break;
            default:
                break;
        }
    } else if (f_ent->group->stage_id == _BCM_FIELD_STAGE_AEFTFP) {
        switch(action1) {
            case bcmFieldActionFlowtrackerAggregateEgressGroupId:
                _FP_ACTIONS_CONFLICT(bcmFieldActionFlowtrackerAggregateEgressGroupId);
                break;
            case bcmFieldActionFlowtrackerAggregateEgressFlowIndex:
                _FP_ACTIONS_CONFLICT(bcmFieldActionFlowtrackerAggregateEgressFlowIndex);
                break;
            default:
                break;
        }
#endif
    } else {
        switch (action1) {
            case bcmFieldActionLatencyMonitorEnable:
            case bcmFieldActionLatencyMonitorDisable:
                _FP_ACTIONS_CONFLICT(bcmFieldActionLatencyMonitorEnable);
                _FP_ACTIONS_CONFLICT(bcmFieldActionLatencyMonitorDisable);
                return BCM_E_NONE;
            default:
                break;
        }
        return  _bcm_field_td2_action_conflict_check(unit,
                                                     f_ent,
                                                     action1,
                                                     action);
    }


    return (BCM_E_NONE);

}
/*
 * Function:
 *     _field_th_common_actions_init
 * Purpose:
 *     Initialize device stage lookup qaualifiers
 *     select codes & offsets
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     stage_fc   - (IN) Field Processor stage control structure.
 * Returns:
 *     BCM_E_NONE
 */
int
_field_th_common_actions_init(int unit, _field_stage_t *stage_fc)
{
    _FP_ACTION_DECL
    uint32 offset = 0;                  /* General variable to carry offset. */
    uint32 profile_one_offset = 0;      /* Offset of PROFILE_ONE_SET. */
    uint32 profile_two_offset = 0;      /* Offset of PROFILE_TWO_SET. */
    uint32 redirect_offset = 0;         /* Offset of REDIRECT_SET. */
    uint32 l3swl2change_offset = 0;     /* Offset of L3SW_CHANGE_L2_SET. */
    uint32 nat_offset = 0;              /* Offset of NAT_SET. */
    uint32 mirror_offset = 0;           /* Offset of MIRROR_SET. */
    uint32 lb_offset = 0;               /* Offset of LB_CONTROL_SET. */
    uint32 nat_override_offset = 0;     /* Offset of NAT_OVERRIDE_SET. */
    uint32 copytocpu_offset = 0;        /* Offset of COPY_TO_CPU_SET. */
    uint32 cutthrough_offset = 0;       /* Offset of CUT_THRU_OVERRIDE_SET. */
    uint32 urpf_offset = 0;             /* Offset of URPF_OVERRIDE_SET. */
    uint32 ttl_offset = 0;              /* Offset of TTL_SET. */
    uint32 cpucos_offset = 0;           /* Offset of CHANGE_CPU_COS_SET. */
    uint32 drop_offset = 0;             /* Offset of DROP_SET. */
    uint32 mirror_override_offset = 0;  /* Offset of MIRROR_OVERRIDE_SET. */
    uint32 sflow_offset = 0;            /* Offset of SFLOW_SET. */
    uint32 debug_offset = 0;            /* Offset of INSTRUMENTATION_TRIGGERS_ENABLE. */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }
    if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
        profile_one_offset     = 0;  /* Start of the IFP_POLICY_TABLE */
        mirror_offset          = 56; /* IFP_PROFILE_SET_1(56b) */
        lb_offset              = 68; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) */
        nat_override_offset    = 71; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                      *  LB_CONTROLS_SET(3b)
                                      */
        copytocpu_offset       = 72; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                      *  LB_CONTROLS_SET(3b) + NAT_OVERRIDE_SET(1b)
                                      */
        cutthrough_offset      = 89; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                      * LB_CONTROLS_SET(3b) + NAT_OVERRIDE_SET(1b) +
                                      *  COPY_TO_CPU_SET(17b)
                                      */
        urpf_offset            = 90; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                      * LB_CONTROLS_SET(3b) + NAT_OVERRIDE_SET(1b) +
                                      * COPY_TO_CPU_SET(17b) +
                                      * CUT_THRU_OVERRIDE_SET(1b)
                                      */
        ttl_offset             = 91; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                      * LB_CONTROLS_SET(3b) + NAT_OVERRIDE_SET(1b) +
                                      * COPY_TO_CPU_SET(17b) +
                                      * CUT_THRU_OVERRIDE_SET(1b) +
                                      * URPF_OVERRIDE_SET(1b)
                                      */
        profile_two_offset    = 101; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                      * LB_CONTROLS_SET(3b) + NAT_OVERRIDE_SET(1b) +
                                      * COPY_TO_CPU_SET(17b) +
                                      * CUT_THRU_OVERRIDE_SET(1b) +
                                      * URPF_OVERRIDE_SET(1b) + IFP_TTL_SET(1b) +
                                      * RESERVED_0(1b) + ECCP_0(8b)
                                      */
        l3swl2change_offset   = 153; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                      * LB_CONTROLS_SET(3b) + NAT_OVERRIDE_SET(1b) +
                                      * COPY_TO_CPU_SET(17b) +
                                      * CUT_THRU_OVERRIDE_SET(1b) +
                                      * URPF_OVERRIDE_SET(1b) + IFP_TTL_SET(1b) +
                                      * RESERVED_0(1b) + ECCP_0(8b) +
                                      * PROFILE_SET_2(52b)
                                      */
        cpucos_offset         = 176; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                      * LB_CONTROLS_SET(3b) + NAT_OVERRIDE_SET(1b) +
                                      * COPY_TO_CPU_SET(17b) +
                                      * CUT_THRU_OVERRIDE_SET(1b) +
                                      * URPF_OVERRIDE_SET(1b) + IFP_TTL_SET(1b) +
                                      * RESERVED_0(1b) + ECCP_0(8b) +
                                      * PROFILE_SET_2(52b) + L3SW_CHANGE_L2_SET(33b)
                                      */
        drop_offset           = 184; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                      * LB_CONTROLS_SET(3b) + NAT_OVERRIDE_SET(1b) +
                                      * COPY_TO_CPU_SET(17b) +
                                      * CUT_THRU_OVERRIDE_SET(1b) +
                                      * URPF_OVERRIDE_SET(1b) + IFP_TTL_SET(1b) +
                                      * RESERVED_0(1b) + ECCP_0(8b) +
                                      * PROFILE_SET_2(52b) + L3SW_CHANGE_L2_SET(33b)
                                      * + CHANGE_CPU_COS_SET(8b)
                                      */
        mirror_override_offset = 190; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                       * LB_CONTROLS_SET(3b) +
                                       * NAT_OVERRIDE_SET(1b) +
                                       * COPY_TO_CPU_SET(17b) +
                                       * CUT_THRU_OVERRIDE_SET(1b) +
                                       * URPF_OVERRIDE_SET(1b) + IFP_TTL_SET(1b) +
                                       * RESERVED_0(1b) + ECCP_0(8b) +
                                       * PROFILE_SET_2(52b) +
                                       * L3SW_CHANGE_L2_SET(33b) +
                                       * CHANGE_CPU_COS_SET(8b) + DROP_SET(6b) +
                                       */
        sflow_offset           = 192; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                       * LB_CONTROLS_SET(3b) +
                                       * NAT_OVERRIDE_SET(1b) +
                                       * COPY_TO_CPU_SET(17b) +
                                       * CUT_THRU_OVERRIDE_SET(1b) +
                                       * URPF_OVERRIDE_SET(1b) + IFP_TTL_SET(1b) +
                                       * RESERVED_0(1b) + ECCP_0(8b) +
                                       * PROFILE_SET_2(52b) +
                                       * L3SW_CHANGE_L2_SET(33b) +
                                       * CHANGE_CPU_COS_SET(8b) + DROP_SET(6b) +
                                       * MIRROR_OVERRIDE_SET(1b) +
                                       * GREEN_TO_PID_SET(1b)
                                       */
        debug_offset           = 193; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                       * LB_CONTROLS_SET(3b) +
                                       * NAT_OVERRIDE_SET(1b) +
                                       * COPY_TO_CPU_SET(17b) +
                                       * CUT_THRU_OVERRIDE_SET(1b) +
                                       * URPF_OVERRIDE_SET(1b) + IFP_TTL_SET(1b) +
                                       * RESERVED_0(1b) + ECCP_0(8b) +
                                       * PROFILE_SET_2(52b) +
                                       * L3SW_CHANGE_L2_SET(33b) +
                                       * CHANGE_CPU_COS_SET(8b) + DROP_SET(6b) +
                                       * MIRROR_OVERRIDE_SET(1b) +
                                       * GREEN_TO_PID_SET(1b) + SFLOW_SET(1b)
                                       */
        redirect_offset        = 202; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                       * LB_CONTROLS_SET(3b) +
                                       * NAT_OVERRIDE_SET(1b) +
                                       * COPY_TO_CPU_SET(17b) +
                                       * CUT_THRU_OVERRIDE_SET(1b) +
                                       * URPF_OVERRIDE_SET(1b) + IFP_TTL_SET(1b) +
                                       * RESERVED_0(1b) + ECCP_0(8b) +
                                       * PROFILE_SET_2(52b) +
                                       * L3SW_CHANGE_L2_SET(33b) +
                                       * CHANGE_CPU_COS_SET(8b) + DROP_SET(6b) +
                                       * MIRROR_OVERRIDE_SET(1b) +
                                       * GREEN_TO_PID_SET(1b) + SFLOW_SET(1b) +
                                       * INSTRUMENTATION_TRIGGERS_ENABLE(1b) +
                                       * ECCP_1(8b)
                                       */
        nat_offset             = 283; /* PROFILE_SET_1(56b) + MIRROR_SET(12b) +
                                       * LB_CONTROLS_SET(3b) +
                                       * NAT_OVERRIDE_SET(1b) +
                                       * COPY_TO_CPU_SET(17b) +
                                       * CUT_THRU_OVERRIDE_SET(1b) +
                                       * URPF_OVERRIDE_SET(1b) + IFP_TTL_SET(1b) +
                                       * RESERVED_0(1b) + ECCP_0(8b) +
                                       * PROFILE_SET_2(52b) +
                                       * L3SW_CHANGE_L2_SET(33b) +
                                       * CHANGE_CPU_COS_SET(8b) + DROP_SET(6b) +
                                       * MIRROR_OVERRIDE_SET(1b) +
                                       * GREEN_TO_PID_SET(1b) + SFLOW_SET(1b) +
                                       * INSTRUMENTATION_TRIGGERS_ENABLE(1b) +
                                       * ECCP_1(8b) + REDIRECT_SET(38b) +
                                       * COUNTER_SET(25b) + METER_SET(18b)
                                       */
    } else if (stage_fc->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        profile_two_offset=56;
    }

    /* IFP_PROFILE_SET_1(56b) */
    offset = profile_one_offset;
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionUntaggedPacketPriorityNew,
                                      0, offset + 52, 4, -1, offset + 51, 1, 1);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpDropPrecedence,
                                                         0, offset + 0, 2, -1);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpDropPrecedence,
                                                         0, offset + 2, 2, -1);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpDropPrecedence,
                                                         0, offset + 4, 2, -1);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpCosQNew,
                                               0, offset + 6, 8, -1, 30, 4, 1);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpCosMapNew,
                                               0, offset + 6, 2, -1, 30, 4, 2);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioIntCopy,
                                                         0, offset + 30, 4, 4);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpPrioIntNew,
                                               0, offset + 6, 8, -1, 30, 4, 5);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioIntTos,
                                                         0, offset + 30, 4, 6);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioIntCancel,
                                                         0, offset + 30, 4, 7);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpUcastCosQNew,
                                               0, offset + 6, 4, -1, 30, 4, 8);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpMcastCosQNew,
                                              0, offset + 10, 4, -1, 30, 4, 9);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpCosQNew,
                                              0, offset + 14, 8, -1, 34, 4, 1);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpCosMapNew,
                                              0, offset + 14, 2, -1, 34, 4, 2);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioIntCopy,
                                                         0, offset + 34, 4, 4);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpPrioIntNew,
                                              0, offset + 14, 8, -1, 34, 4, 5);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioIntTos,
                                                         0, offset + 34, 4, 6);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioIntCancel,
                                                         0, offset + 34, 4, 7);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpUcastCosQNew,
                                              0, offset + 14, 4, -1, 34, 4, 8);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpMcastCosQNew,
                                              0, offset + 18, 4, -1, 34, 4, 9);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpCosQNew,
                                              0, offset + 22, 8, -1, 38, 4, 1);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpCosMapNew,
                                              0, offset + 22, 2, -1, 38, 4, 2);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioIntCopy,
                                                         0, offset + 38, 4, 4);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpPrioIntNew,
                                              0, offset + 22, 8, -1, 38, 4, 5);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioIntTos,
                                                         0, offset + 38, 4, 6);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioIntCancel,
                                                         0, offset + 38, 4, 7);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpUcastCosQNew,
                                              0, offset + 22, 4, -1, 38, 4, 8);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpMcastCosQNew,
                                              0, offset + 26, 4, -1, 38, 4, 9);

    if (soc_feature(unit, soc_feature_ecn_wred)) {
        _FP_ACTION_ADD_TWO(unit, stage_fc,
                           bcmFieldActionGpIntCongestionNotificationNew,
                           _BCM_FIELD_ACTION_NO_EM_SUPPORT,
                           offset + 46, 2, -1, 50, 1, 1);
        _FP_ACTION_ADD_TWO(unit, stage_fc,
                           bcmFieldActionYpIntCongestionNotificationNew,
                           _BCM_FIELD_ACTION_NO_EM_SUPPORT
                           , offset + 44, 2, -1, 49, 1, 1);
       _FP_ACTION_ADD_TWO(unit, stage_fc,
                          bcmFieldActionRpIntCongestionNotificationNew,
                          _BCM_FIELD_ACTION_NO_EM_SUPPORT
                          , offset + 42, 2, -1, 48, 1, 1);
    }

    if (soc_feature(unit, soc_feature_field_action_pfc_class)) {
       _FP_ACTION_ADD_TWO(unit, stage_fc,
                          bcmFieldActionPfcClassNew,
                          0, offset + 52, 4, -1, 51, 1, 1);
    }

    /* IFP_MIRROR_SET(12b) */
    offset = mirror_offset;

    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionMirrorIngress,
                                          0, _FieldActionMirrorSet,
                                          offset + 8, 4, 0, offset , 8, 0);

    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionMirrorEgress,
                                          0, _FieldActionMirrorSet,
                                          offset + 8, 4, 0, offset , 8, 0);

    /* IFP_LB_CONTROLS_SET(3b) */
    offset = lb_offset;

    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc,
                       bcmFieldActionHgTrunkRandomRoundRobinHashCancel,
                       0, _FieldActionLbControlSet,
                       offset + 0, 1, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc,
                       bcmFieldActionTrunkRandomRoundRobinHashCancel,
                       0, _FieldActionLbControlSet,
                       offset + 1, 1, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc,
                       bcmFieldActionEcmpRandomRoundRobinHashCancel,
                       0, _FieldActionLbControlSet,
                       offset + 2, 1, 1);

    /* IFP_NAT_OVERRIDE_SET(1b) */
    offset = nat_override_offset;

    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionNatCancel,
                                 0, _FieldActionNatOverrideSet, offset + 0, 1, 1);

    /* IFP_COPY_TO_CPU_SET(17b) */
    offset = copytocpu_offset;

    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionRpCopyToCpu,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 9, 8, -1, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRpCopyToCpuCancel,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 0, 3, 2);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRpSwitchToCpuCancel,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 0, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRpSwitchToCpuReinstate,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 0, 3, 4);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionRpTimeStampToCpu,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 9, 8, -1, offset + 0, 3, 5);

    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionYpCopyToCpu,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 9, 8, -1, offset + 3, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionYpCopyToCpuCancel,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 3, 3, 2);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionYpSwitchToCpuCancel,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 3, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionYpSwitchToCpuReinstate,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 3, 3, 4);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionYpTimeStampToCpu,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 9, 8, -1, offset + 3, 3, 5);

    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionGpCopyToCpu,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 9, 8, -1, offset + 6, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionGpCopyToCpuCancel,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 6, 3, 2);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionGpSwitchToCpuCancel,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 6, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionGpSwitchToCpuReinstate,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 6, 3, 4);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionGpTimeStampToCpu,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 9, 8, -1, offset + 6, 3, 5);

    /* IFP_CUT_THRU_OVERRIDE_SET(1b) */
    offset = cutthrough_offset;
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDoNotCutThrough,
                                 0, _FieldActionCutThrOverrideSet, offset + 0, 1, 1);

    /* IFP_URPF_OVERRIDE_SET(1b) */
    offset = urpf_offset;

    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDoNotCheckUrpf,
                                 0, _FieldActionUrpfOverrideSet, offset + 0, 1, 1);

    /* IFP_TTL_SET(1b) */
    offset = ttl_offset;

    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDoNotChangeTtl,
                                 0, _FieldActionTtlOverrideSet, offset + 0, 1, 1);

    /* IFP_PROFILE_SET_2(52b) */
    offset = profile_two_offset;

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpEcnNew,
                                        0, offset + 0, 2, -1, offset + 6, 1, 1);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpEcnNew,
                                        0, offset + 2, 2, -1, offset + 7, 1, 1);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpEcnNew,
                                        0, offset + 4, 2, -1, offset + 8, 1, 1);

    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpDot1pPreserve,
                                                          0, offset + 18, 3, 3);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktCopy,
                                                          0, offset + 18, 3, 4);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpPrioPktNew,
                                       0, offset + 9, 3, -1, offset + 18, 3, 5);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktTos,
                                                          0, offset + 18, 3, 6);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktCancel,
                                                          0, offset + 18, 3, 7);

    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpDot1pPreserve,
                                                          0, offset + 21, 3, 3);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktCopy,
                                                          0, offset + 21, 3, 4);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpPrioPktNew,
                                      0, offset + 12, 3, -1, offset + 21, 3, 5);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktTos,
                                                          0, offset + 21, 3, 6);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktCancel,
                                                          0, offset + 21, 3, 7);

    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpDot1pPreserve,
                                                          0, offset + 24, 3, 3);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktCopy,
                                                          0, offset + 24, 3, 4);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpPrioPktNew,
                                      0, offset + 15, 3, -1, offset + 24, 3, 5);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktTos,
                                                          0, offset + 24, 3, 6);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktCancel,
                                                          0, offset + 24, 3, 7);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpDscpNew,
                                      0, offset + 40, 6, -1, offset + 27, 2, 1);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpDscpCancel,
                                                          0, offset + 27, 2, 2);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpDscpPreserve,
                                                          0, offset + 27, 2, 3);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpDscpNew,
                                      0, offset + 34, 6, -1, offset + 29, 2, 1);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpDscpCancel,
                                                          0, offset + 29, 2, 2);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpDscpPreserve,
                                                          0, offset + 29, 2, 3);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpDscpNew,
                                      0, offset + 46, 6, -1, offset + 31, 3, 3);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpDscpCancel,
                                                          0, offset + 31, 3, 4);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpDscpPreserve,
                                                          0, offset + 31, 3, 5);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpTosPrecedenceNew,
                                      0, offset + 46, 6, -1, offset + 31, 3, 1);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpTosPrecedenceCopy,
                                                          0, offset + 31, 3, 2);

    /* IFP_L3SW_CHANGE_L2_SET(33b) */
    offset = l3swl2change_offset;
    if (!soc_feature(unit, soc_feature_th3_style_fp)) {
        _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionDstMacNew,
                                          0, _FieldActionL3SwChangeL2Set,
                                          offset + 0, 15, -1, offset + 19, 4, 1);
        _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionSrcMacNew,
                                          0, _FieldActionL3SwChangeL2Set,
                                          offset + 0, 15, -1, offset + 19, 4, 1);
        _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionOuterVlanNew,
                                          0, _FieldActionL3SwChangeL2Set,
                                          offset + 0, 15, -1, offset + 19, 4, 1);
        _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionVnTagNew,
                                          0, _FieldActionL3SwChangeL2Set,
                                          offset + 0, 15, -1, offset + 19, 4, 1);
        _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionVnTagDelete,
                                          0, _FieldActionL3SwChangeL2Set,
                                          offset + 0, 15, -1, offset + 19, 4, 1);
        _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionEtagNew,
                                          0, _FieldActionL3SwChangeL2Set,
                                          offset + 0, 15, -1, offset + 19, 4, 1);
        _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionEtagDelete,
                                          0, _FieldActionL3SwChangeL2Set,
                                          offset + 0, 15, -1, offset + 19, 4, 1);
    }
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionChangeL2Fields,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 15, -1, offset + 19, 4, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc,
                                      bcmFieldActionChangeL2FieldsCancel,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 19, 4, 2);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionFabricQueue,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 2, -1,
                                      offset + 2, 16, -1, offset + 19, 4, 3);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionAddClassTag,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 16, -1, offset + 19, 4, 4);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionL3Switch,
                                   _BCM_FIELD_ACTION_L3SWITCH_NEXT_HOP,
                                   _FieldActionL3SwChangeL2Set,
                                   offset + 0, 15, -1,
                                   offset + 17, 1, 0, offset + 19, 4, 6);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionL3Switch,
                                   _BCM_FIELD_ACTION_L3SWITCH_ECMP,
                                   _FieldActionL3SwChangeL2Set,
                                   offset + 0, 11, -1,
                                   offset + 17, 1, 1, offset + 19, 4, 6);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionMultipathHash,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 11, 3, -1, offset + 19, 4, 6);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionL3SwitchCancel,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 19, 4, 7);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionEgressClassSelect,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 4, -1, offset + 19, 4, 8);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionHiGigClassSelect,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 4, 3, -1, offset + 19, 4, 8);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionNewClassId,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 7, 9, -1, offset + 19, 4, 8);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionBFDSessionIdNew,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 12, -1, offset + 19, 4, 9);

    /* IFP_CHANGE_CPU_COS_SET(8b) */
    offset = cpucos_offset;
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionCosQCpuNew,
                                        0, _FieldActionChangeCpuCosSet,
                                        offset + 0, 6, -1, offset + 6, 2, 1);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionServicePoolIdNew, 0,
                                                   _FieldActionChangeCpuCosSet,
                                                              offset + 2, 2, -1,
                                                              offset + 4, 2, 2,
                                                              offset + 6, 2, 2);
    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc, bcmFieldActionServicePoolIdPrecedenceNew, 0,
                                                   _FieldActionChangeCpuCosSet,
                                                              offset + 2, 2, -1,
                                                              offset + 0, 2, -1,
                                                              offset + 4, 2, 3,
                                                              offset + 6, 2, 2);
    /* IFP_DROP_SET(6b) */
    offset = drop_offset;
   _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRpDrop,
                                 0, _FieldActionDropSet, offset + 0, 2, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRpDropCancel,
                                 0, _FieldActionDropSet, offset + 0, 2, 2);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionYpDrop,
                                 0, _FieldActionDropSet, offset + 2, 2, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionYpDropCancel,
                                 0, _FieldActionDropSet,  offset + 2, 2, 2);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionGpDrop,
                                 0, _FieldActionDropSet, offset + 4, 2, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionGpDropCancel,
                                 0, _FieldActionDropSet, offset + 4, 2, 2);

    /* IFP_MIRROR_OVERRIDE_SET(1b) */
    offset = mirror_override_offset;

     _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionMirrorOverride,
                                 0, _FieldActionMirrorOverrideSet, offset + 0, 1, 1);

    /* IFP_SFLOW_SET(1b) */
    offset = sflow_offset;

    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionIngSampleEnable,
                                 0, _FieldActionSflowSet, offset + 0, 1, 1);

    /* IFP_INSTRUMENTATION_TRIGGERS_ENABLE_SET(1b)*/
    offset = debug_offset;
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionPacketTraceEnable,
                                       _BCM_FIELD_ACTION_NO_EM_SUPPORT,
                                       _FieldActionInstrumentationSet,
                                       offset + 0, 1, 1);

    /* IFP_REDIRECT_SET(38b) */
    offset = redirect_offset;
    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc, bcmFieldActionRedirect,
                                         _BCM_FIELD_ACTION_REDIRECT_DGLP,
                                         _FieldActionRedirectSet,
                                         offset + 6, 16, -1, offset + 22 , 1, 0,
                                         offset + 3, 3, 0, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirect,
                                          _BCM_FIELD_ACTION_REDIRECT_DVP,
                                          _FieldActionRedirectSet,
                                          offset + 6, 14, -1,
                                          offset + 3, 3, 6, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc, bcmFieldActionRedirect,
                                          _BCM_FIELD_ACTION_REDIRECT_TRUNK,
                                          _FieldActionRedirectSet,
                                          offset + 6, 16, -1, offset + 22, 1, 1,
                                          offset + 3, 3, 0, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc, bcmFieldActionRedirectTrunk,
                                            _BCM_FIELD_ACTION_REDIRECT_TRUNK,
                                            _FieldActionRedirectSet,
                                            offset + 6, 16, -1, offset + 22, 1, 1,
                                            offset + 3, 3, 0, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectTrunk,
                                            _BCM_FIELD_ACTION_REDIRECT_DVP,
                                            _FieldActionRedirectSet,
                                          offset + 6, 14, -1,
                                          offset + 3, 3, 6, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc,
                                     bcmFieldActionUnmodifiedPacketRedirectPort,
                                     _BCM_FIELD_ACTION_REDIRECT_DGLP,
                                     _FieldActionRedirectSet,
                                      offset + 6, 16, -1, offset + 22, 1, 0,
                                      offset + 3, 3, 1, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc,
                                     bcmFieldActionUnmodifiedPacketRedirectPort,
                                     _BCM_FIELD_ACTION_REDIRECT_TRUNK,
                                     _FieldActionRedirectSet,
                                      offset + 6, 16, -1, offset + 22, 1, 1,
                                      offset + 3, 3, 1, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectEgrNextHop,
                                          _BCM_FIELD_ACTION_REDIRECT_NEXT_HOP,
                                          _FieldActionRedirectSet,
                                          offset + 6, 16, -1,
                                          offset + 3, 3, 2, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectEgrNextHop,
                                         _BCM_FIELD_ACTION_REDIRECT_ECMP,
                                         _FieldActionRedirectSet,
                                         offset + 6, 16, -1,
                                         offset + 3, 3, 3, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRedirectCancel,
                                   0, _FieldActionRedirectSet, offset + 0, 3, 2);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectPbmp, 0,
                                         _FieldActionRedirectSet,
                                         offset + 6, 10, -1,
                                         offset + 23, 2, 0, offset + 0, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectVlan, 0,
                                         _FieldActionRedirectSet,
                                         offset + 17, 1, 0,
                                         offset + 23, 2, 1, offset + 0, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc, bcmFieldActionRedirectBcastPbmp, 0,
                                          _FieldActionRedirectSet,
                                          offset + 6, 10, -1, offset + 17, 1, 1,
                                          offset + 23, 2, 1, offset + 0, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectMcast, 0,
                                          _FieldActionRedirectSet,
                                          offset + 6, 14, -1,
                                          offset + 23, 2, 2, offset + 0, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectIpmc, 0,
                                          _FieldActionRedirectSet,
                                          offset + 6, 14, -1,
                                          offset + 23, 2, 3, offset + 0, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionEgressMask, 0,
                                          _FieldActionRedirectSet,
                                          offset + 6, 10, -1, offset + 0, 3, 4);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionEgressPortsAdd, 0,
                                          _FieldActionRedirectSet,
                                          offset + 6, 10, -1, offset + 0, 3, 5);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionFabricEHAddOrUpdate, 0,
                                          _FieldActionRedirectSet,
                                          offset + 3, 32, -1,
                                          offset + 35, 3, -1, offset + 0, 3, 6);

    /* IFP_NAT_SET(12b) */
    offset = nat_offset;
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionNat,
                                0, _FieldActionNatSet, offset + 11, 1, 1);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionNatEgressOverride,
                                0, _FieldActionNatSet,
                                offset + 0, 10, -1, offset + 10, 1, -1);

    /* ExactMatch Action Class Id (12b) */
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionExactMatchClassId,
                       _BCM_FIELD_ACTION_NO_IFP_SUPPORT, 0, 12, 0);

    /* All actions which have corresponding Colored(Gp/Yp/Rp) Actions needs to be
     * initialized with some default configuration(offset = 0, width = 0, value = 0).
     */
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionCosQNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioIntCopy, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioIntNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioIntTos, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioIntCancel, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionUcastCosQNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionMcastCosQNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionDropPrecedence, 0, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionColorIndependent,
                                 0, _FieldActionGreenToPidSet, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionEcnNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktCopy, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktTos, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktCancel, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionDscpNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionDscpCancel, 0, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionCopyToCpu,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionCopyToCpuCancel,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionSwitchToCpuCancel,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionSwitchToCpuReinstate,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionTimeStampToCpu,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionTimeStampToCpuCancel,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionGpTimeStampToCpuCancel,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionYpTimeStampToCpuCancel,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRpTimeStampToCpuCancel,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDrop,
                                 0, _FieldActionDropSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDropCancel,
                                 0, _FieldActionDropSet, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktAndIntCopy, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktAndIntNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktAndIntTos, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktAndIntCancel, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktAndIntCopy, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktAndIntNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktAndIntTos, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktAndIntCancel, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktAndIntCopy, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktAndIntNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktAndIntTos, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktAndIntCancel, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktAndIntCopy, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktAndIntNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktAndIntTos, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktAndIntCancel, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionCosMapNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionDscpPreserve, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionDot1pPreserve, 0, 0, 0, 0);

    return BCM_E_NONE;
}

#ifdef BCM_TOMAHAWK2_SUPPORT
/*
 * Function:
 *     _field_th2_common_actions_init
 * Purpose:
 *     Initialize device stage lookup qaualifiers
 *     select codes & offsets
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     stage_fc   - (IN) Field Processor stage control structure.
 * Returns:
 *     BCM_E_NONE
 */
int
_field_th2_common_actions_init(int unit, _field_stage_t *stage_fc)
{
    _FP_ACTION_DECL
    uint32 offset = 0;                  /* General variable to carry offset. */
    uint32 profile_one_offset = 0;      /* Offset of PROFILE_ONE_SET. */
    uint32 profile_two_offset = 0;      /* Offset of PROFILE_TWO_SET. */
    uint32 redirect_offset = 0;         /* Offset of REDIRECT_SET. */
    uint32 l3swl2change_offset = 0;     /* Offset of L3SW_CHANGE_L2_SET. */
    uint32 nat_offset = 0;              /* Offset of NAT_SET. */
    uint32 mirror_offset = 0;           /* Offset of MIRROR_SET. */
    uint32 lb_offset = 0;               /* Offset of LB_CONTROL_SET. */
    uint32 nat_override_offset = 0;     /* Offset of NAT_OVERRIDE_SET. */
    uint32 copytocpu_offset = 0;        /* Offset of COPY_TO_CPU_SET. */
    uint32 cutthrough_offset = 0;       /* Offset of CUT_THRU_OVERRIDE_SET. */
    uint32 urpf_offset = 0;             /* Offset of URPF_OVERRIDE_SET. */
    uint32 ttl_offset = 0;              /* Offset of TTL_SET. */
    uint32 cpucos_offset = 0;           /* Offset of CHANGE_CPU_COS_SET. */
    uint32 drop_offset = 0;             /* Offset of DROP_SET. */
    uint32 mirror_override_offset = 0;  /* Offset of MIRROR_OVERRIDE_SET. */
    uint32 sflow_offset = 0;            /* Offset of SFLOW_SET. */
    uint32 debug_offset = 0;            /* Offset of INSTRUMENTATION_TRIGGERS_ENABLE. */
    uint32 timestamp_offset = 0;        /* Offset of TIMESTAMP_SET. */
    uint32 dlb_hgt_lag_offset = 0;      /* Offset of DLB_HGT_LAG_SET. */
#if defined(INCLUDE_L3)
    uint32 prot_switch_offset = 0;      /* Offset of PROTECTION_SWITCHING_SET. */
    uint32 dlb_ecmp_offset = 0;         /* Offset of DLB_ECMP_SET. */
    uint32 dlb_alternate_path_control_offset = 0;      /* Offset of DLB_ALTERNATE_PATH_CONTROL_SET. */
#endif /* INCLUDE_L3 */
    soc_field_info_t * f_info;

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
        profile_one_offset = 0;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, MIRROR_SETf);
        mirror_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, LB_CONTROLS_SETf);
        lb_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, NAT_OVERRIDE_SETf);
        nat_override_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, COPY_TO_CPU_SETf);
        copytocpu_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, CUT_THRU_OVERRIDE_SETf);
        cutthrough_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, URPF_OVERRIDE_SETf);
        urpf_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, TTL_OVERRIDE_SETf);
        ttl_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, PROFILE_SET_2f);
        profile_two_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, L3SW_CHANGE_L2_SETf);
        l3swl2change_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, CHANGE_CPU_COS_SETf);
        cpucos_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, DROP_SETf);
        drop_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, MIRROR_OVERRIDE_SETf);
        mirror_override_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, SFLOW_SETf);
        sflow_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, INSTRUMENTATION_TRIGGERS_ENABLEf);
        debug_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, REDIRECT_SETf);
        redirect_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, NAT_SETf);
        nat_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, DLB_HGT_LAG_SETf);
        dlb_hgt_lag_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, TIMESTAMP_SETf);
        timestamp_offset = f_info->bp;
#if defined(INCLUDE_L3)
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, PROTECTION_SWITCHING_SETf);
        prot_switch_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, DLB_ECMP_SETf);
        dlb_ecmp_offset = f_info->bp;
        f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, DLB_ALTERNATE_PATH_CONTROL_SETf);
        dlb_alternate_path_control_offset = f_info->bp;
#endif /* INCLUDE_L3 */
    } else if (stage_fc->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        f_info = soc_mem_fieldinfo_get(unit, EXACT_MATCH_QOS_ACTIONS_PROFILEm, PROFILE_SET_2f);
        profile_two_offset = f_info->bp;
    }

    /* IFP_PROFILE_SET_1(56b) */
    offset = profile_one_offset;
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionUntaggedPacketPriorityNew,
                                      0, offset + 52, 4, -1, offset + 51, 1, 1);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpDropPrecedence,
                                                         0, offset + 0, 2, -1);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpDropPrecedence,
                                                         0, offset + 2, 2, -1);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpDropPrecedence,
                                                         0, offset + 4, 2, -1);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpCosQNew,
                                               0, offset + 6, 8, -1, 30, 4, 1);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpCosMapNew,
                                               0, offset + 6, 2, -1, 30, 4, 2);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioIntCopy,
                                                         0, offset + 30, 4, 4);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpPrioIntNew,
                                               0, offset + 6, 8, -1, 30, 4, 5);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioIntTos,
                                                         0, offset + 30, 4, 6);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioIntCancel,
                                                         0, offset + 30, 4, 7);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpUcastCosQNew,
                                               0, offset + 6, 4, -1, 30, 4, 8);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpMcastCosQNew,
                                              0, offset + 10, 4, -1, 30, 4, 9);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpCosQNew,
                                              0, offset + 14, 8, -1, 34, 4, 1);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpCosMapNew,
                                              0, offset + 14, 2, -1, 34, 4, 2);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioIntCopy,
                                                         0, offset + 34, 4, 4);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpPrioIntNew,
                                              0, offset + 14, 8, -1, 34, 4, 5);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioIntTos,
                                                         0, offset + 34, 4, 6);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioIntCancel,
                                                         0, offset + 34, 4, 7);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpUcastCosQNew,
                                              0, offset + 14, 4, -1, 34, 4, 8);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpMcastCosQNew,
                                              0, offset + 18, 4, -1, 34, 4, 9);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpCosQNew,
                                              0, offset + 22, 8, -1, 38, 4, 1);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpCosMapNew,
                                              0, offset + 22, 2, -1, 38, 4, 2);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioIntCopy,
                                                         0, offset + 38, 4, 4);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpPrioIntNew,
                                              0, offset + 22, 8, -1, 38, 4, 5);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioIntTos,
                                                         0, offset + 38, 4, 6);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioIntCancel,
                                                         0, offset + 38, 4, 7);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpUcastCosQNew,
                                              0, offset + 22, 4, -1, 38, 4, 8);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpMcastCosQNew,
                                              0, offset + 26, 4, -1, 38, 4, 9);

    if (soc_feature(unit, soc_feature_ecn_wred)) {
        _FP_ACTION_ADD_TWO(unit, stage_fc,
                           bcmFieldActionGpIntCongestionNotificationNew,
                           _BCM_FIELD_ACTION_NO_EM_SUPPORT,
                           offset + 46, 2, -1, 50, 1, 1);
        _FP_ACTION_ADD_TWO(unit, stage_fc,
                           bcmFieldActionYpIntCongestionNotificationNew,
                           _BCM_FIELD_ACTION_NO_EM_SUPPORT
                           , offset + 44, 2, -1, 49, 1, 1);
       _FP_ACTION_ADD_TWO(unit, stage_fc,
                          bcmFieldActionRpIntCongestionNotificationNew,
                          _BCM_FIELD_ACTION_NO_EM_SUPPORT
                          , offset + 42, 2, -1, 48, 1, 1);
    }

    if (soc_feature(unit, soc_feature_field_action_pfc_class)) {
       _FP_ACTION_ADD_TWO(unit, stage_fc,
                          bcmFieldActionPfcClassNew,
                          0, offset + 52, 4, -1, 51, 1, 1);
    }

    /* IFP_MIRROR_SET(12b) */
    offset = mirror_offset;

    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionMirrorIngress,
                                          0, _FieldActionMirrorSet,
                                          offset + 8, 4, 0, offset , 8, 0);

    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionMirrorEgress,
                                          0, _FieldActionMirrorSet,
                                          offset + 8, 4, 0, offset , 8, 0);

    /* IFP_LB_CONTROLS_SET(3b) */
    offset = lb_offset;


    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc,
                       bcmFieldActionHgTrunkRandomRoundRobinHashCancel,
                       0, _FieldActionLbControlSet,
                       offset + 0, 1, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc,
                       bcmFieldActionTrunkRandomRoundRobinHashCancel,
                       0, _FieldActionLbControlSet,
                       offset + 1, 1, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc,
                       bcmFieldActionEcmpRandomRoundRobinHashCancel,
                       0, _FieldActionLbControlSet,
                       offset + 2, 1, 1);

    /* IFP_NAT_OVERRIDE_SET(1b) */
    offset = nat_override_offset;

    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionNatCancel,
                       0, _FieldActionNatOverrideSet, offset + 0, 1, 1);
    /* IFP_COPY_TO_CPU_SET(17b) */
    offset = copytocpu_offset;

    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionRpCopyToCpu,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 9, 8, -1, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRpCopyToCpuCancel,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 0, 3, 2);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRpSwitchToCpuCancel,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 0, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRpSwitchToCpuReinstate,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 0, 3, 4);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionRpTimeStampToCpu,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 9, 8, -1, offset + 0, 3, 5);

    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionYpCopyToCpu,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 9, 8, -1, offset + 3, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionYpCopyToCpuCancel,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 3, 3, 2);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionYpSwitchToCpuCancel,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 3, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionYpSwitchToCpuReinstate,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 3, 3, 4);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionYpTimeStampToCpu,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 9, 8, -1, offset + 3, 3, 5);

    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionGpCopyToCpu,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 9, 8, -1, offset + 6, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionGpCopyToCpuCancel,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 6, 3, 2);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionGpSwitchToCpuCancel,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 6, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionGpSwitchToCpuReinstate,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 6, 3, 4);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionGpTimeStampToCpu,
                                        0, _FieldActionCopyToCpuSet,
                                        offset + 9, 8, -1, offset + 6, 3, 5);

    /* IFP_CUT_THRU_OVERRIDE_SET(1b) */
    offset = cutthrough_offset;
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDoNotCutThrough,
                                0, _FieldActionCutThrOverrideSet, offset + 0, 1, 1);

    /* IFP_URPF_OVERRIDE_SET(1b) */
    offset = urpf_offset;

    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDoNotCheckUrpf,
                                0, _FieldActionUrpfOverrideSet, offset + 0, 1, 1);

    /* IFP_TTL_SET(1b) */
    offset = ttl_offset;

    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDoNotChangeTtl,
                                0, _FieldActionTtlOverrideSet, offset + 0, 1, 1);

    /* IFP_PROFILE_SET_2(52b) */
    offset = profile_two_offset;

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpEcnNew,
                                        0, offset + 0, 2, -1, offset + 6, 1, 1);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpEcnNew,
                                        0, offset + 2, 2, -1, offset + 7, 1, 1);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpEcnNew,
                                        0, offset + 4, 2, -1, offset + 8, 1, 1);

    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpDot1pPreserve,
                                                          0, offset + 18, 3, 3);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktCopy,
                                                          0, offset + 18, 3, 4);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpPrioPktNew,
                                       0, offset + 9, 3, -1, offset + 18, 3, 5);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktTos,
                                                          0, offset + 18, 3, 6);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktCancel,
                                                          0, offset + 18, 3, 7);

    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpDot1pPreserve,
                                                          0, offset + 21, 3, 3);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktCopy,
                                                          0, offset + 21, 3, 4);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpPrioPktNew,
                                      0, offset + 12, 3, -1, offset + 21, 3, 5);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktTos,
                                                          0, offset + 21, 3, 6);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktCancel,
                                                          0, offset + 21, 3, 7);

    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpDot1pPreserve,
                                                          0, offset + 24, 3, 3);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktCopy,
                                                          0, offset + 24, 3, 4);
    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpPrioPktNew,
                                      0, offset + 15, 3, -1, offset + 24, 3, 5);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktTos,
                                                          0, offset + 24, 3, 6);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktCancel,
                                                          0, offset + 24, 3, 7);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionRpDscpNew,
                                      0, offset + 40, 6, -1, offset + 27, 2, 1);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpDscpCancel,
                                                          0, offset + 27, 2, 2);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpDscpPreserve,
                                                          0, offset + 27, 2, 3);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionYpDscpNew,
                                      0, offset + 34, 6, -1, offset + 29, 2, 1);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpDscpCancel,
                                                          0, offset + 29, 2, 2);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpDscpPreserve,
                                                          0, offset + 29, 2, 3);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpDscpNew,
                                      0, offset + 46, 6, -1, offset + 31, 3, 3);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpDscpCancel,
                                                          0, offset + 31, 3, 4);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpDscpPreserve,
                                                          0, offset + 31, 3, 5);

    _FP_ACTION_ADD_TWO(unit, stage_fc, bcmFieldActionGpTosPrecedenceNew,
                                      0, offset + 46, 6, -1, offset + 31, 3, 1);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpTosPrecedenceCopy,
                                                          0, offset + 31, 3, 2);

    /* IFP_L3SW_CHANGE_L2_SET(33b) */
    offset = l3swl2change_offset;

    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionDstMacNew,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 16, -1, offset + 19, 4, 1);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionSrcMacNew,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 16, -1, offset + 19, 4, 1);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionOuterVlanNew,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 16, -1, offset + 19, 4, 1);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionVnTagNew,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 16, -1, offset + 19, 4, 1);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionVnTagDelete,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 16, -1, offset + 19, 4, 1);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionEtagNew,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 16, -1, offset + 19, 4, 1);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionEtagDelete,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 16, -1, offset + 19, 4, 1);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionChangeL2Fields,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 16, -1, offset + 19, 4, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionChangeL2FieldsCancel,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 19, 4, 2);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionFabricQueue, 0,
                                    _FieldActionL3SwChangeL2Set,
                                    offset + 0, 2, -1,  offset + 2, 16, -1, offset + 19, 4, 3);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionAddClassTag,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 0, 16, -1, offset + 19, 4, 4);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionL3Switch,
                                      _BCM_FIELD_ACTION_L3SWITCH_NEXT_HOP,
                                      _FieldActionL3SwChangeL2Set,
                                      offset + 0, 16, -1,
                                      offset + 17, 1, 0, offset + 19, 4, 6);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionL3Switch,
                                      _BCM_FIELD_ACTION_L3SWITCH_ECMP,
                                      _FieldActionL3SwChangeL2Set,
                                      offset + 0, 12, -1,
                                      offset + 17, 1, 1, offset + 19, 4, 6);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionMultipathHash,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 12, 3, -1, offset + 19, 4, 6);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionL3SwitchCancel,
                                      0, _FieldActionL3SwChangeL2Set,
                                      offset + 19, 4, 7);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionEgressClassSelect,
                                       0, _FieldActionL3SwChangeL2Set,
                                       offset + 0, 4, -1, offset + 19, 4, 8);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionHiGigClassSelect,
                                       0, _FieldActionL3SwChangeL2Set,
                                      offset + 4, 3, -1, offset + 19, 4, 8);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionNewClassId,
                                       0, _FieldActionL3SwChangeL2Set,
                                      offset + 7, 9, -1, offset + 19, 4, 8);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionBFDSessionIdNew,
                                       0, _FieldActionL3SwChangeL2Set,
                                       offset + 0, 12, -1, offset + 19, 4, 9);

    /* IFP_CHANGE_CPU_COS_SET(8b) */
    offset = cpucos_offset;

    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionCosQCpuNew,
                                        0, _FieldActionChangeCpuCosSet,
                                        offset + 0, 6, -1, offset + 6, 2, 1);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionServicePoolIdNew, 0,
                                                       _FieldActionChangeCpuCosSet,
                                                              offset + 2, 2, -1,
                                                              offset + 4, 2, 2,
                                                              offset + 6, 2, 2);
    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc, bcmFieldActionServicePoolIdPrecedenceNew, 0,
                                                             _FieldActionChangeCpuCosSet,
                                                              offset + 2, 2, -1,
                                                              offset + 0, 2, -1,
                                                              offset + 4, 2, 3,
                                                              offset + 6, 2, 2);

    /* IFP_DROP_SET(6b) */
    offset = drop_offset;

    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRpDrop,
                                 0, _FieldActionDropSet, offset + 0, 2, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRpDropCancel,
                                 0, _FieldActionDropSet, offset + 0, 2, 2);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionYpDrop,
                                 0, _FieldActionDropSet, offset + 2, 2, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionYpDropCancel,
                                 0, _FieldActionDropSet, offset + 2, 2, 2);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionGpDrop,
                                 0, _FieldActionDropSet, offset + 4, 2, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionGpDropCancel,
                                 0, _FieldActionDropSet, offset + 4, 2, 2);

    /* IFP_MIRROR_OVERRIDE_SET(1b) */
    offset = mirror_override_offset;

    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionMirrorOverride,
                                 0, _FieldActionMirrorOverrideSet, offset + 0, 1, 1);

    /* IFP_SFLOW_SET(1b) */
    offset = sflow_offset;

    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionIngSampleEnable,
                                 0, _FieldActionSflowSet, offset + 0, 1, 1);

    /* IFP_INSTRUMENTATION_TRIGGERS_ENABLE_SET(1b)*/
    offset = debug_offset;
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionPacketTraceEnable,
                                 0, _FieldActionInstrumentationSet, offset + 0, 1, 1);

    /* IFP_REDIRECT_SET(38b) */
    offset = redirect_offset;

    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc, bcmFieldActionRedirect,
                                         _BCM_FIELD_ACTION_REDIRECT_DGLP,
                                         _FieldActionRedirectSet,
                                         offset + 6, 16, -1, offset + 22 , 1, 0,
                                         offset + 3, 3, 0, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirect,
                                         _BCM_FIELD_ACTION_REDIRECT_DVP,
                                         _FieldActionRedirectSet,
                                         offset + 6, 14, -1,
                                         offset + 3, 3, 6, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc, bcmFieldActionRedirect,
                                         _BCM_FIELD_ACTION_REDIRECT_TRUNK,
                                         _FieldActionRedirectSet,
                                         offset + 6, 16, -1, offset + 22, 1, 1,
                                           offset + 3, 3, 0, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc, bcmFieldActionRedirectTrunk,
                                         _BCM_FIELD_ACTION_REDIRECT_TRUNK,
                                         _FieldActionRedirectSet,
                                         offset + 6, 16, -1, offset + 22, 1, 1,
                                         offset + 3, 3, 0, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectTrunk,
                                         _BCM_FIELD_ACTION_REDIRECT_DVP,
                                         _FieldActionRedirectSet,
                        offset + 6, 14, -1, offset + 3, 3, 6, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc,
                                     bcmFieldActionUnmodifiedPacketRedirectPort,
                                         _BCM_FIELD_ACTION_REDIRECT_DGLP,
                                         _FieldActionRedirectSet,
                                         offset + 6, 16, -1, offset + 22, 1, 0,
                                         offset + 3, 3, 1, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc,
                                     bcmFieldActionUnmodifiedPacketRedirectPort,
                                         _BCM_FIELD_ACTION_REDIRECT_TRUNK,
                                         _FieldActionRedirectSet,
                                         offset + 6, 16, -1, offset + 22, 1, 0,
                                         offset + 3, 3, 1, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectEgrNextHop,
                                         _BCM_FIELD_ACTION_REDIRECT_NEXT_HOP,
                                         _FieldActionRedirectSet,
                        offset + 6, 16, -1, offset + 3, 3, 2, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectEgrNextHop,
                                         _BCM_FIELD_ACTION_REDIRECT_ECMP,
                                         _FieldActionRedirectSet,
                        offset + 6, 16, -1, offset + 3, 3, 3, offset + 0, 3, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRedirectCancel,
                                         0, _FieldActionRedirectSet,
                                         offset + 0, 3, 2);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectPbmp, 0,
                                         _FieldActionRedirectSet,
                       offset + 6, 10, -1, offset + 23, 2, 0, offset + 0, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectVlan, 0,
                                         _FieldActionRedirectSet,
                        offset + 17, 1, 0, offset + 23, 2, 1, offset + 0, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_FOUR(unit, stage_fc, bcmFieldActionRedirectBcastPbmp, 0,
                                          _FieldActionRedirectSet,
                                          offset + 6, 10, -1, offset + 17, 1, 1,
                                          offset + 23, 2, 1, offset + 0, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectMcast, 0,
                                         _FieldActionRedirectSet,
                       offset + 6, 14, -1, offset + 23, 2, 2, offset + 0, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionRedirectIpmc, 0,
                                         _FieldActionRedirectSet,
                       offset + 6, 14, -1, offset + 23, 2, 3, offset + 0, 3, 3);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionEgressMask, 0,
                                         _FieldActionRedirectSet,
                                         offset + 6, 10, -1, offset + 0, 3, 4);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionEgressPortsAdd, 0,
                                         _FieldActionRedirectSet,
                                         offset + 6, 10, -1, offset + 0, 3, 5);
    _FP_ACTION_WITH_ASET_ADD_THREE(unit, stage_fc, bcmFieldActionFabricEHAddOrUpdate, 0,
                                         _FieldActionRedirectSet,
                      offset + 3, 32, -1, offset + 35, 3, -1, offset + 0, 3, 6);

    /* IFP_NAT_SET(12b) */
    offset = nat_offset;

    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionNat,
                                    0, _FieldActionNatSet, offset + 11, 1, 1);
    _FP_ACTION_WITH_ASET_ADD_TWO(unit, stage_fc, bcmFieldActionNatEgressOverride,
                                    0, _FieldActionNatSet,
                                    offset + 0, 10, -1, offset + 10, 1, -1);
    /* ExactMatch Action Class Id (12b) */
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionExactMatchClassId,
                       _BCM_FIELD_ACTION_NO_IFP_SUPPORT, 0, 12, 0);

    /* TIMESTAMP_SET(4b) */
    offset = timestamp_offset;
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionIngressTimeStampInsert,
                                        0, _FieldActionTimestampInsertionSet,
                                        offset + 0, 2, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionIngressTimeStampInsertCancel,
                                        0, _FieldActionTimestampInsertionSet,
                                        offset + 0, 2, 2);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionEgressTimeStampInsert,
                                        0, _FieldActionTimestampInsertionSet,
                                        offset + 2, 2, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionEgressTimeStampInsertCancel,
                                        0, _FieldActionTimestampInsertionSet,
                                        offset + 2, 2, 2);
        /* DLB_HGT_LAG_SET(2b) */
    offset = dlb_hgt_lag_offset;
    if (soc_feature(unit, soc_feature_lag_dlb)) {
        _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDynamicTrunkEnable,
                    0, _FieldActionHgtLagDlbActionSet, offset + 0, 1, 1);
        _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDynamicTrunkCancel,
                    0, _FieldActionHgtLagDlbActionSet, offset + 1, 1, 1);
    }
    if (soc_feature(unit, soc_feature_hg_dlb)) {
        _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDynamicHgTrunkEnable,
                    0, _FieldActionHgtLagDlbActionSet, offset + 0, 1, 1);
        _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDynamicHgTrunkCancel,
                    0, _FieldActionHgtLagDlbActionSet, offset + 1, 1, 1);
    }

#if defined(INCLUDE_L3)
    /* PROTECTION_SWITCHING_SET(1b) */
    offset = prot_switch_offset;
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRecoverableDropCancel,
                          0, _FieldActionProtectionSwitchingDropOverrideSet,
                          offset + 0, 1, 1);

    /* DLB_ECMP_SET(2b) */
    offset = dlb_ecmp_offset;
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDynamicEcmpEnable,
                            0, _FieldActionEcmpDlbActionSet, offset + 0, 1, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDynamicEcmpCancel,
                            0, _FieldActionEcmpDlbActionSet, offset + 1, 1, 1);

    /* DLB_ALTERNATE_PATH_CONTROL_SET(10b) */
    offset = dlb_alternate_path_control_offset;
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDgm,
                                 0, _FieldActionIfpDlbAlternatePathControlSet,
                                 offset + 0, 1, 1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDgmThreshold,
                                 0, _FieldActionIfpDlbAlternatePathControlSet,
                                 offset + 7, 3, -1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDgmBias,
                                 0, _FieldActionIfpDlbAlternatePathControlSet,
                                 offset + 4, 3, -1);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDgmCost,
                                 0, _FieldActionIfpDlbAlternatePathControlSet,
                                 offset + 1, 3, -1);
#endif /* INCLUDE_L3 */
    /* All actions which have corresponding Colored(Gp/Yp/Rp) Actions needs to be
     * initialized with some default configuration(offset = 0, width = 0, value = 0).
     */
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionCosQNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioIntCopy, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioIntNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioIntTos, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioIntCancel, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionUcastCosQNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionMcastCosQNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionDropPrecedence, 0, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionColorIndependent,
                                 0, _FieldActionGreenToPidSet, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionEcnNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktCopy, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktTos, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktCancel, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionDscpNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionDscpCancel, 0, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionCopyToCpu,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionCopyToCpuCancel,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionSwitchToCpuCancel,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionSwitchToCpuReinstate,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionTimeStampToCpu,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionTimeStampToCpuCancel,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionGpTimeStampToCpuCancel,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionYpTimeStampToCpuCancel,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionRpTimeStampToCpuCancel,
                                 0, _FieldActionCopyToCpuSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDrop,
                                 0, _FieldActionDropSet, 0, 0, 0);
    _FP_ACTION_WITH_ASET_ADD_ONE(unit, stage_fc, bcmFieldActionDropCancel,
                                 0, _FieldActionDropSet, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktAndIntCopy, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktAndIntNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktAndIntTos, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionPrioPktAndIntCancel, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktAndIntCopy, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktAndIntNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktAndIntTos, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionRpPrioPktAndIntCancel, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktAndIntCopy, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktAndIntNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktAndIntTos, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionGpPrioPktAndIntCancel, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktAndIntCopy, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktAndIntNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktAndIntTos, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionYpPrioPktAndIntCancel, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionCosMapNew, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionDscpPreserve, 0, 0, 0, 0);
    _FP_ACTION_ADD_ONE(unit, stage_fc, bcmFieldActionDot1pPreserve, 0, 0, 0, 0);

    return BCM_E_NONE;
}
#endif /*BCM_TOMAHAWK2_SUPPORT*/


/*
 * Function:
 *     _field_th_actionss_init
 * Purpose:
 *     Initialize device actions offsets, widths and encodings.
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     stage_fc   - (IN) Field Processor stage control structure.
 *
 * Returns:
 *     BCM_E_NONE
 * Notes:
 */
STATIC int
_field_th_actions_init(int unit, _field_stage_t *stage_fc)
{
    switch (stage_fc->stage_id) {
        case _BCM_FIELD_STAGE_INGRESS:
        case _BCM_FIELD_STAGE_EXACTMATCH:
             /* Allocated stage qualifiers configuration array. */
             _FP_XGS3_ALLOC(stage_fc->f_action_arr,
                   (_bcmFieldActionCount * sizeof(_bcm_field_action_conf_t *)),
                   "Field Actions");
             if (NULL == stage_fc->f_action_arr) {
                LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META(
                   "TH Actions INIT Memory Resource Error\n")));
                return (BCM_E_MEMORY);
             }
#if defined(BCM_TRIDENT3_SUPPORT)
             if(soc_feature(unit, soc_feature_ifp_action_profiling)) {
                 return (_field_td3_common_actions_init(unit, stage_fc));
             } else
#endif
#ifdef BCM_TOMAHAWK2_SUPPORT
             if (SOC_IS_TOMAHAWK2(unit)) {
                 return (_field_th2_common_actions_init(unit, stage_fc));
             } else
#endif
#if defined(BCM_TOMAHAWK3_SUPPORT)
            if (SOC_IS_TOMAHAWK3(unit)) {
                return _bcm_field_th3_common_actions_init(unit, stage_fc);
            } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
            {
                return (_field_th_common_actions_init(unit, stage_fc));
            }
            break;
        default:
            break;
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_th_lookup_qualifiers_init
 * Purpose:
 *     Initialize device stage lookup qaualifiers
 *     select codes & offsets
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     stage_fc   - (IN) Field Processor stage control structure.
 * Returns:
 *     BCM_E_NONE
 */
STATIC int
_field_th_lookup_qualifiers_init(int unit, _field_stage_t *stage_fc)
{
    uint32 cancun_ver;
    const unsigned f1_offset = 164, f2_offset = 36, f3_offset = 0;
    _FP_QUAL_DECL;

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Allocated stage qualifiers configuration array. */
    _FP_XGS3_ALLOC(stage_fc->f_qual_arr,
        (_bcmFieldQualifyCount * sizeof(_bcm_field_qual_info_t *)),
         "Field qualifiers");
    if (NULL == stage_fc->f_qual_arr) {
        return (BCM_E_MEMORY);
    }

    /* Enable the overlay of Sender Ethernet Address onto MACSA
     * on ARP/RARP packets.
     */
    BCM_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, ING_CONFIG_64r, REG_PORT_ANY,
                                ARP_VALIDATION_ENf, 1));

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyStageLookup,
                 _bcmFieldSliceSelDisable, 0, 0, 0);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIp4,
                 _bcmFieldSliceSelDisable, 0, 0, 0);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIp6,
                 _bcmFieldSliceSelDisable, 0, 0, 0);

    /* FPF1 */
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyInnerIpProtocolCommon,
                               _bcmFieldSliceSelFpf1, 0,
                               _bcmFieldSliceIpHeaderSelect, 1, f1_offset, 3);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIpProtocolCommon,
                               _bcmFieldSliceSelFpf1, 0,
                               _bcmFieldSliceIpHeaderSelect, 0, f1_offset, 3);
    if (!soc_feature(unit, soc_feature_td3_style_fp)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyTunnelTerminated,
                     _bcmFieldSliceSelFpf1, 0, f1_offset + 3, 1);
    }
    /* 1-bit IpInfo is used to qualify on BCM_FIELD_IP_CHECKSUM_OK */
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIpInfo,
                 _bcmFieldSliceSelFpf1, 0, f1_offset + 4, 1);

    if (!soc_feature(unit, soc_feature_fp_no_inner_vlan_support)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerTpid,
                     _bcmFieldSliceSelFpf1, 0, f1_offset + 5, 2);
    }

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterTpid,
                 _bcmFieldSliceSelFpf1, 0, f1_offset + 7, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL2Format,
                 _bcmFieldSliceSelFpf1, 0, f1_offset + 9, 2);

    if (soc_feature(unit, soc_feature_higig_lookup)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigProxy,
                     _bcmFieldSliceSelFpf1, 0, f1_offset + 11, 1);
    }

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGig,
                 _bcmFieldSliceSelFpf1, 0, f1_offset + 12, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlan,
                 _bcmFieldSliceSelFpf1, 0, f1_offset + 13, 16);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlanId,
                 _bcmFieldSliceSelFpf1, 0, f1_offset + 13, 12);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlanCfi,
                 _bcmFieldSliceSelFpf1, 0, f1_offset + 25, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlanPri,
                 _bcmFieldSliceSelFpf1, 0, f1_offset + 26, 3);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVlanFormat,
                 _bcmFieldSliceSelFpf1, 0, f1_offset + 29, 2);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerIpType,
                               _bcmFieldSliceSelFpf1, 0,
                               _bcmFieldSliceIpHeaderSelect, 1, f1_offset + 31,
                               5);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIpType,
                               _bcmFieldSliceSelFpf1, 0,
                               _bcmFieldSliceIpHeaderSelect, 0, f1_offset + 31,
                               5);
    _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifySrcPort,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf1, 0,
                     _bcmFieldSliceSrcEntitySelect, _bcmFieldFwdEntityGlp,
                     0,
                     f1_offset + 36, 8, /* Port value in SGLP */
                     f1_offset + 44, 8, /* Module value in SGLP */
                     f1_offset + 52, 1, /* Trunk bit in SGLP (should be 0) */
                     0
                     );

    _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifySrcTrunk,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf1, 0,
                     _bcmFieldSliceSrcEntitySelect, _bcmFieldFwdEntityGlp,
                     0,
                     f1_offset + 36, 16, /* trunk id field of SGLP */
                     f1_offset + 52, 1,  /* trunk bit of SGLP */
                     0, 0,
                     0
                     );
    _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifySrcGport,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf1, 0,
                     _bcmFieldSliceSrcEntitySelect, _bcmFieldFwdEntityGlp,
                     0,
                     f1_offset + 36, 8, /* Port value in SGLP */
                     f1_offset + 44, 8, /* Module value in SGLP */
                     f1_offset + 52, 1, /* Trunk bit in SGLP (should be 0) */
                     0
                     );


    if (!soc_feature(unit, soc_feature_fp_no_dvp_support)) {

        _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifySrcMplsGport,
                         _bcmFieldDevSelDisable, 0,
                         _bcmFieldSliceSelFpf1, 0,
                         _bcmFieldSliceSrcEntitySelect, _bcmFieldFwdEntityMplsGport,
                         0,
                         f1_offset + 36, 17, /* S_FIELD */
                         f1_offset + 56, 1,  /* SVP_VALID */
                         0, 0,
                         0
                         );

        _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifySrcMimGport,
                         _bcmFieldDevSelDisable, 0,
                         _bcmFieldSliceSelFpf1, 0,
                         _bcmFieldSliceSrcEntitySelect, _bcmFieldFwdEntityMimGport,
                         0,
                         f1_offset + 36, 17, /* S_FIELD */
                         f1_offset + 56, 1,  /* SVP_VALID */
                         0, 0,
                         0
                         );

         _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifySrcVxlanGport,
                          _bcmFieldDevSelDisable, 0,
                          _bcmFieldSliceSelFpf1, 0,
                          _bcmFieldSliceSrcEntitySelect,
                          _bcmFieldFwdEntityVxlanGport,
                          0,
                          f1_offset + 36, 17, /* S_FIELD */
                          f1_offset + 56, 1,  /* SVP_VALID */
                          0, 0,
                          0
                          );
    }

    _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifySrcModPortGport,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf1, 0,
                     _bcmFieldSliceSrcEntitySelect,
                     _bcmFieldFwdEntityModPortGport,
                     0,
                     f1_offset + 36, 16, /* mod + port field of unresolved SGLP */
                     0, 0,
                     0, 0,
                     0
                     );

    _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifySrcModuleGport,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf1, 0,
                     _bcmFieldSliceSrcEntitySelect,
                     _bcmFieldFwdEntityModPortGport,
                     0,
                     f1_offset + 36 + 8, 8, /* mod field of unresolved SGLP */
                     0, 0,
                     0, 0,
                     0
                     );

    _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifyInPort,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf1, 0,
                     _bcmFieldSliceSrcEntitySelect,
                     _bcmFieldFwdEntityPortGroupNum,
                     0,
                     f1_offset + 36, 8, /* ingress port field */
                     0, 0,
                     0, 0,
                     0
                     );

    _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassPort,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf1, 0,
                     _bcmFieldSliceSrcEntitySelect,
                     _bcmFieldFwdEntityPortGroupNum,
                     0,
                     f1_offset + 36 + 8, 8, /* ingress port group field */
                     0, 0,
                     0, 0,
                     0
                     );

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL4Ports,
                 _bcmFieldSliceSelFpf1, 0, f1_offset + 57, 1);

#if defined (BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_th3_style_fp)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOpaqueTagType,
                     _bcmFieldSliceSelFpf1, 0, f1_offset + 58, 2);
    }
#endif

#if defined(BCM_HURRICANE4_SUPPORT) && defined(INCLUDE_XFLOW_MACSEC)
    if (soc_feature(unit, soc_feature_xflow_macsec_svtag)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyMacSecFlow,
                     _bcmFieldSliceSelFpf1, 0, f1_offset + 58, 2);
    }
#endif

    /* F2_0 */
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerTtl,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset, 8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyTtl,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyTcpControl,
                 _bcmFieldSliceSelFpf2, 0, f2_offset + 8, 6);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerIpFrag,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 14,
                               2);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIpFrag,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 14,
                               2);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerTos,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 16,
                               8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyTos,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 16,
                               8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerL4DstPort,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 24,
                               16);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyL4DstPort,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 24,
                               16);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerL4SrcPort,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 40,
                               16);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyL4SrcPort,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 40,
                               16);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIcmpTypeCode,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 40,
                               16);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerIpProtocol,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 56,
                               8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIpProtocol,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 56,
                               8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerDstIp,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 64,
                               32);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstIp,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 64,
                               32);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerSrcIp,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 96,
                               32);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcIp,
                               _bcmFieldSliceSelFpf2, 0,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 96,
                               32);

    /* F2_1 */
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerSrcIp6,
                               _bcmFieldSliceSelFpf2, 1,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset, 128);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcIp6,
                               _bcmFieldSliceSelFpf2, 1,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset, 128);

    /* F2_2 */
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerDstIp6,
                               _bcmFieldSliceSelFpf2, 2,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset, 128);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstIp6,
                               _bcmFieldSliceSelFpf2, 2,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset, 128);

    /* F2_3 */
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyEtherType,
                 _bcmFieldSliceSelFpf2, 3, f2_offset + 16, 16);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifySrcMac,
                 _bcmFieldSliceSelFpf2, 3, f2_offset + 32, 48);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDstMac,
                 _bcmFieldSliceSelFpf2, 3, f2_offset + 80, 48);

    /* F2_4 */
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerTos,
                               _bcmFieldSliceSelFpf2, 4,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset, 8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyTos,
                               _bcmFieldSliceSelFpf2, 4,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset, 8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerIpProtocol,
                               _bcmFieldSliceSelFpf2, 4,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 8,
                               8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIpProtocol,
                               _bcmFieldSliceSelFpf2, 4,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 8,
                               8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerDstIp,
                               _bcmFieldSliceSelFpf2, 4,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 16,
                               32);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstIp,
                               _bcmFieldSliceSelFpf2, 4,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 16,
                               32);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerSrcIp,
                               _bcmFieldSliceSelFpf2, 4,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 48,
                               32);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcIp,
                               _bcmFieldSliceSelFpf2, 4,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 48,
                               32);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifySrcMac,
                 _bcmFieldSliceSelFpf2, 4, f2_offset + 80, 48);

    /* F2_5 */
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerTos,
                               _bcmFieldSliceSelFpf2, 5,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset, 8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyTos,
                               _bcmFieldSliceSelFpf2, 5,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset, 8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerIpProtocol,
                               _bcmFieldSliceSelFpf2, 5,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 8,
                               8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIpProtocol,
                               _bcmFieldSliceSelFpf2, 5,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 8,
                               8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerDstIp,
                               _bcmFieldSliceSelFpf2, 5,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 16,
                               32);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstIp,
                               _bcmFieldSliceSelFpf2, 5,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 16,
                               32);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerSrcIp,
                               _bcmFieldSliceSelFpf2, 5,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 48,
                               32);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcIp,
                               _bcmFieldSliceSelFpf2, 5,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 48,
                               32);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDstMac,
                 _bcmFieldSliceSelFpf2, 5, f2_offset + 80, 48);

    /* F2_6 */
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerSrcIp6High,
                               _bcmFieldSliceSelFpf2, 6,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset, 64);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcIp6High,
                               _bcmFieldSliceSelFpf2, 6,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset, 64);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerDstIp6High,
                               _bcmFieldSliceSelFpf2, 6,
                               _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 64,
                               64);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstIp6High,
                               _bcmFieldSliceSelFpf2, 6,
                               _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 64,
                               64);

    /* F2_7 */

    if (!soc_feature(unit, soc_feature_fp_no_inner_vlan_support)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVnTag,
                     _bcmFieldSliceSelFpf2, 7, f2_offset + 0, 33);
    }
    if (soc_feature(unit, soc_feature_niv)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVnTag,
                     _bcmFieldSliceSelFpf2, 7, f2_offset + 0, 33);
    }
    if (soc_feature(unit, soc_feature_snap)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifySnap,
                     _bcmFieldSliceSelFpf2, 7, f2_offset + 64, 40);
    }
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyLlc,
                 _bcmFieldSliceSelFpf2, 7, f2_offset + 104, 24);

    /* F2_8 */
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData0,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 0, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData1,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 16, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData2,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 32, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData3,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 48, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData4,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 64, 16);
       /* IP header Identifier field is mapped to UDF Chunk 4. */ 
       BCM_IF_ERROR_RETURN(soc_cancun_version_get(unit, &cancun_ver));
       if (SOC_CANCUN_VERSION_5_2_UNDER_SERIES(cancun_ver)) {
           _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIpIdentifier,
                      _bcmFieldSliceSelFpf2, 8, f2_offset + 64, 16);
       }
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData5,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 80, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData6,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 96, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData7,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 112, 16);
       /* UDF2 Chunk 6 and 7 */
       _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyINTProbeMarker1,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 96, 32);
       /* UDF2 Chunk 4 and 5 */
       _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyINTProbeMarker2,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 64, 32);
       /* UDF2 Chunk 2 and 3 */
       _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyINTReserved4Bytes,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 32, 32);
#if defined(BCM_TOMAHAWK3_SUPPORT)
    } else if (soc_feature(unit, soc_feature_udf_selector_support)) {
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData7,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 0, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData6,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 16, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData5,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 32, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData4,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 48, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData3,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 64, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData2,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 80, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData1,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 96, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData0,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 112, 16);
#endif
    } else {
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData4,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 0, 32);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData3,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 32, 32);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData2,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 64, 32);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData1,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 96, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData0,
                    _bcmFieldSliceSelFpf2, 8, f2_offset + 112, 16);
    }

    /* F2_9 */
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData8,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 0, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData9,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 16, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData10,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 32, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData11,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 48, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData12,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 64, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData13,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 80, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData14,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 96, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData15,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 112, 16);
#if defined(BCM_TOMAHAWK3_SUPPORT)
    } else if (soc_feature(unit, soc_feature_udf_selector_support)) {
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData15,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 0, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData14,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 16, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData13,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 32, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData12,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 48, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData11,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 64, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData10,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 80, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData9,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 96, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData8,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 112, 16);
#endif
    } else {
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData9,
                    _bcmFieldSliceSelFpf2, 9, f2_offset, 32);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData8,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 32, 32);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData7,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 64, 32);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData6,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 96, 16);
       _FP_QUAL_ADD(unit, stage_fc, _bcmFieldQualifyData5,
                    _bcmFieldSliceSelFpf2, 9, f2_offset + 112, 16);
    }

    /* F2_10 */

    if (soc_feature(unit, soc_feature_fcoe)) {

        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFibreChanInner,
                     _bcmFieldSliceSelFpf2, 10, f2_offset + 0, 3);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFibreChanOuter,
                     _bcmFieldSliceSelFpf2, 10, f2_offset + 3, 3);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFcoeSOF,
                     _bcmFieldSliceSelFpf2, 10, f2_offset + 6, 8);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFibreChanDFCtl,
                     _bcmFieldSliceSelFpf2, 10, f2_offset + 14, 8);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFibreChanCSCtl,
                     _bcmFieldSliceSelFpf2, 10, f2_offset + 22, 8);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFibreChanFCtl,
                     _bcmFieldSliceSelFpf2, 10, f2_offset + 30, 24);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFibreChanType,
                     _bcmFieldSliceSelFpf2, 10, f2_offset + 54, 8);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFibreChanDstId,
                     _bcmFieldSliceSelFpf2, 10, f2_offset + 62, 24);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFibreChanSrcId,
                     _bcmFieldSliceSelFpf2, 10, f2_offset + 86, 24);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFibreChanRCtl,
                     _bcmFieldSliceSelFpf2, 10, f2_offset + 110, 8);
    }
    /* F3_0 */

    if (!soc_feature(unit, soc_feature_fp_no_inner_vlan_support)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlan,
                     _bcmFieldSliceSelFpf3, 0, f3_offset + 0, 16);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanId,
                     _bcmFieldSliceSelFpf3, 0, f3_offset + 0, 12);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanCfi,
                     _bcmFieldSliceSelFpf3, 0, f3_offset + 12, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanPri,
                     _bcmFieldSliceSelFpf3, 0, f3_offset + 13, 3);
    }

#if defined (BCM_TOMAHAWK3_SUPPORT)
    if (SOC_IS_TOMAHAWK3(unit)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyEtherType,
                 _bcmFieldSliceSelFpf3, 0, f3_offset + 0, 16);
    } else
#endif
    {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyEtherType,
                 _bcmFieldSliceSelFpf3, 0, f3_offset + 16, 16);
    }

    /* F3_1 */
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerL4DstPort,
                               _bcmFieldSliceSelFpf3, 1,
                               _bcmFieldSliceIpHeaderSelect, 1, f3_offset + 0,
                               16);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyL4DstPort,
                               _bcmFieldSliceSelFpf3, 1,
                               _bcmFieldSliceIpHeaderSelect, 0, f3_offset + 0,
                               16);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerL4SrcPort,
                               _bcmFieldSliceSelFpf3, 1,
                               _bcmFieldSliceIpHeaderSelect, 1, f3_offset + 16,
                               16);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyL4SrcPort,
                               _bcmFieldSliceSelFpf3, 1,
                               _bcmFieldSliceIpHeaderSelect, 0, f3_offset + 16,
                               16);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIcmpTypeCode,
                               _bcmFieldSliceSelFpf3, 1,
                               _bcmFieldSliceIpHeaderSelect, 0, f3_offset + 16,
                               16);

    /* F3_2 */
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerTos,
                               _bcmFieldSliceSelFpf3, 2,
                               _bcmFieldSliceIpHeaderSelect, 1, f3_offset + 0,
                               8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyTos,
                               _bcmFieldSliceSelFpf3, 2,
                               _bcmFieldSliceIpHeaderSelect, 0, f3_offset + 0,
                               8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInnerIpProtocol,
                               _bcmFieldSliceSelFpf3, 2,
                               _bcmFieldSliceIpHeaderSelect, 1, f3_offset + 8,
                               8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIpProtocol,
                               _bcmFieldSliceSelFpf3, 2,
                               _bcmFieldSliceIpHeaderSelect, 0, f3_offset + 8,
                               8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyExtensionHeaderSubCode,
                 _bcmFieldSliceSelFpf3, 2, f3_offset + 16, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyExtensionHeaderType,
                 _bcmFieldSliceSelFpf3, 2, f3_offset + 24, 8);


    /* F3_3 */
#ifdef BCM_TRIDENT3_SUPPORT
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlan,
                _bcmFieldSliceSelFpf3, 3, f3_offset, 16);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanId,
                _bcmFieldSliceSelFpf3, 3, f3_offset, 12);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanCfi,
                _bcmFieldSliceSelFpf3, 3, f3_offset + 12, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanPri,
                _bcmFieldSliceSelFpf3, 3, f3_offset + 13, 3);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifySrcModuleGport,
                _bcmFieldSliceSelFpf3, 3, f3_offset + 16, 8);
    } else
#endif
#ifdef BCM_TOMAHAWK2_SUPPORT
    if (SOC_IS_TOMAHAWK2(unit)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL3,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 0, 12);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlan,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 12, 16);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanId,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 12, 12);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanCfi,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 24, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanPri,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 25, 3);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifySrcModuleGport,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 28, 8);
    } else
#endif /*BCM_TOMAHAWK2_SUPPORT*/
#ifdef BCM_TOMAHAWK3_SUPPORT
    if (SOC_IS_TOMAHAWK3(unit)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL3,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 0, 12);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifySrcModuleGport,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 28, 8);
    } else
#endif /*BCM_TOMAHAWK3_SUPPORT*/
    {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL3,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 0, 8);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlan,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 8, 16);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanId,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 8, 12);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanCfi,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 20, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanPri,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 21, 3);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifySrcModuleGport,
                     _bcmFieldSliceSelFpf3, 3, f3_offset + 24, 8);
    }

    /* F3_4 ? */

    /* F3_5 */
    if (soc_feature(unit, soc_feature_fcoe)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFibreChanVFTHopCount,
                     _bcmFieldSliceSelFpf3, 5, f3_offset, 8);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFibreChanVFTVsanId,
                     _bcmFieldSliceSelFpf3, 5, f3_offset + 8, 12);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFibreChanVFTVsanPri,
                     _bcmFieldSliceSelFpf3, 5, f3_offset + 20, 3);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFibreChanVFTVersion,
                     _bcmFieldSliceSelFpf3, 5, f3_offset + 23, 2);
    }

    /* DWF3 */
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerTos,
                            _bcmFieldSliceSelFpf3, 0,
                            _bcmFieldSliceIpHeaderSelect, 1, f3_offset + 0, 8);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyTos,
                            _bcmFieldSliceSelFpf3, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f3_offset + 0, 8);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerTtl,
                            _bcmFieldSliceSelFpf3, 0,
                            _bcmFieldSliceIpHeaderSelect, 1, f3_offset + 8, 8);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyTtl,
                            _bcmFieldSliceSelFpf3, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f3_offset + 8, 8);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyTcpControl,
                            _bcmFieldSliceSelFpf3, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f3_offset + 16,
                            6);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerIpFrag,
                            _bcmFieldSliceSelFpf3, 0,
                            _bcmFieldSliceIpHeaderSelect, 1, f3_offset + 22,
                            2);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyIpFrag,
                            _bcmFieldSliceSelFpf3, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f3_offset + 22,
                            2);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerIpProtocol,
                            _bcmFieldSliceSelFpf3, 0,
                            _bcmFieldSliceIpHeaderSelect, 1, f3_offset + 24,
                            8);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyIpProtocol,
                            _bcmFieldSliceSelFpf3, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f3_offset + 24,
                            8);

    /* DWF2_0 */
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerTtl,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 0,
                            8);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyTtl,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 0,
                            8);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyTcpControl,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 8,
                            6);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerIpFrag,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 14,
                            2);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyIpFrag,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 14,
                            2);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerTos,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 16,
                            8);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyTos,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 16,
                            8);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerL4DstPort,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 24,
                            16);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyL4DstPort,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 24,
                            16);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerL4SrcPort,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 40,
                            16);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyL4SrcPort,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 40,
                            16);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyIcmpTypeCode,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 40,
                            16);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerIpProtocol,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 56,
                            8);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyIpProtocol,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 56,
                            8);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerDstIp,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 64,
                            32);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyDstIp,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 64,
                            32);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerSrcIp,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 96,
                            32);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifySrcIp,
                            _bcmFieldSliceSelFpf2, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 96,
                            32);

    /* DWF2_1 */
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerSrcIp6,
                            _bcmFieldSliceSelFpf2, 1,
                            _bcmFieldSliceIpHeaderSelect, 1, f2_offset,
                            128);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifySrcIp6,
                            _bcmFieldSliceSelFpf2, 1,
                            _bcmFieldSliceIpHeaderSelect, 0, f2_offset,
                            128);

    if (!soc_feature(unit, soc_feature_td3_style_fp)) {
       /* DWF2_2 */
       _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, _bcmFieldQualifyData1,
                            _bcmFieldSliceSelFpf2, 2,
                            _bcmFieldSliceSelDisable, 0,
                            f2_offset, 128);
    }

#if defined (BCM_TOMAHAWK3_SUPPORT)
    if (SOC_IS_TOMAHAWK3(unit)) {
        /* DWF2_3 */
        _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInnerDstIp6High,
                                _bcmFieldSliceSelFpf2, 3,
                                _bcmFieldSliceIpHeaderSelect, 1, f2_offset + 64,
                                64);
        _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyDstIp6High,
                                _bcmFieldSliceSelFpf2, 3,
                                _bcmFieldSliceIpHeaderSelect, 0, f2_offset + 64,
                                64);
        _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyDstMac,
                                _bcmFieldSliceSelFpf2, 3,
                                _bcmFieldSliceSelDisable, 0,
                                f2_offset, 48);
    }
#endif

    /* DWF1 */
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc,
                            bcmFieldQualifyExtensionHeaderSubCode,
                            _bcmFieldSliceSelFpf1, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f1_offset + 0,
                            8);
    _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyExtensionHeaderType,
                            _bcmFieldSliceSelFpf1, 0,
                            _bcmFieldSliceIpHeaderSelect, 0, f1_offset + 8,
                            8);
#if defined (BCM_TOMAHAWK3_SUPPORT)
   if (soc_feature(unit, soc_feature_th3_style_fp)) {
       _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL3,
                                _bcmFieldSliceSelFpf1, 0,
                                _bcmFieldSliceIpHeaderSelect, 0, f1_offset + 16,
                                12);
        _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyEtherType,
                                _bcmFieldSliceSelFpf1, 0,
                                _bcmFieldSliceIpHeaderSelect, 0, f1_offset + 28,
                                16);
   } else
#endif
#if defined (BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyEtherType,
                                _bcmFieldSliceSelFpf1, 0,
                                _bcmFieldSliceIpHeaderSelect, 0, f1_offset + 16,
                                16);
    } else
#endif
    {
        _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL3,
                                _bcmFieldSliceSelFpf1, 0,
                                _bcmFieldSliceIpHeaderSelect, 0, f1_offset + 16,
                                8);
        _FP_QUAL_INTRASLICE_ADD(unit, stage_fc, bcmFieldQualifyEtherType,
                                _bcmFieldSliceSelFpf1, 0,
                                _bcmFieldSliceIpHeaderSelect, 0, f1_offset + 24,
                                16);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_th_egress_qualifiers_init
 * Purpose:
 *     Initialize device stage egress qaualifiers
 *     select codes & offsets
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     stage_fc   - (IN) Field Processor stage control structure.
 *
 * Returns:
 *     BCM_E_NONE
 */
STATIC int
_field_th_egress_qualifiers_init(int unit, _field_stage_t *stage_fc)
{
    _FP_QUAL_DECL;
    _key_fld_ = KEYf;

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Allocated stage qualifiers configuration array. */
    _FP_XGS3_ALLOC(stage_fc->f_qual_arr,
        (_bcmFieldQualifyCount * sizeof(_bcm_field_qual_info_t *)),
         "Field qualifiers");
    if (NULL == stage_fc->f_qual_arr) {
        return (BCM_E_MEMORY);
    }

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyStageEgress,
                 _bcmFieldSliceSelDisable, 0, 0, 0);

   /* EFP_KEY4(L2 Key) Qualifiers */
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL4Ports,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 0, 1);


    if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        /* EG_NEXT_HOP_CLASS_ID */
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClass,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                                   _bcmFieldSliceSelEgrClassKey4, 1,
                                   2, 12);
        /* EG_L3_INTF_CLASS_ID */
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                                   bcmFieldQualifyEgressClassL3Interface,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                                   _bcmFieldSliceSelEgrClassKey4, 2,
                                   2, 12);
    }

    if (!soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        /* EG_NEXT_HOP_CLASS_ID */
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClass,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                                   _bcmFieldSliceSelEgrDvpKey4, 1,
                                   2, 12);
        /* EG_L3_INTF_CLASS_ID */
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                                   bcmFieldQualifyEgressClassL3Interface,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                                   _bcmFieldSliceSelEgrDvpKey4, 2,
                                   2, 12);
        /* EG_DVP_CLASS_ID */
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassTrill,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                                   _bcmFieldSliceSelEgrDvpKey4, 3,
                                   2, 12);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassWlan,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                                   _bcmFieldSliceSelEgrDvpKey4, 3,
                                   2, 12);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassL2Gre,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                                   _bcmFieldSliceSelEgrDvpKey4, 3,
                                   2, 12);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassVxlan,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                                   _bcmFieldSliceSelEgrDvpKey4, 3,
                                   2, 12);

        /* DVP_VALID + DVP + SPARE_DVP */
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstMplsGport,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                                   _bcmFieldSliceSelEgrDvpKey4, 0,
                                   1, 17);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstMimGport,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                                   _bcmFieldSliceSelEgrDvpKey4, 0,
                                   1, 17);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstVxlanGport,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                                   _bcmFieldSliceSelEgrDvpKey4, 0,
                                   1, 17);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                                   bcmFieldQualifyDestVirtualPortValid,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                                   _bcmFieldSliceSelEgrDvpKey4, 0,
                                   1, 1);
    }

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIntPriority,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 18, 4);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyColor,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 22, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL2Format,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 24, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyEtherType,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 26, 16);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifySrcMac,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 42, 48);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDstMac,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 90, 48);

    if (!soc_feature(unit, soc_feature_fp_no_inner_vlan_support)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVlanTranslationHit,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 138, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlan,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 141, 16);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanCfi,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 141, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanPri,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 142, 3);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanId,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 145, 12);
    }

    if (soc_feature(unit, soc_feature_higig_lookup)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigProxy,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 139, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGig,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 140, 1);
    }

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 157, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL3Routable,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 165, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyMirrorCopy,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 166, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlan,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 167, 16);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlanId,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 167, 12);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlanCfi,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 179, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlanPri,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 180, 3);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVlanFormat,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 183, 2);


    if (soc_feature(unit, soc_feature_higig_lookup)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDstHiGig,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 185, 1);
    }

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 186, 8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                               _bcmFieldSliceSelEgrClassF4, 0,
                               194, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                               _bcmFieldSliceSelEgrClassF4, 0,
                               194, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                               _bcmFieldSliceSelEgrClassF4, 0,
                               194, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                               _bcmFieldSliceSelEgrClassF4, 0,
                               194, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                               _bcmFieldSliceSelEgrClassF4, 0,
                               194, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                               _bcmFieldSliceSelEgrClassF4, 0,
                               194, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                               _bcmFieldSliceSelEgrClassF4, 0,
                               194, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                               _bcmFieldSliceSelEgrClassF4, 0,
                               194, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyOutPort,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                               _bcmFieldSliceSelEgrClassF4, 1,
                               194, 8);
    _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifyCpuQueue,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                     _bcmFieldSliceSelEgrClassF4, 2,
                     0,
                     194, 6, /* CpuCos - 6 bits */
                     0, 0,
                     0, 0,
                     0
                     );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIngressClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                               _bcmFieldSliceSelEgrClassF4, 0,
                               194, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyIngressInterfaceClassPort,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                               _bcmFieldSliceSelEgrClassF4, 0,
                               194, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyIngressInterfaceClassVPort,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4,
                               _bcmFieldSliceSelEgrClassF4, 0,
                               194, 12
                               );
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIpType,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 207, 5);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyForwardingVlanId,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 212, 12);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVrf,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 212, 13);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVpn,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 212,
                 SOC_IS_HELIX5(unit) ? 12 : (SOC_IS_HURRICANE4(unit) ? 10 : 13));

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyForwardingType,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 226, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIntCongestionNotification,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 228, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDrop,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 230, 1);

    /* EFP_KEY1(IPv4 Key) Qualifiers */

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL4Ports,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 0, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIntPriority,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 1, 4);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyColor,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 5, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIpFrag,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 7, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyTcpControl,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 9, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL4DstPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 17, 16);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL4SrcPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 33, 16);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIcmpTypeCode,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 33, 16);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyTtl,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 49, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIpProtocol,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 57, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDstIp,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 65, 32);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifySrcIp,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 97, 32);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyTos,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 129, 8);

    if (soc_feature(unit, soc_feature_higig_lookup)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigProxy,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 137, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGig,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 138, 1);
    }

    if (!soc_feature(unit, soc_feature_fp_no_inner_vlan_support)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanId,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 139, 12);
    }

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 151, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL3Routable,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 159, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyMirrorCopy,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 160, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlan,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 161, 16);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlanId,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 161, 12);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlanCfi,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 173, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlanPri,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 174, 3);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVlanFormat,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 177, 2);


    if (soc_feature(unit, soc_feature_higig_lookup)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDstHiGig,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 179, 1);
    }

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 180, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOutPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 188, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIpType,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 196, 5);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                               _bcmFieldSliceSelEgrClassF1, 0,
                               201, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                               _bcmFieldSliceSelEgrClassF1, 0,
                               201, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                               _bcmFieldSliceSelEgrClassF1, 0,
                               201, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                               _bcmFieldSliceSelEgrClassF1, 0,
                               201, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                               _bcmFieldSliceSelEgrClassF1, 0,
                               201, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                               _bcmFieldSliceSelEgrClassF1, 0,
                               201, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                               _bcmFieldSliceSelEgrClassF1, 0,
                               201, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                               _bcmFieldSliceSelEgrClassF1, 0,
                               201, 13
                               );

    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClass,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                               _bcmFieldSliceSelEgrClassF1, 1,
                               201, 12
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyEgressClassL3Interface,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                               _bcmFieldSliceSelEgrClassF1, 2,
                               201, 12
                               );
    if (!soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassTrill,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                                   _bcmFieldSliceSelEgrClassF1, 3,
                                   201, 12
                                   );
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassL2Gre,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                                   _bcmFieldSliceSelEgrClassF1, 3,
                                   201, 12
                                   );
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassVxlan,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                                   _bcmFieldSliceSelEgrClassF1, 3,
                                   201, 12
                                   );
    }
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIngressClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                               _bcmFieldSliceSelEgrClassF1, 0,
                               201, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyIngressInterfaceClassPort,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                               _bcmFieldSliceSelEgrClassF1, 0,
                               201, 13
                               );
   _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyIngressInterfaceClassVPort,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1,
                               _bcmFieldSliceSelEgrClassF1, 0,
                               201, 13
                               );
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyForwardingVlanId,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 214, 12);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVrf,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 214, 13);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVpn,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 214, 13);

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyForwardingType,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 228, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIntCongestionNotification,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 230, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDrop,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 232, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIp4,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY1, 0, 0);

    /* EFP_KEY2 (IPv6 Singlewide Key) Qualifiers */

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL4Ports,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 0, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIpProtocol,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 1, 8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcIp6,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceIp6AddrSelect,
                               _BCM_FIELD_EGRESS_SLICE_V6_KEY_MODE_SIP6,
                               9, 128);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstIp6,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceIp6AddrSelect,
                               _BCM_FIELD_EGRESS_SLICE_V6_KEY_MODE_DIP6,
                               9, 128);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcIp6High,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceIp6AddrSelect,
                               _BCM_FIELD_EGRESS_SLICE_V6_KEY_MODE_SIP_DIP_64,
                               9, 64);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstIp6High,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceIp6AddrSelect,
                               _BCM_FIELD_EGRESS_SLICE_V6_KEY_MODE_SIP_DIP_64,
                               73, 64);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyTos,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 137, 8);

    if (soc_feature(unit, soc_feature_higig_lookup)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigProxy,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 145, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGig,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 146, 1);
    }

    if (!soc_feature(unit, soc_feature_fp_no_inner_vlan_support)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInnerVlanId,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 147, 12);
    }

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 159, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL3Routable,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 167, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyMirrorCopy,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 168, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlan,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 169, 16);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlanId,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 169, 12);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlanCfi,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 181, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOuterVlanPri,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 182, 3);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVlanFormat,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 185, 2);

    if (soc_feature(unit, soc_feature_higig_lookup)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDstHiGig,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 187, 1);
    }
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 188, 8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 0,
                               196, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 0,
                               196, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 0,
                               196, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 0,
                               196, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 0,
                               196, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 0,
                               196, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 0,
                               196, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 0,
                               196, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIngressClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 0,
                               196, 13
                               );

    if (!soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassTrill,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                                   _bcmFieldSliceSelEgrClassF2, 4,
                                   196, 12
                                   );
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassL2Gre,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                                   _bcmFieldSliceSelEgrClassF2, 4,
                                   196, 12
                                   );
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassVxlan,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                                   _bcmFieldSliceSelEgrClassF2, 4,
                                   196, 12
                                   );
    }

    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClass,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 1,
                               196, 12
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyEgressClassL3Interface,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 2,
                               196, 12
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyOutPort,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 3,
                               196, 8
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIngressClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 0,
                               196, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyIngressInterfaceClassPort,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 0,
                               196, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyIngressInterfaceClassVPort,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2,
                               _bcmFieldSliceSelEgrClassF2, 0,
                               196, 13
                               );
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIpType,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 209, 5);

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyForwardingVlanId,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 214, 12);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVrf,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 214, 13);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVpn,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 214, 13);

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyForwardingType,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 228, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIntCongestionNotification,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 230, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDrop,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 232, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIp6,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY2, 0, 0);

    /* EFP_KEY3 (IPv6 Double Wide Key) Qualifiers */

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL4Ports,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 0, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIntPriority,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 1, 4);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyColor,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 5, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIpFrag,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 7, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyTcpControl,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 9, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL4DstPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 17, 16);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyL4SrcPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 33, 16);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIcmpTypeCode,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 33, 16);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyTtl,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 49, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDstIp6,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 57, 128);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyExtensionHeaderSubCode,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 185, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyExtensionHeaderType,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 193, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIpType,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 201, 5);


    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClass,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3,
                               _bcmFieldSliceSelEgrClassF3, 0,
                               206, 12);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyEgressClassL3Interface,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3,
                               _bcmFieldSliceSelEgrClassF3, 1,
                               206, 12);

    if (!soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassTrill,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3,
                                   _bcmFieldSliceSelEgrClassF3, 3,
                                   206, 12);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassL2Gre,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3,
                                   _bcmFieldSliceSelEgrClassF3, 3,
                                   206, 12);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassVxlan,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3,
                                   _bcmFieldSliceSelEgrClassF3, 3,
                                   206, 12);
    }
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIntCongestionNotification,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 218, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDrop,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 220, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIp6,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY3, 0, 0);
#if defined(BCM_TOMAHAWK2_SUPPORT)
    if (SOC_IS_TOMAHAWK2(unit)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyMplsForwardingLabelExp,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 231, 3);
    }
#endif /* BCM_TOMAHAWK2_SUPPORT */

    /*EFP_KEY6 (HiGiG Key)  Qualifiers*/
    if (soc_feature(unit, soc_feature_higig_lookup)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyFabricQueueTag,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 0, 32);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigDstMulticast,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 148, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigDstMulticastGroupId,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 128, 16);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigTrafficClass,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 144, 4);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigDstModuleGport,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 136, 8);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigDstPortGport,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 128, 8);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigDstModPortGport,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 128, 16);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigSrcModuleGport,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 120, 8);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigSrcPortGport,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 112, 8);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigSrcModPortGport,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 112, 16);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigLoadBalanceID,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 104, 8);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigColor,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 102, 2);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigExtendedHeaderPresent,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 101, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigIntCongestionNotification,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 99, 2);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigMirrorOrSwitchPkt,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 88, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigIngressTagged,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 91, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigDstTrunk,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 95, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigDstTrunkId,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 92, 3);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigIngressL3SwitchPkt,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 85, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigLabelType,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 86, 2);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigMplsPkt,
                    _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 84, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigLabel,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 64, 20);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigReplicationId,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 64, 19);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigVlan,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 48, 16);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigPortFilteringMode,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 46, 2);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigSrcTrunk,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 45, 1);
        _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifyHiGigPreserveFlags,
                     _bcmFieldDevSelDisable, 0,
                    _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                    _bcmFieldDevSelDisable, 0,
                    0,
                    44, 1,
                    43, 1,
                    0, 0,
                    0);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigIngressClassificationTag,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 80, 16);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigEgressMcast,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 95, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigForwardingType,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 90, 5);
        _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifyHiGigVni,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                     _bcmFieldDevSelDisable, 0,
                     0,
                     80, 10,
                     36, 4,
                     0, 0,
                     0);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigDstGport,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 64, 16);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigMulticastIndex,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 64, 16);
        _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifyHiGigVpReplicationId,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                     _bcmFieldDevSelDisable, 0,
                     0,
                     64, 16,
                     40, 3,
                     0, 0,
                     0);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigSrcGport,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 48, 16);
        _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifyHiGigDoNotFlags,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                     _bcmFieldDevSelDisable, 0,
                     0,
                     46, 1,
                     45, 1,
                     0, 0,
                     0);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigVpLagFailoverPacket,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 44, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigProtectionSwitchingStatus,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 43, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigMirrorToVp,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 47, 1);
        _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifyHiGigVpPreserveFlags,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                     _bcmFieldDevSelDisable, 0,
                     0,
                     35, 1,
                     34, 1,
                     0, 0,
                     0);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigDstType,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 33, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigSrcType,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 32, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigOffloadEngineClassificationTag,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 80, 16);
        _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifyHiGigOffloadEngineDeferredFlags,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                     _bcmFieldDevSelDisable, 0,
                     0,
                     79, 1,
                     76, 1,
                     72, 1,
                     0);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigOffloadEngineVxltStatus,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 77, 2);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigOffloadEnginePktPriNew,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 73, 3);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigOffloadEngineDscpNew,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 66, 6);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigOffloadEnginePreserveDscp,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 47, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigOffloadEnginePreserveDot1p,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 46, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigOffloadEngineSrcType,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 43, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyMHOpcode,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 40, 3);

        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigProxy,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 160, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGig,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 161, 1);

        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInPort,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 162, 8);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassPort,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 170, 8);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOutPort,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 178, 8);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassL2,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                                   _bcmFieldSliceSelEgrClassF6, 0,
                                   186, 13
                                   );
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassL3,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                                   _bcmFieldSliceSelEgrClassF6, 0,
                                   186, 13
                                   );
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassField,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                                   _bcmFieldSliceSelEgrClassF6, 0,
                                   186, 13
                                   );
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassField,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                                   _bcmFieldSliceSelEgrClassF6, 0,
                                   186, 13
                                   );
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassL2,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                                   _bcmFieldSliceSelEgrClassF6, 0,
                                   186, 13
                                   );
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassL3,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                                   _bcmFieldSliceSelEgrClassF6, 0,
                                   186, 13
                                   );
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL2,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                                   _bcmFieldSliceSelEgrClassF6, 0,
                                   186, 13
                                   );
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL3,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                                   _bcmFieldSliceSelEgrClassF6, 0,
                                   186, 13
                                   );

        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                                   bcmFieldQualifyIngressInterfaceClassPort,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                                   _bcmFieldSliceSelEgrClassF6, 0,
                                   186, 13
                                   );
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                                   bcmFieldQualifyIngressInterfaceClassVPort,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                                   _bcmFieldSliceSelEgrClassF6, 0,
                                   186, 13
                                   );

        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIngressClassField,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                                   _bcmFieldSliceSelEgrClassF6, 0,
                                   186, 13
                                   );

        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIntCongestionNotification,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 199, 2);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDrop,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6, 201, 1);
    }

    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClass,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                               _bcmFieldSliceSelEgrClassF3, 0,
                               186, 12);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyEgressClassL3Interface,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY6,
                               _bcmFieldSliceSelEgrClassF6, 1,
                               186, 12);

    /* EFP_KEY7(Loopback Key) qualifiers */

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyLoopBackQueue,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 116, 4);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyLoopbackType,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 111, 5);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyLoopBackSrcGport,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 94, 16);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyPktIsVisible,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 93, 1);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyLoopBackCpuMasqueradePktProfile,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 90, 3);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyLoopBackColor,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 4, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyLoopBackTrafficClass,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 0, 4);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyLoopBackPacketProcessingPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 0, 8);


    if (soc_feature(unit, soc_feature_higig_lookup)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigProxy,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 128, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGig,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 129, 1);
    }

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 130, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 138, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyOutPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 146, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIntPriority,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 154, 4);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyColor,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY4, 158, 2);

    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                               _bcmFieldSliceSelEgrClassF7, 0,
                               160, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                               _bcmFieldSliceSelEgrClassF7, 0,
                               160, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                               _bcmFieldSliceSelEgrClassF7, 0,
                               160, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                               _bcmFieldSliceSelEgrClassF7, 0,
                               160, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                               _bcmFieldSliceSelEgrClassF7, 0,
                               160, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                               _bcmFieldSliceSelEgrClassF7, 0,
                               160, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                               _bcmFieldSliceSelEgrClassF7, 0,
                               160, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                               _bcmFieldSliceSelEgrClassF7, 0,
                               160, 13
                               );

    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyIngressInterfaceClassPort,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                               _bcmFieldSliceSelEgrClassF7, 0,
                               160, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyIngressInterfaceClassVPort,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                               _bcmFieldSliceSelEgrClassF7, 0,
                               160, 13
                               );

    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIngressClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                               _bcmFieldSliceSelEgrClassF7, 0,
                               160, 13
                               );

    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClass,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                               _bcmFieldSliceSelEgrClassF7, 1,
                               160, 12);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyEgressClassL3Interface,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                               _bcmFieldSliceSelEgrClassF7, 2,
                               160, 12);

    if (!soc_feature(unit, soc_feature_fp_no_dvp_support)) {

        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassTrill,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                                   _bcmFieldSliceSelEgrClassF7, 3,
                                   160, 12);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassL2Gre,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                                   _bcmFieldSliceSelEgrClassF7, 3,
                                   160, 12);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassVxlan,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                                   _bcmFieldSliceSelEgrClassF7, 3,
                                   160, 12);

        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstMplsGport,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                                   _bcmFieldSliceSelEgrClassF7, 4,
                                   0, 16);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstMimGport,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                                   _bcmFieldSliceSelEgrClassF7, 4,
                                   0, 16);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstVxlanGport,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7,
                                   _bcmFieldSliceSelEgrClassF7, 4,
                                   0, 16);
    }
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIntCongestionNotification,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 173, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDrop,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY7, 175, 1);

    /* EFP_KEY8(Bytes After L2 Key) Qualifiers */
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyL2PayLoad,
                    _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                    _bcmFieldSliceSelDisable, 0, 59, 144);


    /* DVP_VALID + DVP + SPARE_DVP */
    if (!soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstMplsGport,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                                   _bcmFieldSliceSelEgrDvpKey8, 0,
                                   0, 16);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstMimGport,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                                   _bcmFieldSliceSelEgrDvpKey8, 0,
                                   0, 16);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstVxlanGport,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                                   _bcmFieldSliceSelEgrDvpKey8, 0,
                                   0, 16);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                                   bcmFieldQualifyDestVirtualPortValid,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                                   _bcmFieldSliceSelEgrDvpKey8, 0,
                                   0, 1);

        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassTrill,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                                   _bcmFieldSliceSelEgrDvpKey8, 3,
                                   1, 12);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassL2Gre,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                                   _bcmFieldSliceSelEgrDvpKey8, 3,
                                   1, 12);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClassVxlan,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                                   _bcmFieldSliceSelEgrDvpKey8, 3,
                                   1, 12);
    }

    if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClass,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                                   _bcmFieldSliceSelEgrClassKey8, 1,
                                   1, 12);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                                   bcmFieldQualifyEgressClassL3Interface,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                                   _bcmFieldSliceSelEgrClassKey8, 2,
                                   1, 12);
    } else {
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyEgressClass,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                                   _bcmFieldSliceSelEgrDvpKey8, 1,
                                   1, 12);
        _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                                   bcmFieldQualifyEgressClassL3Interface,
                                   _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                                   _bcmFieldSliceSelEgrDvpKey8, 2,
                                   1, 12);
    }

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIntPriority,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 17, 4);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyColor,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 21, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyEtherType,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 23, 16);


    if (soc_feature(unit, soc_feature_higig_lookup)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGigProxy,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 39, 1);
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyHiGig,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 40, 1);
    }


    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 41, 8);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyMirrorCopy,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 49, 1);

    if (soc_feature(unit, soc_feature_higig_lookup)) {
        _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDstHiGig,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 50, 1);
    }

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassPort,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 51, 8);
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyOutPort,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                               _bcmFieldSliceSelEgrClassF8, 1,
                               203, 8);
    _FP_QUAL_EXT_ADD(unit, stage_fc, bcmFieldQualifyCpuQueue,
                     _bcmFieldDevSelDisable, 0,
                     _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                     _bcmFieldSliceSelEgrClassF8, 2,
                     0,
                     203, 6, /* CpuCos - 6 bits */
                     0, 0,
                     0, 0,
                     0
                     );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                               _bcmFieldSliceSelEgrClassF8, 0,
                               203, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                               _bcmFieldSliceSelEgrClassF8, 0,
                               203, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                               _bcmFieldSliceSelEgrClassF8, 0,
                               203, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifySrcClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                               _bcmFieldSliceSelEgrClassF8, 0,
                               203, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                               _bcmFieldSliceSelEgrClassF8, 0,
                               203, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyDstClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                               _bcmFieldSliceSelEgrClassF8, 0,
                               203, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL2,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                               _bcmFieldSliceSelEgrClassF8, 0,
                               203, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyInterfaceClassL3,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                               _bcmFieldSliceSelEgrClassF8, 0,
                               203, 13
                               );

    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyIngressInterfaceClassPort,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                               _bcmFieldSliceSelEgrClassF8, 0,
                               203, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc,
                               bcmFieldQualifyIngressInterfaceClassVPort,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                               _bcmFieldSliceSelEgrClassF8, 0,
                               203, 13
                               );
    _FP_QUAL_TWO_SLICE_SEL_ADD(unit, stage_fc, bcmFieldQualifyIngressClassField,
                               _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8,
                               _bcmFieldSliceSelEgrClassF8, 0,
                               203, 13
                               );

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyForwardingVlanId,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 216, 12);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVrf,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 216, 14);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyVpn,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 216, 14);

    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyForwardingType,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 230, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyIntCongestionNotification,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 232, 2);
    _FP_QUAL_ADD(unit, stage_fc, bcmFieldQualifyDrop,
                 _bcmFieldSliceSelFpf3, _BCM_FIELD_EFP_KEY8, 234, 1);

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_egress_mode_get
 *
 * Purpose:
 *     Helper function to get the mode of a slice in a
 *     register value that is to be used for FP_SLICE_CONFIGr.
 *
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     fg         - (IN) Installed group structure.
 *     slice_mode - (IN/OUT) Slice mode for the group.
 *
 * Returns:
 *     BCM_E_XXX
 */

int
_bcm_field_th_egress_mode_get(int unit,
                               _field_group_t *fg,
                               uint8 *slice_mode)
{
    int    inst;
    uint32 reg_value;
    uint32 slice_num;
    _field_stage_t  *stage_fc;
    soc_field_t _th_efp_slice_mode[4] =  {SLICE_0_MODEf, SLICE_1_MODEf,
                                           SLICE_2_MODEf, SLICE_3_MODEf};
    soc_reg_t     efp_slice_control_reg;

    /* Input parameters check. */
    if ((NULL == fg) ||  (NULL == slice_mode)) {
        return (BCM_E_PARAM);
    }

    if (_BCM_FIELD_STAGE_EGRESS != fg->stage_id) {
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, fg->stage_id,
                                                 &stage_fc));

    if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
       inst = _FP_GLOBAL_INST;
    } else {
       inst = fg->instance;
    }

    slice_num = fg->slices->slice_number;

    if (slice_num >= COUNTOF(_th_efp_slice_mode)) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, EFP_SLICE_CONTROLr,
                                                       inst,
                                                       &efp_slice_control_reg));
    BCM_IF_ERROR_RETURN(soc_reg32_get(unit,
                                      efp_slice_control_reg,
                                      REG_PORT_ANY, 0, &reg_value));

    *slice_mode = soc_reg_field_get(unit,
                                    efp_slice_control_reg,
                                    reg_value,
                                    _th_efp_slice_mode[slice_num]);
    return BCM_E_NONE;
}
 /*
  * Function:
  *     _bcm_field_th_egress_mode_set
  *
  * Purpose:
  *     Helper function to _bcm_field_th_mode_install that sets the mode of a
  *     slice in a register value that is to be used for FP_SLICE_CONFIGr.
  *
  * Parameters:
  *     unit       - (IN) BCM device number.
  *     slice_numb - (IN) Slice number to set mode for.
  *     fg         - (IN) Installed group structure.
  *     flags      - (IN) New group/slice mode.
  *
  * Returns:
  *     BCM_E_XXX
  */
int
_bcm_field_th_egress_mode_set(int unit, uint8 slice_numb,
                               _field_group_t *fg, uint8 flags)
{
    int              inst;
    uint32           mode_val[2];
    _field_stage_t  *stage_fc;
    soc_reg_t     efp_slice_control_reg;

    /* Input parameters check. */
    if ((NULL == fg) || (slice_numb >= COUNTOF(_th_efp_slice_mode))) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, fg->stage_id,
                                                 &stage_fc));

    if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
       inst = _FP_GLOBAL_INST;
    } else {
       inst = fg->instance;
    }

    mode_val[1]  = _BCM_FIELD_EGRESS_SLICE_V6_KEY_MODE_SIP6;

    if (flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {

        /* DstIP6 + SrcIp6 or IPv4 + L2 Double wide key. */
        if (((_BCM_FIELD_EFP_KEY3 == fg->sel_codes[0].fpf3) &&
            (_BCM_FIELD_EFP_KEY2 == fg->sel_codes[1].fpf3))) {
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE;
            if (_FP_SELCODE_DONT_CARE != fg->sel_codes[1].ip6_addr_sel) {
                mode_val[1] =fg->sel_codes[1].ip6_addr_sel;
            }
        }

#if defined(BCM_TRIDENT3_SUPPORT)
        /* FCOE Double wide key. */
        if ((_BCM_FIELD_EFP_KEY5 == fg->sel_codes[0].fpf3) && \
            (_BCM_FIELD_EFP_KEY4 == fg->sel_codes[1].fpf3)) {
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_FCOE;
        } else
#endif
        if (_BCM_FIELD_EFP_KEY4 == fg->sel_codes[1].fpf3) {
            if ((_BCM_FIELD_EFP_KEY1 == fg->sel_codes[0].fpf3) &&
                (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIp4))) {
                 mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE;
            } else if (_BCM_FIELD_EFP_KEY2 == fg->sel_codes[0].fpf3) {
                 mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6;
                 if (_FP_SELCODE_DONT_CARE != fg->sel_codes[0].ip6_addr_sel) {
                     mode_val[1] =fg->sel_codes[0].ip6_addr_sel;
                 }
            } else if (_BCM_FIELD_EFP_KEY8 == fg->sel_codes[0].fpf3) {
                 mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE;
            } else {
                 mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY;
            }
        }
    } else {
        if (_BCM_FIELD_EFP_KEY4 == fg->sel_codes[0].fpf3) {
            /* L2 - Slice mode. */
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L2;

        } else  if ((_BCM_FIELD_EFP_KEY1 == fg->sel_codes[0].fpf3)  &&
                    BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIp4)) {
            /* L3 - IPv4 single wide key. */
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3;

        } else if ((_BCM_FIELD_EFP_KEY2 == fg->sel_codes[0].fpf3)) {
            /* L3 - IPv6 single wide key. */
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3;
            if (_FP_SELCODE_DONT_CARE != fg->sel_codes[0].ip6_addr_sel) {
                mode_val[1] =fg->sel_codes[0].ip6_addr_sel;
            }
        }
#if defined(BCM_TRIDENT3_SUPPORT)
        else if ((_BCM_FIELD_EFP_KEY5 == fg->sel_codes[0].fpf3)) {
            /* FCOE single wide key. */
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3;
        }
#endif
        else {
            /* L3 common key. */
            mode_val[0] = _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3_ANY;
        }
    }

    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, EFP_SLICE_CONTROLr,
                                                 inst, &efp_slice_control_reg));
    BCM_IF_ERROR_RETURN(soc_reg_fields32_modify(unit,
                               efp_slice_control_reg, REG_PORT_ANY, 2,
                               _th_efp_slice_mode[slice_numb], mode_val));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_th_lookup_mode_set
 *
 * Purpose:
 *    Auxiliary routine used to set group pairing mode.
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     slice_numb - (IN) Slice number to set mode for.
 *     fg         - (IN) Installed group structure.
 *     flags      - (IN) New group/slice mode.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_lookup_mode_set(int            unit,
                          uint8          slice_num,
                          _field_group_t *fg,
                          uint8          flags)
{
    int              inst;
    uint64           vfp_key_control_1_buf;
    _field_stage_t  *stage_fc;
    soc_reg_t        vfp_control_1_reg;

    /* Input parameters check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, fg->stage_id,
                                                 &stage_fc));

    if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
       inst = _FP_GLOBAL_INST;
    } else {
       inst = fg->instance;
    }

    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, VFP_KEY_CONTROL_1r,
                                                    inst, &vfp_control_1_reg));

    BCM_IF_ERROR_RETURN(soc_reg64_get(unit,
                                      vfp_control_1_reg,
                                      REG_PORT_ANY,
                                      0,
                                      &vfp_key_control_1_buf));

    soc_reg64_field32_set(unit,
                          vfp_control_1_reg,
                          &vfp_key_control_1_buf,
                          vfp_slice_pairing_flds[slice_num >> 1],
                          flags & _FP_GROUP_SPAN_DOUBLE_SLICE ? 1 : 0
                          );
    soc_reg64_field32_set(unit,
                          vfp_control_1_reg,
                          &vfp_key_control_1_buf,
                          vfp_slice_wide_mode_flds[slice_num],
                          flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE ? 1 : 0
                          );


    return (soc_reg64_set(unit,
                          vfp_control_1_reg,
                          REG_PORT_ANY,
                          0,
                          vfp_key_control_1_buf));
}


/*
 * Function:
 *     _field_th_mode_set
 *
 * Purpose:
 *    Auxiliary routine used to set group pairing mode.
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     slice_numb - (IN) Slice number to set mode for.
 *     fg         - (IN) Installed group structure.
 *     flags      - (IN) New group/slice mode.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_mode_set(int unit, uint8 slice_numb,
                       _field_group_t *fg, uint8 flags)
{
    int rv;     /* Operation return status. */

    /* Input parameter check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    switch (fg->stage_id) {
      case _BCM_FIELD_STAGE_INGRESS:
      case _BCM_FIELD_STAGE_EXACTMATCH:
          rv = BCM_E_NONE; /* Mode and select codes programmed together. */
          break;
      case _BCM_FIELD_STAGE_LOOKUP:
          rv  = _field_th_lookup_mode_set(unit, slice_numb, fg, flags);
          break;
      case _BCM_FIELD_STAGE_EGRESS:
          rv = _bcm_field_th_egress_mode_set(unit, slice_numb, fg, flags);
          break;
      case _BCM_FIELD_STAGE_FLOWTRACKER:
      case _BCM_FIELD_STAGE_AMFTFP:
      case _BCM_FIELD_STAGE_AEFTFP:
          rv = BCM_E_NONE;
          break;
      default:
          rv = BCM_E_PARAM;
    }
    return (rv);
}
/*
 * Function:
 *     _field_th_egress_selcodes_install
 *
 * Purpose:
 *     Writes the field egress secondary select codes.
 *
 * Parameters:
 *     unit          - (IN) BCM device number
 *     fg            - (IN) Installed group structure.
 *     slice_numb    - (IN) Slice number to set mode for.
 *     selcode_index - (IN) Index to group slecodes.
 *
 *
 * Returns:
 *     BCM_E_INTERNAL - On read/write errors
 *     BCM_E_NONE     - Success
 *
 * Note:
 *     Unit lock should be held by calling function.
 */

STATIC int
_field_th_egress_selcodes_install(int            unit,
                                   _field_group_t *fg,
                                   uint8          slice_num,
                                   int            selcode_idx
                                   )
{
    int             inst;
    uint8           idx; /* Index to EFP keys. */
    _field_sel_t    *sel;
    _field_stage_t  *stage_fc;
    soc_reg_t       efp_classid_sel_reg;
    soc_reg_t       efp_key4_dvp_reg;
    soc_reg_t       efp_key4_mdl_reg;
    soc_reg_t       efp_key8_dvp_reg;
    soc_reg_t       efp_key4_class_reg;
    soc_reg_t       efp_key8_class_reg;


    if (NULL == fg) {
        return BCM_E_PARAM;
    }

    /* Max number of slices on Tomahawk for EFP is 4(slice 0 - slice 3) */
    if (slice_num >= 4)  {
        return BCM_E_INTERNAL;
    }

    sel = &fg->sel_codes[selcode_idx];
    if (sel == NULL) {
       return BCM_E_INTERNAL;
    }

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, fg->stage_id,
                                                 &stage_fc));
    if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
       inst = _FP_GLOBAL_INST;
    } else {
       inst = fg->instance;
    }
    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                       EFP_CLASSID_SELECTORr,
                                                       inst,
                                                       &efp_classid_sel_reg));
    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                       EFP_KEY4_DVP_SELECTORr,
                                                       inst,
                                                       &efp_key4_dvp_reg));
    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                       EFP_KEY4_MDL_SELECTORr,
                                                       inst,
                                                       &efp_key4_mdl_reg));

    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                       EFP_KEY8_DVP_SELECTORr,
                                                       inst,
                                                       &efp_key8_dvp_reg));

    if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                        EFP_KEY4_L3_CLASSID_SELECTORr,
                                                        inst,
                                                        &efp_key4_class_reg));
        BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                        EFP_KEY8_L3_CLASSID_SELECTORr,
                                                        inst,
                                                        &efp_key8_class_reg));
    }

    idx = 0;
    /* Class Id Selector codes for different EFP keys (KEY1 - KEY8) */
    if (sel->egr_class_f1_sel != _FP_SELCODE_DONT_CARE) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                                                   efp_classid_sel_reg,
                                                   REG_PORT_ANY,
                                                   classfldtbl[slice_num][idx],
                                                   sel->egr_class_f1_sel
                                                   ));
    }

    idx++;
    if (sel->egr_class_f2_sel != _FP_SELCODE_DONT_CARE) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                                                   efp_classid_sel_reg,
                                                   REG_PORT_ANY,
                                                   classfldtbl[slice_num][idx],
                                                   sel->egr_class_f2_sel
                                                   ));
    }

    idx++;
    if (sel->egr_class_f3_sel != _FP_SELCODE_DONT_CARE) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                                                   efp_classid_sel_reg,
                                                   REG_PORT_ANY,
                                                   classfldtbl[slice_num][idx],
                                                   sel->egr_class_f3_sel
                                                   ));
    }

    idx++;
    if (sel->egr_class_f4_sel != _FP_SELCODE_DONT_CARE) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                                                   efp_classid_sel_reg,
                                                   REG_PORT_ANY,
                                                   classfldtbl[slice_num][idx],
                                                   sel->egr_class_f4_sel
                                                   ));
    }

    idx++;
    if (sel->egr_class_f6_sel != _FP_SELCODE_DONT_CARE) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                                                   efp_classid_sel_reg,
                                                   REG_PORT_ANY,
                                                   classfldtbl[slice_num][idx],
                                                   sel->egr_class_f6_sel
                                                   ));
    }

    idx++;
    if (sel->egr_class_f7_sel != _FP_SELCODE_DONT_CARE) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                                                   efp_classid_sel_reg,
                                                   REG_PORT_ANY,
                                                   classfldtbl[slice_num][idx],
                                                   sel->egr_class_f7_sel
                                                   ));
    }

    idx++;
    if (sel->egr_class_f8_sel != _FP_SELCODE_DONT_CARE) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                                                   efp_classid_sel_reg,
                                                   REG_PORT_ANY,
                                                   classfldtbl[slice_num][idx],
                                                   sel->egr_class_f8_sel
                                                   ));
    }

    /* SELECTOR CODES for EFP_KEY4_DVP_SELECTOR register */
    if (sel->egr_key4_dvp_sel != _FP_SELCODE_DONT_CARE) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                                                   efp_key4_dvp_reg,
                                                   REG_PORT_ANY,
                                                   dvpfldtbl[slice_num],
                                                   sel->egr_key4_dvp_sel
                                                  ));
    }
    /* SELECTOR CODES for EFP_KEY8_DVP_SELECTOR register */
    if (sel->egr_key8_dvp_sel != _FP_SELCODE_DONT_CARE) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                                                   efp_key8_dvp_reg,
                                                   REG_PORT_ANY,
                                                   dvpfldtbl[slice_num],
                                                   sel->egr_key8_dvp_sel
                                                  ));
    }

    /* SELECTOR CODES for EFP_KEY4_MDL_SELECTOR register */
    if (sel->egr_key4_mdl_sel != _FP_SELCODE_DONT_CARE) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                                                   efp_key4_mdl_reg,
                                                   REG_PORT_ANY,
                                                   mdlfldtbl[slice_num],
                                                   sel->egr_key4_mdl_sel
                                                  ));
    }

#if defined (BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        /* SELECTOR CODES for EFP_KEY4_L3_CLASSID_SELECTOR register */
        if (sel->egr_key4_l3_classId_sel != _FP_SELCODE_DONT_CARE) {
            BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                                                       efp_key4_class_reg,
                                                       REG_PORT_ANY,
                                                       classIdBfldtbl[slice_num],
                                                       sel->egr_key4_l3_classId_sel
                                                      ));
        }
        /* SELECTOR CODES for EFP_KEY8_L3_CLASSID_SELECTOR register */
        if (sel->egr_key8_l3_classId_sel != _FP_SELCODE_DONT_CARE) {
            BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                                                       efp_key8_class_reg,
                                                       REG_PORT_ANY,
                                                       classIdBfldtbl[slice_num],
                                                       sel->egr_key8_l3_classId_sel
                                                      ));
        }
    }
#endif

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_lookup_selcodes_install
 *
 * Purpose:
 *     Writes the field select codes (ie. FPFx).
 *     for VFP (_BCM_FIELD_STAGE_LOOKUP) lookup stage.
 *
 * Parameters:
 *     unit  - BCM device number
 *     fs    - slice that needs its select codes written
 *
 * Returns:
 *     BCM_E_XXX
 */

int
_bcm_field_th_lookup_selcodes_install(int             unit,
                                       _field_group_t *fg,
                                       uint8          slice_num,
                                       int            selcode_idx)
{
    static const soc_field_t s_type_fld_tbl[] = {
        SLICE_0_S_TYPE_SELf,
        SLICE_1_S_TYPE_SELf,
        SLICE_2_S_TYPE_SELf,
        SLICE_3_S_TYPE_SELf
    };

    _field_sel_t * const sel = &fg->sel_codes[selcode_idx];
    int           errcode = BCM_E_NONE;
    uint64        regval;
    uint64        val;
    int           inst;
    _field_stage_t  *stage_fc;
    soc_reg_t     vfp_control_1_reg;
    soc_reg_t     vfp_control_2_reg;

    /* Input parameters check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, fg->stage_id,
                                                 &stage_fc));

    if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
       inst = _FP_GLOBAL_INST;
    } else {
       inst = fg->instance;
    }

    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, VFP_KEY_CONTROL_1r,
                                                    inst, &vfp_control_1_reg));
    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, VFP_KEY_CONTROL_2r,
                                                       inst, &vfp_control_2_reg));

    BCM_IF_ERROR_RETURN(soc_reg64_get(unit,
                                      vfp_control_1_reg,
                                      REG_PORT_ANY,
                                      0,
                                      &regval
                                      ));

    if ((fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)
        && (selcode_idx & 1)
        ) {
        if (sel->fpf2 != _FP_SELCODE_DONT_CARE) {
            COMPILER_64_SET(val, 0, sel->fpf2);
            soc_reg64_field_set(unit,
                                vfp_control_1_reg,
                                &regval,
                                _bcm_field_trx_vfp_double_wide_sel[slice_num],
                                val
                                );
        }
    } else {
        if (sel->fpf2 != _FP_SELCODE_DONT_CARE) {
            COMPILER_64_SET(val, 0, sel->fpf2);
            soc_reg64_field_set(unit,
                                vfp_control_1_reg,
                                &regval,
                                _bcm_field_trx_vfp_field_sel[slice_num][0],
                                val
                                );
        }
        if (sel->fpf3 != _FP_SELCODE_DONT_CARE) {
            COMPILER_64_SET(val, 0, sel->fpf3);
            soc_reg64_field_set(unit,
                                vfp_control_1_reg,
                                &regval,
                                _bcm_field_trx_vfp_field_sel[slice_num][1],
                                val
                                );
        }
    }


    if (sel->src_entity_sel != _FP_SELCODE_DONT_CARE) {
        uint32 value;


        switch (sel->src_entity_sel) {
            case _bcmFieldFwdEntityPortGroupNum:
                value = 4;
                break;
            case _bcmFieldFwdEntityMplsGport:
            case _bcmFieldFwdEntityNivGport:
            case _bcmFieldFwdEntityMimGport:
            case _bcmFieldFwdEntityWlanGport:
            case _bcmFieldFwdEntityVxlanGport:
            case _bcmFieldFwdEntityVlanGport:
                value = 0;
                break;
            case _bcmFieldFwdEntityModPortGport:
                value = 2;
                break;
            case _bcmFieldFwdEntityGlp:
                value = 1;
                break;
            default:
                return (BCM_E_INTERNAL);
        }
        COMPILER_64_SET(val, 0, value);
        soc_reg64_field_set(unit,
                            vfp_control_1_reg,
                            &regval,
                            s_type_fld_tbl[slice_num],
                            val
                            );
    }

    BCM_IF_ERROR_RETURN(soc_reg64_set(unit,
                                      vfp_control_1_reg,
                                      REG_PORT_ANY,
                                      0,
                                      regval
                                      )
                        );

    /* Set inner/outer ip header selection. */
    /* In TD3, vfp_key_control_2 register is not avaliable.
     * we cannot match on Inner Ip header fields */
    if (!soc_feature(unit, soc_feature_vfp_no_inner_ip_fields_support) &&
        sel->ip_header_sel != _FP_SELCODE_DONT_CARE) {
        errcode = soc_reg_field32_modify(
                      unit,
                      vfp_control_2_reg,
                      REG_PORT_ANY,
                      _bcm_field_trx_vfp_ip_header_sel[slice_num],
                      sel->ip_header_sel
                      );
    }

    return (errcode);
}

/*
 * Function:
 *     _field_th_lookup_slice_clear
 *
 * Purpose:
 *     Reset slice configuraton on group deletion event.
 *
 * Parameters:
 *     unit  - BCM device number
 *     fg    - Field group slice belongs to
 *     fs    - Field slice structure.
 *
 * Returns:
 *     BCM_E_NONE     - Success
 *
 * Note:
 *     Unit lock should be held by calling function.
 */
STATIC int
_field_th_lookup_slice_clear(int unit, _field_group_t *fg, _field_slice_t *fs)
{
    uint64           reg_val;
    int              rv;
    int              inst;
    int              slice_num;
    _field_stage_t  *stage_fc;
    soc_reg_t        vfp_control_1_reg;
    soc_reg_t        vfp_control_2_reg;

    /* Input parameters check. */
    if (NULL == fg || NULL == fs) {
        return (BCM_E_PARAM);
    }

    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
       inst = _FP_GLOBAL_INST;
    } else {
       inst = fg->instance;
    }

    slice_num = fs->slice_number;

    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, VFP_KEY_CONTROL_1r,
                                                    inst, &vfp_control_1_reg));
    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, VFP_KEY_CONTROL_2r,
                                                       inst, &vfp_control_2_reg));

    BCM_IF_ERROR_RETURN(soc_reg64_get(unit,
                                      vfp_control_1_reg,
                                      REG_PORT_ANY,
                                      0,
                                      &reg_val
                                      )
                        );
    soc_reg64_field32_set(unit,
                          vfp_control_1_reg,
                          &reg_val,
                          _bcm_field_trx_vfp_double_wide_sel[slice_num],
                          0
                          );
    soc_reg64_field32_set(unit,
                          vfp_control_1_reg,
                          &reg_val,
                          _bcm_field_trx_vfp_field_sel[slice_num][0],
                          0
                          );
    soc_reg64_field32_set(unit,
                          vfp_control_1_reg,
                          &reg_val,
                          _bcm_field_trx_vfp_field_sel[slice_num][1],
                          0
                          );
    soc_reg64_field32_set(unit,
                          vfp_control_1_reg,
                          &reg_val,
                          _bcm_field_trx_slice_pairing_field[slice_num >> 1],
                          0
                          );
    BCM_IF_ERROR_RETURN(soc_reg64_set(unit,
                                      vfp_control_1_reg,
                                      REG_PORT_ANY,
                                      0,
                                      reg_val
                                      )
                        );
    /* In TD3, vfp_key_control_2 register is not avaliable.
     * we cannot match on Inner Ip header fields */
    if (!soc_feature(unit, soc_feature_vfp_no_inner_ip_fields_support)) {
        rv = soc_reg_field32_modify(unit,
                                   vfp_control_2_reg,
                                   REG_PORT_ANY,
                                   _bcm_field_trx_vfp_ip_header_sel[slice_num],
                                   0
                                   );
    }
    return rv;
}
/*
 * Function:
 *     _bcm_field_th_selcodes_install
 *
 * Purpose:
 *     Writes the field select codes (ie. FPFx).
 *
 * Parameters:
 *     unit  - BCM device number
 *     fs    - slice that needs its select codes written
 *
 * Returns:
 *     BCM_E_INTERNAL - On read/write errors
 *     BCM_E_NONE     - Success
 *
 * Note:
 *     Unit lock should be held by calling function.
 */
int
_bcm_field_th_selcodes_install(int unit, _field_group_t *fg,
                                uint8 slice_numb, bcm_pbmp_t pbmp,
                                int selcode_index)
{
    int rv;    /* Operation return status. */

    /* Input parameters check. */
    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    /* Set slice mode. Single/Double/Triple, Intraslice */
    rv = _bcm_field_th_mode_set(unit, slice_numb, fg, fg->flags);
    BCM_IF_ERROR_RETURN(rv);
    switch (fg->stage_id) {
      case _BCM_FIELD_STAGE_LOOKUP:
          rv = _bcm_field_th_lookup_selcodes_install(unit, fg, slice_numb,
                                                      selcode_index);
          break;
      case _BCM_FIELD_STAGE_EGRESS:
#if defined(BCM_TRIDENT3_SUPPORT)
            if (soc_feature(unit, soc_feature_td3_style_fp)) {
                rv = _field_td3_egress_selcodes_install(unit, fg, slice_numb,
                                                         selcode_index);
            } else
#endif
            {
                rv = _field_th_egress_selcodes_install(unit, fg, slice_numb,
                                                         selcode_index);
            }
            break;
      case _BCM_FIELD_STAGE_EXTERNAL:
      case _BCM_FIELD_STAGE_INGRESS:
      case _BCM_FIELD_STAGE_EXACTMATCH:
      case _BCM_FIELD_STAGE_FLOWTRACKER:
      case _BCM_FIELD_STAGE_AMFTFP:
      case _BCM_FIELD_STAGE_AEFTFP:
          rv = (BCM_E_NONE);
          break;
      default:
          rv = (BCM_E_PARAM);
    }
    return (rv);
}

/*
 * Function:
 *     _bcm_field_action_conf_get
 * Purpose:
 *     Get configuration structure of a field action in the given stage.
 * Parameters:
 *     unit     - (IN)  BCM device number.
 *     stage_fc - (IN)  Stage field control strucutre.
 *     action   - (IN)  Field Action.
 *     ptr      - (OUT) FP action info.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_action_config_get(int unit, _field_stage_t *stage_fc,
                             int action, _bcm_field_action_conf_t **ptr)
{

    /* Input parameters check. */
    if (NULL == stage_fc || NULL == ptr ||
        (action < 0) || (action > _bcmFieldActionCount)) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    if ((_BCM_FIELD_STAGE_INGRESS != stage_fc->stage_id) &&
        (_BCM_FIELD_STAGE_EXACTMATCH != stage_fc->stage_id)) {
        return BCM_E_INTERNAL;
    }

    *ptr = stage_fc->f_action_arr[action];
    if (NULL == *ptr) {
        return BCM_E_UNAVAIL;
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_action_offset_get
 * Purpose:
 *     Get offset info of a field action for the given stage and flags.
 * Parameters:
 *     unit     - (IN)  BCM device number.
 *     stage_fc - (IN)  Stage field control strucutre.
 *     action   - (IN)  Field Action.
 *     ptr      - (OUT) FP action offset info.
 *     flags    - (IN)  Field Actions Flags of type _BCM_FIELD_ACTION_XXX.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_action_offset_get(int unit, _field_stage_t *stage_fc,
                            _bcm_field_internal_action_t action,
                                _bcm_field_action_offset_t *ptr,
                                                   uint32 flags)
{
    uint32 found; /* Indicates action offset existance.*/
    _bcm_field_action_conf_t   *aconf;  /* Action config structure. */
    _bcm_field_action_offset_t *offset; /* Field Action Offset Iformation. */

    /* Input parameters check. */
    if (NULL == stage_fc || NULL == ptr ||
        (action < 0) || (action > _bcmFieldActionCount)) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    if ((_BCM_FIELD_STAGE_INGRESS != stage_fc->stage_id) &&
        (_BCM_FIELD_STAGE_EXACTMATCH != stage_fc->stage_id)) {
        return BCM_E_INTERNAL;
    }

    aconf = stage_fc->f_action_arr[action];
    if (NULL == aconf) {
        return BCM_E_UNAVAIL;
    }

    found = 0;
    offset = aconf->offset;
    do {
        if (flags == (offset->flags & flags)) {
            sal_memset(ptr, 0, sizeof(_bcm_field_action_offset_t));
            sal_memcpy(ptr, offset, sizeof(_bcm_field_action_offset_t));
            found = 1;
            break;
        }
        offset = offset->next;
    } while (NULL != offset);

    if (!found) {
        LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                "Action offset info for flags %d is not available.\n"), flags));
        return BCM_E_UNAVAIL;
    }

    return BCM_E_NONE;
}

STATIC int
_field_th_ingress_action_support_check(int unit, unsigned stage,
                                       bcm_field_action_t action)
{
    int rv;  /* Operation return status. */
    _field_stage_t *stage_fc; /* Field Stage Structure. */
    _bcm_field_action_conf_t *aconf; /* Field Action config structure. */

    rv = _field_stage_control_get(unit, stage, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    return _bcm_field_action_config_get(unit, stage_fc, action, &aconf);
}

/*
 * Function:
 *     _field_th_stage_action_support_check
 * Purpose:
 *     Check if action is supported by tomahawk for the given stage.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     stage    - (IN) Field processor stage.
 *     action   - (IN) Action to check(bcmFieldActionXXX)
 *     result   - (OUT)
 *               TRUE   - action is supported by device
 *               FALSE  - action is NOT supported by device
 * Returns:
 *     BCM_E_XXX
 */
int
_field_th_stage_action_support_check(int unit,
                                     unsigned stage,
                                     bcm_field_action_t action,
                                     int *result)
{

    if (NULL == result) {
        return BCM_E_PARAM;
    }

    if ((_BCM_FIELD_STAGE_INGRESS == stage) ||
        (_BCM_FIELD_STAGE_EXACTMATCH == stage)) {

        if (BCM_SUCCESS(_field_th_ingress_action_support_check(unit, stage, action))) {
            *result = TRUE;
        } else {
            *result = FALSE;
        }

        return BCM_E_NONE;
    }

    switch (action) {
        case bcmFieldActionHiGigDstModuleGportNew:
        case bcmFieldActionHiGigDstPortGportNew:
        case bcmFieldActionHiGigDstGportNew:
        case bcmFieldActionGpHiGigDropPrecedenceNew:
        case bcmFieldActionYpHiGigDropPrecedenceNew:
        case bcmFieldActionRpHiGigDropPrecedenceNew:
        case bcmFieldActionHiGigDropPrecedenceNew:
        case bcmFieldActionGpHiGigIntPriNew:
        case bcmFieldActionYpHiGigIntPriNew:
        case bcmFieldActionRpHiGigIntPriNew:
        case bcmFieldActionHiGigIntPriNew:
        case bcmFieldActionLoopbackSrcModuleGportNew:
        case bcmFieldActionLoopbackSrcPortGportNew:
        case bcmFieldActionLoopbackSrcGportNew:
        case bcmFieldActionLoopbackCpuMasqueradePktProfileNew:
        case bcmFieldActionLoopBackTypeNew:
            *result = (stage == _BCM_FIELD_STAGE_EGRESS);
            return (BCM_E_NONE);
        case bcmFieldActionLoopbackPacketProcessingPortNew:
            *result = ((0 == soc_feature(unit, soc_feature_td3_style_fp)) && (stage == _BCM_FIELD_STAGE_EGRESS));
            return (BCM_E_NONE);
        case bcmFieldActionClassZero:
        case bcmFieldActionClassOne:
            *result = (stage == _BCM_FIELD_STAGE_CLASS);
            return (BCM_E_NONE);
        case bcmFieldActionHashSelect0:
        case bcmFieldActionHashSelect1:
            *result = (stage == _BCM_FIELD_STAGE_LOOKUP);
            return (BCM_E_NONE);
        case bcmFieldActionMplsLabel1ExpNew:
#if defined (BCM_TOMAHAWK2_SUPPORT)
            if (SOC_IS_TOMAHAWK2(unit)) {
                *result = (stage == _BCM_FIELD_STAGE_EGRESS);
            } else
#endif
            {
                *result = FALSE;
            }
            return BCM_E_NONE;
#if defined(BCM_FLOWTRACKER_SUPPORT)
        case bcmFieldActionFlowtrackerGroupId:
        case bcmFieldActionFlowtrackerEnable:
        case bcmFieldActionFlowtrackerNewLearnEnable:
            *result = (stage == _BCM_FIELD_STAGE_FLOWTRACKER);
            return BCM_E_NONE;
#endif
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
        case bcmFieldActionFlowtrackerAggregateIngressGroupId:
        case bcmFieldActionFlowtrackerAggregateClass:
        case bcmFieldActionFlowtrackerAggregateIngressFlowIndex:
            if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
                *result = (stage == _BCM_FIELD_STAGE_FLOWTRACKER);
            } else {
                *result = FALSE;
            }
            return BCM_E_NONE;
        case bcmFieldActionFlowtrackerAggregateMmuGroupId:
        case bcmFieldActionFlowtrackerAggregateMmuFlowIndex:
            if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
                *result = (stage == _BCM_FIELD_STAGE_AMFTFP);
            } else {
                *result = FALSE;
            }
            return BCM_E_NONE;
        case bcmFieldActionFlowtrackerAggregateEgressGroupId:
        case bcmFieldActionFlowtrackerAggregateEgressFlowIndex:
            if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
                *result = (stage == _BCM_FIELD_STAGE_AEFTFP);
            } else {
                *result = FALSE;
            }
            return BCM_E_NONE;
#endif
        default:
        ;
    }

    return (_bcm_field_td2_stage_action_support_check(unit, stage,
                                                      action, result));
}

/*
 * Function:
 *     _bcm_field_th_stage_action_support_check
 * Purpose:
 *     Check if action is supported by tomahawk for the given stage.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     stage    - (IN) Field processor stage.
 *     action   - (IN) Action to check(bcmFieldActionXXX)
 *     result   - (OUT)
 *               TRUE   - action is supported by device
 *               FALSE  - action is NOT supported by device
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_stage_action_support_check(int unit,
                                         unsigned stage,
                                         bcm_field_action_t action,
                                         int *result)
{
#if defined (BCM_TOMAHAWK3_SUPPORT)
    if (SOC_IS_TOMAHAWK3(unit)) {
        return (_field_th3_stage_action_support_check(unit,
                                                     stage,
                                                     action,
                                                     result));
    }
#endif
    return _field_th_stage_action_support_check(unit, stage, action, result);
}

/*
 * Function:
 *     _bcm_field_th_action_support_check
 * Purpose:
 *     Check if action is supported by tomahawk for the given stage.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     f_ent    - (IN) Field entry structure to get policy info from.
 *     action   - (IN) Action to check(bcmFieldActionXXX)
 *     result   - (OUT)
 *               TRUE   - action is supported by device
 *               FALSE  - action is NOT supported by device
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_action_support_check(int unit,
                                   _field_entry_t *f_ent,
                                   bcm_field_action_t action,
                                   int *result)
{
    return _bcm_field_th_stage_action_support_check(unit,
                                                    f_ent->group->stage_id,
                                                    action, result);
}

/*
 * Function:
 *     _bcm_field_th_mirror_resolve
 * Purpose:
 *     Resolve mirroring destination & enable mirroring for rule matching
 *     packets.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     f_ent    - (IN) Entry structure to get policy info from
 *     fa       - (IN) field action
 *     params   - (OUT) Field Action params structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_mirror_resolve(int unit,
                             _field_entry_t *f_ent,
                             _field_action_t *fa,
                             _field_action_params_t *params)
{
    int rv;             /* Operation return status.       */
    int mtp_index;      /* Index to IM_MIRROR_CONTROL.    */
    int mtp_type_index; /* Bit position in MIRROR field.  */
    int flexibleMirror; /* Flag to indicate flexible mirroring status. */
    int directedMirror; /* Flag to indicate directed mirroring status. */

    /* Input parameters check. */
    if (NULL == f_ent || NULL == fa || NULL == params) {
        return (BCM_E_PARAM);
    }

    mtp_index = fa->hw_index;
    mtp_type_index = mtp_index;

    /* shifting the index back since flexible slot shift was done
     * prior to this
     */
    rv = bcm_esw_switch_control_get(unit,bcmSwitchFlexibleMirrorDestinations,
                                                            &flexibleMirror);
    BCM_IF_ERROR_RETURN(rv);

    rv = bcm_esw_switch_control_get(unit,bcmSwitchDirectedMirroring,
                                                   &directedMirror);
    BCM_IF_ERROR_RETURN(rv);

    if (soc_feature(unit, soc_feature_mirror_flexible)
        && flexibleMirror && directedMirror) {
        mtp_index = (fa->hw_index & BCM_MIRROR_MTP_FLEX_SLOT_MASK);
        mtp_type_index = ((fa->hw_index >> BCM_MIRROR_MTP_FLEX_SLOT_SHIFT)
                           & BCM_MIRROR_MTP_FLEX_SLOT_MASK);
    }

    /* For Tomahawk Ingress and Egress Mirror together supports 4 MTP's. */
    if (mtp_type_index >= 4) {
        fa->hw_index = _FP_INVALID_INDEX;
        return (BCM_E_INTERNAL);
    }


    params->mtp_index = mtp_index;
    params->mtp_type_index = mtp_type_index;

    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit, "Resolved Parameters: ")));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                                  "MTP Index = %d, "), params->mtp_index));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                        "MTP Type Index = %d, "), params->mtp_type_index));

    return (BCM_E_NONE);
}
/*
 * Function:
 *     _bcm_field_th_cosq_resolve
 * Purpose:
 *     Resolve field action parameters for cosq actions.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     f_ent    - (IN) Field entry structure.
 *     fa       - (IN) Field action structure.
 *     params   - (OUT) Field Action params structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_cosq_resolve(int unit, _field_entry_t *f_ent,
                                       _field_action_t *fa,
                            _field_action_params_t *params)
{
    int    rv;         /* Operation return status.   */
    int    cosq_new;   /* New Cosq Value.            */
    uint32 cosq;       /* Cosq Value passed by User. */

    if (NULL == f_ent || NULL == fa || NULL == params) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    cosq = fa->param[0];
    cosq_new = -1;
    switch (fa->action) {
        case bcmFieldActionCosQNew:
        case bcmFieldActionGpCosQNew:
        case bcmFieldActionYpCosQNew:
        case bcmFieldActionRpCosQNew:
        case bcmFieldActionUcastCosQNew:
        case bcmFieldActionGpUcastCosQNew:
        case bcmFieldActionYpUcastCosQNew:
        case bcmFieldActionRpUcastCosQNew:
            if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(cosq)) {
#if defined(BCM_TOMAHAWK3_SUPPORT)
                if (SOC_IS_TOMAHAWK3(unit)) {
                    rv = _bcm_th3_cosq_index_resolve(unit, cosq, 0,
                              _BCM_TH3_COSQ_INDEX_STYLE_COS, NULL,
                              &cosq_new, NULL);
                } else
#endif
                {
                    rv = _bcm_th_cosq_index_resolve(unit, cosq, 0,
                            _BCM_TH_COSQ_INDEX_STYLE_COS, NULL,
                            &cosq_new, NULL);
                }
                BCM_IF_ERROR_RETURN(rv);
            } else {
                cosq_new = cosq;
            }
            break;
        case bcmFieldActionMcastCosQNew:
        case bcmFieldActionGpMcastCosQNew:
        case bcmFieldActionYpMcastCosQNew:
        case bcmFieldActionRpMcastCosQNew:
            if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(cosq)) {
#if defined(BCM_TOMAHAWK3_SUPPORT)
                if (SOC_IS_TOMAHAWK3(unit)) {
                    rv = _bcm_th3_cosq_index_resolve(unit, cosq, 0,
                            _BCM_TH3_COSQ_INDEX_STYLE_COS, NULL,
                            &cosq_new, NULL);
                } else
#endif
                {
                    rv = _bcm_th_cosq_index_resolve(unit, cosq, 0,
                             _BCM_TH_COSQ_INDEX_STYLE_COS, NULL,
                             &cosq_new, NULL);
                }
                BCM_IF_ERROR_RETURN(rv);
            } else {
                cosq_new = cosq;
            }
            break;
        case bcmFieldActionCosMapNew:
        case bcmFieldActionGpCosMapNew:
        case bcmFieldActionYpCosMapNew:
        case bcmFieldActionRpCosMapNew:
            if (_BCM_COSQ_CLASSIFIER_IS_FIELD(cosq)) {
                cosq_new = _BCM_COSQ_CLASSIFIER_FIELD_GET(cosq);
            }
            break;
        default:
            LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                        "%s can't be resolved.\n"), action_name[fa->action]));
            return BCM_E_UNAVAIL;
    }

    if (-1 == cosq_new) {
        return BCM_E_PARAM;
    }

    params->cosq_new = cosq_new;

    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                "Resolved Parameters:\n cosq_new = %d \n"), params->cosq_new));
    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_fabric_tag_resolve
 * Purpose:
 *     Resolve field action parameters for action bcmFieldActionFabricQueue.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     f_ent    - (IN) Field entry structure.
 *     fa       - (IN) Field action structure.
 *     params   - (OUT) Field Action params structure.
 * Returns:
 *     BCM_E_XXX
 */
int _bcm_field_th_fabric_tag_resolve(int unit, _field_entry_t *f_ent,
                                                 _field_action_t *fa,
                                      _field_action_params_t *params)
{
    uint8 fabric_tag_type; /* Fabric Tag Type. */
    uint32 in_flags;       /* Incoming Fabric Queue Flags. */
    uint32 fabric_tag;     /* Fabric Tag Value. */

    if (NULL == f_ent || NULL == fa || NULL == params) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    in_flags = fa->param[0];

    if ((in_flags & BCM_FABRIC_QUEUE_QOS_BASE)  &&
        (in_flags & BCM_FABRIC_QUEUE_DEST_OFFSET)) {
        return (BCM_E_PARAM);
    }

    if (in_flags &
         ~(BCM_FABRIC_QUEUE_CUSTOMER |
           BCM_FABRIC_QUEUE_QOS_BASE |
           BCM_FABRIC_QUEUE_DEST_OFFSET |
           0xffff)) {
        return (BCM_E_PARAM);
    }

    /* Tag type resolution. */
    if (in_flags & BCM_FABRIC_QUEUE_QOS_BASE) {
        fabric_tag_type = 0x3;  /* Offset to base queue number from the
                                   QUEUE_MAP Table. Index into QUEUE_MAP
                                   Table is {DST_MODID, DST_PID} */
    } else if (in_flags & BCM_FABRIC_QUEUE_DEST_OFFSET) {
        fabric_tag_type = 0x2;  /* Index into QUEUE_MAP Table used
                                   for lookup.*/
    } else {
        fabric_tag_type = 0x1;  /* Explicit queue number. */
    }

    fabric_tag = in_flags & 0xffff;

    params->fabric_tag_type = fabric_tag_type;
    params->fabric_tag = fabric_tag;

    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit, "Resolved Parameters:\n")));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                               "fabric_tag_type = %d \n fabric_tag = %d\n"),
                               params->fabric_tag_type, params->fabric_tag));
    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_i2e_class_resolve
 * Purpose:
 *     Resolve field action parameters for action
 *     bcmFieldActionEgressClassSelect.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     f_ent    - (IN) Field entry structure.
 *     fa       - (IN) Field action structure.
 *     params   - (OUT) Field Action params structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_i2e_class_resolve(int unit, _field_entry_t *f_ent,
                                            _field_action_t *fa,
                                 _field_action_params_t *params)
{
    uint32 i2e_cl_sel; /* Ingress to Egress Class Selector. */

    if (NULL == f_ent || NULL == fa || NULL == params) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    switch (fa->param[0]) {
        case BCM_FIELD_EGRESS_CLASS_SELECT_PORT:
            i2e_cl_sel = 0x1;
            break;
        case BCM_FIELD_EGRESS_CLASS_SELECT_SVP:
            i2e_cl_sel = 0x2;
            break;
        case BCM_FIELD_EGRESS_CLASS_SELECT_L3_IIF:
            i2e_cl_sel = 0x3;
            break;
        case BCM_FIELD_EGRESS_CLASS_SELECT_FIELD_SRC:
            i2e_cl_sel = 0x4; /* VFP hi */
            break;
        case BCM_FIELD_EGRESS_CLASS_SELECT_FIELD_DST:
            i2e_cl_sel = 0x5; /* VFP lo */
            break;
        case BCM_FIELD_EGRESS_CLASS_SELECT_L2_SRC:
            i2e_cl_sel = 0x6;
            break;
        case BCM_FIELD_EGRESS_CLASS_SELECT_L2_DST:
            i2e_cl_sel = 0x7;
            break;
        case BCM_FIELD_EGRESS_CLASS_SELECT_L3_SRC:
            i2e_cl_sel = 0x8;
            break;
        case BCM_FIELD_EGRESS_CLASS_SELECT_L3_DST:
            i2e_cl_sel = 0x9;
            break;
        case BCM_FIELD_EGRESS_CLASS_SELECT_VLAN:
            i2e_cl_sel = 0xa;
            break;
        case BCM_FIELD_EGRESS_CLASS_SELECT_VRF:
            i2e_cl_sel = 0xb;
            break;
        case BCM_FIELD_EGRESS_CLASS_SELECT_NEW:
            i2e_cl_sel = 0xf;
            break;
        default:
            LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                        "Invalid i2e class selector: %d.\n"), fa->param[0]));
            return (BCM_E_PARAM);
    }

    params->i2e_cl_sel = i2e_cl_sel;
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
             "Resolved Parameters:\n i2e_cl_sel = %d \n"), params->i2e_cl_sel));
    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_i2e_hg_class_resolve
 * Purpose:
 *     Resolve field action parameters for action bcmFieldActionHiGigClassSelect
 * Parameters:
 *     unit     - (IN) BCM device number
 *     f_ent    - (IN) Field entry structure.
 *     fa       - (IN) Field action structure.
 *     params   - (OUT) Field Action params structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_i2e_hg_class_resolve(int unit, _field_entry_t *f_ent,
                                               _field_action_t *fa,
                                    _field_action_params_t *params)
{
    uint32 i2e_hg_cl_sel; /* Ingress to Egress HiGiG Class selector. */

    if (NULL == f_ent || NULL == fa || NULL == params) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    switch (fa->param[0]) {
        case BCM_FIELD_HIGIG_CLASS_SELECT_EGRESS:
            i2e_hg_cl_sel = 1;
            break;
        case BCM_FIELD_HIGIG_CLASS_SELECT_PORT:
            i2e_hg_cl_sel = 4;
            break;
        default:
            /* Invalid parameter should have been caught earlier */
            LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                     "Invalid i2e higig class selector: %d.\n"), fa->param[0]));
            return (BCM_E_PARAM);
    }

    params->i2e_hg_cl_sel = i2e_hg_cl_sel;
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit, "Resolved Parameters:\n")));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                              "i2e_hg_cl_sel = %d \n"), params->i2e_hg_cl_sel));
    return BCM_E_NONE;
}
#ifdef INCLUDE_L3
/*
 * Function:
 *     _bcm_field_th_nat_resolve
 * Purpose:
 *     Resolve field action parameters for actions in IFP_NAT_SET.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     f_ent    - (IN) Field entry structure.
 *     fa       - (IN) Field action structure.
 *     params   - (OUT) Field Action params structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_nat_resolve(int unit, _field_entry_t *f_ent,
                                      _field_action_t *fa,
                           _field_action_params_t *params)
{
    int32 hw_idx;
    int32 hw_half;

    if (NULL == f_ent || NULL == fa || NULL == params) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    hw_idx = hw_half = 0;
    BCM_L3_NAT_EGRESS_HW_IDX_GET(fa->param[0], hw_idx, hw_half);
    if ((hw_idx < 0) || (hw_idx > soc_mem_index_max(unit,
                                  EGR_NAT_PACKET_EDIT_INFOm))) {
       LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit, "Invalid Parameters.\n")));
       return BCM_E_PARAM;
    }

    params->hw_idx = hw_idx;
    params->hw_half = hw_half;

    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit, "Resolved Parameters:\n")));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                                          "hw_idx = %d \n hw_half = %d \n"),
                                           params->hw_idx, params->hw_half));
    return BCM_E_NONE;

}
#endif
/*
 * Function:
 *     _bcm_field_th_redirect_resolve
 * Purpose:
 *     Resolve field action parameters for actions in IFP_REDIRECT_SET.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     f_ent    - (IN) Field entry structure.
 *     fa       - (IN) Field action structure.
 *     params   - (OUT) Field Action params structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_redirect_resolve(int unit, _field_entry_t *f_ent,
                                           _field_action_t *fa,
                                _field_action_params_t *params)
{
    int    nh_ecmp_id;   /* Next Hop or ECMP Id. */
    uint8  is_dvp;       /* Redirect to DVP. */
    uint8  is_trunk;     /* Redirect to Trunk. */
    uint8  eh_tag_mask_index;      /* Pointer to the EH_MASK_PROFILE_TABLE. */
    uint8  ucast_redirect_control; /* Unicast Redirection Control. */
    uint8  mcast_redirect_control; /* Multicast Redirection Control. */
    uint32 flags;                  /* Field Action Flags. */
    uint32 redir_field;            /* Dest object to redirect the packet. */
    uint32 eh_tag;                 /* HiGiG extended header. */
#ifdef INCLUDE_L3
    int    ifp_type = 0;           /* Egress object entry type. */
#endif

    if (NULL == fa || NULL == f_ent || NULL == params) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return (BCM_E_PARAM);
    }

    nh_ecmp_id = -1;
    is_dvp = 0;
    is_trunk = 0;
    ucast_redirect_control = 0;
    mcast_redirect_control = 0;
    flags = 0;
    redir_field = 0;
    eh_tag = 0;
    eh_tag_mask_index = 0;

    switch (fa->action) {
        case bcmFieldActionRedirect: /* param0 = modid, param1 = port*/
            ucast_redirect_control = 0x6;
            if (BCM_GPORT_IS_MPLS_PORT(fa->param[1])) {
                redir_field = BCM_GPORT_MPLS_PORT_ID_GET((int)fa->param[1]);
                is_dvp = 1;
            } else if (BCM_GPORT_IS_MIM_PORT(fa->param[1])) {
                redir_field = BCM_GPORT_MIM_PORT_ID_GET((int)fa->param[1]);
                is_dvp = 1;
            } else if (BCM_GPORT_IS_VXLAN_PORT(fa->param[1])) {
                redir_field = BCM_GPORT_VXLAN_PORT_ID_GET((int)fa->param[1]);
                is_dvp = 1;
            } else if (BCM_GPORT_IS_FLOW_PORT(fa->param[1])) {
                redir_field = BCM_GPORT_FLOW_PORT_ID_GET((int)fa->param[1]);
                is_dvp = 1;
            } else if (BCM_GPORT_IS_TRILL_PORT(fa->param[1])) {
                redir_field = BCM_GPORT_TRILL_PORT_ID_GET((int)fa->param[1]);
                is_dvp = 1;
            } else if (BCM_GPORT_IS_L2GRE_PORT(fa->param[1])) {
                redir_field = BCM_GPORT_L2GRE_PORT_ID_GET((int)fa->param[1]);
                is_dvp = 1;
            } else if (BCM_GPORT_IS_NIV_PORT(fa->param[1])) {
                redir_field = BCM_GPORT_NIV_PORT_ID_GET((int)fa->param[1]);
                is_dvp = 1;
            } else {
                redir_field = ((fa->param[0] & 0xff) << 8);
                redir_field |= (fa->param[1] & 0xff);
                ucast_redirect_control = 0x0;
                is_trunk = 0;
            }
            break;
        case bcmFieldActionRedirectTrunk: /* param0 = trunk ID */
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
            if (soc_feature(unit, soc_feature_vp_lag)) {
                int tid_is_vp_lag = 0;
                int vp = -1;
                int rv = BCM_E_NONE;
                rv = _bcm_esw_trunk_id_is_vp_lag(unit, fa->param[0],
                                                 &tid_is_vp_lag);
                BCM_IF_ERROR_RETURN(rv);

                if (tid_is_vp_lag) {

                    rv = _bcm_esw_trunk_tid_to_vp_lag_vp(unit,
                                                         fa->param[0], &vp);
                    BCM_IF_ERROR_RETURN(rv);

                    if (_bcm_vp_used_get(unit, vp, _bcmVpTypeVpLag)) {
                        redir_field = vp;
                        is_dvp = 1;
                    } else {
                        return BCM_E_PARAM;
                    }
                } else {
                    redir_field = fa->param[0];
                }
            } else
#endif
            {
                redir_field = fa->param[0];
            }
            ucast_redirect_control = 0;
            is_trunk = 1;
            break;
        case bcmFieldActionRedirectCancel:
            break;
        case bcmFieldActionRedirectPbmp:
            redir_field = fa->hw_index;
            mcast_redirect_control = 0x0;
            break;
        case bcmFieldActionEgressMask:
            redir_field = fa->hw_index;
            break;
        case bcmFieldActionEgressPortsAdd:
            redir_field = fa->hw_index;
            break;
        case bcmFieldActionFabricEHAddOrUpdate:
            eh_tag = fa->param[0];
            eh_tag_mask_index = fa->hw_index;
            break;
#ifdef INCLUDE_L3
        case bcmFieldActionRedirectIpmc:
            if (soc_feature(unit, soc_feature_field_action_redirect_ipmc)) {
                if (_BCM_MULTICAST_IS_SET(fa->param[0])) {
                    redir_field = _BCM_MULTICAST_ID_GET(fa->param[0]);
                } else {
                    redir_field = fa->param[0];
                }
            } else {
                redir_field = fa->hw_index;
            }
            mcast_redirect_control = 0x3;
            break;
        case bcmFieldActionRedirectEgrNextHop:
            if ((!soc_feature(unit, soc_feature_nh_for_ifp_actions)) &&
                (fa->param[1] == bcmFieldRedirectTypeAll)) {
               return BCM_E_UNAVAIL;
            }

            /* Get next hop info from Egress Object ID param */
            BCM_IF_ERROR_RETURN
              (_bcm_field_l3_egr_object_ifp_type_index_get(unit, fa->param[0],
                                         &ifp_type, &flags, &nh_ecmp_id));
            /* Valid redirect type param */
            if (!(((fa->param[1] == bcmFieldRedirectTypeAll) &&
                 (ifp_type == TRUE)) ||
                ((fa->param[1] == bcmFieldRedirectTypeL3) &&
                 (ifp_type == FALSE)))) {
               return BCM_E_PARAM;
            }

            if (flags & BCM_L3_MULTIPATH) {
                /* Param0 - ECMP next hop */
                if (0 == soc_feature(unit,
                                   soc_feature_field_action_redirect_ecmp)) {
                    return (BCM_E_PARAM);
                }
                ucast_redirect_control = 0x3;
            } else {
                ucast_redirect_control = 0x2;
            }
            break;
#endif /* INCLUDE_L3 */
        case bcmFieldActionRedirectMcast:
            if (soc_feature(unit, soc_feature_field_action_redirect_ipmc)) {
                if (_BCM_MULTICAST_IS_SET(fa->param[0])) {
                    if (0 == _BCM_MULTICAST_IS_L2(fa->param[0])) {
                        return (BCM_E_PARAM);
                    }
                    redir_field = _BCM_MULTICAST_ID_GET(fa->param[0]);
                } else {
                    redir_field = fa->param[0];
                }
            } else {
                redir_field = fa->hw_index;
            }
            mcast_redirect_control = 0x2;
            break;
        case bcmFieldActionRedirectVlan:
            mcast_redirect_control = 0x1;
            break;
        case bcmFieldActionRedirectBcastPbmp:
            redir_field = fa->hw_index;
            mcast_redirect_control = 0x1;
            break;
        case bcmFieldActionUnmodifiedPacketRedirectPort:
            if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
                redir_field = ((BCM_GPORT_MODPORT_MODID_GET(
                                                    fa->param[0]) & 0xff) << 8);
                redir_field |= (BCM_GPORT_MODPORT_PORT_GET(
                                                          fa->param[0]) & 0xff);
                is_trunk = 0;
            } else if (BCM_GPORT_IS_TRUNK(fa->param[0])) {
                redir_field = BCM_GPORT_TRUNK_GET(fa->param[0]);
                is_trunk = 1;
            } else {
                redir_field = ((fa->param[0] & 0xff) << 8);
                redir_field |= (fa->param[1] & 0xff);
                is_trunk = 0;
            }
            ucast_redirect_control = 0x1;
            break;
        default:
            LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                        "%s can't be resolved.\n"), action_name[fa->action]));
            return (BCM_E_UNAVAIL);
    }

    params->flags |= flags;
    params->is_dvp = is_dvp;
    params->is_trunk = is_trunk;
    params->nh_ecmp_id = nh_ecmp_id;
    params->redirect_value = redir_field;
    params->ucast_redirect_control = ucast_redirect_control;
    params->mcast_redirect_control = mcast_redirect_control;
    params->eh_tag = eh_tag;
    params->eh_tag_mask_index = eh_tag_mask_index;

    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit, "Resolved Parameters:\n")));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                                         "is_dvp = %d \n"), params->is_dvp));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                                      "is_trunk = %d \n"), params->is_trunk));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                                  "nh_ecmp_id = %d \n"), params->nh_ecmp_id));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                          "redirect_value = %d \n"), params->redirect_value));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                                            "ucast_redirect_control = %d \n"),
                                             params->ucast_redirect_control));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                                            "mcast_redirect_control = %d \n"),
                                             params->mcast_redirect_control));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                                            "HiGiG Extended Header  = %d \n"),
                                             params->eh_tag));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                                   "HiGiG Extended Header Mask Index = %d \n"),
                                          params->eh_tag_mask_index));

    return (BCM_E_NONE);
}
/*
 * Function:
 *     _bcm_field_th_l3swl2change_resolve
 * Purpose:
 *     Resolve field action parameters for actions in IFP_L3SW_L2_CHANGE_SET.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     f_ent    - (IN) Field entry structure.
 *     fa       - (IN) Field action structure.
 *     params   - (OUT) Field Action params structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_l3swl2change_resolve(int unit,
                                   _field_entry_t *f_ent,
                                   _field_action_t *fa,
                                   _field_action_params_t *params)
{
    int rv;         /* Operation return status. */
    int nh_ecmp_id; /* Next Hop or ECMP Id. */
    uint32 flags;   /* Multippath Flags. */
#if defined INCLUDE_L3
    int ifp_type = 0; /* Egress object entry type. */
#endif

    if (NULL == fa || NULL == f_ent || NULL == params) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return (BCM_E_PARAM);
    }

#if defined INCLUDE_L3
    rv = _bcm_field_l3_egr_object_ifp_type_index_get(unit, fa->param[0],
                                                &ifp_type, &flags, &nh_ecmp_id);
    BCM_IF_ERROR_RETURN(rv);
#endif /* INCLUDE_L3 */

    switch (fa->action)  {
        case bcmFieldActionL3Switch:
#if defined INCLUDE_L3
            if (ifp_type == TRUE) {
               return BCM_E_PARAM;
            }
#else
           return BCM_E_UNAVAIL;
#endif
           break;
        case bcmFieldActionChangeL2Fields:
#if defined INCLUDE_L3
           if (ifp_type == FALSE) {
              return BCM_E_PARAM;
           }
           fa->hw_index = nh_ecmp_id;
#else
           return BCM_E_UNAVAIL;
#endif
           break;
        default:
           LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                        "%s can't be resolved.\n"), action_name[fa->action]));
           return BCM_E_UNAVAIL;
    }

    params->flags |= flags;
    params->nh_ecmp_id = nh_ecmp_id;

    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit, "Resolved Parameters:\n")));
    LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                                          "flags = %d \n  nh_ecmp_id = %d \n"),
                                           params->flags, params->nh_ecmp_id));
    return rv;
}
/*
 * Function:
 *     _bcm_field_th_action_resolve
 * Purpose:
 *     Resolve field action parameters.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     f_ent    - (IN) Field entry structure.
 *     fa       - (IN) Field action structure.
 *     params   - (OUT) Field Action params structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_action_resolve(int unit, _field_entry_t *f_ent,
                          _field_action_t *fa, _field_action_params_t *params)
{
    if (NULL == f_ent || NULL == fa || NULL == params) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    switch (fa->action) {
        /* Actions from PROFILE_SET_1 */
        case bcmFieldActionCosQNew:
        case bcmFieldActionGpCosQNew:
        case bcmFieldActionYpCosQNew:
        case bcmFieldActionRpCosQNew:
        case bcmFieldActionUcastCosQNew:
        case bcmFieldActionGpUcastCosQNew:
        case bcmFieldActionYpUcastCosQNew:
        case bcmFieldActionRpUcastCosQNew:
        case bcmFieldActionMcastCosQNew:
        case bcmFieldActionGpMcastCosQNew:
        case bcmFieldActionYpMcastCosQNew:
        case bcmFieldActionRpMcastCosQNew:
        case bcmFieldActionCosMapNew:
        case bcmFieldActionGpCosMapNew:
        case bcmFieldActionYpCosMapNew:
        case bcmFieldActionRpCosMapNew:
            return _bcm_field_th_cosq_resolve(unit, f_ent, fa, params);
        case bcmFieldActionEgressClassSelect:
            return _bcm_field_th_i2e_class_resolve(unit, f_ent, fa, params);
        case bcmFieldActionHiGigClassSelect:
            return _bcm_field_th_i2e_hg_class_resolve(unit, f_ent, fa, params);
        case bcmFieldActionFabricQueue:
            return _bcm_field_th_fabric_tag_resolve(unit, f_ent, fa, params);
#ifdef INCLUDE_L3
        case bcmFieldActionL3Switch:
        case bcmFieldActionChangeL2Fields:
            return _bcm_field_th_l3swl2change_resolve(unit, f_ent, fa, params);
        case bcmFieldActionNatEgressOverride:
            return _bcm_field_th_nat_resolve(unit, f_ent, fa, params);
#endif
        case bcmFieldActionRedirect:
        case bcmFieldActionRedirectTrunk:
        case bcmFieldActionUnmodifiedPacketRedirectPort:
        case bcmFieldActionRedirectMcast:
#ifdef INCLUDE_L3
        case bcmFieldActionRedirectEgrNextHop:
        case bcmFieldActionRedirectIpmc:
#endif
        case bcmFieldActionRedirectCancel:
        case bcmFieldActionRedirectPbmp:
        case bcmFieldActionRedirectVlan:
        case bcmFieldActionRedirectBcastPbmp:
        case bcmFieldActionEgressMask:
        case bcmFieldActionEgressPortsAdd:
        case bcmFieldActionFabricEHAddOrUpdate:
            return _bcm_field_th_redirect_resolve(unit, f_ent, fa, params);
        case bcmFieldActionMirrorIngress:
        case bcmFieldActionMirrorEgress:
            return _bcm_field_th_mirror_resolve(unit, f_ent, fa, params);
        default:
            LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                        "%s can't be resolved.\n"), action_name[fa->action]));
            return BCM_E_UNAVAIL;
   }

   return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_ingress_action_params_check
 * Purpose:
 *     Check field action parameters.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     f_ent    - (IN) Field entry structure.
 *     fa       - (IN) Field action structure.
 *     action   - (IN) Field Action of type bcmFieldActionXXX.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_ingress_action_params_check(int unit,
                                         _field_entry_t *f_ent,
                                         _field_action_t *fa)
{
    int rv; /* Operation return status. */
    _field_stage_t *stage_fc; /* Field Stage Structure. */
    _field_action_params_t params; /* Field Params Structutre. */
    _bcm_field_action_offset_t a_offset; /* Field Offset Structure. */
    bcm_field_action_t action;  /* Field Action of Type bcmFieldActionXXX. */
#ifdef INCLUDE_L3
    int                redir_field = -1;
#endif
#if defined (BCM_TOMAHAWK3_SUPPORT)
    int ref_count = -1;  /* For Mirror Zeroing */
#endif

    if (NULL == f_ent ||
        NULL == fa) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    sal_memset(&params , 0, sizeof(params));

    action = fa->action;
    switch (action) {
        /* Actions from PROFILE_SET_1 */
        case bcmFieldActionCosQNew:
        case bcmFieldActionGpCosQNew:
        case bcmFieldActionYpCosQNew:
        case bcmFieldActionRpCosQNew:
            /* For the xxcosQNew action, the param received is a 4 bit ucosq.
             * This value is set for both ucosq (lower 4 bits) and
             * mcosq(higher 4 bits) of G/Y/R_COS_INT_PRI.
             * Since, param received is only ucosq (4 bit value), it is
             * validated against bcmFieldActionGpUcastCosQNew.
             */

            action = bcmFieldActionGpUcastCosQNew;
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            ACTION_CHECK(a_offset.width[0], params.cosq_new);
            break;
        case bcmFieldActionUcastCosQNew:
        case bcmFieldActionGpUcastCosQNew:
        case bcmFieldActionYpUcastCosQNew:
        case bcmFieldActionRpUcastCosQNew:
            action = bcmFieldActionGpUcastCosQNew;
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            ACTION_CHECK(a_offset.width[0], params.cosq_new);
            break;
        case bcmFieldActionMcastCosQNew:
        case bcmFieldActionGpMcastCosQNew:
        case bcmFieldActionYpMcastCosQNew:
        case bcmFieldActionRpMcastCosQNew:
            action = bcmFieldActionGpMcastCosQNew;
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            ACTION_CHECK(a_offset.width[0], params.cosq_new);
            break;
        case bcmFieldActionPrioIntNew:
        case bcmFieldActionGpPrioIntNew:
        case bcmFieldActionYpPrioIntNew:
        case bcmFieldActionRpPrioIntNew:
        case bcmFieldActionPrioPktAndIntNew:
        case bcmFieldActionRpPrioPktAndIntNew:
        case bcmFieldActionGpPrioPktAndIntNew:
        case bcmFieldActionYpPrioPktAndIntNew:
            action = bcmFieldActionGpPrioIntNew;
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionGpIntCongestionNotificationNew:
        case bcmFieldActionYpIntCongestionNotificationNew:
        case bcmFieldActionRpIntCongestionNotificationNew:
        case bcmFieldActionPfcClassNew:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionDropPrecedence:
        case bcmFieldActionGpDropPrecedence:
        case bcmFieldActionYpDropPrecedence:
        case bcmFieldActionRpDropPrecedence:
            action = bcmFieldActionGpDropPrecedence;
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            if ((BCM_FIELD_COLOR_GREEN != fa->param[0]) && (BCM_FIELD_COLOR_RED != fa->param[0]) &&
                (BCM_FIELD_COLOR_YELLOW != fa->param[0])) {
                LOG_ERROR(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP: Error: param0 "
                                    "is not a valid Color.\n")));
                return BCM_E_PARAM;
            }
            break;
        case bcmFieldActionUntaggedPacketPriorityNew:
             ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
             ACTION_CHECK(a_offset.width[0], fa->param[0]);
             break;
        case bcmFieldActionCosMapNew:
        case bcmFieldActionGpCosMapNew:
        case bcmFieldActionYpCosMapNew:
        case bcmFieldActionRpCosMapNew:
            action = bcmFieldActionGpCosMapNew;
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], params.cosq_new);
            break;
        case bcmFieldActionPrioIntCopy:
        case bcmFieldActionPrioIntTos:
        case bcmFieldActionPrioIntCancel:
        case bcmFieldActionGpPrioIntCopy:
        case bcmFieldActionGpPrioIntTos:
        case bcmFieldActionGpPrioIntCancel:
        case bcmFieldActionYpPrioIntCopy:
        case bcmFieldActionYpPrioIntTos:
        case bcmFieldActionYpPrioIntCancel:
        case bcmFieldActionRpPrioIntCopy:
        case bcmFieldActionRpPrioIntTos:
        case bcmFieldActionRpPrioIntCancel:
            break;
        /* Actions from PROFILE_SET_2 */
        case bcmFieldActionEcnNew:
        case bcmFieldActionGpEcnNew:
        case bcmFieldActionYpEcnNew:
        case bcmFieldActionRpEcnNew:
            action = bcmFieldActionGpEcnNew;
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionPrioPktNew:
        case bcmFieldActionGpPrioPktNew:
        case bcmFieldActionYpPrioPktNew:
        case bcmFieldActionRpPrioPktNew:
            action = bcmFieldActionGpPrioPktNew;
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionGpTosPrecedenceNew:
            action = bcmFieldActionGpTosPrecedenceNew;
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionDscpNew:
        case bcmFieldActionGpDscpNew:
        case bcmFieldActionYpDscpNew:
        case bcmFieldActionRpDscpNew:
            action = bcmFieldActionGpDscpNew;
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionPrioPktCopy:
        case bcmFieldActionGpPrioPktCopy:
        case bcmFieldActionYpPrioPktCopy:
        case bcmFieldActionRpPrioPktCopy:
        case bcmFieldActionPrioPktTos:
        case bcmFieldActionGpPrioPktTos:
        case bcmFieldActionYpPrioPktTos:
        case bcmFieldActionRpPrioPktTos:
        case bcmFieldActionPrioPktCancel:
        case bcmFieldActionGpPrioPktCancel:
        case bcmFieldActionYpPrioPktCancel:
        case bcmFieldActionRpPrioPktCancel:
        case bcmFieldActionDot1pPreserve:
        case bcmFieldActionGpDot1pPreserve:
        case bcmFieldActionYpDot1pPreserve:
        case bcmFieldActionRpDot1pPreserve:
        case bcmFieldActionDscpCancel:
        case bcmFieldActionGpDscpCancel:
        case bcmFieldActionYpDscpCancel:
        case bcmFieldActionRpDscpCancel:
        case bcmFieldActionDscpPreserve:
        case bcmFieldActionGpDscpPreserve:
        case bcmFieldActionYpDscpPreserve:
        case bcmFieldActionRpDscpPreserve:
        case bcmFieldActionGpTosPrecedenceCopy:
        case bcmFieldActionPrioPktAndIntCopy:
        case bcmFieldActionPrioPktAndIntTos:
        case bcmFieldActionPrioPktAndIntCancel:
        case bcmFieldActionRpPrioPktAndIntCopy:
        case bcmFieldActionRpPrioPktAndIntTos:
        case bcmFieldActionRpPrioPktAndIntCancel:
        case bcmFieldActionGpPrioPktAndIntCopy:
        case bcmFieldActionGpPrioPktAndIntTos:
        case bcmFieldActionGpPrioPktAndIntCancel:
        case bcmFieldActionYpPrioPktAndIntCopy:
        case bcmFieldActionYpPrioPktAndIntTos:
        case bcmFieldActionYpPrioPktAndIntCancel:
            break;
        /* Actions from L3SW_CHANGE_L2_SWT */
        case bcmFieldActionEgressClassSelect:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            ACTION_CHECK(a_offset.width[0], params.i2e_cl_sel);
            break;
        case bcmFieldActionHiGigClassSelect:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            ACTION_CHECK(a_offset.width[0], params.i2e_hg_cl_sel);
            break;
        case bcmFieldActionNewClassId:
        case bcmFieldActionMultipathHash:
        case bcmFieldActionAddClassTag:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionFabricQueue:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            ACTION_CHECK(a_offset.width[0], params.fabric_tag_type);
            ACTION_CHECK(a_offset.width[1], params.fabric_tag);
            break;
        case bcmFieldActionL3Switch:
#if defined INCLUDE_L3
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            if (params.flags & BCM_L3_MULTIPATH) {
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset,
                                 _BCM_FIELD_ACTION_L3SWITCH_ECMP);
                ACTION_CHECK(a_offset.width[0], params.nh_ecmp_id);
            } else {
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset,
                             _BCM_FIELD_ACTION_L3SWITCH_NEXT_HOP);
                ACTION_CHECK(a_offset.width[0], params.nh_ecmp_id);
            }
            break;
#else
         return BCM_E_UNAVAIL;
#endif /* INCLUDE_L3 */
        case bcmFieldActionDstMacNew:
        case bcmFieldActionSrcMacNew:
        case bcmFieldActionOuterVlanNew:
        case bcmFieldActionVnTagNew:
        case bcmFieldActionVnTagDelete:
        case bcmFieldActionEtagNew:
        case bcmFieldActionEtagDelete:
        case bcmFieldActionL3SwitchCancel:
        case bcmFieldActionChangeL2FieldsCancel:
            break;
        case bcmFieldActionBFDSessionIdNew:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        /* Actions from IFP_LB_CONTROLS_SET */
        case bcmFieldActionHgTrunkRandomRoundRobinHashCancel:
        case bcmFieldActionTrunkRandomRoundRobinHashCancel:
        case bcmFieldActionEcmpRandomRoundRobinHashCancel:
            break;
        /* Actions from IFP_NAT_OVERRIDE_SET */
        case bcmFieldActionNatCancel:
            break;
#if defined(BCM_HURRICANE4_SUPPORT) && defined(INCLUDE_XFLOW_MACSEC)
        case bcmFieldActionMacSecModidBase:
            break;
#endif
        /* Actions from IFP_COPY_TO_CPU_SET */
        case bcmFieldActionCopyToCpu:
        case bcmFieldActionGpCopyToCpu:
        case bcmFieldActionYpCopyToCpu:
        case bcmFieldActionRpCopyToCpu:
        case bcmFieldActionOamCopyToCpu:
        case bcmFieldActionGpOamCopyToCpu:
        case bcmFieldActionYpOamCopyToCpu:
        case bcmFieldActionRpOamCopyToCpu:
            if (0 != fa->param[0]) {
                action = bcmFieldActionGpCopyToCpu;
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
                ACTION_CHECK(a_offset.width[0], fa->param[1]);
            }
            break;
        case bcmFieldActionTimeStampToCpu:
        case bcmFieldActionGpTimeStampToCpu:
        case bcmFieldActionYpTimeStampToCpu:
        case bcmFieldActionRpTimeStampToCpu:
            if (0 != fa->param[0]) {
                action = bcmFieldActionGpTimeStampToCpu;
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
                ACTION_CHECK(a_offset.width[0], fa->param[1]);
            }
            break;
        case bcmFieldActionCopyToCpuCancel:
        case bcmFieldActionGpCopyToCpuCancel:
        case bcmFieldActionYpCopyToCpuCancel:
        case bcmFieldActionRpCopyToCpuCancel:
        case bcmFieldActionSwitchToCpuCancel:
        case bcmFieldActionGpSwitchToCpuCancel:
        case bcmFieldActionYpSwitchToCpuCancel:
        case bcmFieldActionRpSwitchToCpuCancel:
        case bcmFieldActionSwitchToCpuReinstate:
        case bcmFieldActionGpSwitchToCpuReinstate:
        case bcmFieldActionYpSwitchToCpuReinstate:
        case bcmFieldActionRpSwitchToCpuReinstate:
        case bcmFieldActionTimeStampToCpuCancel:
        case bcmFieldActionGpTimeStampToCpuCancel:
        case bcmFieldActionYpTimeStampToCpuCancel:
        case bcmFieldActionRpTimeStampToCpuCancel:

            break;
        /* Actions from IFP_XXX_OVERRIDE_SET */
        case bcmFieldActionDoNotCheckUrpf:
        case bcmFieldActionDoNotChangeTtl:
        case bcmFieldActionMirrorOverride:
        case bcmFieldActionDoNotCutThrough:
            break;
        /* Actions from IFP_INSTRUMENTATION_TRIGGERS_ENABLE_SET */
        case bcmFieldActionPacketTraceEnable:
           break;
        /* Actions from IFP_CHANGE_CPU_COS_SET */
        case bcmFieldActionCosQCpuNew:
        case bcmFieldActionServicePoolIdNew:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionServicePoolIdPrecedenceNew:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            ACTION_CHECK(a_offset.width[1], fa->param[1]);
            if (!fa->param[1]) {
               return BCM_E_PARAM;
            }
            break;
        /* Actions from IFP_DROP_SET */
        case bcmFieldActionDrop:
        case bcmFieldActionGpDrop:
        case bcmFieldActionYpDrop:
        case bcmFieldActionRpDrop:
        case bcmFieldActionDropCancel:
        case bcmFieldActionGpDropCancel:
        case bcmFieldActionYpDropCancel:
        case bcmFieldActionRpDropCancel:
            break;
        /* Actions from IFP_SFLOW_SET */
        case bcmFieldActionIngSampleEnable:
            break;
        /* Actions from IFP_NAT_SET */
#ifdef INCLUDE_L3
        case bcmFieldActionNatEgressOverride:
            if (soc_feature(unit, soc_feature_nat)) {
                bcm_l3_nat_egress_t nat_info;
                nat_info.nat_id = fa->param[0];

                rv = bcm_esw_l3_nat_egress_get(unit, &nat_info);
                if(BCM_FAILURE(rv)){
                    return BCM_E_PARAM;
                }
            }
            else {
                return BCM_E_UNAVAIL;
            }
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            ACTION_CHECK(a_offset.width[0], params.hw_idx);
            ACTION_CHECK(a_offset.width[1], params.hw_half);
            break;
#endif
        case bcmFieldActionNat:
            break;
        /* Actions from REDIRECT_SET */
        case bcmFieldActionRedirectTrunk:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            if (params.is_dvp) {
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset,
                                  _BCM_FIELD_ACTION_REDIRECT_DVP);
            } else {
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset,
                                  _BCM_FIELD_ACTION_REDIRECT_TRUNK);
            }
            ACTION_CHECK(a_offset.width[0], params.redirect_value);
            break;
        case bcmFieldActionRedirect:
            rv = _bcm_field_action_dest_check(unit, fa);
            BCM_IF_ERROR_RETURN(rv);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            if (params.is_dvp) {
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset,
                                  _BCM_FIELD_ACTION_REDIRECT_DVP);
            } else if (params.is_trunk) {
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset,
                                 _BCM_FIELD_ACTION_REDIRECT_TRUNK);
            } else {
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset,
                                 _BCM_FIELD_ACTION_REDIRECT_DGLP);
            }
            ACTION_CHECK(a_offset.width[0], params.redirect_value);
            break;
        case bcmFieldActionUnmodifiedPacketRedirectPort:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            if (params.is_trunk) {
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset,
                                 _BCM_FIELD_ACTION_REDIRECT_TRUNK);
            } else {
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset,
                                 _BCM_FIELD_ACTION_REDIRECT_DGLP);
            }
            ACTION_CHECK(a_offset.width[0], params.redirect_value);
            break;
#ifdef INCLUDE_L3
        case bcmFieldActionRedirectEgrNextHop:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            if (params.flags & BCM_L3_MULTIPATH) {
                ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset,
                                      _BCM_FIELD_ACTION_REDIRECT_ECMP);
            } else {
                ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset,
                                  _BCM_FIELD_ACTION_REDIRECT_NEXT_HOP);
            }
            ACTION_CHECK(a_offset.width[0], params.nh_ecmp_id);
            break;
#endif
        case bcmFieldActionFabricEHAddOrUpdate:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            break;
        case bcmFieldActionRedirectCancel:
        case bcmFieldActionRedirectPbmp:
        case bcmFieldActionRedirectVlan:
        case bcmFieldActionRedirectBcastPbmp:
        case bcmFieldActionRedirectMcast:
        case bcmFieldActionEgressMask:
        case bcmFieldActionEgressPortsAdd:
        case bcmFieldActionColorIndependent:
            break;
        case bcmFieldActionRedirectIpmc:
#ifdef INCLUDE_L3
            redir_field = fa->param[0];
            if (soc_feature(unit, soc_feature_field_action_redirect_ipmc)) {
                if (_BCM_MULTICAST_IS_SET(fa->param[0])) {
                    if ((0 == _BCM_MULTICAST_IS_L3(fa->param[0])) &&
                            (0 == _BCM_MULTICAST_IS_WLAN(fa->param[0])) &&
                            (0 == _BCM_MULTICAST_IS_VXLAN(fa->param[0])) &&
                            (0 == _BCM_MULTICAST_IS_VLAN(fa->param[0])) &&
                            (0 == _BCM_MULTICAST_IS_VPLS(fa->param[0]))) {
                        return (BCM_E_PARAM);
                    }
                    redir_field = _BCM_MULTICAST_ID_GET(fa->param[0]);
                }
            }
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], redir_field);
#endif
            break;
        case bcmFieldActionMirrorIngress:
        case bcmFieldActionMirrorEgress:
            if((_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id) &&
                    (0 == BCM_GPORT_IS_MIRROR(fa->param[1]))) {
                LOG_ERROR(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP(unit %d) Error: param1=0x%x "
                                    "is not a valid Mirror Destination ID.\n"),
                         unit, fa->param[1]));
                return BCM_E_PARAM;
            }
#ifdef BCM_TOMAHAWK3_SUPPORT
            if (SOC_IS_TOMAHAWK3(unit)) {
                /* Mirroring over trunk not supported */
                if (BCM_GPORT_IS_TRUNK(fa->param[1])) {
                    return (BCM_E_PARAM);
                }
            }
#endif

            rv = _bcm_field_action_dest_check(unit, fa);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionChangeL2Fields:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            break;
        case bcmFieldActionExactMatchClassId:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        /*Actions from TIMESTAMP_SET*/
        case bcmFieldActionEgressTimeStampInsert:
        case bcmFieldActionIngressTimeStampInsert:
        case bcmFieldActionIngressTimeStampInsertCancel:
        case bcmFieldActionEgressTimeStampInsertCancel:
            break;
        /*Actions from DLB_HGT_LAG_SET*/
        case bcmFieldActionDynamicTrunkEnable:
        case bcmFieldActionDynamicTrunkCancel:
        case bcmFieldActionDynamicHgTrunkEnable:
        case bcmFieldActionDynamicHgTrunkCancel:
            break;
#if defined(INCLUDE_L3)
        /*Actions from DLB_ECMP_SET*/
        case bcmFieldActionDynamicEcmpEnable:
        case bcmFieldActionDynamicEcmpCancel:
            break;
        /*Actions from DLB_ALTERNATE_PATH_CONTROL_SET*/
        case bcmFieldActionDgm:
            break;
        case bcmFieldActionDgmThreshold:
        case bcmFieldActionDgmBias:
        case bcmFieldActionDgmCost:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        /*Actions from PROTECTION_SWITCHING_SET*/
        case bcmFieldActionRecoverableDropCancel:
            break;
#endif /* INCLUDE_L3 */
        /* ECMP1_RH_ACTION_SET */
        case bcmFieldActionEcmpResilientHashEnable:
        case bcmFieldActionEcmpResilientHashDisable:
        /* LAG_TH_ACTION_SET */
        case bcmFieldActionTrunkResilientHashEnable:
        case bcmFieldActionTrunkResilientHashDisable:
        /* HGT_RH_ACTION_SET */
        case bcmFieldActionHiGigTrunkResilientHashEnable:
        case bcmFieldActionHiGigTrunkResilientHashDisable:
        /* IGNORE_FCOE_ZONE_CHECK_SET */
        case bcmFieldActionFibreChanZoneCheckActionCancel:
            break;
        /* LOOPBACK_PROFILE_ACTION_SET */
        case bcmFieldActionLoopbackType:
            if ((bcmFieldLoopbackTypeMasquerade != fa->param[0]) &&
                (bcmFieldLoopbackTypeMasqueradeWithSwitchDropIndication != fa->param[0]) &&
                (bcmFieldLoopbackTypeRedirect != fa->param[0])){
                return BCM_E_PARAM;
            }
            break;
        case bcmFieldActionFibreChanVsanId:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionFibreChanIntVsanPri:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[1], fa->param[0]);
            break;
        case bcmFieldActionAssignExtractionCtrlId:
        case bcmFieldActionAssignEditCtrlId:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            ACTION_CHECK(a_offset.width[1], fa->param[1]);
            break;
        case bcmFieldActionAssignOpaqueObject4:
        case bcmFieldActionAssignOpaqueObject3:
        case bcmFieldActionAssignOpaqueObject2:
        case bcmFieldActionAssignOpaqueObject1:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionLoopbackSubtype:
            if (bcmFieldLoopbackSubtypeCount <= fa->param[0]) {
                return BCM_E_PARAM;
            }
            break;
        case bcmFieldActionEgressFlowControlEnable:
            if (bcmFieldEgressFlowControlCount <= fa->param[0]) {
                return BCM_E_PARAM;
            }
            break;
        case bcmFieldActionEgressFlowEncapEnable:
            if (bcmFieldEgressFlowEncapCount <= fa->param[0]) {
                return BCM_E_PARAM;
            }
            break;
        case bcmFieldActionIntEncapEnable:
        case bcmFieldActionIntEncapUpdate:
        case bcmFieldActionIntTurnAround:
        case bcmFieldActionAddIngOuterVlanToEgrOuterVlan:
        case bcmFieldActionErspan3HdrVlanCosPktCopy:
        case bcmFieldActionGbpClassifierAdd:
        case bcmFieldActionGbpSrcMacMcastBitSet:
        case bcmFieldActionNshEncapEnable:
            break;
        case bcmFieldActionErspan3HdrGbpSrcIdAdd:
        case bcmFieldActionErspan3HdrUdf2Add:
        case bcmFieldActionAssignChangeL2FieldsClassId:
            ACTION_OFFSET_GET(unit, stage_fc, _bcmFieldActionOpaque3, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionAssignNatClassId:
        case bcmFieldActionGbpSrcIdNew:
            ACTION_OFFSET_GET(unit, stage_fc, _bcmFieldActionOpaque1, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionGbpDstIdNew:
            ACTION_OFFSET_GET(unit, stage_fc, _bcmFieldActionOpaque2, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionEncapIfaMetadataHdr:
            ACTION_OFFSET_GET(unit, stage_fc, _bcmFieldActionOpaque4, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionIntEncapDisable:
        case bcmFieldActionElephantColorEnable:
        case bcmFieldActionElephantColorDisable:
        case bcmFieldActionElephantQueueEnable:
        case bcmFieldActionElephantQueueDisable:
        case bcmFieldActionElephantLookupEnable:
        case bcmFieldActionElephantLookupDisable:
        case bcmFieldActionMatchPbmpDrop:
            break;
        case bcmFieldActionMatchPbmpRedirect:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[1], fa->param[0]);
            break;
        case bcmFieldActionDlbEcmpMonitorEnable:
            if ((fa->param[0] != BCM_FIELD_DLB_ECMP_MON_ENABLE) &&
                (fa->param[0] != BCM_FIELD_DLB_ECMP_MON_DISABLE)) {
                return BCM_E_PARAM;
            }
            break;
#if defined (BCM_TOMAHAWK3_SUPPORT)
        case bcmFieldActionMirrorZeroingEnable:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            /* Profile 0 is not supposed to be used */
            if (fa->param[0] == 0) {
                return (BCM_E_PARAM);
            }
            BCM_IF_ERROR_RETURN(
               _bcm_esw_mirror_zero_profile_ref_count_get(unit,
                                            fa->param[0], &ref_count));
            if (ref_count < 1) {
                return (BCM_E_PARAM);
            }
#endif
            break;
        case bcmFieldActionNshServiceIndex:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK(a_offset.width[0], fa->param[0]);
            break;
        case bcmFieldActionNshServicePathId:
            ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
            ACTION_CHECK((a_offset.width[0] + a_offset.width[1]), fa->param[0]);
            break;
        case bcmFieldActionFlowTimestampType:
            if (bcmFieldFlowTimestampCount <= fa->param[0]) {
                return BCM_E_PARAM;
            }
            break;
        case bcmFieldActionFlowTimestampSource0:
        case bcmFieldActionFlowTimestampSource1:
            if (bcmFieldFlowTimestampSourceCount <= fa->param[0]) {
                return BCM_E_PARAM;
            }
            break;
        default:
            LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                "Unsupported Action %s.\n"), action_name[fa->action]));
            return BCM_E_UNAVAIL;
   }
   return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_action_params_check
 * Purpose:
 *     Check field action parameters.
 * Parameters:
 *     unit     - BCM device number
 *     f_ent    - Field entry structure.
 *     fa       - field action
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_action_params_check(int unit,
                              _field_entry_t  *f_ent,
                              _field_action_t *fa)
{
    uint8    mod_id;     /* Module Id.              */
    uint8    port_id;    /* Port Id.                */
    soc_mem_t mem;       /* Policy table memory id. */
    soc_mem_t tcam_mem;  /* Tcam memory id.         */

    if (NULL == f_ent ||
        NULL == fa) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    if (_BCM_FIELD_STAGE_EXTERNAL == f_ent->group->stage_id) {
        return BCM_E_INTERNAL;
    }

    BCM_IF_ERROR_RETURN
         (_bcm_field_th_tcam_policy_mem_get(unit, f_ent, &tcam_mem, &mem));

    switch (f_ent->group->stage_id) {
#if defined(BCM_TOMAHAWK3_SUPPORT)
        case _BCM_FIELD_STAGE_LOOKUP:
            switch (fa->action) {
                case bcmFieldActionMplsLookupEnable:
                     if ((fa->param[0] != BCM_FIELD_MPLS_ENABLE) &&
                         (fa->param[0] != BCM_FIELD_MPLS_DISABLE)) {
                         return BCM_E_PARAM;
                     }
                     return (BCM_E_NONE);
                case bcmFieldActionTerminationAllowed:
                     if (fa->param[0] > BCM_FIELD_ARP_RARP_TERM_ALLOWED) {
                         return BCM_E_PARAM;
                     }
                     return (BCM_E_NONE);
                default:
                    ;
            }
            break;
#endif
        case _BCM_FIELD_STAGE_EGRESS:
            switch (fa->action) {
                case bcmFieldActionHiGigDstModuleGportNew:
                    if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
                        mod_id = BCM_GPORT_MODPORT_MODID_GET(fa->param[0]);
                    } else {
                        return BCM_E_PARAM;
                    }
                    PolicyCheck(unit, mem, HG_DST_MODID_NEWf, mod_id);
                    return (BCM_E_NONE);
                case bcmFieldActionHiGigDstPortGportNew:
                    if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
                        port_id = BCM_GPORT_MODPORT_PORT_GET(fa->param[0]);
                    } else {
                        return BCM_E_PARAM;
                    }
                    PolicyCheck(unit, mem, HG_DST_PORT_NEWf, port_id);
                    return (BCM_E_NONE);
                case bcmFieldActionHiGigDstGportNew:
                    if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
                        mod_id = BCM_GPORT_MODPORT_MODID_GET(fa->param[0]);
                        port_id = BCM_GPORT_MODPORT_PORT_GET(fa->param[0]);
                    } else {
                        return BCM_E_PARAM;
                    }
                    PolicyCheck(unit, mem, HG_DST_MODID_NEWf, mod_id);
                    PolicyCheck(unit, mem, HG_DST_PORT_NEWf, port_id);
                    return (BCM_E_NONE);
                case bcmFieldActionGpHiGigDropPrecedenceNew:
                    PolicyCheck(unit, mem, G_HG_DP_NEWf, fa->param[0]);
                    return (BCM_E_NONE);
                case bcmFieldActionYpHiGigDropPrecedenceNew:
                    PolicyCheck(unit, mem, Y_HG_DP_NEWf, fa->param[0]);
                    return (BCM_E_NONE);
                case bcmFieldActionRpHiGigDropPrecedenceNew:
                    PolicyCheck(unit, mem, R_HG_DP_NEWf, fa->param[0]);
                    return (BCM_E_NONE);
                case bcmFieldActionHiGigDropPrecedenceNew:
                    PolicyCheck(unit, mem, G_HG_DP_NEWf, fa->param[0]);
                    PolicyCheck(unit, mem, Y_HG_DP_NEWf, fa->param[0]);
                    PolicyCheck(unit, mem, R_HG_DP_NEWf, fa->param[0]);
                    return (BCM_E_NONE);
                case bcmFieldActionGpHiGigIntPriNew:
                    PolicyCheck(unit, mem, G_HG_INT_PRI_NEWf , fa->param[0]);
                    return (BCM_E_NONE);
                case bcmFieldActionYpHiGigIntPriNew:
                    PolicyCheck(unit, mem, Y_HG_INT_PRI_NEWf , fa->param[0]);
                    return (BCM_E_NONE);
                case bcmFieldActionRpHiGigIntPriNew:
                    PolicyCheck(unit, mem, R_HG_INT_PRI_NEWf , fa->param[0]);
                    return (BCM_E_NONE);
                case bcmFieldActionHiGigIntPriNew:
                    PolicyCheck(unit, mem, G_HG_INT_PRI_NEWf , fa->param[0]);
                    PolicyCheck(unit, mem, Y_HG_INT_PRI_NEWf , fa->param[0]);
                    PolicyCheck(unit, mem, R_HG_INT_PRI_NEWf , fa->param[0]);
                    return (BCM_E_NONE);
                case bcmFieldActionLoopbackSrcModuleGportNew:
                    if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
                        mod_id = BCM_GPORT_MODPORT_MODID_GET(fa->param[0]);
                    } else {
                        return BCM_E_PARAM;
                    }
                    PolicyCheck(unit, mem, LB_SRC_MODID_NEWf, mod_id);
                    return (BCM_E_NONE);
                case bcmFieldActionLoopbackSrcPortGportNew:
                    if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
                        port_id = BCM_GPORT_MODPORT_PORT_GET(fa->param[0]);
                    } else {
                        return BCM_E_PARAM;
                    }
                    PolicyCheck(unit, mem, LB_SRC_PORT_NEWf, port_id);
                    return (BCM_E_NONE);
                case bcmFieldActionLoopbackSrcGportNew:
                    if (BCM_GPORT_IS_MODPORT(fa->param[0])) {
                        mod_id = BCM_GPORT_MODPORT_MODID_GET(fa->param[0]);
                        port_id = BCM_GPORT_MODPORT_PORT_GET(fa->param[0]);
                    } else {
                        return BCM_E_PARAM;
                    }
                    PolicyCheck(unit, mem, LB_SRC_MODID_NEWf, mod_id);
                    PolicyCheck(unit, mem, LB_SRC_PORT_NEWf, port_id);
                    return (BCM_E_NONE);
                case bcmFieldActionLoopbackCpuMasqueradePktProfileNew:
                    PolicyCheck(unit, mem,
                                LB_PACKET_PROFILE_NEWf,
                                fa->param[0]);
                    return (BCM_E_NONE);
                case bcmFieldActionLoopbackPacketProcessingPortNew:
                    PolicyCheck(unit, mem, LB_PP_PORT_NEWf , fa->param[0]);
                    return (BCM_E_NONE);
                case bcmFieldActionLoopBackTypeNew:
                    PolicyCheck(unit, mem, LB_TYPE_NEWf , fa->param[0]);
                    return (BCM_E_NONE);
#if defined(BCM_TOMAHAWK2_SUPPORT)
                case bcmFieldActionMplsLabel1ExpNew:
                    PolicyCheck(unit, mem, EXPf, fa->param[0]);
                    return (BCM_E_NONE);
#endif
                case bcmFieldActionLatencyMonitorEnable:
                    PolicyCheck(unit, mem, LAT_MON_ENf, fa->param[0]);
                    return (BCM_E_NONE);
                case bcmFieldActionLatencyMonitorDisable:
                    PolicyCheck(unit, mem, LAT_MON_DISf, fa->param[0]);
                    return (BCM_E_NONE);
                default:
                    ;
            }
            break;
        case _BCM_FIELD_STAGE_INGRESS:
        case _BCM_FIELD_STAGE_EXACTMATCH:
            return _bcm_field_th_ingress_action_params_check(unit, f_ent, fa);
#if defined(BCM_FLOWTRACKER_SUPPORT)
        case _BCM_FIELD_STAGE_FLOWTRACKER:
        case _BCM_FIELD_STAGE_AMFTFP:
        case _BCM_FIELD_STAGE_AEFTFP:
            return _bcm_field_hx5_ft_action_params_check(unit, f_ent, fa);
#endif
        default:
            ;
    }

    return _bcm_field_td2_action_params_check(unit, f_ent, fa);
}
/*
 * Function:
 *     _bcm_field_th_val_set
 * Purpose:
 *     Write the width size of data from p_data to p_fn_data at offset.
 * Parameters:
 *     p_fn_data      - (OUT) Field Policy table entry
 *     p_data         - (IN) Data to be written into p_fn_data
 *     offset         - (IN) Offset at which data has to be copied to p_fn_data
 *     width          - (IN) Size of the data to be written into p_fn_data
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_val_set(uint32 *p_fn_data, uint32 *p_data,
                            uint32 offset, uint32 width)
{
    uint32 u32_mask;
    int idx, wp, bp, len;

    if (NULL == p_fn_data || NULL == p_data) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    wp = offset / 32;
    bp = offset & (32 - 1);
    idx = 0;

    for (len = width; len > 0; len -= 32) {
        if (bp) {
            if (len < 32) {
                u32_mask = (1 << len) - 1;
                if ((p_data[idx] & ~u32_mask) != 0) {
                    return (BCM_E_PARAM);
                }
            } else {
                u32_mask = 0xffffffff;
            }

            p_fn_data[wp] &= ~(u32_mask << bp);
            p_fn_data[wp] |= p_data[idx] << bp;
            if (len > (32-bp)) {
                wp++;
                p_fn_data[wp] &= ~(u32_mask >> (32 - bp));
                p_fn_data[wp] |= p_data[idx] >> (32 - bp) & ((1 << bp) - 1);
            }
        } else {
            if (len < 32) {
                u32_mask = (1 << len) - 1;
                if ((p_data[idx] & ~u32_mask) != 0) {
                    return (BCM_E_PARAM);
                }
                p_fn_data[wp] &= ~u32_mask;
                p_fn_data[wp++] |= p_data[idx];
            } else {
                p_fn_data[wp++] = p_data[idx];
            }
        }

        idx++;
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_val_get
 * Purpose:
 *     Write the width size of data to p_data from p_fn_data at offset.
 * Parameters:
 *     p_fn_data      - (IN)  Field Policy table entry
 *     p_data         - (OUT) Data to be from p_fn_data
 *     offset         - (IN)  Offset at which data has to be
 *                            copied from p_fn_data
 *     width          - (IN)  Size of the data to be written into p_data
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_val_get(uint32 *p_fn_data, uint32 *p_data,
                            uint32 offset, uint32 width)
{
    int                 idx, wp, bp, len;

    /* Input parameters check. */
    if (NULL == p_fn_data || NULL == p_data) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return (BCM_E_PARAM);
    }

    wp = offset / 32;
    bp = offset & (32 - 1);
    idx = 0;

    for (len = width; len > 0; len -= 32) {
        if (bp) {
            p_data[idx] = (p_fn_data[wp++] >> bp) & ((1 << (32 - bp)) - 1);
            p_data[idx] |= p_fn_data[wp] << (32 - bp);
        } else {
            p_data[idx] = p_fn_data[wp++];
        }

        if (len < 32) {
            p_data[idx] &= ((1 << len) - 1);
        }

        idx++;
    }

    return (BCM_E_NONE);
}
/*
 * Function:
 *     _bcm_field_action_val_set
 * Purpose:
 *     Get the actions to be written
 * Parameters:
 *     unit     - BCM device number
 *     mem      - Policy table memory
 *     fa       - field action
 *     buf      - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_NONE
 *     BCM_E_PARAM - Action parameter out-of-range or unrecognized action.
 */
int
_bcm_field_action_val_set(int unit, _field_entry_t *f_ent, uint32 *entbuf,
                                     _bcm_field_action_offset_t *a_offset)
{
    int rv;
    uint32 idx;
    uint32 offset;
    uint32 width;
    uint32 value;

    if (NULL == entbuf || NULL == f_ent || NULL == a_offset) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return (BCM_E_PARAM);
    }

    for (idx = 0; idx < _FP_ACTION_PARAM_SZ; idx++) {
        if (a_offset->width[idx] > 0 ) {
            offset = a_offset->offset[idx];
            width  = a_offset->width[idx];
            value  = a_offset->value[idx];
            /*
             * COVERITY
             *
             * This flow takes care of the  Out-of-bounds access issue
             * for data and mask.
             */
            /* coverity[callee_ptr_arith : FALSE] */
            rv = _bcm_field_th_val_set(entbuf, &value, offset, width);
            BCM_IF_ERROR_RETURN(rv);
        }
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_action_val_get
 * Purpose:
 *     Get the actions written into buffer
 * Parameters:
 *     unit     - (IN) BCM device number
 *     f_ent    - (IN) Field Entry
 *     buf      - (IN) Field Policy table entry
 *     action   - (IN) Field Action of type bcmFieldActionXXX
 *     flags    - (IN) flags to inform offset configuration
 *     a_offset - (OUT) Action offset information
 * Returns:
 *     BCM_E_NONE
 *     BCM_E_PARAM - Action parameter out-of-range or unrecognized action.
 */
int
_bcm_field_action_val_get(int unit,
                          _field_entry_t *f_ent,
                          uint32 *entbuf,
                          _bcm_field_internal_action_t action,
                          uint32 flags,
                          _bcm_field_action_offset_t *a_offset)
{
    int rv;
    uint32 idx;
    uint32 value;
    _field_stage_t *stage_fc;

    if (NULL == entbuf || NULL == a_offset || NULL == f_ent) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return (BCM_E_PARAM);
    }

    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    rv = _bcm_field_action_offset_get(unit, stage_fc, action, a_offset, flags);
    BCM_IF_ERROR_RETURN(rv);


    for (idx = 0; idx < _FP_ACTION_PARAM_SZ; idx++) {
        if (a_offset->width[idx] > 0 ) {
            value = 0;
            rv = _bcm_field_th_val_get(entbuf, &value,
                                       a_offset->offset[idx],
                                       a_offset->width[idx]);
            BCM_IF_ERROR_RETURN(rv);
            a_offset->value[idx]  = value;
        }
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_profile1_cd_action_set
 * Purpose:
 *     Set the color dependent actions of IFP_PROFILE_ONE_SET
 *     in entbuf which is to be written into POLICY table.
 * Parameters:
 *     unit     - BCM device number
 *     action   - Field Action of type bcmFieldActionXXX
 *     f_ent    - entry structure to get policy info from
 *     fa       - field action
 *     entbuf   - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_NONE
 *     BCM_E_PARAM - Action parameter out-of-range or unrecognized action.
 * Notes:
 *     This is a simple read/modify/write pattern.
 *     FP unit lock should be held by calling function.
 */
int
_bcm_field_th_profile1_cd_action_set(int unit,
                                     bcm_field_action_t action,
                                     _field_entry_t *f_ent,
                                     _field_action_t *fa, uint32 *entbuf)

{
    int rv;
    int ucosq = BCM_COS_INVALID;            /* Current unicast queue value */
    int mcosq = BCM_COS_INVALID;            /* Current mcast queue value */
    uint8 mcast_mode_set = 0;               /* Multicast action is set */
    uint8 ucast_mode_set = 0;               /* Unicast action is set */
    _field_stage_t *stage_fc;
    _field_action_t *f_ent_act;
    _field_action_params_t params;
    _bcm_field_action_offset_t a_offset;

    if (NULL == f_ent || NULL == fa || NULL == entbuf) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    rv = _bcm_field_action_offset_get(unit, stage_fc, action, &a_offset, 0);
    BCM_IF_ERROR_RETURN(rv);

    sal_memset(&params, 0, sizeof(params));

    switch (action) {
        case bcmFieldActionGpCosQNew:
        case bcmFieldActionYpCosQNew:
        case bcmFieldActionRpCosQNew:
            /* For the cosQNew action, the param received has to be set
             * for both ucast and mcast.
             * The lower 4 bits of G/Y/R_COS_INT_PRI should be set with ucosq
             * and the upper 4 bits should be set with mcosq.
             * For Helix5 Lower 5 bits is UcosQ and upper 5 mcosq.
             */
            ACTION_RESOLVE(unit, f_ent, fa, &params);
#if defined(BCM_HELIX5_SUPPORT)
            if (SOC_IS_HELIX5(unit) || SOC_IS_HURRICANE4(unit)) {
                ucosq =  (params.cosq_new) & (0x1f);
                mcosq =  (((params.cosq_new) & 0x1f) << 5);
            } else
#endif
            {
                ucosq =  (params.cosq_new) & (0xf);
                mcosq =  (((params.cosq_new) & 0xf) << 4);
            }
            params.cosq_new = ucosq | mcosq;
            a_offset.value[0] = params.cosq_new;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionGpCosMapNew:
        case bcmFieldActionYpCosMapNew:
        case bcmFieldActionRpCosMapNew:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            a_offset.value[0] = params.cosq_new;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionGpPrioIntCopy:
        case bcmFieldActionYpPrioIntCopy:
        case bcmFieldActionRpPrioIntCopy:
        case bcmFieldActionGpPrioIntTos:
        case bcmFieldActionYpPrioIntTos:
        case bcmFieldActionRpPrioIntTos:
        case bcmFieldActionGpPrioIntCancel:
        case bcmFieldActionYpPrioIntCancel:
        case bcmFieldActionRpPrioIntCancel:
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionGpPrioIntNew:
        case bcmFieldActionYpPrioIntNew:
        case bcmFieldActionRpPrioIntNew:
            a_offset.value[0] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionGpIntCongestionNotificationNew:
        case bcmFieldActionYpIntCongestionNotificationNew:
        case bcmFieldActionRpIntCongestionNotificationNew:
        case bcmFieldActionPfcClassNew:
            a_offset.value[0] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionGpUcastCosQNew:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            ucosq = params.cosq_new;
            mcast_mode_set = 0;
            /* Check if corresponding multicast action is set for this entry */
            for (f_ent_act = f_ent->actions;
                 f_ent_act != NULL;
                 f_ent_act = f_ent_act->next) {
                if (bcmFieldActionGpMcastCosQNew == f_ent_act->action ||
                    bcmFieldActionMcastCosQNew == f_ent_act->action) {
                    sal_memset(&params, 0, sizeof(params));
                    /* Get current Mcast queue value */
                    mcast_mode_set = 1;
                    ACTION_RESOLVE(unit, f_ent, f_ent_act, &params);
                    mcosq = params.cosq_new;
                    break;
                }
            }
            if (0 == mcast_mode_set) {
                a_offset.value[0] = ucosq;
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            } else {
                /* Since both ucast and mcast queue modes are to be set,
                 * the offset info of action bcmFieldActionGpCosQNew is used
                 * ie 8 bits of G_COS_INT_PRI and
                 *  value 1 for G_CHANGE_COS_OR_INT_PRI
                 */
                action = bcmFieldActionGpCosQNew;
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);
#if defined(BCM_HELIX5_SUPPORT)
                if (SOC_IS_HELIX5(unit) || SOC_IS_HURRICANE4(unit)) {
                    a_offset.value[0] = ucosq | (mcosq << 5);
                } else
#endif
                {
                    a_offset.value[0] = ucosq | (mcosq << 4);
                }
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            }
            break;
        case bcmFieldActionYpUcastCosQNew:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            ucosq = params.cosq_new;
            mcast_mode_set = 0;
            /* Check if corresponding multicast action is set for this entry */
            for (f_ent_act = f_ent->actions;
                 f_ent_act != NULL;
                 f_ent_act = f_ent_act->next) {
                if (bcmFieldActionYpMcastCosQNew == f_ent_act->action ||
                    bcmFieldActionMcastCosQNew == f_ent_act->action) {
                    sal_memset(&params, 0, sizeof(params));
                    /* Get current Mcast queue value */
                    mcast_mode_set = 1;
                    ACTION_RESOLVE(unit, f_ent, f_ent_act, &params);
                    mcosq = params.cosq_new;
                    break;
                }
            }
            if (0 == mcast_mode_set) {
                a_offset.value[0] = ucosq;
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            } else {
                /* Since both ucast and mcast queue modes are to be set,
                 * the offset info of action bcmFieldActionYpCosQNew is used
                 * ie 8 bits of Y_COS_INT_PRI and
                 *  value 1 for Y_CHANGE_COS_OR_INT_PRI
                 */
                action = bcmFieldActionYpCosQNew;
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);

#if defined(BCM_HELIX5_SUPPORT)
                if (SOC_IS_HELIX5(unit) || SOC_IS_HURRICANE4(unit)) {
                    a_offset.value[0] = ucosq | (mcosq << 5);
                } else
#endif
                {
                    a_offset.value[0] = ucosq | (mcosq << 4);
                }
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            }
            break;
        case bcmFieldActionRpUcastCosQNew:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            ucosq = params.cosq_new;
            mcast_mode_set = 0;
            /* Check if corresponding multicast action is set for this entry */
            for (f_ent_act = f_ent->actions;
                 f_ent_act != NULL;
                 f_ent_act = f_ent_act->next) {
                if (bcmFieldActionRpMcastCosQNew == f_ent_act->action ||
                    bcmFieldActionMcastCosQNew == f_ent_act->action) {
                    sal_memset(&params, 0, sizeof(params));
                    /* Get current Mcast queue value */
                    mcast_mode_set = 1;
                    ACTION_RESOLVE(unit, f_ent, f_ent_act, &params);
                    mcosq = params.cosq_new;
                    break;
                }
            }
            if (0 == mcast_mode_set) {
                a_offset.value[0] = ucosq;
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            } else {
                /* Since both ucast and mcast queue modes are to be set,
                 * the offset info of action bcmFieldActionRpCosQNew is used
                 * ie 8 bits of R_COS_INT_PRI and
                 *  value 1 for R_CHANGE_COS_OR_INT_PRI
                 */

                action = bcmFieldActionRpCosQNew;
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);

#if defined(BCM_HELIX5_SUPPORT)
                if (SOC_IS_HELIX5(unit) || SOC_IS_HURRICANE4(unit)) {
                    a_offset.value[0] = ucosq | (mcosq << 5);
                } else
#endif
                {
                    a_offset.value[0] = ucosq | (mcosq << 4);
                }
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            }
            break;
        case bcmFieldActionGpMcastCosQNew:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            mcosq = params.cosq_new;
            ucast_mode_set = 0;
            /* Check if corresponding multicast action is set for this entry */
            for (f_ent_act = f_ent->actions;
                 f_ent_act != NULL;
                 f_ent_act = f_ent_act->next) {
                if (bcmFieldActionGpUcastCosQNew == f_ent_act->action ||
                    bcmFieldActionUcastCosQNew == f_ent_act->action) {
                    sal_memset(&params, 0, sizeof(params));
                    /* Get current Mcast queue value */
                    ucast_mode_set = 1;
                    ACTION_RESOLVE(unit, f_ent, f_ent_act, &params);
                    ucosq = params.cosq_new;
                    break;
                }
            }
            if (0 == ucast_mode_set) {
                a_offset.value[0] = mcosq;
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            } else {
                /* Since both ucast and mcast queue modes are to be set,
                 * the offset info of action bcmFieldActionGpCosQNew is used
                 * ie 8 bits of G_COS_INT_PRI and
                 *  value 1 for G_CHANGE_COS_OR_INT_PRI
                 */
                action = bcmFieldActionGpCosQNew;
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);

#if defined(BCM_HELIX5_SUPPORT)
                if (SOC_IS_HELIX5(unit) || SOC_IS_HURRICANE4(unit)) {
                    a_offset.value[0] = ucosq | (mcosq << 5);
                } else
#endif
                {
                    a_offset.value[0] = ucosq | (mcosq << 4);
                }
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            }
            break;
        case bcmFieldActionYpMcastCosQNew:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            mcosq = params.cosq_new;
            ucast_mode_set = 0;
            /* Check if corresponding multicast action is set for this entry */
            for (f_ent_act = f_ent->actions;
                 f_ent_act != NULL;
                 f_ent_act = f_ent_act->next) {
                if (bcmFieldActionYpUcastCosQNew == f_ent_act->action ||
                    bcmFieldActionUcastCosQNew == f_ent_act->action) {
                    sal_memset(&params, 0, sizeof(params));
                    /* Get current Mcast queue value */
                    ucast_mode_set = 1;
                    ACTION_RESOLVE(unit, f_ent, f_ent_act, &params);
                    ucosq = params.cosq_new;
                    break;
                }
            }

            if (0 == ucast_mode_set) {
                a_offset.value[0] = mcosq;
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            } else {
                /* Since both ucast and mcast queue modes are to be set,
                 * the offset info of action bcmFieldActionYpCosQNew is used
                 * ie 8 bits of Y_COS_INT_PRI and
                 *  value 1 for Y_CHANGE_COS_OR_INT_PRI
                 */
                action = bcmFieldActionYpCosQNew;
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);

#if defined(BCM_HELIX5_SUPPORT)
                if (SOC_IS_HELIX5(unit) || SOC_IS_HURRICANE4(unit)) {
                    a_offset.value[0] = ucosq | (mcosq << 5);
                } else
#endif
                {
                    a_offset.value[0] = ucosq | (mcosq << 4);
                }
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            }

            break;
        case bcmFieldActionRpMcastCosQNew:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            mcosq = params.cosq_new;
            ucast_mode_set = 0;
            /* Check if corresponding multicast action is set for this entry */
            for (f_ent_act = f_ent->actions;
                 f_ent_act != NULL;
                 f_ent_act = f_ent_act->next) {
                if (bcmFieldActionRpUcastCosQNew == f_ent_act->action ||
                    bcmFieldActionUcastCosQNew == f_ent_act->action) {
                    sal_memset(&params, 0, sizeof(params));
                    /* Get current Mcast queue value */
                    ucast_mode_set = 1;
                    ACTION_RESOLVE(unit, f_ent, f_ent_act, &params);
                    ucosq = params.cosq_new;
                    break;
                }
            }

            if (0 == ucast_mode_set) {
                a_offset.value[0] = mcosq;
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            } else {
                /* Since both ucast and mcast queue modes are to be set,
                 * the offset info of action bcmFieldActionRpCosQNew is used
                 * ie 8 bits of R_COS_INT_PRI and
                 *  value 1 for R_CHANGE_COS_OR_INT_PRI
                 */
                action = bcmFieldActionRpCosQNew;
                ACTION_OFFSET_GET(unit, stage_fc, action, &a_offset, 0);

#if defined(BCM_HELIX5_SUPPORT)
                if (SOC_IS_HELIX5(unit) || SOC_IS_HURRICANE4(unit)) {
                    a_offset.value[0] = ucosq | (mcosq << 5);
                } else
#endif
                {
                    a_offset.value[0] = ucosq | (mcosq << 4);
                }
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            }
            break;
        case bcmFieldActionGpDropPrecedence:
        case bcmFieldActionYpDropPrecedence:
        case bcmFieldActionRpDropPrecedence:
            a_offset.value[0] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionUntaggedPacketPriorityNew:
            a_offset.value[0] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        default:
            LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                        "%s is not found.\n"), action_name[action]));
            return BCM_E_UNAVAIL;
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_profile1_action_set
 * Purpose:
 *     Set the color independent actions of IFP_PROFILE_ONE_SET
 *     in entbuf which is to be written into POLICY table.
 * Parameters:
 *     unit     - BCM device number
 *     action   - Field Action of type bcmFieldActionXXX
 *     f_ent    - entry structure to get policy info from
 *     fa       - field action
 *     entbuf   - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_NONE
 *     BCM_E_PARAM - Action parameter out-of-range or unrecognized action.
 * Notes:
 *     This is a simple read/modify/write pattern.
 *     FP unit lock should be held by calling function.
 */
int
_bcm_field_th_profile1_action_set(int unit, _field_entry_t *f_ent,
                                  _field_action_t *fa, uint32 *entbuf)

{
    int rv;

    if (NULL == f_ent || NULL == fa || NULL == entbuf) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    switch (fa->action) {
        case bcmFieldActionCosQNew:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                      bcmFieldActionGpCosQNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                      bcmFieldActionYpCosQNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                      bcmFieldActionRpCosQNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionCosMapNew:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                      bcmFieldActionGpCosMapNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                      bcmFieldActionYpCosMapNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                      bcmFieldActionRpCosMapNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionPrioIntCopy:
        case bcmFieldActionPrioPktAndIntCopy:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionGpPrioIntCopy,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionYpPrioIntCopy,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionRpPrioIntCopy,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionRpPrioPktAndIntCopy:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionRpPrioIntCopy,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionYpPrioPktAndIntCopy:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionYpPrioIntCopy,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionGpPrioPktAndIntCopy:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionGpPrioIntCopy,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionPrioIntNew:
        case bcmFieldActionPrioPktAndIntNew:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                     bcmFieldActionGpPrioIntNew,
                                                     f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                     bcmFieldActionYpPrioIntNew,
                                                     f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                     bcmFieldActionRpPrioIntNew,
                                                     f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionRpPrioPktAndIntNew:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                     bcmFieldActionRpPrioIntNew,
                                                     f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionYpPrioPktAndIntNew:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                     bcmFieldActionYpPrioIntNew,
                                                     f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionGpPrioPktAndIntNew:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                     bcmFieldActionGpPrioIntNew,
                                                     f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionPrioIntTos:
        case bcmFieldActionPrioPktAndIntTos:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                     bcmFieldActionGpPrioIntTos,
                                                     f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                     bcmFieldActionYpPrioIntTos,
                                                     f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                     bcmFieldActionRpPrioIntTos,
                                                     f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionRpPrioPktAndIntTos:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                     bcmFieldActionRpPrioIntTos,
                                                     f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionYpPrioPktAndIntTos:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                     bcmFieldActionYpPrioIntTos,
                                                     f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionGpPrioPktAndIntTos:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                     bcmFieldActionGpPrioIntTos,
                                                     f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionPrioIntCancel:
        case bcmFieldActionPrioPktAndIntCancel:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                  bcmFieldActionGpPrioIntCancel,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                  bcmFieldActionYpPrioIntCancel,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                  bcmFieldActionRpPrioIntCancel,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionRpPrioPktAndIntCancel:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                  bcmFieldActionRpPrioIntCancel,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionYpPrioPktAndIntCancel:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                  bcmFieldActionYpPrioIntCancel,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionGpPrioPktAndIntCancel:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                  bcmFieldActionGpPrioIntCancel,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionUcastCosQNew:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                   bcmFieldActionGpUcastCosQNew,
                                                   f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                   bcmFieldActionYpUcastCosQNew,
                                                   f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                   bcmFieldActionRpUcastCosQNew,
                                                   f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionMcastCosQNew:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                   bcmFieldActionGpMcastCosQNew,
                                                   f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                   bcmFieldActionYpMcastCosQNew,
                                                   f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                   bcmFieldActionRpMcastCosQNew,
                                                   f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionDropPrecedence:
            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                 bcmFieldActionGpDropPrecedence,
                                                 f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                 bcmFieldActionYpDropPrecedence,
                                                 f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                 bcmFieldActionRpDropPrecedence,
                                                 f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        default:
            return _bcm_field_th_profile1_cd_action_set(unit, fa->action,
                                                        f_ent, fa, entbuf);
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_profile2_cd_action_set
 * Purpose:
 *     Set the color dependent actions of IFP_PROFILE_TWO_SET
 *     in entbuf which is to be written into POLICY table.
 * Parameters:
 *     unit     - BCM device number
 *     action   - Field Action of type bcmFieldActionXXX
 *     f_ent    - entry structure to get policy info from
 *     fa       - field action
 *     entbuf   - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_NONE
 *     BCM_E_PARAM - Action parameter out-of-range or unrecognized action.
 * Notes:
 *     This is a simple read/modify/write pattern.
 *     FP unit lock should be held by calling function.
 */
int
_bcm_field_th_profile2_cd_action_set(int unit,
                                     bcm_field_action_t action,
                                     _field_entry_t *f_ent,
                                     _field_action_t *fa, uint32 *entbuf)

{
    int rv;
    _field_stage_t *stage_fc;
    _bcm_field_action_offset_t a_offset;


    if (NULL == f_ent || NULL == fa || NULL == entbuf) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    rv = _bcm_field_action_offset_get(unit, stage_fc, action, &a_offset, 0);
    BCM_IF_ERROR_RETURN(rv);

    switch (action) {
        case bcmFieldActionGpPrioPktNew:
        case bcmFieldActionYpPrioPktNew:
        case bcmFieldActionRpPrioPktNew:
        case bcmFieldActionGpTosPrecedenceNew:
        case bcmFieldActionGpDscpNew:
        case bcmFieldActionYpDscpNew:
        case bcmFieldActionRpDscpNew:
        case bcmFieldActionGpEcnNew:
        case bcmFieldActionYpEcnNew:
        case bcmFieldActionRpEcnNew:
            a_offset.value[0] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionGpPrioPktCopy:
        case bcmFieldActionGpPrioPktTos:
        case bcmFieldActionGpPrioPktCancel:
        case bcmFieldActionGpDot1pPreserve:
        case bcmFieldActionGpTosPrecedenceCopy:
        case bcmFieldActionGpDscpCancel:
        case bcmFieldActionGpDscpPreserve:
        case bcmFieldActionYpPrioPktCopy:
        case bcmFieldActionYpPrioPktTos:
        case bcmFieldActionYpPrioPktCancel:
        case bcmFieldActionYpDot1pPreserve:
        case bcmFieldActionYpDscpCancel:
        case bcmFieldActionYpDscpPreserve:
        case bcmFieldActionRpPrioPktCopy:
        case bcmFieldActionRpPrioPktTos:
        case bcmFieldActionRpPrioPktCancel:
        case bcmFieldActionRpDot1pPreserve:
        case bcmFieldActionRpDscpCancel:
        case bcmFieldActionRpDscpPreserve:
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        default:
            LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                        "%s is not found.\n"), action_name[action]));
            return BCM_E_UNAVAIL;
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_profile2_action_set
 * Purpose:
 *     Set the color independent actions of IFP_PROFILE_TWO_SET
 *     in entbuf which is to be written into POLICY table.
 * Parameters:
 *     unit     - BCM device number
 *     action   - Field Action of type bcmFieldActionXXX
 *     f_ent    - entry structure to get policy info from
 *     fa       - field action
 *     entbuf   - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_NONE
 *     BCM_E_PARAM - Action parameter out-of-range or unrecognized action.
 * Notes:
 *     This is a simple read/modify/write pattern.
 *     FP unit lock should be held by calling function.
 */
int
_bcm_field_th_profile2_action_set(int unit, _field_entry_t *f_ent,
                                  _field_action_t *fa, uint32 *entbuf)

{
    int rv;

    if (NULL == f_ent || NULL == fa || NULL == entbuf) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    switch (fa->action) {
        case bcmFieldActionEcnNew:
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionGpEcnNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionYpEcnNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionRpEcnNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionPrioPktNew:
        case bcmFieldActionPrioPktAndIntNew:
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionGpPrioPktNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionYpPrioPktNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionRpPrioPktNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionDscpNew:
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionGpDscpNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionYpDscpNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionRpDscpNew,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionDscpCancel:
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionGpDscpCancel,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionYpDscpCancel,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionRpDscpCancel,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionDscpPreserve:
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionGpDscpPreserve,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionYpDscpPreserve,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionRpDscpPreserve,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionPrioPktCopy:
        case bcmFieldActionPrioPktAndIntCopy:
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionGpPrioPktCopy,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionYpPrioPktCopy,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionRpPrioPktCopy,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionPrioPktTos:
        case bcmFieldActionPrioPktAndIntTos:
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionGpPrioPktTos,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionYpPrioPktTos,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionRpPrioPktTos,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionPrioPktCancel:
        case bcmFieldActionPrioPktAndIntCancel:
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionGpPrioPktCancel,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionYpPrioPktCancel,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionRpPrioPktCancel,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionDot1pPreserve:
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionGpDot1pPreserve,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionYpDot1pPreserve,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                      bcmFieldActionRpDot1pPreserve,
                                                      f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        default:
            return _bcm_field_th_profile2_cd_action_set(unit, fa->action,
                                                        f_ent, fa, entbuf);
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_redirect_action_set
 * Purpose:
 *     Set the actions of IFP_REDIRECT_SET in entbuf
 *     which is to be written into POLICY table.
 * Parameters:
 *     unit     - BCM device number
 *     action   - Field Action of type bcmFieldActionXXX
 *     f_ent    - entry structure to get policy info from
 *     fa       - field action
 *     entbuf   - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_NONE
 *     BCM_E_PARAM - Action parameter out-of-range or unrecognized action.
 * Notes:
 *     This is a simple read/modify/write pattern.
 *     FP unit lock should be held by calling function.
 */
int
_bcm_field_th_redirect_action_set(int unit,
                                  _field_entry_t *f_ent,
                                  _field_action_t *fa, uint32 *entbuf)

{
    int rv;
    _field_stage_t *stage_fc;
    _field_action_params_t params;
    _bcm_field_action_offset_t a_offset;


    if (NULL == f_ent || NULL == fa || NULL == entbuf) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    sal_memset(&params, 0, sizeof(params));

    switch(fa->action) {
        case bcmFieldActionRedirectTrunk:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            if (params.is_dvp) {
                ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset,
                                  _BCM_FIELD_ACTION_REDIRECT_DVP);
            } else {
                ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset,
                                  _BCM_FIELD_ACTION_REDIRECT_TRUNK);
            }
            a_offset.value[0] = params.redirect_value;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionRedirect:
        case bcmFieldActionUnmodifiedPacketRedirectPort:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            if (params.is_dvp) {
                ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset,
                                      _BCM_FIELD_ACTION_REDIRECT_DVP);
            } else if (params.is_trunk) {
                ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset,
                                      _BCM_FIELD_ACTION_REDIRECT_TRUNK);
            } else {
                ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset,
                                       _BCM_FIELD_ACTION_REDIRECT_DGLP);
            }
            a_offset.value[0] = params.redirect_value;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
#ifdef INCLUDE_L3
        case bcmFieldActionRedirectEgrNextHop:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            if (params.flags & BCM_L3_MULTIPATH) {
                ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset,
                                      _BCM_FIELD_ACTION_REDIRECT_ECMP);
            } else {
                ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset,
                                      _BCM_FIELD_ACTION_REDIRECT_NEXT_HOP);
            }
            a_offset.value[0] = params.nh_ecmp_id;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
#endif
        case bcmFieldActionRedirectCancel:
            ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset, 0);
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionRedirectPbmp:
        case bcmFieldActionRedirectVlan:
        case bcmFieldActionRedirectBcastPbmp:
        case bcmFieldActionRedirectMcast:
#ifdef INCLUDE_L3
        case bcmFieldActionRedirectIpmc:
#endif
            ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            a_offset.value[0] = params.redirect_value;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionEgressMask:
            ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            a_offset.value[0] = params.redirect_value;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionEgressPortsAdd:
            ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            a_offset.value[0] = params.redirect_value;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionFabricEHAddOrUpdate:
            ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            a_offset.value[0] = params.eh_tag;
            a_offset.value[1] = params.eh_tag_mask_index;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        default:
            LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                        "%s is not found.\n"), action_name[fa->action]));
            return BCM_E_UNAVAIL;
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_l3swl2change_action_set
 * Purpose:
 *     Set the actions of IFP_REDIRECT_SET in entbuf
 *     which is to be written into POLICY table.
 * Parameters:
 *     unit     - BCM device number
 *     action   - Field Action of type bcmFieldActionXXX
 *     f_ent    - entry structure to get policy info from
 *     fa       - field action
 *     entbuf   - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_NONE
 *     BCM_E_PARAM - Action parameter out-of-range or unrecognized action.
 * Notes:
 *     This is a simple read/modify/write pattern.
 *     FP unit lock should be held by calling function.
 */
int
_bcm_field_th_l3swl2change_action_set(int unit,
                                      _field_entry_t *f_ent,
                                      _field_action_t *fa, uint32 *entbuf)
{
    int rv;
    _field_stage_t *stage_fc;
    _field_action_params_t params;
    _bcm_field_action_offset_t a_offset;

    if (NULL == f_ent || NULL == fa || NULL == entbuf) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    sal_memset(&params, 0, sizeof(params));

    switch (fa->action) {
        case bcmFieldActionEgressClassSelect:
            ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            a_offset.value[0] = params.i2e_cl_sel;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionHiGigClassSelect:
            ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            a_offset.value[0] = params.i2e_hg_cl_sel;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionNewClassId:
        case bcmFieldActionAddClassTag:
        case bcmFieldActionMultipathHash:
            ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset, 0);
            a_offset.value[0] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionDstMacNew:
        case bcmFieldActionSrcMacNew:
        case bcmFieldActionOuterVlanNew:
        case bcmFieldActionVnTagNew:
        case bcmFieldActionVnTagDelete:
        case bcmFieldActionEtagNew:
        case bcmFieldActionEtagDelete:
        case bcmFieldActionChangeL2Fields:
            ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset, 0);
            a_offset.value[0] = fa->hw_index;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionFabricQueue:
            ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset, 0);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            a_offset.value[0] = params.fabric_tag_type;
            a_offset.value[1] = params.fabric_tag;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionL3Switch:
#ifdef INCLUDE_L3
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            if (params.flags & BCM_L3_MULTIPATH) {
                ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset,
                                     _BCM_FIELD_ACTION_L3SWITCH_ECMP);
                a_offset.value[0]  = params.nh_ecmp_id;
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            } else {
                ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset,
                                 _BCM_FIELD_ACTION_L3SWITCH_NEXT_HOP);
                a_offset.value[0] = params.nh_ecmp_id;
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            }
#else
            return BCM_E_UNAVAIL;
#endif
            break;
        case bcmFieldActionL3SwitchCancel:
        case bcmFieldActionChangeL2FieldsCancel:
            ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset, 0);
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionBFDSessionIdNew:
            ACTION_OFFSET_GET(unit, stage_fc, fa->action, &a_offset, 0);
            a_offset.value[0] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        default:
            LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                        "%s is not found.\n"), action_name[fa->action]));
            return BCM_E_UNAVAIL;
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_misc_cd_action_set
 * Purpose:
 *     Set the miscellaneous color dependent actions in entbuf which is to be
 *     written into POLICY table.
 * Parameters:
 *     unit     - BCM device number
 *     action   - Field Action of type bcmFieldActionXXX
 *     f_ent    - entry structure to get policy info from
 *     fa       - field action
 *     entbuf   - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_NONE
 *     BCM_E_PARAM - Action parameter out-of-range or unrecognized action.
 * Notes:
 *     This is a simple read/modify/write pattern.
 *     FP unit lock should be held by calling function.
 */
int
_bcm_field_th_misc_cd_action_set(int unit,
                                 bcm_field_action_t action,
                                 _field_entry_t *f_ent,
                                 _field_action_t *fa, uint32 *entbuf)
{
    int rv;
    _field_stage_t *stage_fc;
    _field_action_params_t params;
    _bcm_field_action_offset_t a_offset;

    if (NULL == f_ent || NULL == fa || NULL == entbuf) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    rv = _bcm_field_action_offset_get(unit, stage_fc, action, &a_offset, 0);
    BCM_IF_ERROR_RETURN(rv);

    sal_memset(&params, 0, sizeof(params));

    switch (action) {
        case bcmFieldActionGpSwitchToCpuReinstate:
        case bcmFieldActionYpSwitchToCpuReinstate:
        case bcmFieldActionRpSwitchToCpuReinstate:
        case bcmFieldActionGpDrop:
        case bcmFieldActionYpDrop:
        case bcmFieldActionRpDrop:
        case bcmFieldActionGpDropCancel:
        case bcmFieldActionYpDropCancel:
        case bcmFieldActionRpDropCancel:
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionGpTimeStampToCpu:
        case bcmFieldActionYpTimeStampToCpu:
        case bcmFieldActionRpTimeStampToCpu:
        case bcmFieldActionGpCopyToCpu:
        case bcmFieldActionYpCopyToCpu:
        case bcmFieldActionRpCopyToCpu:
        case bcmFieldActionGpOamCopyToCpu:
        case bcmFieldActionYpOamCopyToCpu:
        case bcmFieldActionRpOamCopyToCpu:
            if (fa->param[0]) {
                a_offset.value[0] = fa->param[1];
            } else {
                a_offset.value[0] = 0;
            }
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionGpCopyToCpuCancel:
            sal_memset(&a_offset, 0 , sizeof(a_offset));
            action = bcmFieldActionGpSwitchToCpuCancel;
            ACTION_GET(unit, f_ent, entbuf, action, 0, &a_offset);
            if (a_offset.value[0] == 0x3) {
                a_offset.value[0] = 0x6;
            } else {
                a_offset.value[0] = 0x2;
            }
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionYpCopyToCpuCancel:
            sal_memset(&a_offset, 0 , sizeof(a_offset));
            action = bcmFieldActionYpSwitchToCpuCancel;
            ACTION_GET(unit, f_ent, entbuf, action, 0, &a_offset);
            if (a_offset.value[0] == 0x3) {
                a_offset.value[0] = 0x6;
            } else {
                a_offset.value[0] = 0x2;
            }
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionRpCopyToCpuCancel:
            sal_memset(&a_offset, 0 , sizeof(a_offset));
            action = bcmFieldActionRpSwitchToCpuCancel;
            ACTION_GET(unit, f_ent, entbuf, action, 0, &a_offset);
            if (a_offset.value[0] == 0x3) {
                a_offset.value[0] = 0x6;
            } else {
                a_offset.value[0] = 0x2;
            }
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionGpSwitchToCpuCancel:
            sal_memset(&a_offset, 0 , sizeof(a_offset));
            action = bcmFieldActionGpCopyToCpuCancel;
            ACTION_GET(unit, f_ent, entbuf, action, 0, &a_offset);
            if (a_offset.value[0] == 0x2) {
                a_offset.value[0] = 0x6;
            } else {
                a_offset.value[0] = 0x3;
            }
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionYpSwitchToCpuCancel:
            sal_memset(&a_offset, 0 , sizeof(a_offset));
            action = bcmFieldActionYpCopyToCpuCancel;
            ACTION_GET(unit, f_ent, entbuf, action, 0, &a_offset);
            if (a_offset.value[0] == 0x2) {
                a_offset.value[0] = 0x6;
            } else {
                a_offset.value[0] = 0x3;
            }
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionRpSwitchToCpuCancel:
            sal_memset(&a_offset, 0 , sizeof(a_offset));
            action = bcmFieldActionRpCopyToCpuCancel;
            ACTION_GET(unit, f_ent, entbuf, action, 0, &a_offset);
            if (a_offset.value[0] == 0x2) {
                a_offset.value[0] = 0x6;
            } else {
                a_offset.value[0] = 0x3;
            }
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionRpPrioPktAndIntCopy:
            if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
                rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionRpPrioIntCopy,
                                                    f_ent, fa, entbuf);
                BCM_IF_ERROR_RETURN(rv);
            }
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                    bcmFieldActionRpPrioPktCopy,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionRpPrioPktAndIntNew:
            if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
                rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionRpPrioIntNew,
                                                    f_ent, fa, entbuf);
                BCM_IF_ERROR_RETURN(rv);
            }
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                    bcmFieldActionRpPrioPktNew,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionRpPrioPktAndIntTos:
            if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
                rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionRpPrioIntTos,
                                                    f_ent, fa, entbuf);
                BCM_IF_ERROR_RETURN(rv);
            }
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                    bcmFieldActionRpPrioPktTos,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionRpPrioPktAndIntCancel:
            if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
                rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionRpPrioIntCancel,
                                                    f_ent, fa, entbuf);
                BCM_IF_ERROR_RETURN(rv);
            }
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                    bcmFieldActionRpPrioPktCancel,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionGpPrioPktAndIntCopy:
            if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
                rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionGpPrioIntCopy,
                                                    f_ent, fa, entbuf);
                BCM_IF_ERROR_RETURN(rv);
            }
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                    bcmFieldActionGpPrioPktCopy,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionGpPrioPktAndIntNew:
            if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
                rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionGpPrioIntNew,
                                                    f_ent, fa, entbuf);
                BCM_IF_ERROR_RETURN(rv);
            }
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                    bcmFieldActionGpPrioPktNew,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionGpPrioPktAndIntTos:
            if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
                rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionGpPrioIntTos,
                                                    f_ent, fa, entbuf);
                BCM_IF_ERROR_RETURN(rv);
            }
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                    bcmFieldActionGpPrioPktTos,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionGpPrioPktAndIntCancel:
            if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
                rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionGpPrioIntCancel,
                                                    f_ent, fa, entbuf);
                BCM_IF_ERROR_RETURN(rv);
            }
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                    bcmFieldActionGpPrioPktCancel,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionYpPrioPktAndIntCopy:
            if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
                rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionYpPrioIntCopy,
                                                    f_ent, fa, entbuf);
                BCM_IF_ERROR_RETURN(rv);
            }
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                    bcmFieldActionYpPrioPktCopy,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionYpPrioPktAndIntNew:
            if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
                rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionYpPrioIntNew,
                                                    f_ent, fa, entbuf);
                BCM_IF_ERROR_RETURN(rv);
            }
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                    bcmFieldActionYpPrioPktNew,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionYpPrioPktAndIntTos:
            if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
                rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionYpPrioIntTos,
                                                    f_ent, fa, entbuf);
                BCM_IF_ERROR_RETURN(rv);
            }
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                    bcmFieldActionYpPrioPktTos,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionYpPrioPktAndIntCancel:
            if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
                rv = _bcm_field_th_profile1_cd_action_set(unit,
                                                    bcmFieldActionYpPrioIntCancel,
                                                    f_ent, fa, entbuf);
                BCM_IF_ERROR_RETURN(rv);
            }
            rv = _bcm_field_th_profile2_cd_action_set(unit,
                                                    bcmFieldActionYpPrioPktCancel,
                                                    f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;

        default:
            LOG_VERBOSE(BSL_LS_BCM_FP,(BSL_META_U(unit,
                        "%s is not found.\n"), action_name[action]));
            return BCM_E_UNAVAIL;
    }

    return BCM_E_NONE;

}

/*
 * Function:
 *     _bcm_field_th_misc_action_set
 * Purpose:
 *     Set the miscellaneous actions in entbuf which is to be
 *     written into POLICY table.
 * Parameters:
 *     unit     - BCM device number
 *     action   - Field Action of type bcmFieldActionXXX
 *     f_ent    - entry structure to get policy info from
 *     fa       - field action
 *     entbuf   - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_NONE
 *     BCM_E_PARAM - Action parameter out-of-range or unrecognized action.
 * Notes:
 *     This is a simple read/modify/write pattern.
 *     FP unit lock should be held by calling function.
 */
int
_bcm_field_th_misc_action_set(int unit,
                              _field_entry_t *f_ent,
                              _field_action_t *fa, uint32 *entbuf)
{
    int rv;
    _field_stage_t *stage_fc;
    _field_action_params_t params;
    _bcm_field_action_offset_t a_offset;


    if (NULL == f_ent || NULL == fa || NULL == entbuf) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return BCM_E_PARAM;
    }

    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    rv = _bcm_field_action_offset_get(unit, stage_fc, fa->action, &a_offset, 0);
    BCM_IF_ERROR_RETURN(rv);

    sal_memset(&params, 0, sizeof(params));

    switch (fa->action) {
        case bcmFieldActionHgTrunkRandomRoundRobinHashCancel:
        case bcmFieldActionTrunkRandomRoundRobinHashCancel:
        case bcmFieldActionEcmpRandomRoundRobinHashCancel:
        case bcmFieldActionNatCancel:
        case bcmFieldActionDoNotCheckUrpf:
        case bcmFieldActionDoNotChangeTtl:
        case bcmFieldActionMirrorOverride:
        case bcmFieldActionIngSampleEnable:
        case bcmFieldActionNat:
        case bcmFieldActionPacketTraceEnable:
        case bcmFieldActionDoNotCutThrough:
        case bcmFieldActionEgressTimeStampInsert:
        case bcmFieldActionIngressTimeStampInsert:
        case bcmFieldActionIngressTimeStampInsertCancel:
        case bcmFieldActionEgressTimeStampInsertCancel:
        case bcmFieldActionDynamicTrunkEnable:
        case bcmFieldActionDynamicTrunkCancel:
        case bcmFieldActionDynamicHgTrunkEnable:
        case bcmFieldActionDynamicHgTrunkCancel:
#if defined(INCLUDE_L3)
        case bcmFieldActionDynamicEcmpEnable:
        case bcmFieldActionDynamicEcmpCancel:
        case bcmFieldActionRecoverableDropCancel:
#endif /* INCLUDE_L3 */
#if defined(BCM_HURRICANE4_SUPPORT) && defined(INCLUDE_XFLOW_MACSEC)
        case bcmFieldActionMacSecModidBase:
#endif
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
#ifdef INCLUDE_L3
        case bcmFieldActionNatEgressOverride:
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            a_offset.value[0] = params.hw_idx;
            a_offset.value[1] = params.hw_half;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
#endif
        case bcmFieldActionCosQCpuNew:
        case bcmFieldActionServicePoolIdNew:
            a_offset.value[0] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionServicePoolIdPrecedenceNew:
            a_offset.value[0] = fa->param[0];
            a_offset.value[1] = ((BCM_FIELD_COLOR_GREEN == fa->param[1]) ? 0 : \
                                  ((BCM_FIELD_COLOR_YELLOW == fa->param[1]) ? 3 : 1));
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionMirrorIngress:
        case bcmFieldActionMirrorEgress:
            sal_memset(&a_offset, 0 , sizeof(a_offset));
            ACTION_GET(unit, f_ent, entbuf, fa->action, 0, &a_offset);
            ACTION_RESOLVE(unit, f_ent, fa, &params);
            a_offset.value[0] |= (0x1 << params.mtp_type_index);
            a_offset.value[1] |= (0x3 & params.mtp_index) << (2 * params.mtp_type_index);
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            if ((fa->flags & _BCM_FIELD_ACTION_CTC_MANIPULATE_FLAG) &&
                (fa->param[2] == 1)) {
                int matched_rule = fa->param[3];

                sal_memset(&a_offset, 0 , sizeof(a_offset));
                ACTION_GET(unit, f_ent, entbuf, bcmFieldActionFabricQueue, 0, &a_offset);
                a_offset.value[0] = 0;
                a_offset.value[1] = matched_rule;
                a_offset.value[2] = 0x3;
                ACTION_SET(unit, f_ent, entbuf, &a_offset);
            }

            break;
        case bcmFieldActionDrop:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                  bcmFieldActionGpDrop,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                  bcmFieldActionYpDrop,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                  bcmFieldActionRpDrop,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionDropCancel:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                  bcmFieldActionGpDropCancel,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                  bcmFieldActionYpDropCancel,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                  bcmFieldActionRpDropCancel,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionOamCopyToCpu:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                  bcmFieldActionGpOamCopyToCpu,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                  bcmFieldActionYpOamCopyToCpu,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                  bcmFieldActionRpOamCopyToCpu,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionCopyToCpu:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                  bcmFieldActionGpCopyToCpu,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                  bcmFieldActionYpCopyToCpu,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                  bcmFieldActionRpCopyToCpu,
                                                  f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionCopyToCpuCancel:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                bcmFieldActionGpCopyToCpuCancel,
                                                f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                bcmFieldActionYpCopyToCpuCancel,
                                                f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                bcmFieldActionRpCopyToCpuCancel,
                                                f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionSwitchToCpuCancel:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                              bcmFieldActionGpSwitchToCpuCancel,
                                              f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                              bcmFieldActionYpSwitchToCpuCancel,
                                              f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                              bcmFieldActionRpSwitchToCpuCancel,
                                              f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionSwitchToCpuReinstate:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                           bcmFieldActionGpSwitchToCpuReinstate,
                                           f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                           bcmFieldActionYpSwitchToCpuReinstate,
                                           f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                           bcmFieldActionRpSwitchToCpuReinstate,
                                           f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionTimeStampToCpu:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                              bcmFieldActionGpTimeStampToCpu,
                                              f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                              bcmFieldActionYpTimeStampToCpu,
                                              f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                              bcmFieldActionRpTimeStampToCpu,
                                              f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionGpTimeStampToCpu:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                              bcmFieldActionGpTimeStampToCpu,
                                              f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionYpTimeStampToCpu:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                              bcmFieldActionYpTimeStampToCpu,
                                              f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionRpTimeStampToCpu:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                              bcmFieldActionRpTimeStampToCpu,
                                              f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionTimeStampToCpuCancel:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                bcmFieldActionGpCopyToCpuCancel,
                                                f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                bcmFieldActionYpCopyToCpuCancel,
                                                f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                bcmFieldActionRpCopyToCpuCancel,
                                                f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
	case bcmFieldActionGpTimeStampToCpuCancel:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                bcmFieldActionGpCopyToCpuCancel,
                                                f_ent, fa, entbuf);
	    BCM_IF_ERROR_RETURN(rv);
            break;
	case bcmFieldActionYpTimeStampToCpuCancel:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                bcmFieldActionYpCopyToCpuCancel,
                                                f_ent, fa, entbuf);
	    BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionRpTimeStampToCpuCancel:
            rv = _bcm_field_th_misc_cd_action_set(unit,
                                                bcmFieldActionRpCopyToCpuCancel,
                                                f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionPrioPktAndIntCopy:
        case bcmFieldActionPrioPktAndIntNew:
        case bcmFieldActionPrioPktAndIntTos:
        case bcmFieldActionPrioPktAndIntCancel:
            if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
                rv = _bcm_field_th_profile1_action_set(unit,
                                               f_ent, fa, entbuf);

                BCM_IF_ERROR_RETURN(rv);
            }
            rv = _bcm_field_th_profile2_action_set(unit,
                                               f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
#ifdef	INCLUDE_L3
        case bcmFieldActionDgm:
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionDgmThreshold:
        case bcmFieldActionDgmBias:
        case bcmFieldActionDgmCost:
            a_offset.value[0] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
#endif /*INCLUDE_L3*/
        case bcmFieldActionEcmpResilientHashEnable:
        case bcmFieldActionEcmpResilientHashDisable:
        case bcmFieldActionTrunkResilientHashEnable:
        case bcmFieldActionTrunkResilientHashDisable:
        case bcmFieldActionHiGigTrunkResilientHashEnable:
        case bcmFieldActionHiGigTrunkResilientHashDisable:
        case bcmFieldActionFibreChanZoneCheckActionCancel:
        case bcmFieldActionIntEncapEnable:
        case bcmFieldActionIntEncapDisable:
        case bcmFieldActionElephantColorEnable:
        case bcmFieldActionElephantColorDisable:
        case bcmFieldActionElephantQueueEnable:
        case bcmFieldActionElephantQueueDisable:
        case bcmFieldActionElephantLookupEnable:
        case bcmFieldActionElephantLookupDisable:
        case bcmFieldActionNshEncapEnable:
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionAssignExtractionCtrlId:
        case bcmFieldActionAssignEditCtrlId:
            a_offset.value[0] = fa->param[0];
            a_offset.value[1] = fa->param[1];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionAssignOpaqueObject4:
        case bcmFieldActionAssignOpaqueObject3:
        case bcmFieldActionAssignOpaqueObject2:
        case bcmFieldActionAssignOpaqueObject1:
            a_offset.value[0] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
#if defined (BCM_TRIDENT3_SUPPORT)
        case bcmFieldActionEgressFlowControlEnable:
        case bcmFieldActionEgressFlowEncapEnable:
        case bcmFieldActionLoopbackSubtype:
        case bcmFieldActionLoopbackType:
        case bcmFieldActionAssignChangeL2FieldsClassId:
        case bcmFieldActionEncapIfaMetadataHdr:
            BCM_IF_ERROR_RETURN(_field_td3_flex_action_set(unit, fa, &a_offset));
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
#endif
        case bcmFieldActionFibreChanVsanId:
            a_offset.value[0] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionFibreChanIntVsanPri:
            a_offset.value[1] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionMatchPbmpDrop:
            a_offset.value[0] = fa->hw_index;
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionMatchPbmpRedirect:
            a_offset.value[0] = fa->hw_index;
            a_offset.value[1] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionDlbEcmpMonitorEnable:
        case bcmFieldActionMirrorZeroingEnable:
            a_offset.value[0] = fa->param[0];
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionFlowTimestampType:
            if (fa->param[0] == bcmFieldFlowTimestampEgress) {
                a_offset.value[0] = 1;
            } else {
                a_offset.value[0] = 0;
            }
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        case bcmFieldActionFlowTimestampSource0:
        case bcmFieldActionFlowTimestampSource1:
            if (fa->param[0] == bcmFieldFlowTimestampSourceLegacy) {
                a_offset.value[0] = 1;
            } else if (fa->param[0] == bcmFieldFlowTimestampSourceNTP) {
                a_offset.value[0] = 2;
            } else if (fa->param[0] == bcmFieldFlowTimestampSourcePTP) {
                a_offset.value[0] = 3;
            } else {
                a_offset.value[0] = 0;
            }
            ACTION_SET(unit, f_ent, entbuf, &a_offset);
            break;
        default:
            return _bcm_field_th_misc_cd_action_set(unit, fa->action,
                                                    f_ent, fa, entbuf);
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_th_action_set
 * Purpose:
 *     Set the actions in entbuf which is to be written into POLICY table.
 * Parameters:
 *     unit     - BCM device number
 *     mem      - Policy table memory
 *     f_ent    - entry structure to get policy info from
 *     tcam_idx - index into TCAM
 *     fa       - field action
 *     buf      - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_NONE
 *     BCM_E_PARAM - Action parameter out-of-range or unrecognized action.
 * Notes:
 *     This is a simple read/modify/write pattern.
 *     FP unit lock should be held by calling function.
 */
int
_bcm_field_th_action_set(int unit, soc_mem_t mem, _field_entry_t *f_ent,
                          int tcam_idx, _field_action_t *fa, uint32 *entbuf)
{
    int rv;

    if (NULL == f_ent || NULL == fa || NULL == entbuf) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return (BCM_E_PARAM);
    }

    switch (fa->action) {
        case bcmFieldActionCosQNew:
        case bcmFieldActionGpCosQNew:
        case bcmFieldActionYpCosQNew:
        case bcmFieldActionRpCosQNew:
        case bcmFieldActionCosMapNew:
        case bcmFieldActionGpCosMapNew:
        case bcmFieldActionYpCosMapNew:
        case bcmFieldActionRpCosMapNew:
        case bcmFieldActionUcastCosQNew:
        case bcmFieldActionGpUcastCosQNew:
        case bcmFieldActionYpUcastCosQNew:
        case bcmFieldActionRpUcastCosQNew:
        case bcmFieldActionMcastCosQNew:
        case bcmFieldActionGpMcastCosQNew:
        case bcmFieldActionYpMcastCosQNew:
        case bcmFieldActionRpMcastCosQNew:
        case bcmFieldActionPrioIntNew:
        case bcmFieldActionGpPrioIntNew:
        case bcmFieldActionYpPrioIntNew:
        case bcmFieldActionRpPrioIntNew:
        case bcmFieldActionDropPrecedence:
        case bcmFieldActionGpDropPrecedence:
        case bcmFieldActionYpDropPrecedence:
        case bcmFieldActionRpDropPrecedence:
        case bcmFieldActionPrioIntCopy:
        case bcmFieldActionPrioIntTos:
        case bcmFieldActionPrioIntCancel:
        case bcmFieldActionGpPrioIntCopy:
        case bcmFieldActionGpPrioIntTos:
        case bcmFieldActionGpPrioIntCancel:
        case bcmFieldActionYpPrioIntCopy:
        case bcmFieldActionYpPrioIntTos:
        case bcmFieldActionYpPrioIntCancel:
        case bcmFieldActionRpPrioIntCopy:
        case bcmFieldActionRpPrioIntTos:
        case bcmFieldActionRpPrioIntCancel:
        case bcmFieldActionGpIntCongestionNotificationNew:
        case bcmFieldActionYpIntCongestionNotificationNew:
        case bcmFieldActionRpIntCongestionNotificationNew:
        case bcmFieldActionUntaggedPacketPriorityNew:
            rv = _bcm_field_th_profile1_action_set(unit, f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionEcnNew:
        case bcmFieldActionGpEcnNew:
        case bcmFieldActionYpEcnNew:
        case bcmFieldActionRpEcnNew:
        case bcmFieldActionPrioPktNew:
        case bcmFieldActionGpPrioPktNew:
        case bcmFieldActionYpPrioPktNew:
        case bcmFieldActionRpPrioPktNew:
        case bcmFieldActionGpTosPrecedenceNew:
        case bcmFieldActionDscpNew:
        case bcmFieldActionGpDscpNew:
        case bcmFieldActionYpDscpNew:
        case bcmFieldActionRpDscpNew:
        case bcmFieldActionPrioPktCopy:
        case bcmFieldActionGpPrioPktCopy:
        case bcmFieldActionYpPrioPktCopy:
        case bcmFieldActionRpPrioPktCopy:
        case bcmFieldActionPrioPktTos:
        case bcmFieldActionGpPrioPktTos:
        case bcmFieldActionYpPrioPktTos:
        case bcmFieldActionRpPrioPktTos:
        case bcmFieldActionPrioPktCancel:
        case bcmFieldActionGpPrioPktCancel:
        case bcmFieldActionYpPrioPktCancel:
        case bcmFieldActionRpPrioPktCancel:
        case bcmFieldActionDot1pPreserve:
        case bcmFieldActionGpDot1pPreserve:
        case bcmFieldActionYpDot1pPreserve:
        case bcmFieldActionRpDot1pPreserve:
        case bcmFieldActionDscpCancel:
        case bcmFieldActionGpDscpCancel:
        case bcmFieldActionYpDscpCancel:
        case bcmFieldActionRpDscpCancel:
        case bcmFieldActionGpTosPrecedenceCopy:
        case bcmFieldActionDscpPreserve:
        case bcmFieldActionGpDscpPreserve:
        case bcmFieldActionYpDscpPreserve:
        case bcmFieldActionRpDscpPreserve:
            rv = _bcm_field_th_profile2_action_set(unit, f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionRedirect:
        case bcmFieldActionRedirectTrunk:
        case bcmFieldActionUnmodifiedPacketRedirectPort:
        case bcmFieldActionRedirectMcast:
        case bcmFieldActionRedirectEgrNextHop:
        case bcmFieldActionRedirectCancel:
        case bcmFieldActionRedirectPbmp:
        case bcmFieldActionRedirectVlan:
        case bcmFieldActionRedirectBcastPbmp:
        case bcmFieldActionRedirectIpmc:
        case bcmFieldActionEgressMask:
        case bcmFieldActionEgressPortsAdd:
        case bcmFieldActionFabricEHAddOrUpdate:
            rv = _bcm_field_th_redirect_action_set(unit, f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        case bcmFieldActionEgressClassSelect:
        case bcmFieldActionHiGigClassSelect:
        case bcmFieldActionNewClassId:
        case bcmFieldActionMultipathHash:
        case bcmFieldActionAddClassTag:
        case bcmFieldActionFabricQueue:
        case bcmFieldActionL3Switch:
        case bcmFieldActionDstMacNew:
        case bcmFieldActionSrcMacNew:
        case bcmFieldActionOuterVlanNew:
        case bcmFieldActionVnTagNew:
        case bcmFieldActionVnTagDelete:
        case bcmFieldActionEtagNew:
        case bcmFieldActionEtagDelete:
        case bcmFieldActionL3SwitchCancel:
        case bcmFieldActionChangeL2Fields:
        case bcmFieldActionChangeL2FieldsCancel:
        case bcmFieldActionBFDSessionIdNew:
            rv = _bcm_field_th_l3swl2change_action_set(unit, f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
            break;
        default:
            rv = _bcm_field_th_misc_action_set(unit, f_ent, fa, entbuf);
            BCM_IF_ERROR_RETURN(rv);
    }

    fa->flags &= ~_FP_ACTION_DIRTY; /* Mark action as installed. */

    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_stage_quals_ibus_map_init
 * Purpose:
 *    Initialize Field Ingress Stage Qualifiers to their extractors mapping.
 * Parameters:
 *    unit       - (IN) BCM device number.
 *    stage_fc   - (IN/OUT) Field Processor stage control structure.
 *
 * Returns:
 *    BCM_E_PARAM - Null field stage control structure.
 *    BCM_E_MEMORY - Allocation failure.
 *    BCM_E_INTERNAL - Invalid CAP Stage ID.
 *    BCM_E_NONE - Success.
 */
STATIC int
_field_th_stage_quals_ibus_map_init(int unit, _field_stage_t *stage_fc)
{
    bcmi_keygen_qual_flags_bmp_t qual_flags;
    bcmi_keygen_qual_cfg_info_db_t *db = NULL;
    BCMI_KEYGEN_QUAL_CFG_DECL;

    BCMI_KEYGEN_FUNC_ENTER(unit);

    /* L0 BUS extractor sections offset:
     *    - 32bit extractor = 0
     *    - 16bit extractor = 608
     *    - 8bit extractor  = 1120
     *    - 4bit extractor  = 1280
     *    - 2bit extractor  = 1400
     */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    _FP_XGS3_ALLOC(stage_fc->qual_cfg_info_db,
         sizeof(bcmi_keygen_qual_cfg_info_db_t),
         "IFP qualifiers");
    if (NULL == stage_fc->qual_cfg_info_db) {
        return (BCM_E_MEMORY);
    }
    db = stage_fc->qual_cfg_info_db;
    sal_memset(&qual_flags, 0, sizeof(bcmi_keygen_qual_flags_bmp_t));

    /* Pseudo qualifiers */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyStage, qual_flags);

    if (soc_feature(unit, soc_feature_field_exact_match_support)) {
        SHR_BITSET(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_IFP);
        BCMI_KEYGEN_QUAL_CFG_INIT(unit);
        BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyStageIngressExactMatch, qual_flags);
        SHR_BITCLR(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_IFP);
    }

    SHR_BITSET(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_EM);
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyStageIngress, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyExactMatchHitStatus, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyExactMatchActionClassId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyExactMatchGroupClassId, qual_flags);
    SHR_BITCLR(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_EM);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyNormalizeIpAddrs, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyNormalizeMacAddrs, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIp4, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIp6, qual_flags);


    /* UDF Qualifiers. */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 8, 256, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyData4, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 9, 288, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyData3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 10, 320, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyData2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 8, 128, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyData1, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 9, 144, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyData0, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 5, 160, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyData9, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 6, 192, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyData8, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 7, 224, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyData7, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 6, 96, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyData6, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 7, 112, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyData5, qual_flags);

    /* Packet Fields */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 25, 400, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyOuterVlan, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 25, 400, 12);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyOuterVlanId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 4, 32, 8);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E4, 5, 20, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyOuterVlanId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 25, 412, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyOuterVlanCfi, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 25, 413, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyOuterVlanPri, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 26, 416, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInnerVlan, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 26, 416, 12);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInnerVlanId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 3, 24, 8);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E4, 4, 16, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInnerVlanId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 26, 428, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInnerVlanCfi, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 26, 429, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInnerVlanPri, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 2, 64, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 30, 480, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcMac, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 3, 96, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 31, 496, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstMac, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 11, 352, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcIp, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 15, 480, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstIp, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 11, 352, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E32, 12, 384, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(2, BCMI_KEYGEN_EXT_SECTION_L1E32, 13, 416, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(3, BCMI_KEYGEN_EXT_SECTION_L1E32, 14, 448, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcIp6, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 11, 352, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E32, 12, 384, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcIp6Low, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 13, 416, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E32, 14, 448, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcIp6High, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 15, 480, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E32, 16, 512, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(2, BCMI_KEYGEN_EXT_SECTION_L1E32, 17, 544, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(3, BCMI_KEYGEN_EXT_SECTION_L1E32, 18, 576, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstIp6, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 15, 480, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E32, 16, 512, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstIp6Low, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 17, 544, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E32, 18, 576, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstIp6High, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 29, 464, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyEtherType, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 28, 448, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL4SrcPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 28, 448, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db,
                                    bcmFieldQualifyIcmpTypeCode, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 27, 432, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL4DstPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 4, 128, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyISid, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 4, 128, 24);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL2GreVsid, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 0, 24);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanNetworkId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 32, 24);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanNetworkId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 4, 128, 24);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanNetworkId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 48, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanNetworkId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 80, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanNetworkId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 24, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanFlags, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 56, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanFlags, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 56, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanFlags, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 88, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanFlags, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 0, 24);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanHeaderBits8_31, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 32, 24);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanHeaderBits8_31, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 48, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanHeaderBits8_31, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 80, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanHeaderBits8_31, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 24, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanHeaderBits56_63, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 56, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanHeaderBits56_63, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 56, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanHeaderBits56_63, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 88, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVxlanHeaderBits56_63, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 0, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyETag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 32, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyETag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyETag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 80, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyETag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 0, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVnTag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 32, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVnTag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVnTag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 80, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVnTag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 0, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyCnTag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 32, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyCnTag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyCnTag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 80, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyCnTag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 0, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFabricQueueTag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 32, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFabricQueueTag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFabricQueueTag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 80, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFabricQueueTag, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 0, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabel, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 32, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabel, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabel, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 80, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabel, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 12, 20);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 44, 20);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 44, 4);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 76, 4);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 80, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 0, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelTtl, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 32, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelTtl, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 32, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelTtl, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 64, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelTtl, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 9, 3);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelExp, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 41, 3);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelExp, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 41, 3);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelExp, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 73, 3);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelExp, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 8, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelBos, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 40, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelBos, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 40, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelBos, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 72, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelBos, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 0, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsControlWord, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 32, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsControlWord, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsControlWord, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 80, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsControlWord, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 0, 20);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 9);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIp6FlowLabel, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 32, 20);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 9);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIp6FlowLabel, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 48, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 9);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIp6FlowLabel, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 80, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 9);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIp6FlowLabel, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 13, 104, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_TTL_FN, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyTtl, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 12, 96, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_TOS_FN, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyTos, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 14, 112, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpProtocol, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 2, 8, 4);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E4, 3, 12, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_TCP_FN, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyTcpControl, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 27, 432, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFcoeRxID, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 28, 448, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFcoeOxID, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 16, 256, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyExactMatchGroupClassIdLookup0, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 16, 264, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyExactMatchGroupClassIdLookup1, qual_flags);

    /* The extractors are fixed for ltid and
     * ltid init is done along with pmux init
     */

    if (soc_feature(unit, soc_feature_fp_ltid_match_all_parts) &&
        (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS)) {
        BCMI_KEYGEN_QUAL_CFG_INIT(unit);
        BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 5, 40, 5);
        BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_LTID, 1);
        BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyPreLogicalTableId1, qual_flags);

        BCMI_KEYGEN_QUAL_CFG_INIT(unit);
        BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 5, 40, 5);
        BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_LTID, 2);
        BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, _bcmFieldQualifyPreLogicalTableId2, qual_flags);
    }
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 16, 128, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyExtensionHeaderType, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 15, 120, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyExtensionHeader2Type, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 17, 136, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyExtensionHeaderSubCode, qual_flags);

    SHR_BITSET(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_EM);
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 28, 112, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMHOpcode, qual_flags);
    SHR_BITCLR(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_EM);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 18, 36, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpFlags, qual_flags);

    /*Packet Types*/
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 20, 41, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyHiGig, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 7, 15, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyHiGigProxy, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 7, 14, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyCpuVisibilityPacket, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 13, 54, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDosAttack, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 0, 1, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_D, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL4Ports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 1, 17, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_C, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL4Ports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 8, 17, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL4Ports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 20, 40, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMirrorCopy, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 19, 38, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpFrag, qual_flags);

    if (soc_feature(unit, soc_feature_nat)) {
        BCMI_KEYGEN_QUAL_CFG_INIT(unit);
        BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 0, 0, 2);
        BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyNatSrcRealmId, qual_flags);
    }

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 8, 16, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpFragNonOrFirst, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 1, 16, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_C, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpFragNonOrFirst, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 0, 0, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_D, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpFragNonOrFirst, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 5, 10, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIcmpError, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 5, 11, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRepCopy, qual_flags);

    /*Table HIT/Lookup Status bits*/
    SHR_BITSET(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_EM);
    /* not supported for EM */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 11, 46, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL2SrcHit, qual_flags);

    /* not supported for EM */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 12, 48, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL2DestHit, qual_flags);

    /* not supported for EM */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 12, 50, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL3SrcHostHit, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 12, 50, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpmcStarGroupHit, qual_flags);

    /* not supported for EM */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 12, 51, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL3DestHostHit, qual_flags);

    /* not supported for EM */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 13, 52, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL3DestRouteHit, qual_flags);

    /* not supported for EM */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 13, 53, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL2StationMove, qual_flags);

    /* not supported for EM */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 12, 49, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL2CacheHit, qual_flags);

    /* not supported for EM */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 11, 47, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL2SrcStatic, qual_flags);

    SHR_BITCLR(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_EM);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 13, 55, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpTunnelHit, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 10, 40, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVlanTranslationHit, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 14, 56, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsLabel1Hit, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 14, 56, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyTrillEgressRbridgeHit, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 14, 56, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL2GreSrcIpHit, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 14, 56, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMimSrcGportHit, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 14, 57, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsLabel2Hit, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 14, 57, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyTrillIngressRbridgeHit, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 14, 56, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL2GreVfiHit, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 14, 56, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMimVfiHit, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 9, 18, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIntCongestionNotification, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 17, 35, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMyStationHit, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 14, 58, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsTerminated, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 16, 33, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstIpLocal, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 17, 34, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL3Routable, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 0, 0, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_D, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7AHashUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 1, 16, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_C, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7AHashUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7AHashUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 80, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7AHashUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 16, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7AHashUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7AHashUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 0, 0, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_D, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7BHashUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 1, 16, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_C, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7BHashUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7BHashUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 80, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7BHashUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 16, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7BHashUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7BHashUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 0, 0, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_D, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7AHashLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 1, 16, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_C, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7AHashLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7AHashLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7AHashLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 0, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7AHashLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7AHashLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 0, 0, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_D, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7BHashLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 1, 16, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_C, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7BHashLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7BHashLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7BHashLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 0, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7BHashLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRtag7BHashLower, qual_flags);

    /*Class Ids from different Tables*/

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 15, 240, 12);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 14, 224, 12);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 9, 72, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 8, 64, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 9, 36, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 8, 32, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 15, 240, 12);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 14, 224, 12);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 9, 72, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 8, 64, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 9, 36, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 8, 32, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 15, 240, 12);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassVPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 14, 224, 12);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassVPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 9, 72, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassVPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 8, 64, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassVPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 9, 36, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassVPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 8, 32, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassVPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 15, 240, 12);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 14, 224, 12);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 9, 72, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 8, 64, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 9, 36, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 8, 32, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 15, 240, 10);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 14, 224, 10);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 13, 208, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 12, 192, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 9, 72, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 8, 64, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 7, 56, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 6, 48, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 9, 36, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 8, 32, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 7, 28, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 6, 24, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 15, 240, 10);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 14, 224, 10);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 13, 216, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 12, 200, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 9, 72, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 8, 64, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 9, 36, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 8, 32, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassField, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 15, 248, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceLookupClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 14, 232, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceLookupClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 15, 240, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceIngressKeySelectClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 14, 224, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceIngressKeySelectClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 9, 72, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceIngressKeySelectClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 8, 64, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceIngressKeySelectClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 9, 36, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceIngressKeySelectClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 8, 32, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInterfaceIngressKeySelectClassPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 15, 240, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyUdfClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 14, 224, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyUdfClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 9, 72, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyUdfClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 8, 64, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyUdfClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 9, 36, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_A, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyUdfClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 8, 32, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_B, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyUdfClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 13, 208, 10);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 12, 192, 10);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 13, 216, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 12, 200, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 7, 56, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 6, 48, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 7, 28, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 6, 24, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 13, 208, 10);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 12, 192, 10);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 13, 208, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 12, 192, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 7, 56, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 7, 56, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 6, 48, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 6, 48, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 7, 28, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 7, 28, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 6, 24, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 6, 24, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL2, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 13, 208, 12);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 12, 192, 12);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 13, 216, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 12, 200, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 7, 56, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 6, 48, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 7, 28, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 6, 24, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 13, 208, 10);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 12, 192, 10);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 13, 208, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 12, 192, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 7, 56, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 7, 56, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 6, 48, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 6, 48, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 7, 28, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 7, 28, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_C, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 6, 24, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 6, 24, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_CLASSID_D, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstClassL3, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 5, 46, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyGroupClass, qual_flags);

    /* Ingress/Egress Objects */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 10, 43, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyForwardingVlanValid, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 11, 44, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIngressStpState, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 11, 44, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyStpState, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 17, 272, 12);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyForwardingVlanId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 10, 20, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcVirtualPortValid, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 10, 21, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDestVirtualPortValid, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcModPortGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcModPortGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcTrunkMemberGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 168, 8);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcModuleGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcModPortGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcModPortGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcTrunkMemberGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 182, 8);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcModuleGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcTrunk, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcTrunk, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcMplsGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcMplsGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcMplsGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcMplsGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcMimGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcMimGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcMimGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcMimGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcWlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcWlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcWlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcWlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcNivGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcNivGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcNivGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcNivGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcVxlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcVxlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcVxlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcVxlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcVlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcVlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcVlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcVlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 10, 160, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 7, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_A, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 14);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 2, 16, 8);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E4, 29, 116, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVrf, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 17, 272, 12);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVrf, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 1, 8, 8);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E4, 0, 0, 4);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(2, BCMI_KEYGEN_EXT_SECTION_L1E2, 1, 2, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVpn, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 17, 274, 14);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVpn, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 18, 288, 13);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL3Ingress, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 0, 0, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInPort, qual_flags);

    /*Miscellaneous*/
    SHR_BITSET(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_EM);
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 27, 108, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIntPriority, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 26, 52, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyColor, qual_flags);
    SHR_BITCLR(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_EM);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 27, 55, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db,
                        bcmFieldQualifyRouterAlertLabelValid, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 27, 54, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db,
           bcmFieldQualifyGenericAssociatedChannelLabelValid, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 28, 56, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db,
                         bcmFieldQualifyMplsControlWordValid, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 15, 30, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_MAC_NORM, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMacAddrsNormalized, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 15, 31, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_L3_L4_NORM, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpAddrsNormalized, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 22, 44, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyVlanFormat, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 23, 46, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyTranslatedVlanFormat, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 11, 352, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E32, 12, 384, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(2, BCMI_KEYGEN_EXT_SECTION_L1E32, 13, 416, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(3, BCMI_KEYGEN_EXT_SECTION_L1E32, 14, 448, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(4, BCMI_KEYGEN_EXT_SECTION_L1E32, 15, 480, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(5, BCMI_KEYGEN_EXT_SECTION_L1E32, 16, 512, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(6, BCMI_KEYGEN_EXT_SECTION_L1E32, 17, 544, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(7, BCMI_KEYGEN_EXT_SECTION_L1E32, 18, 576, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL2PayLoad, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 17, 544, 32);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E32, 18, 576, 32);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db,
                        bcmFieldQualifyL2PayloadFirstEightBytes, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 29, 58, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpInfo, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 0, 0, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 10);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyBfdYourDiscriminator, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 1, 32, 32);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 10);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyBfdYourDiscriminator, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 2, 32, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 3, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_B, 10);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyBfdYourDiscriminator, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 4, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 5, 80, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_A, 10);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyBfdYourDiscriminator, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 0, 0, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_D, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyPacketLength, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 1, 16, 16);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_C, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyPacketLength, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 23, 368, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 24, 384, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRangeCheck, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 11, 176, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 3, 6, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_B, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcTrunkMemberGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 26, 104, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyMplsForwardingLabelAction, qual_flags);

    SHR_BITSET(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_EM);
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 11, 88, 6);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyPacketRes, qual_flags);
    SHR_BITCLR(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_EM);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 10, 84, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyLoopback, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 10, 80, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyLoopbackType, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 10, 80, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyTunnelType, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 1, 4, 4);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E2, 4, 8, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpType, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 21, 42, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL2Format, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 25, 50, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInnerTpid, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 24, 48, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyOuterTpid, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 15, 60, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyForwardingType, qual_flags);

    /* Compression Qualifiers */

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 17, 68, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFcoeOxIDClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 16, 64, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFcoeRxIDClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 17, 68, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL4SrcPortClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 0, 6, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_D, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL4SrcPortClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 1, 22, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_C, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL4SrcPortClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 16, 64, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL4DstPortClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 0, 2, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_D, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL4DstPortClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 1, 18, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_C, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyL4DstPortClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 19, 76, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpProtocolClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 0, 10, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_D, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpProtocolClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 1, 26, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_C, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyIpProtocolClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 18, 72, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyEtherTypeClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 13, 104, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_TTL_FN, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyTtlClassZero, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 13, 104, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_TTL_FN, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyTtlClassOne, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 12, 96, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_TOS_FN, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyTosClassZero, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 12, 96, 8);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_TOS_FN, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyTosClassOne, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 2, 8, 4);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E4, 3, 12, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_TCP_FN, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyTcpClassZero, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 2, 8, 4);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E4, 3, 12, 4);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_TCP_FN, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyTcpClassOne, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 21, 336, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 22, 352, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(2, BCMI_KEYGEN_EXT_SECTION_L1E4, 20, 80, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcIpClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 21, 336, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcIpClassLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 22, 352, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcIpClassUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 20, 80, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcIpClassMsbNibble, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 21, 336, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 22, 352, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(2, BCMI_KEYGEN_EXT_SECTION_L1E4, 20, 80, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcIp6Class, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 21, 336, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcIp6ClassLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 22, 352, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcIp6ClassUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 20, 80, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifySrcIp6ClassMsbNibble, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 19, 304, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 20, 320, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(2, BCMI_KEYGEN_EXT_SECTION_L1E4, 21, 84, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstIpClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 19, 304, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstIpClassLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 20, 320, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstIpClassUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 21, 84, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstIpClassMsbNibble, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 19, 304, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 20, 320, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(2, BCMI_KEYGEN_EXT_SECTION_L1E4, 21, 84, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstIp6Class, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 19, 304, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstIp6ClassLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 20, 320, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstIp6ClassUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 21, 84, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstIp6ClassMsbNibble, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 21, 336, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 22, 352, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(2, BCMI_KEYGEN_EXT_SECTION_L1E4, 20, 80, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanSrcIdClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 21, 336, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanSrcIdClassLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 22, 352, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanSrcIdClassUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 20, 80, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanSrcIdClassMsbNibble, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 19, 304, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1, BCMI_KEYGEN_EXT_SECTION_L1E16, 20, 320, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(2, BCMI_KEYGEN_EXT_SECTION_L1E4, 21, 84, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanDstIdClass, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 19, 304, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanDstIdClassLower, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 20, 320, 16);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanDstIdClassUpper, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E4, 21, 84, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanDstIdClassMsbNibble, qual_flags);

    /*Fiber Channel Qualifiers */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 11, 360, 24);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanSrcId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 11, 355, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanInner, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 11, 352, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanOuter, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 12, 392, 24);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanFCtl, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 12, 384, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFcoeSOF, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 15, 488, 24);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanDstId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E32, 15, 480, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanRCtl, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 12, 96, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanCSCtl, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 13, 104, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanVFTHopCount, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 0, 12, 3);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_D, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanVFTPri, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 0, 0, 12);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_D, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanVFTFabricId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 1, 28, 3);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_C, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanVFTPri, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E16, 1, 16, 12);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_AUX_TAG_C, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanVFTFabricId, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 14, 112, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanType, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E8, 16, 128, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyFibreChanDFCtl, qual_flags);

#if defined(BCM_TOMAHAWK2_SUPPORT)
    if (SOC_IS_TOMAHAWK2(unit)) {
        BCMI_KEYGEN_QUAL_CFG_INIT(unit);
        BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_L1E2, 6, 12, 1);
        BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyRecoverableDrop, qual_flags);
    }
#endif /* BCM_TOMAHAWK2_SUPPORT */

    /* ltid is assigned fixed offset to avoid issues
     * with matching on ltid with value 0
     */
    SHR_BITSET(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_PMUX);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0,
        BCMI_KEYGEN_EXT_SECTION_LTID, 0, 144, 4);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1,
        BCMI_KEYGEN_EXT_SECTION_LTID, 1, 150, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db,
        _bcmFieldQualifyPreLogicalTableId, qual_flags);

    SHR_BITSET(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_EM);
    /* Post Mux Qualifers */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_DROP, 0, 159, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDrop, qual_flags);

    if (soc_feature(unit, soc_feature_nat)) {
        /* NAT Qualifiers */
        BCMI_KEYGEN_QUAL_CFG_INIT(unit);
        BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
            (0, BCMI_KEYGEN_EXT_SECTION_NAT_NEEDED, 1, 158, 1);
        BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyNatNeeded, qual_flags);

        BCMI_KEYGEN_QUAL_CFG_INIT(unit);
        BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
            (0, BCMI_KEYGEN_EXT_SECTION_NAT_DST_REALMID, 2, 156, 2);
        BCMI_KEYGEN_QUAL_CFG_INSERT
            (unit, db, bcmFieldQualifyNatDstRealmId, qual_flags);
    }

    /* Exact Match Class Id  and HIT status Qualifiers. */
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0,
        BCMI_KEYGEN_EXT_SECTION_EM_FIRST_LOOKUP_CLASSID_BITS_0_3, 8, 120, 4);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1,
        BCMI_KEYGEN_EXT_SECTION_EM_FIRST_LOOKUP_CLASSID_BITS_4_7, 9, 124, 4);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(2,
        BCMI_KEYGEN_EXT_SECTION_EM_FIRST_LOOKUP_CLASSID_BITS_8_11, 10, 128, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db,
                  _bcmFieldQualifyExactMatchActionClassIdLookup0, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0,
        BCMI_KEYGEN_EXT_SECTION_EM_SECOND_LOOKUP_CLASSID_BITS_0_3, 5, 132, 4);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(1,
        BCMI_KEYGEN_EXT_SECTION_EM_SECOND_LOOKUP_CLASSID_BITS_4_7, 6, 136, 4);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(2,
        BCMI_KEYGEN_EXT_SECTION_EM_SECOND_LOOKUP_CLASSID_BITS_8_11, 7, 140, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db,
                   _bcmFieldQualifyExactMatchActionClassIdLookup1, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0,
        BCMI_KEYGEN_EXT_SECTION_EM_FIRST_LOOKUP_HIT, 3, 154, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db,
        _bcmFieldQualifyExactMatchHitStatusLookup0, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0,
        BCMI_KEYGEN_EXT_SECTION_EM_SECOND_LOOKUP_HIT, 3, 155, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db,
        _bcmFieldQualifyExactMatchHitStatusLookup1, qual_flags);

    /* Destination Port Object(PORT/LAG/VP/VPLAG) -
     * Any other Mode than SINGLE.
     */
    SHR_BITSET(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_PMUX);
    SHR_BITSET(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_SINGLE);
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstTrunk, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstTrunk, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMimGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMimGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMimGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMimGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstNivGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstNivGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstNivGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstNivGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVxlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVxlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVxlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVxlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMplsGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstMplsGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMplsGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMplsGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstWlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstWlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstWlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstWlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 9);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL3EgressNextHops, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 9);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL3Egress, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 9);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL3EgressNextHops, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 9);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL3Egress, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMultipath, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMultipath, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMultipathOverlay, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMultipathOverlay, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMultipathUnderlay, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMultipathUnderlay, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 10);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL3MulticastGroup, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 10);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL3MulticastGroup, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 14, 48, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 11);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL2MulticastGroup, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 13, 64, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 11);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL2MulticastGroup, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_IPBM, 0, 0, 34);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_IPBM_PRESENT, 0);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyInPorts, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_IPBM, 0, 0, 34);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_IPBM_PRESENT, 3);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDevicePortBitmap, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_IPBM, 0, 0, 34);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_IPBM_PRESENT, 1);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifySystemPortBitmap, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD(0, BCMI_KEYGEN_EXT_SECTION_IPBM, 0, 0, 34);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_IPBM_PRESENT, 2);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifySourceGportBitmap, qual_flags);

    /* Destination Port Object(PORT/LAG/VP/VPLAG) - SINGLE Wide Mode */
    SHR_BITCLR(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_SINGLE);
    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstPort, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstTrunk, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 4);
    BCMI_KEYGEN_QUAL_CFG_INSERT(unit, db, bcmFieldQualifyDstTrunk, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMimGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMimGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMimGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMimGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstNivGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstNivGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstNivGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstNivGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVxlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVxlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVxlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVxlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstVlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstWlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstWlanGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstWlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstWlanGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMplsGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMplsGport, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMplsGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 5);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMplsGports, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 9);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL3EgressNextHops, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 9);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL3Egress, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 9);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL3EgressNextHops, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 9);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL3Egress, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMultipath, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMultipath, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMultipathOverlay, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 7);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMultipathOverlay, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMultipathUnderlay, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 8);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstMultipathUnderlay, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 10);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL3MulticastGroup, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 10);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL3MulticastGroup, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_0, 12, 88, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 152, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_0, 11);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL2MulticastGroup, qual_flags);

    BCMI_KEYGEN_QUAL_CFG_INIT(unit);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (0, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINER_1, 11, 104, 16);
    BCMI_KEYGEN_QUAL_CFG_OFFSET_ADD
        (1, BCMI_KEYGEN_EXT_SECTION_SRC_DST_CONTAINERS_MSB, 4, 153, 1);
    BCMI_KEYGEN_QUAL_CFG_PRI_CTRL_SEL_ADD(BCMI_KEYGEN_EXT_CTRL_SEL_SRC_DST_1, 11);
    BCMI_KEYGEN_QUAL_CFG_INSERT
        (unit, db, bcmFieldQualifyDstL2MulticastGroup, qual_flags);

exit:
    BCMI_KEYGEN_FUNC_EXIT();
}

/*
 * Function:
 *    _field_th_qualifiers_init
 * Purpose:
 *    Initialize device qaualifiers select codes & offsets
 * Parameters:
 *    unit       - (IN) BCM device number.
 *    stage_fc   - (IN/OUT) Field Processor stage control structure.
 *
 * Returns:
 *    BCM_E_PARAM - Null field stage control structure.
 *    BCM_E_MEMORY - Allocation failure.
 *    BCM_E_INTERNAL - Invalid CAP Stage ID.
 *    BCM_E_NONE - Success.
 */
STATIC int
_field_th_qualifiers_init(int unit, _field_stage_t *stage_fc)
{
    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Initialize the stage's qualifier information. */
    switch (stage_fc->stage_id) {
        case _BCM_FIELD_STAGE_LOOKUP:
            return (_field_th_lookup_qualifiers_init(unit, stage_fc));
        case _BCM_FIELD_STAGE_EGRESS:
#if defined(BCM_TRIDENT3_SUPPORT)
            if (soc_feature(unit, soc_feature_td3_style_fp)) {
                return (_field_td3_egress_qualifiers_init(unit, stage_fc));
            } else
#endif
            {
                return (_field_th_egress_qualifiers_init(unit, stage_fc));
            }
        case _BCM_FIELD_STAGE_INGRESS:
        case _BCM_FIELD_STAGE_EXACTMATCH:
        case _BCM_FIELD_STAGE_CLASS:
        case _BCM_FIELD_STAGE_FLOWTRACKER:
        case _BCM_FIELD_STAGE_AMFTFP:
        case _BCM_FIELD_STAGE_AEFTFP:
            return BCM_E_NONE;

        default:
            break;
    }

    return (BCM_E_INTERNAL);
}

/*
 * Function:
 *     _bcm_field_th_egress_key_match_type_set
 *
 * Purpose:
 *     Set key match type based on entry group.
 *     NOTE: For double wide entries key type must be the same for
 *           both parts of the entry.
 * Parameters:
 *     unit   - (IN) BCM device number
 *     f_ent  - (IN) Slice number to enable
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_egress_key_match_type_set (int unit, _field_entry_t *f_ent)
{
    _field_group_t    *fg;          /* Field group entry belongs to. */
    uint32            data;         /* Key match type.               */
    uint32            default_data; /* default key match type.       */
    uint32            mask;         /* Key match type mask.          */
    int               rv;           /* Operation return status.      */

    /* Key match type offset.        */
    _bcm_field_qual_offset_t q_offset;
    {
       sal_memset(&q_offset, 0, sizeof(q_offset));
       q_offset.field = KEYf;
       q_offset.num_offsets = 1;
       if (!soc_feature(unit, soc_feature_td3_style_fp)) {
           q_offset.offset[0] = 236;
       } else {
           q_offset.offset[0] = 268;
       }
       q_offset.width[0] = 4;
    }

    /* Input parameters check. */
    if (NULL == f_ent) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return (BCM_E_PARAM);
    }
    if (NULL == (fg = f_ent->group)) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return (BCM_E_PARAM);
    }

    if (fg->flags & _FP_GROUP_SPAN_SINGLE_SLICE) {
        switch (fg->sel_codes[0].fpf3) {
            case _BCM_FIELD_EFP_KEY1:
                data = KEY_TYPE_IPv4_SINGLE;
                default_data = KEY_TYPE_L2_SINGLE;
                break;
            case _BCM_FIELD_EFP_KEY2:
                data = KEY_TYPE_IPv6_SINGLE;
                default_data = KEY_TYPE_L2_SINGLE;
                break;
            case _BCM_FIELD_EFP_KEY4:
                data = KEY_TYPE_L2_SINGLE;
                default_data = KEY_TYPE_L2_SINGLE;
                break;
#if defined(BCM_TRIDENT3_SUPPORT)
          case _BCM_FIELD_EFP_KEY5:
                data = KEY_TYPE_FCOE_SINGLE;
                default_data = KEY_TYPE_L2_SINGLE;
              break;
#endif /* BCM_TRIDENT3_SUPPORT */
            default:
                return (BCM_E_INTERNAL);
        }
    } else {
        switch (fg->sel_codes[1].fpf3) {
            case _BCM_FIELD_EFP_KEY2:
                data = KEY_TYPE_IPv6_DOUBLE;
                default_data = KEY_TYPE_L2_DOUBLE;
                break;
            case _BCM_FIELD_EFP_KEY4:
                if (_BCM_FIELD_EFP_KEY1 == fg->sel_codes[0].fpf3) {
                    if (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIp4)){
                        default_data = KEY_TYPE_L2_DOUBLE;
                    } else {
                        default_data = KEY_TYPE_IPv4_L2_L3_DOUBLE;
                    }
                    data = KEY_TYPE_IPv4_L2_L3_DOUBLE;
                } else if (_BCM_FIELD_EFP_KEY2 == fg->sel_codes[0].fpf3) {
                    data = KEY_TYPE_IPv4_IPv6_DOUBLE;
                    default_data = KEY_TYPE_L2_DOUBLE;
                } else if (_BCM_FIELD_EFP_KEY6 == fg->sel_codes[0].fpf3) {
                    data = KEY_TYPE_HIGIG_DOUBLE;
                    default_data = KEY_TYPE_IPv4_L2_L3_DOUBLE;
                } else if (_BCM_FIELD_EFP_KEY7 == fg->sel_codes[0].fpf3) {
                    data = KEY_TYPE_LOOPBACK_DOUBLE;
                    default_data = KEY_TYPE_IPv4_L2_L3_DOUBLE;
                } else if (_BCM_FIELD_EFP_KEY8 == fg->sel_codes[0].fpf3) {
                    data = KEY_TYPE_L2_DOUBLE;
                    default_data = KEY_TYPE_L2_DOUBLE;
                } else if (_BCM_FIELD_EFP_KEY5 == fg->sel_codes[0].fpf3) {
                    data = KEY_TYPE_FCOE_DOUBLE;
                    default_data = KEY_TYPE_IPv4_L2_L3_DOUBLE;
                }
                break;
            default:
                return (BCM_E_INTERNAL);
        }
    }

    mask = 0xf;

   /*
    * COVERITY
    *
    *This flow takes care of the  Out-of-bounds access issue
    * for data and mask.
    */
    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_qual_value_set_by_entry_type(unit, &q_offset, f_ent,
                                                 &data, &mask,
                                                 _FP_ENTRY_TYPE_0);
    BCM_IF_ERROR_RETURN(rv);

   /*
    * COVERITY
    *
    * This flow takes care of the  Out-of-bounds access issue
    * for data and mask.
    */

    /* coverity[callee_ptr_arith : FALSE] */

    rv = _bcm_field_qual_value_set_by_entry_type(unit, &q_offset, f_ent,
                                                 &default_data, &mask,
                                                 _FP_ENTRY_TYPE_1);
    BCM_IF_ERROR_RETURN(rv);

    return rv;
}

/*
 * Function:
 *     _bcm_field_th_egress_selcode_get
 * Purpose:
 *     Finds a select encodings that will satisfy the
 *     requested qualifier set (Qset).
 * Parameters:
 *     unit      - (IN) BCM unit number.
 *     stage_fc  - (IN) Stage Field control structure.
 *     qset_req  - (IN) Client qualifier set.
 *     fg        - (IN/OUT)Select code information filled into the group.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_egress_selcode_get(int unit, _field_stage_t *stage_fc,
                               bcm_field_qset_t *qset_req,
                               _field_group_t *fg)
{
    int             rv;          /* Operation return status. */
    bcm_field_qset_t new_qset;

    /* Input parameters check. */
    if ((NULL == fg) || (NULL == qset_req) || (NULL == stage_fc)) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return (BCM_E_PARAM);
    }

    if  (fg->flags & _FP_GROUP_SPAN_SINGLE_SLICE) {
        /* Attempt _BCM_FIELD_EFP_KEY4  (L2 key). */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY4, 0, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY4, -1, &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);

            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY4 (Any Packet type) */

            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           0, fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY4;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

        /* Attempt _BCM_FIELD_EFP_KEY1  (IPv4 key). */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY1, 0, fg);

        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY4, -1, &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);


            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY4 (Any Packet type) */

            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           0, fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY1;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

        /* Attempt _BCM_FIELD_EFP_KEY2  (IPv6 key). */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY2, 0, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY4, -1, &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);


            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY4 (Any Packet type) */


            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           0, fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY2;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

#if defined(BCM_TRIDENT3_SUPPORT)
        if (soc_feature(unit, soc_feature_td3_style_fp)) {
            /* Attempt _BCM_FIELD_EFP_KEY5  (FCOE key). */
            rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                    _BCM_FIELD_EFP_KEY5, 0, fg);
            if (BCM_SUCCESS(rv)) {

                rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                        _BCM_FIELD_EFP_KEY4, -1, &new_qset, fg);
                BCM_IF_ERROR_RETURN(rv);


                /* In EFP, for a given qset we can have two selector code
 *                    combination. So attempt _BCM_FIELD_EFP_KEY4 (Any Packet type) */


                rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                        &new_qset,
                        _BCM_FIELD_EFP_KEY4,
                        0, fg);
                if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                            (rv != BCM_E_RESOURCE))) {
                    fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY5;
                    return rv;
                }
            } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
                return rv;
            }
        }
#endif
    } else {

        if (BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIp4)) {
            /* L3 + L2 double wide key for IPv4 packets */
            rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                               _BCM_FIELD_EFP_KEY1,
                                               _BCM_FIELD_EFP_KEY4, fg);
            if (BCM_SUCCESS(rv)) {

                rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                             _BCM_FIELD_EFP_KEY8,
                                             _BCM_FIELD_EFP_KEY4,
                                             &new_qset, fg);
                BCM_IF_ERROR_RETURN(rv);


                /* In EFP, for a given qset we can have two selector code
                   combination. So attempt _BCM_FIELD_EFP_KEY8 and
                   _BCM_FIELD_EFP_KEY4 (Any Packet type) */


                rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                               &new_qset,
                                                           _BCM_FIELD_EFP_KEY8,
                                                           _BCM_FIELD_EFP_KEY4,
                                                              fg);
                if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                   (rv != BCM_E_RESOURCE))) {
                    fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY1;
                    fg->sel_codes[1].fpf3= _BCM_FIELD_EFP_KEY4;
                    return rv;
                }
            } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
                return rv;
            }
        }

        /* L2 + L3 double wide predefined key. */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY1,
                                           _BCM_FIELD_EFP_KEY4, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY1,
                                         _BCM_FIELD_EFP_KEY4,
                                         &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);


            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY1 and
               _BCM_FIELD_EFP_KEY4 (Any Packet type) */


            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY1,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY1;
                fg->sel_codes[1].fpf3= _BCM_FIELD_EFP_KEY4;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

        /* HiGiG Doublewide key */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY6,
                                           _BCM_FIELD_EFP_KEY4, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY1,
                                         _BCM_FIELD_EFP_KEY4,
                                         &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);


            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY1 and
               _BCM_FIELD_EFP_KEY4 (Any Packet type) */


            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY1,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY6;
                fg->sel_codes[1].fpf3= _BCM_FIELD_EFP_KEY4;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

        /* Loopback double wide key */

        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY7,
                                           _BCM_FIELD_EFP_KEY4, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY1,
                                         _BCM_FIELD_EFP_KEY4,
                                         &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);


            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY1 and
               _BCM_FIELD_EFP_KEY4 (Any Packet type) */


            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY1,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY7;
                fg->sel_codes[1].fpf3= _BCM_FIELD_EFP_KEY4;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

        /* L3 + L2 double wide key for IPv6 packets */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY2,
                                           _BCM_FIELD_EFP_KEY4, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY8,
                                         _BCM_FIELD_EFP_KEY4,
                                         &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);


            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY8 and
               _BCM_FIELD_EFP_KEY4 (Any Packet type) */


            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY8,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY2;
                fg->sel_codes[1].fpf3= _BCM_FIELD_EFP_KEY4;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

        /* L3 key for IPv6 packets */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY3,
                                           _BCM_FIELD_EFP_KEY2, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY8,
                                         _BCM_FIELD_EFP_KEY4,
                                         &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);


            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY8 and
               _BCM_FIELD_EFP_KEY4 (Any Packet type) */


            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY8,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY3;
                fg->sel_codes[1].fpf3= _BCM_FIELD_EFP_KEY2;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

        /* Bytes after L2 Double key for non IP packets */
        rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                                           _BCM_FIELD_EFP_KEY8,
                                           _BCM_FIELD_EFP_KEY4, fg);
        if (BCM_SUCCESS(rv)) {

            rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                                         _BCM_FIELD_EFP_KEY8,
                                         _BCM_FIELD_EFP_KEY4,
                                         &new_qset, fg);
            BCM_IF_ERROR_RETURN(rv);


            /* In EFP, for a given qset we can have two selector code
               combination. So attempt _BCM_FIELD_EFP_KEY8 and
               _BCM_FIELD_EFP_KEY4 (Any Packet type) */


            rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                                                           &new_qset,
                                                           _BCM_FIELD_EFP_KEY8,
                                                           _BCM_FIELD_EFP_KEY4,
                                                           fg);
            if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                                    (rv != BCM_E_RESOURCE))) {
                fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY8;
                fg->sel_codes[1].fpf3= _BCM_FIELD_EFP_KEY4;
                return rv;
            }
        } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
            return rv;
        }

#if defined(BCM_TRIDENT3_SUPPORT)
        if (soc_feature(unit, soc_feature_td3_style_fp)) {
            /* FCOE double wide predefined key. */
            rv = _bcm_field_egress_key_attempt(unit, stage_fc, qset_req,
                    _BCM_FIELD_EFP_KEY5,
                    _BCM_FIELD_EFP_KEY4, fg);
            if (BCM_SUCCESS(rv)) {

                rv = _bcm_field_trx_qset_get(unit, qset_req, stage_fc,
                        _BCM_FIELD_EFP_KEY1,
                        _BCM_FIELD_EFP_KEY4,
                        &new_qset, fg);
                BCM_IF_ERROR_RETURN(rv);


                /* In EFP, for a given qset we can have two selector code
                 * combination. So attempt _BCM_FIELD_EFP_KEY1 and
                 * _BCM_FIELD_EFP_KEY4 (Any Packet type) */
                rv = _bcm_field_trx_egress_default_selcode_get(unit, stage_fc,
                        &new_qset,
                        _BCM_FIELD_EFP_KEY1,
                        _BCM_FIELD_EFP_KEY4,
                        fg);
                if (BCM_SUCCESS(rv) || (BCM_FAILURE(rv) &&
                            (rv != BCM_E_RESOURCE))) {
                    fg->sel_codes[0].fpf3= _BCM_FIELD_EFP_KEY5;
                    fg->sel_codes[1].fpf3= _BCM_FIELD_EFP_KEY4;
                    return rv;
                }
            } else if(BCM_FAILURE(rv) && (rv != BCM_E_RESOURCE)) {
                return rv;
            }
        }
#endif
    }

    return BCM_E_RESOURCE;
}

/*
 * Function:
 *     _bcm_field_th_selcode_get
 * Purpose:
 *     Finds a 4-tuple of select encodings that will satisfy the
 *     requested qualifier set (Qset).
 * Parameters:
 *     unit      - (IN) BCM unit number.
 *     stage_fc  - (IN) Stage Field control structure.
 *     qset_req  - (IN) Client qualifier set.
 *     fg        - (IN/OUT)Select code information filled into the group.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_selcode_get(int unit, _field_stage_t *stage_fc,
                          bcm_field_qset_t *qset_req,
                          _field_group_t *fg)
{
    int  rv;                     /* Operation return status. */

    /* Input parameters check. */
    if ((NULL == fg) || (NULL == qset_req) || (NULL == stage_fc)) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return (BCM_E_PARAM);
    }

    /* Egress qualifiers are selected based on Key. */
    switch (stage_fc->stage_id) {
      case _BCM_FIELD_STAGE_EGRESS:
          rv =  _bcm_field_th_egress_selcode_get(unit, stage_fc, qset_req, fg);
          break;
      default:
          rv =  _bcm_field_selcode_get(unit, stage_fc, qset_req, fg);
    }
    return (rv);
}

/*
 * Function:
 *    _field_th_group_install
 *
 * Purpose:
 *    Auxiliary routine used to install field group.
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     fg         - (IN) Installed group structure.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_group_install(int unit, _field_group_t *fg)
{
    _field_slice_t *fs;        /* Slice pointer.           */
    uint8  slice_number;       /* Slices iterator.         */
    int    parts_count;        /* Number of entry parts.   */
    int    idx;                /* Iteration index.         */

    if (NULL == fg) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META("Invalid Parameters\n")));
        return (BCM_E_PARAM);
    }

    /* Get number of entry parts. */
    BCM_IF_ERROR_RETURN(_bcm_field_entry_tcam_parts_count(unit,
                                                          fg->stage_id,
                                                          fg->flags,
                                                          &parts_count
                                                          )
                        );

    for (idx = 0; idx < parts_count; ++idx) {
        BCM_IF_ERROR_RETURN(_bcm_field_tcam_part_to_slice_number(unit, idx,
                                                                 fg,
                                                                 &slice_number
                                                                 )
                            );
        fs = fg->slices + slice_number;

        BCM_IF_ERROR_RETURN(_bcm_field_th_selcodes_install(unit,
                                                           fg,
                                                           fs->slice_number,
                                                           fg->pbmp,
                                                           idx)
                            );
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_group_install
 *
 * Purpose:
 *    Auxiliary routine used to install field group.
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     fg         - (IN) Installed group structure.
 *
 * Returns:
 *     BCM_E_XXX
 */

int
_bcm_field_th_group_install(int unit, _field_group_t *fg)
{
  return _field_th_group_install(unit, fg);
}
           /* START OF COUNTER ROUTINES */


/*
 * Function:
 *     _bcm_field_th_flex_stat_index_get
 * Purpose:
 *      Get the indexes and flags needed to compose requested statistic
 *      which uses flex counter pools.
 *
 * Parameters:
 *   unit          - (IN)  BCM device number.
 *   f_st          - (IN)  Field statistics entity.
 *   stat          - (IN)  Counter type.
 *   idx1          - (OUT) Primary counter index.
 *   idx2          - (OUT) Secondary counter index.
 *   idx3          - (OUT) Ternary Counter Index.
 *   out_flags     - (OUT) Counter flags.
 * Returns:
 *    BCM_E_XXX
 */
int
_bcm_field_th_flex_stat_index_get(int unit,
                                  _field_stat_t *f_st,
                                  bcm_field_stat_t stat,
                                  int *idx1, int *idx2,
                                  int *idx3, uint32 *out_flags)
{
    int     fp_stat_mode_max; /* Max stat modes.                 */
    uint8   idx;              /* HW counter modes iterator.      */
    uint32  flags = 0;        /* _FP_STAT_XXX flags.             */
    uint32  req_bmap;         /* Requested statistics bitmap.    */
    uint32  hw_bmap;          /* HW supported statistics bitmap. */
    _field_stat_color_t  color; /* Stat Color. */

    if (NULL == f_st ||
        NULL == idx1 ||
        NULL == idx2 ||
        NULL == idx3 ||
        NULL == out_flags) {
        return BCM_E_PARAM;
    }

    /* Get application requested bitmap. */
    BCM_IF_ERROR_RETURN
        (_bcm_field_stat_array_to_bmap(unit, f_st, &req_bmap));

    /* If bitmap is zero - no mode selection is required. */
    if (0 == req_bmap) {
        return BCM_E_INTERNAL;
    }

    *idx1 = *idx2 = *idx3 = _FP_INVALID_INDEX;

    fp_stat_mode_max = COUNTOF(th_ingress_cntr_hw_mode_tbl);
    for (idx = 0; idx < fp_stat_mode_max; idx++) {
        hw_bmap = th_ingress_cntr_hw_mode_tbl[idx].hw_bmap;
        color = th_ingress_cntr_hw_mode_tbl[idx].color;
        if (0 == ((req_bmap | hw_bmap) & ~(hw_bmap))) {
            /*
             * For maximizing utilization of hardware counters, this should
             * select the hw_mode both supports the requested stats
             * AND minimizes the number of required hardware counters.
             */
             break;
        }
    }

    if  (idx >= fp_stat_mode_max) {
        return (BCM_E_INTERNAL);
    }

    switch (stat) {
        case bcmFieldStatBytes:
            flags |= _FP_STAT_BYTES;
            /* Fall through */
        case bcmFieldStatPackets:
            if (_bcmFieldStatColorNoColor == color) {
                *idx1 = f_st->hw_index;
            } else if ((_bcmFieldStatColorGreenNotGreen == color) ||
                     (_bcmFieldStatColorYellowNotYellow == color) ||
                     (_bcmFieldStatColorRedNotRed == color)) {
                *idx1 = f_st->hw_index;
                *idx2 = f_st->hw_index + 1;
            } else if (_bcmFieldStatColorGreenYellowRed == color) {
                *idx1 = f_st->hw_index;
                *idx2 = f_st->hw_index + 1;
                *idx3 = f_st->hw_index + 2;
            } else {
                return BCM_E_INTERNAL;
            }
            break;
        case bcmFieldStatGreenBytes:
            flags |= _FP_STAT_BYTES;
            /* Fall through */
        case bcmFieldStatGreenPackets:
            if ((_bcmFieldStatColorGreen == color) ||
                (_bcmFieldStatColorGreenYellow == color) ||
                (_bcmFieldStatColorGreenRed == color) ||
                (_bcmFieldStatColorGreenNotGreen == color) ||
                (_bcmFieldStatColorGreenYellowRed == color)) {
                *idx1 = f_st->hw_index;
            } else {
                return BCM_E_INTERNAL;
            }
            break;
        case bcmFieldStatYellowBytes:
            flags |= _FP_STAT_BYTES;
            /* Fall through */
        case bcmFieldStatYellowPackets:
            if ((_bcmFieldStatColorYellow == color) ||
                (_bcmFieldStatColorYellowRed == color) ||
                (_bcmFieldStatColorYellowNotYellow == color)) {
                *idx1 = f_st->hw_index;
            } else if ((_bcmFieldStatColorGreenYellow == color) ||
                       (_bcmFieldStatColorGreenYellowRed == color)) {
                *idx1 = f_st->hw_index + 1;
            } else {
                return BCM_E_INTERNAL;
            }
            break;
        case bcmFieldStatRedBytes:
            flags |= _FP_STAT_BYTES;
            /* Fall through */
        case bcmFieldStatRedPackets:
            if ((_bcmFieldStatColorRed == color) ||
                (_bcmFieldStatColorRedNotRed == color)) {
                *idx1 = f_st->hw_index;
            } else if ((_bcmFieldStatColorGreenRed == color) ||
                       (_bcmFieldStatColorYellowRed == color)) {
                *idx1 = f_st->hw_index + 1;
            } else if (_bcmFieldStatColorGreenYellowRed == color) {
                *idx1 = f_st->hw_index + 2;
            } else {
                return BCM_E_INTERNAL;
            }
            break;
        case bcmFieldStatNotGreenBytes:
            flags |= _FP_STAT_BYTES;
            /* Fall through */
        case bcmFieldStatNotGreenPackets:
            if (_bcmFieldStatColorNotGreen == color) {
                *idx1 = f_st->hw_index;
            } else if (_bcmFieldStatColorGreenNotGreen == color) {
                *idx1 = f_st->hw_index + 1;
            } else if (_bcmFieldStatColorYellowRed == color) {
                *idx1 = f_st->hw_index;
                *idx2 = f_st->hw_index + 1;
            } else if (_bcmFieldStatColorGreenYellowRed == color) {
                *idx1 = f_st->hw_index + 1;
                *idx2 = f_st->hw_index + 2;
            } else {
                return BCM_E_INTERNAL;
            }
            break;
        case bcmFieldStatNotYellowBytes:
            flags |= _FP_STAT_BYTES;
            /* Fall through */
        case bcmFieldStatNotYellowPackets:
            if (_bcmFieldStatColorNotYellow == color) {
                *idx1 = f_st->hw_index;
            } else if (_bcmFieldStatColorYellowNotYellow == color) {
                *idx1 = f_st->hw_index + 1;
            } else if (_bcmFieldStatColorGreenRed == color) {
                *idx1 = f_st->hw_index;
                *idx2 = f_st->hw_index + 1;
            } else if (_bcmFieldStatColorGreenYellowRed == color) {
                *idx1 = f_st->hw_index;
                *idx2 = f_st->hw_index + 2;
            } else {
                return BCM_E_INTERNAL;
            }
            break;
        case bcmFieldStatNotRedBytes:
            flags |= _FP_STAT_BYTES;
            /* Fall through */
        case bcmFieldStatNotRedPackets:
            if (_bcmFieldStatColorNotRed == color) {
                *idx1 = f_st->hw_index;
            } else if (_bcmFieldStatColorRedNotRed == color) {
                *idx1 = f_st->hw_index + 1;
            } else if ((_bcmFieldStatColorGreenYellow == color) ||
                       (_bcmFieldStatColorGreenYellowRed == color)) {
                *idx1 = f_st->hw_index;
                *idx2 = f_st->hw_index + 1;
            } else {
                return BCM_E_INTERNAL;
            }
            break;
        default:
            return BCM_E_INTERNAL;
    }

    flags |= _FP_STAT_ADD;
    *out_flags = flags;
    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_th_stat_index_get
 * Purpose:
 *      Get the indexes and flags needed to compose requested statistic.
 *
 * Parameters:
 *   unit          - (IN)  BCM device number.
 *   f_st          - (IN)  Field statistics entity.
 *   stat          - (IN)  Counter type.
 *   idx1          - (OUT)  Primary counter index.
 *   idx2          - (OUT)  Secondary counter index.
 *   out_flags     - (OUT)  Counter flags.
 * Returns:
 *    BCM_E_XXX
 */
int
_bcm_field_th_stat_index_get(int unit,
                             _field_stat_t *f_st,
                             bcm_field_stat_t stat,
                             int *idx1, int *idx2,
                             int *idx3, uint32 *out_flags)
{
    int rv;

    if (NULL == f_st ||
        NULL == idx1 ||
        NULL == idx2 ||
        NULL == idx3 ||
        NULL == out_flags) {
        return BCM_E_PARAM;
    }

    if ((_BCM_FIELD_STAGE_INGRESS == f_st->stage_id) ||
        (_BCM_FIELD_STAGE_EXACTMATCH == f_st->stage_id)) {
        rv = _bcm_field_th_flex_stat_index_get(unit, f_st, stat, idx1,
                                               idx2, idx3, out_flags);
    } else {
        rv = _bcm_field_trx_stat_index_get(unit, f_st, stat, idx1,
                                           idx2, idx3, out_flags);
    }

    return rv;
}

/*
 * Function:
 *    _field_th_flex_mode_get
 * Purpose:
 *    Get flex stat hardware counter mode information
 * Parameters:
 *     unit  - (IN) BCM device number
 *     f_st  - (IN) Pointer to field stat structure
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_flex_mode_get(int unit,
                         _field_stat_t *f_st)
{
    int     fp_stat_mode_max; /* Max stat modes.  */
    uint8   idx;            /* HW counter modes iterator.      */
    uint8   hw_entry_count; /* Number of counter table entries.*/
    uint32  req_bmap;       /* Requested statistics bitmap.    */
    uint32  hw_bmap;        /* HW supported statistics bitmap. */

    /* Input parameter check. */
    if (NULL == f_st) {
        return (BCM_E_PARAM);
    }

    /* Get application requested bitmap. */
    BCM_IF_ERROR_RETURN
        (_bcm_field_stat_array_to_bmap(unit, f_st, &req_bmap));

    /* If bitmap is zero - no mode selection is required. */
    if (0 == req_bmap) {
        f_st->hw_mode = 0;
        f_st->hw_stat = 0;
        f_st->hw_flags |= _FP_STAT_FLEX_CNTR;
        f_st->flex_mode = 0;
        f_st->hw_entry_count = 0;
        return (BCM_E_NONE);
    }

    fp_stat_mode_max = COUNTOF(th_ingress_cntr_hw_mode_tbl);
    for (idx = 0; idx < fp_stat_mode_max; idx++) {
        hw_bmap = th_ingress_cntr_hw_mode_tbl[idx].hw_bmap;
        hw_entry_count = th_ingress_cntr_hw_mode_tbl[idx].hw_entry_count;
        if (0 == ((req_bmap | hw_bmap) & ~(hw_bmap))) {
            /*
             * For maximizing utilization of hardware counters, this should
             * select the hw_mode both supports the requested stats
             * AND minimizes the number of required hardware counters.
             */
             break;
        }
    }

    if  (idx >= fp_stat_mode_max) {
        return (BCM_E_RESOURCE);
    }

     /* Initialize stat structure with flex stat parameter info. */
     f_st->hw_stat   = req_bmap;
     f_st->hw_flags |= _FP_STAT_FLEX_CNTR;
     f_st->flex_mode = 0;
     f_st->hw_entry_count = hw_entry_count;

     return (BCM_E_NONE);
}

/*
 * Function:
 *    _bcm_field_th_stat_hw_mode_get
 *
 * Description:
 *      Get hw counter mode which will satisfy requested statistics set.
 * Parameters:
 *      unit     - (IN) BCM device number.
 *      f_st     - (IN) Field statistics entity.
 *      stage_id - (IN) Field stage id.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_th_stat_hw_mode_get(int unit, _field_stat_t *f_st,
                                  _field_stage_id_t stage_id)
{
    /* Input parameters check. */
    if (NULL == f_st) {
        return (BCM_E_PARAM);
    }

    /*
     * Tomahawk supports advanced flex counters
     * for both IFP and EM then get flex stat mode for this Stat.
     */
    if (soc_feature(unit, soc_feature_advanced_flex_counter)
        && ((_BCM_FIELD_STAGE_INGRESS == stage_id) ||
            (_BCM_FIELD_STAGE_EXACTMATCH == stage_id))) {
        return (_field_th_flex_mode_get(unit, f_st));
    }

    /* EFP still uses dedicated counter pools which can be used by only EFP.
     * Tomahawk VFP uses advance flex counters but no change when compred to
     * Trident2.
     */
    return _bcm_field_stat_hw_mode_get(unit, f_st, stage_id);
}

/*
 * Function:
 *    _bcm_field_th_group_counter_pbm_clear
 *
 * Description:
 *      Clear group counter pool bitmap based on used entries in
 *      in the pool.
 * Parameters:
 *      unit     - (IN) BCM device number.
 *      f_ent    - (IN) Field entry structure.
 *      pool_id  - (IN) Counter pool id.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_th_group_counter_pbm_clear(int unit,
                                      _field_entry_t *f_ent,
                                      uint32 pool_id)
{
    int rv; /* Operational Status. */
    uint32 num_pools; /* Counter pool count. */
    uint32 actual_num_pools; /* Actual Counter Pooll Count. */
    bcm_stat_flex_direction_t direction; /* Flex Stat Module object to indicate
                                          * Ingres/Egress Counter pools.
                                          */
    /* Flex Stat Object to carry counter pool info. */
    bcm_stat_flex_pool_stat_info_t pool_info[_FIELD_MAX_COUNTER_POOLS];

    _field_stage_t       *stage_fc;  /* pipeline stage  */
    int pipe_no = 0;

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, f_ent->group->stage_id,
                                                 &stage_fc));
    if(stage_fc->oper_mode == bcmFieldGroupOperModePipeLocal) {
        pipe_no = f_ent->group->instance;
    } else {
        pipe_no = 0;
    }

    /* Though Tomahawk supports 20 flex counter pools , as of now only 16 pools
     * are initialized and operating. Remain 4 pools are unused. num_pools has
     * to be set to 20 once the remaining 4 pools are supported.
     */
    num_pools = _FIELD_MAX_COUNTER_POOLS;
    direction = bcmStatFlexDirectionIngress;
    rv = _bcm_esw_stat_flex_pipe_pool_info_multi_get(unit,
                                                direction,
                                                pipe_no,
                                                num_pools,
                                                pool_info,
                                                &actual_num_pools);
    BCM_IF_ERROR_RETURN(rv);

    /*
     * Attached entries in any pool is zero means no Field entry has associated stat
     * in the cuurent Flex stat pool.
     * Used entries in any pool is zero means flex stat module disassociated
     * that pool from Field module and can be assigned to any other module.
     * So field group should also disassociate the pool from its in use counter
     * pool bitmap.
     */
    if (0 == pool_info[pool_id].attached_entries) {

        /* If the pool is in use for the group, disassocite it now. */
        if (_FP_COUNTER_POOL_BMP_TEST(
                            f_ent->group->counter_pool_bmp, pool_id)) {
            _FP_COUNTER_POOL_BMP_REMOVE(
                            f_ent->group->counter_pool_bmp, pool_id);
        }
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_flex_counter_free
 *
 * Purpose:
 *     Free flex counter resources used by field entry/entries.
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     f_ent    - (IN) Entry array policer belongs to.
 *     f_st     - (IN) Statistics entity.
 *     mem      - (IN) Policy Table name.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_flex_counter_free(int unit,
                                _field_entry_t *f_ent,
                                _field_stat_t *f_st, soc_mem_t mem)
{
    int              rv; /* Operational status. */
    int              entry_idx; /* Entry index in a slice. */
    _field_control_t *fc; /* Field Control Structure. */
    _field_stage_t   *stage_fc; /* Field Stage structure.*/
    _field_entry_stat_t  *f_ent_st;  /* Field entry statistics structure. */

    if (NULL == f_ent || NULL == f_st || INVALIDm == mem) {
        return BCM_E_PARAM;
    }

    f_ent_st = &f_ent->statistic;

    /* Get pipeline stage information. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit,
                                  f_ent->group->stage_id,
                                  &stage_fc
                                  )
        );

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));


    /* Detach flex stat only if it has been created. */
    if (f_st->flex_mode != 0) {
        /*
         * Get entry index at which flex STAT information
         * has been programmed in policy table.
         */
        if (_FP_ENTRY_STAT_INSTALLED ==
           (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED)) {
            BCM_IF_ERROR_RETURN
                (_bcm_field_slice_offset_to_tcam_idx(unit,
                                                 stage_fc,
                                                 f_ent->group->instance,
                                                 f_ent->fs->slice_number,
                                                 f_ent->slice_idx,
                                                 &entry_idx
                                                 ));

            /*
             * TH/TH2/TD3 (Intra Slice) Double Wide/ Triple wide modes,
             * IFP_TCAM_WIDE have 256 entries but IFP_POLICY_TABLE will have 512 entries.
             * In TH3, IFP_POLICY_TABLE_WIDE mode is used for TCAM Wide modes and
             * entries are 1:1 mapped.
             */
            if ((SOC_IS_TOMAHAWKX(unit) && !(SOC_IS_TOMAHAWK3(unit)) &&
                (f_ent->fs->stage_id == _BCM_FIELD_STAGE_INGRESS) &&
                (!(f_ent->group->flags & _FP_GROUP_SPAN_SINGLE_SLICE)
                || (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)))) {
                entry_idx = entry_idx + (f_ent->fs->slice_number * 256);
            }

            /* Disassociate flex counters from the IFP policy table entry
             * they are attached to. Once detached, the flex counters are
             * no longer updated even if matching traffic
             * hits the corresponding IFP policy table entry.
             */
            rv = _bcm_esw_stat_flex_detach_ingress_table_counters
                    (unit,
                     mem,
                     entry_idx
                     );
            /*
             * Flex STATs module initialized before field module, ignore
             * error during bcm_field_detach().
             */
            if (BCM_FAILURE(rv) && (TRUE == fc->init)) {
                return (rv);
            }
        }

        if (!(f_st->hw_flags & _FP_STAT_CREATED_BY_FLEX_MODULE)) {
          /*
           * Release counter resources and perform associated cleanup in flex
           * stat module. This function must be called, once the associated
           * statistics collection function is no longer needed and the
           * reserved counter resources can be freed for use by other
           * applications. Once this function is called, the counters
           * associated with the given stat counter id are no longer
           * available for any further stat collection.
           */
           rv = bcm_esw_stat_group_destroy(unit, f_st->flex_mode);

          /*
           * Flex STATs module initialized before field module, ignore
           * error during bcm_field_detach().
           * Ignore:BCM_E_INTERNAL(as multiple stat entries use same SingleMode
           */
           if (rv == BCM_E_INTERNAL) {
              /* Doesn't look appropriate error code but */
              rv = BCM_E_NONE;
           }
           if (BCM_FAILURE(rv) && (TRUE == fc->init)) {
              return (rv);
           }
        }

        /* Check and if required disassociate counter pools from the group. */
        rv = _bcm_field_th_group_counter_pbm_clear(unit, f_ent,
                                                   f_st->pool_index);
        BCM_IF_ERROR_RETURN(rv);

        /* decrement the group's counter count equal to
           the hw counters used for this stat */
        f_ent->group->group_status.counter_count =
             f_ent->group->group_status.counter_count - f_st->hw_entry_count;

        /* Reset the field stat attributes. */
        f_st->hw_index   = _FP_INVALID_INDEX;
        f_st->pool_index = _FP_INVALID_INDEX;
        f_st->hw_entry_count = 0;
        f_st->flex_mode = 0;
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *  _bcm_field_th_em_flex_counter_free
 * Purpose:
 *  Free flex counter resources used by em field entry/entries.
 * Parameters:
 *  unit     - (IN) BCM device number.
 *  f_ent    - (IN) Entry array policer belongs to.
 *  f_st     - (IN) Statistics entity.
 *  mem      - (IN) Policy Table name.
 * Returns:
 *  BCM_E_XXX
 */
int
_bcm_field_th_em_flex_counter_free(int unit,
                                   _field_entry_t *f_ent,
                                   _field_stat_t *f_st, soc_mem_t mem)
{
    int              rv; /* Operational status. */
    _field_control_t *fc; /* Field Control Structure. */
    _field_stage_t   *stage_fc; /* Field Stage structure.*/
    _field_entry_stat_t  *f_ent_st;  /* Field entry statistics structure. */

    if (NULL == f_ent || NULL == f_st || INVALIDm == mem) {
        return BCM_E_PARAM;
    }

    f_ent_st = &f_ent->statistic;

    /* Get pipeline stage information. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit,
                                  f_ent->group->stage_id,
                                  &stage_fc));

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Detach flex stat only if it has been created. */
    if (f_st->flex_mode != 0) {
        if (_FP_ENTRY_STAT_INSTALLED ==
           (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED)) {
            rv = _bcm_esw_stat_flex_detach_ingress_table_counters_sw(unit,
                           mem, 0, f_st->hw_mode, f_st->hw_index,
                           f_st->pool_index);
            /*
             * Flex STATs module initialized before field module, ignore
             * error during bcm_field_detach().
             */
            if (BCM_FAILURE(rv) && (TRUE == fc->init)) {
                return (rv);
            }
        }

        if (!(f_st->hw_flags & _FP_STAT_CREATED_BY_FLEX_MODULE)) {
            /*
             * Release counter resources and perform associated cleanup in flex
             * stat module. This function must be called, once the associated
             * statistics collection function is no longer needed and the reserved
             * counter resources can be freed for use by other applications. Once
             * this function is called, the counters associated with the given stat
             * counter id are no longer available for any further stat collection.
             */
            rv = bcm_esw_stat_group_destroy(unit, f_st->flex_mode);

            /*
             * Flex STATs module initialized before field module, ignore
             * error during bcm_field_detach().
             * Ignore:BCM_E_INTERNAL (as multiple stat entries use same SingleMode
             */
            if (rv == BCM_E_INTERNAL) {
                /* Doesn't look appropriate error code but */
                rv = BCM_E_NONE;
            }
            if (BCM_FAILURE(rv) && (TRUE == fc->init)) {
                return (rv);
            }
        }

        /* Check and if required disassociate counter pools from the group. */
        rv = _bcm_field_th_group_counter_pbm_clear(unit, f_ent,
                                                   f_st->pool_index);
        BCM_IF_ERROR_RETURN(rv);

        /* decrement the group's counter count equal to
           the hw counters used for this stat */
        f_ent->group->group_status.counter_count =
             f_ent->group->group_status.counter_count - f_st->hw_entry_count;

        /* Reset the field stat attributes. */
        f_st->hw_index   = _FP_INVALID_INDEX;
        f_st->pool_index = _FP_INVALID_INDEX;
        f_st->hw_entry_count = 0;
        f_st->flex_mode = 0;
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_th_stat_hw_free
 *
 * Purpose:
 *     Deallocate hw counter from an entry for IFP and VFP stages.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Entry statistics belongs to.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_stat_hw_free (int unit, _field_entry_t *f_ent)
{
    int                  rv;         /* Operation return status.          */
    int                  idx;        /* Statistics iteration index.       */
    int                  entry_idx;  /* Entry index at policy table       */
    soc_mem_t            tcam_mem;   /* Tcam Table Name.                  */
    soc_mem_t            policy_mem; /* Policy Table Name.                */
    _field_stat_t        *f_st;      /* Statistics entity descriptor.     */
    _field_stage_t       *stage_fc;  /* pipeline stage                    */
    _field_control_t     *fc;        /* Field Control Structure.          */
    _field_entry_stat_t  *f_ent_st;  /* Field entry statistics structure. */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    f_ent_st = &f_ent->statistic;
    /* Skip uninstalled statistics entity.*/
    if (0 == (f_ent_st->flags & _FP_ENTRY_STAT_VALID)) {
        return (BCM_E_NONE);
    }

    /* Get pipeline stage information. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit,
                                  f_ent->group->stage_id,
                                  &stage_fc
                                  )
        );

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Read stat entity configuration. */
    BCM_IF_ERROR_RETURN(_bcm_field_stat_get(unit, f_ent_st->sid, &f_st));

    BCM_IF_ERROR_RETURN(_bcm_field_th_tcam_policy_mem_get(unit, f_ent,
                                                      &tcam_mem, &policy_mem));

    if (_FP_ENTRY_STAT_INSTALLED ==
           (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED)) {
        /* Decrement hw reference count. */
        if (f_st->hw_ref_count > 0) {
            f_st->hw_ref_count--;
            if (f_st->flex_mode != 0 && f_st->hw_ref_count > 0) {
                /*
                 * Get entry index at which flex STAT information
                 * has been programmed in policy table.
                 */
                BCM_IF_ERROR_RETURN
                    (_bcm_field_slice_offset_to_tcam_idx(unit,
                                                 stage_fc,
                                                 f_ent->group->instance,
                                                 f_ent->fs->slice_number,
                                                 f_ent->slice_idx,
                                                 &entry_idx
                                                 ));

               /*
                * TH/TH2/TD3 (Intra Slice) Double Wide/ Triple wide modes,
                * IFP_TCAM_WIDE have 256 entries but IFP_POLICY_TABLE will have 512 entries.
                * In TH3, IFP_POLICY_TABLE_WIDE mode is used for TCAM Wide modes and
                * entries are 1:1 mapped.
                */
               if ((SOC_IS_TOMAHAWKX(unit) && (!SOC_IS_TOMAHAWK3(unit)) &&
                   (f_ent->fs->stage_id == _BCM_FIELD_STAGE_INGRESS) &&
                   (!(f_ent->group->flags & _FP_GROUP_SPAN_SINGLE_SLICE)
                   || (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE))
                   )) {
                   entry_idx = entry_idx + (f_ent->fs->slice_number * 256);
               }

               /* Disassociate flex counters from the IFP policy table entry
                * they are attached to. Once detached, the flex counters are
                * no longer updated even if matching traffic hits
                *  the corresponding IFP policy table entry.
                */
                rv = _bcm_esw_stat_flex_detach_ingress_table_counters
                        (unit,
                         policy_mem,
                         entry_idx
                         );
                /*
                 * Flex STAT module detached before field module, ignore
                 * error during bcm_field_detach().
                 */
                if (BCM_FAILURE(rv) && (TRUE == fc->init)) {
                    return (rv);
                }
            }
        }
    }

    /* Statistics is not used by any other entry. */
    if (f_st->hw_ref_count == 0) {
        /*
         * Retrieve the stat values only during run time.
         * It doesn't need to be maintained during field init/detach.
         */
        if (_FP_ENTRY_STAT_INSTALLED ==
                 (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED)) {
            if (fc->init == TRUE) {
                /* Read & Reset  individual statistics. */
                for (idx = 0; idx < f_st->nstat; idx++) {
                    rv = _field_stat_value_get(unit, 0, f_st,
                                             f_st->stat_arr[idx],
                                             f_st->stat_values + idx);
                    if (BCM_FAILURE(rv)) {
                        /* During system restart flex stat module
                         * might be reinitialized before fp reinit. Hence
                         * calls to the flex stat module will result in
                         * BCM_E_NOT_FOUND * error code.
                         */
                        if (0 == (((_BCM_FIELD_STAGE_INGRESS ==
                                  f_st->stage_id) ||
                                  (_BCM_FIELD_STAGE_LOOKUP == f_st->stage_id))
                                  && (BCM_E_NOT_FOUND == rv))) {
                            return rv;
                        }
                    }
                }
            }
        }

        /* Mark hw resource as unused in sw. */
        rv = _bcm_field_th_flex_counter_free(unit, f_ent, f_st, policy_mem);
        BCM_IF_ERROR_RETURN(rv);
    }

    /*
     * If qualifiers have not been modified for this entry,
     * set Action only dirty flag.
     */
    if (_FP_ENTRY_STAT_INSTALLED ==
         (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED)) {
        if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
            f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
        }

        f_ent_st->flags &= ~_FP_ENTRY_STAT_INSTALLED;

        /* Mark entry for reinstall. */
        f_ent->flags |= _FP_ENTRY_DIRTY;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *  _field_th_em_stat_hw_free
 * Purpose:
 *  Deallocate hw counter from an entry for exact match stage.
 * Parameters:
 *  unit      - (IN) BCM device number.
 *  f_ent     - (IN) Entry statistics belongs to.
 * Returns:
 *  BCM_E_XXX
 */
STATIC int
_field_th_em_stat_hw_free (int unit, _field_entry_t *f_ent)
{
    int                  rv;         /* Operation return status.          */
    int                  idx;        /* Statistics iteration index.       */
    soc_mem_t            tcam_mem;   /* Tcam Table Name.                  */
    soc_mem_t            policy_mem; /* Policy Table Name.                */
    _field_stat_t        *f_st;      /* Statistics entity descriptor.     */
    _field_stage_t       *stage_fc;  /* pipeline stage                    */
    _field_control_t     *fc;        /* Field Control Structure.          */
    _field_entry_stat_t  *f_ent_st;  /* Field entry statistics structure. */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    f_ent_st = &f_ent->statistic;
    /* Skip uninstalled statistics entity. */
    if (0 == (f_ent_st->flags & _FP_ENTRY_STAT_VALID)) {
        return (BCM_E_NONE);
    }

    /* Get pipeline stage information. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit,
                                  f_ent->group->stage_id,
                                  &stage_fc));

    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Read stat entity configuration. */
    BCM_IF_ERROR_RETURN(_bcm_field_stat_get(unit, f_ent_st->sid, &f_st));

    BCM_IF_ERROR_RETURN(_bcm_field_th_tcam_policy_mem_get(unit, f_ent,
                                                &tcam_mem, &policy_mem));
    if (_FP_ENTRY_STAT_INSTALLED ==
               (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED)) {
        /* Decrement hw reference count. */
        if (f_st->hw_ref_count > 0) {
            f_st->hw_ref_count--;
            if (f_st->flex_mode != 0 && f_st->hw_ref_count > 0) {

                /* Disassociate flex counters from the EM table entry
                 * they are attached to. Once detached, the flex counters are
                 * no longer updated even if matching traffic
                 *  hits the corresponding EM table entry.
                 */
                rv = _bcm_esw_stat_flex_detach_ingress_table_counters_sw(unit,
                            policy_mem, 0,
                            f_st->hw_mode, f_st->hw_index, f_st->pool_index);
                /*
                 * Flex STAT module detached before field module, ignore
                 * error during bcm_field_detach().
                 */
                if (BCM_FAILURE(rv) && (TRUE == fc->init)) {
                    return (rv);
                }
            }
        }
    }
    /* Statistics is not used by any other entry. */
    if (f_st->hw_ref_count == 0) {
        /*
         * Retrieve the stat values only during run time.
         * It doesn't need to be maintained during field init/detach.
         */
        if (_FP_ENTRY_STAT_INSTALLED ==
                 (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED)) {
            if (fc->init == TRUE) {
                for (idx = 0; idx < f_st->nstat; idx++) {
                    rv = _field_stat_value_get(unit, 0, f_st,
                            f_st->stat_arr[idx],
                            f_st->stat_values + idx);
                    if (BCM_FAILURE(rv)) {
                        /* During system restart flex stat module
                         * might be reinitialized before fp reinit. Hence
                         * calls to the flex stat module will result in
                         * BCM_E_NOT_FOUND * error code.
                         */
                        if (0 == (((_BCM_FIELD_STAGE_INGRESS ==
                                   f_st->stage_id) ||
                                   (_BCM_FIELD_STAGE_EXACTMATCH ==
                                   f_st->stage_id) ||
                                   (_BCM_FIELD_STAGE_LOOKUP ==
                                   f_st->stage_id))
                                   && (BCM_E_NOT_FOUND == rv))) {
                            return rv;
                        }
                    }
                }
            }
        }

        /* Mark hw resource as unused in sw. */
        rv = _bcm_field_th_em_flex_counter_free(unit, f_ent, f_st, policy_mem);
        BCM_IF_ERROR_RETURN(rv);
    }

    /*
     * If qualifiers have not been modified for this entry,
     * set Action only dirty flag.
     */
    if (_FP_ENTRY_STAT_INSTALLED ==
         (f_ent_st->flags & _FP_ENTRY_STAT_INSTALLED)) {
        if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
            f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
        }

        f_ent_st->flags &= ~_FP_ENTRY_STAT_INSTALLED;

        /* Mark entry for reinstall. */
        f_ent->flags |= _FP_ENTRY_DIRTY;
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_stat_hw_free
 *
 * Purpose:
 *     Deallocate hw counter from an entry.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Entry statistics belongs to.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_stat_hw_free(int unit, _field_entry_t *f_ent)
{
    int rv = BCM_E_INTERNAL; /* Operational Status. */

    if (NULL == f_ent) {
        return BCM_E_PARAM;
    }

    switch (f_ent->fs->stage_id) {
       case _BCM_FIELD_STAGE_INGRESS:
         if (soc_feature(unit, soc_feature_ifp_action_profiling)) {
             rv = _field_th_em_stat_hw_free(unit, f_ent);
         } else {
             rv = _field_th_stat_hw_free(unit, f_ent);
         }
         break;
       case _BCM_FIELD_STAGE_LOOKUP:
         rv = _field_th_stat_hw_free(unit, f_ent);
         break;
       case _BCM_FIELD_STAGE_EXACTMATCH:
         rv = _field_th_em_stat_hw_free(unit, f_ent);
         break;
       case _BCM_FIELD_STAGE_EGRESS:
#if defined BCM_TRIDENT3_SUPPORT
         if (soc_feature(unit, soc_feature_td3_style_fp)) {
            rv = _bcm_field_td2plus_stat_hw_free(unit, f_ent);
         } else
#endif /* BCM_TRIDENT3_SUPPORT */
         {
            rv = _bcm_field_stat_hw_free(unit, f_ent);
         }
         break;
       default:
         rv = _bcm_field_stat_hw_free(unit, f_ent);
         break;
    }
    return rv;
}
/*
 * Function:
 *     _bcm_field_stat_array_get
 *
 * Purpose:
 *     Get field stat types array from flex stat attribute array.
 *
 * Parameters:
 *     unit        - (IN) BCM device number.
 *     nattr       - (IN) Number of attributes.
 *     stat_attr   - (IN) Flex stat attribute array.
 *     nstat       - (OUT) Number of field stat types.
 *     stata_arr   - (OUT) Field stat array.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_stat_array_get(int unit,
                          uint32 nattr,
                          bcm_stat_group_mode_attr_selector_t *stat_attr,
                          int *nstat, bcm_field_stat_t *stat_arr)
{
     int idx = 0; /* Index Variable. */
     int packets = -1;  /* Al coloreed packets. */
     int bytes = -1;    /* All colored bytes. */
     int g_packets = -1; /* Green Packets. */
     int y_packets = -1; /* Yellow Packets. */
     int r_packets = -1; /* Red Packets. */
     int g_bytes = -1; /* Green Bytes. */
     int y_bytes = -1; /* Yellow Bytes. */
     int r_bytes = -1; /* Red Bytes. */
     int ng_packets = -1; /* Not Green Packets. */
     int ny_packets = -1; /* Not Yellow Packets. */
     int nr_packets = -1; /* Not Red Packets. */
     int ng_bytes = -1; /* Not Green Bytes. */
     int ny_bytes = -1; /* Not Yellow Bytes. */
     int nr_bytes = -1; /* Not Red Bytes. */
     int g_offset = -1; /* Green counter offset. */
     int y_offset = -1; /* Yellow Counter Offset. */
     int r_offset = -1; /* Red Counter Offset. */
     int color = 0; /* Bitmap of G, Y and R colors. */
     int g_present = 0; /* Green Packets Present. */
     int y_present = 0; /* Yellow Packets Present. */
     int r_present = 0; /* Red Packets Present. */

     /* Parameters Check. */

     /* Max number of attributes for any flex stat Id should not excced 3, as
      * the max counters attached to an ifp entry doesnot exceed 3.
      */
     if (nattr <= 0 || nattr > 3) {
         return BCM_E_PARAM;
     }

     if (NULL == nstat || NULL == stat_attr || NULL == stat_arr) {
         return BCM_E_PARAM;
     }

     *nstat = 0;

     /* Get the flex stat Colors and flex stat counters offsets.  */
     for (idx = 0; idx < nattr; idx++) {
         if (NULL != (stat_attr + idx)) {
             if (bcmColorGreen == (stat_attr + idx)->attr_value) {
                 g_present = 1;
                 g_offset = (stat_attr + idx)->counter_offset;
             } else if (bcmColorYellow == (stat_attr + idx)->attr_value) {
                 y_present = 1;
                 y_offset = (stat_attr + idx)->counter_offset;
             } else if (bcmColorRed == (stat_attr + idx)->attr_value) {
                 r_present = 1;
                 r_offset = (stat_attr + idx)->counter_offset;
             }
         }
     }

     color = (r_present << 2) | (y_present << 1) | g_present;

     switch (color) {
         case 1:
             /* If flex Stat has bcmColorGreen, then include Green Packets and
              * Green Bytes into field stat types.
              */
             if (-1 != g_offset) {
                 g_packets = 1;
                 g_bytes = 1;
                 *nstat = 2;
             } else {
                 return BCM_E_INTERNAL;
             }
             break;
         case 2:
             /* If flex Stat has bcmColorYellow, then include Yellow Packets and
              * Yellow Bytes into field stat types.
              */
             if (-1 != y_offset) {
                 y_packets = 1;
                 y_bytes = 1;
                 *nstat = 2;
             } else {
                 return BCM_E_INTERNAL;
             }
             break;
         case 3:
             /* flex stat has both bcmColorGreen and bcmColorYellow. */
             if (-1 != g_offset && -1 != y_offset) {
                 /* If flex stat has both bcmColorGreen and bcmColorYellow,
                  * and corrsponding counter offsets are same include
                  * NotRedPackets and NotRedBytes into field stat types.
                  */
                 if (g_offset == y_offset) {
                     nr_packets = 1;
                     nr_bytes = 1;
                     *nstat = 2;
                 } else {
                     /* If flex stat has both bcmColorGreen and bcmColorYellow,
                      * and corrsponding counter offsets are not same include
                      * GreenPackets, GreenBytes, YellowPackets and YellowBytes
                      * into field stat types.
                      */
                     g_packets = 1;
                     g_bytes = 1;
                     y_packets = 1;
                     y_bytes = 1;
                     *nstat = 4;
                 }
             } else {
                 return BCM_E_INTERNAL;
             }
             break;
         case 4:
             /* If flex Stat has bcmColorYellow, then include Yellow Packets and
              * Yellow Bytes into field stat types.
              */
             if (-1 != r_offset) {
                 r_packets = 1;
                 r_bytes = 1;
                 *nstat = 2;
             } else {
                 return BCM_E_INTERNAL;
             }
             break;
         case 5:
             /* flex stat has both bcmColorGreen and bcmColorRed. */
             if (-1 != g_offset && -1 != r_offset) {
                 if (g_offset == r_offset) {
                     /* If flex stat has both bcmColorGreen and bcmColorRed,
                      * and corrsponding counter offsets are same include
                      * NotYellowPackets and NotYellowBytes into field stat
                      * types.
                      */
                     ny_packets = 1;
                     ny_bytes = 1;
                     *nstat = 2;
                 } else {
                     /* If flex stat has both bcmColorGreen and bcmColorRed,
                      * and corrsponding counter offsets are not same include
                      * GreenPackets, GreenBytes, RedPackets and RedBytes
                      * into field stat types.
                      */
                     g_packets = 1;
                     g_bytes = 1;
                     r_packets = 1;
                     r_bytes = 1;
                     *nstat = 4;
                 }
             } else {
                 return BCM_E_INTERNAL;
             }
             break;
         case 6:
             /* flex stat has both bcmColorYellow and bcmColorRed. */
             if (-1 != r_offset && -1 != y_offset) {
                 if (r_offset == y_offset) {
                     /* If flex stat has both bcmColorYellow and bcmColorRed,
                      * and corrsponding counter offsets are same include
                      * NotGreenPackets and NotGreenBytes into field stat
                      * types.
                      */
                     ng_packets = 1;
                     ng_bytes = 1;
                     *nstat = 2;
                 } else {
                     /* If flex stat has both bcmColorGreen and bcmColorRed,
                      * and corrsponding counter offsets are not same include
                      * YellowPackets, YellowBytes, RedPackets and RedBytes
                      * into field stat types.
                      */
                     r_packets = 1;
                     r_bytes = 1;
                     y_packets = 1;
                     y_bytes = 1;
                     *nstat = 4;
                 }
             } else {
                 return BCM_E_INTERNAL;
             }
             break;
         case 7:
             /* flex stat has ColorGreen , ColorYellow and ColorRed. */
             if (-1 != g_offset && -1 != y_offset && -1 != r_offset) {
                 if (g_offset == y_offset && g_offset == r_offset) {
                     /* Flex stat has bcmColorGreen ,bcmColorYellow and
                      * bcmColorRed, and corrsponding counter offsets are same
                      * include Packets and Bytes into field stat
                      * types.
                      */
                     packets = 1;
                     bytes = 1;
                     *nstat = 2;
                 } else if (g_offset == y_offset && g_offset != r_offset) {
                     /* Flex stat has bcmColorGreen ,bcmColorYellow and
                      * bcmColorRed. Green and Yellow counter offsets are same
                      * but have different red counter offset then include
                      * NotRedPackets, NotRedBytes, RedPackets and RedBytes into
                      * field stat types.
                      */
                     nr_packets = 1;
                     nr_bytes = 1;
                     r_packets = 1;
                     r_bytes = 1;
                     *nstat = 4;
                 } else if (g_offset != y_offset && g_offset == r_offset) {
                     /* Flex stat has bcmColorGreen ,bcmColorYellow and
                      * bcmColorRed. Green and Red counter offsets are same
                      * but have different Yellow counter offset then include
                      * NotYellowPackets, NotYellowBytes, YellowPackets and
                      * YellowBytes into field stat types.
                      */
                     ny_packets = 1;
                     ny_bytes = 1;
                     y_packets = 1;
                     y_bytes = 1;
                     *nstat = 4;
                 } else if(r_offset == y_offset && g_offset != r_offset) {
                     /* Flex stat has bcmColorGreen ,bcmColorYellow and
                      * bcmColorRed. Yellow and Red counter offsets are same
                      * but have different Green counter offset then include
                      * NotGreenPackets, NotGreenBytes, GreenPackets and
                      * GreenBytes into field stat types.
                      */
                     ng_packets = 1;
                     ng_bytes = 1;
                     g_packets = 1;
                     g_bytes = 1;
                     *nstat = 4;
                 } else if (r_offset != y_offset && g_offset != r_offset &&
                            y_offset != g_offset) {
                     /* Flex stat has bcmColorGreen ,bcmColorYellow and
                      * bcmColorRed and corrsponding counter offsets are
                      * different then include GreenPackets, GreenBytes,
                      * YellowPackets, YellowBytes , NotGreenPackets,
                      * NotGreenBytes, NotYellowPackets, NotYellowBYtes,
                      * NoteRedPackets, NotRedBytes, Packets and Bytes into
                      * field stat types.
                      */
                     g_packets = 1;
                     g_bytes = 1;
                     y_packets = 1;
                     y_bytes = 1;
                     r_packets = 1;
                     r_bytes = 1;
                     ng_packets = 1;
                     ng_bytes = 1;
                     ny_packets = 1;
                     ny_bytes = 1;
                     nr_packets = 1;
                     nr_bytes = 1;
                     packets = 1;
                     bytes = 1;
                     *nstat = 14;
                 }
             } else {
                 return BCM_E_INTERNAL;
             }
             break;
         default:
             return BCM_E_INTERNAL;
     }

     /* Number field stat types cannot exceed 14 */
     if (*nstat > 14) {
         return BCM_E_INTERNAL;
     }

     /* Update the field stat types belongs given flex stat attributes. */
     idx = 0;
     if (-1 != g_packets) {
         *(stat_arr+ idx) = bcmFieldStatGreenPackets;
         idx++;
     }

     if (-1 != y_packets) {
         *(stat_arr+ idx) = bcmFieldStatYellowPackets;
         idx++;
     }

     if (-1 != r_packets) {
         *(stat_arr+ idx) = bcmFieldStatRedPackets;
         idx++;
     }

     if (-1 != g_bytes) {
         *(stat_arr+ idx) = bcmFieldStatGreenBytes;
         idx++;
     }

     if (-1 != y_bytes) {
         *(stat_arr+ idx) = bcmFieldStatYellowBytes;
         idx++;
     }

     if (-1 != r_bytes) {
         *(stat_arr+ idx) = bcmFieldStatRedBytes;
         idx++;
     }

     if (-1 != ng_packets) {
         *(stat_arr+ idx) = bcmFieldStatNotGreenPackets;
         idx++;
     }

     if (-1 != ny_packets) {
         *(stat_arr+ idx) = bcmFieldStatNotYellowPackets;
         idx++;
     }

     if (-1 != nr_packets) {
         *(stat_arr+ idx) = bcmFieldStatNotRedPackets;
         idx++;
     }

     if (-1 != ng_bytes) {
         *(stat_arr+ idx) = bcmFieldStatNotGreenBytes;
         idx++;
     }

     if (-1 != ny_bytes) {
         *(stat_arr+ idx) = bcmFieldStatNotYellowBytes;
         idx++;
     }

     if (-1 != nr_bytes) {
         *(stat_arr+ idx) = bcmFieldStatNotRedBytes;
         idx++;
     }

     if (-1 != packets) {
         *(stat_arr+ idx) = bcmFieldStatPackets;
         idx++;
     }

     if (-1 != bytes) {
         *(stat_arr+ idx) = bcmFieldStatBytes;
         idx++;
     }

     return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_th_stat_attach
 *
 * Purpose:
 *     Attach flex counters created using flex stat API's to fie;ld group.
 *
 * Parameters:
 *     unit        - (IN) BCM device number.
 *     field_group - (IN) Field Group Id.
 *     flex_sid    - (IN) Flex stat Id created using flex stat API's.
 *     stat_id     - (OUT) Field stat id mapped to flex_sid.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_stat_attach(int unit,
                          bcm_field_group_t field_group,
                          uint32 flex_sid, uint32 *stat_id)
{
    int rv; /* Operational Status. */
    int nstat;  /* Number of stats attached to stat id. */
    int fp_stat_mode_max;  /* Max stat modes. */
    uint8  idx; /* Index variable to carry loop count. */
    uint32 pool_num;          /* Flex Stat Hw Pool No. */
    uint32 base_index;        /* Flex Stat counter base index. */
    uint32 num_hw_cntrs;      /* Number of counters allocated.   */
    uint32 req_bmap;          /* Requested statistics bitmap.    */
    uint32 hw_bmap;           /* HW supported statistics bitmap. */
    uint32 nattr;             /* Number of flex stat attribute types. */
    _field_stat_t *f_st;      /* Field statistics descriptor.   */
    bcm_field_stat_t stat_arr[14]; /* Allowable stat types to attach. */
    bcm_stat_group_mode_t   stat_mode;   /* Stat type bcmStatGroupModeXXX. */
    bcm_stat_object_t       stat_obj; /* Stat object type. */
    bcm_stat_flex_mode_t    offset_mode; /* Counter mode.     */
    bcm_stat_flex_direction_t direction; /* Ingress/Egress Flex Stats. */
    bcm_stat_group_mode_attr_selector_t stat_attr[8192]; /* Flex stat attrs. */


    /* Null parameter Check */
    if (NULL == stat_id) {
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_stat_id_validate(unit, flex_sid));

    /* Get flex counter hardware details stored in flex stat ID.*/
    _bcm_esw_stat_get_counter_id_info(unit,
                                      flex_sid,
                                      &stat_mode,
                                      &stat_obj,
                                      &offset_mode,
                                      &pool_num,
                                      &base_index);

    /* Validate the stat object is in range. */
    BCM_IF_ERROR_RETURN(_bcm_esw_stat_validate_object(unit,
                                                      stat_obj, &direction));
    /* Validate the stat mode. */
    BCM_IF_ERROR_RETURN(_bcm_esw_stat_validate_group(unit, stat_mode));

    /* Validate stat object. */
    if ((bcmStatObjectIngFieldStageIngress != stat_obj) &&
        (bcmStatObjectIngFieldStageLookup != stat_obj) &&
        (bcmStatObjectIngExactMatch != stat_obj)) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META_U(unit,
              "Retrieved object need to be bcmStatObjectFieldStageIngress or"
              " bcmStatObjectIngFieldStageLookup or"
              " bcmStatObjectIngExactMatch\n\r")));
        return BCM_E_PARAM;
    }

    if ((bcmStatObjectIngFieldStageIngress == stat_obj) ||
        (bcmStatObjectIngExactMatch == stat_obj)){
       /* Get flex stat attributes array for the given flex stat Id. */
       rv = _bcm_flex_ctr_field_stat_types_get(unit, flex_sid,
                                               stat_attr, &nattr);
       BCM_IF_ERROR_RETURN(rv);

       sal_memset(stat_arr, 0, sizeof(stat_arr));

       if ((bcmStatGroupModeAttrFieldIngressColor == stat_attr->attr)
            || (bcmStatGroupModeAttrColor == stat_attr->attr)) {
           /* Get the Field Color stat types based on the Flex Ctr attributes */
           rv = _bcm_field_stat_array_get(unit, nattr, stat_attr, &nstat, stat_arr);
           BCM_IF_ERROR_RETURN(rv);
       } else {
           /* No need of color attributes. Use all colors */
           nstat = 2;
           stat_arr[0] = bcmFieldStatBytes;
           stat_arr[1] = bcmFieldStatPackets;
       }
    } else {
       nstat = 2;
       stat_arr[0] = bcmFieldStatBytes;
       stat_arr[1] = bcmFieldStatPackets;
    }

    FP_LOCK(unit);

    /* Create field stat corrsponding to flext stat id. */
    rv = bcm_esw_field_stat_create(unit, field_group, nstat,
                                   stat_arr, (int *)stat_id);

    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Get the newly created stat operational structure. */
    rv = _bcm_field_stat_get(unit, *stat_id, &f_st);
    if(BCM_FAILURE(rv)) {
       FP_UNLOCK(unit);
       bcm_esw_field_stat_destroy(unit,*stat_id);
       return rv;
    }

    if ((bcmStatObjectIngFieldStageIngress == stat_obj) ||
        (bcmStatObjectIngExactMatch == stat_obj)){
       /* Get application requested bitmap. */
       BCM_IF_ERROR_RETURN
           (_bcm_field_stat_array_to_bmap(unit, f_st, &req_bmap));

       fp_stat_mode_max = COUNTOF(th_ingress_cntr_hw_mode_tbl);

       for (idx = 0; idx < fp_stat_mode_max; idx++) {
          hw_bmap = th_ingress_cntr_hw_mode_tbl[idx].hw_bmap;
          num_hw_cntrs = th_ingress_cntr_hw_mode_tbl[idx].hw_entry_count;

          if (0 == ((req_bmap | hw_bmap) & ~(hw_bmap))) {
             /*
              * For maximizing utilization of hardware counters, this should
              * select the hw_mode both supports the requested stats
              * AND minimizes the number of required hardware counters.
              */
              break;
          }
       }
    } else {
       num_hw_cntrs = 1;
    }

    /* Update the flex mode with flex stat id so that during entry installs
     * h/w resources will not be allocated again. Also update the other
     * Stat attributes.
     */
    f_st->flex_mode = flex_sid;
    f_st->pool_index = pool_num;
    f_st->hw_index = base_index;
    f_st->hw_mode = offset_mode;
    f_st->hw_entry_count = num_hw_cntrs;
    f_st->hw_flags |= _FP_STAT_CREATED_BY_FLEX_MODULE;
    FP_UNLOCK(unit);

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_group_flex_ctr_info_get
 * Purpose:
 *     To get the miscellaenous information about field group.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     group     - (IN) Field groups Id.
 *     instance  - (OUT) Pipe to which Field groupd belongs to.
 *     counter_pool_bmp - (OUT) Bitmap of flex Counter pools in which
 *                              counters are allocated for field group.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_group_flex_ctr_info_get(int unit,
                               bcm_field_group_t group, int *instance,
                               _field_counter_pool_bmp_t *counter_pool_bmp)
{
    int rv;                           /* Operation Status.             */
    _field_group_t *fg = NULL;        /* Group Operational Structure.  */
    bcm_field_group_oper_mode_t mode; /* Stage Group operational mode. */
    bcm_field_qualify_t stage;

    if (NULL == instance || NULL == counter_pool_bmp) {
        return BCM_E_PARAM;
    }

    /* Get the group operational structure. */
    BCM_IF_ERROR_RETURN(_field_group_get(unit, group, &fg));


    if (fg->stage_id == _BCM_FIELD_STAGE_INGRESS) {
        stage = bcmFieldQualifyStageIngress;
    } else if (fg->stage_id == _BCM_FIELD_STAGE_LOOKUP) {
        stage = bcmFieldQualifyStageLookup;
    } else if (fg->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        stage = bcmFieldQualifyStageIngressExactMatch;
    }
#if defined(BCM_TRIDENT3_SUPPORT)
    else if (soc_feature(unit, soc_feature_td3_style_fp) &&
            (fg->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
        stage = bcmFieldQualifyStageEgress;
    }
#endif
    else {
        return (BCM_E_PARAM);
    }

    /* Get the field stage's group operational mode. */
    rv = _bcm_field_th_group_oper_mode_get(unit, stage, &mode);
    BCM_IF_ERROR_RETURN(rv);

    if (bcmFieldGroupOperModePipeLocal == mode) {
        /* Group instance holds pipe to which this group belongs to. */
        *instance = fg->instance;
    } else if (bcmFieldGroupOperModeGlobal == mode) {
        /* In global mode group instance is set to _FP_DEF_INST(= 0), So to
         * dis ambiguate from pipe 0 in PipeLocal mode, instance is given back
         * as -1.
         */
        *instance = _FP_GLOBAL_INST;
    } else {
        /* No other mode are supported. */
        return BCM_E_INTERNAL;
    }

    /* Copy counter pool bitmap from group operational structure. */
    sal_memcpy(counter_pool_bmp, &fg->counter_pool_bmp,
                    sizeof(_field_counter_pool_bmp_t));

    return BCM_E_NONE;
}
/*
 * Function:
 *     _bcm_field_group_flex_ctr_pool_bmp_update
 * Purpose:
 *     Update the counter pool bitmap of field group.
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     group     - (IN) Field groups Id.
 *     pool_number - (IN) Flex counter pool number.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_group_flex_ctr_pool_bmp_update(int unit,
                                         bcm_field_group_t group,
                                         int pool_number)
{
    _field_group_t *fg = NULL; /* Group Operational Structure.  */

    /* Get the group operational structure. */
    BCM_IF_ERROR_RETURN(_field_group_get(unit, group, &fg));

    /*Update the group's flex counter pool bitmap. */
    _FP_COUNTER_POOL_BMP_ADD(fg->counter_pool_bmp, pool_number);

    return BCM_E_NONE;
}

/*
 * Function:
 *  _bcm_field_th_em_color_offset_get
 * Purpose:
 *  Get Color offsets for given field stat entry.
 * Parameters:
 *  unit           - (IN) BCM device number.
 *  f_st           - (IN) Field Stat Entry.
 *  green_offset   - (OUT) Green Color Offset.
 *  yellow_offset  - (OUT) Yellow Color Offset.
 *  red_offset     - (OUT) Red Color Offset.
 * Returns:
 *  BCM_E_XXX
 */
int
_bcm_field_th_em_color_offset_get(int unit, _field_stat_t *f_st,
                                           uint32 *green_offset,
                                          uint32 *yellow_offset,
                                             uint32 *red_offset)
{
    int rv = BCM_E_NONE;      /* Return Operational Status.      */
    uint32 req_bmap;          /* Requested statistics bitmap.    */
    uint8  idx;               /* HW counter modes iterator.      */
    uint32 hw_bmap;           /* HW supported statistics bitmap. */
    _field_stat_color_t  color;
                              /* Flex Stat Mode in s/w.          */
    int    fp_stat_mode_max;  /* Max stat modes.                 */

    /* Input Parameter Check. */
    if ((f_st == NULL) ||
        (green_offset == NULL) ||
        (yellow_offset == NULL) ||
        (red_offset == NULL)) {
        return (BCM_E_INTERNAL);
    }

    /* Get application requested bitmap. */
    BCM_IF_ERROR_RETURN
        (_bcm_field_stat_array_to_bmap(unit, f_st, &req_bmap));

    /* If bitmap is zero - no mode selection is required. */
    if (0 == req_bmap) {
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "FP(unit %d): No Valid stats.\n "), unit));
        return BCM_E_INTERNAL;
    }

    fp_stat_mode_max = COUNTOF(th_ingress_cntr_hw_mode_tbl);

    for (idx = 0; idx < fp_stat_mode_max; idx++) {
        hw_bmap = th_ingress_cntr_hw_mode_tbl[idx].hw_bmap;
        color = th_ingress_cntr_hw_mode_tbl[idx].color;

        if (0 == ((req_bmap | hw_bmap) & ~(hw_bmap))) {
            /*
             * For maximizing utilization of hardware counters, this should
             * select the hw_mode both supports the requested stats
             * AND minimizes the number of required hardware counters.
             */
            break;
        }
    }

    if (idx >= fp_stat_mode_max) {
        return (BCM_E_INTERNAL);
    }

    switch (color) {
        case _bcmFieldStatColorGreen:
            *green_offset = 1;
            *yellow_offset = 0;
            *red_offset = 0;
            break;
        case _bcmFieldStatColorYellow:
            *green_offset = 0;
            *yellow_offset = 1;
            *red_offset = 0;
            break;
        case _bcmFieldStatColorRed:
            *green_offset = 0;
            *yellow_offset = 0;
            *red_offset = 1;
            break;
        case _bcmFieldStatColorNotGreen:
            *green_offset = 0;
            *yellow_offset = 1;
            *red_offset = 1;
            break;
        case _bcmFieldStatColorNotYellow:
            *green_offset = 1;
            *yellow_offset = 0;
            *red_offset = 1;
            break;
        case _bcmFieldStatColorNotRed:
            *green_offset = 1;
            *yellow_offset = 1;
            *red_offset = 0;
            break;
        case _bcmFieldStatColorGreenYellow:
            *green_offset = 1;
            *yellow_offset = 2;
            *red_offset = 0;
            break;
        case _bcmFieldStatColorGreenRed:
            *green_offset = 1;
            *yellow_offset = 0;
            *red_offset = 2;
            break;
        case _bcmFieldStatColorYellowRed:
            *green_offset = 0;
            *yellow_offset = 1;
            *red_offset = 2;
            break;
        case _bcmFieldStatColorGreenNotGreen:
            *green_offset = 1;
            *yellow_offset = 2;
            *red_offset = 2;
            break;
        case _bcmFieldStatColorYellowNotYellow:
            *green_offset = 2;
            *yellow_offset = 1;
            *red_offset = 2;
            break;
        case _bcmFieldStatColorRedNotRed:
            *green_offset = 2;
            *yellow_offset = 2;
            *red_offset = 1;
            break;
        case _bcmFieldStatColorNoColor:
            *green_offset = 1;
            *yellow_offset = 1;
            *red_offset = 1;
            break;
        case _bcmFieldStatColorGreenYellowRed:
            *green_offset = 1;
            *yellow_offset = 2;
            *red_offset = 3;
            break;
        default:
            return (BCM_E_INTERNAL);
    }

    return (rv);
}
/*
 * Function:
 *  _bcm_field_th_flex_counter_info_get
 * Purpose:
 *  Get the free and total flex counters available for group.
 * Parameters:
 *  unit           - (IN) BCM device number.
 *  fg             - (IN) Field Group.
 *  counters_total - (OUT) Total Flex counters available for this group.
 *  counters_free  - (OUT) Free Flex counters available for this group.
 * Returns:
 *  BCM_E_XXX
 */
int
_bcm_field_th_flex_counter_status_get(int unit,
                                      _field_group_t *fg,
                                      int *counters_total,
                                      int *counters_free)
{
    int rv = BCM_E_NONE; /* Operational Status. */
    int pipe_no = 0;
    _field_stage_t  *stage_fc;  /* pipeline stage  */
    uint8 idx = 0; /* Index to iterate through flex counter pools. */
    uint32 num_pools = 0; /* Number of flex counter Pools. */
    bcm_stat_flex_pool_stat_info_t *flex_pool_info; /* Flex stat pool Info. */

    if (NULL == fg || NULL == counters_total || NULL == counters_free) {
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, fg->stage_id,
                           &stage_fc));
   if(stage_fc->oper_mode == bcmFieldGroupOperModePipeLocal) {
       pipe_no = fg->instance;
   } else {
       pipe_no = 0;
   }

    flex_pool_info = NULL;
    rv =_bcm_esw_stat_flex_pipe_pool_info_multi_get(unit,
                                               bcmStatFlexDirectionIngress,
                                               pipe_no, 0, flex_pool_info,
                                               &num_pools);
    BCM_IF_ERROR_RETURN(rv);

    /* Tomahawk has only 20 Ingress flex counter pools(from pool-0 - pool-19) */
    if (num_pools > 20) {
        return BCM_E_INTERNAL;
    }

    _FP_XGS3_ALLOC(flex_pool_info,
                   num_pools * sizeof(bcm_stat_flex_pool_stat_info_t),
                   "Ingress Flex Pool Information");

    if (NULL == flex_pool_info) {
        return BCM_E_MEMORY;
    }

    rv = _bcm_esw_stat_flex_pipe_pool_info_multi_get(unit,
                                                bcmStatFlexDirectionIngress,
                                                pipe_no, num_pools,
                                                flex_pool_info, &num_pools);
    if (BCM_FAILURE(rv)) {
        sal_free(flex_pool_info);
        return rv;
    }

    *counters_free = 0;
    *counters_total = 0;

    for (idx = 0; idx < num_pools; idx++) {

        /* Pools 12 to 19 are only dedicated to IFP. */
        if ((_BCM_FIELD_STAGE_LOOKUP == fg->stage_id) &&
            (flex_pool_info[idx].pool_id > 11)) {
            continue;
        }

        if (!flex_pool_info[idx].used_entries) {
            *counters_free += flex_pool_info[idx].free_entries;
            *counters_total += flex_pool_info[idx].total_entries;
        } else {
            *counters_total += flex_pool_info[idx].total_entries;
            if (_FP_COUNTER_POOL_BMP_TEST(fg->counter_pool_bmp,
                                          flex_pool_info[idx].pool_id)) {
               *counters_free += flex_pool_info[idx].free_entries;
            }
        }
    }

    sal_free(flex_pool_info);
    return BCM_E_NONE;
}
/*
 * Function:
 *     _field_th_ingress_stat_hw_alloc
 *
 * Purpose:
 *     Allocate flex stat hardware resource for Ingress stage
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Entry array policer belongs to.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_ingress_stat_hw_alloc(int unit, _field_entry_t *f_ent)
{
    int    rv;                /* Return Operational Status.      */
    int    fp_stat_mode_max;  /* Max stat modes.                 */
    uint8  idx;               /* HW counter modes iterator.      */
    uint32 flex_sid;          /* Flex Stat ID.                   */
    uint32 num_hw_cntrs;      /* Number of counters allocated.   */
    uint32 pool_num;          /* Flex Stat Hw Pool No.           */
    uint32 base_index;        /* Flex Stat counter base index.   */
    uint32 num_selectors;     /* NUmber of flex attr slectors.   */
    uint32 req_bmap;          /* Requested statistics bitmap.    */
    uint32 hw_bmap;           /* HW supported statistics bitmap. */
    uint32 mode_id;           /* Flex Stat Mode. */
    uint32 num_counters;      /* Number of flex counters required. */
    _field_stat_color_t     color;        /* Flex Stat Mode in s/w.         */
    _field_entry_stat_t     *f_ent_st;    /* Field entry stat collector.    */
    _field_stat_t           *f_st;        /* Field statistics descriptor.   */
    bcm_stat_flex_mode_t    offset_mode;  /* Counter mode.                  */
    bcm_stat_group_mode_t   stat_mode;    /* Stat type bcmStatGroupModeXXX. */
    bcm_stat_object_t       stat_obj;     /* Stat object type.              */
    bcm_stat_group_mode_id_config_t stat_config; /* Flex stat configuration. */
    bcm_stat_group_mode_attr_selector_t attr_sel[6]; /* Flext stat Attribute
                                                      * selector structure. */
    bcm_stat_object_t  object; /* Field stat object. */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Get field entry STAT structure. */
    f_ent_st = &f_ent->statistic;

    /* Read STAT configuration. */
    rv = (_bcm_field_stat_get(unit, f_ent_st->sid, &f_st));
    if (rv == BCM_E_NOT_FOUND) {
       /* No Stats attached */
       return BCM_E_NONE;
    } else if (BCM_FAILURE(rv)) {
       return rv;
    }

    /* If counter is disabled skip allocation. */
    if (0 == f_st->hw_stat) {
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                               "FP(unit %d): Stat is not enabled.\n "), unit));
        return (BCM_E_INTERNAL);
    }

    /* Get application requested bitmap. */
    BCM_IF_ERROR_RETURN
        (_bcm_field_stat_array_to_bmap(unit, f_st, &req_bmap));

    /* If bitmap is zero - no mode selection is required. */
    if (0 == req_bmap) {
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                                  "FP(unit %d): No Valid stats.\n "), unit));
        return BCM_E_INTERNAL;
    }


    if (_FP_INVALID_INDEX == f_st->hw_index) {
        fp_stat_mode_max = COUNTOF(th_ingress_cntr_hw_mode_tbl);

        for (idx = 0; idx < fp_stat_mode_max; idx++) {

            hw_bmap = th_ingress_cntr_hw_mode_tbl[idx].hw_bmap;
            num_hw_cntrs = th_ingress_cntr_hw_mode_tbl[idx].hw_entry_count;
            color = th_ingress_cntr_hw_mode_tbl[idx].color;

            if (0 == ((req_bmap | hw_bmap) & ~(hw_bmap))) {
                /*
                 * For maximizing utilization of hardware counters, this should
                 * select the hw_mode both supports the requested stats
                 * AND minimizes the number of required hardware counters.
                 */
                break;
            }
        }

        if (idx >= fp_stat_mode_max) {
            return (BCM_E_INTERNAL);
        }

        for (idx = 0; idx < 6; idx++) {
            /* Initialize attribute selectors to 0 */
            bcm_stat_group_mode_attr_selector_t_init(&attr_sel[idx]);
        }

        switch (color) {
            case _bcmFieldStatColorGreen:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                num_selectors = 1;
                num_counters = 1;
                break;
            case _bcmFieldStatColorYellow:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorYellow;
                attr_sel[0].counter_offset = 0;
                num_selectors = 1;
                num_counters = 1;
                break;
            case _bcmFieldStatColorRed:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorRed;
                attr_sel[0].counter_offset = 0;
                num_selectors = 1;
                num_counters = 1;
                break;
            case _bcmFieldStatColorNotGreen:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorYellow;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorRed;
                attr_sel[1].counter_offset = 0;
                num_selectors = 2;
                num_counters = 1;
                break;
            case _bcmFieldStatColorNotYellow:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorRed;
                attr_sel[1].counter_offset = 0;
                num_selectors = 2;
                num_counters = 1;
                break;
            case _bcmFieldStatColorNotRed:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorYellow;
                attr_sel[1].counter_offset = 0;
                num_selectors = 2;
                num_counters = 1;
                break;
            case _bcmFieldStatColorGreenYellow:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorYellow;
                attr_sel[1].counter_offset = 1;
                num_selectors = 2;
                num_counters = 2;
                break;
            case _bcmFieldStatColorGreenRed:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorRed;
                attr_sel[1].counter_offset = 1;
                num_selectors = 2;
                num_counters = 2;
                break;
            case _bcmFieldStatColorYellowRed:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorYellow;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorRed;
                attr_sel[1].counter_offset = 1;
                num_selectors = 2;
                num_counters = 2;
                break;
            case _bcmFieldStatColorGreenNotGreen:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorYellow;
                attr_sel[1].counter_offset = 1;
                attr_sel[2].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[2].attr_value = bcmColorRed;
                attr_sel[2].counter_offset = 1;
                num_selectors = 3;
                num_counters = 2;
                break;
            case _bcmFieldStatColorYellowNotYellow:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorYellow;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorGreen;
                attr_sel[1].counter_offset = 1;
                attr_sel[2].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[2].attr_value = bcmColorRed;
                attr_sel[2].counter_offset = 1;
                num_selectors = 3;
                num_counters = 2;
                break;
            case _bcmFieldStatColorRedNotRed:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorRed;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorGreen;
                attr_sel[1].counter_offset = 1;
                attr_sel[2].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[2].attr_value = bcmColorYellow;
                attr_sel[2].counter_offset = 1;
                num_selectors = 3;
                num_counters = 2;
                break;
            case _bcmFieldStatColorNoColor:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorYellow;
                attr_sel[1].counter_offset = 0;
                attr_sel[2].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[2].attr_value = bcmColorRed;
                attr_sel[2].counter_offset = 0;
                num_selectors = 3;
                num_counters = 1;
                break;
            case _bcmFieldStatColorGreenYellowRed:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorYellow;
                attr_sel[1].counter_offset = 1;
                attr_sel[2].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[2].attr_value = bcmColorRed;
                attr_sel[2].counter_offset = 2;
                num_selectors = 3;
                num_counters = 3;
                break;
             default:
                 return BCM_E_INTERNAL;
        }

        /* Create custom counter update mode */
        bcm_stat_group_mode_id_config_t_init(&stat_config);
        stat_config.flags = BCM_STAT_GROUP_MODE_INGRESS;
        stat_config.hint.type = bcmStatGroupAllocHintIngressFieldGroup;
        object = bcmStatObjectIngFieldStageIngress;
        stat_config.total_counters = num_counters;
        stat_config.hint.value = f_ent->group->gid; /* group id returned by
                                                     * field_group_create()*/
        rv = bcm_esw_stat_group_mode_id_config_create(unit, 0, &stat_config,
                                                      num_selectors, attr_sel,
                                                      &mode_id);
        BCM_IF_ERROR_RETURN(rv);

        /* Create custom stat group */
        rv = bcm_esw_stat_custom_group_create(unit, mode_id, object,
                                              &flex_sid, &num_hw_cntrs);
        BCM_IF_ERROR_RETURN(rv);

        /* Get flex counter hardware details stored in flex stat ID.*/
        _bcm_esw_stat_get_counter_id_info(unit, flex_sid,
                                          &stat_mode,
                                          &stat_obj,
                                          &offset_mode,
                                          &pool_num,
                                          &base_index);

        /* If the pool is not set to in use for the group, set it now. */
        if (!_FP_COUNTER_POOL_BMP_TEST(
                            f_ent->group->counter_pool_bmp, pool_num)) {
            _FP_COUNTER_POOL_BMP_ADD(f_ent->group->counter_pool_bmp, pool_num);
        }

        /* Store flex stat hardware details in stat data structure. */
        f_st->flex_mode = flex_sid;
        f_st->pool_index = pool_num;
        f_st->hw_index = base_index;
        f_st->hw_mode = offset_mode;
        f_st->hw_entry_count = num_hw_cntrs;
        /* Increment the group counters count equal to
           the hw entries count .*/
        f_ent->group->group_status.counter_count =
               f_ent->group->group_status.counter_count + num_hw_cntrs;
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *  _field_th_exactmatch_stat_hw_alloc
 * Purpose:
 *  Allocate flex stat hardware resource for Exact Match stage
 * Parameters:
 *  unit      - (IN) BCM device number.
 *  f_ent     - (IN) Entry array policer belongs to.
 * Returns:
 *  BCM_E_XXX
 */
STATIC int
_field_th_exactmatch_stat_hw_alloc(int unit, _field_entry_t *f_ent)
{
    int    rv;                /* Return Operational Status.      */
    int    fp_stat_mode_max;  /* Max stat modes.                 */
    uint8  idx;               /* HW counter modes iterator.      */
    uint32 flex_sid;          /* Flex Stat ID.                   */
    uint32 num_hw_cntrs;      /* Number of counters allocated.   */
    uint32 pool_num;          /* Flex Stat Hw Pool No.           */
    uint32 base_index;        /* Flex Stat counter base index.   */
    uint32 num_selectors;     /* NUmber of flex attr slectors.   */
    uint32 req_bmap;          /* Requested statistics bitmap.    */
    uint32 hw_bmap;           /* HW supported statistics bitmap. */
    uint32 mode_id;           /* Flex Stat Mode. */
    uint32 num_counters;      /* Number of flex counters required. */
    _field_stat_color_t     color;        /* Flex Stat Mode in s/w.         */
    _field_entry_stat_t     *f_ent_st;    /* Field entry stat collector.    */
    _field_stat_t           *f_st;        /* Field statistics descriptor.   */
    bcm_stat_flex_mode_t    offset_mode;  /* Counter mode.                  */
    bcm_stat_group_mode_t   stat_mode;    /* Stat type bcmStatGroupModeXXX. */
    bcm_stat_object_t       stat_obj;     /* Stat object type.              */
    bcm_stat_group_mode_id_config_t stat_config; /* Flex stat configuration. */
    bcm_stat_group_mode_attr_selector_t attr_sel[6]; /* Flext stat Attribute
                                                      * selector structure. */
    bcm_stat_object_t  object; /* Field stat object. */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Get field entry STAT structure. */
    f_ent_st = &f_ent->statistic;

    /* Read STAT configuration. */
    rv = (_bcm_field_stat_get(unit, f_ent_st->sid, &f_st));
    if (rv == BCM_E_NOT_FOUND) {
        /* No Stats attached */
        return BCM_E_NONE;
    } else if (BCM_FAILURE(rv)) {
        return rv;
    }

    /* If counter is disabled skip allocation. */
    if (0 == f_st->hw_stat) {
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "FP(unit %d): Stat is not enabled.\n "), unit));
        return (BCM_E_INTERNAL);
    }

    /* Get application requested bitmap. */
    BCM_IF_ERROR_RETURN
        (_bcm_field_stat_array_to_bmap(unit, f_st, &req_bmap));

    /* If bitmap is zero - no mode selection is required. */
    if (0 == req_bmap) {
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                        "FP(unit %d): No Valid stats.\n "), unit));
        return BCM_E_INTERNAL;
    }


    if (_FP_INVALID_INDEX == f_st->hw_index) {
        fp_stat_mode_max = COUNTOF(th_ingress_cntr_hw_mode_tbl);

        for (idx = 0; idx < fp_stat_mode_max; idx++) {

            hw_bmap = th_ingress_cntr_hw_mode_tbl[idx].hw_bmap;
            num_hw_cntrs = th_ingress_cntr_hw_mode_tbl[idx].hw_entry_count;
            color = th_ingress_cntr_hw_mode_tbl[idx].color;

            if (0 == ((req_bmap | hw_bmap) & ~(hw_bmap))) {
                /*
                 * For maximizing utilization of hardware counters, this should
                 * select the hw_mode both supports the requested stats
                 * AND minimizes the number of required hardware counters.
                 */
                break;
            }
        }

        if (idx >= fp_stat_mode_max) {
            return (BCM_E_INTERNAL);
        }

        for (idx = 0; idx < 6; idx++) {
            /* Initialize attribute selectors to 0 */
            bcm_stat_group_mode_attr_selector_t_init(&attr_sel[idx]);
        }

        switch (color) {
            case _bcmFieldStatColorGreen:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                num_selectors = 1;
                num_counters = 1;
                break;
            case _bcmFieldStatColorYellow:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorYellow;
                attr_sel[0].counter_offset = 0;
                num_selectors = 1;
                num_counters = 1;
                break;
            case _bcmFieldStatColorRed:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorRed;
                attr_sel[0].counter_offset = 0;
                num_selectors = 1;
                num_counters = 1;
                break;
            case _bcmFieldStatColorNotGreen:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorYellow;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorRed;
                attr_sel[1].counter_offset = 0;
                num_selectors = 2;
                num_counters = 1;
                break;
            case _bcmFieldStatColorNotYellow:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorRed;
                attr_sel[1].counter_offset = 0;
                num_selectors = 2;
                num_counters = 1;
                break;
            case _bcmFieldStatColorNotRed:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorYellow;
                attr_sel[1].counter_offset = 0;
                num_selectors = 2;
                num_counters = 1;
                break;
            case _bcmFieldStatColorGreenYellow:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorYellow;
                attr_sel[1].counter_offset = 1;
                num_selectors = 2;
                num_counters = 2;
                break;
            case _bcmFieldStatColorGreenRed:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorRed;
                attr_sel[1].counter_offset = 1;
                num_selectors = 2;
                num_counters = 2;
                break;
            case _bcmFieldStatColorYellowRed:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorYellow;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorRed;
                attr_sel[1].counter_offset = 1;
                num_selectors = 2;
                num_counters = 2;
                break;
            case _bcmFieldStatColorGreenNotGreen:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorYellow;
                attr_sel[1].counter_offset = 1;
                attr_sel[2].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[2].attr_value = bcmColorRed;
                attr_sel[2].counter_offset = 1;
                num_selectors = 3;
                num_counters = 2;
                break;
            case _bcmFieldStatColorYellowNotYellow:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorYellow;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorGreen;
                attr_sel[1].counter_offset = 1;
                attr_sel[2].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[2].attr_value = bcmColorRed;
                attr_sel[2].counter_offset = 1;
                num_selectors = 3;
                num_counters = 2;
                break;
            case _bcmFieldStatColorRedNotRed:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorRed;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorGreen;
                attr_sel[1].counter_offset = 1;
                attr_sel[2].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[2].attr_value = bcmColorYellow;
                attr_sel[2].counter_offset = 1;
                num_selectors = 3;
                num_counters = 2;
                break;
            case _bcmFieldStatColorNoColor:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorYellow;
                attr_sel[1].counter_offset = 0;
                attr_sel[2].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[2].attr_value = bcmColorRed;
                attr_sel[2].counter_offset = 0;
                num_selectors = 3;
                num_counters = 1;
                break;
            case _bcmFieldStatColorGreenYellowRed:
                attr_sel[0].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[0].attr_value = bcmColorGreen;
                attr_sel[0].counter_offset = 0;
                attr_sel[1].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[1].attr_value = bcmColorYellow;
                attr_sel[1].counter_offset = 1;
                attr_sel[2].attr = bcmStatGroupModeAttrFieldIngressColor;
                attr_sel[2].attr_value = bcmColorRed;
                attr_sel[2].counter_offset = 2;
                num_selectors = 3;
                num_counters = 3;
                break;
            default:
                return BCM_E_INTERNAL;
        }

        /* Create custom counter update mode */
        bcm_stat_group_mode_id_config_t_init(&stat_config);
        stat_config.flags = BCM_STAT_GROUP_MODE_INGRESS;
        stat_config.hint.type = bcmStatGroupAllocHintExactMatchFieldGroup;
        object = bcmStatObjectIngExactMatch;
        stat_config.total_counters = num_counters;
        stat_config.hint.value = f_ent->group->gid; /* group id returned by
                                                       field_group_create()*/
        rv = bcm_esw_stat_group_mode_id_config_create(unit, 0, &stat_config,
                                                      num_selectors, attr_sel,
                                                      &mode_id);
        BCM_IF_ERROR_RETURN(rv);

        /* Create custom stat group */
        rv = bcm_esw_stat_custom_group_create(unit, mode_id, object,
                                              &flex_sid, &num_hw_cntrs);
        BCM_IF_ERROR_RETURN(rv);

        /* Get flex counter hardware details stored in flex stat ID.*/
        _bcm_esw_stat_get_counter_id_info(unit, flex_sid,
                                          &stat_mode,
                                          &stat_obj,
                                          &offset_mode,
                                          &pool_num,
                                          &base_index);

        /* If the pool is not set to in use for the group, set it now. */
        if (!_FP_COUNTER_POOL_BMP_TEST(
                 f_ent->group->counter_pool_bmp, pool_num)) {
            _FP_COUNTER_POOL_BMP_ADD(f_ent->group->counter_pool_bmp, pool_num);
        }

        /* Store flex stat hardware details in stat data structure. */
        f_st->flex_mode = flex_sid;
        f_st->pool_index = pool_num;
        f_st->hw_index = base_index;
        f_st->hw_mode = offset_mode;
        f_st->hw_entry_count = num_hw_cntrs;
        /* Increment the group counters count equal to
           the hw entries count .*/
        f_ent->group->group_status.counter_count =
               f_ent->group->group_status.counter_count + num_hw_cntrs;
    }

    return (BCM_E_NONE);
}


/*
 * Function:
 *     _field_th_lookup_stat_hw_alloc
 *
 * Purpose:
 *     Allocate flex stat hardware resource for lookup stage
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Entry array policer belongs to.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_lookup_stat_hw_alloc(int unit, _field_entry_t *f_ent)
{
    int    rv;                /* Return Operational Status.      */
    uint8  idx;               /* HW counter modes iterator.      */
    uint32 flex_sid;          /* Flex Stat ID.                   */
    uint32 num_hw_cntrs;      /* Number of counters allocated.   */
    uint32 pool_num;          /* Flex Stat Hw Pool No.           */
    uint32 base_index;        /* Flex Stat counter base index.   */
    uint32 num_selectors;     /* NUmber of flex attr slectors.   */
    uint32 req_bmap;          /* Requested statistics bitmap.    */
    uint32 mode_id;           /* Flex Stat Mode. */
    uint32 num_counters;      /* Number of flex counters required. */
    _field_entry_stat_t     *f_ent_st;    /* Field entry stat collector.    */
    _field_stat_t           *f_st;        /* Field statistics descriptor.   */
    bcm_stat_flex_mode_t    offset_mode;  /* Counter mode.                  */
    bcm_stat_group_mode_t   stat_mode;    /* Stat type bcmStatGroupModeXXX. */
    bcm_stat_object_t       stat_obj;     /* Stat object type.              */
    bcm_stat_group_mode_id_config_t stat_config; /* Flex stat configuration. */
    bcm_stat_group_mode_attr_selector_t attr_sel[6]; /* Flext stat Attribute
                                                      * selector structure. */
    bcm_stat_object_t  object; /* Field stat object. */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Get field entry STAT structure. */
    f_ent_st = &f_ent->statistic;

    /* Read STAT configuration. */
    rv = (_bcm_field_stat_get(unit, f_ent_st->sid, &f_st));
    if (rv == BCM_E_NOT_FOUND) {
       /* No Stats attached */
       return BCM_E_NONE;
    } else if (BCM_FAILURE(rv)) {
       return rv;
    }

    /* If counter is disabled skip allocation. */
    if (0 == f_st->hw_stat) {
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                               "FP(unit %d): Stat is not enabled.\n "), unit));
        return (BCM_E_INTERNAL);
    }

    /* Get application requested bitmap. */
    BCM_IF_ERROR_RETURN
        (_bcm_field_stat_array_to_bmap(unit, f_st, &req_bmap));

    /* If bitmap is zero - no mode selection is required. */
    if (0 == req_bmap) {
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                                  "FP(unit %d): No Valid stats.\n "), unit));
        return BCM_E_INTERNAL;
    }


    if (_FP_INVALID_INDEX == f_st->hw_index) {
        num_hw_cntrs = 1;

        for (idx = 0; idx < 6; idx++) {
            /* Initialize attribute selectors to 0 */
            bcm_stat_group_mode_attr_selector_t_init(&attr_sel[idx]);
        }

        attr_sel[0].attr = bcmStatGroupModeAttrPktType;
        attr_sel[0].attr_value = BCM_STAT_GROUP_MODE_ATTR_ALL_VALUES;
        attr_sel[0].counter_offset = 0;
        num_selectors = 1;
        num_counters = 1;

        /* Create custom counter update mode */
        bcm_stat_group_mode_id_config_t_init(&stat_config);
        stat_config.flags = BCM_STAT_GROUP_MODE_INGRESS;
        stat_config.hint.type = bcmStatGroupAllocHintVlanFieldGroup;
        object = bcmStatObjectIngFieldStageLookup;
        stat_config.total_counters = num_counters;
        stat_config.hint.value = f_ent->group->gid; /* group id returned by
                                                     * field_group_create()*/
        rv = bcm_esw_stat_group_mode_id_config_create(unit, 0, &stat_config,
                                                      num_selectors, attr_sel,
                                                      &mode_id);
        BCM_IF_ERROR_RETURN(rv);

        /* Create custom stat group */
        rv = bcm_esw_stat_custom_group_create(unit, mode_id, object,
                                              &flex_sid, &num_hw_cntrs);
        BCM_IF_ERROR_RETURN(rv);

        /* Get flex counter hardware details stored in flex stat ID.*/
        _bcm_esw_stat_get_counter_id_info(unit, flex_sid,
                                          &stat_mode,
                                          &stat_obj,
                                          &offset_mode,
                                          &pool_num,
                                          &base_index);

        /* If the pool is not set to in use for the group, set it now. */
        if (!_FP_COUNTER_POOL_BMP_TEST(
                            f_ent->group->counter_pool_bmp, pool_num)) {
            _FP_COUNTER_POOL_BMP_ADD(f_ent->group->counter_pool_bmp, pool_num);
        }

        /* Store flex stat hardware details in stat data structure. */
        f_st->flex_mode = flex_sid;
        f_st->pool_index = pool_num;
        f_st->hw_index = base_index;
        f_st->hw_mode = offset_mode;
        f_st->hw_entry_count = num_hw_cntrs;
        /* Increment the group counters count equal to
           the hw entries count .*/
        f_ent->group->group_status.counter_count =
               f_ent->group->group_status.counter_count + num_hw_cntrs;
    }

    return (BCM_E_NONE);
}


/*
 * Function:
 *     _bcm_field_th_stat_hw_alloc
 *
 * Purpose:
 *     Allocate Stat hardware resource
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     f_ent     - (IN) Entry array stat belongs to.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_stat_hw_alloc(int unit,
                            _field_entry_t *f_ent)
{
    int rv = BCM_E_INTERNAL; /* Operational Status. */

    if (NULL == f_ent) {
        return BCM_E_PARAM;
    }

    switch (f_ent->fs->stage_id) {
       case _BCM_FIELD_STAGE_INGRESS:
           rv = _field_th_ingress_stat_hw_alloc(unit, f_ent);
           break;
       case _BCM_FIELD_STAGE_EXACTMATCH:
           rv = _field_th_exactmatch_stat_hw_alloc(unit, f_ent);
           break;
       case _BCM_FIELD_STAGE_LOOKUP:
           rv = _field_th_lookup_stat_hw_alloc(unit, f_ent);
           break;
       case _BCM_FIELD_STAGE_EGRESS:
#if defined BCM_TRIDENT3_SUPPORT
           if (soc_feature(unit, soc_feature_td3_style_fp)) {
              rv = _bcm_field_td2plus_stat_hw_alloc(unit, f_ent);
           } else
#endif /* BCM_TRIDENT3_SUPPORT */
           {
              rv = _bcm_field_stat_hw_alloc(unit, f_ent);
           }
           break;
       default:
           rv = _bcm_field_stat_hw_alloc(unit, f_ent);
           break;
    }

    return rv;
}
/*
 * Function:
 *     _bcm_field_th_flex_stat_action_set
 * Purpose:
 *     Install flex counter update action into policy table.
 * Parameters:
 *     unit         - (IN) BCM device number
 *     f_ent        - (IN) entry structure to get policy info from
 *     mem          - (IN) Policy table memory
 *     tcam_idx     - (IN) Common index of various tables
 *     buf          - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_flex_stat_action_set(int unit,
                                   _field_entry_t *f_ent,
                                   soc_mem_t mem,
                                   int tcam_idx,
                                   uint32 *buf)
{
    int rv; /* Return Operational Status. */
    int idx; /* Stat array index. */
    _field_stat_t *f_st; /* Field statistics descriptor. */


    /* Increment statistics hw reference count. */
    if ((f_ent->statistic.flags & _FP_ENTRY_STAT_VALID)
        && !(f_ent->statistic.flags & _FP_ENTRY_STAT_INSTALLED)) {
        /* Get statistics entity description structure. */
        rv = _bcm_field_stat_get(unit, f_ent->statistic.sid, &f_st);
        BCM_IF_ERROR_RETURN(rv);

        if (_FP_INVALID_INDEX != f_st->hw_index) {
            /*
             * For STATs that are shared by entries, hardware counters
             * are not allocated again. But reference count is incremented
             * for these counters.
             */
            f_st->hw_ref_count++;

            /*
             *  Once flex counters have been allocated for the IFP/VFP, these
             * counters need to be attached to the appropriate IFP/VFP policy
             * table entry. Once flex counters have been attached by associating
             * them with the appropriate IFP/VFP policy table entry, counters
             * are now ready to be updated by corresponding packets.
             */
            rv = _bcm_esw_stat_flex_attach_ingress_table_counters1(unit, mem,
                                                     tcam_idx, f_st->hw_mode,
                                                              f_st->hw_index,
                                                      f_st->pool_index, buf);
            BCM_IF_ERROR_RETURN(rv);

            /* Mark entry as installed. */
            f_ent->statistic.flags |=  _FP_ENTRY_STAT_INSTALLED;

            /*
             * Write individual statistics previous value, first time
             * entry is installed in hardware.
             */
            if (1 == f_st->hw_ref_count) {
                for (idx = 0; idx < f_st->nstat; idx++) {
                    rv = _field_stat_value_set(unit, f_st, f_st->stat_arr[idx],
                                                       f_st->stat_values[idx]);
                    BCM_IF_ERROR_RETURN(rv);
                }
            }
        }
    } else {
        if (f_ent->group->stage_id == _BCM_FIELD_STAGE_LOOKUP) {
           /* Disable counters if it is not attached to the entry. */
           PolicySet(unit, mem, buf, FLEX_CTR_OFFSET_MODEf, 0);
           PolicySet(unit, mem, buf, FLEX_CTR_POOL_NUMBERf, 0);
           PolicySet(unit, mem, buf, FLEX_CTR_BASE_COUNTER_IDXf, 0);
        } else {
          /* setting COUNTER_SETf to 0 will set FLEX_CTR_BASE_COUNTER_IDX,
           * FLEX_CTR_OFFSET_MODE, FLEX_CTR_POOL_NUMBER, G_COUNT, Y_COUNT and
           * R_COUNT fields to 0.
           */
           PolicySet(unit, mem, buf, COUNTER_SETf, 0);
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_stat_action_set
 * Purpose:
 *     Install counter update action into policy table.
 * Parameters:
 *     unit         - (IN) BCM device number
 *     f_ent        - (IN) entry structure to get policy info from
 *     mem          - (IN) Policy table memory
 *     tcam_idx     - (IN) Common index of various tables
 *     buf          - (OUT) Field Policy table entry
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_stat_action_set(int unit, _field_entry_t *f_ent,
                               soc_mem_t mem, int tcam_idx,
                               uint32 *buf)
{
    int rv = BCM_E_NONE;  /* Operation return status.     */

    if (NULL == f_ent || NULL == buf) {
        return (BCM_E_PARAM);
    }

    switch (f_ent->group->stage_id) {
       case _BCM_FIELD_STAGE_INGRESS:
       case _BCM_FIELD_STAGE_LOOKUP:
       case _BCM_FIELD_STAGE_EXACTMATCH:
          /* Tomahawk IFP/VFP uses Flex counters. */
          rv = _bcm_field_th_flex_stat_action_set(unit, f_ent, mem,
                                                  tcam_idx, buf);
          break;
       default:
          rv = _bcm_field_trx_stat_action_set(unit, f_ent, mem,
                                              tcam_idx, buf);
    }

    return rv;
}
/*
 * Function:
 *     _bcm_field_th_multi_pipe_counter_mem_get
 *
 * Purpose:
 *     To get the pipe specific counter memory names for a given
 *     Field Processor stage(VFP/IFP/EFP).
 * Parameters:
 *     unit         - (IN)  BCM device number
 *     stage_fc     - (IN)  Field Processor stage control structure.
 *     counter_mem  - (OUT) pointer to array of counter memories.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_multi_pipe_counter_mem_get(int unit,
                                         _field_stage_t *stage_fc,
                                         soc_mem_t *counter_mem)
{
    int              pipe;          /* XGS pipeline to operate on.        */
    int              max_pipes;     /* Maximum XGS pipelines in the stage */

    /* Input parameters check. */
    if ((NULL == stage_fc) ||
        (NULL == counter_mem)) {
        return BCM_E_PARAM;
    }

    max_pipes = stage_fc->num_pipes;
    for (pipe = 0; pipe < max_pipes; pipe++) {
        counter_mem[pipe] = INVALIDm;
    }

    switch(stage_fc->stage_id) {
        case _BCM_FIELD_STAGE_EGRESS:
            counter_mem[0] = EFP_COUNTER_TABLE_PIPE0m;
            counter_mem[1] = EFP_COUNTER_TABLE_PIPE1m;
            counter_mem[2] = EFP_COUNTER_TABLE_PIPE2m;
            counter_mem[3] = EFP_COUNTER_TABLE_PIPE3m;
            break;
        case _BCM_FIELD_STAGE_LOOKUP:
            break;
        default:
            return BCM_E_INTERNAL;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_th_counter_read
 * Purpose:
 *     Update accumulated sw counter and return current counter value.
 * Parameters:
 *   unit          - (IN)  BCM device number
 *   stage_fc      - (IN)  Stage field control
 *   mamacc_byte   - (IN)  Memory access cache for byte counters
 *   memacc_pkt    - (IN)  Memory access cache for packet counters
 *   buf           - (IN)  Memory table entry for FP counter
 *   cntrs32_buf   - (IN)  s/w packet Counter value
 *   cntrs64_buf   - (IN)  s/w byte Counter value
 *   packet_count  - (OUT) Packet counter value
 *   byte_count    - (OUT) Byte counter value
 * Returns:
 *    BCM_E_XXX
 */
int
_bcm_field_th_counter_read(int unit, _field_stage_t *stage_fc,
                        soc_memacc_t *memacc_byte,
                        soc_memacc_t *memacc_pkt, uint32 *buf,
                        _field_counter32_collect_t *cntrs32_buf,
                        _field_counter64_collect_t *cntrs64_buf,
                        uint64 *packet_count, uint64 *byte_count)
{
    uint32  hw_val[2];     /* Parsed field counter value.*/

    if (NULL == buf ||
        NULL == memacc_byte ||
        NULL == memacc_pkt ||
        NULL == cntrs32_buf ||
        NULL == cntrs64_buf) {
        return BCM_E_PARAM;
    }

    /* Byte counter. */
    hw_val[0] = hw_val[1] = 0;
    soc_memacc_field_get(memacc_byte, buf, hw_val);

    _bcm_field_34bit_counter_update(unit, hw_val, cntrs64_buf);
    if (NULL != byte_count) {
        COMPILER_64_ADD_64(*byte_count, cntrs64_buf->accumulated_counter);
    }
    /* Packet counter. */
    hw_val[0] = hw_val[1] = 0;
    soc_memacc_field_get(memacc_pkt, buf, hw_val);
    _bcm_field_26bit_counter_update(unit, hw_val, cntrs32_buf);
    if (NULL != packet_count) {
        COMPILER_64_ADD_64(*packet_count, cntrs32_buf->accumulated_counter);
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_th_pipe_counter_get
 * Purpose:
 *     Update accumulated sw counter and return current counter value.
 * Parameters:
 *   unit          - (IN)  BCM device number
 *   stage_fc      - (IN)  Stage field control
 *   counter_mem   - (IN)  Memory name for FP counter
 *   mem_buf       - (IN)  Memory table entry for FP counter
 *   idx           - (IN)  Counter index
 *   pipe          - (IN)  XGS pipeline to operate on
 *   packet_count  - (OUT) Packet counter value
 *   byte_count    - (OUT) Byte counter value
 * Returns:
 *    BCM_E_XXX
 */
int
_bcm_field_th_pipe_counter_get(int unit,
                            _field_stage_t *stage_fc,
                            soc_mem_t counter_mem,
                            uint32 *mem_buf,
                            int idx,
                            int pipe,
                            uint64 *packet_count,
                            uint64 *byte_count)
{
    _field_counter32_collect_t *cntrs32_buf;  /* Sw packet counter value    */
    _field_counter64_collect_t *cntrs64_buf;  /* Sw byte counter value      */
    soc_memacc_t *memacc_pkt, *memacc_byte;   /* Memory access cache.   */

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return BCM_E_PARAM;
    }

    cntrs64_buf = &stage_fc->_field_64_counters[pipe][idx];
    cntrs32_buf = &stage_fc->_field_32_counters[pipe][idx];
    memacc_byte = &(stage_fc->_field_memacc_counters[(pipe * 2)]);
    memacc_pkt  = &(stage_fc->_field_memacc_counters[((pipe * 2) + 1)]);
    BCM_IF_ERROR_RETURN(_bcm_field_th_counter_read(unit, stage_fc,
                                                   memacc_byte,
                                                   memacc_pkt,
                                                   mem_buf,
                                                   cntrs32_buf, cntrs64_buf,
                                                   packet_count, byte_count));

    return BCM_E_NONE;
}

/*
 * Function:
 *    _field_th_multi_pipe_sw_counter_get
 *
 * Description:
 *       Service routine used to retrieve 64-bit software accumulated counters.
 * Parameters:
 *   unit         - (IN) BCM device number.
 *   stage_fc     - (IN) Stage field control structure.
 *   stat_group_pipe - (IN) XGS Pipline associated to the field group.
 *   idx          - (IN) Counter hw index.
 *   packet_count - (OUT) Packet Counter value
 *   byte_count   - (OUT) Byte Counter value
 * Returns:
 *    BCM_E_XXX
 */
STATIC int
_field_th_multi_pipe_sw_counter_get(int unit,
                                 _field_stage_t *stage_fc,
                                 int stat_group_pipe,
                                 int idx,
                                 uint64 *packet_count,
                                 uint64 *byte_count)
{
    int                       rv;              /* Operation return status.    */
    int                       pipe;            /* XGS pipeline to operate on. */
    int                       max_pipes;       /* Maximum pipeline per stage. */
    uint32                    *hw_buf;         /*  memory HW  buffer.         */
    uint32                    *hw_buffer;      /*  memory HW  buffer.         */
    _field_control_t          *fc;             /* Field control structure.    */
    _field_counter32_collect_t *cntrs32_buf;   /* Sw packet counter value     */
    _field_counter64_collect_t *cntrs64_buf;   /* Sw byte counter value       */
    soc_mem_t counter_mem[_FP_MAX_NUM_PIPES];  /* FieldProcessor
                                                     (IFP/EFP/VFP)
                                                     counter memories */


    hw_buf = hw_buffer = NULL;

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Get counter memory. */
    rv = _bcm_field_th_multi_pipe_counter_mem_get(unit, stage_fc,
                                                    counter_mem);
    BCM_IF_ERROR_RETURN(rv);

    /* HW index sanity check. */
    if (idx < soc_mem_index_min(unit, counter_mem[0]) ||
        idx > soc_mem_index_max(unit, counter_mem[0])) {
        return (BCM_E_INTERNAL);
    }

    max_pipes = stage_fc->num_pipes;
    if (_BCM_FIELD_GLOBAL_GROUP != stat_group_pipe) {
        for (pipe = 0; pipe < max_pipes; pipe++ ) {
             if (pipe != stat_group_pipe) {
                 counter_mem[pipe] = INVALIDm;
             }
        }
    }

    if (0 == (fc->flags & _FP_STAT_SYNC_ENABLE)) {
        for (pipe = 0; pipe < max_pipes; pipe++) {
            if (INVALIDm != counter_mem[pipe]) {
                cntrs64_buf = &stage_fc->_field_64_counters[pipe][idx];
                COMPILER_64_ADD_64(*byte_count,
                                   cntrs64_buf->accumulated_counter);
                cntrs32_buf = &stage_fc->_field_32_counters[pipe][idx];
                COMPILER_64_ADD_64(*packet_count,
                                    cntrs32_buf->accumulated_counter);
            }
        }
    } else {
        /* Allocate buffer for counter values in HW.  */
        _FP_XGS3_ALLOC(hw_buffer,
                     max_pipes * WORDS2BYTES(SOC_MAX_MEM_FIELD_WORDS),
                     "Counter buffers");
        if (NULL == hw_buffer) {
            return (BCM_E_MEMORY);
        }

        for (pipe = 0; pipe < max_pipes; pipe++) {
            if (INVALIDm != counter_mem[pipe]) {
                hw_buf = hw_buffer + (pipe * SOC_MAX_MEM_FIELD_WORDS);
                rv = soc_th_ifp_mem_read(unit,
                                  counter_mem[pipe],
                                  MEM_BLOCK_ANY,
                                  idx, hw_buf);
                if (BCM_FAILURE(rv)) {
                    sal_free(hw_buffer);
                    return rv;
                }
                rv = _bcm_field_th_pipe_counter_get(unit, stage_fc,
                                                 counter_mem[pipe],
                                                 hw_buf, idx, pipe,
                                                 packet_count, byte_count);
                if (BCM_FAILURE(rv)) {
                    sal_free(hw_buffer);
                    return rv;
                }

            }
        }

        sal_free(hw_buffer);

    }

    return rv;
}

/*
 * Function:
 *      _bcm_th_field_stat_value_set
 *
 * Description:
 *      Set 64 bit counter value for specific statistic type.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      f_st      - (IN) Statistics entity descriptor.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (IN) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_th_field_stat_value_set(int unit,
                             _field_stat_t *f_st,
                             bcm_field_stat_t stat,
                             uint64 value)
{
    int                 rv = BCM_E_NONE; /* Operation return status.          */
    int                 idx1;            /* First counter index to read.      */
    int                 idx2;            /* Second counter index to read.     */
    int                 idx3;            /* Third counter index to read.      */
    int                 len;             /* length of the h/w field.          */
    uint32              flags;           /* _FP_STAT_XXX.                     */
    uint64              hw_value;        /* h/w counter value to be written.  */
    uint64              reset_val;       /* Value to be set on reset          */
    _field_control_t    *fc;             /* Field control structure.          */
    bcm_stat_value_t    stat_val;        /* Stat Values structure to SET.     */
    soc_reg_t           reg;             /* Variable to hold SOC register.    */
    soc_ctr_control_info_t ctrl_info;    /* Centralized counter information.  */

    /* Input parameters check. */
    if (NULL == f_st) {
        return (BCM_E_PARAM);
    }

    /* Check that stat was requested during statistics entity creation. */
    for (idx1 = 0; idx1 < f_st->nstat; idx1++) {
        if (stat == f_st->stat_arr[idx1]) {
            break;
        }
    }
    if (idx1 == f_st->nstat) {
        return (BCM_E_PARAM);
    }

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Get hw indexes and flags needed to compose requested statistic.*/
    rv = fc->functions.fp_stat_index_get(unit, f_st, stat, &idx1,
                                         &idx2, &idx3, &flags);
    BCM_IF_ERROR_RETURN(rv);

    if (_FP_INVALID_INDEX == idx1) {
        return (BCM_E_INTERNAL);
    }

    if (_BCM_FIELD_STAGE_EGRESS == f_st->stage_id) {
        int                 inst;            /* Pipe Instance.          */
        _field_group_t      *fg;             /* Field Group structure.  */
        _field_stage_t      *stage_fc;       /* Field Stage Structure.  */

        /* Get group descriptor. */
        rv = _field_group_get (unit, f_st->gid, &fg);
        BCM_IF_ERROR_RETURN(rv);

        /* Get Stage descriptor */
        BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, f_st->stage_id,
                                                 &stage_fc));

        if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
           inst = 0;
        } else {
           inst = fg->instance;
        }

        if (flags & _FP_STAT_BYTES) {
            reg = SOC_COUNTER_NON_DMA_EFP_BYTE;
            /* For Tomahawk BYTE_COUNTERf field_length = 34*/
            len = soc_mem_field_length(unit, EFP_COUNTER_TABLEm, BYTE_COUNTERf);
        } else {
            reg = SOC_COUNTER_NON_DMA_EFP_PKT;
            /* For Tomahawk field_length = 26 */
            len = soc_mem_field_length(unit, EFP_COUNTER_TABLEm,
                                                PACKET_COUNTERf);
        }

        if (len < 32) {
            COMPILER_64_SET(hw_value, 0,
                            COMPILER_64_LO(value) & ((1 << len) - 1));
        } else {
            COMPILER_64_SET(hw_value,
                            COMPILER_64_HI(value) & ((1 << (len - 32)) - 1),
                                                     COMPILER_64_LO(value));
        }

        
        if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
            ctrl_info.instance = _FP_GLOBAL_INST;
        } else {
            ctrl_info.instance = inst;
        }

        ctrl_info.instance_type = SOC_CTR_INSTANCE_TYPE_PIPE;
        COMPILER_64_ZERO(reset_val);

        rv = soc_counter_generic_set(unit, reg,
                                     ctrl_info, 0,
                                     idx1, reset_val);
        BCM_IF_ERROR_RETURN(rv);
        /* Reset accumulated counter value at secondary index. */
        if (_FP_INVALID_INDEX != idx2) {
            rv = soc_counter_generic_set(unit, reg,
                                         ctrl_info, 0,
                                         idx2, reset_val);
            BCM_IF_ERROR_RETURN(rv);
        }

        if (_FP_INVALID_INDEX != idx3) {
            rv = soc_counter_generic_set(unit, reg,
                                         ctrl_info, 0,
                                         idx3, reset_val);
            BCM_IF_ERROR_RETURN(rv);
        }

        /* Set accumulated counter value at primary index. */
        ctrl_info.instance = inst;
        rv = soc_counter_generic_set(unit, reg,
                                     ctrl_info, 0,
                                     idx1, hw_value);
        BCM_IF_ERROR_RETURN(rv);
    } else if ((_BCM_FIELD_STAGE_INGRESS == f_st->stage_id) ||
               (_BCM_FIELD_STAGE_EXACTMATCH == f_st->stage_id)) {

        if (flags & _FP_STAT_BYTES) {
            COMPILER_64_SET(stat_val.bytes,
                            COMPILER_64_HI(value),
                            COMPILER_64_LO(value));
        } else {
            stat_val.packets = 0;
            COMPILER_64_SET(stat_val.packets64,
                            COMPILER_64_HI(value),
                            COMPILER_64_LO(value));
        }

        /* Set accumulated counter value at primary index. */
        /* coverity[uninit_use_in_call : FALSE] */
        rv = _bcm_esw_stat_counter_raw_set(unit,
                                           f_st->flex_mode,
                                           (flags & _FP_STAT_BYTES) ? 1 : 0,
                                           idx1 - f_st->hw_index,
                                           &stat_val);
        BCM_IF_ERROR_RETURN(rv);

        if (_FP_INVALID_INDEX != idx2) {
            COMPILER_64_ZERO(stat_val.bytes);
            stat_val.packets = 0;
            COMPILER_64_ZERO(stat_val.packets64);
            /* Reset accumulated counter value at secondary index. */
            /* coverity[uninit_use_in_call : FALSE] */
             rv = _bcm_esw_stat_counter_raw_set(unit,
                                               f_st->flex_mode,
                                               (flags & _FP_STAT_BYTES) ? 1 : 0,
                                               idx2 - f_st->hw_index,
                                               &stat_val);
             BCM_IF_ERROR_RETURN(rv);
        }

        if (_FP_INVALID_INDEX != idx3) {
            COMPILER_64_ZERO(stat_val.bytes);
            stat_val.packets = 0;
            COMPILER_64_ZERO(stat_val.packets64);
            /* Reset accumulated counter value at ternary index. */
            /* coverity[uninit_use_in_call : FALSE] */
             rv = _bcm_esw_stat_counter_raw_set(unit,
                                               f_st->flex_mode,
                                               (flags & _FP_STAT_BYTES) ? 1 : 0,
                                               idx3 - f_st->hw_index,
                                               &stat_val);
             BCM_IF_ERROR_RETURN(rv);
        }
    } else {
        return BCM_E_INTERNAL;
    }

    return (rv);
}

/*
 * Function:
 *      _bcm_th_field_stat_value_get
 *
 * Description:
 *      Get 64 bit counter value for specific statistic type.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      f_st      - (IN) Statistics entity descriptor.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (OUT) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_th_field_stat_value_get(int unit, int sync_mode,
                             _field_stat_t *f_st,
                             bcm_field_stat_t stat,
                             uint64 *value)
{

    int                 idx1;     /* First counter index to read.      */
    int                 idx2;     /* Second counter index to read.     */
    int                 idx3;     /* Third counter index to read.      */
    int                 rv;       /* Operation return status.          */
    uint32              flags;    /* _FP_STAT_XXX.                     */
    uint64              count_1;  /* Primary index packet count.       */
    uint64              count_2;  /* Primary index byte count.         */
    uint64              count_3;  /* Third counterindex byte count.    */
    _field_control_t    *fc;      /* Field control structure.          */
    soc_ctr_control_info_t ctrl_info;
    soc_reg_t reg;
    bcm_stat_value_t stat_val;

    if (NULL == f_st || NULL == value) {
        return BCM_E_PARAM;
    }

    /* Initialization. */
    COMPILER_64_ZERO(count_1);
    COMPILER_64_ZERO(count_2);
    COMPILER_64_ZERO(count_3);
    idx1 = idx2 = idx3 = _FP_INVALID_INDEX;
    flags = 0;

    /* Check that stat was requested during statistics entity creation. */
    for (idx1 = 0; idx1 < f_st->nstat; idx1++) {
        if (stat == f_st->stat_arr[idx1]) {
            break;
        }
    }
    if (idx1 == f_st->nstat) {
        return (BCM_E_PARAM);
    }

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* If stat sync field control is enabled, get the status from h/w. */
    if (fc->flags & _FP_STAT_SYNC_ENABLE) {
        sync_mode = 1;
    } else {
        sync_mode = 0;
    }

    /* Get hw indexes and flags needed to compose requested statistic.*/
    rv = fc->functions.fp_stat_index_get(unit, f_st, stat, &idx1,
                                         &idx2, &idx3, &flags);
    BCM_IF_ERROR_RETURN(rv);

    if (!(f_st->hw_flags & _FP_STAT_FLEX_CNTR)) {
        /* Fixed Counters - for stage BCM_FIELD_STAGE_EGRESS */
        int                 inst;            /* Pipe Instance.          */
        _field_stage_t      *stage_fc;       /* Field Stage Structure.  */
        _field_group_t      *fg;             /* Field Group structure.  */

        /* Get group descriptor. */
        rv = _field_group_get (unit, f_st->gid, &fg);
        BCM_IF_ERROR_RETURN(rv);

        /* Get Stage descriptor */
        BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, f_st->stage_id,
                                                 &stage_fc));

        if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
           inst = _FP_GLOBAL_INST;
        } else {
           inst = fg->instance;
        }

        ctrl_info.instance = inst;
        ctrl_info.instance_type = SOC_CTR_INSTANCE_TYPE_PIPE;

        if (flags & _FP_STAT_BYTES) {
            reg = SOC_COUNTER_NON_DMA_EFP_BYTE;
        } else {
            reg = SOC_COUNTER_NON_DMA_EFP_PKT;
        }

        /* Get accumulated counter value at primary index. */
        if (_FP_INVALID_INDEX != idx1) {
            rv = soc_counter_generic_get (unit, reg,
                                          ctrl_info, sync_mode,
                                          idx1, &count_1);
            BCM_IF_ERROR_RETURN(rv);
        }

        /* Get accumulated counter value at secondary index. */
        if (_FP_INVALID_INDEX != idx2) {
            rv = soc_counter_generic_get (unit, reg,
                                          ctrl_info, sync_mode,
                                          idx2, &count_2);
            BCM_IF_ERROR_RETURN(rv);
        }

        /* Get accumulated counter value at secondary index. */
        if (_FP_INVALID_INDEX != idx3) {
            rv = soc_counter_generic_get (unit, reg,
                                          ctrl_info, sync_mode,
                                          idx3, &count_3);
            BCM_IF_ERROR_RETURN(rv);
        }

    } else if (((_BCM_FIELD_STAGE_INGRESS == f_st->stage_id) ||
                (_BCM_FIELD_STAGE_EXACTMATCH == f_st->stage_id) ||
                (_BCM_FIELD_STAGE_EGRESS == f_st->stage_id)) &&
               (f_st->hw_flags & _FP_STAT_FLEX_CNTR) &&
               (soc_feature(unit, soc_feature_advanced_flex_counter))) {

        /* Get accumulated counter value at primary index. */
        if (_FP_INVALID_INDEX != idx1) {
            rv = _bcm_esw_stat_counter_raw_get(unit, sync_mode, f_st->flex_mode,
                                               (flags & _FP_STAT_BYTES) ? 1 : 0,
                                                          idx1 - f_st->hw_index,
                                                                     &stat_val);
            /*
             * Flex STAT module is initalized before field module during reset.
             * Attempt to read flex stats by field module would result in
             * error. Ignore these errors.
             */
            if (BCM_FAILURE(rv)) {
                if (TRUE == fc->init) {
                    return (rv);
                } else {
                    return (BCM_E_NOT_FOUND);
                }
            } else {
                /* Store retrieved stat value in return variable. */
                if (flags & _FP_STAT_BYTES) {
                    COMPILER_64_OR(count_1, stat_val.bytes);
                } else {
                    COMPILER_64_OR(count_1, stat_val.packets64);
                }
            }
        }

        /* Get accumulated counter value at secondary index. */
        if (_FP_INVALID_INDEX != idx2) {

            rv = _bcm_esw_stat_counter_raw_get(unit, sync_mode, f_st->flex_mode,
                                               (flags & _FP_STAT_BYTES) ? 1 : 0,
                                                          idx2 - f_st->hw_index,
                                                                     &stat_val);
            /*
             * Flex STAT module is initalized before field module during reset.
             * Attempt to read flex stats by field module would result in
             * error. Ignore these errors.
             */
            if (BCM_FAILURE(rv)) {
                if (TRUE == fc->init) {
                    return (rv);
                } else {
                    return (BCM_E_NOT_FOUND);
                }
            } else {
                /* Store retrieved stat value in return variable. */
                if (flags & _FP_STAT_BYTES) {
                    COMPILER_64_OR(count_2, stat_val.bytes);
                } else {
                    COMPILER_64_OR(count_2, stat_val.packets64);
                }
            }

        }

        /* Get accumulated counter value at secondary index. */
        if (_FP_INVALID_INDEX != idx3) {

            rv = _bcm_esw_stat_counter_raw_get(unit, sync_mode, f_st->flex_mode,
                                               (flags & _FP_STAT_BYTES) ? 1 : 0,
                                                          idx3 - f_st->hw_index,
                                                                     &stat_val);
            /*
             * Flex STAT module is initalized before field module during reset.
             * Attempt to read flex stats by field module would result in
             * error. Ignore these errors.
             */
            if (BCM_FAILURE(rv)) {
                if (TRUE == fc->init) {
                    return (rv);
                } else {
                    return (BCM_E_NOT_FOUND);
                }
            } else {
                /* Store retrieved stat value in return variable. */
                if (flags & _FP_STAT_BYTES) {
                    COMPILER_64_OR(count_3, stat_val.bytes);
                } else {
                    COMPILER_64_OR(count_3, stat_val.packets64);
                }
            }
        }

    } else {
        return BCM_E_INTERNAL;
    }

    /* Get final counter value. */
    COMPILER_64_ZERO(*value);
    if (flags & _FP_STAT_ADD) {
        COMPILER_64_ADD_64(count_1, count_2);
        COMPILER_64_ADD_64(count_1, count_3);
    } else if (flags & _FP_STAT_SUBSTRACT) {
        COMPILER_64_SUB_64(count_1, count_2);
    }
    COMPILER_64_OR(*value, count_1);
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_th_multi_pipe_stat_value_get
 *
 * Description:
 *      Get 64 bit counter value for specific statistic type.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      f_st      - (IN) Statistics entity descriptor.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (OUT) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_th_multi_pipe_stat_value_get(int unit,
                                 _field_stat_t *f_st,
                                 bcm_field_stat_t stat,
                                 uint64 *value)
{
    int                 idx1;            /* First counter index to read.      */
    int                 idx2;            /* Second counter index to read.     */
    int                 idx3;            /* Third counter index to read.      */
    int                 rv;              /* Operation return status.          */
    int                 stat_group_pipe; /* XGS Pipline associated
                                            to the field group.               */
    uint32              flags;           /* _FP_STAT_XXX.                     */
    uint64              packet_count_1;  /* Primary index packet count.       */
    uint64              byte_count_1;    /* Primary index byte count.         */
    uint64              packet_count_2;  /* Secondary index packet count.     */
    uint64              byte_count_2;    /* Secondary index byte count.       */
    uint64              packet_count_3;  /* Third counter index packet count. */
    uint64              byte_count_3;    /* Third counterindex byte count.    */
    _field_stage_t      *stage_fc;       /* Stage field control.              */
    _field_control_t    *fc;             /* Field control structure.          */

    /* Initialization. */
    COMPILER_64_ZERO(packet_count_1);
    COMPILER_64_ZERO(packet_count_2);
    COMPILER_64_ZERO(packet_count_3);
    COMPILER_64_ZERO(byte_count_1);
    COMPILER_64_ZERO(byte_count_2);
    COMPILER_64_ZERO(byte_count_3);
    idx1 = idx2 = idx3 = _FP_INVALID_INDEX;
    flags = 0;

    /* Get field control. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Stage field control structure. */
    rv = _field_stage_control_get(unit, f_st->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Check that stat was requested during statistics entity creation. */
    for (idx1 = 0; idx1 < f_st->nstat; idx1++) {
        if (stat == f_st->stat_arr[idx1]) {
            break;
        }
    }
    if (idx1 == f_st->nstat) {
        return (BCM_E_PARAM);
    }

    /* Get hw indexes and flags needed to compose requested statistic.*/
    rv = fc->functions.fp_stat_index_get(unit, f_st, stat, &idx1,
                                         &idx2, &idx3, &flags);
    BCM_IF_ERROR_RETURN(rv);

    stat_group_pipe = _BCM_FIELD_GLOBAL_GROUP;

    /* Get accumulated counter value at primary index. */
    if (_FP_INVALID_INDEX != idx1) {
        rv = _field_th_multi_pipe_sw_counter_get(unit, stage_fc,
                                              stat_group_pipe, idx1,
                                              &packet_count_1,
                                              &byte_count_1);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Get accumulated counter value at secondary index. */
    if (_FP_INVALID_INDEX != idx2) {
        rv = _field_th_multi_pipe_sw_counter_get(unit, stage_fc,
                                              stat_group_pipe, idx2,
                                              &packet_count_2,
                                              &byte_count_2);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Get accumulated counter value at secondary index. */
    if (_FP_INVALID_INDEX != idx3) {
        rv = _field_th_multi_pipe_sw_counter_get(unit, stage_fc,
                                              stat_group_pipe, idx3,
                                              &packet_count_3,
                                              &byte_count_3);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Get final counter value. */
    COMPILER_64_ZERO(*value);
    if (flags & _FP_STAT_BYTES) {
        if (flags & _FP_STAT_ADD) {
            COMPILER_64_ADD_64(byte_count_1, byte_count_2);
            COMPILER_64_ADD_64(byte_count_1, byte_count_3);
        } else if (flags & _FP_STAT_SUBSTRACT) {
            COMPILER_64_SUB_64(byte_count_1, byte_count_2);
        }
        COMPILER_64_OR(*value, byte_count_1);
    } else {
        if (flags & _FP_STAT_ADD) {
            COMPILER_64_ADD_64(packet_count_1, packet_count_2);
            COMPILER_64_ADD_64(packet_count_1, packet_count_3);
        } else if (flags & _FP_STAT_SUBSTRACT) {
            COMPILER_64_SUB_64(packet_count_1, packet_count_2);
        }
        COMPILER_64_OR(*value, packet_count_1);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_th_counter_multi_pipe_memacc_alloc
 * Purpose:
 *     Initialize software cached memory access info for field counters
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     mem          - (IN) Counter memory.
 *     descr        - (IN) Counter descriptor.
 *     ptr          - (OUT) Allocated pointer.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_counter_multi_pipe_memacc_alloc(int unit, soc_memacc_t **memacc_ptr)
{
    int mem_size; /* Total memory size of memory access info of
                     all different counter in all pipes */

    /* Input parameters check. */
    if (NULL == memacc_ptr) {
        return (BCM_E_PARAM);
    }

    mem_size = _FIELD_COUNTER_MEMACC_PIPE_NUM * sizeof(soc_memacc_t);
    *memacc_ptr = sal_alloc(mem_size, "FP counter memory access cache");
    if (NULL == *memacc_ptr) {
        return (BCM_E_MEMORY);
    }
    sal_memset(*memacc_ptr, 0, mem_size);
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_counter_multi_pipe_collect_init
 * Purpose:
 *     Initialize software field 64bit counters.
 *
 * Parameters:
 *     unit         - (IN) BCM device number.
 *     fc           - (IN) Field control structure.
 *     stage_fc     - (IN/OUT) Stage field control structure.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_counter_multi_pipe_collect_init(int unit,
                                       _field_control_t *fc,
                                       _field_stage_t *stage_fc)
{
    int              rv = BCM_E_NONE; /* Operation return status.            */
    int              pipe;            /* XGS pipeline to operate on.         */
    int              max_pipes;       /* Maximum XGS pipelines in the stage. */
    soc_memacc_t     *memacc_list;    /* Memory access cache list.           */
    soc_mem_t        counter_mem[_FP_MAX_NUM_PIPES]; /* FieldProcessor
                                                           (IFP/EFP/VFP)
                                                           counter memories  */
    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_th_multi_pipe_counter_mem_get(unit, stage_fc,
                                                  counter_mem);
    BCM_IF_ERROR_RETURN(rv);


    max_pipes = stage_fc->num_pipes;

    /* Check if stage has counters. */
    if (INVALIDm == counter_mem[0]) {
        return (BCM_E_NONE);
    }

    /* Allocate space for cached counter memory access info */
    rv = _field_th_counter_multi_pipe_memacc_alloc(unit,
                                   &(stage_fc->_field_memacc_counters));
    if (BCM_FAILURE(rv)) {
        return (rv);
    }
    memacc_list = stage_fc->_field_memacc_counters;

    for (pipe = 0; pipe < max_pipes; pipe++) {

        rv = _bcm_field_counter32_collect_alloc(unit, counter_mem[pipe],
                                               "FP pipeline counters",
                                           &stage_fc->_field_32_counters[pipe]);
        if (BCM_FAILURE(rv)) {
            _bcm_field_counter_collect_deinit(unit, stage_fc);
            return (rv);
        }

        rv = _bcm_field_counter64_collect_alloc(unit, counter_mem[pipe],
                                            "FP pipeline byte counters",
                                           &stage_fc->_field_64_counters[pipe]);
        if (BCM_FAILURE(rv)) {
            _bcm_field_counter_collect_deinit(unit, stage_fc);
            return (rv);
        }

        rv = soc_memacc_init(unit, counter_mem[pipe], BYTE_COUNTERf,
                                 &(memacc_list[(pipe * 2)]));
        if(BCM_FAILURE(rv)) {
            _bcm_field_counter_collect_deinit(unit, stage_fc);
            return (rv);
        }

        rv = soc_memacc_init(unit, counter_mem[pipe], PACKET_COUNTERf,
                            &(memacc_list[((pipe * 2) + 1)]));

        if(BCM_FAILURE(rv)) {
            _bcm_field_counter_collect_deinit(unit, stage_fc);
            return (rv);
        }
    }
    return (rv);
}

/*
 * Function:
 *  _bcm_field_th_multi_pipe_sw_counter_update
 * Description:
 *  Service routine used to update 64-bit software accumulated counters.
 *  based on hw memory block.
 * Parameters:
 *   unit     - (IN) BCM device number.
 *   stage_fc - (IN/OUT) Stage field control structure.
 *   mem      - (IN) Counters memory.
 *   idx_min  - (IN) First counter index in the buffer.
 *   idx_max  - (IN) Last counter index in the buffer.
 *   buf      - (IN) Counters buffer.
 *   flags    - (IN) Device counters flags.
 * Returns:
 *  BCM_E_XXX
 */
int
_bcm_field_th_multi_pipe_sw_counter_update(int unit, _field_stage_t *stage_fc,
                                        soc_mem_t mem, int idx_min, int idx_max,
                                        char *buf, int pipe)
{
    int                    rv = BCM_E_NONE; /* Operartion return status.      */
    int                    idx;             /* Iteration index.               */
    int                    buf_offset;      /* Offset into counters buffer.   */
    uint32                 *entry_p;        /* HW entry pointer.              */
    _field_control_t       *fc;             /* Field control structure.       */

    if ((NULL == stage_fc) || (NULL == buf)) {
        return BCM_E_PARAM;
    }

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));
    for (idx = idx_min, buf_offset = 0; idx <= idx_max; idx++, buf_offset++) {
        /* Read counter value from the first memory. */
        entry_p = soc_mem_table_idx_to_pointer(unit, mem, uint32 *,
                                               buf, buf_offset);

        /* Process accumulated counter value. */
        rv = _bcm_field_th_pipe_counter_get(unit, stage_fc, mem, entry_p,
                                            idx, pipe, NULL, NULL);
        if (BCM_FAILURE(rv)) {
            break;
        }
    }
    return rv;
}

/*
 * Function:
 *    _field_th_multi_pipe_mem_counters_read
 * Description:
 *    Service routine used to coolect 64-bit software accumulated counters.
 *    for a specific stage.
 * Parameters:
 *    unit     - (IN) BCM device number.
 *    mem      - (IN) Counters memory.
 *    pipe     - (IN) XGS pipeline to operate on.
 *    stage_fc - (IN/OUT) Stage field control structure.
 * Returns:
 *  BCM_E_XXX
 */
STATIC int
_field_th_multi_pipe_mem_counters_read(int unit,
                                    soc_mem_t mem,
                                    int pipe,
                                    _field_stage_t *stage_fc)
{
    int       rv = BCM_E_NONE;       /* Operation return value.   */
    int       idx;                   /* Table iteration index.    */
    int       buf_end_idx;           /* Buffer end index.         */
    int       alloc_size;            /* DMA buffer size.          */
    int       max_idx;               /* Counter memory index max. */
    int       min_idx;               /* Counter memory index min. */
    char      *buf;                  /* Buffer to read the table. */


    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    /* Make sure memory is valid */
    if (INVALIDm == mem) {
        return BCM_E_INTERNAL;
    }

    /* Get table boundaries. */
    min_idx = soc_mem_index_min(unit, mem);
    max_idx = soc_mem_index_max(unit, mem);

    /* Allocate memory buffer. */
    alloc_size = (_FP_64_COUNTER_BUCKET * sizeof(fp_counter_table_entry_t));
    buf = soc_cm_salloc(unit, alloc_size, "fp_64_bit_counter");
    if (buf == NULL) {
        return (BCM_E_MEMORY);
    }

    /* Dma part of the table & update software counters. */
    soc_mem_lock(unit, mem);
    for (idx = min_idx; idx <= max_idx; idx += _FP_64_COUNTER_BUCKET) {
        buf_end_idx = MIN(max_idx, (idx + _FP_64_COUNTER_BUCKET - 1));
        /* Dma range of entries in counter table. */
        rv = soc_mem_read_range(unit, mem, MEM_BLOCK_ANY, idx,
                                    buf_end_idx, buf);
        if (BCM_FAILURE(rv)) {
            break;
        }

        rv = _bcm_field_th_multi_pipe_sw_counter_update(unit, stage_fc,
                                                     mem, idx,
                                                     buf_end_idx,
                                                     buf, pipe);
        if (BCM_FAILURE(rv)) {
            break;
        }
    }
    soc_mem_unlock(unit, mem);
    soc_cm_sfree(unit, buf);
    return (rv);
}

/*
 * Function:
 *  _bcm_field_th_stage_multi_pipe_counters_collect
 * Description:
 *  Service routine used to coolect  64-bit software accumulated counters.
 *  for a specific stage.
 * Parameters:
 *   unit     - (IN) BCM device number.
 *   fc       - (IN) Field control structure.
 *   stage_fc - (IN/OUT) Stage field control structure.
 * Returns:
 *  BCM_E_XXX
 * Notes:
 *  None.
 */
int
_bcm_field_th_stage_multi_pipe_counters_collect (int unit, _field_control_t *fc,
                               _field_stage_t *stage_fc)
{
    int              rv = BCM_E_NONE; /* Operation return value.            */
    int              pipe;            /* XGS pipeline to operate on.        */
    int              max_pipes;       /* Maximum XGS pipelines in the stage */
    soc_mem_t        counter_mem[_FP_MAX_NUM_PIPES]; /* FieldProcessor
                                                           (IFP/EFP/VFP)
                                                           counter memories */
    /* Input parameters check. */
    if (NULL == stage_fc || NULL == fc) {
        return (BCM_E_PARAM);
    }

    max_pipes = stage_fc->num_pipes;
    for (pipe = 0; pipe < max_pipes; pipe++ ) {
        if (NULL == stage_fc->_field_32_counters[pipe] ||
            NULL == stage_fc->_field_64_counters[pipe])
            return BCM_E_UNAVAIL;
    }

    /* Get counters memory for the stage. */
    rv = _bcm_field_th_multi_pipe_counter_mem_get(unit, stage_fc,
                                                     counter_mem);
    BCM_IF_ERROR_RETURN(rv);

    for (pipe = 0; pipe < max_pipes; pipe++ ) {
        if (INVALIDm != counter_mem[pipe]) {
        BCM_IF_ERROR_RETURN
            (_field_th_multi_pipe_mem_counters_read(unit, counter_mem[pipe],
                                                 pipe, stage_fc));
        }
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_th_field_counter_config_set
 * Description:
 *     To set the SOC configuration for EFP counters.
 * Parameters:
 *     unit     - (IN) BCM device number.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 *     Field module must perform 2 steps to start the counter module to
 *     start performing the DMA.
 *     1. Enable the DMA for the respective counter (Both PKT/BYTE)
 *     2. Setup a DMA profile.
 */

int
_bcm_th_field_counter_config_set(int unit)
{
    int rv;
    int count;
    soc_ctr_control_info_t ctrl_info;
    soc_ctr_ctrl_config_t  ctrl_config;

    ctrl_info.instance_type = SOC_CTR_INSTANCE_TYPE_PIPE;
    ctrl_info.instance = -1;
    ctrl_config.config_type = SOC_CTR_CTRL_CONFIG_DMA_ENABLE;
    ctrl_config.config_val = 1; /* Enable DMA */
    count = 1;
    rv = soc_counter_config_multi_set(unit, SOC_COUNTER_NON_DMA_EFP_PKT,
                                      count, &ctrl_info, &ctrl_config);
    BCM_IF_ERROR_RETURN(rv);

    rv = soc_counter_config_multi_set(unit, SOC_COUNTER_NON_DMA_EFP_BYTE,
                                  count, &ctrl_info, &ctrl_config);

    BCM_IF_ERROR_RETURN(rv);

    ctrl_config.config_type = SOC_CTR_CTRL_CONFIG_DMA_RATE_PROFILE_ALL;
    ctrl_config.config_val = 1; /* Enable ALL profiles for EFP_PKT */
    rv = soc_counter_config_multi_set (unit, SOC_COUNTER_NON_DMA_EFP_PKT,
                                       count, &ctrl_info, &ctrl_config);

    BCM_IF_ERROR_RETURN(rv);

    rv = soc_counter_config_multi_set(unit, SOC_COUNTER_NON_DMA_EFP_BYTE,
                                  count, &ctrl_info, &ctrl_config);
    return rv;
}

              /*  END OF COUNTER ROUTINES */

              /*  START OF POLICER ROUTINES */
/*
 * Function:
 *     _bcm_field_th_policer_mem_get
 * Purpose:
 *     Get policer table name.
 * Parameters:
 *     unit         - (IN)  BCM device number
 *     stage_fc     - (IN)  Field Processor stage control structure.
 *     counter_mem  - (OUT) pointer to array of counter memories.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_policer_mem_get(int unit,
                              _field_stage_t *stage_fc,
                              int instance,
                              soc_mem_t *policer_mem)
{
    int pipe;
    soc_mem_t mem = INVALIDm;

    if (NULL == policer_mem || NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    pipe = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
               _FP_GLOBAL_INST : instance;

    *policer_mem = INVALIDm;

    switch (stage_fc->stage_id) {
      case _BCM_FIELD_STAGE_INGRESS:
      case _BCM_FIELD_STAGE_EXACTMATCH:
          mem = IFP_METER_TABLEm;
          break;
      case _BCM_FIELD_STAGE_EGRESS:
          mem = EFP_METER_TABLEm;
          break;
      default:
          return (BCM_E_INTERNAL);
    }

    /* Retrieve meter table name. */
    return (_bcm_field_mem_instance_get(unit, mem, pipe, policer_mem));
}

/*
 * Function:
 *     _bcm_field_th_policer_install
 * Purpose:
 *     Install a meter pair into the hardware tables.
 * Parameters:
 *     unit   - (IN) BCM device number.
 *     f_ent  - (IN) Field entry.
 *     f_pl   - (IN) Field policer descriptor.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_policer_install(int unit, _field_entry_t *f_ent,
                               _field_policer_t *f_pl)
{
    int       refresh_bitsize;          /* Number of bits for the
                                           refresh rate field.                */
    int       bucket_max_bitsize;       /* Number of bits for the
                                           bucket max field.                  */
    int       rv;                       /* Operation return status.           */
    int       multi_factor;             /* Multiple Factor. */
    uint32    bucketsize_peak = 0;      /* Bucket size.                       */
    uint32    refresh_rate_peak = 0;    /* Policer refresh rate.              */
    uint32    granularity_peak = 0;     /* Policer granularity.               */
    uint32    bucketsize_commit = 0;    /* Bucket size.                       */
    uint32    refresh_rate_commit = 0;  /* Policer refresh rate.              */
    uint32    granularity_commit = 0;   /* Policer granularity.               */
    uint32    flags;                    /* Policer flags.                     */
    soc_mem_t policer_mem;              /* Meter table name.                  */
    _field_stage_t *stage_fc;           /* Stage Field control structure.     */

    /* Input parameters check. */
    if ((NULL == f_ent) || (NULL == f_pl)) {
        return (BCM_E_PARAM);
    }

    if (NULL == f_ent->group || NULL == f_ent->fs) {
        return (BCM_E_INTERNAL);
    }

    if (0 == (f_pl->hw_flags & _FP_POLICER_DIRTY)) {
        return (BCM_E_NONE);
    }


    rv = _field_stage_control_get (unit, f_ent->fs->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Resolve meter table name. */
    rv = _bcm_field_th_policer_mem_get(unit, stage_fc, f_ent->group->instance,
                                       &policer_mem);
    BCM_IF_ERROR_RETURN(rv);

    refresh_bitsize = soc_mem_field_length(unit, policer_mem, REFRESHCOUNTf);
    bucket_max_bitsize = soc_mem_field_length(unit, policer_mem, BUCKETSIZEf);

    /* lookup bucket size from tables */
    flags = _BCM_XGS_METER_FLAG_GRANULARITY | _BCM_XGS_METER_FLAG_FP_POLICER;

    /* TD2/TH has change in granularity calculation */
    if (f_pl->cfg.flags & BCM_POLICER_MODE_PACKETS) {
        flags = flags | _BCM_XGS_METER_FLAG_FP_TD2_POLICER;
    }

    /* Set packet mode flags setting */
    if (f_pl->cfg.flags & BCM_POLICER_MODE_PACKETS) {
        flags |= _BCM_XGS_METER_FLAG_PACKET_MODE;
    } else {
        flags &= ~_BCM_XGS_METER_FLAG_PACKET_MODE;
    }

    /* In Tomahawk EFP metering, Refresh tick duration has changed from
     * 7.8125us to 15.625us ,but the RTL does not double the REFRESHCOUNT
     * while putting the tokens into the bucket which is causing 50% lesser
     * traffic rate than expected. So the work around is the value programmed
     * from software in EFP meters needs to be doubled.
     *
     * In TH2, refresh tick is still 15.625 usec, but EFRESHCOUNT is doubled
     * in HW before adding to the bucket per refresh
     */

    multi_factor = 1;
    if (SOC_IS_TOMAHAWK(unit) &&
        (_BCM_FIELD_STAGE_EGRESS == stage_fc->stage_id)) {
        multi_factor = 2;
        refresh_bitsize--;
    }

    if (f_pl->cfg.mode  != bcmPolicerModeSrTcm) {
        if (f_pl->hw_flags & _FP_POLICER_COMMITTED_DIRTY) {
            /* Calculate policer bucket size/refresh_rate/granularity. */
            rv = _bcm_xgs_kbits_to_bucket_encoding(f_pl->cfg.ckbits_sec,
                                                   f_pl->cfg.ckbits_burst,
                                                   flags, refresh_bitsize,
                                                   bucket_max_bitsize,
                                                   &refresh_rate_commit,
                                                   &bucketsize_commit,
                                                   &granularity_commit);

            if ((INVALIDm != policer_mem) && BCM_SUCCESS(rv)) {
                /* Programm policer parameters into hw. */
                rv =  _bcm_field_trx_policer_hw_update(unit, f_ent, f_pl,
                                                  BCM_FIELD_METER_COMMITTED,
                                                  bucketsize_commit,
                                                  (refresh_rate_commit *
                                                   multi_factor),
                                                  granularity_commit,
                                                  policer_mem);
                BCM_IF_ERROR_RETURN(rv);

            }
            f_pl->hw_flags &= ~_FP_POLICER_COMMITTED_DIRTY;
        }

        if (f_pl->hw_flags & _FP_POLICER_PEAK_DIRTY) {

            if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
                /*
                 * Rates are always set in committed variables,
                 * for flow meters.
                 */
                f_pl->cfg.pkbits_sec = f_pl->cfg.ckbits_sec;
                f_pl->cfg.pkbits_burst = f_pl->cfg.ckbits_burst;
            }

            /* Calculate policer bucket size/refresh_rate/granularity. */
            rv = _bcm_xgs_kbits_to_bucket_encoding(f_pl->cfg.pkbits_sec,
                                                   f_pl->cfg.pkbits_burst,
                                                   flags,
                                                   refresh_bitsize,
                                                   bucket_max_bitsize,
                                                   &refresh_rate_peak,
                                                   &bucketsize_peak,
                                                   &granularity_peak);

            if ((INVALIDm != policer_mem) && BCM_SUCCESS(rv)) {
                /* Programm policer parameters into hw. */
                rv =  _bcm_field_trx_policer_hw_update(unit, f_ent, f_pl,
                                                       BCM_FIELD_METER_PEAK,
                                                       bucketsize_peak,
                                                       (refresh_rate_peak *
                                                        multi_factor),
                                                       granularity_peak,
                                                       policer_mem);
                BCM_IF_ERROR_RETURN(rv);

            }

            f_pl->hw_flags &= ~_FP_POLICER_PEAK_DIRTY;

            if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
                /* Reset peak meter rates. */
                f_pl->cfg.pkbits_sec = 0;
                f_pl->cfg.pkbits_burst = 0;
            }
        }
    } else {
        if (f_pl->hw_flags & _FP_POLICER_COMMITTED_DIRTY) {
            /* Calculate policer bucket size/refresh_rate/granularity. */
            rv = _bcm_xgs_kbits_to_bucket_encoding(f_pl->cfg.ckbits_sec,
                                                   f_pl->cfg.ckbits_burst,
                                                   flags, refresh_bitsize,
                                                   bucket_max_bitsize,
                                                   &refresh_rate_commit,
                                                   &bucketsize_commit,
                                                   &granularity_commit);
            BCM_IF_ERROR_RETURN(rv);
        }

        if (f_pl->hw_flags & _FP_POLICER_PEAK_DIRTY) {
            /* Calculate policer bucket size/refresh_rate/granularity. */
            rv = _bcm_xgs_kbits_to_bucket_encoding(f_pl->cfg.pkbits_sec,
                                                   f_pl->cfg.pkbits_burst,
                                                   flags,
                                                   refresh_bitsize,
                                                   bucket_max_bitsize,
                                                   &refresh_rate_peak,
                                                   &bucketsize_peak,
                                                   &granularity_peak);
            BCM_IF_ERROR_RETURN(rv);
        }

        if (granularity_commit != granularity_peak) {
            if (granularity_commit < granularity_peak) {
                rv = _bcm_xgs_kbits_to_dual_bucket_encoding(
                                                         f_pl->cfg.ckbits_sec,
                                                         f_pl->cfg.ckbits_burst,
                                                         flags,
                                                         refresh_bitsize,
                                                         bucket_max_bitsize,
                                                         granularity_peak,
                                                         &refresh_rate_commit,
                                                         &bucketsize_commit,
                                                         &granularity_commit);
            } else if (granularity_commit > granularity_peak) {
                rv = _bcm_xgs_kbits_to_dual_bucket_encoding(
                                                         f_pl->cfg.pkbits_sec,
                                                         f_pl->cfg.pkbits_burst,
                                                         flags,
                                                         refresh_bitsize,
                                                         bucket_max_bitsize,
                                                         granularity_commit,
                                                         &refresh_rate_peak,
                                                         &bucketsize_peak,
                                                         &granularity_peak);
            }
            BCM_IF_ERROR_RETURN(rv);
        }


        if ((INVALIDm != policer_mem) && BCM_SUCCESS(rv)) {
            /* Programm policer parameters into hw. */
            rv =  _bcm_field_trx_policer_hw_update(unit, f_ent, f_pl,
                                                  BCM_FIELD_METER_COMMITTED,
                                                  bucketsize_commit,
                                                  (refresh_rate_commit *
                                                   multi_factor),
                                                  granularity_commit,
                                                  policer_mem);
            BCM_IF_ERROR_RETURN(rv);
        }

        f_pl->hw_flags &= ~_FP_POLICER_COMMITTED_DIRTY;

        if ((INVALIDm != policer_mem) && BCM_SUCCESS(rv)) {
            /* Programm policer parameters into hw. */
            rv =  _bcm_field_trx_policer_hw_update(unit, f_ent, f_pl,
                                                 BCM_FIELD_METER_PEAK,
                                                 bucketsize_peak,
                                                 (refresh_rate_peak *
                                                  multi_factor),
                                                 granularity_peak,
                                                 policer_mem);
            BCM_IF_ERROR_RETURN(rv);
        }

        f_pl->hw_flags &= ~_FP_POLICER_PEAK_DIRTY;
    }

    /* Update current policer counters from hw */
    rv = _field_entry_policer_update_actual_hw_rates(unit, policer_mem,
            f_ent->group->instance, f_ent, f_pl);

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_th_policer_meter_hw_free
 *
 * Purpose:
 *     Clear the meter entries from the h/w associated with the policer
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     level     - (IN) Policer level.
 *     f_ent     - (IN) Entry policer belongs to.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_policer_meter_hw_free(int unit, _field_entry_t *f_ent,
                                 _field_entry_policer_t *f_ent_pl)
{
    int                rv = BCM_E_NONE; /* Return value                  */
    int                idx;             /* Meter hw index                */
    soc_mem_t          policer_mem;     /* Meter table identifier.       */
    _field_meter_pool_t *mp;            /* Meter pool pointer.           */
    _field_slice_t *fs;                 /* Field slice pointer.          */
    _field_stage_t    *stage_fc;        /* Stage field control structure */
    _field_policer_t  *f_pl;            /* Policer descriptor            */
    _field_stage_id_t stage_id;         /* Stage id used for metering.   */

    stage_id = (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id) ? \
                   _BCM_FIELD_STAGE_INGRESS : f_ent->group->stage_id;

    /* Get field stage control structure. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, stage_id,
                                        &stage_fc));

    /* Resolve meter table name. */
    rv = _bcm_field_th_policer_mem_get(unit, stage_fc, f_ent->group->instance, &policer_mem);
    BCM_IF_ERROR_RETURN(rv);

    /* Read policer configuration.*/
    BCM_IF_ERROR_RETURN
        (_bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl));

    /* Must be a valid meter index. */
    if (f_pl->hw_index == _FP_INVALID_INDEX) {
        return (BCM_E_INTERNAL);
    }

    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        mp = stage_fc->meter_pool[f_ent->group->instance][f_pl->pool_index];
        /* Get slice policer installed in. */
        idx =  (f_pl->pool_index * mp->pool_size) + (2 * f_pl->hw_index);

    } else {
        fs = stage_fc->slices[f_ent->group->instance] + f_pl->pool_index;
        idx = fs->start_tcam_idx +  (2 * f_pl->hw_index);
    }

    if (idx < soc_mem_index_min(unit, policer_mem) ||
        idx > soc_mem_index_max(unit, policer_mem)) {
        return (BCM_E_INTERNAL);
    }

    if (!_FP_POLICER_IS_FLOW_MODE(f_pl)) {
        rv = soc_th_ifp_mem_write(unit, policer_mem, MEM_BLOCK_ALL,
                idx, soc_mem_entry_null(unit, policer_mem));
        BCM_IF_ERROR_RETURN(rv);

        idx++;
        rv = soc_th_ifp_mem_write(unit, policer_mem, MEM_BLOCK_ALL,
                idx, soc_mem_entry_null(unit, policer_mem));
    } else {
        if (_FP_POLICER_COMMITTED_HW_METER(f_pl)) {
            idx ++;
        }

        rv = soc_th_ifp_mem_write(unit, policer_mem, MEM_BLOCK_ALL,
                idx, soc_mem_entry_null(unit, policer_mem));
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_policer_meter_hw_free_old
 *
 * Purpose:
 *     Clear the meter entries from the h/w associated with the policer
 *     priori to calling bem_policer_set API
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     level     - (IN) Policer level.
 *     f_ent     - (IN) Entry policer belongs to.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_policer_meter_hw_free_old(int unit, _field_entry_t *f_ent,
                                 _field_entry_policer_t *f_ent_pl)
{
    int                rv = BCM_E_NONE; /* Return value                  */
    int                idx;             /* Meter hw index                */
    soc_mem_t          policer_mem;     /* Meter table identifier.       */
    _field_meter_pool_t *mp;            /* Meter pool pointer.           */
    _field_slice_t *fs;                 /* Field slice pointer.          */
    _field_stage_t    *stage_fc;        /* Stage field control structure */
    _field_policer_t  *f_pl;            /* Policer descriptor            */
    _field_stage_id_t stage_id;         /* Stage id used for metering.   */

    stage_id = (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id) ? \
                   _BCM_FIELD_STAGE_INGRESS : f_ent->group->stage_id;

    /* Get field stage control structure. */
    BCM_IF_ERROR_RETURN
        (_field_stage_control_get(unit, stage_id,
                                        &stage_fc));

    /* Resolve meter table name. */
    rv = _bcm_field_th_policer_mem_get(unit, stage_fc, f_ent->group->instance, &policer_mem);
    BCM_IF_ERROR_RETURN(rv);

    /* Read policer configuration.*/
    BCM_IF_ERROR_RETURN
        (_bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl));

    /* Must be a valid meter index. */
    if (f_pl->old_hw_index == _FP_INVALID_INDEX) {
        return (BCM_E_INTERNAL);
    }

    if (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) {
        mp = stage_fc->meter_pool[f_ent->group->instance][f_pl->old_pool_index];
        /* Get slice policer installed in. */
        idx =  (f_pl->old_pool_index * mp->pool_size) + (2 * f_pl->old_hw_index);

    } else {
        fs = stage_fc->slices[f_ent->group->instance] + f_pl->old_pool_index;
        idx = fs->start_tcam_idx +  (2 * f_pl->old_hw_index);
    }

    if (idx < soc_mem_index_min(unit, policer_mem) ||
        idx > soc_mem_index_max(unit, policer_mem)) {
        return (BCM_E_INTERNAL);
    }

    if (bcmPolicerModeCommitted != (f_pl)->old_mode) {
        rv = soc_th_ifp_mem_write(unit, policer_mem, MEM_BLOCK_ALL,
                idx, soc_mem_entry_null(unit, policer_mem));
        BCM_IF_ERROR_RETURN(rv);

        idx++;
        rv = soc_th_ifp_mem_write(unit, policer_mem, MEM_BLOCK_ALL,
                idx, soc_mem_entry_null(unit, policer_mem));
    } else {
        if ((bcmPolicerModeCommitted == (f_pl)->old_mode) &&
                  (!((f_pl)->old_hw_flags & _FP_POLICER_EXCESS_METER))) {
            idx ++;
        }
        rv = soc_th_ifp_mem_write(unit, policer_mem, MEM_BLOCK_ALL,
                idx, soc_mem_entry_null(unit, policer_mem));
    }

    return (BCM_E_NONE);
}
         /* END OF POLICER ROUTINES */


/*
 * Function:
 *    _field_th_hw_clear
 *
 * Purpose:
 *    Clear hardware memories for the requested stage.
 *
 * Parameters:
 *    unit - (IN) BCM device number.
 *    stage_fc - (IN) Field Processor stage control structure.
 *
 * Returns:
 *    BCM_E_INTERNAL - Invalid CAP stage.
 *    BCM_E_NONE - Success.
 */
STATIC int
_field_th_hw_clear(int unit, _field_stage_t *stage_fc, _field_control_t *fc)
{
    int pipe = 0;
    soc_mem_t fp_tcam;

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_NONE);
    }

    /*
     * Note: DO NOT CLEAR HW tables when in warm boot mode.
     * If HW tables are cleared, there is no configuration available in hardware
     * to perform Level2 or Level1 WB recovery
     */
    if (SOC_WARM_BOOT(unit)) {
        return (BCM_E_NONE);
    }

    switch (stage_fc->stage_id) {
        case _BCM_FIELD_STAGE_INGRESS:
            if (soc_feature(unit, soc_feature_udf_support) && UDF_CTRL(unit)) {
                if (UDF_CTRL(unit)->udf_used_by_module == UDF_USED_BY_FIELD_MODULE) {
                    BCM_IF_ERROR_RETURN(soc_mem_clear(unit, FP_UDF_TCAMm, COPYNO_ALL,
                                TRUE));
                    BCM_IF_ERROR_RETURN(soc_mem_clear(unit, FP_UDF_OFFSETm, COPYNO_ALL,
                                TRUE));
                }
            }

            if (RANGE_CTRL(unit)) {
                if (!RANGE_CTRL(unit)->range_used_by_module) {
                    BCM_IF_ERROR_RETURN(soc_mem_clear(unit, IFP_RANGE_CHECKm,
                                                          COPYNO_ALL, TRUE));
                }
            } else {
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, IFP_RANGE_CHECKm,
                                                      COPYNO_ALL, TRUE));
            }

            if (soc_property_get(unit, spn_FIELD_ATOMIC_UPDATE, FALSE) == TRUE) {
#if defined (BCM_TOMAHAWK3_SUPPORT)
               if (SOC_IS_TOMAHAWK3(unit)) {
                   BCM_IF_ERROR_RETURN(soc_mem_clear(unit, IFP_TCAMm,
                                       COPYNO_ALL, TRUE));
               } else
#endif
               {
                   BCM_IF_ERROR_RETURN(soc_mem_clear(unit, IFP_TCAM_WIDEm,
                                       COPYNO_ALL, TRUE));
               }

            } else {
               for (pipe = 0; pipe < stage_fc->num_pipes; pipe++) {
                   if (!(fc->pipe_map & (1 << pipe))) {
                        continue;
                   }
#if defined (BCM_TOMAHAWK3_SUPPORT)
                   if (soc_feature(unit, soc_feature_th3_style_fp)) {
                       BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                           IFP_TCAMm,
                                                           pipe,
                                                           &fp_tcam));
                   } else
#endif
                   {
                       BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                           IFP_TCAM_WIDEm,
                                                           pipe,
                                                           &fp_tcam));
                   }
                   BCM_IF_ERROR_RETURN(soc_mem_clear(unit, fp_tcam,
                                       COPYNO_ALL, TRUE));
               }
            }
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, IFP_POLICY_TABLEm,
                COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, IFP_LOGICAL_TABLE_SELECTm,
                COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                IFP_KEY_GEN_PROGRAM_PROFILEm, COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                IFP_KEY_GEN_PROGRAM_PROFILE2m, COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                IFP_LOGICAL_TABLE_ACTION_PRIORITYm, COPYNO_ALL, TRUE));
            break;
        case _BCM_FIELD_STAGE_LOOKUP:
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, VFP_TCAMm, COPYNO_ALL,
                TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, VFP_POLICY_TABLEm,
                COPYNO_ALL, TRUE));
            /*
             * Group destroy done as part of Field Deinit "bcm_esw_field_detach"
             * clears following registers:
             *     VFP_KEY_CONTROL_1
             *     VFP_KEY_CONTROL_2
             *     VFP_SLICE_MAP
             */
            break;
        case _BCM_FIELD_STAGE_EGRESS:
             for (pipe = 0; pipe < stage_fc->num_pipes; pipe++) {
                   if (!(fc->pipe_map & (1 << pipe))) {
                        continue;
                   }
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit, EFP_COUNTER_TABLEm,
                                                               pipe,
                                                               &fp_tcam));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, fp_tcam,
                    COPYNO_ALL, TRUE));
            }
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, EFP_TCAMm, COPYNO_ALL,
                TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, EFP_POLICY_TABLEm,
                COPYNO_ALL, TRUE));
            if (soc_feature(unit, soc_feature_field_egress_metering)) {
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, EFP_METER_TABLEm,
                    COPYNO_ALL, TRUE));
            }

            break;
        case _BCM_FIELD_STAGE_CLASS:
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, TCP_FNm, COPYNO_ALL,
                        TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, TOS_FNm, COPYNO_ALL,
                        TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, TTL_FNm, COPYNO_ALL,
                        TRUE));
            if (!SOC_IS_TOMAHAWK3(unit)) {
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, SRC_COMPRESSIONm, COPYNO_ALL,
                            TRUE));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, DST_COMPRESSIONm, COPYNO_ALL,
                            TRUE));
            }
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, IP_PROTO_MAPm, COPYNO_ALL,
                        TRUE));
            break;
        case _BCM_FIELD_STAGE_EXACTMATCH:
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                        EXACT_MATCH_LOGICAL_TABLE_SELECTm, COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                        EXACT_MATCH_KEY_GEN_MASKm, COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                        EXACT_MATCH_DEFAULT_POLICYm, COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                        EXACT_MATCH_KEY_GEN_PROGRAM_PROFILEm, COPYNO_ALL, TRUE));
            if(!SAL_BOOT_PLISIM) {
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                                    EXACT_MATCH_2m, COPYNO_ALL, TRUE));
            }
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                        EXACT_MATCH_ACTION_PROFILEm, COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                        EXACT_MATCH_QOS_ACTIONS_PROFILEm, COPYNO_ALL, TRUE));
            break;
#if defined(BCM_FLOWTRACKER_SUPPORT)
        case _BCM_FIELD_STAGE_FLOWTRACKER:
            if (!soc_feature(unit, soc_feature_field_flowtracker_support)) {
                break;
            }
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP_LTS_LOGICAL_TBL_SEL_TCAMm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP_LTS_LOGICAL_TBL_SEL_SRAMm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP_LTS_MUX_CTRL_0m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP_LTS_MASK_0m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP_LTS_MUX_CTRL_1m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP_LTS_MASK_1m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP_LTS_MUX_CTRL_2_PLUS_MASKm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP_TCAMm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP_POLICYm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_SESSION_KEY_LTS_MUX_CTRL_0m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_SESSION_KEY_LTS_MASK_0m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_SESSION_KEY_LTS_MUX_CTRL_1m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_SESSION_KEY_LTS_MASK_1m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_SESSION_KEY_LTS_MUX_CTRL_2_PLUS_MASKm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_SESSION_DATA_LTS_MUX_CTRL_0m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_SESSION_DATA_LTS_MASK_0m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_SESSION_DATA_LTS_MUX_CTRL_1_PLUS_MASKm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_ALU_DATA_LTS_MUX_CTRL_PLUS_MASKm,
                        COPYNO_ALL, TRUE));
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
            if (!soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
                break;
            }
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP2_LTS_LOGICAL_TBL_SEL_TCAMm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP2_LTS_LOGICAL_TBL_SEL_SRAMm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP2_LTS_MUX_CTRL_0m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP2_LTS_MASK_0m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP2_LTS_MUX_CTRL_1m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP2_LTS_MASK_1m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP2_LTS_MUX_CTRL_2_PLUS_MASKm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP2_TCAMm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_FTFP2_POLICYm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_SESSION_DATA2_LTS_MUX_CTRL_0m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_SESSION_DATA2_LTS_MASK_0m,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_SESSION_DATA2_LTS_MUX_CTRL_1_PLUS_MASKm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_ALU_DATA2_LTS_MUX_CTRL_PLUS_MASKm,
                        COPYNO_ALL, TRUE));
#endif
            break;
#endif
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
        case _BCM_FIELD_STAGE_AMFTFP:
            if (!soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
                break;
            }
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_AMFP_TCAMm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_AMFP_POLICYm,
                        COPYNO_ALL, TRUE));
            break;
        case _BCM_FIELD_STAGE_AEFTFP:
            if (!soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
                break;
            }
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_AEFP_TCAMm,
                        COPYNO_ALL, TRUE));
            BCM_IF_ERROR_RETURN(soc_mem_clear(unit, BSK_AEFP_POLICYm,
                        COPYNO_ALL, TRUE));
            break;
#endif
        default:
            /* Should never hit this default condition. */
            return (BCM_E_INTERNAL);

    } /* end switch */

    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_pipes_hw_clear
 *
 * Purpose:
 *    Clear hardware memories for a requested stage on all pipes.
 *
 * Parameters:
 *    unit - (IN) BCM device number
 *    stage_fc - (IN) Field Processor stage control structure.
 *
 * Returns:
 *    BCM_E_INTERNAL - Invalid CAP stage.
 *    BCM_E_NONE - Success.
 */
STATIC int
_field_th_pipes_hw_clear(int unit, _field_stage_t *stage_fc,
                         _field_control_t *fc)
{
    int pipe; /* Pipe iterator. */
    soc_mem_t vfp_tcam; /* VFP TCAM memory names. */
    soc_mem_t vfp_policy; /* VFP POLICY table memory names. */
    soc_mem_t rcheck; /* IFP range checker memory names. */
    soc_mem_t fp_tcam;/* IFP TCAM memory names. */
    soc_mem_t fp_policy;  /* IFP POLICY memory names. */
    soc_mem_t lt_tcam; /* LT selection TCAM memory names. */
    soc_mem_t kgen_prof1; /* Keygen program memory names. */
    soc_mem_t kgen_prof2; /* Keygen program memory names. */
    soc_mem_t action_pri; /* LT priority memory names. */
    soc_mem_t efp_tcam; /* EFP TCAM memory names. */
    soc_mem_t efp_policy;  /* EFP policy memory names. */
    soc_mem_t efp_meter; /* EFP meter memory names. */
    soc_mem_t efp_cntr; /* EFP counter memory names. */
    soc_mem_t ttl_fn ; /* Class TTL memory names. */
    soc_mem_t tos_fn; /* Class TOS memory names. */
    soc_mem_t tcp_fn; /* Class TCP memory names. */
    soc_mem_t src_compress; /* Class Src Compression memory names. */
    soc_mem_t dst_compress; /* Class Dst Compression memory names. */
    soc_mem_t ip_proto_map; /* IP Protocol Map Memory names. */
    soc_mem_t lt_em_tcam;
    soc_mem_t lt_em_kgen_mask;
    soc_mem_t lt_em_def_policy;
    soc_mem_t kgen_em_prof;
    soc_mem_t em_act_prof;
    soc_mem_t em_qos_act_prof;
    soc_mem_t em_uft_wide;
    soc_mem_t em_uft_narrow;

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_NONE);
    }

    /*
     * Note: DO NOT CLEAR HW tables when in warm boot mode.
     * If HW tables are cleared, there is no configuration available in hardware
     * to perform Level2 or Level1 WB recovery
     */
    if (SOC_WARM_BOOT(unit)) {
        return (BCM_E_NONE);
    }

    switch (stage_fc->stage_id) {
        case _BCM_FIELD_STAGE_INGRESS:
            if (RANGE_CTRL(unit)) {
                if (!RANGE_CTRL(unit)->range_used_by_module) {
                    for (pipe = 0; pipe < stage_fc->num_pipes; pipe++) {
                        if (!(fc->pipe_map & (1 << pipe))) {
                             continue;
                        }
                        BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                            IFP_RANGE_CHECKm,
                                                            pipe,
                                                            &rcheck));
                        BCM_IF_ERROR_RETURN(soc_mem_clear(unit, rcheck,
                                                          COPYNO_ALL, TRUE));
                    }
                }
            } else {
                for (pipe = 0; pipe < stage_fc->num_pipes; pipe++) {
                    if (!(fc->pipe_map & (1 << pipe))) {
                         continue;
                    }
                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                        IFP_RANGE_CHECKm,
                                                        pipe,
                                                        &rcheck));
                    BCM_IF_ERROR_RETURN(soc_mem_clear(unit, rcheck,
                                                       COPYNO_ALL, TRUE));
                }
            }

            for (pipe = 0; pipe < stage_fc->num_pipes; pipe++) {
                if (!(fc->pipe_map & (1 << pipe))) {
                     continue;
                }
#if defined (BCM_TOMAHAWK3_SUPPORT)
                if (soc_feature(unit, soc_feature_th3_style_fp)) {
                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                           IFP_TCAMm,
                                                           pipe,
                                                           &fp_tcam));
                } else
#endif
                {
                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                           IFP_TCAM_WIDEm,
                                                           pipe,
                                                           &fp_tcam));
                }
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, fp_tcam,
                    COPYNO_ALL, TRUE));
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       IFP_POLICY_TABLEm,
                                                       pipe,
                                                       &fp_policy));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, fp_policy,
                    COPYNO_ALL, TRUE));
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                     IFP_LOGICAL_TABLE_SELECTm,
                                                     pipe,
                                                     &lt_tcam));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, lt_tcam,
                    COPYNO_ALL, TRUE));
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                   IFP_KEY_GEN_PROGRAM_PROFILEm,
                                                   pipe,
                                                   &kgen_prof1));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, kgen_prof1,
                    COPYNO_ALL, TRUE));
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                  IFP_KEY_GEN_PROGRAM_PROFILE2m,
                                                  pipe,
                                                  &kgen_prof2));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, kgen_prof2,
                    COPYNO_ALL, TRUE));
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                             IFP_LOGICAL_TABLE_ACTION_PRIORITYm,
                                             pipe,
                                             &action_pri));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, action_pri,
                    COPYNO_ALL, TRUE));
            }
            /*
             * Currently Field module doesn't support per-pipe mode for UDF.
             * Hence, accessing the memory globally.
             */
            if (soc_feature(unit, soc_feature_udf_support) && UDF_CTRL(unit)) {
                if (UDF_CTRL(unit)->udf_used_by_module
                    == UDF_USED_BY_FIELD_MODULE) {
                    BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                                FP_UDF_TCAMm, COPYNO_ALL,
                                TRUE));
                    BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                                FP_UDF_OFFSETm, COPYNO_ALL,
                                TRUE));
                }
            }
            break;
        case _BCM_FIELD_STAGE_LOOKUP:
            for (pipe = 0; pipe < stage_fc->num_pipes; pipe++) {
                if (!(fc->pipe_map & (1 << pipe))) {
                     continue;
                }
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       VFP_TCAMm,
                                                       pipe, &vfp_tcam));
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       VFP_POLICY_TABLEm,
                                                       pipe,
                                                       &vfp_policy));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, vfp_tcam,
                    COPYNO_ALL, TRUE));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, vfp_policy,
                    COPYNO_ALL, TRUE));
            }
            break;
        case _BCM_FIELD_STAGE_EGRESS:
            for (pipe = 0; pipe < stage_fc->num_pipes; pipe++) {
                if (!(fc->pipe_map & (1 << pipe))) {
                     continue;
                }
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       EFP_TCAMm,
                                                       pipe, &efp_tcam));
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       EFP_POLICY_TABLEm,
                                                       pipe,
                                                       &efp_policy));
                if (soc_feature(unit, soc_feature_field_egress_metering)) {

                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                           EFP_METER_TABLEm,
                                                           pipe, &efp_meter));
                }
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       EFP_COUNTER_TABLEm,
                                                       pipe,
                                                       &efp_cntr));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, efp_tcam,
                    COPYNO_ALL, TRUE));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, efp_policy,
                    COPYNO_ALL, TRUE));
                if (soc_feature(unit, soc_feature_field_egress_metering)) {
                    BCM_IF_ERROR_RETURN(soc_mem_clear(unit, efp_meter,
                        COPYNO_ALL, TRUE));
                }
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, efp_cntr,
                    COPYNO_ALL, TRUE));
            }
            break;
        case _BCM_FIELD_STAGE_CLASS:
            for (pipe = 0; pipe < stage_fc->num_pipes; pipe++) {
                if (!(fc->pipe_map & (1 << pipe))) {
                     continue;
                }
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       TTL_FNm,
                                                       pipe,
                                                       &ttl_fn));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, ttl_fn,
                            COPYNO_ALL, TRUE));
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       TOS_FNm,
                                                       pipe,
                                                       &tos_fn));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, tos_fn,
                            COPYNO_ALL, TRUE));
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       TCP_FNm,
                                                       pipe,
                                                       &tcp_fn));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, tcp_fn,
                            COPYNO_ALL, TRUE));
                if (!(SOC_IS_TOMAHAWK3(unit))) {
                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                           SRC_COMPRESSIONm,
                                                           pipe,
                                                           &src_compress));
                    BCM_IF_ERROR_RETURN(soc_mem_clear(unit, src_compress,
                                COPYNO_ALL, TRUE));
                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                           DST_COMPRESSIONm,
                                                           pipe,
                                                           &dst_compress));
                    BCM_IF_ERROR_RETURN(soc_mem_clear(unit, dst_compress,
                                COPYNO_ALL, TRUE));
                }
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       IP_PROTO_MAPm,
                                                       pipe,
                                                       &ip_proto_map));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit, ip_proto_map,
                            COPYNO_ALL, TRUE));
            }
            break;
        case _BCM_FIELD_STAGE_EXACTMATCH:
            for (pipe = 0; pipe < stage_fc->num_pipes; pipe++) {
                if (!(fc->pipe_map & (1 << pipe))) {
                     continue;
                }
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                           EXACT_MATCH_LOGICAL_TABLE_SELECTm,
                                           pipe,
                                           &lt_em_tcam));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                            lt_em_tcam, COPYNO_ALL, TRUE));
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                           EXACT_MATCH_KEY_GEN_MASKm,
                                           pipe,
                                           &lt_em_kgen_mask));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                            lt_em_kgen_mask, COPYNO_ALL, TRUE));
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                           EXACT_MATCH_DEFAULT_POLICYm,
                                           pipe,
                                           &lt_em_def_policy));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                            lt_em_def_policy, COPYNO_ALL, TRUE));
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                           EXACT_MATCH_KEY_GEN_PROGRAM_PROFILEm,
                                           pipe,
                                           &kgen_em_prof));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                            kgen_em_prof, COPYNO_ALL, TRUE));
#if defined (BCM_TOMAHAWK3_SUPPORT)
                if (soc_feature(unit, soc_feature_th3_style_fp)) {
                    
                } else
#endif
                {
                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                        EXACT_MATCH_2m,
                                        pipe,
                                        &em_uft_narrow));
                    BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                                        em_uft_narrow, COPYNO_ALL, TRUE));
                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                        EXACT_MATCH_4m,
                                        pipe,
                                        &em_uft_wide));
                    BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                                        em_uft_wide, COPYNO_ALL, TRUE));
                }
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                    EXACT_MATCH_ACTION_PROFILEm,
                                    pipe,
                                    &em_act_prof));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                                    em_act_prof, COPYNO_ALL, TRUE));
                BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                    EXACT_MATCH_QOS_ACTIONS_PROFILEm,
                                    pipe,
                                    &em_qos_act_prof));
                BCM_IF_ERROR_RETURN(soc_mem_clear(unit,
                            em_qos_act_prof, COPYNO_ALL, TRUE));
            }
            break;
        default:
            /* Should never hit this default condition. */
            return (BCM_E_INTERNAL);

    } /* end switch */

    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_pipes_meter_refresh_enable
 *
 * Purpose:
 *    Enable meters refresh cycle on all pipes.
 *
 * Parameters:
 *    unit - (IN) BCM device number.
 *    fc - (IN) Field control structure.
 *    state  - (IN) On/Off boolean.
 *
 * Returns:
 *    BCM_E_PARAM - Null field control structure or invalid value for "state".
 *    BCM_E_INTERNAL - Null field stage control structure.
 *    BCM_E_NONE - Success.
 */
STATIC int
_field_th_pipes_meter_refresh_enable(int unit,
                                     _field_control_t *fc,
                                     uint32 state)
{
    int pipe; /* Pipe iterator. */
    _field_stage_t *stage_fc; /* Pointer to Stage control structure. */
    soc_reg_t reg; /* FP IP auxilary arbiter control register. */

      /* Input parameters check. */
    if (NULL == fc || ((TRUE != state) && (FALSE != state))) {
        return (BCM_E_PARAM);
    }


    /* Get the stage control handle. */
    stage_fc = fc->stages;

    /* Ensure stage data structure is initialized. */
    if (NULL == stage_fc) {
        return (BCM_E_INTERNAL);
    }

    /* Enable FP meter refresh in each pipe */
    for (pipe = 0; pipe < stage_fc->num_pipes; pipe++) {
        if (!(fc->pipe_map & (1 << pipe))) {
              continue;
         }
         BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                            AUX_ARB_CONTROLr,
                                                            pipe, &reg));
         BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit, reg,
            REG_PORT_ANY, FP_REFRESH_ENABLEf, state));
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *    _field_th_detach
 *
 * Purpose:
 *    Clears field module hardware tables based on Group operational mode.
 *    Also disables FP meter refresh and FP lookup control on ports.
 *
 * Parameters:
 *    unit - (IN) BCM device number
 *    fc - (IN) Field control structure.
 *
 * Returns:
 *    BCM_E_PARAM - Null field control structure.
 *    BCM_E_INTERNAL - Invalid CAP stage ID.
 *    BCM_E_NONE - Success.
 */
STATIC int
_field_th_detach(int unit, _field_control_t *fc)
{
    _field_stage_t *stage_fc; /* Stage control structure pointer. */

    /* Input parameters check. */
    if (NULL == fc) {
        return (BCM_E_PARAM);
    }

    /* Get the stage control handle. */
    stage_fc = fc->stages;

    /*
     * Initialize FP hardware tables based on the device Group Oper mode
     * settings.
     */
    switch (stage_fc->oper_mode) {
        case bcmFieldGroupOperModeGlobal:
            /* Legacy global mode, use DUPLICATE view to clear FP HW tables. */
            while (stage_fc) {

                /*
                 * Note : DO NOT CLEAR Exact Match HW tables if ExactMatch SKIP detach flag is set.
                 * Retaining ExactMatch groups during bcm_field_init for retaining ExactMatch stage.
                 */
                if ((fc->flags & _FP_EXACTMATCH_STAGE_SKIP_DETACH) &&
                    (_BCM_FIELD_STAGE_EXACTMATCH == stage_fc->stage_id)) {
                    /* Goto next stage */
                    stage_fc = stage_fc->next;
                    continue;
                }
                /* Clear hardware table */
                BCM_IF_ERROR_RETURN(_field_th_hw_clear(unit, stage_fc, fc));

                /* Goto next stage */
                stage_fc = stage_fc->next;
            }

            /* Disable FP meter refresh on all pipes. */
            if (!(soc_feature(unit, soc_feature_th3_style_fp))) {
                BCM_IF_ERROR_RETURN(_field_meter_refresh_enable_set(unit, fc,
                                                                    FALSE));
            }
            break;

        case bcmFieldGroupOperModePipeLocal:
            while (stage_fc) {
                /*
                 * Note : DO NOT CLEAR Exact Match HW tables if ExactMatch SKIP detach flag is set.
                 * Retaining ExactMatch groups during bcm_field_init for retaining ExactMatch stage.
                 */
                if ((fc->flags & _FP_EXACTMATCH_STAGE_SKIP_DETACH) &&
                    (_BCM_FIELD_STAGE_EXACTMATCH == stage_fc->stage_id)) {
                    /* Goto next stage */
                    stage_fc = stage_fc->next;
                    continue;
                }
                /* Clear hardware table */
                BCM_IF_ERROR_RETURN(_field_th_pipes_hw_clear(unit, stage_fc, fc));

                /* Goto next stage */
                stage_fc = stage_fc->next;
            }

            /* Enable FP meter refresh on all pipes. */
            if (!(soc_feature(unit, soc_feature_th3_style_fp))) {
                BCM_IF_ERROR_RETURN(_field_th_pipes_meter_refresh_enable(unit, fc,
                                                                         FALSE));
            }
            break;
        default:
            break;
    }

    /* Don't disable port controls during Warmboot or Reloading state */
    if (0 == SOC_HW_ACCESS_DISABLE(unit)) {
        /* Disable filter processor */
        BCM_IF_ERROR_RETURN(_field_port_filter_enable_set(unit, fc, FALSE));
    }

    /* Murthy: Check and disable any counter ejection support here. */

    return (BCM_E_NONE);
}
/*
 * Function:
 *     _field_th_egress_slice_clear
 *
 * Purpose:
 *     Reset slice configuraton on group deletion event.
 *
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     fg         - (IN) Reference to Field Group Structure.
 *     slice_numb - (IN) Slice number to set mode for.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_egress_slice_clear(int unit, _field_group_t *fg, uint8 slice_numb)
{
    int rv;  /* Operation return status. */
    int inst; /* Pipe Instance. */
    uint32 mode_val[2] =  {0, 0}; /* Mode values for slice control. */
    uint32 class_mode_val[7] = {0, 0, 0, 0, 0, 0, 0}; /* Mode values for
                                                       * class select register
                                                       */
    _field_stage_t     *stage_fc; /* Ref. to Stage control structure. */
    soc_reg_t efp_classid_sel_r;
    soc_reg_t efp_key4_dvp_reg;
    soc_reg_t efp_key4_mdl_reg;
    soc_reg_t efp_slice_control_reg;
    soc_reg_t efp_key8_dvp_reg;
    soc_reg_t efp_dst_port_reg;
    soc_reg_t efp_key4_class_reg;
    soc_reg_t efp_key8_class_reg;

#if defined (BCM_TRIDENT3_SUPPORT)
    soc_reg_t efp_classid_b_sel_reg;
    int idx = 0;
    static const soc_field_t efp_dest_port_selector_flds[][2] = {
             {SLICE_0_F1_DEST_SELf, SLICE_0_F5_DEST_SELf},
             {SLICE_1_F1_DEST_SELf, SLICE_1_F5_DEST_SELf},
             {SLICE_2_F1_DEST_SELf, SLICE_2_F5_DEST_SELf},
             {SLICE_3_F1_DEST_SELf, SLICE_3_F5_DEST_SELf},
        };
#endif

    /* Input parameters check. */
    if (slice_numb >= COUNTOF(_th_efp_slice_mode)) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                        fg->stage_id, &stage_fc));

    if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
       inst = _FP_GLOBAL_INST;
    } else {
       inst = fg->instance;
    }

    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                   EFP_KEY4_DVP_SELECTORr,
                                                   inst, &efp_key4_dvp_reg));
    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                   EFP_KEY8_DVP_SELECTORr,
                                                   inst, &efp_key8_dvp_reg));
    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                   EFP_KEY4_MDL_SELECTORr,
                                                   inst, &efp_key4_mdl_reg));

    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, EFP_SLICE_CONTROLr,
                                                   inst,
                                                   &efp_slice_control_reg));

    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                       EFP_DEST_PORT_SELECTORr,
                                                       inst,
                                                       &efp_dst_port_reg));

    if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                        EFP_KEY4_L3_CLASSID_SELECTORr,
                                                        inst,
                                                        &efp_key4_class_reg));
        BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                        EFP_KEY8_L3_CLASSID_SELECTORr,
                                                        inst,
                                                        &efp_key8_class_reg));
    }

#if defined (BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                   EFP_CLASSID_SELECTOR_Ar,
                                                   inst, &efp_classid_sel_r));
    } else
#endif
    {
        BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                  EFP_CLASSID_SELECTORr,
                                                  inst, &efp_classid_sel_r));
     }
    rv = soc_reg_fields32_modify(unit, efp_slice_control_reg, REG_PORT_ANY,
                                  2, _th_efp_slice_mode[slice_numb], mode_val);
    BCM_IF_ERROR_RETURN(rv);

    rv = soc_reg_fields32_modify(unit, efp_classid_sel_r, REG_PORT_ANY,
                                 7, classfldtbl[slice_numb], class_mode_val);
    BCM_IF_ERROR_RETURN(rv);

#if defined (BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        uint32 const0 = 0;
        uint32 reg_val;

        BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                    EFP_CLASSID_B_SELECTOR_KEY_TYPEr,
                    inst, &efp_classid_b_sel_reg));

        /* Reset class id b values to 0 */
        for (idx =0; idx<=7; idx++) {
            BCM_IF_ERROR_RETURN(soc_reg32_get(unit,
                                      efp_classid_b_sel_reg,
                                      REG_PORT_ANY,
                                      idx,
                                      &reg_val
                                      )
                        );
            soc_reg_field_set(unit,
                          efp_classid_b_sel_reg,
                          &reg_val,
                          classIdBfldtbl[slice_numb],
                          const0
                          );
            BCM_IF_ERROR_RETURN(soc_reg32_set(unit,
                                      efp_classid_b_sel_reg,
                                      REG_PORT_ANY,
                                      idx,
                                      reg_val
                                      )
                        );
         }
    }
#endif
    if (!soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        rv = soc_reg_field32_modify(unit, efp_key4_dvp_reg, REG_PORT_ANY,
                                                       dvpfldtbl[slice_numb], 0);
        BCM_IF_ERROR_RETURN(rv);
    }

    if (0 == soc_feature(unit, soc_feature_td3_style_fp)) {
        rv = soc_reg_field32_modify(unit, efp_key4_mdl_reg, REG_PORT_ANY,
                                                       mdlfldtbl[slice_numb], 0);
        BCM_IF_ERROR_RETURN(rv);
    }

    if (!soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        rv = soc_reg_field32_modify(unit, efp_key8_dvp_reg, REG_PORT_ANY,
                                                       mdlfldtbl[slice_numb], 0);
        BCM_IF_ERROR_RETURN(rv);
    }

#if defined (BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        rv = soc_reg_field32_modify(unit, efp_key4_class_reg, REG_PORT_ANY,
                                                classIdBfldtbl[slice_numb], 0);
        BCM_IF_ERROR_RETURN(rv);
        rv = soc_reg_field32_modify(unit, efp_key8_class_reg, REG_PORT_ANY,
                                                classIdBfldtbl[slice_numb], 0);
        BCM_IF_ERROR_RETURN(rv);
    }
#endif

#if defined (BCM_TRIDENT3_SUPPORT)
    /* SELECTOR CODES for EFP_DEST_PORT_SELECTORr */
    if (SOC_REG_IS_VALID(unit, EFP_DEST_PORT_SELECTORr)) {
            rv = soc_reg_field32_modify(unit,
                        efp_dst_port_reg,
                        REG_PORT_ANY,
                        efp_dest_port_selector_flds[slice_numb][0],
                        0
                        );
            BCM_IF_ERROR_RETURN(rv);

            rv = soc_reg_field32_modify(unit,
                        efp_dst_port_reg,
                        REG_PORT_ANY,
                        efp_dest_port_selector_flds[slice_numb][1],
                        0
                        );
            BCM_IF_ERROR_RETURN(rv);
    }
#endif

    return (rv);
}

/*
 * Function:
 *     _field_th_slice_clear
 *
 * Purpose:
 *     Clear slice configuration on group removal
 *
 * Parameters:
 *     unit  - BCM device number
 *     fg    - Field group slice belongs to
 *     fs    - Field slice structure.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_slice_clear(int unit, _field_group_t *fg, _field_slice_t *fs)
{
    int rv;

    switch (fs->stage_id) {
      case _BCM_FIELD_STAGE_INGRESS:
          rv = _bcm_field_th_ingress_slice_clear(unit, fg, fs);
          break;
      case _BCM_FIELD_STAGE_LOOKUP:
          rv = _field_th_lookup_slice_clear(unit, fg, fs);
          break;
      case _BCM_FIELD_STAGE_EGRESS:
          rv = _field_th_egress_slice_clear(unit, fg, fs->slice_number);
          break;
      default:
          rv = BCM_E_INTERNAL;
    }
    return (rv);
}

/*
 * Function:
 *     _bcm_field_th_slice_clear
 *
 * Purpose:
 *     Clear slice configuration on group removal
 *
 * Parameters:
 *     unit  - BCM device number
 *     fg    - Field group slice belongs to
 *     fs    - Field slice structure.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_slice_clear(int unit, _field_group_t *fg, _field_slice_t *fs)
{
    return _field_th_slice_clear(unit, fg, fs);
}

/*
 * Function:
 *    _bcm_field_th_functions_init
 *
 * Purpose:
 *    Set up functions pointers
 *
 * Parameters:
 *    functions - (IN/OUT) Pointer to device specific field module utility
 *                         routines.
 *
 * Returns:
 *     Nothing
 */
void
_bcm_field_th_functions_init(_field_funct_t *functions)
{
    functions->fp_detach               = _field_th_detach;
    functions->fp_group_install        = _bcm_field_th_group_install;
    functions->fp_selcodes_install     = _bcm_field_th_selcodes_install;
    functions->fp_slice_clear          = _bcm_field_th_slice_clear;
    functions->fp_entry_remove         = _bcm_field_th_entry_remove;
    functions->fp_entry_move           = _bcm_field_th_entry_move;
    functions->fp_entry_enable         = _bcm_field_th_entry_enable_set;
    functions->fp_selcode_get          = _bcm_field_th_selcode_get;
    functions->fp_selcode_to_qset      = _bcm_field_selcode_to_qset;
    functions->fp_qual_list_get        = _bcm_field_qual_lists_get;
    functions->fp_tcam_policy_clear    = NULL;
    functions->fp_tcam_policy_install  = _bcm_field_th_entry_install;
    functions->fp_tcam_policy_reinstall = _bcm_field_th_entry_reinstall;
    functions->fp_policer_install      = _bcm_field_th_policer_install;
    functions->fp_write_slice_map      = _bcm_field_th_write_slice_map;
    functions->fp_qualify_ip_type      = _bcm_field_td2_qualify_ip_type;
    functions->fp_qualify_ip_type_get  = _bcm_field_td2_qualify_ip_type_get;
    functions->fp_action_support_check = _bcm_field_th_action_support_check;
    functions->fp_action_conflict_check = _bcm_field_th_action_conflict_check;
    functions->fp_counter_get          = _bcm_field_td_counter_get;
    functions->fp_counter_set          = _bcm_field_td_counter_set;
    functions->fp_stat_value_get       = _bcm_th_field_stat_value_get;
    functions->fp_stat_value_set       = _bcm_th_field_stat_value_set;
    functions->fp_stat_index_get       = _bcm_field_th_stat_index_get;
    functions->fp_action_params_check  = _bcm_field_th_action_params_check;
    functions->fp_action_depends_check = NULL;
    functions->fp_egress_key_match_type_set
                                    = _bcm_field_th_egress_key_match_type_set;
    functions->fp_external_entry_install  = NULL;
    functions->fp_external_entry_reinstall  = NULL;
    functions->fp_external_entry_remove   = NULL;
    functions->fp_external_entry_prio_set = NULL;
    functions->fp_data_qualifier_ethertype_add
                          = _bcm_field_trx2_data_qualifier_ethertype_add;
    functions->fp_data_qualifier_ethertype_delete
                          = _bcm_field_trx2_data_qualifier_ethertype_delete;
    functions->fp_data_qualifier_ip_protocol_add
                          = _bcm_field_trx2_data_qualifier_ip_protocol_add;
    functions->fp_data_qualifier_ip_protocol_delete
                          = _bcm_field_trx2_data_qualifier_ip_protocol_delete;
    functions->fp_data_qualifier_packet_format_add
                          = _bcm_field_trx2_data_qualifier_packet_format_add;
    functions->fp_data_qualifier_packet_format_delete
                          = _bcm_field_trx2_data_qualifier_packet_format_delete;
    functions->fp_control_set = _bcm_field_th_control_set;
    functions->fp_control_get = _bcm_field_th_control_get;
    functions->fp_stat_hw_mode_get = _bcm_field_th_stat_hw_mode_get;
    functions->fp_stat_hw_alloc    = _bcm_field_th_stat_hw_alloc;
    functions->fp_stat_hw_free     = _bcm_field_th_stat_hw_free;
    functions->fp_group_add        = _bcm_field_th_group_add;
    functions->fp_qualify_svp      = _bcm_field_th_qualify_svp;
    functions->fp_qualify_dvp      = _bcm_field_th_qualify_dvp;
    functions->fp_qualify_trunk    = _bcm_field_th_qualify_trunk;
    functions->fp_qualify_trunk_get = _bcm_field_th_qualify_trunk_get;
    functions->fp_qualify_inports = _bcm_field_th_qualify_InPorts;
    functions->fp_entry_stat_extended_attach = NULL;
    functions->fp_entry_stat_extended_get = NULL;
    functions->fp_entry_stat_detach = _bcm_field_entry_stat_detach;
    functions->fp_class_size_get = _bcm_field_th_qual_class_size_get;
    functions->fp_eh_mask_profile_hw_alloc =
                                     _bcm_field_th_eh_mask_profile_hw_alloc;
    functions->fp_eh_mask_profile_hw_free =
                                     _bcm_field_th_eh_mask_profile_hw_free;
    functions->fp_qualify_packet_res = _bcm_field_th_qualify_PacketRes;
    functions->fp_qualify_packet_res_get = _bcm_field_th_qualify_PacketRes_get;
    functions->fp_ddrop_action_alloc = _bcm_field_th_ddrop_profile_alloc;
    functions->fp_dredirect_action_alloc = _bcm_field_th_dredirect_profile_alloc;
}

/*
 * Function:
 *    _field_th_stage_extractors_init
 * Purpose:
 *    Initialize extractor section hierarcy structure for the IFP stage.
 * Parameters:
 *    unit     - (IN) BCM device number.
 *    stage_fc - (IN) Stage field control structure pointer.
 * Returns:
 *    BCM_E_PARAM   - Invalid parameter.
 *    BCM_E_MEMORY  - Memory allocation failure.
 *    BCM_E_NONE    - Success.
 */
STATIC int
_field_th_stage_extractors_init(int unit, _field_stage_t *stage_fc)
{
    int idx = 0;                     /* Index iterator.                     */
    int level = 0;                   /* Extractor hierarchy level.          */
    int gran = 0;                    /* Extractor granularity.              */
    int ext_num = 0;                 /* Extractor number.                   */
    int part;                        /* Entry part number.                  */
    bcmi_keygen_ext_attrs_t ext_attrs;
    bcmi_keygen_ext_attrs_t temp_attrs;
    bcmi_keygen_ext_attrs_t *attrs = &temp_attrs;
    uint32 ext_attrs_size = 0;
    BCMI_KEYGEN_EXT_CFG_DECL;       /* Extractors config declaration.      */
    bcmi_keygen_ext_cfg_db_t *ext_cfg_db = NULL;
    BCMI_KEYGEN_FUNC_ENTER(unit);

    BCMI_KEYGEN_NULL_CHECK(stage_fc, BCM_E_PARAM);

    ext_attrs_size = sizeof(bcmi_keygen_ext_attrs_t);
    sal_memset(attrs, 0, ext_attrs_size);

    _FP_XGS3_ALLOC(stage_fc->ext_cfg_db_arr,
                   (BCMI_KEYGEN_MODE_COUNT * sizeof(bcmi_keygen_ext_cfg_db_t *)),
                    "Field Extractors Data base Array");
    if (NULL == stage_fc->ext_cfg_db_arr) {
        return (BCM_E_MEMORY);
    }

    _FP_XGS3_ALLOC(ext_cfg_db,
                   sizeof(bcmi_keygen_ext_cfg_db_t), "Field Extractors DB");
    if (NULL == ext_cfg_db) {
        return (BCM_E_MEMORY);
    }
    stage_fc->ext_cfg_db_arr[BCMI_KEYGEN_MODE_DBLINTRA] = ext_cfg_db;
    /* Initialize Level_1 32-bit extractor section. */
    level = 1;
    gran = 32;
    ext_num = 0;
    part = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2S1, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2S1, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2S1, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2S1, 96, attrs);

    /* Initialize Level_1 16-bit extractors section. */
    level = 1;
    gran = 16;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2S1, 128, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2S1, 144, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2S1, 160, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2S1, 176, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2S1, 192, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2S1, 208, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2S1, 224, attrs);

    /* Initialize Level_1 8-bit extractors section. */
    level = 1;
    gran = 8;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2S2, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2S2, 8, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2S2, 16, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2S2, 24, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2S2, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2S2, 40, attrs);

    ext_num = 6;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_LTID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num ,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2S2, 48, &ext_attrs);

    /* Initialize Level_1 4-bit extractors section. */
    level = 1;
    gran = 4;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2S2, 56, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2S2, 60, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2S2, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2S2, 68, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2S2, 72, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2S2, 76, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2S2, 80, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2S2, 84, attrs);

    /* Initialize Level1 2-bit extractors section. */
    level = 1;
    gran = 2;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2S2, 88, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2S2, 90, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2S2, 92, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2S2, 94, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2S2, 96, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2S2, 98, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2S2, 100, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2S2, 102, attrs);

    /* Initialize Level_2 16-bit extractors section. */
    level = 2;
    gran = 16;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_IPBM);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_MODE_HALF);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2S1, BCMI_KEYGEN_EXT_SECTION_L3S1, 0, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2S1, BCMI_KEYGEN_EXT_SECTION_L3S1, 16, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_MODE_SINGLE_ASET_WIDE);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_MODE_HALF);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_0);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2S1, BCMI_KEYGEN_EXT_SECTION_L3S1, 32, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_MODE_SINGLE_ASET_WIDE);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_MODE_HALF);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_1);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2S1, BCMI_KEYGEN_EXT_SECTION_L3S1, 48, &ext_attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2S1, BCMI_KEYGEN_EXT_SECTION_L3S2, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2S1, BCMI_KEYGEN_EXT_SECTION_L3S2, 16, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2S1, BCMI_KEYGEN_EXT_SECTION_L3S2, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L2S1, BCMI_KEYGEN_EXT_SECTION_L3S2, 48, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 8),
        BCMI_KEYGEN_EXT_SECTION_L2S1, BCMI_KEYGEN_EXT_SECTION_L3S2, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 9),
        BCMI_KEYGEN_EXT_SECTION_L2S1, BCMI_KEYGEN_EXT_SECTION_L3S2, 80, attrs);

    /* Initialize Level_2 8-bit extractors section. */
    level = 2;
    gran = 8;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 96, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 104, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 112, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 120, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 128, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 136, &ext_attrs);
    ext_num = 6;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_LTID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num ,
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 144, &ext_attrs);

    /* Initialize Level_2 4-bit extractors section. */
    level = 2;
    gran = 4;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 152, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 156, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 160, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 164, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 168, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 172, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 176, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 180, &ext_attrs);

    /* Initialize Level2 2-bit extractors section. */
    level = 2;
    gran = 2;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 184, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 186, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 188, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 190, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 192, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 194, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 196, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L2S2, BCMI_KEYGEN_EXT_SECTION_L3S2, 198, &ext_attrs);

    /* Initialize two Level_3 16-bit extractors section. */
    level = 3;
    gran = 16;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_IPBM);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_MODE_HALF);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3S1, BCMI_KEYGEN_EXT_SECTION_FK, 0, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L3S1, BCMI_KEYGEN_EXT_SECTION_FK, 20, &ext_attrs);

    /* Initialize four Level_3 4-bit extractors section. */
    level = 3;
    gran = 4;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_IPBM);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_MODE_HALF);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK, 16, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_MODE_HALF);
    for (idx = 1; idx < 4; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK,
            36 + (gran * (idx - 1)) , &ext_attrs);
    }

    /* Initialize Level_3 16-bit extractors section. */
    level = 3;
    gran = 16;
    ext_num = 2;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_MODE_SINGLE_ASET_WIDE);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_MODE_HALF);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_0);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3S1, BCMI_KEYGEN_EXT_SECTION_FK, 48, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_MODE_SINGLE_ASET_WIDE);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_MODE_HALF);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_1);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L3S1, BCMI_KEYGEN_EXT_SECTION_FK, 64, &ext_attrs);

    /* Initialize seventeen Level_3 4-bit extractors section. */
    level = 3;
    gran = 4;
    ext_num = 4;
    for (idx = 0; idx < 2; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK,
            80 + (idx * gran), attrs);
    }
    ext_num = 4;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_0_HM);
    for (idx = 2; idx < 6; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK,
            80 + (idx * gran), &ext_attrs);
    }
    ext_num = 4;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_1_HM);
    for (idx = 6; idx < 10; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK,
            80 + (idx * gran), &ext_attrs);
    }
    ext_num = 4;
    idx = 10;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_FIRST_LOOKUP_CLASSID_BITS_0_3);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran,
        (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK,
        80 + (idx * gran), &ext_attrs);
    idx = 11;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_FIRST_LOOKUP_CLASSID_BITS_4_7);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran,
        (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK,
        80 + (idx * gran), &ext_attrs);
    idx = 12;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_FIRST_LOOKUP_CLASSID_BITS_8_11);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran,
        (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK,
        80 + (idx * gran), &ext_attrs);

    ext_num = 4;
    idx = 13;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_SECOND_LOOKUP_CLASSID_BITS_0_3);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran,
        (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK,
        80 + (idx * gran), &ext_attrs);

    idx = 14;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_SECOND_LOOKUP_CLASSID_BITS_4_7);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran,
        (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK,
        80 + (idx * gran), &ext_attrs);

    idx = 15;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_SECOND_LOOKUP_CLASSID_BITS_8_11);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran,
        (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK,
        80 + (idx * gran), &ext_attrs);

    idx = 16;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_LTID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran,
        (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK,
        80 + (idx * gran), &ext_attrs);

    /* Initialize 5 Level_3 2-bit extractors section. */
    level = 3;
    gran = 2;

    for (ext_num = 0; ext_num < 1; ext_num++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
            BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK,
            148 + (ext_num * gran), attrs);
    }

    ext_num = 1;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_LTID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num ,
        BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK, 150, &ext_attrs);

    /* Overlay with BCMI_KEYGEN_POST_MUX_SRC_DST_CONT_0/1. */
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_MSB);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_MSB_HM);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK, 152, &ext_attrs);

    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_FIRST_LOOKUP_HIT);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_SECOND_LOOKUP_HIT);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK, 154, &ext_attrs);

    /* Overlay with NAT_DST_REALM_ID. */
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_NAT_DST_REALM_ID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK, 156, &ext_attrs);

    /* Initialize 2 Level_3 1-bit extractors section. */
    level = 3;
    gran = 1;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_NAT_NEEDED);
    /* Overlay with NAT_NEEDED. */
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK, 158, &ext_attrs);

    /* Overlay with DROP. */
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_DROP);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L3S2, BCMI_KEYGEN_EXT_SECTION_FK, 159, &ext_attrs);

    /* Initialize Level_4 extractor section. */
    level = 4;
    gran = 160;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, 0,
        BCMI_KEYGEN_EXT_SECTION_FK, BCMI_KEYGEN_EXT_SECTION_DISABLE, 0, attrs);

    /* 320 bits mode - Initialize Level_1 32-bit extractor section. */
    ext_cfg_db = NULL;
    _FP_XGS3_ALLOC(ext_cfg_db,
                   sizeof(bcmi_keygen_ext_cfg_db_t), "Field Extractors DB");
    if (NULL == ext_cfg_db) {
        return (BCM_E_MEMORY);
    }
    stage_fc->ext_cfg_db_arr[BCMI_KEYGEN_MODE_DBLINTER] = ext_cfg_db;
    level = 1;
    gran = 32;
    ext_num = 0;

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2AS1, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2BS1, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2AS1, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2BS1, 32, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2AS1, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2BS1, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2AS1, 96, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2BS1, 96, attrs);

    /* Initialize Level_1 16-bit extractor section. */
    level = 1;
    gran = 16;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 128, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 128, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 144, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 144, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 160, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 160, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 176, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 176, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 192, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 192, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 208, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 208, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 224, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 224, attrs);

    /* Initialize Level_1 8-bit extractor section. */
    level = 1;
    gran = 8;
    ext_num = 0;

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 8, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 8, attrs);


    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 16, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 16, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 24, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 24, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 40, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 40, attrs);

    ext_num = 6;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 48, attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_LTID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num ,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 48, &ext_attrs);

    /* Initialize Level_1 4-bit extractor section. */
    level = 1;
    gran = 4;
    ext_num = 0;

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 56, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 56, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 60, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 60, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 68, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 68, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 72, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 72, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 76, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 76, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 80, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 80, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 7,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 84, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 7,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 84, attrs);

    /* Initialize Level_1 2-bit extractor section. */
    level = 1;
    gran = 2;
    ext_num = 0;

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 88, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 88, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 90, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 90, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 92, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 92, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 94, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 94, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 96, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 96, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 98, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 98, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 100, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 100, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 7,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 102, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 7,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 102, attrs);

    /* Initialize Level_2 16-bit extractors section. */
    level = 2;
    gran = 16;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_IPBM);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2AS1, BCMI_KEYGEN_EXT_SECTION_L3AS1, 0, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L2AS1, BCMI_KEYGEN_EXT_SECTION_L3AS1, 16, &ext_attrs);

    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_0);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L2AS1, BCMI_KEYGEN_EXT_SECTION_L3AS1, 32, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_1);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L2AS1, BCMI_KEYGEN_EXT_SECTION_L3AS1, 48, &ext_attrs);

    for (ext_num = 4; ext_num < 10; ext_num++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
            BCMI_KEYGEN_EXT_SECTION_L2AS1, BCMI_KEYGEN_EXT_SECTION_L3AS2,
            ((ext_num - 4) * gran), attrs);
    }

    level = 2;
    gran = 16;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS1, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS1, 16, attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_0);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS1, 32, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_1);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS1, 48, &ext_attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 4,
            BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS2, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 5,
            BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS2, 16, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 6,
            BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS2, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 7,
            BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS2, 48, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 8,
            BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS2, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 9,
            BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS2, 80, attrs);


    /* Initialize Level_2 8-bit extractors section. */
    level = 2;
    gran = 8;
    ext_num = 0;
    part = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 96, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2,104, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 112, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 120, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 128, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 136, &ext_attrs);

    ext_num = 6;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_LTID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num ,
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 144, &ext_attrs);

    /* Initialize Level_2 4-bit extractors section. */
    level = 2;
    gran = 4;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 152, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 156, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 160, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 164, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 168, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 172, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 176, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 180, &ext_attrs);

    /* Initialize Level2 2-bit extractors section. */
    level = 2;
    gran = 2;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 184, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 186, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 188, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 190, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 192, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 194, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 196, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 198, &ext_attrs);


    /* Initialize Level_2 8-bit extractors section. */
    level = 2;
    gran = 8;
    ext_num = 0;
    part = 1;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 96, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2,104, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 112, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 120, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 128, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 136, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 144, &ext_attrs);

    /* Initialize Level_2 4-bit extractors section. */
    level = 2;
    gran = 4;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 152, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 156, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 160, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 164, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 168, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 172, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 176, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 180, &ext_attrs);

    /* Initialize Level2 2-bit extractors section. */
    level = 2;
    gran = 2;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 184, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 186, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 188, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 190, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 192, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 194, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 196, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 198, &ext_attrs);

    /* Initialize Level_3 16-bit extractors section - SLICE_A. */
    level = 3;
    gran = 16;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_IPBM);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3AS1, BCMI_KEYGEN_EXT_SECTION_FKA, 0, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L3AS1, BCMI_KEYGEN_EXT_SECTION_FKA, 20, &ext_attrs);

    /* Overlay with BCMI_KEYGEN_POST_MUX_SRC_DST_CONT_0/1. */
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_0);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L3AS1, BCMI_KEYGEN_EXT_SECTION_FKA, 48, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_1);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L3AS1, BCMI_KEYGEN_EXT_SECTION_FKA, 64, &ext_attrs);

    /* Initialize Level_3 4-bit extractors section. */
    level = 3;
    gran = 4;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_IPBM);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 16, &ext_attrs);
    for (idx = 1; idx < 4; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            36 + (gran * (idx - 1)), attrs);
    }

    level = 3;
    gran = 4;
    ext_num = 4;
    for (idx = 0; idx < 10; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            80 + (idx * gran), attrs);
    }

    ext_num = 4;
    idx = 10;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_FIRST_LOOKUP_CLASSID_BITS_0_3);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
        (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
        80 + (idx * gran), &ext_attrs);

    idx = 11;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_FIRST_LOOKUP_CLASSID_BITS_4_7);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
        (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
        80 + (idx * gran), &ext_attrs);

    idx = 12;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_FIRST_LOOKUP_CLASSID_BITS_8_11);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
        (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
        80 + (idx * gran), &ext_attrs);

    ext_num = 4;
    idx = 13;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_SECOND_LOOKUP_CLASSID_BITS_0_3);
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            80 + (idx * gran), &ext_attrs);

    idx = 14;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_SECOND_LOOKUP_CLASSID_BITS_4_7);
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            80 + (idx * gran), &ext_attrs);

    idx = 15;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_SECOND_LOOKUP_CLASSID_BITS_8_11);
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            80 + (idx * gran), &ext_attrs);

    ext_num = 4;
    idx = 16;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_LTID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
        (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
        80 + (idx * gran), &ext_attrs);

    /* Initialize Level_3 2-bit extractors section. */
    level = 3;
    gran = 2;
    for (ext_num = 0; ext_num < 1; ext_num++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
            BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            148 + (ext_num * gran), attrs);
    }
    ext_num = 1;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_LTID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num ,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 150, &ext_attrs);


    /* Overlay with BCMI_KEYGEN_POST_MUX_SRC_DST_CONT_0/1. */
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_MSB);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 152, &ext_attrs);

    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_FIRST_LOOKUP_HIT);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_SECOND_LOOKUP_HIT);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 154, &ext_attrs);

    /* Overlay with NAT_DST_REALM_ID. */
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_NAT_DST_REALM_ID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 156, &ext_attrs);

    /* Initialize 2 Level_3 1-bit extractors section. */
    level = 3;
    gran = 1;
    ext_num = 0;
    /* Overlay with NAT_NEEDED. */
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_NAT_NEEDED);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 158, &ext_attrs);
    /* Overlay with DROP. */
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_DROP);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 159, &ext_attrs);

    /* Initialize Level_3 16-bit extractors section - SLICE_B. */
    level = 3;
    gran = 16;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3BS1, BCMI_KEYGEN_EXT_SECTION_FKB, 0, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L3BS1, BCMI_KEYGEN_EXT_SECTION_FKB, 20, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_0);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L3BS1, BCMI_KEYGEN_EXT_SECTION_FKB, 48, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_1);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L3BS1, BCMI_KEYGEN_EXT_SECTION_FKB, 64, &ext_attrs);

    /* Initialize Level_3 4-bit extractors section. */
    level = 3;
    gran = 4;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB, 16, attrs);

    for (idx = 1; idx < 4; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB,
            36 + (gran * (idx - 1)), attrs);
    }

    level = 3;
    gran = 4;
    ext_num = 4;

    for (idx = 0; idx < 17; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB,
            80 + (idx * gran), attrs);
    }

    /* Initialize Level_3 2-bit extractors section. */
    level = 3;
    gran = 2;
    for (ext_num = 0; ext_num < 2; ext_num++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
            BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB,
            148 + (ext_num * gran), attrs);
    }

    /* Overlay with BCMI_KEYGEN_POST_MUX_SRC_DST_CONT_0/1. */
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_MSB);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB, 152, &ext_attrs);

    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB, 154, attrs);

    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB, 156, attrs);

    /* Initialize 2 Level_3 1-bit extractors section. */
    level = 3;
    gran = 1;
    for (ext_num = 0; ext_num < 2; ext_num++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
            BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB,
            158 + (ext_num * gran), attrs);
    }

    /* Initialize Level_4 extractor section. */
    level = 4;
    gran = 160;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, 0,
        BCMI_KEYGEN_EXT_SECTION_FK, BCMI_KEYGEN_EXT_SECTION_DISABLE, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, 0,
        BCMI_KEYGEN_EXT_SECTION_FKA, BCMI_KEYGEN_EXT_SECTION_DISABLE, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, 0,
        BCMI_KEYGEN_EXT_SECTION_FKB, BCMI_KEYGEN_EXT_SECTION_DISABLE, 0, attrs);

    /* 480 bit mode - Initialize Level_1 32-bit extractor section. */
    ext_cfg_db = NULL;
    _FP_XGS3_ALLOC(ext_cfg_db,
                   sizeof(bcmi_keygen_ext_cfg_db_t), "Field Extractors DB");
    if (NULL == ext_cfg_db) {
        return (BCM_E_MEMORY);
    }
    stage_fc->ext_cfg_db_arr[BCMI_KEYGEN_MODE_TRIPLE] = ext_cfg_db;
    level = 1;
    gran = 32;
    ext_num = 0;

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2AS1, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2AS1, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2BS1, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2BS1, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2CS1, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2CS1, 32, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2AS1, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2AS1, 96, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2BS1, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2BS1, 96, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2CS1, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E32, BCMI_KEYGEN_EXT_SECTION_L2CS1, 96, attrs);

    /* Initialize Level_1 16-bit extractor section. */
    level = 1;
    gran = 16;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 128, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 144, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2CS1, 128, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2CS1, 144, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 128, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 144, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 160, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 176, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2CS1, 160, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2CS1, 176, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 160, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 176, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 192, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 208, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2CS1, 192, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2CS1, 208, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 192, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 208, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2BS1, 224, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2CS1, 224, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E16, BCMI_KEYGEN_EXT_SECTION_L2AS1, 224, attrs);

    /* Initialize Level_1 8-bit extractor section. */
    level = 1;
    gran = 8;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 8, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2CS2, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2CS2, 8, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 8, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 16, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 24, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2CS2, 16, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2CS2, 24, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 16, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 24, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 40, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2CS2, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2CS2, 40, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 40, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2BS2, 48, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2CS2, 48, attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_LTID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E8, BCMI_KEYGEN_EXT_SECTION_L2AS2, 48, &ext_attrs);

    /* Initialize Level_1 4-bit extractor section. */
    level = 1;
    gran = 4;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 56, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 60, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2CS2, 56, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2CS2, 60, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 56, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 60, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 68, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2CS2, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2CS2, 68, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 68, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 72, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 76, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2CS2, 72, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2CS2, 76, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 72, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 76, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 80, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 7,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2BS2, 84, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2CS2, 80, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 7,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2CS2, 84, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 80, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 7,
        BCMI_KEYGEN_EXT_SECTION_L1E4, BCMI_KEYGEN_EXT_SECTION_L2AS2, 84, attrs);

    /* Initialize Level_1 2-bit extractor section. */
    level = 1;
    gran = 2;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2CS2, 88, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2CS2, 90, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 88, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 90, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 88, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 90, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2CS2, 92, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2CS2, 94, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 92, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 94, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 92, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 94, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2CS2, 96, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2CS2, 98, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 96, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 98, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 96, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 98, attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2CS2, 100, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 7,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2CS2, 102, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 100, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 7,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2BS2, 102, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 100, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 7,
        BCMI_KEYGEN_EXT_SECTION_L1E2, BCMI_KEYGEN_EXT_SECTION_L2AS2, 102, attrs);

    /* Initialize Level_2 16-bit extractors section - Slice_A. */
    level = 2;
    gran = 16;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_IPBM);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2AS1, BCMI_KEYGEN_EXT_SECTION_L3AS1, 0, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L2AS1, BCMI_KEYGEN_EXT_SECTION_L3AS1, 16, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_0);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L2AS1, BCMI_KEYGEN_EXT_SECTION_L3AS1, 32, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_1);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db,  0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L2AS1, BCMI_KEYGEN_EXT_SECTION_L3AS1, 48, &ext_attrs);
    for (ext_num = 4; ext_num < 10; ext_num++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
            BCMI_KEYGEN_EXT_SECTION_L2AS1, BCMI_KEYGEN_EXT_SECTION_L3AS2,
            ((ext_num - 4) * gran), attrs);
    }

    /* Initialize Level_2 8-bit extractors section. */
    level = 2;
    gran = 8;
    ext_num = 0;
    part = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 96, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2,104, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 112, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 120, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 128, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 136, &ext_attrs);

    ext_num = 6;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_LTID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num ,
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 144, &ext_attrs);

    /* Initialize Level_2 4-bit extractors section. */
    level = 2;
    gran = 4;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 152, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 156, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 160, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 164, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 168, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 172, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 176, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 180, &ext_attrs);

    /* Initialize Level2 2-bit extractors section. */
    level = 2;
    gran = 2;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 184, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 186, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 188, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 190, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 192, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 194, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 196, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L2AS2, BCMI_KEYGEN_EXT_SECTION_L3AS2, 198, &ext_attrs);

    /* Initialize Level_2 16-bit extractors section - Slice_B. */
    level = 2;
    gran = 16;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS1, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS1, 16, attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_0);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS1, 32, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_1);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS1, 48, &ext_attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS2, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS2, 16, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS2, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 7,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS2, 48, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 8,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS2, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 9,
        BCMI_KEYGEN_EXT_SECTION_L2BS1, BCMI_KEYGEN_EXT_SECTION_L3BS2, 80, attrs);

    /* Initialize Level_2 8-bit extractors section. */
    level = 2;
    gran = 8;
    ext_num = 0;
    part = 1;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 96, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2,104, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 112, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 120, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 128, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 136, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 144, &ext_attrs);

    /* Initialize Level_2 4-bit extractors section. */
    level = 2;
    gran = 4;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 152, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 156, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 160, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 164, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 168, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 172, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 176, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 180, &ext_attrs);

    /* Initialize Level2 2-bit extractors section. */
    level = 2;
    gran = 2;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 184, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 186, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 188, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 190, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 192, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 194, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 196, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L2BS2, BCMI_KEYGEN_EXT_SECTION_L3BS2, 198, &ext_attrs);

    /* Initialize Level_2 16-bit extractors section - Slice_C. */
    level = 2;
    gran = 16;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2CS1, BCMI_KEYGEN_EXT_SECTION_L3CS1, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L2CS1, BCMI_KEYGEN_EXT_SECTION_L3CS1, 16, attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_0);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L2CS1, BCMI_KEYGEN_EXT_SECTION_L3CS1, 32, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_1);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L2CS1, BCMI_KEYGEN_EXT_SECTION_L3CS1, 48, &ext_attrs);

    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L2CS1, BCMI_KEYGEN_EXT_SECTION_L3CS2, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 5,
        BCMI_KEYGEN_EXT_SECTION_L2CS1, BCMI_KEYGEN_EXT_SECTION_L3CS2, 16, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 6,
        BCMI_KEYGEN_EXT_SECTION_L2CS1, BCMI_KEYGEN_EXT_SECTION_L3CS2, 32, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 7,
        BCMI_KEYGEN_EXT_SECTION_L2CS1, BCMI_KEYGEN_EXT_SECTION_L3CS2, 48, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 8,
        BCMI_KEYGEN_EXT_SECTION_L2CS1, BCMI_KEYGEN_EXT_SECTION_L3CS2, 64, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 9,
        BCMI_KEYGEN_EXT_SECTION_L2CS1, BCMI_KEYGEN_EXT_SECTION_L3CS2, 80, attrs);

    /* Initialize Level_2 8-bit extractors section. */
    level = 2;
    gran = 8;
    ext_num = 0;
    part = 2;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 96, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2,104, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 112, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 120, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 128, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 136, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 144, &ext_attrs);

    /* Initialize Level_2 4-bit extractors section. */
    level = 2;
    gran = 4;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 152, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 156, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 160, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 164, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 168, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 172, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 176, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 180, &ext_attrs);

    /* Initialize Level2 2-bit extractors section. */
    level = 2;
    gran = 2;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 184, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 1),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 186, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 2),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 188, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 3),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 190, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 4),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 192, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 5),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 194, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 6),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 196, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, part, level, gran, (ext_num + 7),
        BCMI_KEYGEN_EXT_SECTION_L2CS2, BCMI_KEYGEN_EXT_SECTION_L3CS2, 198, &ext_attrs);

    /* Initialize Level_3 16-bit extractors section - SLICE_A. */
    level = 3;
    gran = 16;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_IPBM);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3AS1, BCMI_KEYGEN_EXT_SECTION_FKA, 0, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L3AS1, BCMI_KEYGEN_EXT_SECTION_FKA, 20, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_0);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L3AS1, BCMI_KEYGEN_EXT_SECTION_FKA, 48, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_1);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L3AS1, BCMI_KEYGEN_EXT_SECTION_FKA, 64, &ext_attrs);

    /* Initialize Level_3 4-bit extractors section. */
    level = 3;
    gran = 4;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_IPBM);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 16, &ext_attrs);
    for (idx = 1; idx < 4; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            36 + (gran * (idx - 1)), attrs);
    }

    level = 3;
    gran = 4;
    ext_num = 4;
    for (idx = 0; idx < 10; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            80 + (idx * gran), attrs);
    }

    ext_num = 4;
    idx = 10;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_FIRST_LOOKUP_CLASSID_BITS_0_3);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            80 + (idx * gran), &ext_attrs);

    idx = 11;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_FIRST_LOOKUP_CLASSID_BITS_4_7);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            80 + (idx * gran), &ext_attrs);

    idx = 12;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_FIRST_LOOKUP_CLASSID_BITS_8_11);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            80 + (idx * gran), &ext_attrs);

    ext_num = 4;
    idx = 13;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_SECOND_LOOKUP_CLASSID_BITS_0_3);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            80 + (idx * gran), &ext_attrs);

    idx = 14;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_SECOND_LOOKUP_CLASSID_BITS_4_7);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            80 + (idx * gran), &ext_attrs);

    idx = 15;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,
       BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_SECOND_LOOKUP_CLASSID_BITS_8_11);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            80 + (idx * gran), &ext_attrs);

    ext_num = 4;
    idx = 16;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w,BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_LTID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran,
        (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
        80 + (idx * gran), &ext_attrs);


    /* Initialize Level_3 2-bit extractors section. */
    level = 3;
    gran = 2;
    for (ext_num = 0; ext_num < 1; ext_num++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
            BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA,
            148 + (ext_num * gran), attrs);
    }
    ext_num = 1;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_LTID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num ,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 150, &ext_attrs);

    /* Overlay with BCMI_KEYGEN_POST_MUX_SRC_DST_CONT_0/1. */
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_MSB);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 152, &ext_attrs);
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_FIRST_LOOKUP_HIT);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_EM_SECOND_LOOKUP_HIT);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 154, &ext_attrs);

    /* Overlay with NAT_DST_REALM_ID. */
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_NAT_DST_REALM_ID);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 156, &ext_attrs);

    /* Initialize Level_3 1-bit extractors section. */
    level = 3;
    gran = 1;
    ext_num = 0;
    /* Overlay with NAT_NEEDED. */
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_NAT_NEEDED);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 158, &ext_attrs);
    /* Overlay with DROP. */
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_DROP);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L3AS2, BCMI_KEYGEN_EXT_SECTION_FKA, 159, &ext_attrs);

    /* Initialize Level_3 16-bit extractors section - SLICE_B. */
    level = 3;
    gran = 16;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3BS1, BCMI_KEYGEN_EXT_SECTION_FKB, 0, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L3BS1, BCMI_KEYGEN_EXT_SECTION_FKB, 20, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_0);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L3BS1, BCMI_KEYGEN_EXT_SECTION_FKB, 48, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_1);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L3BS1, BCMI_KEYGEN_EXT_SECTION_FKB, 64, &ext_attrs);

    /* Initialize Level_3 4-bit extractors section. */
    level = 3;
    gran = 4;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB, 16, attrs);
    for (idx = 1; idx < 4; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB,
            36 + (gran * (idx - 1)), attrs);
    }
    level = 3;
    gran = 4;
    ext_num = 4;
    for (idx = 0; idx < 17; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB,
            80 + (idx * gran), attrs);
    }
    /* Initialize Level_3 2-bit extractors section. */
    level = 3;
    gran = 2;
    for (ext_num = 0; ext_num < 2; ext_num++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
            BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB,
            148 + (gran * ext_num), attrs);
    }

    /* Overlay with BCMI_KEYGEN_POST_MUX_SRC_DST_CONT_0/1. */
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_MSB);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB, 152, &ext_attrs);

    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB, 154, attrs);

    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB, 156, attrs);

    /* Initialize Level_3 1-bit extractors section. */
    level = 3;
    gran = 1;
    for (ext_num = 0; ext_num < 2; ext_num++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, ext_num,
            BCMI_KEYGEN_EXT_SECTION_L3BS2, BCMI_KEYGEN_EXT_SECTION_FKB,
            158 + (gran * ext_num), attrs);
    }

    /* Initialize Level_3 16-bit extractors section - SLICE_C. */
    level = 3;
    gran = 16;
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3CS1, BCMI_KEYGEN_EXT_SECTION_FKC, 0, &ext_attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 1,
        BCMI_KEYGEN_EXT_SECTION_L3CS1, BCMI_KEYGEN_EXT_SECTION_FKC, 20, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_0);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L3CS1, BCMI_KEYGEN_EXT_SECTION_FKC, 48, &ext_attrs);
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_PASS_THRU);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_1);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L3CS1, BCMI_KEYGEN_EXT_SECTION_FKC, 64, &ext_attrs);

    /* Initialize Level_3 4-bit extractors section. */
    level = 3;
    gran = 4;
    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num,
        BCMI_KEYGEN_EXT_SECTION_L3CS2, BCMI_KEYGEN_EXT_SECTION_FKC, 16, attrs);
    for (idx = 1; idx < 4; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3CS2, BCMI_KEYGEN_EXT_SECTION_FKC,
            36 + (gran * (idx - 1)), attrs);
    }

    level = 3;
    gran = 4;
    ext_num = 4;
    for (idx = 0; idx < 17; idx++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran,
            (ext_num + idx), BCMI_KEYGEN_EXT_SECTION_L3CS2, BCMI_KEYGEN_EXT_SECTION_FKC,
            80 + (idx * gran), attrs);
    }

    /* Initialize Level_3 2-bit extractors section. */
    level = 3;
    gran = 2;
    for (ext_num = 0; ext_num < 2; ext_num++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num,
            BCMI_KEYGEN_EXT_SECTION_L3CS2, BCMI_KEYGEN_EXT_SECTION_FKC,
            148 + (gran * ext_num), attrs);
    }

    /* Overlay with BCMI_KEYGEN_POST_MUX_SRC_DST_CONT_0/1. */
    ext_num = 0;
    sal_memset(&ext_attrs, 0, ext_attrs_size);
    SHR_BITSET(ext_attrs.w, BCMI_KEYGEN_EXT_ATTR_NOT_WITH_PMUX_SRC_DST_CONT_MSB);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 2,
        BCMI_KEYGEN_EXT_SECTION_L3CS2, BCMI_KEYGEN_EXT_SECTION_FKC, 152, &ext_attrs);

    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 3,
        BCMI_KEYGEN_EXT_SECTION_L3CS2, BCMI_KEYGEN_EXT_SECTION_FKC, 154, attrs);

    ext_num = 0;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num + 4,
        BCMI_KEYGEN_EXT_SECTION_L3CS2, BCMI_KEYGEN_EXT_SECTION_FKC, 156, attrs);


    /* Initialize Level_3 1-bit extractors section. */
    level = 3;
    gran = 1;
    for (ext_num = 0; ext_num < 2; ext_num++) {
        BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, ext_num,
            BCMI_KEYGEN_EXT_SECTION_L3CS2, BCMI_KEYGEN_EXT_SECTION_FKC,
            158 + (gran * ext_num), attrs);
    }

    /* Initialize Level_4 extractor section. */
    level = 4;
    gran = 160;
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, 0,
        BCMI_KEYGEN_EXT_SECTION_FK, BCMI_KEYGEN_EXT_SECTION_DISABLE, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 0, level, gran, 0,
        BCMI_KEYGEN_EXT_SECTION_FKA, BCMI_KEYGEN_EXT_SECTION_DISABLE, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 1, level, gran, 0,
        BCMI_KEYGEN_EXT_SECTION_FKB, BCMI_KEYGEN_EXT_SECTION_DISABLE, 0, attrs);
    BCMI_KEYGEN_EXT_CFG_ADD(unit, ext_cfg_db, 2, level, gran, 0,
        BCMI_KEYGEN_EXT_SECTION_FKC, BCMI_KEYGEN_EXT_SECTION_DISABLE, 0, attrs);
exit:
    BCMI_KEYGEN_FUNC_EXIT();
}

/*
 * Function:
 *    _bcm_field_th_init
 * Purpose:
 *    Perform initializations that are specific to BCM56960. This
 *    includes initializing the FP field select bit offset tables for FPF[1-3]
 *    for every stage.
 * Parameters:
 *    unit       - (IN) BCM device number.
 *    fc         - (IN) Field Processor control structure.
 *
 * Returns:
 *    BCM_E_PARAM - Null field control structure or stage control structure.
 *    BCM_E_INTERNAL - Invalid CAP stage ID.
 *    BCM_E_NONE - Success.
 */
int
_bcm_field_th_init(int unit, _field_control_t *fc)
{
    _field_stage_t *stage_fc; /* Pointer to Stage control structure. */

    /* Input parameters check. */
    if (NULL == fc || NULL == fc->stages) {
        return (BCM_E_PARAM);
    }

    /* Get the stage control handle. */
    stage_fc = fc->stages;

    /*
     * Initialize FP hardware tables based on the device Group Oper mode
     * settings.
     */
    switch (stage_fc->oper_mode) {
        case bcmFieldGroupOperModeGlobal:
            /* Legacy global mode, use DUPLICATE view to clear FP HW tables. */
            while (stage_fc) {
                if (!SAL_BOOT_BCMSIM && !SAL_BOOT_QUICKTURN && !SAL_BOOT_XGSSIM) {
                    /* Clear hardware table */
                    BCM_IF_ERROR_RETURN(_field_th_hw_clear(unit,
                        stage_fc, fc));
                }

                /* Initialize qualifiers info. */
                BCM_IF_ERROR_RETURN(_field_th_qualifiers_init(unit, stage_fc));

                /* Initialize stage actions information. */
                BCM_IF_ERROR_RETURN(_field_th_actions_init(unit, stage_fc));

                /* Goto next stage */
                stage_fc = stage_fc->next;
            }

            if (0 == SOC_WARM_BOOT(unit)) {
                if (!(soc_feature(unit, soc_feature_th3_style_fp))) {
                    /* Enable FP meter refresh on all pipes. */
                    BCM_IF_ERROR_RETURN(_field_meter_refresh_enable_set(unit, fc,
                        TRUE));
                }
#if defined (BCM_CHANNELIZED_SWITCHING_SUPPORT)
                if ((soc_feature(unit, soc_feature_channelized_switching))
                     && SOC_MEM_IS_VALID(unit, EFP_FLEX_DATA_MASKm)) {
                    BCM_IF_ERROR_RETURN(_field_td3_flex_data_mask_set(unit, fc));
                }
#endif
            }
            break;

        case bcmFieldGroupOperModePipeLocal:
            while (stage_fc) {
                if (!SAL_BOOT_BCMSIM && !SAL_BOOT_QUICKTURN && !SAL_BOOT_XGSSIM) {
                    /* Clear hardware table */
                    BCM_IF_ERROR_RETURN(_field_th_pipes_hw_clear(unit,
                        stage_fc, fc));
                }

                /* Initialize qualifiers info. */
                BCM_IF_ERROR_RETURN(_field_th_qualifiers_init(unit, stage_fc));

                /* Initialize stage actions information. */
                BCM_IF_ERROR_RETURN(_field_th_actions_init(unit, stage_fc));

                /* Goto next stage */
                stage_fc = stage_fc->next;
            }
            if (0 == SOC_WARM_BOOT(unit)) {
                /* Enable FP meter refresh on all pipes. */
                if (!(soc_feature(unit, soc_feature_th3_style_fp))) {

                    BCM_IF_ERROR_RETURN(_field_th_pipes_meter_refresh_enable(
                                                            unit, fc, TRUE));
                }
            }
            break;

        default:
            break;
    }

    if (0 == SOC_WARM_BOOT(unit)) {
        /* Enable filter processor */
        BCM_IF_ERROR_RETURN(_field_port_filter_enable_set(unit, fc, TRUE));

    }

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       /* Initialize the function pointers */
       _bcm_field_td3_functions_init(&fc->functions);
    } else
#endif /* BCM_TRIDENT3_SUPPORT */
    {
       /* Initialize the function pointers */
       _bcm_field_th_functions_init(&fc->functions);
    }

    /* initialize the qset comb */
    BCM_IF_ERROR_RETURN(_field_th_qset_comb_init(unit, fc));

    /* Register with Counter ejection */
    _bcm_th_field_counter_config_set(unit);

    stage_fc = fc->stages;
    while (stage_fc) {
       if ((stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
           (stage_fc->stage_id == _BCM_FIELD_STAGE_EXACTMATCH)) {
          /* Match ID width partition for each zone */
          if (fc->functions.fp_zone_match_id_partition_init != NULL) {
             BCM_IF_ERROR_RETURN(fc->functions.fp_zone_match_id_partition_init
                                                            (unit, stage_fc));
          }
       }
#ifdef BCM_FLOWTRACKER_SUPPORT
       if (stage_fc->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER) {
            BCM_IF_ERROR_RETURN(_field_hx5_ft_tcam_policy_init(unit, stage_fc));
       }
#endif
#ifdef BCM_FLOWTRACKER_V3_SUPPORT
       if (soc_feature(unit, soc_feature_field_flowtracker_v3_support) &&
               ((stage_fc->stage_id == _BCM_FIELD_STAGE_AMFTFP) ||
                (stage_fc->stage_id == _BCM_FIELD_STAGE_AEFTFP))) {
           BCM_IF_ERROR_RETURN(
                   _field_fb6_aft_tcam_policy_init(unit, stage_fc));
       }
#endif
       /* Goto next stage */
       stage_fc = stage_fc->next;
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_ingress_entry_tcam_wide_install
 * Purpose:
 *     Set the per-pipe PBMP in the Ingress TCAM
 * Parameters:
 *     unit         - (IN) BCM device number
 *     f_ent        - (IN) entry structure to get policy info from
 *     tcam_idx     - (IN) Index in the TCAM memory.
 *     _f_pbmp      - (IN) Reference to field PBMP.
 *     num_pipe     - (IN) Number of Pipes the _f_pbmp has.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_ingress_entry_tcam_wide_install(int unit, _field_entry_t *f_ent,
                                       int tcam_idx, uint8 set_pbmp,
                                      _field_pbmp_t *_f_pbmp,
                                       int num_pipe)
{
    int            inst;                     /* Pipe Instance.              */
    int            valid = 0;                /* Valid bit.                  */
    _field_tcam_t  *tcam;
    uint32         entry_buf[SOC_MAX_MEM_FIELD_WORDS] = {0};
                                     /* Buffer to fill Policy & TCAM entry.*/
    soc_mem_t      ifp_tcam_wide;    /* IFP TCAM memory names. */

#if defined(BCM_TOMAHAWK2_SUPPORT)
    bcm_pbmp_t     valid_pbm; /* valid_pbm in HW. */
#endif
    if (f_ent == NULL || _f_pbmp == NULL) {
       return BCM_E_PARAM;
    }

    /* Update the valid bit based on the mode and group flags */
    valid = (f_ent->group->flags & _FP_GROUP_LOOKUP_ENABLED) ? 3 : 0;

    tcam = &f_ent->tcam;
    for (inst = 0; inst < num_pipe; inst++) {
      if (!SOC_IS_TOMAHAWK3(unit)) {
          BCM_IF_ERROR_RETURN(
              _bcm_field_mem_instance_get(unit,
                                          IFP_TCAM_WIDEm,
                                          inst,
                                          &ifp_tcam_wide));
      } else {
          BCM_IF_ERROR_RETURN(
              _bcm_field_mem_instance_get(unit,
                                          IFP_TCAMm,
                                          inst,
                                          &ifp_tcam_wide));
      }
      sal_memset(entry_buf, 0x0, sizeof(entry_buf));
      soc_mem_field_set(unit, ifp_tcam_wide, entry_buf, KEYf, tcam->key);
      soc_mem_field_set(unit, ifp_tcam_wide, entry_buf, MASKf, tcam->mask);
      if (set_pbmp == 1) {
#if defined(BCM_TOMAHAWK2_SUPPORT)
          if (soc_feature(unit, soc_feature_xy_tcam_x0y)) {
              BCM_PBMP_CLEAR(valid_pbm);
              soc_mem_field_set(unit, ifp_tcam_wide, entry_buf,
                               IPBMf, (uint32 *)&valid_pbm);
              BCM_PBMP_ASSIGN(valid_pbm, _f_pbmp[inst].data);
              BCM_PBMP_AND(valid_pbm, _f_pbmp[inst].mask);
              BCM_PBMP_XOR(valid_pbm, _f_pbmp[inst].mask);
              soc_mem_field_width_fit_set(unit, ifp_tcam_wide, entry_buf,
                               IPBM_MASKf, (uint32 *)&valid_pbm);
          } else
#endif /* BCM_TOMAHAWK2_SUPPORT */
          {
              soc_mem_field_set(unit, ifp_tcam_wide, entry_buf,
                               IPBMf, (uint32 *)&_f_pbmp[inst].data);
              soc_mem_field_width_fit_set(unit, ifp_tcam_wide, entry_buf,
                               IPBM_MASKf, (uint32 *)&_f_pbmp[inst].mask);
          }
      }
      soc_mem_field32_set(unit, ifp_tcam_wide, entry_buf, VALIDf, valid);
      BCM_IF_ERROR_RETURN(soc_th_ifp_mem_write(unit,
                                        ifp_tcam_wide,
                                        MEM_BLOCK_ALL,
                                        tcam_idx,
                                        entry_buf));
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_fp_tcam_ipbmp_size
 * Purpose:
 *     Retrieve the per-pipe PBMP size for a chip.
 * Parameters:
 *     unit          - (IN)  BCM device number
 * Returns:
 *     pbmp_size
 */

int
_field_fp_tcam_ipbmp_size(int unit) {

#ifdef BCM_TOMAHAWK3_SUPPORT
    if (SOC_IS_TOMAHAWK3(unit)) {
        return soc_mem_field_length(unit, IFP_TCAMm, IPBMf);
    } else
#endif
    {
        return soc_mem_field_length(unit, IFP_TCAM_WIDEm, IPBMf);;
    }
}

/*
 * Function:
 *     _field_ingress_pipe_pbmp_get
 * Purpose:
 *     Retrieve the per-pipe PBMP from the given pbmp
 * Parameters:
 *     unit          - (IN)  BCM device number
 *     qset          - (IN)  Qualifier QSET
 *     pbmp          - (IN)  Input PBMP, contains all pipes pbmp.
 *     pipe_pbmp     - (OUT) Reference to per-pipe PBMP.
 *     pipe_pbmp_len - (IN)  Number of elements in pipe_pbmp array.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_ingress_pipe_pbmp_get(int              unit,
                             bcm_field_qset_t qset,
                             _field_pbmp_t    *pbmp,
                             _field_pbmp_t    *pipe_pbmp,
                             int              pipe_pbmp_len)
{
   int      inst;       /* Pipe Instance */
   int      port;       /* Input Port */
   int      pipe_port;  /* Pipe Port */
   int      pipe_ports_max; /* Max ports per pipe. */

   /* NULL parameter checks. */
   if (pbmp == NULL || NULL == pipe_pbmp) {
      return BCM_E_PARAM;
   }

   /* Update the pipe PBMP for PortBitmap Qualifiers. */
   if (!BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyInPorts)) {
      int  base_port;   /* Instance Base port. */
      int  max_port;    /* Instance Max Port. */

      for (inst = 0; inst < pipe_pbmp_len; inst++) {
         base_port = (inst * _FP_TCAM_IPBMP_SIZE(unit));
         max_port = ((inst + 1) * _FP_TCAM_IPBMP_SIZE(unit));
         for (port = base_port; port < max_port; port++) {
            /* Update data. */
            if (BCM_PBMP_MEMBER(pbmp->data, port)) {
               pipe_port = port - base_port;
               BCM_PBMP_PORT_ADD(pipe_pbmp[inst].data, pipe_port);
            }
            /* Update mask. */
            if (BCM_PBMP_MEMBER(pbmp->mask, port)) {
               pipe_port = port - base_port;
               BCM_PBMP_PORT_ADD(pipe_pbmp[inst].mask, pipe_port);
            }
         }
      }
      return BCM_E_NONE;
   }

#if defined(BCM_TRIDENT3_SUPPORT)
   if (soc_feature(unit, soc_feature_td3_style_fp)) {
       pipe_ports_max = _BCM_TD3_NUM_PIPE_PORTS;
   } else
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TOMAHAWK2_SUPPORT)
   if (soc_feature(unit, soc_feature_field_multi_pipe_enhanced)) {
       pipe_ports_max = _TH2_DEV_PORTS_PER_PIPE;
   } else
#endif /* BCM_TOMAHAWK2_SUPPORT */
#if defined(BCM_TOMAHAWK3_SUPPORT)
   if (soc_feature(unit, soc_feature_ifp_no_narrow_mode_support)) {
       pipe_ports_max = _TH3_DEV_PORTS_PER_PIPE;
   } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
   {
       pipe_ports_max = _TH_DEV_PORTS_PER_PIPE;
   }

   /* Update the Output Data Pipe Pbmp based on the input pbmp */
   BCM_PBMP_ITER(pbmp->data, port) {
       SOC_IF_ERROR_RETURN(soc_port_pipe_get(unit, port, &inst));
       if (inst >= pipe_pbmp_len) {
           return BCM_E_INTERNAL;
       }

       /* per_pipe pbmp does not have cpu port but all pbmp has cpu port. */
       if (inst == 0 && port == 0) {
           BCM_PBMP_PORT_ADD(pipe_pbmp[inst].data, port);
       } else if (BCM_PBMP_MEMBER(PBMP_PIPE(unit, inst), port)) {
           pipe_port = port - (inst * pipe_ports_max);
           BCM_PBMP_PORT_ADD(pipe_pbmp[inst].data, pipe_port);
       } else {
           LOG_ERROR(BSL_LS_BCM_FP, (BSL_META("Invalid port[%d] \n\r"), port));
           return BCM_E_PARAM;
       }
   }

   /* Update the Output Mask Pipe Pbmp based on the input pbmp */
   BCM_PBMP_ITER(pbmp->mask, port) {
       SOC_IF_ERROR_RETURN(soc_port_pipe_get(unit, port, &inst));
       if (inst >= pipe_pbmp_len) {
           return BCM_E_INTERNAL;
       }

       /* per_pipe pbmp does not have cpu port but all pbmp has cpu port. */
       if (inst == 0 && port == 0) {
           BCM_PBMP_PORT_ADD(pipe_pbmp[inst].mask, port);
       } else if (BCM_PBMP_MEMBER(PBMP_PIPE(unit, inst), port) ||
               IS_LB_PORT(unit, port)) {
           pipe_port = port - (inst * pipe_ports_max);
           BCM_PBMP_PORT_ADD(pipe_pbmp[inst].mask, pipe_port);
           LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META("Adding Port[%d] to Mask"
                     " .. pipe_port:%d on inst:%d\n\r"),
                     port, pipe_port, inst));
       } else {
           LOG_ERROR(BSL_LS_BCM_FP, (BSL_META("Invalid mask[%d] \n\r"), port));
           return BCM_E_PARAM;
       }
   }

   return BCM_E_NONE;
}

/*
 * Function:
 *     _field_th_ingress_entry_qual_tcam_install
 * Purpose:
 *     Install the entry qualifiers in the Ingress TCAM.
 * Parameters:
 *     unit         - (IN) BCM device number
 *     f_ent        - (IN) entry structure to get policy info from
 *     tcam_mem     - (IN) TCAM memory index.
 *     tcam_idx     - (IN) Index in the TCAM memory.
 * Returns:
 *     BCM_E_XXX
 */

STATIC int
_field_th_ingress_entry_qual_tcam_install(int unit, _field_entry_t *f_ent,
                                          soc_mem_t tcam_mem, int tcam_idx)
{
    uint32         entry_buf[SOC_MAX_MEM_FIELD_WORDS] = {0};
                              /* Buffer to fill Policy & TCAM entry.*/
    _field_stage_t *stage_fc; /* Reference to Stage control structure. */
    _field_tcam_t  *tcam;
    _field_group_t *fg;
    int            rv;
    int            stage_id;
    uint32         valid;
    uint8          mode;

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    tcam = &f_ent->tcam;
    fg = f_ent->group;
    if (tcam == NULL || fg == NULL) {
       return BCM_E_INTERNAL;
    }

    stage_id = f_ent->group->stage_id;
    BCM_IF_ERROR_RETURN
       (_field_stage_control_get(unit, stage_id, &stage_fc));

    /* Determine the slice mode based on group flags. */
    mode = _BCM_FIELD_IS_SLICE_MODE_PBMP_SUPPORTED(fg->flags) ?
         _IFP_SLICE_MODE_WIDE : _IFP_SLICE_MODE_NARROW;

    /* Update the valid bit based on the mode and group flags */
    valid = (fg->flags & _FP_GROUP_LOOKUP_ENABLED) ?
           ((mode == _IFP_SLICE_MODE_WIDE) ? 3 : 1) : 0;

    /*
     * When the TCAM Mode is Wide on a global view,
     * Install the entry on the Pipes to support the PBMP.
     */
    if ((mode == _IFP_SLICE_MODE_WIDE) &&
        (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) &&
        (soc_property_get(unit, spn_FIELD_ATOMIC_UPDATE, FALSE) == FALSE)) {
        uint8 set_pbmp = 0;
        _field_pbmp_t   pipe_pbmp[_FP_MAX_NUM_PIPES];

        if (_BCM_FIELD_QSET_PBMP_TEST(f_ent->group->qset)) {
           _field_entry_t  *entry_p = NULL;

           rv = _field_entry_get(unit, f_ent->eid, _FP_ENTRY_PRIMARY, &entry_p);
           BCM_IF_ERROR_RETURN(rv);

           /* If entry is the primary part, set the pbmp. */
           if (entry_p == f_ent) {
              set_pbmp = 1;
           }

           if ((set_pbmp == 1) ||
               ((soc_feature(unit, soc_feature_td3_style_fp) &&
                 BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInPorts)))) {
              sal_memset(&pipe_pbmp, 0x0,
                      sizeof(_field_pbmp_t) * _FP_MAX_NUM_PIPES);
              rv = _field_ingress_pipe_pbmp_get(unit, f_ent->group->qset,
                                                &entry_p->pbmp,
                                                pipe_pbmp, stage_fc->num_pipes);
              if (BCM_FAILURE(rv)) {
                 LOG_ERROR(BSL_LS_BCM_FP, (BSL_META("Failed to retrieve Pipe PBMP,"
                 " Failed to write PBMP on IFP_TCAM Pipes.\n\r")));
                 return BCM_E_INTERNAL;
              }
           }
        }

#if defined(BCM_TRIDENT3_SUPPORT)
        if (soc_feature(unit, soc_feature_td3_style_fp) &&
            BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyInPorts)) {
           rv = _bcm_field_td3_ifp_inports_entry_tcam_install(unit, f_ent, tcam_idx,
                                                              set_pbmp, pipe_pbmp,
                                                              stage_fc->num_pipes);
        } else
#endif /* BCM_TRIDENT3_SUPPORT */
        {
           rv = _field_ingress_entry_tcam_wide_install(unit, f_ent, tcam_idx,
                                                       set_pbmp, pipe_pbmp,
                                                       stage_fc->num_pipes);
        }

        if (BCM_FAILURE(rv)) {
             LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                   " Failed to write PBMP on IFP_TCAM Pipes.\n\r")));
             return BCM_E_INTERNAL;
        }

        return (BCM_E_NONE);
    }

    BCM_IF_ERROR_RETURN(soc_th_ifp_mem_read(unit,
                                     tcam_mem,
                                     MEM_BLOCK_ANY,
                                     tcam_idx,
                                     entry_buf));
    soc_mem_field_set(unit, tcam_mem, entry_buf, KEYf, tcam->key);
    soc_mem_field_set(unit, tcam_mem, entry_buf, MASKf, tcam->mask);

    soc_mem_field32_set(unit, tcam_mem, entry_buf, VALIDf, valid);
#if defined(BCM_TOMAHAWK2_SUPPORT)
    if (soc_feature(unit, soc_feature_xy_tcam_x0y) &&
        (soc_feature(unit, soc_feature_field_multi_pipe_enhanced) ||
         soc_feature(unit, soc_feature_th3_style_fp)) &&
        _BCM_FIELD_QSET_PBMP_TEST(f_ent->group->qset)) {
        bcm_pbmp_t      valid_pbm; /* valid_pbm in HW. */
        _field_entry_t  *entry_p = NULL;

        BCM_IF_ERROR_RETURN
            (_field_entry_get(unit, f_ent->eid, _FP_ENTRY_PRIMARY, &entry_p));
        /* If entry is the primary part, set the pbmp. */
        if (entry_p == f_ent) {
            BCM_PBMP_CLEAR(valid_pbm);
            soc_mem_field_width_fit_set(unit, tcam_mem, entry_buf, IPBMf,
                                        (uint32 *)&valid_pbm);
            BCM_PBMP_ASSIGN(valid_pbm, f_ent->pbmp.data);
            BCM_PBMP_AND(valid_pbm, f_ent->pbmp.mask);
            BCM_PBMP_XOR(valid_pbm, f_ent->pbmp.mask);
            soc_mem_field_width_fit_set(unit, tcam_mem, entry_buf, IPBM_MASKf,
                                        (uint32 *)&valid_pbm);
        }
   }
#endif /* BCM_TOMAHAWK2_SUPPORT */
    BCM_IF_ERROR_RETURN(soc_th_ifp_mem_write(unit,
                                      tcam_mem,
                                      MEM_BLOCK_ALL,
                                      tcam_idx,
                                      entry_buf));
   return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_th_vfp_efp_entry_qual_tcam_install
 * Purpose:
 *     Install the entry qualifiers in the VFP or EFP TCAM.
 * Parameters:
 *     unit         - (IN) BCM device number
 *     f_ent        - (IN) entry structure to get policy info from
 *     tcam_mem     - (IN) TCAM memory index.
 *     tcam_idx     - (IN) Index in the TCAM memory.
 * Returns:
 *     BCM_E_XXX
 */

STATIC int
_field_th_vfp_efp_entry_qual_tcam_install(int unit, _field_entry_t *f_ent,
                                          soc_mem_t tcam_mem, int tcam_idx)
{
    uint32          entry_buf[SOC_MAX_MEM_FIELD_WORDS] = {0};
                              /* Buffer to fill Policy & TCAM entry.*/
    uint8           valid = 0;
    soc_field_t     mask_field;
    _field_tcam_t   *tcam = NULL;
    uint8           hw_enable = 0, hw_disable = 0;


    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Update TCAM and Mask field as per the stage. */
    switch (f_ent->group->stage_id) {
        case _BCM_FIELD_STAGE_LOOKUP:
            tcam = &f_ent->tcam;
            mask_field = MASKf;
            break;
        case _BCM_FIELD_STAGE_EGRESS:
            tcam = (f_ent->efp_key_match_type) ?
                   &f_ent->key_match_tcam : &f_ent->tcam;
            mask_field = KEY_MASKf;
            break;
        default:
            return (BCM_E_INTERNAL);
    }

    if (tcam == NULL) {
       return BCM_E_INTERNAL;
    }

    if ((soc_feature(unit, soc_feature_field_multi_pipe_enhanced) ||
        soc_feature(unit, soc_feature_td3_style_fp)) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_LOOKUP)) {
        /* VALIDf in VFP_TCAM on TH2 only has one bit */
        hw_enable = 1;
        hw_disable = 0;
    } else if ((SOC_IS_TOMAHAWK3(unit)) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) ||
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_LOOKUP))) {
        /* VALIDf in EFP_TCAM on TH3 only has one bit */
        hw_enable = 1;
        hw_disable = 0;
    } else {
        hw_enable = 3;
        hw_disable = 2;
    }

    valid = (f_ent->group->flags & _FP_GROUP_LOOKUP_ENABLED)
             ? hw_enable:hw_disable;

    soc_mem_field_set(unit, tcam_mem, entry_buf, KEYf, tcam->key);
    soc_mem_field_set(unit, tcam_mem, entry_buf, mask_field, tcam->mask);

    soc_mem_field32_set(unit, tcam_mem, entry_buf, VALIDf, valid);

    BCM_IF_ERROR_RETURN(soc_th_ifp_mem_write(unit, tcam_mem, MEM_BLOCK_ALL,
                                      tcam_idx, entry_buf));
    return (BCM_E_NONE);
}


/*
 * Function:
 *     _bcm_field_th_tcam_policy_mem_get
 *
 * Purpose:
 *     Get tcam & policy memories for a specific chip pipeline stage.
 *
 * Parameters:
 *     unit       -  (IN)  BCM device number.
 *     f_ent     -   (IN)  Field entry.
 *     tcam_mem   -  (OUT) TCAM Memory id.
 *     policy_mem -  (OUT) Policy memory id.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_tcam_policy_mem_get(int unit,
                                  _field_entry_t *f_ent,
                                  soc_mem_t *tcam_mem,
                                  soc_mem_t *policy_mem)
{
    int   mode = 0;     /* IFP_TCAM mode */
    int   instance; /* Pipe Instance */
    soc_mem_t  vfp_tcam;
    soc_mem_t  vfp_policy_table;
    soc_mem_t  efp_tcam;
    soc_mem_t  efp_policy_table;
    soc_mem_t  ifp_tcam_wide;
    soc_mem_t  ifp_tcam_narrow;
    soc_mem_t  ifp_policy_table_wide;
    soc_mem_t  ifp_policy_table;
    soc_mem_t  em_uft_wide;
    soc_mem_t  em_uft_narrow;

    _field_stage_t *stage_fc; /* Reference to Stage control structure. */

    /* Input parameters check. */
    if ((NULL == f_ent) || (NULL == tcam_mem) || (NULL == policy_mem)) {
        return (BCM_E_PARAM);
    }

    if (NULL == f_ent->group) {
        return (BCM_E_INTERNAL);
    }

    BCM_IF_ERROR_RETURN
      (_field_stage_control_get (unit, f_ent->group->stage_id, &stage_fc));

    if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
       instance = _FP_GLOBAL_INST;
    } else {
       instance = f_ent->group->instance;
    }

    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit, VFP_TCAMm,
                                                       instance, &vfp_tcam));
    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit, VFP_POLICY_TABLEm,
                                                  instance, &vfp_policy_table));
    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit, EFP_TCAMm,
                                                       instance, &efp_tcam));
    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit, EFP_POLICY_TABLEm,
                                                  instance, &efp_policy_table));
    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                           IFP_TCAM_WIDEm,
                                           instance,
                                           &ifp_tcam_wide));
    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                           IFP_TCAMm,
                                           instance,
                                           &ifp_tcam_narrow));
    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                           IFP_POLICY_TABLEm,
                                           instance,
                                           &ifp_policy_table));
    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                           IFP_POLICY_TABLE_WIDEm,
                                           instance,
                                           &ifp_policy_table_wide));

    switch (f_ent->group->stage_id) {
       case _BCM_FIELD_STAGE_INGRESS:
            if (soc_feature(unit, soc_feature_ifp_no_narrow_mode_support)) {
                *tcam_mem = ifp_tcam_narrow;
            } else {
                mode = _BCM_FIELD_IS_SLICE_MODE_PBMP_SUPPORTED(f_ent->group->flags)?
                       _IFP_SLICE_MODE_WIDE : _IFP_SLICE_MODE_NARROW;
                *tcam_mem = (mode == _IFP_SLICE_MODE_WIDE) ?
                                ifp_tcam_wide:ifp_tcam_narrow;
            }

            if(soc_feature(unit, soc_feature_ifp_action_profiling)) {
                *policy_mem = (mode == _IFP_SLICE_MODE_WIDE) ?
                 ifp_policy_table_wide : ifp_policy_table;
            } else {
                *policy_mem = ifp_policy_table;
            }
            break;

       case _BCM_FIELD_STAGE_LOOKUP:
            *tcam_mem = vfp_tcam;
            *policy_mem = vfp_policy_table;
            break;

       case _BCM_FIELD_STAGE_EGRESS:
            *tcam_mem = efp_tcam;
            *policy_mem = efp_policy_table;
            break;
       case _BCM_FIELD_STAGE_EXACTMATCH:
            mode = (f_ent->group->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) ?
                _IFP_SLICE_MODE_WIDE : _IFP_SLICE_MODE_NARROW;
            BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       EXACT_MATCH_2m,
                                                       instance,
                                                       &em_uft_narrow));
            BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       EXACT_MATCH_4m,
                                                       instance,
                                                       &em_uft_wide));
            *tcam_mem = (mode == _IFP_SLICE_MODE_WIDE) ?
                        em_uft_wide : em_uft_narrow;
            *policy_mem = *tcam_mem;
            break;
#if defined(BCM_FLOWTRACKER_SUPPORT)
        case _BCM_FIELD_STAGE_FLOWTRACKER:
            if (soc_feature(unit, soc_feature_field_flowtracker_support)) {
                if (f_ent->fs->slice_number == 1) {
                    *tcam_mem = BSK_FTFP2_TCAMm;
                    *policy_mem = BSK_FTFP2_POLICYm;
                } else {
                    *tcam_mem = BSK_FTFP_TCAMm;
                    *policy_mem = BSK_FTFP_POLICYm;
                }
            } else {
                *tcam_mem = INVALIDm;
                *policy_mem = INVALIDm;
            }
            break;
#endif
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
        case _BCM_FIELD_STAGE_AMFTFP:
            if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
                *tcam_mem = BSK_AMFP_TCAMm;
                *policy_mem = BSK_AMFP_POLICYm;
            } else {
                *tcam_mem = INVALIDm;
                *policy_mem = INVALIDm;
            }
            break;
        case _BCM_FIELD_STAGE_AEFTFP:
            if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
                *tcam_mem = BSK_AEFP_TCAMm;
                *policy_mem = BSK_AEFP_POLICYm;
            } else {
                *tcam_mem = INVALIDm;
                *policy_mem = INVALIDm;
            }
            break;
#endif
       default:
            *tcam_mem = *policy_mem = INVALIDm;
            return BCM_E_PARAM;
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_th_default_policer_set
 *
 * Purpose:
 *     Get metering portion of Policy Table.
 *
 * Parameters:
 *     unit      - (IN)BCM device number.
 *     stage_fc  - (IN)Stage control structure.
 *     level     - (IN)Policer level.
 *     f_ent     - (IN)Software entry structure to get tcam info from.
 *     buf       - (IN/OUT)Hardware policy entry
 *
 * Returns:
 *     BCM_E_NONE  - Success
 */

STATIC int
_field_th_default_policer_set(int unit, _field_stage_t *stage_fc,
                               int level, _field_entry_t *f_ent, uint32 *buf)
{
    _bcm_field_action_offset_t  meter_info_offset; /* Meter Set for basic Meter info. */
    soc_format_t                fmt = IFP_METER_SETfmt;
    soc_field_info_t            *fld_info = NULL;
    int                         meter_base = 0;

    /* Input parameter check. */
    if ((NULL == stage_fc) || (NULL == buf) || (NULL == f_ent))  {
        return (BCM_E_PARAM);
    }

    sal_memset(&meter_info_offset, 0x0, sizeof(meter_info_offset));
    /*
     * For the legacy devices which doesn't support PDD format for IFP,
     * base offset for IFP_METER_SET will be non zero and part of IFP_POLICY_TABLE.
     */
    if ((_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)
        && (0 == soc_feature(unit, soc_feature_ifp_action_profiling))) {
        fld_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, METER_SETf);
        meter_base = fld_info->bp;
    } else {
        meter_base = 0;
    }

    /*
     * Get each meter field offset and width in format IFP_METE_SETfmt
     * and update respective meter_info_offset.
     */
    /* METER_PAIR_MODE */
    fld_info = NULL;
    fld_info = soc_format_fieldinfo_get(unit, fmt, METER_PAIR_MODEf);
    if (NULL == fld_info) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                        "IFP policer set failed for field %d\n\r"),
                    METER_PAIR_MODEf));
        return BCM_E_INTERNAL;
    }
    meter_info_offset.offset[1] = meter_base + fld_info->bp;
    meter_info_offset.width[1]  = fld_info->len;
    /* DEFAULT meter pair mode is enabled */
    meter_info_offset.value[1]  = 0;

    fld_info = NULL;
    fld_info = soc_format_fieldinfo_get(unit, fmt, METER_PAIR_MODE_MODIFIERf);
    if (NULL == fld_info) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                        "IFP policer set failed for field %d\n\r"),
                    METER_PAIR_MODE_MODIFIERf));
        return BCM_E_INTERNAL;
    }
    /* METER_PAIR_MODE_MODIFIER */
    meter_info_offset.offset[2] = meter_base + fld_info->bp;
    meter_info_offset.width[2]  = fld_info->len;
    /* Enable packet color modifier */
    meter_info_offset.value[2]  = 1;

    ACTION_SET(unit, f_ent, buf, &meter_info_offset);

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_th_ingress_policer_action_set
 *
 * Purpose:
 *     Get metering portion of Policy Table.
 *
 * Parameters:
 *     unit      - (IN)BCM device number.
 *     f_ent     - (IN)Software entry structure to get tcam info from.
 *     buf       - (IN/OUT)Hardware policy entry
 *
 * Returns:
 *     BCM_E_NONE  - Success
 */
int
_field_th_ingress_policer_action_set(int unit, _field_entry_t *f_ent,
                                     uint32 *buf)
{
    _field_entry_policer_t      *f_ent_pl;  /* Field entry policer descriptor.*/
    _field_stage_t              *stage_fc;  /* Stage field control structure. */
    _field_policer_t            *f_pl;      /* Field policer descriptor.      */
    int                         idx;        /* Policers levels iterator.      */
    uint32                      meter_pair_mode = BCM_FIELD_METER_MODE_DEFAULT;
    /* Hw meter usage bits.      */
    soc_format_t                fmt = IFP_METER_SETfmt;
    uint8                       meter_type = 0xff;
    soc_field_info_t            *fld_info = NULL;
    int                         meter_pair_idx;  /* Meter pair index.         */
    int                         rv;              /* Operation return status.  */
    _bcm_field_action_offset_t  meter_offset;    /* Meter Set for ODD_EVEN    */
    _bcm_field_action_offset_t  meter_info_offset;/* Meter Set for basic info */
    int                         instance;    /*  Current Pipe instance        */
    int                         meter_base = 0;    /* Meter base value */
    _field_stage_id_t      stage_id;  /* Stage id used for metering.          */

    /* Input parameter check. */
    if ((NULL == f_ent) || (NULL == buf))  {
        return (BCM_E_PARAM);
    }
    if (NULL == f_ent->group) {
        return (BCM_E_PARAM);
    }

    stage_id = (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id) ? \
               _BCM_FIELD_STAGE_INGRESS : f_ent->group->stage_id;

    /*
     * For the legacy devices which doesn't support PDD format for IFP,
     * base offset for IFP_METER_SET will be non zero and part of IFP_POLICY_TABLE.
     */
    if (0 == soc_feature(unit, soc_feature_ifp_action_profiling)) {
        fld_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, METER_SETf);
        meter_base = fld_info->bp;
    }

    /* Get stage control structure. */
    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Get the current pipe instance from group */
    instance = f_ent->group->instance;

    for (idx = 0; idx < _FP_POLICER_LEVEL_COUNT; idx++) {
        f_ent_pl = f_ent->policer + idx;

        if ((idx > 0)) {
            /* Trident device does not support Level1 policers */
            break;
        }

        if (0 == (f_ent_pl->flags & _FP_POLICER_INSTALLED)) {
            /* Install preserve the color policer. */
            rv = _field_th_default_policer_set(unit, stage_fc, idx,
                    f_ent, buf);
            BCM_IF_ERROR_RETURN(rv);
            continue;
        }

        /* Get policer config. */
        rv = _bcm_field_policer_get(unit, f_ent_pl->pid, &f_pl);
        BCM_IF_ERROR_RETURN(rv);

        if (0 == f_pl->level) {
            /* Get hw encoding for meter mode. */
            rv = _bcm_field_meter_pair_mode_get(unit, f_pl, &meter_pair_mode);
            BCM_IF_ERROR_RETURN(rv);
            /* If level 0 policer is Modified trTcm ->
             * meter sharing mode is dual.
             */
        }


        /* Pair index is (Pool number * Pairs in Pool + Pair number) */
        meter_pair_idx
            = (f_pl->pool_index
                    * (stage_fc->meter_pool[instance][f_pl->pool_index]->num_meter_pairs))
            + (f_pl->hw_index);

        sal_memset(&meter_info_offset, 0x0, sizeof(meter_info_offset));
        sal_memset(&meter_offset, 0x0, sizeof(meter_offset));

        /*
         * Get each meter field offset and width in format IFP_METE_SETfmt
         * and update respective meter_info_offset.
         */
        fld_info = NULL;
        fld_info = soc_format_fieldinfo_get(unit, fmt, METER_PAIR_INDEXf);
        if (NULL == fld_info) {
            LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                            "IFP policer set failed for field %d\n\r"),
                        METER_PAIR_INDEXf));
            return BCM_E_INTERNAL;
        }
        /* METER_PAIR_INDEX */
        meter_info_offset.offset[0] = meter_base + fld_info->bp;
        meter_info_offset.width[0]  = fld_info->len;
        /* Program meter pair index */
        meter_info_offset.value[0]  = meter_pair_idx;

        fld_info = NULL;
        fld_info = soc_format_fieldinfo_get(unit, fmt, METER_PAIR_MODEf);
        if (NULL == fld_info) {
            LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                            "IFP policer set failed for field %d\n\r"),
                        METER_PAIR_MODEf));
            return BCM_E_INTERNAL;
        }
        /* METER_PAIR_MODE */
        meter_info_offset.offset[1] = meter_base + fld_info->bp;
        meter_info_offset.width[1]  = fld_info->len;
        /* H/W encoding of meter pair mode based on policer level */
        meter_info_offset.value[1]  = meter_pair_mode;

        /*
         * Flow mode is the only one that cares about the test and
         * update bits.
         */
        if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
            /* Excess meter - even index. */
            meter_type = _FIELD_METER_TYPE_EVEN;
        } else if (_FP_POLICER_COMMITTED_HW_METER(f_pl)) {
            /* Committed meter - odd index. */
            meter_type = _FIELD_METER_TYPE_ODD;
        } else {
            meter_type = 0xff;
        }

        if (0xff != meter_type) {
            fld_info = NULL;
            fld_info = soc_format_fieldinfo_get(unit, fmt, METER_TEST_ODDf);
            if (NULL == fld_info) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                                "IFP policer set failed for field %d\n\r"),
                            METER_TEST_ODDf));
                return BCM_E_INTERNAL;
            }
            /* METER_TEST_ODD */
            meter_offset.offset[0] = meter_base + fld_info->bp;
            meter_offset.width[0]  = fld_info->len;
            /* Enable only for Odd idx or Committed meter otherwise disable it */
            meter_offset.value[0]  = (_FIELD_METER_TYPE_ODD == meter_type);

            fld_info = NULL;
            fld_info = soc_format_fieldinfo_get(unit, fmt, METER_TEST_EVENf);
            if (NULL == fld_info) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                                "IFP policer set failed for field %d\n\r"),
                            METER_TEST_EVENf));
                return BCM_E_INTERNAL;
            }
            /* METER_TEST_EVEN */
            meter_offset.offset[1] = meter_base + fld_info->bp;
            meter_offset.width[1]  = fld_info->len;
            /* Enable only for Even idx or Excess meter otherwise disable it */
            meter_offset.value[1]  = (_FIELD_METER_TYPE_EVEN == meter_type);

            fld_info = NULL;
            fld_info = soc_format_fieldinfo_get(unit, fmt, METER_UPDATE_ODDf);
            if (NULL == fld_info) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                                "IFP policer set failed for field %d\n\r"),
                            METER_UPDATE_ODDf));
                return BCM_E_INTERNAL;
            }
            /* METER_UPDATE_ODD */
            meter_offset.offset[2] = meter_base + fld_info->bp;
            meter_offset.width[2]  = fld_info->len;
            /* Enable only for Odd idx or Committed meter otherwise disable it */
            meter_offset.value[2]  = (_FIELD_METER_TYPE_ODD == meter_type);

            fld_info = NULL;
            fld_info = soc_format_fieldinfo_get(unit, fmt, METER_UPDATE_EVENf);
            if (NULL == fld_info) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                                "IFP policer set failed for field %d\n\r"),
                            METER_UPDATE_EVENf));
                return BCM_E_INTERNAL;
            }
            /* METER_UPDATE_EVEN */
            meter_offset.offset[3] = meter_base + fld_info->bp;
            meter_offset.width[3]  = fld_info->len;
            /* Enable only for Even idx or Excess meter otherwise disable it */
            meter_offset.value[3]  = (_FIELD_METER_TYPE_EVEN == meter_type);
        }

        if ((f_pl->cfg.mode == bcmPolicerModePassThrough) ||
                (f_pl->cfg.mode == bcmPolicerModeSrTcmModified)) {

            fld_info = NULL;
            fld_info = soc_format_fieldinfo_get(unit, fmt, METER_PAIR_MODE_MODIFIERf);
            if (NULL == fld_info) {
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                                "IFP policer set failed for field %d\n\r"),
                            METER_PAIR_MODE_MODIFIERf));
                return BCM_E_INTERNAL;
            }
            /* METER_PAIR_MODE_MODIFIER */
            meter_info_offset.offset[2] = meter_base + fld_info->bp;
            meter_info_offset.width[2]  = fld_info->len;
            /* Enable packet color modifier */
            meter_info_offset.value[2]  = 1;
        }

        ACTION_SET(unit, f_ent, buf, &meter_offset);
        ACTION_SET(unit, f_ent, buf, &meter_info_offset);
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_th_ingress_entry_policy_mem_install
 * Purpose:
 *     Install the entry actions into the policy table.
 * Parameters:
 *     unit         - (IN) BCM device number
 *     f_ent        - (IN) entry structure to get policy info from
 *     policy_mem   - (IN) Policy table memory
 *     tcam_idx     - (IN) Common index of various tables
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_ingress_entry_policy_mem_install(int unit, _field_entry_t *f_ent,
                                           soc_mem_t policy_mem, int tcam_idx)
{
    uint32            e_buf[SOC_MAX_MEM_FIELD_WORDS] = {0};
                                       /* Buffer to fill Policy entry.        */
    _field_action_t   *fa = NULL;      /* Reference to field action structure */
    int               rv;              /* Operation return status.            */
    int               policy_idx;      /* Policy index in the Policy table.   */
    uint8             entry_part;      /* Entry part number in wider group    */
    soc_field_info_t * f_info;

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }


    /*
     * TH/TH2/TD3 (Intra Slice) Double Wide/ Triple wide modes,
     * IFP_TCAM_WIDE have 256 entries but IFP_POLICY_TABLE will have 512 entries.
     * In TH3, IFP_POLICY_TABLE_WIDE mode is used for TCAM Wide modes and
     * entries are 1:1 mapped.
     */
    if ((SOC_IS_TOMAHAWKX(unit) && !(SOC_IS_TOMAHAWK3(unit)) &&
        (!(f_ent->group->flags & _FP_GROUP_SPAN_SINGLE_SLICE) ||
          (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)))) {
        policy_idx = tcam_idx + (f_ent->fs->slice_number * 256);
    } else {
        policy_idx = tcam_idx;
    }

    /* Get the entry part number from entry flags */
    _bcm_field_th_entry_flags_to_tcam_part(unit, f_ent->flags,
                                   f_ent->group->flags, &entry_part);

    if (entry_part != 0) {
        /* policy install is needed only for Entry part 0
          of wider groups */
        return BCM_E_NONE;
    }
    /* Extract the policy info from the entry structure. */
    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
        /* Skip the invalid entries */
        if (_FP_ACTION_VALID & fa->flags) {
            rv = _bcm_field_th_action_set(unit, policy_mem, f_ent,
                                          policy_idx, fa, e_buf);
            if (BCM_FAILURE(rv)) {
               LOG_ERROR(BSL_LS_BCM_FP, (BSL_META("TH Action set failed.\n")));
               return rv;
            }
        }
    }

    /*
     * Handle color dependence/independence
     * (1 bit field in GREEN_TO_PID_SET)
     */
    {
       _bcm_field_action_offset_t  a_offset;
       sal_memset(&a_offset, 0x0, sizeof(a_offset));
       f_info = soc_mem_fieldinfo_get(unit, IFP_POLICY_TABLEm, GREEN_TO_PID_SETf);
       a_offset.offset[0] = f_info->bp;
       a_offset.width[0]  = 1;
       a_offset.value[0]  = ((f_ent->flags & _FP_ENTRY_COLOR_INDEPENDENT)
                              ? 1 : 0);
       ACTION_SET(unit, f_ent, e_buf, &a_offset);
    }

    /* Extract meter related policy fields */
    BCM_IF_ERROR_RETURN
        (_field_th_ingress_policer_action_set(unit, f_ent, e_buf));

    if ( (f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) &&
         (!(f_ent->statistic.flags & _FP_ENTRY_STAT_DIRTY)) &&
         (f_ent->statistic.flags & _FP_ENTRY_STAT_VALID) ) {
        uint32     val;
        uint32     count;
        uint32     counter_set;
        uint32     data[SOC_MAX_MEM_FIELD_WORDS] = {0};
        /* retain counter values. */

        /* Read policy entry from current tcam index. */
        rv = soc_th_ifp_mem_read(unit, policy_mem, MEM_BLOCK_ANY,
                                policy_idx, data);
        BCM_IF_ERROR_RETURN(rv);

        val = soc_mem_field32_get(unit, policy_mem, data, FLEX_CTR_POOL_NUMBERf);
        soc_mem_field32_set(unit, policy_mem, e_buf, FLEX_CTR_POOL_NUMBERf, val);
        val = soc_mem_field32_get(unit, policy_mem, data, FLEX_CTR_OFFSET_MODEf);
        soc_mem_field32_set(unit, policy_mem, e_buf, FLEX_CTR_OFFSET_MODEf, val);
        val = soc_mem_field32_get(unit, policy_mem, data, FLEX_CTR_BASE_COUNTER_IDXf);
        soc_mem_field32_set(unit, policy_mem, e_buf, FLEX_CTR_BASE_COUNTER_IDXf, val);

        count = soc_mem_field32_get(unit, policy_mem, data, Y_COUNTf);
        soc_mem_field32_set(unit, policy_mem, e_buf, Y_COUNTf, count);
        count = soc_mem_field32_get(unit, policy_mem, data, G_COUNTf);
        soc_mem_field32_set(unit, policy_mem, e_buf, G_COUNTf, count);
        count = soc_mem_field32_get(unit, policy_mem, data, R_COUNTf);
        soc_mem_field32_set(unit, policy_mem, e_buf, R_COUNTf, count);

        counter_set = soc_mem_field32_get(unit, policy_mem, data, COUNTER_SETf);
        soc_mem_field32_set(unit, policy_mem, e_buf, COUNTER_SETf, counter_set);
    } else {
        /* Extract counter related policy fields */
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_flex_stat_action_set(unit, f_ent, policy_mem,
                                              policy_idx, e_buf));
    }


    /* Write the POLICY Table */
    rv = soc_th_ifp_mem_write(unit, policy_mem, MEM_BLOCK_ALL, policy_idx, e_buf);
    return (rv);
}

/*
 * Function:
 *     _field_th_vfp_efp_entry_policy_mem_install
 * Purpose:
 *     Install the entry actions into the policy table.
 * Parameters:
 *     unit         - (IN) BCM device number
 *     f_ent        - (IN) entry structure to get policy info from
 *     policy_mem   - (IN) Policy table memory
 *     policy_idx   - (IN) Index to the Policy Memory Table.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_vfp_efp_entry_policy_mem_install(int unit, _field_entry_t *f_ent,
                                           soc_mem_t policy_mem, int policy_idx)
{
    uint32            e_buf[SOC_MAX_MEM_FIELD_WORDS] = {0};
                                       /* Buffer to fill Policy entry.        */

    int               rv;              /* Operation return status.            */

    _field_action_t   *fa = NULL;      /* Reference to field action structure */

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Extract the policy info from the entry structure. */
    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
        /* Skip the invalid entries */
        if (_FP_ACTION_VALID & fa->flags) {
            rv = _bcm_field_trx_action_get(unit, policy_mem, f_ent,
                                           policy_idx, fa, e_buf);
            if (BCM_FAILURE(rv)) {
               LOG_ERROR(BSL_LS_BCM_FP, (BSL_META("TH Action set failed.\n")));
               return rv;
            }
        }
    }

    /* Extract meter related policy fields */
    if (((soc_feature(unit, soc_feature_field_egress_metering))
         && (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS))
         || (f_ent->group->stage_id != _BCM_FIELD_STAGE_EGRESS)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_trx_policer_action_set(unit, f_ent, policy_mem, e_buf));
    }

    /* Extract counter related policy fields */
    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_LOOKUP) {
       BCM_IF_ERROR_RETURN(_bcm_field_th_flex_stat_action_set(unit, f_ent,
                                          policy_mem, policy_idx, e_buf));
    } else {
       BCM_IF_ERROR_RETURN(_bcm_field_trx_stat_action_set(unit, f_ent,
                                      policy_mem, policy_idx, e_buf));
#ifdef BCM_TRIDENT2PLUS_SUPPORT
       if (soc_feature(unit, soc_feature_td3_style_fp)) {
           rv = _bcm_field_td2plus_extended_stat_action_set(unit, f_ent,
                                         policy_mem, policy_idx, e_buf);
           BCM_IF_ERROR_RETURN(rv);
       }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

    }

    /* Write the POLICY Table */
    rv = soc_th_ifp_mem_write(unit, policy_mem, MEM_BLOCK_ALL, policy_idx, e_buf);
    return (rv);
}


/*
 * Function:
 *     _field_th_entry_policy_mem_install
 * Purpose:
 *     Install the entry actions into the policy table.
 * Parameters:
 *     unit         - (IN) BCM device number
 *     f_ent        - (IN) entry structure to get policy info from
 *     policy_mem   - (IN) Policy table memory
 *     tcam_idx     - (IN) Common index of various tables
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_entry_policy_mem_install(int unit, _field_entry_t *f_ent,
                                   soc_mem_t policy_mem, int tcam_idx)
{
    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    switch (f_ent->group->stage_id) {
        case _BCM_FIELD_STAGE_INGRESS:
#if defined(BCM_TRIDENT3_SUPPORT)
             if(soc_feature(unit, soc_feature_ifp_action_profiling)) {
                 return _field_td3_ingress_entry_policy_mem_install(unit,
                                              f_ent, policy_mem, tcam_idx);
             } else
#endif
	     {
                 return _field_th_ingress_entry_policy_mem_install(unit,
                                              f_ent, policy_mem, tcam_idx);
             }
        case _BCM_FIELD_STAGE_EGRESS:
        case _BCM_FIELD_STAGE_LOOKUP:
             return _field_th_vfp_efp_entry_policy_mem_install(unit, f_ent,
                                                     policy_mem, tcam_idx);
#if defined(BCM_FLOWTRACKER_SUPPORT)
        case _BCM_FIELD_STAGE_FLOWTRACKER:
             if (soc_feature(unit, soc_feature_field_flowtracker_support)) {
                return _field_hx5_ft_entry_policy_mem_install(unit,
                                              f_ent, policy_mem, tcam_idx);
            }
            break;
#endif
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
        case _BCM_FIELD_STAGE_AMFTFP:
        case _BCM_FIELD_STAGE_AEFTFP:
            if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
                return _field_fb6_aft_entry_policy_mem_install(unit,
                                             f_ent, policy_mem, tcam_idx);
            }
            break;
#endif
        default:
             break;
    }

    return (BCM_E_INTERNAL);
}

/*
 * Function:
 *     _field_th_entry_qual_tcam_install
 * Purpose:
 *     Install the entry qualifiers in the TCAM.
 * Parameters:
 *     unit         - (IN) BCM device number
 *     f_ent        - (IN) entry structure to get policy info from
 *     tcam_mem     - (IN) TCAM memory index.
 *     tcam_idx     - (IN) Index in the TCAM memory.
 * Returns:
 *     BCM_E_XXX
 */

STATIC int
_field_th_entry_qual_tcam_install(int unit, _field_entry_t *f_ent,
                                  soc_mem_t tcam_mem, int tcam_idx)
{
    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    switch (f_ent->group->stage_id) {
        case _BCM_FIELD_STAGE_INGRESS:
            return _field_th_ingress_entry_qual_tcam_install(unit, f_ent,
                                                     tcam_mem, tcam_idx);
        case _BCM_FIELD_STAGE_EGRESS:
        case _BCM_FIELD_STAGE_LOOKUP:
            return _field_th_vfp_efp_entry_qual_tcam_install(unit, f_ent,
                                                     tcam_mem, tcam_idx);
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
        case _BCM_FIELD_STAGE_AMFTFP:
        case _BCM_FIELD_STAGE_AEFTFP:
            if (soc_feature(unit,
                        soc_feature_field_flowtracker_v3_support)) {
                return _field_fb6_aft_entry_qual_tcam_install(unit,
                        f_ent, tcam_mem, tcam_idx);
            }
#endif
        default:
            break;
    }

    return (BCM_E_INTERNAL);
}

/*
 * Function:
 *     _bcm_field_th_entry_install
 * Purpose:
 *     Write entry into the device hardware TCAM memory.
 * Parameters:
 *     unit     -   (IN) BCM Device Number
 *     f_ent    -   (IN) Physical entry structure to be installed
 *     tcam_idx -   (IN) common index of various tables
 * Returns:
 *     BCM_E_XXX        On TCAM read/write errors
 *     BCM_E_NONE
 * Note:
 *     Unit lock should be held by calling function.
 */
int
_bcm_field_th_entry_install(int unit, _field_entry_t *f_ent,
                                    int tcam_idx)
{
    int              rv = BCM_E_INTERNAL; /* Return Value            */
    soc_mem_t        tcam_mem;            /* TCAM memory id.         */
    soc_mem_t        policy_mem;          /* Policy table memory id. */
    uint8            enabled = 0;

    /* Input parameters check. */
    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    if (NULL == f_ent->fs || NULL == f_ent->group) {
        return BCM_E_INTERNAL;
    }

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER) {
        return _field_hx5_ft_entry_tcam_policy_install(unit, f_ent, tcam_idx);
    }
#endif

    rv = _bcm_field_th_tcam_policy_mem_get(unit, f_ent,
                                       &tcam_mem, &policy_mem);
    BCM_IF_ERROR_RETURN(rv);

    if ((tcam_idx < soc_mem_index_min(unit, tcam_mem)) ||
        (tcam_idx > soc_mem_index_max(unit, tcam_mem))) {
        return (BCM_E_PARAM);
    }

    if ((f_ent->fs->slice_flags & _BCM_FIELD_SLICE_HW_ENABLE) == 0)  {
       if (BCM_FAILURE(_bcm_field_th_slice_enable_set(unit,
                                             f_ent->group, f_ent->fs, 1))) {
          LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                   "Failed to Enable Field Slice[%d] for Entry[%d].\n\r"),
                   f_ent->fs->slice_number, f_ent->eid));
       }
       f_ent->fs->slice_flags |= _BCM_FIELD_SLICE_HW_ENABLE;
       enabled = 1;
    }


    /* Write actions into Policy Table */
    rv = _field_th_entry_policy_mem_install(unit, f_ent, policy_mem, tcam_idx);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                 "Failed to Install Policy Table for Entry[%d]"
                 " tcam_idx:[%d].\n\r"),
                 f_ent->eid, tcam_idx));
        goto cleanup;
    }

    /* Write qualifiers into TCAM */
    rv = _field_th_entry_qual_tcam_install(unit, f_ent, tcam_mem, tcam_idx);

    /* Enable the Slice if it is the first Entry */
    if (BCM_SUCCESS(rv)) {
       /*
        * Check for Entry installed or not.
        * Hw_ent_count shoudb be incremented only once per an entry.
        */
       if (0 == (f_ent->flags & _FP_ENTRY_INSTALLED)) {
           /* Increment the HW Slice entry count */
           f_ent->fs->hw_ent_count++;
       }
    } else {
       LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                 "Failed to Install the TCAM Entry[%d] tcam_idx:[%d].\n\r"),
                 f_ent->eid, tcam_idx));
       goto cleanup;
    }

    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
        "==> %s(): Entry[%d] Installed - mem:%d tcam_idx:%d slice:%d\n\r"),
         __func__, f_ent->eid, tcam_mem, tcam_idx, f_ent->fs->slice_number));

    return rv;

cleanup:
    if ((enabled == 1) && (f_ent->fs->slice_flags & _BCM_FIELD_SLICE_HW_ENABLE)) {
        if (BCM_FAILURE(_bcm_field_th_slice_enable_set(unit, f_ent->group,
                                                       f_ent->fs, 0))) {
            LOG_WARN(BSL_LS_BCM_FP, (BSL_META("Failed to Disable Field"
                                      " Slice[%d] for Entry[%d].\n\r"),
                                      f_ent->fs->slice_number, f_ent->eid));
        }
        f_ent->fs->slice_flags &= ~_BCM_FIELD_SLICE_HW_ENABLE;
    }
    return rv;

}

/*
 * Function:
 *     _bcm_field_th_entry_reinstall
 * Purpose:
 *     Write entry into the chip's memory.
 * Parameters:
 *     unit     -   BCM Unit
 *     f_ent    -   Physical entry structure to be installed
 *     tcam_idx - common index of various tables
 * Returns:
 *     BCM_E_XXX        On TCAM read/write errors
 *     BCM_E_NONE
 * Note:
 *     Unit lock should be held by calling function.
 */
int
_bcm_field_th_entry_reinstall(int unit, _field_entry_t *f_ent, int tcam_idx)
{
    int              rv = BCM_E_INTERNAL; /* Return Value */
    soc_mem_t        tcam_mem;          /* TCAM memory id.                    */
    soc_mem_t        policy_mem;        /* Policy table memory id .           */

    /* Input parameters check. */
    if (NULL == f_ent) {
       return (BCM_E_PARAM);
    }

    if (NULL == f_ent->fs) {
       return (BCM_E_PARAM);
    }

    rv = _bcm_field_th_tcam_policy_mem_get(unit, f_ent,
                                       &tcam_mem, &policy_mem);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    rv = _bcm_field_fb6_entry_sw_to_hw_tcam_idx(unit,
            f_ent->fs, tcam_idx, &tcam_idx);
    BCM_IF_ERROR_RETURN(rv);
#endif


    if ((tcam_idx < soc_mem_index_min(unit, tcam_mem)) ||
        (tcam_idx > soc_mem_index_max(unit, tcam_mem))) {
        return (BCM_E_PARAM);
    }

    /* Write actions into Policy Table */
    rv = _field_th_entry_policy_mem_install(unit, f_ent, policy_mem, tcam_idx);
    return rv;
}

/*
 * Function:
 *     _field_th_qual_tcam_key_mask_get
 * Purpose:
 *     Allocate & read from hw tcam key/mask image.
 * Parameters:
 *     unit  - (IN)     BCM device number.
 *     f_ent - (IN/OUT) Field entry.
 *     tcam  - (IN)     Reference to Entry TCAM structure.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_qual_tcam_key_mask_get(int unit,
                                 _field_entry_t *f_ent,
                                 _field_tcam_t *tcam)
{
    int             rv = BCM_E_INTERNAL; /* Return Value */
    uint32          tcam_key_words;      /* tcam key length */
    soc_field_t     mask_field;          /* Mask field */
    soc_mem_t       tcam_mem;            /* TCAM Memory name */
    soc_mem_t       policy_mem;          /* Policy Memory name */


    /* Validate input parameters */
    if (NULL == f_ent || NULL == tcam) {
       return BCM_E_PARAM;
    }

    /* Validate the group */
    if (NULL == f_ent->fs || NULL == f_ent->group) {
       return BCM_E_INTERNAL;
    }

    mask_field = (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) ?
                 KEY_MASKf : MASKf;

    BCM_IF_ERROR_RETURN
        (_bcm_field_th_tcam_policy_mem_get(unit, f_ent,
                                       &tcam_mem, &policy_mem));
    /*
     * Always use Per-pipe view for IFP_TCAM_WIDE memory
     * in-case of Global mode.
     */
    if (tcam_mem == IFP_TCAM_WIDEm) {
        tcam_mem = IFP_TCAM_WIDE_PIPE0m;
    } else if (tcam_mem == IFP_TCAMm) {
        tcam_mem = IFP_TCAM_PIPE0m;
    }

    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        if (f_ent->group->em_mode == _FieldExactMatchMode128) {
            tcam_key_words = BITS2WORDS(soc_mem_field_length(unit,
                                                         tcam_mem,
                                             MODE128__KEY_0_ONLYf)
                                      + soc_mem_field_length(unit,
                                                         tcam_mem,
                                            MODE128__KEY_1_ONLYf));
        } else if (f_ent->group->em_mode == _FieldExactMatchMode160) {
            tcam_key_words = BITS2WORDS(soc_mem_field_length(unit,
                                                         tcam_mem,
                                             MODE160__KEY_0_ONLYf)
                                      + soc_mem_field_length(unit,
                                                         tcam_mem,
                                            MODE160__KEY_1_ONLYf));
        } else if (f_ent->group->em_mode == _FieldExactMatchMode320) {
            tcam_key_words = BITS2WORDS(soc_mem_field_length(unit,
                                                   EXACT_MATCH_2m,
                                             MODE160__KEY_0_ONLYf)
                                      + soc_mem_field_length(unit,
                                                   EXACT_MATCH_2m,
                                            MODE160__KEY_1_ONLYf));
        } else {
            /* Invalid Exact Match Mode. */
            return (BCM_E_INTERNAL);
        }
    } else {
        tcam_key_words = BITS2WORDS(soc_mem_field_length(unit,
                                                     tcam_mem,
                                                        KEYf));
    }

    /* Retrieve the key size */
    tcam->key_size = WORDS2BYTES(tcam_key_words);

    /* Allocate Memory for TCAM Key and Mask */
    _FP_XGS3_ALLOC(tcam->key, tcam->key_size, "TH TCAM Key Alloc.");
    _FP_XGS3_ALLOC(tcam->mask, tcam->key_size, "TH TCAM Mask Alloc.");
    if (tcam->key == NULL || tcam->mask == NULL) {
        rv = BCM_E_MEMORY;
        goto error;
    }

    /* Only applicable for ingress stage. */
    if (f_ent->group->stage_id != _BCM_FIELD_STAGE_EXACTMATCH) {
        if (f_ent->flags & _FP_ENTRY_INSTALLED) {
            int    tcam_idx;
            uint32 tcam_entry[SOC_MAX_MEM_FIELD_WORDS] = {0};

            rv = _bcm_field_entry_tcam_idx_get(unit, f_ent, &tcam_idx);
            if (BCM_FAILURE(rv)) {
                goto error;
            }

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
            if (soc_feature(unit,
                        soc_feature_field_flowtracker_v3_support)) {
                rv = _bcm_field_fb6_entry_sw_to_hw_tcam_idx(unit,
                        f_ent->fs, tcam_idx, &tcam_idx);
                if (BCM_FAILURE(rv)) {
                    goto error;
                }
            }
#endif

            if(f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) {
                rv = soc_mem_read(unit,
                                  tcam_mem,
                                  MEM_BLOCK_ANY,
                                  tcam_idx,
                                  tcam_entry);
            } else {
                rv = soc_th_ifp_mem_read(unit,
                    tcam_mem,
                    MEM_BLOCK_ANY,
                    tcam_idx,
                    tcam_entry);
            }
            if (BCM_FAILURE(rv)) {
                goto error;
            }
            soc_mem_field_get(unit, tcam_mem, tcam_entry,
                              KEYf, tcam->key);
            soc_mem_field_get(unit, tcam_mem, tcam_entry,
                              mask_field, tcam->mask);
        }
    }

    return (BCM_E_NONE);

 error:
    if (tcam->key) {
        sal_free(tcam->key);
        tcam->key = NULL;
    }
    if (tcam->mask) {
        sal_free(tcam->mask);
        tcam->mask = NULL;
    }

    return rv;
}

/*
 * Function:
 *     _bcm_field_qual_tcam_key_mask_get
 * Purpose:
 *     Allocate & read from hw tcam key/mask image.
 * Parameters:
 *     unit  - (IN)     BCM device number.
 *     f_ent - (IN/OUT) Field entry.
 *     tcam  - (IN)     Reference to Entry TCAM structure.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_qual_tcam_key_mask_get(int unit,
                                     _field_entry_t *f_ent,
                                     _field_tcam_t  *tcam)
{
    int rv = BCM_E_NONE;  /* Return value */

    /* Validate input parameters */
    if (NULL == f_ent || NULL == tcam) {
       return BCM_E_PARAM;
    }

    switch (f_ent->group->stage_id) {
       case _BCM_FIELD_STAGE_INGRESS:
       case _BCM_FIELD_STAGE_LOOKUP:
       case _BCM_FIELD_STAGE_EGRESS:
       case _BCM_FIELD_STAGE_EXACTMATCH:
       case _BCM_FIELD_STAGE_FLOWTRACKER:
       case _BCM_FIELD_STAGE_AMFTFP:
       case _BCM_FIELD_STAGE_AEFTFP:
          rv = _field_th_qual_tcam_key_mask_get(unit, f_ent, tcam);
          break;
       default:
          rv = BCM_E_INTERNAL;
          break;
    }

    return rv;
}

/*
 * Function:
 *     _field_th_ingress_tcam_policy_clear
 *
 * Purpose:
 *     Writes a null entry into the TCAM plus Policy table.
 *
 * Parameters:
 *     unit      -   (IN) BCM device number.
 *     f_ent     -   (IN) Field entry.
 *     tcam_idx  -   (IN) Entry tcam index.
 *
 * Returns:
 *     BCM_E_XXX
 *
 * Note:
 *     Unit lock should be held by calling function.
 */
STATIC int
_field_th_ingress_tcam_policy_clear(int unit, _field_entry_t *f_ent,
                                    int tcam_idx)
{
    soc_mem_t      tcam_mem;            /* TCAM memory id.                */
    soc_mem_t      policy_mem;          /* Policy table memory id .       */

    _field_stage_t *stage_fc;           /* Stage field control structure. */
    int              num_tcams = 0;     /* Number of TCAMs                */
    int              ct;
    int policy_idx;                     /* Policy index in the Policy table. */
    soc_mem_t      tcam_mem_global;     /* Global TCAM Id */
    uint8          per_pipe_mode = FALSE;

    /* Validate input parameters */
    if (NULL == f_ent) {
       return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN
       (_bcm_field_th_tcam_policy_mem_get(unit, f_ent, &tcam_mem, &policy_mem));
    tcam_mem_global = tcam_mem;

    /* Get field stage control . */
    BCM_IF_ERROR_RETURN
       (_field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc));

    /*
     * When the TCAM Mode is Wide on a global view,
     * Clear entries from the Pipes.
     */
    if (((tcam_mem == IFP_TCAM_WIDEm) ||
        ((soc_feature(unit, soc_feature_th3_style_fp)) &&
        (tcam_mem == IFP_TCAMm))) &&
        (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) &&
        (soc_property_get(unit, spn_FIELD_ATOMIC_UPDATE, FALSE) == FALSE)) {
       num_tcams = stage_fc->num_pipes;
       per_pipe_mode = TRUE;
    } else {
       num_tcams = 1; /* tcam name is fetched in tcam_mem */
    }

    for (ct = 0; ct < num_tcams; ct++) {
       if (per_pipe_mode == TRUE) {
           BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                       tcam_mem_global,
                                       ct,
                                       &tcam_mem));
       }

       /* Memory index sanity check. */
       if (tcam_idx > soc_mem_index_max(unit, tcam_mem)) {
          return (BCM_E_PARAM);
       }

       /* Write the TCAM & Policy Tables */
       SOC_IF_ERROR_RETURN
           (soc_th_ifp_mem_write(unit, tcam_mem, MEM_BLOCK_ALL, tcam_idx,
                          soc_mem_entry_null(unit, tcam_mem)));
    }

    /*
     * TH/TH2/TD3 (Intra Slice) Double Wide/ Triple wide modes,
     * IFP_TCAM_WIDE have 256 entries but IFP_POLICY_TABLE will have 512 entries.
     * In TH3, IFP_POLICY_TABLE_WIDE mode is used for TCAM Wide modes and
     * entries are 1:1 mapped.
     */
    if ((SOC_IS_TOMAHAWKX(unit) && !(SOC_IS_TOMAHAWK3(unit)) &&
        (!(f_ent->group->flags & _FP_GROUP_SPAN_SINGLE_SLICE) ||
        (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)))) {
        policy_idx = tcam_idx + (f_ent->fs->slice_number * 256);
    } else {
        policy_idx = tcam_idx;
    }

    SOC_IF_ERROR_RETURN
       (soc_th_ifp_mem_write(unit, policy_mem, MEM_BLOCK_ALL, policy_idx,
                      soc_mem_entry_null(unit, policy_mem)));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_entry_move
 * Purpose:
 *     Copy an entry from one TCAM index to another. It copies the values in
 *     hardware from the old index to the new index.
 *     IT IS ASSUMED THAT THE NEW INDEX IS EMPTY (VALIDf=00) IN HARDWARE.
 *     The old Hardware index is cleared at the end.
 * Parameters:
 *     unit           - (IN) BCM device number.
 *     f_ent          - (IN) Entry to move
 *     parts_count    - (IN) Field entry parts count.
 *     tcam_idx_old   - (IN) Source entry tcam index.
 *     tcam_idx_new   - (IN) Destination entry tcam index.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_entry_move(int unit, _field_entry_t *f_ent, int parts_count,
                         int *tcam_idx_old, int *tcam_idx_new)
{
    static uint32  entry_buf[BCM_MAX_NUM_UNITS][25];
                                        /* For TCAM                           */
    static uint32  policy_buf[BCM_MAX_NUM_UNITS][25];
                                        /* For policies                       */
    soc_mem_t tcam_mem;                 /* TCAM memory id.                    */
    soc_mem_t policy_mem;               /* Policy table memory id .           */
    int tcam_idx_max;                   /* TCAM memory max index.             */
    int tcam_idx_min;                   /* TCAM memory min index.             */
    _field_stage_t *stage_fc;           /* Stage field control structure.     */
    _field_stage_id_t stage_id;         /* Field pipeline stage id.           */
    int idx;                            /* Iteration index.                   */
    _field_group_t   *fg;               /* Field group structure.             */
    _field_slice_t *fs = NULL;
    int              rv;                /* Operation return status.           */
    int              is_backup_entry = 0; /* Flag ,checks the entry is
                                             backup entry or not*/
    int              num_tcams = 0;     /* Number of TCAMs                    */
    int              ct;
    int              policy_idx;
    int              new_slice_idx = 0, /* New slice number and index.        */
                     new_slice_numb = 0;
    uint8            enabled = 0;
    uint8            per_pipe_mode = FALSE;
    soc_mem_t        tcam_mem_global;     /* Global TCAM Id */

    /* Input parameters check. */
    if ((NULL == f_ent) || (NULL == tcam_idx_old) || (NULL == tcam_idx_new)) {
       return (BCM_E_PARAM);
    }


    fg = f_ent->group;
    if (fg == NULL) {
       return BCM_E_INTERNAL;
    }

    /* Get field stage control . */
    stage_id = fg->stage_id;
    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if (stage_id == _BCM_FIELD_STAGE_FLOWTRACKER) {
        return _bcm_field_hx5_ft_entry_move(unit, f_ent, parts_count,
                                    tcam_idx_old, tcam_idx_new);
    }
#endif

    /*
     * Invoke common function for the stages other than Ingress
     * Need to re-visit for per-pipe support for other stages.
     */
    if (f_ent->group->stage_id != _BCM_FIELD_STAGE_INGRESS) {

       for (idx = 0; idx < parts_count; idx++) {
           /* Calculate entry new slice & offset in the slice. */
           rv = _bcm_field_tcam_idx_to_slice_offset (unit, stage_fc,
                                                     f_ent->group->instance,
                                                     tcam_idx_new[idx],
                                                     &new_slice_numb,
                                                     &new_slice_idx);
           BCM_IF_ERROR_RETURN(rv);
           fs = &stage_fc->slices[f_ent->group->instance][new_slice_numb];
           fs->hw_ent_count++;
       }

       rv = _bcm_field_td2_entry_move(unit, f_ent, parts_count,
                                      tcam_idx_old, tcam_idx_new);
       if (BCM_FAILURE(rv)) {
           for (idx = 0; idx < parts_count; idx++) {
               /* Calculate entry new slice & offset in the slice. */
               rv = _bcm_field_tcam_idx_to_slice_offset (unit, stage_fc,
                                                         f_ent->group->instance,
                                                         tcam_idx_new[idx],
                                                         &new_slice_numb,
                                                         &new_slice_idx);
               BCM_IF_ERROR_RETURN(rv);
               fs = &stage_fc->slices[f_ent->group->instance][new_slice_numb];
               fs->hw_ent_count--;
           }
       }

       return rv;
    }

    /* Get entry tcam and actions. */
    BCM_IF_ERROR_RETURN
         (_bcm_field_th_tcam_policy_mem_get(unit, f_ent,
                                       &tcam_mem, &policy_mem));
    tcam_mem_global = tcam_mem;

    /*
     * When the TCAM Mode is Wide on a global view,
     * Move entries from the Pipes.
     */
    if (((tcam_mem == IFP_TCAM_WIDEm) ||
        ((soc_feature(unit, soc_feature_th3_style_fp)) &&
        (tcam_mem == IFP_TCAMm))) &&
        (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) &&
        (soc_property_get(unit, spn_FIELD_ATOMIC_UPDATE, FALSE) == FALSE)) {
       num_tcams = stage_fc->num_pipes;
       per_pipe_mode = TRUE;
    } else {
       num_tcams = 1; /* tcam name is fetched in tcam_mem */
    }

    for (ct = 0; ct < num_tcams; ct++) {
       if (per_pipe_mode == TRUE) {
           BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                       tcam_mem_global,
                                       ct,
                                       &tcam_mem));
       }
       tcam_idx_max = soc_mem_index_max(unit, tcam_mem);
       tcam_idx_min = soc_mem_index_min(unit, tcam_mem);

       for (idx = 0; idx < parts_count; idx++) {
           /* Index sanity check. */
           if ((tcam_idx_old[idx] < tcam_idx_min) ||
               (tcam_idx_old[idx] > tcam_idx_max) ||
               (tcam_idx_new[idx] < tcam_idx_min) ||
               (tcam_idx_new[idx] > tcam_idx_max)) {
               LOG_DEBUG(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                          "Invalid index range for _field_td2_entry_move\n"
                     "from %d to %d"), tcam_idx_old[idx], tcam_idx_new[idx]));
                return (BCM_E_PARAM);
           }
       }

       /* Update policy entry if moving across the slices. */
       if (((NULL != f_ent->ent_copy) &&
                   (f_ent->ent_copy->eid ==  _FP_INTERNAL_RESERVED_ID))) {
           is_backup_entry = 1;
       }

       for (idx = 0; idx < parts_count; idx++) {
           /* Calculate entry new slice & offset in the slice. */
           rv = _bcm_field_th_tcam_idx_to_slice_offset (unit, stage_fc,
                                                        f_ent,
                                                        tcam_idx_new[idx],
                                                        &new_slice_numb,
                                                        &new_slice_idx);
           if (BCM_SUCCESS(rv)) {

               fs = &stage_fc->slices[f_ent->group->instance][new_slice_numb];
               /* Enable the slice if the entry moves to new slice. */
               if (!(fs->slice_flags & _BCM_FIELD_SLICE_HW_ENABLE)) {
                   if (BCM_FAILURE(_bcm_field_th_slice_enable_set(unit,
                                                      f_ent->group, fs, 1))) {
                       LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
                           "Failed to Enable Field Slice[%d] for Entry[%d].\n\r"),
                           fs->slice_number, f_ent->eid));
                   }
                   fs->slice_flags |= _BCM_FIELD_SLICE_HW_ENABLE;
                   enabled = 1;
               }
           }
      }
      /*
       * Write entry to the destination
       * ORDER is important
       */
       for (idx = parts_count - 1; idx >= 0; idx--) {
           if (ct == 0) {

              /*
               * TH/TH2/TD3 (Intra Slice) Double Wide/ Triple wide modes,
               * IFP_TCAM_WIDE have 256 entries but IFP_POLICY_TABLE will have 512 entries.
               * In TH3, IFP_POLICY_TABLE_WIDE mode is used for TCAM Wide modes and
               * entries are 1:1 mapped.
               */
              if ((SOC_IS_TOMAHAWKX(unit) && !(SOC_IS_TOMAHAWK3(unit)) &&
                  (!(f_ent->group->flags & _FP_GROUP_SPAN_SINGLE_SLICE) ||
                  (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)))) {
                 policy_idx = tcam_idx_old[idx] + (tcam_idx_old[idx]/256 * 256);
              } else {
                 policy_idx = tcam_idx_old[idx];
              }

              /* Read policy entry from current tcam index. */
              rv = soc_th_ifp_mem_read(unit, policy_mem, MEM_BLOCK_ANY,
                                   policy_idx, policy_buf[unit]);

              if (BCM_FAILURE(rv)) {
                  goto cleanup;
              }

              /*
               * TH/TH2/TD3 (Intra Slice) Double Wide/ Triple wide modes,
               * IFP_TCAM_WIDE have 256 entries but IFP_POLICY_TABLE will have 512 entries.
               * In TH3, IFP_POLICY_TABLE_WIDE mode is used for TCAM Wide modes and
               * entries are 1:1 mapped.
               */
              if ((SOC_IS_TOMAHAWKX(unit) && !(SOC_IS_TOMAHAWK3(unit)) &&
                  (!(f_ent->group->flags & _FP_GROUP_SPAN_SINGLE_SLICE) ||
                  (f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)))) {
                 policy_idx = tcam_idx_new[idx] + (tcam_idx_new[idx]/256 * 256);
              } else {
                 policy_idx = tcam_idx_new[idx];
              }

              /* Write duplicate  policy entry to new tcam index. */
              rv = soc_th_ifp_mem_write(unit, policy_mem, MEM_BLOCK_ALL,
                                 policy_idx, policy_buf[unit]);
              if (BCM_FAILURE(rv)) {
                  goto cleanup;
              }
           }

           /* Read tcam entry from current tcam index. */
           rv = soc_th_ifp_mem_read(unit, tcam_mem, MEM_BLOCK_ANY,
                             tcam_idx_old[idx], entry_buf[unit]);
           if (BCM_FAILURE(rv)) {
               goto cleanup;
           }

           /* Write duplicate  tcam entry to new tcam index. */
           rv = soc_th_ifp_mem_write(unit, tcam_mem, MEM_BLOCK_ALL,
                              tcam_idx_new[idx], entry_buf[unit]);
           if (BCM_FAILURE(rv)) {
               goto cleanup;
           }
       }
    }

    for (idx = 0; idx < parts_count; idx++) {
       /* Calculate entry new slice & offset in the slice. */
       rv = _bcm_field_th_tcam_idx_to_slice_offset (unit, stage_fc,
                                                    f_ent,
                                                    tcam_idx_new[idx],
                                                    &new_slice_numb,
                                                    &new_slice_idx);
       if (BCM_SUCCESS(rv)) {

           fs = &stage_fc->slices[f_ent->group->instance][new_slice_numb];
           /* Increment the HW Slice entry count */
           fs->hw_ent_count++;
       } else {
           goto cleanup;
       }

       /*
        * fp_entry_move is invoked even for backup entry create
        * to copy TCAM and FP_POLICY_TABLE tables. In this case
        * TCAM and FP_POLICY_TABLEs should not be erased for
        * original entry.
        */
       if (1 != is_backup_entry) {
           /*
            * Clear old location
            */
           rv = _bcm_field_th_tcam_policy_clear(unit, f_ent,
                   tcam_idx_old[idx]);
           BCM_IF_ERROR_RETURN(rv);
       }
    }
    return (BCM_E_NONE);

cleanup:
       if (enabled == 1) {
           for (idx = 0; idx < parts_count; idx++) {
               /* Calculate entry new slice & offset in the slice. */
               rv = _bcm_field_th_tcam_idx_to_slice_offset (unit, stage_fc,
                                                            f_ent,
                                                            tcam_idx_new[idx],
                                                            &new_slice_numb,
                                                            &new_slice_idx);
               if (BCM_SUCCESS(rv)) {

                   fs = &stage_fc->slices[f_ent->group->instance][new_slice_numb];
                   if (fs->slice_flags & _BCM_FIELD_SLICE_HW_ENABLE) {
                       if (BCM_FAILURE(_bcm_field_th_slice_enable_set(unit, f_ent->group,
                                                                      fs, 0))) {
                           LOG_WARN(BSL_LS_BCM_FP, (BSL_META("Failed to Disable Field"
                                                     " Slice[%d] for Entry[%d].\n\r"),
                                                       fs->slice_number, f_ent->eid));
                       }
                       fs->slice_flags &= ~_BCM_FIELD_SLICE_HW_ENABLE;
                   }
               }
          }
      }
      return rv;
}

/*
 * Function:
 *     _bcm_field_th_tcam_policy_clear
 *
 * Purpose:
 *     Writes a null entry into the TCAM plus Policy table.
 *
 * Parameters:
 *     unit      -   (IN) BCM device number.
 *     f_ent     -   (IN) Field entry.
 *     tcam_idx  -   (IN) Entry tcam index.
 *
 * Returns:
 *     BCM_E_XXX
 *
 * Note:
 *     Unit lock should be held by calling function.
 */
int
_bcm_field_th_tcam_policy_clear(int unit, _field_entry_t *f_ent, int tcam_idx)
{
    bcm_error_t rv = BCM_E_NONE;        /* Operational Status.                */
    soc_mem_t tcam_mem;                 /* TCAM memory id.                    */
    soc_mem_t policy_mem;               /* Policy table memory id .           */
    int new_slice_idx = 0;              /* New slice number.                  */
    int new_slice_numb = 0;             /* New slice index.                   */
    _field_slice_t *fs;                 /* Field Slice structure.             */
    _field_stage_t *stage_fc;           /* Stage field control structure.     */

    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    /* Get field stage control . */
    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, f_ent->group->stage_id,
                                                 &stage_fc));

    switch (f_ent->group->stage_id) {
       case _BCM_FIELD_STAGE_INGRESS:
           BCM_IF_ERROR_RETURN (_field_th_ingress_tcam_policy_clear(unit, f_ent,
                                                                     tcam_idx));

           /* Calculate entry new slice & offset in the slice. */
           rv = _bcm_field_th_tcam_idx_to_slice_offset (unit, stage_fc,
                                                        f_ent, tcam_idx,
                                                        &new_slice_numb,
                                                        &new_slice_idx);
           BCM_IF_ERROR_RETURN(rv);

          break;
       case _BCM_FIELD_STAGE_LOOKUP:
       case _BCM_FIELD_STAGE_EGRESS:
          BCM_IF_ERROR_RETURN (_bcm_field_th_tcam_policy_mem_get(unit, f_ent,
                                                       &tcam_mem, &policy_mem));
          /* Memory index sanity check. */
          if (tcam_idx > soc_mem_index_max(unit, tcam_mem)) {
             return (BCM_E_PARAM);
          }

          /* Write the TCAM & Policy Tables */
          SOC_IF_ERROR_RETURN
            (soc_th_ifp_mem_write(unit, tcam_mem, MEM_BLOCK_ALL, tcam_idx,
                                  soc_mem_entry_null(unit, tcam_mem)));
          SOC_IF_ERROR_RETURN
            (soc_th_ifp_mem_write(unit, policy_mem, MEM_BLOCK_ALL, tcam_idx,
                                  soc_mem_entry_null(unit, policy_mem)));

          /* Calculate entry new slice & offset in the slice. */
          rv = _bcm_field_tcam_idx_to_slice_offset(unit, stage_fc,
                                                   f_ent->group->instance,
                                                   tcam_idx,
                                                   &new_slice_numb,
                                                   &new_slice_idx);
          BCM_IF_ERROR_RETURN(rv);

          break;
#if defined(BCM_FLOWTRACKER_SUPPORT)
        case _BCM_FIELD_STAGE_FLOWTRACKER:
        case _BCM_FIELD_STAGE_AMFTFP:
        case _BCM_FIELD_STAGE_AEFTFP:
          BCM_IF_ERROR_RETURN(_bcm_field_hx5_ft_tcam_policy_clear(unit, f_ent,
                                                                    tcam_idx));
           /* Calculate entry new slice & offset in the slice. */
           rv = _bcm_field_th_tcam_idx_to_slice_offset (unit, stage_fc,
                                                        f_ent, tcam_idx,
                                                        &new_slice_numb,
                                                        &new_slice_idx);
          break;
#endif
       default:
          return BCM_E_INTERNAL;
    }

    fs = &stage_fc->slices[f_ent->group->instance][new_slice_numb];
    if ((fs->slice_flags & _BCM_FIELD_SLICE_HW_ENABLE) &&
        (fs->hw_ent_count == 1)) {
       /* Disable the Slice, if it the last entry */
       if (BCM_FAILURE(_bcm_field_th_slice_enable_set(unit, f_ent->group,
                                                      fs, 0))) {
           LOG_WARN(BSL_LS_BCM_FP, (BSL_META("Failed to Disable Field"
                                 " Slice[%d] for Entry[%d].\n\r"),
                                   fs->slice_number, f_ent->eid));
       }
       fs->slice_flags &= ~_BCM_FIELD_SLICE_HW_ENABLE;
       /* Decrement the HW Slice entry count */
       fs->hw_ent_count = 0;
    } else {
       if (0 >= fs->hw_ent_count) {

           LOG_ERROR(BSL_LS_BCM_FP, (BSL_META("Mismatch b/w number of entries"
                                    "created and deleted in Slice [%d].\n\r"),
                                    fs->slice_number));

           return BCM_E_INTERNAL;
       }
       fs->hw_ent_count--;

    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_entry_remove
 * Purpose:
 *     Remove a previously installed physical entry.
 * Parameters:
 *     unit   - BCM device number
 *     f_ent  - Physical entry data
 * Returns:
 *     BCM_E_XXX
 *     BCM_E_NONE
 * Notes:
 *     FP unit lock should be held by calling function.
 */
int
_bcm_field_th_entry_remove(int unit, _field_entry_t *f_ent, int tcam_idx)
{
    int rv; /* Return value */

    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    if ((NULL == f_ent->fs) || (NULL == f_ent->group)) {
        return (BCM_E_INTERNAL);
    }

    /* Remove exact match entry from hardware. */
    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        return _field_th_em_entry_remove(unit, f_ent);
    }

    rv = _bcm_field_th_tcam_policy_clear(unit, f_ent, tcam_idx);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META(
              "Failed to Remove the TCAM entry for entry[%d] tcam_idx[%d]."
              "\n\r"), f_ent->eid, tcam_idx));
        return rv;
    }

    f_ent->flags |= _FP_ENTRY_DIRTY; /* Mark entry as not installed */
    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
        "==> %s(): Entry[%d] Un-installed - tcam_idx:%d slice:%d\n\r"), __func__,
         f_ent->eid, tcam_idx, f_ent->fs->slice_number));
    return (BCM_E_NONE);
}

/*
 * Function: _field_th_stage_entry_enable_set
 *
 * Purpose:
 *     Enable/Disable an entry from the ingress field hw tables.
 *
 * Parameters:
 *     unit        - (IN) BCM device number
 *     f_ent       - (IN) Reference to Entry structure
 *     enable_flag - (IN) Flag to enable or disable
 *
 * Returns:
 *     BCM_E_XXX
 *
 * Notes:
 *     This does not destroy the entry, nor deallocate any related resources;
 *     it only enables/disables a rule from hardware table using VALIDf of the
 *     corresponding hardware entry. To deallocate the memory used by the entry
 *     call bcm_field_entry_destroy.
 */
int
_field_th_stage_entry_enable_set(int unit, _field_entry_t *f_ent,
                                   int enable_flag)
{
    int                 rv;          /* Operation return status. */
    int                 tcam_idx;
    int                 valid = 0;
    soc_mem_t           tcam_mem = INVALIDm;
    soc_mem_t           policy_mem = INVALIDm;
    uint32              tcam_entry[SOC_MAX_MEM_FIELD_WORDS] = {0};
    _field_stage_t      *stage_fc;         /* Stage field control structure. */
    int                 num_tcams = 0;     /* Number of TCAMs */
    int                 ct;
    uint8               per_pipe_mode = FALSE;
    soc_mem_t           tcam_mem_global;     /* Global TCAM Id */

    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    if ((NULL == f_ent->fs) || (NULL == f_ent->group)) {
        return (BCM_E_INTERNAL);
    }

    /* Get tcam indexes for installed entry. */
    rv = _bcm_field_entry_tcam_idx_get(unit, f_ent,
                                       &tcam_idx);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support) &&
            (f_ent->group->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER)) {
        rv = _bcm_field_fb6_entry_sw_to_hw_tcam_idx(unit,
                f_ent->fs, tcam_idx, &tcam_idx);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
    }
#endif

    rv = _bcm_field_th_tcam_policy_mem_get(unit, f_ent,
                                       &tcam_mem, &policy_mem);
    BCM_IF_ERROR_RETURN(rv);
    tcam_mem_global = tcam_mem;

    /* Get field stage control . */
    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /*
     * When the TCAM Mode is Wide on a global view,
     * Access the entries per-pipe.
     */
    if (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) {

        if (((tcam_mem == IFP_TCAM_WIDEm) ||
            ((soc_feature(unit, soc_feature_th3_style_fp)) &&
            (tcam_mem == IFP_TCAMm))) &&
            (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) &&
            (soc_property_get(unit, spn_FIELD_ATOMIC_UPDATE, FALSE) == FALSE)) {
           num_tcams = stage_fc->num_pipes;
           per_pipe_mode = TRUE;
        } else {
           num_tcams = 1; /* tcam name is fetched in tcam_mem */
        }

        if (enable_flag) {
            int  mode;

            mode = _BCM_FIELD_IS_SLICE_MODE_PBMP_SUPPORTED(f_ent->group->flags) ?
                            _IFP_SLICE_MODE_WIDE : _IFP_SLICE_MODE_NARROW;
            /* Update the valid bit based on the mode */
            valid = (mode == _IFP_SLICE_MODE_WIDE) ? 3 : 1;
        }

    } else if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id ||
               _BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        num_tcams = 1;

        /* Set the VALIDf bits appropriately */
        if (((soc_feature(unit, soc_feature_field_multi_pipe_enhanced) ||
           soc_feature(unit, soc_feature_td3_style_fp)) &&
           (f_ent->group->stage_id == _BCM_FIELD_STAGE_LOOKUP)) ||
           (SOC_IS_TOMAHAWK3(unit))) {
           valid = (enable_flag) ? 1 : 0;
        } else {
           valid = (enable_flag) ? 3 : 2;
        }
#if defined(BCM_FLOWTRACKER_SUPPORT)
    } else if (_BCM_FIELD_STAGE_FLOWTRACKER == f_ent->group->stage_id) {
            valid = (enable_flag) ? 3 : 2;
            num_tcams = 1;
#endif
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    } else if ((_BCM_FIELD_STAGE_AMFTFP == f_ent->group->stage_id) ||
               (_BCM_FIELD_STAGE_AEFTFP == f_ent->group->stage_id)) {
            valid = (enable_flag) ? 3 : 2;
            num_tcams = 1;
#endif

    } else {
        return BCM_E_INTERNAL;
    }

    for (ct = 0; ct < num_tcams; ct++) {

       if (per_pipe_mode == TRUE) {
           BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                       tcam_mem_global,
                                       ct,
                                       &tcam_mem));
       }

       rv = soc_th_ifp_mem_read(unit, tcam_mem, MEM_BLOCK_ANY,
                                tcam_idx, tcam_entry);
       if (BCM_FAILURE(rv)) {
          return (rv);
       }

       soc_mem_field32_set(unit, tcam_mem, tcam_entry, VALIDf, valid);

       BCM_IF_ERROR_RETURN(soc_th_ifp_mem_write(unit,
                                                tcam_mem,
                                                MEM_BLOCK_ALL,
                                                tcam_idx,
                                                tcam_entry));
    }

    if (enable_flag) {
       f_ent->flags |= _FP_ENTRY_ENABLED;
    } else {
       f_ent->flags &= ~_FP_ENTRY_ENABLED;
    }

    return BCM_E_NONE;
}

#if defined(BCM_TOMAHAWK2_SUPPORT)
/*
 * Function: _field_th2_lookup_entry_enable_set
 *
 * Purpose:
 *     Enable/Disable an entry from th2 vfp hw tables.
 *
 * Parameters:
 *     unit        - (IN) BCM device number
 *     f_ent       - (IN) Reference to Entry structure
 *     enable_flag - (IN) Flag to enable or disable
 *
 * Returns:
 *     BCM_E_XXX
 *
 * Notes:
 *     This does not destroy the entry, nor deallocate any related resources;
 *     it only enables/disables a rule from hardware table using one bit VALIDf of the
 *     corresponding hardware entry. To deallocate the memory used by the entry
 *     call bcm_field_entry_destroy.
 */
int
_field_th2_lookup_entry_enable_set(int unit, _field_entry_t *f_ent,
                                   int enable_flag)
{
    int                 rv;          /* Operation return status. */
    int                 tcam_idx;
    int                 valid = 0;
    soc_mem_t           tcam_mem = INVALIDm;
    soc_mem_t           policy_mem = INVALIDm;
    uint32              tcam_entry[SOC_MAX_MEM_FIELD_WORDS] = {0};

    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    if ((NULL == f_ent->fs) || (NULL == f_ent->group)) {
        return (BCM_E_INTERNAL);
    }

    /* Get tcam indexes for installed entry. */
    rv = _bcm_field_entry_tcam_idx_get(unit, f_ent, &tcam_idx);
    BCM_IF_ERROR_RETURN(rv);

    rv = _bcm_field_th_tcam_policy_mem_get(unit, f_ent, &tcam_mem, &policy_mem);
    BCM_IF_ERROR_RETURN(rv);

    rv = soc_mem_read(unit, tcam_mem, MEM_BLOCK_ANY, tcam_idx, tcam_entry);
    BCM_IF_ERROR_RETURN(rv);

    valid = enable_flag ? 1 : 0;
    soc_mem_field32_set(unit, tcam_mem, tcam_entry, VALIDf, valid);
    BCM_IF_ERROR_RETURN(soc_mem_write(unit,
                                      tcam_mem,
                                      MEM_BLOCK_ALL,
                                      tcam_idx,
                                      tcam_entry));

    if (enable_flag) {
       f_ent->flags |= _FP_ENTRY_ENABLED;
    } else {
       f_ent->flags &= ~_FP_ENTRY_ENABLED;
    }

    return BCM_E_NONE;
}
#endif /* BCM_TOMAHAWK2_SUPPORT */

/*
 * Function: _bcm_field_th_entry_enable_set
 *
 * Purpose:
 *     Enable/Disable an entry from the hardware tables.
 *
 * Parameters:
 *     unit        - (IN) BCM device number
 *     f_ent       - (IN) Reference to Entry structure
 *     enable_flag - (IN) Flag to enable or disable
 *
 * Returns:
 *     BCM_E_XXX
 *
 * Notes:
 *     This does not destroy the entry, nor deallocate any related resources;
 *     it only enables/disables a rule from hardware table using VALIDf of the
 *     corresponding hardware entry. To deallocate the memory used by the entry
 *     call bcm_field_entry_destroy.
 */
int
_bcm_field_th_entry_enable_set(int unit, _field_entry_t *f_ent, int enable_flag)
{
    int rv = BCM_E_NONE;

    if (NULL == f_ent) {
        return (BCM_E_PARAM);
    }

    if ((NULL == f_ent->fs) || (NULL == f_ent->group)) {
        return (BCM_E_INTERNAL);
    }

    switch (f_ent->group->stage_id) {
       case _BCM_FIELD_STAGE_LOOKUP:
#if defined(BCM_TOMAHAWK2_SUPPORT)
           if (soc_feature(unit, soc_feature_field_multi_pipe_enhanced)) {
                return _field_th2_lookup_entry_enable_set(unit, f_ent, enable_flag);
            }
#endif /* BCM_TOMAHAWK2_SUPPORT */
       case _BCM_FIELD_STAGE_INGRESS:
       case _BCM_FIELD_STAGE_EGRESS:
           rv = _field_th_stage_entry_enable_set(unit, f_ent, enable_flag);
           break;
       case _BCM_FIELD_STAGE_EXACTMATCH:
           rv = BCM_E_UNAVAIL;
           break;
#if defined(BCM_FLOWTRACKER_SUPPORT)
       case _BCM_FIELD_STAGE_FLOWTRACKER:
        case _BCM_FIELD_STAGE_AMFTFP:
        case _BCM_FIELD_STAGE_AEFTFP:
           rv = _field_hx5_ft_stage_entry_enable_set(unit, f_ent, enable_flag);
           break;
#endif

       default:
           rv = BCM_E_INTERNAL;
           break;
    }

    return rv;
}

/*
 * Function:
 *      _field_ser_oper_mode_init
 * Purpose:
 *      Initialize the SER for the given operational mode
 *      per-CAP stage.
 * Parameters:
 *      unit    - (IN) BCM Device number.
 *      stage   - (IN) Field Stage Pipeline value.
 *      mode    - (IN) Field Group Operational Mode enum value.
 * Returns:
 *      BCM_E_NONE   - Operation successful.
 *      BCM_E_PARAM  - Invalid operational mode or Field Stage.
 *      BCM_E_XXX    - For others.
 *
 * Notes:
 *   1. Valid "stage" input parameter values supported by
 *      this API are:
 *              "bcmFieldQualifyStageLookup"
 * 	            "bcmFieldQualifyStageIngress"
 *              "bcmFieldQualifyStageEgress"
 *              "bcmFieldQualifyStageIngressExactMatch"
 *              "bcmFieldQualifyStageClass"
 *              "bcmFieldQualifyStageClassExactMatch".
 *   2. Irrespective of the given mode, the IFP_TCAM_WIDE is
 *      always be initialized to Unique Mode.
 */
STATIC int
_field_ser_oper_mode_init(
    int unit,
    int stage_id,
    bcm_field_group_oper_mode_t mode)
{
    int               idx;          /* Temp Index variable. */
    int               ser_mode;     /* SER mode */
    int               rv;           /* Return Value */
    int8              num_tcam = 0, /* Number of tcams */
                      ct;
    soc_mem_t         tcam_mem[12] = {INVALIDm};  /* Tcam memory id */
    int               set_mode[12] = {0};

   /* Validate input parameters */
   if ((mode != bcmFieldGroupOperModeGlobal) &&
       (mode != bcmFieldGroupOperModePipeLocal)) {
      return BCM_E_PARAM;
   }

   /* Update the SER mode */
   ser_mode = (mode == bcmFieldGroupOperModeGlobal) ?
               _SOC_SER_MEM_MODE_GLOBAL:_SOC_SER_MEM_MODE_PIPE_UNIQUE;

   /* Update stage_id and tcam memory for the given stage */
   switch (stage_id) {
     case _BCM_FIELD_STAGE_LOOKUP:
          tcam_mem[0] = VFP_TCAMm;
          num_tcam = 2;
          break;
     case _BCM_FIELD_STAGE_INGRESS:
          tcam_mem[1] = IFP_LOGICAL_TABLE_SELECTm;
          tcam_mem[2] = IFP_LOGICAL_TABLE_SELECT_TCAM_ONLYm;
          tcam_mem[3] = IFP_TCAMm;
          tcam_mem[4] = IFP_TCAM_WIDEm;
          num_tcam = 5;
          break;
     case _BCM_FIELD_STAGE_EGRESS:
          tcam_mem[0] = EFP_TCAMm;
          num_tcam = 1;
          break;
     case _BCM_FIELD_STAGE_EXACTMATCH:
          tcam_mem[0] = EXACT_MATCH_LOGICAL_TABLE_SELECTm;
          tcam_mem[1] = EXACT_MATCH_LOGICAL_TABLE_SELECT_TCAM_ONLYm;
          num_tcam = 2;
          break;
     case _BCM_FIELD_STAGE_CLASS:
          tcam_mem[0] = SRC_COMPRESSIONm;
          tcam_mem[1] = SRC_COMPRESSION_TCAM_ONLYm;
          tcam_mem[2] = DST_COMPRESSIONm;
          tcam_mem[3] = DST_COMPRESSION_TCAM_ONLYm;
          tcam_mem[4] = TTL_FNm;
          tcam_mem[5] = TOS_FNm;
          tcam_mem[6] = TCP_FNm;
          tcam_mem[7] = IP_PROTO_MAPm;
          num_tcam = 8;
          break;
     default:
          return BCM_E_PARAM;
   }

   for (idx = 0; idx < num_tcam; idx++) {
       /* In order to support the bcmFieldQualifyInPorts qualifier in
        * Global Mode, reads/writes on IFP_TCAM_WIDE should always be
        * in per pipe mode.
        */
       if (((IFP_TCAM_WIDEm == tcam_mem[idx]) ||
           ((soc_feature(unit, soc_feature_th3_style_fp)) &&
            (IFP_TCAMm == tcam_mem[idx]))) &&
           (soc_property_get(unit, spn_FIELD_ATOMIC_UPDATE, FALSE) == FALSE)) {
          set_mode[idx] = _SOC_SER_MEM_MODE_PIPE_UNIQUE;
       } else {
          set_mode[idx] = ser_mode;
       }
   }

    SOC_IF_ERROR_RETURN(soc_generic_ser_mem_scan_stop(unit));
    for (ct = 0; num_tcam > 0; ct++,num_tcam--) {
        rv = soc_generic_ser_mem_update(unit, tcam_mem[ct], stage_id, set_mode[ct]);
        if (SOC_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                      "SER memory update failed[%d] to set"
                      " '%s' mode for tcam[%d].\n"),
                      rv,
                     (set_mode[ct] == _SOC_SER_MEM_MODE_GLOBAL)?"Global":"Unique",
                     tcam_mem[ct]));
        }
    }
    SOC_IF_ERROR_RETURN(soc_generic_ser_mem_scan_start(unit));

   return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_th_field_stage_supported_qset_init
 *
 * Purpose:
 *     Initialize field stages supported qset for each stage
 *
 * Parameters:
 *     unit - (IN) BCM device number.
 *
 * Returns:
 *     BCM_E_NONE   - Success
 *     BCM_E_MEMORY - Allocation failure
 */
int
_bcm_th_field_stage_supported_qset_init(int unit, _field_control_t *fc,
                                        _field_stage_t   *stage_fc)
{
    bcm_field_qset_t *qset;     /* Operation result.              */
    int idx;                    /* Iteration index.               */
    bcmi_keygen_qual_cfg_info_t **qual_cfg_info = NULL;
    bcmi_keygen_qual_flags_bmp_t qual_flags;

    /* Fill supported qset for each  pipeline stage. */
    qset = &stage_fc->_field_supported_qset;

    if (stage_fc->qual_cfg_info_db != NULL )  {
        qual_cfg_info = stage_fc->qual_cfg_info_db->qual_cfg_info;
        for (idx = 0; idx < _bcmFieldQualifyCount; idx++) {
            if (NULL != qual_cfg_info[idx]) {
                qual_flags = qual_cfg_info[idx]->qual_cfg_arr->qual_flags;
                /* Check whether the qual is supported in the respective stage*/
                if ((_BCM_FIELD_STAGE_EXACTMATCH == stage_fc->stage_id)
                        && (SHR_BITGET(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_EM))) {
                    continue;
                } else if ((_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)
                        && (SHR_BITGET(qual_flags.w, BCMI_KEYGEN_QUAL_FLAGS_NOT_IN_IFP))) {
                    continue;
                }
                /* Update supported qset for the stage */
                BCM_FIELD_QSET_ADD(*qset, (qual_cfg_info[idx])->qual);
            }
        }
    } else if (stage_fc->f_qual_arr != NULL ) {
        for (idx = 0; idx < _bcmFieldQualifyCount; idx++) {
            if (NULL != stage_fc->f_qual_arr[idx]) {
                /* Update supported qset for the stage */
                BCM_FIELD_QSET_ADD(*qset, (stage_fc->f_qual_arr[idx])->qid);
            }
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_wb_group_oper_mode_set
 * Purpose:
 *      Configure Field Processor Group operational mode
 *      per-CAP stage.
 * Parameters:
 *      unit    - (IN) BCM Device number.
 *      stage   - (IN) Field Stage Pipeline Qualifier enum value.
 *      mode    - (IN) Field Group Operational Mode enum value.
 * Returns:
 *      BCM_E_NONE   - Operation successful.
 *      BCM_E_PARAM  - Invalid operational mode or Field Stage.
 *      BCM_E_INIT   - BCM unit not initialized.
 *      BCM_E_BUSY   - Field stage has valid group/entry configured.
 *
 * Notes:
 *      Valid "stage" input parameter values supported by
 *      this API are:
 *              "bcmFieldQualifyStageLookup"
 * 	        "bcmFieldQualifyStageIngress"
 *              "bcmFieldQualifyStageEgress"
 *              "bcmFieldQualifyStageExactMatch".
 */

int
_bcm_field_wb_group_oper_mode_set(
    int unit,
    bcm_field_qualify_t stage,
    _field_stage_t     **stage_fc,
    bcm_field_group_oper_mode_t mode)
{
   _field_control_t   *fc;          /* Field control structure. */
   _field_stage_id_t  stage_id;     /* Pipeline stage id */
   _field_group_t     *fg;          /* Field group structure */
    int               rv;           /* Return Value */

   /* Validate input parameters */
   if ((mode != bcmFieldGroupOperModeGlobal) &&
       (mode != bcmFieldGroupOperModePipeLocal)) {
      return BCM_E_PARAM;
   }

   /* Update stage_id and tcam memory for the given stage */
   switch (stage) {
     case bcmFieldQualifyStageLookup:
          stage_id = _BCM_FIELD_STAGE_LOOKUP;
          break;
     case bcmFieldQualifyStageIngress:
          stage_id = _BCM_FIELD_STAGE_INGRESS;
          break;
     case bcmFieldQualifyStageEgress:
          stage_id = _BCM_FIELD_STAGE_EGRESS;
          break;
     case bcmFieldQualifyStageIngressExactMatch:
          stage_id = _BCM_FIELD_STAGE_EXACTMATCH;
          break;
     case bcmFieldQualifyStageClass:
          stage_id = _BCM_FIELD_STAGE_CLASS;
          break;
     default:
          return BCM_E_PARAM;
   }

   /* Verify whether the mode is already set */
   if ((*stage_fc)->oper_mode == mode) {
      return BCM_E_NONE;
   }

   /* Field control structure */
   BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

   /* Verify whether stage related group/entry is configured */
   fg = fc->groups;
   while (NULL != fg) {
      if (fg->stage_id == stage_id) {
         /* can't modify the stage as a group already exists */
         return BCM_E_BUSY;
      }
      fg = fg->next;
   }

   /* To reinitialize the stage, first delete the stage. */
   rv = _field_th_stage_delete(unit, fc, *stage_fc);
   if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "FP(unit %d) Error: Stage=%d Delete failed = %d.\n"),
            unit, (*stage_fc)->stage_id, rv));
        return (rv);
   }

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp) &&
        ((stage_id == _BCM_FIELD_STAGE_INGRESS) ||
         (stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
        BCM_IF_ERROR_RETURN(_bcm_field_td3_flex_qual_ceh_db_init(unit));
    }
#endif /* BCM_TRIDENT3_SUPPORT */

   /*
    * Add the stage back. Stage structure is allocated in this function hence
    * pass the stage ID as input parameter to this function.
    * The oper_mode is updated in this function.
    */
   rv = _field_th_stage_add(unit, fc, stage_id, mode);
   if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "FP(unit %d) Error: Stage=%d Add failed = %d.\n"),
                                         unit, stage_id, rv));
        return (rv);
   }

   /* SER initialization */
   BCM_IF_ERROR_RETURN(_field_ser_oper_mode_init(unit, stage_id, mode));

   BCM_IF_ERROR_RETURN
      (_field_stage_control_get(unit, stage_id, stage_fc));

   /* Initialize qualifiers info. */
   BCM_IF_ERROR_RETURN(_field_th_qualifiers_init(unit, *stage_fc));

   /* Initialize stage actions information. */
   BCM_IF_ERROR_RETURN(_field_th_actions_init(unit, *stage_fc));

   /* Initialize supported qset for each stage. */
   BCM_IF_ERROR_RETURN(_bcm_th_field_stage_supported_qset_init(unit, fc, *stage_fc));

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp) &&
        ((stage_id == _BCM_FIELD_STAGE_INGRESS) ||
         (stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
       rv = (_bcm_field_td3_flex_qual_ceh_db_clear(unit));
    }
#endif

   return rv;
}

int
_field_th_group_oper_mode_set(
    int unit,
    bcm_field_qualify_t stage,
    bcm_field_group_oper_mode_t mode)
{
   _field_stage_t     *stage_fc;    /* Stage field control structure. */
   _field_control_t   *fc;          /* Field control structure. */
   _field_stage_id_t  stage_id;     /* Pipeline stage id */
   _field_group_t     *fg;          /* Field group structure */
    int               rv;           /* Return Value */

   /* Validate input parameters */
   if ((mode != bcmFieldGroupOperModeGlobal) &&
       (mode != bcmFieldGroupOperModePipeLocal)) {
      return BCM_E_PARAM;
   }

   /* Update stage_id and tcam memory for the given stage */
   switch (stage) {
     case bcmFieldQualifyStageLookup:
          stage_id = _BCM_FIELD_STAGE_LOOKUP;
          break;
     case bcmFieldQualifyStageIngress:
          stage_id = _BCM_FIELD_STAGE_INGRESS;
          break;
     case bcmFieldQualifyStageEgress:
          stage_id = _BCM_FIELD_STAGE_EGRESS;
          break;
     case bcmFieldQualifyStageIngressExactMatch:
          stage_id = _BCM_FIELD_STAGE_EXACTMATCH;
          break;
     case bcmFieldQualifyStageClass:
     case bcmFieldQualifyStageClassExactMatch:
          stage_id = _BCM_FIELD_STAGE_CLASS;
          break;
     default:
          return BCM_E_PARAM;
   }

   /*
    * Retrieve Field stage control structure,
    * It also return BCM_E_INIT if the field is not initialized.
    */
   BCM_IF_ERROR_RETURN
      (_field_stage_control_get(unit, stage_id, &stage_fc));

   /* Verify whether the mode is already set */
   if (stage_fc->oper_mode == mode) {
      return BCM_E_NONE;
   }

   /* Field control structure */
   BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

   /* Restrict EM in per pipe mode for TH3 */
#if defined (BCM_TOMAHAWK3_SUPPORT)
   if (soc_feature(unit, soc_feature_th3_style_fp)) {
       if ((stage_id == _BCM_FIELD_STAGE_EXACTMATCH) &&
              (mode == bcmFieldGroupOperModePipeLocal)) {
           LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                           "FP(unit %d) Error: Exact Match Stage Per Pipe Mode Not Supported.\n"),
                       unit));
           return (BCM_E_UNAVAIL);
       }
   }
#endif

   /* Verify whether stage related group/entry is configured */
   fg = fc->groups;
   while (NULL != fg) {
       if (fg->stage_id == stage_id) {
           return BCM_E_BUSY;
       }
       fg = fg->next;
   }

   switch (stage_fc->oper_mode) {
        case bcmFieldGroupOperModeGlobal:
            /* Clear hardware table */
            BCM_IF_ERROR_RETURN(_field_th_hw_clear(unit, stage_fc, fc));
            break;
        case bcmFieldGroupOperModePipeLocal:
            /* Clear hardware table */
            BCM_IF_ERROR_RETURN(_field_th_pipes_hw_clear(unit, stage_fc, fc));
            break;
        default:
            return BCM_E_INTERNAL;
   }

   /* To reinitialize the stage, first delete the stage. */
   rv = _field_th_stage_delete(unit, fc, stage_fc);
   if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "FP(unit %d) Error: Stage=%d Delete failed = %d.\n"),
            unit, stage_fc->stage_id, rv));
        return (rv);
   }

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp) &&
        ((stage_id == _BCM_FIELD_STAGE_INGRESS) ||
         (stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
        BCM_IF_ERROR_RETURN(_bcm_field_td3_flex_qual_ceh_db_init(unit));
    }
#endif /* BCM_TRIDENT3_SUPPORT */

   /*
    * Add the stage back. Stage structure is allocated in this function hence
    * pass the stage ID as input parameter to this function.
    * The oper_mode is updated in this function.
    */
   rv = _field_th_stage_add(unit, fc, stage_id, mode);
   if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "FP(unit %d) Error: Stage=%d Add failed = %d.\n"),
                                         unit, stage_id, rv));
        goto cleanup;
   }

   /* SER initialization */
   rv = (_field_ser_oper_mode_init(unit, stage_id, mode));
   if (BCM_FAILURE(rv)) {
       goto cleanup;
   }

   rv = (_field_stage_control_get(unit, stage_id, &stage_fc));
   if (BCM_FAILURE(rv)) {
       goto cleanup;
   }

   switch (stage_fc->oper_mode) {
        case bcmFieldGroupOperModeGlobal:
            /* Clear hardware table */
            rv = (_field_th_hw_clear(unit, stage_fc, fc));
            break;
        case bcmFieldGroupOperModePipeLocal:
            /* Clear hardware table */
            rv = (_field_th_pipes_hw_clear(unit, stage_fc, fc));
            break;
        default:
            rv = BCM_E_INTERNAL;
            break;
   }

   if (BCM_FAILURE(rv)) {
       goto cleanup;
   }

   if ((stage_id == _BCM_FIELD_STAGE_INGRESS) ||
        (stage_id == _BCM_FIELD_STAGE_EXACTMATCH)) {
       /* Match ID width partition for each zone */
       if (fc->functions.fp_zone_match_id_partition_init != NULL) {
          fc->functions.fp_zone_match_id_partition_init(unit, stage_fc);
       }
   }

   /* Initialize qualifiers info. */
   rv = (_field_th_qualifiers_init(unit, stage_fc));
   if (BCM_FAILURE(rv)) {
       goto cleanup;
   }

   /* Initialize stage actions information. */
   rv = (_field_th_actions_init(unit, stage_fc));
   if (BCM_FAILURE(rv)) {
       goto cleanup;
   }

   /* IFP and EXACTMATCH stages are non-correlative if FLOWTRACKER_ENABLE is enabled*/
   if ((stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) &&
       soc_feature(unit, soc_feature_field_exact_match_support)){
       /* Update exact match input bus when ingress oper mode is changed. */
       rv = (_field_th_emstage_update(unit, stage_fc));
       if (BCM_FAILURE(rv)) {
          goto cleanup;
       }
   }

   /* Initialize supported qset for each stage seperately */
   rv = (_bcm_th_field_stage_supported_qset_init(unit, fc, stage_fc));
   if (BCM_FAILURE(rv)) {
       goto cleanup;
   }

cleanup:
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp) &&
        ((stage_id == _BCM_FIELD_STAGE_INGRESS) ||
         (stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
       rv = (_bcm_field_td3_flex_qual_ceh_db_clear(unit));
    }
#endif

   return rv;
}

/*
 * Function:
 *      _bcm_field_th_group_oper_mode_set
 * Purpose:
 *      Configure Field Processor Group operational mode
 *      per-CAP stage.
 * Parameters:
 *      unit    - (IN) BCM Device number.
 *      stage   - (IN) Field Stage Pipeline Qualifier enum value.
 *      mode    - (IN) Field Group Operational Mode enum value.
 * Returns:
 *      BCM_E_NONE   - Operation successful.
 *      BCM_E_PARAM  - Invalid operational mode or Field Stage.
 *      BCM_E_INIT   - BCM unit not initialized.
 *      BCM_E_BUSY   - Field stage has valid group/entry configured.
 *
 * Notes:
 *      Valid "stage" input parameter values supported by
 *      this API are:
 *              "bcmFieldQualifyStageLookup"
 * 	            "bcmFieldQualifyStageIngress"
 *              "bcmFieldQualifyStageEgress"
 *              "bcmFieldQualifyStageIngressExactMatch"
 *              "bcmFieldQualifyStageClass"
 *              "bcmFieldQualifyStageClassExactMatch".
 *              "bcmFieldQualifyStageIngressFlowtracker."
 */
int
_bcm_field_th_group_oper_mode_set(
    int unit,
    bcm_field_qualify_t stage,
    bcm_field_group_oper_mode_t mode)
{
    BCM_IF_ERROR_RETURN(_field_th_group_oper_mode_set(unit, stage, mode));
    return BCM_E_NONE;
}
/*
 * Function:
 *      _bcm_field_th_group_oper_mode_get
 * Purpose:
 *      Retrieve Field Processor Group operational mode
 *      per-CAP stage.
 * Parameters:
 *      unit    - (IN)  BCM Device number.
 *      stage   - (IN)  Field Stage Pipeline Qualifier enum value.
 *      mode    - (OUT) Reference to Field Group Operational
 *                      Mode enum value.
 * Returns:
 *      BCM_E_NONE   - Operation successful.
 *      BCM_E_PARAM  - Invalid parameter.
 *      BCM_E_INIT   - BCM unit not initialized.
 *
 * Notes:
 *      Valid "stage" input parameter values supported by
 *      this API are:
 *              "bcmFieldQualifyStageLookup"
 * 	            "bcmFieldQualifyStageIngress"
 *              "bcmFieldQualifyStageEgress"
 *              "bcmFieldQualifyStageIngressExactMatch"
 *              "bcmFieldQualifyStageClass"
 *              "bcmFieldQualifyStageClassExactMatch."
 *              "bcmFieldQualifyStageIngressFlowtracker."
 */

int
_bcm_field_th_group_oper_mode_get(
    int unit,
    bcm_field_qualify_t stage,
    bcm_field_group_oper_mode_t *mode)
{
   _field_stage_t     *stage_fc; /* Stage field control structure. */
   _field_stage_id_t  stage_id;  /* Pipeline stage id */

   /* Validate input parameters */
   if (mode == NULL) {
      return BCM_E_PARAM;
   }

   switch (stage) {
     case bcmFieldQualifyStageLookup:
          stage_id = _BCM_FIELD_STAGE_LOOKUP;
          break;
     case bcmFieldQualifyStageIngress:
          stage_id = _BCM_FIELD_STAGE_INGRESS;
          break;
     case bcmFieldQualifyStageEgress:
          stage_id = _BCM_FIELD_STAGE_EGRESS;
          break;
     case bcmFieldQualifyStageClass:
     case bcmFieldQualifyStageClassExactMatch:
          stage_id = _BCM_FIELD_STAGE_CLASS;
          break;
     case bcmFieldQualifyStageIngressExactMatch:
          stage_id = _BCM_FIELD_STAGE_EXACTMATCH;
          break;
     case bcmFieldQualifyStageIngressFlowtracker:
          stage_id = _BCM_FIELD_STAGE_FLOWTRACKER;
          break;
     default:
          return BCM_E_PARAM;
          break;
   }

   /*
    * Retrieve Field stage control structure,
    * It also return BCM_E_INIT if the field is not initialized.
    */
   BCM_IF_ERROR_RETURN
      (_field_stage_control_get (unit, stage_id, &stage_fc));

   /* update the mode */
   *mode = stage_fc->oper_mode;
   return BCM_E_NONE;
}

/*
 * Function:
 *     _field_th_ingress_slice_enable_set
 *
 * Purpose:
 *     Enables or disables packet lookup on a hardware slice
 *     and configures the slice mode.
 *
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     fg       - (IN) Reference to Group Structure.
 *     fs       - (IN) Reference to Slice Structure.
 *     enable   - (IN) enable/disable state of slice.
 *
 * Returns:
 *     BCM_E_NONE      - Success
 *     BCM_E_INTERNAL  - SOC read/write error
 *
 * Note:
 *     Calling function is responsible for checking feature availability.
 */

int
_field_th_ingress_slice_enable_set(int            unit,
                                   _field_group_t *fg,
                                   uint8          slice_idx,
                                   uint8          enable)
{
    uint32              regval_old, regval_new;
    uint8               mode;
    _field_stage_t     *stage_fc;
    soc_reg_t           reg;
    int inst;

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                        _BCM_FIELD_STAGE_INGRESS, &stage_fc));

    if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
       inst = _FP_GLOBAL_INST;
    } else {
       inst = fg->instance;
    }

    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, IFP_CONFIGr,
                                                       inst, &reg));

    BCM_IF_ERROR_RETURN
       (soc_reg32_get(unit, reg, REG_PORT_ANY, slice_idx, &regval_old));
    regval_new = regval_old;

    enable = (enable == 0) ? 0 : 1;
    soc_reg_field_set(unit, reg, &regval_new, IFP_SLICE_ENABLEf, enable);
    soc_reg_field_set(unit, reg, &regval_new, IFP_SLICE_LOOKUP_ENABLEf, enable);

    if (!soc_feature(unit, soc_feature_ifp_no_narrow_mode_support)) {

       /* Determine the slice mode based on group flags. */
       mode = _BCM_FIELD_IS_SLICE_MODE_PBMP_SUPPORTED(fg->flags) ?
              _IFP_SLICE_MODE_WIDE : _IFP_SLICE_MODE_NARROW;
       soc_reg_field_set(unit, reg, &regval_new, IFP_SLICE_MODEf, mode);
    }

    if (regval_new != regval_old) {
       BCM_IF_ERROR_RETURN
          (soc_reg32_set(unit, reg, REG_PORT_ANY, slice_idx, regval_new));
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _field_th_stage_slice_enable_set
 *
 * Purpose:
 *     Enables or disables packet lookup on a hardware slice for
 *     VFP and EFP stages.
 *
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     fg       - (IN) Reference to Group Structure.
 *     fs       - (IN) Reference to Slice Structure.
 *     enable   - (IN) enable/disable state of slice.
 *
 * Returns:
 *     BCM_E_NONE      - Success
 *     BCM_E_INTERNAL  - SOC read/write error
 *
 * Note:
 *     Calling function is responsible for checking feature availability.
 */
int
_field_th_stage_slice_enable_set(int unit, _field_group_t *fg,
                                 int slice, int enable)
{
    int                 inst;
    soc_reg_t           reg;
    _field_stage_t     *stage_fc;
    uint32              val;

    static soc_field_t lookup_enable_field[4] = {LOOKUP_ENABLE_SLICE_0f,
                                                LOOKUP_ENABLE_SLICE_1f,
                                                LOOKUP_ENABLE_SLICE_2f,
                                                LOOKUP_ENABLE_SLICE_3f};

    static soc_field_t slice_enable_field[4] = {SLICE_ENABLE_SLICE_0f,
                                                SLICE_ENABLE_SLICE_1f,
                                                SLICE_ENABLE_SLICE_2f,
                                                SLICE_ENABLE_SLICE_3f};

    if (NULL == fg) {
        return (BCM_E_PARAM);
    }

    /* Validate slice. */
    if (slice < 0 || slice >= COUNTOF(slice_enable_field)) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                        fg->stage_id, &stage_fc));

    if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
       inst = _FP_GLOBAL_INST;
    } else {
       inst = fg->instance;
    }

    switch (fg->stage_id) {
        case _BCM_FIELD_STAGE_LOOKUP:
             BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                       VFP_SLICE_CONTROLr,
                                                       inst, &reg));
             break;
        case _BCM_FIELD_STAGE_EGRESS:
             BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                       EFP_SLICE_CONTROLr,
                                                       inst, &reg));
            break;
        default:
            return BCM_E_INTERNAL;
    }

    val = (enable ? 1 : 0);

    /* SW WAR for TH3-5323 */
    if ((soc_feature(unit, soc_feature_th3_style_fp)) &&
         (fg->stage_id == _BCM_FIELD_STAGE_LOOKUP)) {

          BCM_IF_ERROR_RETURN(soc_reg_fields32_modify(unit, reg, REG_PORT_ANY, 1,
                                              &slice_enable_field[slice], &val));
    }

    BCM_IF_ERROR_RETURN(soc_reg_fields32_modify(unit, reg, REG_PORT_ANY, 1,
                                        &lookup_enable_field[slice], &val));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_slice_enable_set
 *
 * Purpose:
 *     Enables or disables packet lookup on a hardware slice.
 *
 * Parameters:
 *     unit     - (IN) BCM device number
 *     fg       - (IN) Reference to Group Structure.
 *     fs       - (IN) Reference to Slice Structure.
 *     enable   - (IN) enable/disable state of slice.
 *
 * Returns:
 *     BCM_E_NONE      - SUCCESS
 *     BCM_E_INTERNAL  - SOC read/write error
 *
 * Note:
 *     Calling function is responsible for checking feature availability.
 */
int
_bcm_field_th_slice_enable_set(int                unit,
                               _field_group_t     *fg,
                               _field_slice_t     *fs,
                                uint8             enable)
{
    if (NULL == fg || NULL == fs) {
        return (BCM_E_PARAM);
    }

    switch (fg->stage_id) {
        case _BCM_FIELD_STAGE_INGRESS:
             return
                (_field_th_ingress_slice_enable_set(unit, fg,
                                                    fs->slice_number, enable));
             break;
        case _BCM_FIELD_STAGE_LOOKUP:
        case _BCM_FIELD_STAGE_EGRESS:
             return
                (_field_th_stage_slice_enable_set(unit, fg,
                                                  fs->slice_number, enable));
             break;
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
        case _BCM_FIELD_STAGE_AMFTFP:
        case _BCM_FIELD_STAGE_AEFTFP:
            return BCM_E_NONE;
#endif
        default:
             LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META(
                         "Invalid stage_id[%d].\n\r"),
                         fg->stage_id));
             break;
    }

    return BCM_E_INTERNAL;
}

/*
 * Function:
 *     _bcm_field_th_qualify_class
 * Purpose:
 *     Qualifies field entry classifier id data and mask value
 * Parameters:
 *     unit  - (IN) BCM device number
 *     entry - (IN) Field entry identifier
 *     data  - (IN) Classifier ID lookup key value
 *     mask  - (IN) Classifier ID lookup mask value
 * Returns:
 *     BCM_E_XXXX
 */
int
_bcm_field_th_qualify_class(int unit,
                            bcm_field_entry_t entry,
                            bcm_field_qualify_t qual,
                            uint32 *data,
                            uint32 *mask)
{
    _field_entry_t *f_ent;
    uint32 cl_width, cl_max;
    uint32 ifp_cl_type; /* IFP Class Type propagted to EFP. */

    /* Get field entry part that contains the qualifier. */
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry, qual, &f_ent));

    switch (f_ent->group->stage_id) {
        case _BCM_FIELD_STAGE_INGRESS:
        case _BCM_FIELD_STAGE_EXACTMATCH:
        case _BCM_FIELD_STAGE_FLOWTRACKER:
            switch (qual) {
                /* Class IDs from L2 Entry Table (10) */
                case bcmFieldQualifySrcClassL2:
                case bcmFieldQualifyDstClassL2:
                    cl_width = 10;
                    break;
                /* Class fields from VFP_CLASS_ID_HI */
                case bcmFieldQualifySrcClassField:
                /* Class fields from VFP_CLASS_ID_L0 */
                case bcmFieldQualifyDstClassField:
                    cl_width = 10;
                    break;
                /* Class IDs from L3 Entry table (12) */
                case bcmFieldQualifySrcClassL3:
                    cl_width = 10;
                    break;
                case bcmFieldQualifyDstClassL3:
                    cl_width = 10;
                    break;
                /* Class ID from VLAN table (12) */
                case bcmFieldQualifyInterfaceClassL2:
                /* Class ID from L3_IIF (12) */
                case bcmFieldQualifyInterfaceClassL3:
                /* Class ID from Port Table (12) */
                case bcmFieldQualifyInterfaceClassPort:
                /* Class ID from SVP (12) */
                case bcmFieldQualifyInterfaceClassVPort:
                    cl_width = 12;
                    break;
                case bcmFieldQualifyGroupClass:
                    cl_width = 2;
                    break;
                case bcmFieldQualifyUdfClass:
                case bcmFieldQualifyInterfaceLookupClassPort:
                case bcmFieldQualifyInterfaceIngressKeySelectClassPort:
                    cl_width = 8;
                    break;
                default:
                    return (BCM_E_INTERNAL);
            }

            cl_max = 1 << cl_width;

            if (*data >= cl_max) {
                return (BCM_E_PARAM);
            }
            break;

        case _BCM_FIELD_STAGE_LOOKUP:
             return
                (_bcm_field_td2_qualify_class(unit, entry, qual,
                                              data, mask));
        case _BCM_FIELD_STAGE_EGRESS:
            cl_width = 9;
            /* Need to set IFP_CLASS_TYPE in TCAM (upper 4 bits) */
            switch (qual) {
                case bcmFieldQualifySrcClassL2:
                    ifp_cl_type = 6;
                    break;
                case bcmFieldQualifySrcClassL3:
                    ifp_cl_type = 8;
                    break;
                case bcmFieldQualifySrcClassField:
                    ifp_cl_type = 4;
                    break;
                case bcmFieldQualifyDstClassL2:
                    ifp_cl_type = 7;
                    break;
                case bcmFieldQualifyDstClassL3:
                    ifp_cl_type = 9;
                    break;
                case bcmFieldQualifyDstClassField:
                    ifp_cl_type = 5;
                    break;
                case bcmFieldQualifyInterfaceClassL2:
                    ifp_cl_type = 10;
                    break;
                case bcmFieldQualifyInterfaceClassL3:
                    ifp_cl_type = 3;
                    break;
                case bcmFieldQualifyIngressClassField:
                    ifp_cl_type = 15;
                    break;
                case bcmFieldQualifyIngressInterfaceClassPort:
                    ifp_cl_type = 1;
                    break;
                case bcmFieldQualifyIngressInterfaceClassVPort:
                    ifp_cl_type = 2;
                    break;
                case bcmFieldQualifyEgressClass:
                case bcmFieldQualifyEgressClassL3Interface:
                case bcmFieldQualifyEgressClassTrill:
                case bcmFieldQualifyEgressClassL2Gre:
                case bcmFieldQualifyEgressClassVxlan:
                case bcmFieldQualifyEgressClassTunnel:
                case bcmFieldQualifyEgressClassL3InterfaceTunnel:

                    cl_width = 12;
                    ifp_cl_type = 0;
                    break;
                default:
                    return (BCM_E_INTERNAL);
            }

            cl_max   = 1 << cl_width;

            if (*data >= cl_max || (*mask != BCM_FIELD_EXACT_MATCH_MASK && *mask >= cl_max)) {
                return (BCM_E_PARAM);
            }

            if (ifp_cl_type) {
                *data |= ifp_cl_type << cl_width;
                *mask |= 0xf << cl_width;
            }
            break;
        default:
            return (BCM_E_INTERNAL);
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_qualify_class_get
 * Purpose:
 *     Retrieve field entry classifier id data and mask values
 * Parameters:
 *     unit  - (IN) BCM device number
 *     entry - (IN) Field entry identifier
 *     qual  - (IN) Field entry qualifier enumeration
 *     data  - (IN/OUT) Classifier ID lookup key value
 *     mask  - (IN/OUT) Classifier ID lookup mask value
 * Returns:
 *     BCM_E_XXXX
 */
int
_bcm_field_th_qualify_class_get(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_field_qualify_t qual,
                                 uint32 *data,
                                 uint32 *mask
                                 )
{
    _field_entry_t *f_ent;
    const uint32 m = (1 << 9) - 1;

    /* Get field entry part that contains the qualifier. */
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry, qual, &f_ent));

    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) {
        switch (qual) {
            case bcmFieldQualifySrcClassL2:
            case bcmFieldQualifySrcClassL3:
            case bcmFieldQualifySrcClassField:
            case bcmFieldQualifyDstClassL2:
            case bcmFieldQualifyDstClassL3:
            case bcmFieldQualifyDstClassField:
            case bcmFieldQualifyInterfaceClassL2:
            case bcmFieldQualifyInterfaceClassL3:
            case bcmFieldQualifyIngressClassField:
            case bcmFieldQualifyIngressInterfaceClassPort:
            case bcmFieldQualifyIngressInterfaceClassVPort:
                /* Mask off IFP_CLASSID_TYPE */
                *data &= m;
                *mask &= m;
                break;
            default:
                break;
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function: _bcm_field_th_ForwardingType_set
 *
 * Purpose:
 *     Add qualification data to an entry for IP Type.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number.
 *     stage_id - (IN) Stage ID.
 *     entry    - (IN) Entry ID.
 *     type     - (IN) Forwarding type.
 *     data     - (OUT) Data.
 *     mask     - (OUT) Mask.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_forwardingType_set(int unit, _field_stage_id_t stage_id,
                                 bcm_field_entry_t entry,
                                 bcm_field_ForwardingType_t type,
                                 uint32 *data, uint32 *mask)
{

    if (NULL == data || NULL == mask) {
       return BCM_E_PARAM;
    }

    switch (stage_id) {
       case _BCM_FIELD_STAGE_INGRESS:
       case _BCM_FIELD_STAGE_EXACTMATCH:
           switch (type) {
            case bcmFieldForwardingTypeAny:
                *data = 0;
                *mask = 0;
                break;
            case bcmFieldForwardingTypeL2:
                *data = 0;
                *mask = 0xE;
                break;
            case bcmFieldForwardingTypeL2Independent:
                *data = 0;
                *mask = 0xF;
                break;
            case bcmFieldForwardingTypeL2Shared:
                *data = 1;
                *mask = 0xF;
                break;
            case bcmFieldForwardingTypeL2Vpn:
                *data = 2;
                *mask = 0xF;
                break;
            case bcmFieldForwardingTypeL2VpnDirect:
                *data = 3;
                *mask = 0xF;
                break;
            case bcmFieldForwardingTypeL3Direct:
                *data = 4;
                *mask = 0xF;
                break;
            case bcmFieldForwardingTypeL3:
                *data = 5;
                *mask = 0xF;
                break;
            case bcmFieldForwardingTypePortExtender:
                *data = 6;
                *mask = 0xF;
                break;
            case bcmFieldForwardingTypeMpls:
                *data = 7;
                *mask = 0xF;
                break;
            case bcmFieldForwardingTypeTrill:
                *data = 8;
                *mask = 0xF;
                break;
            default:
               return (BCM_E_PARAM);
          }
          break;
      default:
          return BCM_E_INTERNAL;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_field_th_forwardingType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyForwardingType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit     - (IN) Unit number.
 *      stage_id - (IN) Stage ID.
 *      entry    - (IN) BCM field entry id.
 *      type     - (OUT) Qualifier match forwarding type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_field_th_forwardingType_get(int unit, _field_stage_id_t stage_id,
                                 bcm_field_entry_t entry,
                                 uint32 data,  uint32 mask,
                                 bcm_field_ForwardingType_t *type)
{
    if (NULL == type) {
       return BCM_E_PARAM;
    }

    switch (stage_id) {
       case _BCM_FIELD_STAGE_INGRESS:
       case _BCM_FIELD_STAGE_EXACTMATCH:
          if ((0 == data) && (mask == 0)) {
              *type = bcmFieldForwardingTypeAny;
          } else if ((0 == data) && (mask == 0xE)) {
              *type = bcmFieldForwardingTypeL2;
          } else if ((0 == data) && (mask == 0xF)) {
              *type = bcmFieldForwardingTypeL2Independent;
          } else if ((1 == data) && (mask == 0xF)) {
              *type = bcmFieldForwardingTypeL2Shared;
          } else if ((2 == data) && (mask == 0xF)) {
              *type =  bcmFieldForwardingTypeL2Vpn;
          } else if ((3 == data) && (mask == 0xF)) {
              *type = bcmFieldForwardingTypeL2VpnDirect;
          } else if ((4 == data) && (mask == 0xF)) {
              *type = bcmFieldForwardingTypeL3Direct;
          } else if ((5 == data) && (mask == 0xF)) {
              *type = bcmFieldForwardingTypeL3;
          } else if ((6 == data) && (mask == 0xF)) {
              *type = bcmFieldForwardingTypePortExtender;
          } else if ((7 == data) && (mask == 0xF)) {
              *type = bcmFieldForwardingTypeMpls;
          } else if ((8 == data) && (mask == 0xF)) {
              *type = bcmFieldForwardingTypeTrill;
          } else {
              return (BCM_E_INTERNAL);
          }
           break;
       default:
           return BCM_E_INTERNAL;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_field_th_qualify_svp
 * Purpose:
 *      Add source virtual port field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      qual  - (IN) SVP Qualifier type
 *      data  - (IN) SVP data
 *      mask  - (IN) SVP Mask
 *      svp_valid - (IN) Indication to SVP Valid field
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_field_th_qualify_svp(int unit, bcm_field_entry_t entry,
                          bcm_field_qualify_t qual,
                          uint32 data, uint32 mask,
                          int svp_valid)
{
    int                        rv;        /* Operational Status */
     _field_entry_t            *f_ent;    /* Field entry structure. */
     _bcm_field_qual_offset_t  *q_offset; /* Field qualifier offset info. */

     /* Get the field entry operational structure. */
     BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
                                                   qual, &f_ent));

     /* Get qualifier offsets in the tcam. */
     rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
     BCM_IF_ERROR_RETURN(rv);

    if (mask == (uint32)BCM_FIELD_EXACT_MATCH_MASK) {
        uint32 multi_width;

        _BCM_FIELD_QUAL_MULTI_OFFSET_WIDTH(q_offset, multi_width);

        /* Exact match requested, make maximum mask value */
        mask =  (1 << multi_width) - 1;
    }

    /* coverity[address_of : FALSE] */
    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_th_qualify_set(unit, entry, qual, &data, &mask,
                                   _FP_QUALIFIER_ADD);
    BCM_IF_ERROR_RETURN(rv);

    f_ent->flags |= _FP_ENTRY_DIRTY;
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_th_qualify_dvp
 * Purpose:
 *      Add destination virtual port field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      qual  - (IN) SVP Qualifier type
 *      data  - (IN) SVP data
 *      mask  - (IN) SVP Mask
 *      dvp_valid - (IN) Indication to DVP Valid field
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_field_th_qualify_dvp(int unit,
                          bcm_field_entry_t entry,
                          bcm_field_qualify_t qual,
                          uint32 data, uint32 mask,
                          int dvp_valid)
{
    int                       rv;        /* Operational Status */
     _field_entry_t            *f_ent;   /* Field entry structure. */
     _bcm_field_qual_offset_t  *q_offset; /* Field qualifier offset info. */


     /* Get the field entry operational structure. */
     BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
                                                   qual, &f_ent));

     /* Get qualifier offsets in the tcam. */
     rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
     BCM_IF_ERROR_RETURN(rv);

    if (mask == (uint32)BCM_FIELD_EXACT_MATCH_MASK) {
        uint32 multi_width;

        _BCM_FIELD_QUAL_MULTI_OFFSET_WIDTH(q_offset, multi_width);
        /* Exact match requested, make maximum mask value */
        mask =  (1 << multi_width) - 1;
    }

    /* coverity[address_of : FALSE] */
    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_th_qualify_set(unit, entry, qual, &data, &mask,
                                   _FP_QUALIFIER_ADD);
    BCM_IF_ERROR_RETURN(rv);

    f_ent->flags |= _FP_ENTRY_DIRTY;
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_th_qualify_trunk
 * Purpose:
 *      Match on Source or Destination Trunk in Field Processor.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      qual  - (IN) Trunk Qualifier type
 *      data  - (IN) Trunk data
 *      mask  - (IN) Trunk Mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_field_th_qualify_trunk(int unit,
                            bcm_field_entry_t entry,
                            bcm_field_qualify_t qual,
                            bcm_trunk_t data, bcm_trunk_t mask)
{
    int              rv;          /* Operational Status. */
    uint32           hw_data = 0; /* HW buffer data. */
    uint32           hw_mask = 0; /* HW buffer mask. */
     _field_entry_t  *f_ent;      /* Field entry structure. */


    TRUNK_CHK_TGID_EXTENDED(unit, data);

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    if ((_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) ||
        (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id)) {

        /* set the trunk bit */
        hw_data = data | (0x1 << SOC_TRUNK_BIT_POS(unit));
        hw_mask = mask | (0x1 << SOC_TRUNK_BIT_POS(unit));

        /* coverity[address_of : FALSE] */
        /* coverity[callee_ptr_arith : FALSE] */
        rv = _bcm_field_th_qualify_set(unit, entry, qual, &hw_data, &hw_mask,
                                       _FP_QUALIFIER_ADD);
        BCM_IF_ERROR_RETURN(rv);

        f_ent->flags |= _FP_ENTRY_DIRTY;
    } else {
        return _bcm_field_qualify_trunk(unit, entry, qual, data, mask);
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_th_qualify_trunk_get
 * Purpose:
 *      Get Source or Destination Trunk qualified in Field Processor Key.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      qual  - (IN) Trunk Qualifier type
 *      data  - (OUT) Trunk data
 *      mask  - (OUT) Trunk Mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int
_bcm_field_th_qualify_trunk_get(int unit,
                                bcm_field_entry_t entry,
                                bcm_field_qualify_t qual,
                                bcm_trunk_t *data, bcm_trunk_t *mask)
{
    int       rv;          /* Operational Status. */
    uint32    hw_data = 0; /* HW buffer data. */
    uint32    hw_mask = 0; /* HW buffer mask. */
    _field_entry_t *f_ent; /* Field entry structure. */


    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask))  {
        return (BCM_E_PARAM);
    }

    if ((qual != bcmFieldQualifySrcTrunk) && (qual != bcmFieldQualifyDstTrunk)
        && (qual != bcmFieldQualifySrcGport) ){
        return (BCM_E_INTERNAL);
    }

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    if ((_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) ||
        (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id)) {

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, qual,
                                                   &hw_data, &hw_mask);

        /* set the trunk bit */
        *data = hw_data & ~(0x1 << SOC_TRUNK_BIT_POS(unit));
        *mask = hw_mask & ~(0x1 << SOC_TRUNK_BIT_POS(unit));

    } else {
        return _bcm_field_qualify_trunk_get(unit, entry, qual, data, mask);
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_th_qualify_PortBitmap
 * Purpose:
 *      Match on IPBM Source bitmap for the given bitmap.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      qual  - (IN) IPBM Qualifier type
 *      data  - (IN) IPBM data
 *      mask  - (IN) IPBM Mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
STATIC int
_bcm_field_th_qualify_PortBitmap(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_field_qualify_t qual,
                                 bcm_pbmp_t data,
                                 bcm_pbmp_t mask)
{
    int               rv;          /* Operational Status.           */
    uint8             instance;    /* Field group pipe information. */
    bcm_port_t        port;        /* Holds physical port number.   */
    bcm_pbmp_t        temp_pbm;    /* Holds valid pbm supported.    */
    bcm_pbmp_t        valid_pbm;   /* Holds valid pbm supported     */
    _field_stage_t   *stage_fc;    /* Stage operational Structure.  */
    _field_group_t   *fg;          /* Field group structure.        */
    _field_entry_t   *f_ent;       /* Field entry structure.        */

    /* Validate the qualifier. */
    if (!_BCM_FIELD_IS_PBMP_QUALIFIER(qual)) {
        return BCM_E_PARAM;
    }

    /* Get field entry structure pointer. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    fg = f_ent->group;
    /* Get the stage control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Confirm that InPorts/PortBitmap Qualifiers are in group's Qset. */
    if (!_BCM_FIELD_QSET_PBMP_TEST(fg->qset)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                  "Error: %s not in Group=%d Qset.\n"),
                  _field_qual_name(qual), fg->gid));
        return (BCM_E_NOT_FOUND);
    }

    if (bcmFieldGroupOperModePipeLocal == stage_fc->oper_mode) {
       instance = fg->instance;
    } else {
       /*
        * In-case of Atomic update, InPorts/PortBitmap qualifiers are not
        * support in Global mode.
        */
       if (soc_property_get(unit, spn_FIELD_ATOMIC_UPDATE, FALSE) == TRUE) {
          return BCM_E_UNAVAIL;
       }

       instance = _BCM_FIELD_GLOBAL_GROUP;
    }

    BCM_PBMP_CLEAR(valid_pbm);
    /* Retreive Valid PBMP for the given pipe */
    _BCM_FIELD_VALID_PIPE_PBMP_GET(unit, instance, valid_pbm);

    /* Validate data */
    BCM_PBMP_ASSIGN(temp_pbm, valid_pbm);
    BCM_PBMP_OR(temp_pbm, data);
    if (BCM_PBMP_NEQ(temp_pbm, valid_pbm)) {
       return BCM_E_PARAM;
    }

    /*
     * Check and clear invalid ports in the mask.
     */
    BCM_PBMP_AND(valid_pbm, mask);
    BCM_PBMP_ASSIGN(mask, valid_pbm);

    BCM_PBMP_CLEAR(f_ent->pbmp.data);
    BCM_PBMP_CLEAR(f_ent->pbmp.mask);

    switch (instance) {
        case _BCM_FIELD_PIPE0_GROUP:
        case _BCM_FIELD_PIPE1_GROUP:
        case _BCM_FIELD_PIPE2_GROUP:
        case _BCM_FIELD_PIPE3_GROUP:
        case _BCM_FIELD_PIPE4_GROUP:
        case _BCM_FIELD_PIPE5_GROUP:
        case _BCM_FIELD_PIPE6_GROUP:
        case _BCM_FIELD_PIPE7_GROUP:

            BCM_PBMP_ITER(data, port)  {
                 if ((port - (_FP_TCAM_IPBMP_SIZE(unit) * instance)) < 0) {
                     return BCM_E_PARAM;
                 }
                 BCM_PBMP_PORT_ADD(f_ent->pbmp.data, port -
                                (_FP_TCAM_IPBMP_SIZE(unit) * f_ent->group->instance));
            }
            BCM_PBMP_ITER(mask, port)  {
                 if ((port - (_FP_TCAM_IPBMP_SIZE(unit) * instance)) < 0) {
                     return BCM_E_PARAM;
                 }
                 BCM_PBMP_PORT_ADD(f_ent->pbmp.mask, port -
                                (_FP_TCAM_IPBMP_SIZE(unit) * f_ent->group->instance));
            }
            break;
        case _BCM_FIELD_GLOBAL_GROUP:
            BCM_PBMP_ASSIGN(f_ent->pbmp.data, data);
            BCM_PBMP_ASSIGN(f_ent->pbmp.mask, mask);
            break;
        default:
            return BCM_E_INTERNAL;
    }

    if (bcmFieldGroupOperModePipeLocal == stage_fc->oper_mode) {
        /* coverity[address_of : FALSE] */
        /* coverity[callee_ptr_arith : FALSE] */
        rv = _bcm_field_th_qualify_set(unit, entry, qual,
                                   (uint32 *)&f_ent->pbmp.data,
                                   (uint32 *)&f_ent->pbmp.mask,
                                   _FP_QUALIFIER_ADD);
        BCM_IF_ERROR_RETURN(rv);
    }

    f_ent->flags |= _FP_ENTRY_DIRTY;

    return BCM_E_NONE;
}



/*
 * Function:
 *      _bcm_field_th_qualify_InPorts
 * Purpose:
 *      Match on Source or Destination Trunk in Field Processor.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      qual  - (IN) IPBM Qualifier type
 *      data  - (IN) IPBM data
 *      mask  - (IN) IPBM Mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_field_th_qualify_InPorts(int unit,
                              bcm_field_entry_t entry,
                              bcm_field_qualify_t qual,
                              bcm_pbmp_t data,
                              bcm_pbmp_t mask)
{
    int               rv;          /* Operational Status.           */
    uint8             instance;    /* Field group pipe information. */
    bcm_port_t        port;        /* Holds physical port number.   */
    bcm_pbmp_t        temp_pbm;    /* Holds valid pbm supported.    */
    bcm_pbmp_t        valid_pbm;   /* Holds valid pbm supported     */
    _field_stage_t   *stage_fc;    /* Stage operational Structure.  */
    _field_group_t   *fg;          /* Field group structure.        */
    _field_entry_t   *f_ent;       /* Field entry structure.        */

    /* Validate the qualifier. */
    if (!_BCM_FIELD_IS_PBMP_QUALIFIER(qual)) {
        return BCM_E_PARAM;
    }

    if (qual != bcmFieldQualifyInPorts) {
       return _bcm_field_th_qualify_PortBitmap(unit, entry, qual, data, mask);
    }
    if (soc_feature(unit, soc_feature_ifp_no_inports_support)
        && qual == bcmFieldQualifyInPorts) {
        return (BCM_E_UNAVAIL);
    }
    /* Get field entry structure pointer. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    fg = f_ent->group;
    /* Get the stage control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    /* Confirm that InPorts/PortBitmap Qualifiers are in group's Qset. */
    if (!_BCM_FIELD_QSET_PBMP_TEST(fg->qset)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                  "Error: %s not in Group=%d Qset.\n"),
                  _field_qual_name(qual), fg->gid));
        return (BCM_E_NOT_FOUND);
    }

    if (bcmFieldGroupOperModePipeLocal == stage_fc->oper_mode) {
       instance = fg->instance;
       /* Retreive Valid Pipe PBMP */
       BCM_PBMP_ASSIGN(valid_pbm, PBMP_PIPE(unit, fg->instance));
       BCM_PBMP_REMOVE(valid_pbm, PBMP_LB(unit));
    } else {
       /*
        * In-case of Atomic update, InPorts/PortBitmap qualifiers are not
        * support in Global mode.
        */
       if (soc_property_get(unit, spn_FIELD_ATOMIC_UPDATE, FALSE) == TRUE) {
          return BCM_E_UNAVAIL;
       }

       instance = _BCM_FIELD_GLOBAL_GROUP;
       /* Retreive Valid PBMP for all the ports */
       BCM_PBMP_CLEAR(valid_pbm);
       BCM_IF_ERROR_RETURN(_bcm_field_valid_pbmp_get(unit, &valid_pbm));
    }

    /* Validate data */
    BCM_PBMP_ASSIGN(temp_pbm, valid_pbm);
    BCM_PBMP_AND(temp_pbm, data);
    if (BCM_PBMP_NEQ(temp_pbm, data)) {
       return BCM_E_PARAM;
    }

    /*
     * Check and clear invalid ports in the mask.
     */
    BCM_PBMP_AND(valid_pbm, mask);
    BCM_PBMP_ASSIGN(mask, valid_pbm);
    /*
     * Add Loopback ports to mask so that Loopback packets
     * will not hit entry if InPorts is qualified.
     */
    if (bcmFieldGroupOperModePipeLocal == stage_fc->oper_mode) {
        bcm_pbmp_t pipe_lb_mask;
        int prt_no;
        BCM_PBMP_CLEAR(pipe_lb_mask);
        /* Getting Loopback PBM per pipe */
        for (prt_no = instance * _FP_TCAM_IPBMP_SIZE(unit);
                prt_no < (instance + 1) * _FP_TCAM_IPBMP_SIZE(unit); prt_no++) {
            BCM_PBMP_PORT_ADD(pipe_lb_mask, prt_no);
        }
        BCM_PBMP_AND(pipe_lb_mask, PBMP_LB(unit));
        BCM_PBMP_OR(mask, pipe_lb_mask);
    } else {
        BCM_PBMP_OR(mask, PBMP_LB(unit));
    }


    BCM_PBMP_CLEAR(f_ent->pbmp.data);
    BCM_PBMP_CLEAR(f_ent->pbmp.mask);


    switch (instance) {
        case _BCM_FIELD_PIPE0_GROUP:
        case _BCM_FIELD_PIPE1_GROUP:
        case _BCM_FIELD_PIPE2_GROUP:
        case _BCM_FIELD_PIPE3_GROUP:
        case _BCM_FIELD_PIPE4_GROUP:
        case _BCM_FIELD_PIPE5_GROUP:
        case _BCM_FIELD_PIPE6_GROUP:
        case _BCM_FIELD_PIPE7_GROUP:
            BCM_PBMP_ITER(data, port)  {
                 if ((port - (_FP_TCAM_IPBMP_SIZE(unit) * instance)) < 0) {
                     return BCM_E_PARAM;
                 }
                 BCM_PBMP_PORT_ADD(f_ent->pbmp.data, port -
                                   (_FP_TCAM_IPBMP_SIZE(unit)
                                    * f_ent->group->instance));
            }
            BCM_PBMP_ITER(mask, port)  {
                 if ((port - (_FP_TCAM_IPBMP_SIZE(unit) * instance)) < 0) {
                     return BCM_E_PARAM;
                 }
                 BCM_PBMP_PORT_ADD(f_ent->pbmp.mask, port -
                                   (_FP_TCAM_IPBMP_SIZE(unit)
                                    * f_ent->group->instance));
            }
            break;
        case _BCM_FIELD_GLOBAL_GROUP:
            BCM_PBMP_ITER(data, port)  {
                 BCM_PBMP_PORT_ADD(f_ent->pbmp.data, port);
            }
            BCM_PBMP_ITER(mask, port)  {
                 BCM_PBMP_PORT_ADD(f_ent->pbmp.mask, port);
            }
            break;
        default:
            return BCM_E_INTERNAL;
    }

    if (bcmFieldGroupOperModePipeLocal == stage_fc->oper_mode) {
        /* coverity[address_of : FALSE] */
        /* coverity[callee_ptr_arith : FALSE] */
        rv = _bcm_field_th_qualify_set(unit, entry, qual,
                                   (uint32 *)&f_ent->pbmp.data,
                                   (uint32 *)&f_ent->pbmp.mask,
                                   _FP_QUALIFIER_ADD);
        BCM_IF_ERROR_RETURN(rv);
    }

    f_ent->flags |= _FP_ENTRY_DIRTY;

    return BCM_E_NONE;
}

int
_bcm_field_th_qualify_VlanTranslationHit(int               unit,
                                          bcm_field_entry_t entry,
                                          uint8             *data,
                                          uint8             *mask)
{
    _field_entry_t *f_ent = NULL;
    int (*func)(int, bcm_field_entry_t, uint8 *, uint8 *) =
                                         _field_qualify_VlanTranslationHit;

    if (soc_feature(unit, soc_feature_field_preselector_support) &&
            (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == FALSE))
    {
        BCM_IF_ERROR_RETURN(_field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent));

#if defined(BCM_TRIDENT3_SUPPORT)
        if (soc_feature(unit, soc_feature_td3_style_fp)
                && (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id)) {
            func = _bcm_field_td3_qualify_VlanTranslationHit;
        } else
#endif
        if (SOC_IS_TD2_TT2(unit)
            && (_BCM_FIELD_STAGE_EGRESS != f_ent->group->stage_id)) {
            func = _bcm_field_td2_qualify_VlanTranslationHit;
        } 
    } else {
        func = _bcm_field_td2_qualify_VlanTranslationHit;
    }

    BCM_IF_ERROR_RETURN((*func)(unit, entry, data, mask));
    return BCM_E_NONE;

}
/*
 * Function:
 *  _bcm_field_th_entry_check_full_mask
 * Purpose:
 *  To check if mask for qualifier is exact match mask
 * Parameters:
 *  unit       - (IN) BCM device number.
 *  qid        - (IN) Qualifier id.
 *  stage_fc   - (IN) Stage Control Structure.
 *  mask       - (IN) Qualifying Mask.
 *  flags      - (IN) Qualifier Flags.
 * Returns:
 *  BCM_E_XXX
 */
int
_bcm_field_th_entry_check_full_mask(int unit, int qid,
                                    _field_stage_t *stage_fc,
                                    uint32 *mask, uint8 flags)
{
    int rv = BCM_E_NONE;           /* BCM Operational Status.   */
    uint32 qual_width = 0;         /* Actual Qualifier Width.   */
    uint32 keywords = 0;           /* Width Keywords.           */
    uint32 leftover_width = 0;     /* Qualifier Leftover width. */
    uint32 idx = 0;                /* Index for Iteration.      */
    uint32 mask_exact = ~0;        /* Exact Match Mask.         */
    uint32 mask_orig = 0;          /* Original Mask Data.       */
    uint8  max_chunks = 0;         /* Max available chunks per qual */
    uint8  num_chunks = 0;         /* iterator for chunks */

    /* Input Parameter Check. */
    if ((stage_fc == NULL) ||
        (mask == NULL)) {
        return (BCM_E_PARAM);
    }

    /* If Called for Delete then ignore. */
    if (flags & _FP_QUALIFIER_DEL) {
        return (BCM_E_NONE);
    }

    /* For Certain Qualifiers mask is internal.
     * It can be ignored. */
    if ((qid == bcmFieldQualifyL2Format) ||
        (qid == bcmFieldQualifyVlanTranslationHit) ||
        (qid == bcmFieldQualifyForwardingType) ||
        (qid == bcmFieldQualifyTunnelType) ||
        (qid == bcmFieldQualifyLoopbackType) ||
        (qid == bcmFieldQualifySrcModPortGport) ||
        (qid == bcmFieldQualifySrcModPortGports) ||
        (qid == bcmFieldQualifySrcModuleGport) ||
        (qid == bcmFieldQualifySrcTrunkMemberGport) ||
        (qid == bcmFieldQualifySrcTrunk) ||
        (qid == bcmFieldQualifySrcMplsGport) ||
        (qid == bcmFieldQualifySrcMplsGports) ||
        (qid == bcmFieldQualifySrcMimGport) ||
        (qid == bcmFieldQualifySrcMimGports) ||
        (qid == bcmFieldQualifySrcWlanGport) ||
        (qid == bcmFieldQualifySrcWlanGports) ||
        (qid == bcmFieldQualifySrcVlanGport) ||
        (qid == bcmFieldQualifySrcVlanGports) ||
        (qid == bcmFieldQualifySrcVxlanGport) ||
        (qid == bcmFieldQualifySrcVxlanGports) ||
        (qid == bcmFieldQualifySrcNivGport) ||
        (qid == bcmFieldQualifySrcNivGports) ) {
        return (BCM_E_NONE);
    }

    /* For all data qualifiers exact match mask checks are done
     * in _field_qualify_data
     */
    if ((qid == _bcmFieldQualifyData0) ||
        (qid == _bcmFieldQualifyData1) ||
        (qid == _bcmFieldQualifyData2) ||
        (qid == _bcmFieldQualifyData3) ||
        (qid == _bcmFieldQualifyData4) ||
        (qid == _bcmFieldQualifyData5) ||
        (qid == _bcmFieldQualifyData6) ||
        (qid == _bcmFieldQualifyData7) ||
        (qid == _bcmFieldQualifyData8) ||
        (qid == _bcmFieldQualifyData9) ||
        (qid == _bcmFieldQualifyData10) ||
        (qid == _bcmFieldQualifyData11) ||
        (qid == _bcmFieldQualifyData12) ||
        (qid == _bcmFieldQualifyData13) ||
        (qid == _bcmFieldQualifyData14) ||
        (qid == _bcmFieldQualifyData15)) {
        return BCM_E_NONE;
    }

    if ((NULL != stage_fc->qual_cfg_info_db) &&
            (NULL != stage_fc->qual_cfg_info_db->qual_cfg_info[qid])) {
        max_chunks = stage_fc->qual_cfg_info_db->qual_cfg_info[qid]->qual_cfg_arr[0].num_chunks;
        /*
         * Loop over all chunks available for respective qualifier.
         * Sum width of each chunk to make qualifier total width.
         */
        for (num_chunks = 0; num_chunks < max_chunks; num_chunks++) {
            qual_width += stage_fc->qual_cfg_info_db->qual_cfg_info[qid]->qual_cfg_arr[0].e_params[num_chunks].width;
        }
    } else if((NULL != stage_fc->f_qual_arr[qid]) &&
            (NULL != stage_fc->f_qual_arr[qid]->conf_arr)) {
        /* Retreive Actual Qualifier Width. */
        qual_width = stage_fc->f_qual_arr[qid]->conf_arr->offset.qual_width;
    } else {
        /* Something is really wrong. No Qual DB is present */
        return BCM_E_INTERNAL;
    }


    /* Calculate data words and leftover width. */
    keywords = qual_width/32;
    leftover_width = qual_width%32;

    /* Go to last MSB part of qualifier. */
    for (idx = 0; idx < keywords; idx++) {
        mask_exact = ~0;
        if (*mask != mask_exact) {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: Qual(%s) "
                                "mask = 0x%08x is not exact match.\n"),
                     unit, _field_qual_name(qid), *mask));
            return (BCM_E_PARAM);
        }
        mask++;
    }

    if (leftover_width != 0) {
        /* Check if mask is exact, ignore higher mask bits */
        mask_exact = ((1 << leftover_width) - 1);
        mask_orig = *mask & ((1 << leftover_width) - 1);

        if (mask_orig != mask_exact) {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: Qual(%s) "
                                "mask = 0x%08x is not exact match.\n"),
                     unit, _field_qual_name(qid), *mask));
            return (BCM_E_PARAM);
        }
    }

    return (rv);
}

/*
 * Function:
 *     _bcm_field_th_qual_part_offset_get
 * Purpose:
 *     Retrieve qualifier offsets
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     f_ent      - (IN) Field entry structure.
 *     entry_part - (IN) Entry part
 *     qid        - (IN) Qualifier id.
 *     offset     - (OUT) Qualifier offset and width.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_qual_part_offset_get(int unit, _field_entry_t *f_ent,
                                   int entry_part, int qid,
                                   _bcm_field_qual_offset_t *offset)
{
    _bcm_field_group_qual_t *q_arr;     /* Qualifiers array.          */
    _field_group_t          *fg;        /* Field group structure.     */
    uint8                   entry_type; /* Index to tcam entries
                                           of multiple types      */
    int                     idx;        /* Entry qualifiers iterator. */

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
               "_field_qual_offset_get\n")));

    /* Input parameters check. */
    if ((NULL == offset) || (NULL == f_ent)) {
        return (BCM_E_PARAM);
    }

    /* Validate Entry Part */
    if (entry_part > _FP_MAX_ENTRY_WIDTH) {
        return (BCM_E_PARAM);
    }

    /* Get entry group. */
    fg = f_ent->group;

    if (0 == BCM_FIELD_QSET_TEST(fg->qset, qid)) {
        /* Only qualifiers that were explicitly requested may be used */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                  "FP(unit %d) Error: qual=%s not in group=%d Qset\n"),
                   unit, _field_qual_name(qid), f_ent->group->gid));
        return (BCM_E_PARAM);
    }

    entry_type = _FP_ENTRY_TYPE_DEFAULT;
    /* Get qualifier information. */
    q_arr = &(fg->qual_arr[entry_type][entry_part]);
    for (idx = 0; idx < q_arr->size; idx++) {
        if (qid == q_arr->qid_arr[idx]) {
            sal_memcpy(offset, q_arr->offset_arr + idx,
                          sizeof(_bcm_field_qual_offset_t));
            break;
        }
    }

    if (idx == q_arr->size) {
        offset = NULL;
        return (BCM_E_NOT_FOUND);
    }

    /*
     *  For Single wide mode, MSB 80-bits of 160-bits are valid
     *  in the final key, hence shift the offset by 80-bit.
     */
    if (fg->stage_id == _BCM_FIELD_STAGE_INGRESS) {
        if ((fg->flags & _FP_GROUP_SPAN_SINGLE_SLICE) &&
                !(fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)) {
            int qual_part;

            for (qual_part = 0; qual_part < (offset)->num_offsets; ++qual_part) {
                if ((offset)->width[qual_part] > 0) {
                    (offset)->offset[qual_part] -= 80;
                }
            }
        }
    } else  if (fg->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        /* In Exact Match Mode 128 - whole key is not presented
         * for lookup. Instead Bit 0-47 and Bit 80-160 are provided
         * to UFT. Hence qualifier offsets at position greater than
         * 80 bit are shifted by 32 bit for key.
         */
        if(fg->em_mode == _FieldExactMatchMode128) {
           if (soc_feature(unit, soc_feature_th3_style_fp)) {
               int q_part;
               for (q_part = 0; q_part < (offset)->num_offsets; ++q_part) {
                   if ((offset)->width[q_part] > 0) {
                       if(((offset)->offset[q_part]) > 51) {
                           (offset)->offset[q_part] -= 32;
                       }
                   }
               }
            } else {
                int q_part;
                for (q_part = 0; q_part < (offset)->num_offsets; ++q_part) {
                    if ((offset)->width[q_part] > 0) {
                        if(((offset)->offset[q_part]) > 79) {
                            (offset)->offset[q_part] -= 32;
                        }
                    }
                }
            }
        }
#if defined(BCM_FLOWTRACKER_SUPPORT)
    } else if (fg->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER) {
        int q_part;
        /*
         * Flowtracker stage support 2 modes - Single (180 bits) and
         * Double (360 bits) using 1 and 2 indices in TCAM.
         * Each entry has 7-bit Keytype and 1-bit keymode at bit position 0 to
         * 7th in KEYf. So, substacting 180 bits and then adding 8 bits to the
         * correct offset per hw entry.
         */
        for (q_part = 0; q_part < (offset)->num_offsets; ++q_part) {
            if ((offset)->width[q_part] > 0) {
                (offset)->offset[q_part] -= (entry_part * 180);
                (offset)->offset[q_part] += 8;
            }
        }
#endif
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    } else if (fg->stage_id == _BCM_FIELD_STAGE_AMFTFP) {
        /* Flowtracker AMFP stage support 1 mode - Single */
        return (BCM_E_NONE);
#endif /* BCM_FLOWTRACKER_V3_SUPPORT */
    } else {
        /* Invalid Stage. */
        return (BCM_E_PARAM);
    }

    return (BCM_E_NONE);
}

int
_field_udf_internal_qual_valid_get(int unit, int int_qual,
                                   uint32 chunk_bitmap, uint8 *valid)
{
    uint8 compound_chunk = 0;

    if (NULL == valid) {
        return BCM_E_PARAM;
    }

    compound_chunk = !(soc_feature(unit, soc_feature_td3_style_fp)
                        || soc_feature(unit, soc_feature_udf_selector_support));
    switch (int_qual) {
        case _bcmFieldQualifyData0:
             *valid = (chunk_bitmap & (1 << 0));
             break;
        case _bcmFieldQualifyData1:
             *valid = (chunk_bitmap & (1 << 1));
             break;
        case _bcmFieldQualifyData2:
             if (compound_chunk) {
                 *valid = (chunk_bitmap & (1 << 2)) || (chunk_bitmap & (1 << 3));
             } else {
                 *valid = (chunk_bitmap & (1 << 2));
             }
             break;
        case _bcmFieldQualifyData3:
             if (compound_chunk) {
                 *valid = (chunk_bitmap & (1 << 4)) || (chunk_bitmap & (1 << 5));
             } else {
                 *valid = (chunk_bitmap & (1 << 3));
             }
             break;
        case _bcmFieldQualifyData4:
             if (compound_chunk) {
                 *valid = (chunk_bitmap & (1 << 6)) || (chunk_bitmap & (1 << 7));
             } else {
                 *valid = (chunk_bitmap & (1 << 4));
             }
             break;
        case _bcmFieldQualifyData5:
             if (compound_chunk) {
                 *valid = (chunk_bitmap & (1 << 8)) || (chunk_bitmap & (1 << 9));
             } else {
                 *valid = (chunk_bitmap & (1 << 5));
             }
             break;
        case _bcmFieldQualifyData6:
             if (compound_chunk) {
                 *valid = (chunk_bitmap & (1 << 9)) || (chunk_bitmap & (1 << 10));
             } else {
                 *valid = (chunk_bitmap & (1 << 6));
             }
             break;
        case _bcmFieldQualifyData7:
             if (compound_chunk) {
                 *valid = (chunk_bitmap & (1 << 10)) || (chunk_bitmap & (1 << 11));
             } else {
                 *valid = (chunk_bitmap & (1 << 7));
             }
             break;
        case _bcmFieldQualifyData8:
             if (compound_chunk) {
                 *valid = (chunk_bitmap & (1 << 12)) || (chunk_bitmap & (1 << 13));
             } else {
                 *valid = (chunk_bitmap & (1 << 8));
             }
             break;
        case _bcmFieldQualifyData9:
             if (compound_chunk) {
                 *valid = (chunk_bitmap & (1 << 14)) || (chunk_bitmap & (1 << 15));
             } else {
                 *valid = (chunk_bitmap & (1 << 9));
             }
             break;
        case _bcmFieldQualifyData10:
             *valid = (chunk_bitmap & (1 << 10));
             break;
        case _bcmFieldQualifyData11:
             *valid = (chunk_bitmap & (1 << 11));
             break;
        case _bcmFieldQualifyData12:
             *valid = (chunk_bitmap & (1 << 12));
             break;
        case _bcmFieldQualifyData13:
             *valid = (chunk_bitmap & (1 << 13));
             break;
        case _bcmFieldQualifyData14:
             *valid = (chunk_bitmap & (1 << 14));
             break;
        case _bcmFieldQualifyData15:
             *valid = (chunk_bitmap & (1 << 15));
             break;
        default:
             return BCM_E_INTERNAL;
    }
    return BCM_E_NONE;
}

int
_field_udf_chunk_to_internal_qual_get(int unit, uint16 chunk, int *int_qual)
{
    uint8 compound_chunk = 0;
    if (NULL == int_qual) {
        return BCM_E_PARAM;
    }

    compound_chunk = !(soc_feature(unit, soc_feature_td3_style_fp)
                        || soc_feature(unit, soc_feature_udf_selector_support));
    switch(chunk) {
        case 0x0:
            *int_qual = _bcmFieldQualifyData0;
            break;
        case 0x1:
            *int_qual = _bcmFieldQualifyData1;
            break;
        case 0x2:
            *int_qual = _bcmFieldQualifyData2;
            break;
        case 0x3:
            *int_qual = (compound_chunk) ? (_bcmFieldQualifyData2) : (_bcmFieldQualifyData3);
            break;
        case 0x4:
            *int_qual = (compound_chunk) ? (_bcmFieldQualifyData3) : (_bcmFieldQualifyData4);
            break;
        case 0x5:
            *int_qual = (compound_chunk) ? (_bcmFieldQualifyData3) : (_bcmFieldQualifyData5);
            break;
        case 0x6:
            *int_qual = (compound_chunk) ? (_bcmFieldQualifyData4) : (_bcmFieldQualifyData6);
            break;
        case 0x7:
            *int_qual = (compound_chunk) ? (_bcmFieldQualifyData4) : (_bcmFieldQualifyData7);
            break;
        case 0x8:
            *int_qual = (compound_chunk) ? (_bcmFieldQualifyData5) : (_bcmFieldQualifyData8);
            break;
        case 0x9:
            *int_qual = (compound_chunk) ? (_bcmFieldQualifyData6) : (_bcmFieldQualifyData9);
            break;
        case 10:
            *int_qual = (compound_chunk) ? (_bcmFieldQualifyData7) : (_bcmFieldQualifyData10);
            break;
        case 11:
            *int_qual = (compound_chunk) ? (_bcmFieldQualifyData7) : (_bcmFieldQualifyData11);
            break;
        case 12:
            *int_qual = (compound_chunk) ? (_bcmFieldQualifyData8) : (_bcmFieldQualifyData12);
            break;
        case 13:
            *int_qual = (compound_chunk) ? (_bcmFieldQualifyData8) : (_bcmFieldQualifyData13);
            break;
        case 14:
            *int_qual = (compound_chunk) ? (_bcmFieldQualifyData9) : (_bcmFieldQualifyData14);
            break;
        case 15:
            *int_qual = (compound_chunk) ? (_bcmFieldQualifyData9) : (_bcmFieldQualifyData15);
            break;
        default:
            return BCM_E_INTERNAL;
    }
    return BCM_E_NONE;
}
int
_bcm_th_qual_hint_bmp_get(int unit, int qual,
                          uint8 em_keygen_mask,
                          _field_hint_t *hint_node,
                          uint32 *qual_bitmap,
                          uint8 partial,
                          bcm_field_qset_t *qset,
                          bcmi_keygen_qual_info_t *qual_info)
{
    bcm_udf_id_t udf_id;
    int idx = 0;
    uint8 valid = 0;
    uint8 start_second_chunk = 0;
    uint8 end_second_chunk = 0;
#if defined(BCM_TRIDENT3_SUPPORT)
    _bcm_udf_td3_obj_info_t *obj_info = NULL;
#endif
    bcmi_xgs4_udf_offset_info_t *offset_info = NULL;
    uint32 chunk_bmap = 0;
    uint32 temp_bitmap = 0;
    uint32 start_width = 0;
    uint32 start_bit = 0;
    uint32 end_bit = 0;
    uint32 cont_width = 0;
    uint32 end_width = 0;
    uint16 chunk = 0;
    uint16 extra_width = 0;
    uint16 max_chunks = 0;
    uint16 start_chunk = 0;
    uint16 start_chunk_valid = 0;
    uint16 end_chunk = 0;
    int int_qual_start = 0;
    int int_qual_end = 0;

    udf_id =  hint_node->hint->udf_id;
    /* Get UDF info. */
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        BCM_IF_ERROR_RETURN(_bcm_udf_td3_object_info_get(unit, udf_id, &obj_info));
        chunk_bmap = obj_info->chunk_bmap;
        cont_width = obj_info->width;
        max_chunks = _BCM_UDF_CTRL_MAX_UDF_CHUNKS(unit);
    } else
#endif
    {
        BCM_IF_ERROR_RETURN(bcmi_xgs4_udf_offset_node_get(unit, udf_id, &offset_info));
        chunk_bmap = offset_info->hw_bmap;
        cont_width = offset_info->width;
        max_chunks = BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit);
    }

    /* Logical Start and end chunks  based on user given inputs */
    if (!soc_feature(unit, soc_feature_td3_style_fp)) {
        /*
         * Check whether UDF container width is multiple of 16 or not.
         * cont_width is multiple of bytes. It has to be even number for multiple of 16 bits
         */
        if (cont_width & 1) {
            /*
             * For the UDFs whcih are not multiples of 16,
             * Chunk allocation is always be mutlples of 16 bit.
             * Need to think that the given start and end bit be
             * 8 bits extra width.
             */
            extra_width = partial ? 8 : 0;
        }
    }

    if ((hint_node->hint->start_bit > (cont_width * 8))
            || (hint_node->hint->end_bit) > (cont_width * 8)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
              "Provided hint has wrong start/end bit\n\r")));
        return BCM_E_PARAM;
    }

    start_chunk = hint_node->hint->start_bit/16 + extra_width;
    end_chunk = hint_node->hint->end_bit/16 + extra_width;
    chunk = 0;
    start_chunk_valid = 0;
    /* Derive physical chunks with logical moves */
    for (idx = max_chunks - 1; idx >= 0; idx--) {
        if ((chunk_bmap & (1 << idx))) {
            if ((0 == start_chunk_valid) && (chunk == start_chunk)) {
                start_chunk = idx;
                start_chunk_valid = 1;
            }
            if (chunk == end_chunk) {
                end_chunk = idx;
                break;
            }
            chunk++;
        }
    }

    BCM_IF_ERROR_RETURN(_field_udf_chunk_to_internal_qual_get(unit, start_chunk, &int_qual_start));
    BCM_IF_ERROR_RETURN(_field_udf_chunk_to_internal_qual_get(unit, end_chunk, &int_qual_end));

    if ((_bcmFieldQualifyCount == int_qual_start)
            || (_bcmFieldQualifyCount == int_qual_end)) {
        return BCM_E_INTERNAL;
    }

    if (soc_feature(unit, soc_feature_td3_style_fp)
            || soc_feature(unit, soc_feature_udf_selector_support)) {
        start_bit = hint_node->hint->start_bit%16;
        end_width = hint_node->hint->end_bit%16;
        start_width = _UDF_CHUNK_WIDTH_ - start_bit;
        /* End chunk starts from 0 for all 16bit chunks */
        end_bit = 0;
    } else if (SOC_IS_TOMAHAWK(unit) || SOC_IS_TOMAHAWK2(unit)) {
        switch (int_qual_start) {
            case _bcmFieldQualifyData0:
            case _bcmFieldQualifyData1:
            case _bcmFieldQualifyData5:
            case _bcmFieldQualifyData6:
                start_bit = hint_node->hint->start_bit%(_UDF_CHUNK_WIDTH_);
                start_width = _UDF_CHUNK_WIDTH_ - start_bit;
                break;
            case _bcmFieldQualifyData2:
                 _FIELD_UDF_START_CHUNK_OFFSET_GET(2, 3);
                break;
            case _bcmFieldQualifyData3:
                 _FIELD_UDF_START_CHUNK_OFFSET_GET(4, 5);
                break;
            case _bcmFieldQualifyData4:
                 _FIELD_UDF_START_CHUNK_OFFSET_GET(6, 7);
                break;
            case _bcmFieldQualifyData7:
                 _FIELD_UDF_START_CHUNK_OFFSET_GET(10, 11);
                break;
            case _bcmFieldQualifyData8:
                 _FIELD_UDF_START_CHUNK_OFFSET_GET(12, 13);
                break;
            case _bcmFieldQualifyData9:
                 _FIELD_UDF_START_CHUNK_OFFSET_GET(14, 15);
                break;
            default:
                return BCM_E_INTERNAL;
        }

        switch (int_qual_end) {
            case _bcmFieldQualifyData0:
            case _bcmFieldQualifyData1:
            case _bcmFieldQualifyData5:
            case _bcmFieldQualifyData6:
                end_width = hint_node->hint->end_bit%(_UDF_CHUNK_WIDTH_);
                break;
            case _bcmFieldQualifyData2:
                _FIELD_UDF_END_CHUNK_OFFSET_GET(2, 3);
                break;
            case _bcmFieldQualifyData3:
                _FIELD_UDF_END_CHUNK_OFFSET_GET(4, 5);
                break;
            case _bcmFieldQualifyData4:
                _FIELD_UDF_END_CHUNK_OFFSET_GET(6, 7);
                break;
            case _bcmFieldQualifyData7:
                _FIELD_UDF_END_CHUNK_OFFSET_GET(10, 11);
                break;
            case _bcmFieldQualifyData8:
                _FIELD_UDF_END_CHUNK_OFFSET_GET(12, 13);
                break;
            case _bcmFieldQualifyData9:
                _FIELD_UDF_END_CHUNK_OFFSET_GET(14, 15);
                break;
            default:
                return BCM_E_INTERNAL;
        }
    } else {
        return BCM_E_INTERNAL;
    }

    if (partial && (start_second_chunk || end_second_chunk)) {
        temp_bitmap = *qual_bitmap;
        *qual_bitmap = 0;
    }

    idx = 0;
    if (em_keygen_mask && (*qual_bitmap)) {
        /*
         * EM KEYGEN needs to set the number of bits needed for the qualfiier
         * not the bit positions bitmap.
         * So whenever Same qualifier has mutliple hints,
         * need to consider previous hint width too.
         */
        for (idx = 0; (idx < 32) && (SHR_BITGET(qual_bitmap, idx)); idx++);
    }

    if ((int_qual_start == qual) && (int_qual_end == qual)) {
        SHR_BITSET_RANGE(qual_bitmap,
                    em_keygen_mask ? 0 : start_bit,
                    (idx + hint_node->hint->end_bit - hint_node->hint->start_bit + 1));

        if (start_second_chunk) {
            SHR_BITSET_RANGE(qual_bitmap,
                    (start_bit >= _UDF_CHUNK_WIDTH_) ? 0 : _UDF_CHUNK_WIDTH_,
                    _UDF_CHUNK_WIDTH_);
        }

        if ((0 == start_second_chunk) && end_second_chunk) {
            SHR_BITSET_RANGE(qual_bitmap,
                    (end_width >= _UDF_CHUNK_WIDTH_) ? 0 : _UDF_CHUNK_WIDTH_,
                    _UDF_CHUNK_WIDTH_);
        }

        if (partial && (NULL != qual_info)) {
            qual_info->partial = TRUE;
        }
    } else {
        if (qual == int_qual_start) {
            SHR_BITSET_RANGE(qual_bitmap,
                    em_keygen_mask ? 0 : start_bit,
                    idx + start_width);
            if (start_second_chunk) {
                SHR_BITSET_RANGE(qual_bitmap,
                        (start_bit >= _UDF_CHUNK_WIDTH_) ? 0 : _UDF_CHUNK_WIDTH_,
                        _UDF_CHUNK_WIDTH_);
            }
            if (partial && (NULL != qual_info)) {
                qual_info->partial = TRUE;
            }
        } else if (qual == int_qual_end) {
            SHR_BITSET_RANGE(qual_bitmap,
                    em_keygen_mask ? 0 : end_bit, (idx + end_width + 1));
            if (end_second_chunk) {
                SHR_BITSET_RANGE(qual_bitmap,
                        (end_width >= _UDF_CHUNK_WIDTH_) ? 0 : _UDF_CHUNK_WIDTH_,
                        _UDF_CHUNK_WIDTH_);
            }
            if (partial && (NULL != qual_info)) {
                qual_info->partial = TRUE;
            }
        } else if ((int_qual_start < qual) || (qual < int_qual_end)) {
            if (partial && (NULL != qual_info)) {
                /* Check whether qual belongs to this UDF Object */
                BCM_IF_ERROR_RETURN(_field_udf_internal_qual_valid_get(unit, qual, chunk_bmap, &valid));
                if (valid) {
                    qual_info->partial = TRUE;
                }
            }
        }
    }

    if (partial && temp_bitmap && (start_second_chunk || end_second_chunk)) {
        *qual_bitmap &= temp_bitmap;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_th_qual_hints_get
 * Purpose:
 *     Get the hints for the given qualifier.
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     qual       - (IN) Field Qualifier.
 *     hintid     - (IN) HintId attached to the field group.
 *     hints_present  - (OUT) Flag to indicate whetehr hints
 *                            present for the qualifier or not.
 *     qual_bitmap    - (OUT) Required bit to extract for the qualifier.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_qual_hints_get(int unit, int qual,
                             bcm_field_hintid_t hintid,
                             bcm_field_qset_t *qset,
                             uint8 *hints_present,
                             _bcm_field_qual_data_t qual_bitmap)
{
    int idx = 0;                             /* Index variablre. */
    uint8 hints_p = 0;                       /* hints present status */
    _field_hints_t        *f_ht = NULL;      /* Field hints Structure. */
    _field_hint_t         *hint_node = NULL; /* Field hint Structure. */

    /* Parameters Check */
    if (NULL == hints_present) {
        return BCM_E_PARAM;
    }

    *hints_present = 0;
    _FP_QUAL_DATA_CLEAR(qual_bitmap);

    BCM_IF_ERROR_RETURN(_field_hints_control_get (unit, hintid, &f_ht));

    /* Not a valid hint Id. */
    if (NULL == f_ht) {
        return BCM_E_NONE;
    }

    /* No hinta are attached to the hintid. */
    if (NULL == f_ht->hints) {
        return BCM_E_NONE;
    }

    /* Go through all the hints in the hintid. */
    hint_node = f_ht->hints;
    while (NULL != hint_node) {

        if (bcmFieldQualifyUdf != hint_node->hint->qual) {
            if ((bcmFieldHintTypeExtraction == hint_node->hint->hint_type) &&
                    (qual == hint_node->hint->qual)) {
                *hints_present = 1;
                break;
            }
        } else {
            if ((bcmFieldHintTypeExtraction == hint_node->hint->hint_type) &&
                    (_FIELD_IS_INTERNAL_UDF_QUAL(qual))) {
                *hints_present = 1;
                break;
            }
        }

        hint_node = hint_node->next;
    }

    /* Hints not present for the qualifier. */
    if (!(*hints_present)) {
        return BCM_E_NONE;
    }

    hint_node = f_ht->hints;

    /* Update the required bits for the qualifier. */
    while (NULL != hint_node) {

        if (bcmFieldQualifyUdf != hint_node->hint->qual) {
            if (bcmFieldHintTypeExtraction == hint_node->hint->hint_type &&
                    qual != hint_node->hint->qual) {
                hint_node = hint_node->next;
                continue;
            }
        } else {
            if ((bcmFieldHintTypeExtraction == hint_node->hint->hint_type) &&
                    (!(_FIELD_IS_INTERNAL_UDF_QUAL(qual)))) {
                hint_node = hint_node->next;
                continue;
            }
        }

#if defined(BCM_FLOWTRACKER_SUPPORT)
        if ((qual == bcmFieldQualifyDosAttackEvents) ||
            (qual == bcmFieldQualifyInnerDosAttackEvents)) {
            SHR_BITOR_RANGE(&(hint_node->hint->dosattack_event_flags),
                    qual_bitmap, 0, 32, qual_bitmap);
            hint_node = hint_node->next;
            continue;
        }
#endif

        if (bcmFieldQualifyUdf != hint_node->hint->qual) {
            for (idx = hint_node->hint->start_bit;
                    idx <= hint_node->hint->end_bit; idx++) {
                SHR_BITSET(qual_bitmap, idx);
            }
        } else {
            BCM_IF_ERROR_RETURN(_bcm_th_qual_hint_bmp_get(unit, qual, 0, hint_node,
                                           qual_bitmap, 1, qset, NULL));
            if (*qual_bitmap) {
                hints_p = 1;
                *hints_present = 1;
            }

            if (hints_p == 0) {
                *hints_present = 0;
            }
        }
        hint_node = hint_node->next;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_field_th_qualify_set
 *
 * Purpose:
 *      Utility routine for qualify APIs taking 32 bits or less
 *
 * Parameters:
 *      unit - BCM device number
 *      entry - Entry ID
 *      qual  - Qualifier field
 *      data  - Matching data
 *      mask  - Bit mask for data
 *      flags - Qualifier Flags.
 * Returns:
 *     BCM_E_NONE     - BCM device number
 *     BCM_E_PARAM    - Qualifier not in group's Qset
 *     BCM_E_CONFIG   - entry is groups default entry
 */

int
_bcm_field_th_qualify_set(int unit, bcm_field_entry_t entry,
                          int qual, uint32 *data, uint32 *mask, uint8 flags)
{
    int                      rv;
    _bcm_field_qual_offset_t q_offset;
    _field_entry_t           *f_ent;
    _bcm_field_qual_data_t   out_data1;
    _bcm_field_qual_data_t   out_mask1;
    _bcm_field_qual_data_t   out_data2;
    _bcm_field_qual_data_t   out_mask2;
    _bcm_field_qual_data_t   actual_data;
    _bcm_field_qual_data_t   actual_mask;
    _bcm_field_qual_data_t   qual_bitmap;
    uint32                   start_offset = 0;
    int                      parts_cnt;
    int                      miss_count;
    int                      part_idx;
    int                      idx;
    int                      get_start_bit;
    int                      set_start_bit;
    uint16                   width;
    uint16                   total_width;
    uint8                    hints_present;
    _bcm_field_qual_data_t   null_data;
    uint16                   chunk_size[_BCM_FIELD_QUAL_OFFSET_MAX] = {0};
    uint16                   chunk_offset[_BCM_FIELD_QUAL_OFFSET_MAX] = {0};
    _field_stage_t           *stage_fc;

    /* Input Parameter Check. */
    if (NULL == data || NULL == mask) {
        return BCM_E_PARAM;
    }

    /* Retrieve the field entry. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    /* Currently this function handles qualifiers related to IFP,FT and EM */
    if ((f_ent->group->stage_id != _BCM_FIELD_STAGE_INGRESS) &&
        (f_ent->group->stage_id != _BCM_FIELD_STAGE_EXACTMATCH) &&
        (f_ent->group->stage_id != _BCM_FIELD_STAGE_FLOWTRACKER) &&
        (f_ent->group->stage_id != _BCM_FIELD_STAGE_AMFTFP)) {
        return BCM_E_INTERNAL;
    }

    /* Check if it is group default entry. */
    if (f_ent->flags & _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT) {
        return (BCM_E_CONFIG);
    }

    /* Retrieve group entry parts */
    rv = _bcm_field_th_entry_tcam_parts_count(unit, f_ent->group->flags,
                                                             &parts_cnt);
    BCM_IF_ERROR_RETURN(rv);

    /* Retreive stage control. */
    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    _FP_QUAL_DATA_CLEAR(actual_data);
    _FP_QUAL_DATA_CLEAR(actual_mask);

    /* Check if mask is full, do it only for exact match entries. */
    if (stage_fc->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        rv = _bcm_field_th_entry_check_full_mask(unit, qual,
                                             stage_fc, mask, flags);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Initialize q_offset to NULL */
    sal_memset(&q_offset, 0x0, sizeof(q_offset));
    _FP_QUAL_DATA_CLEAR(null_data);
    miss_count = 0;
    total_width = 0;
    hints_present = 0;
    get_start_bit = -1;
    set_start_bit = 0;
    width = 0;

    /* Update each chunk size of the qualifier. */
    for (part_idx = 0; part_idx < parts_cnt; ++part_idx) {
        /* Retrieve the Qualifier offsets for the particular entry part */
        rv = _bcm_field_th_qual_part_offset_get(unit, f_ent + part_idx,
                                                part_idx, qual, &q_offset);

        if (rv == BCM_E_NOT_FOUND) {
            continue;
        } else if (BCM_FAILURE(rv)) {
            return rv;
        }

        for (idx = 0; idx < _BCM_FIELD_QUAL_OFFSET_MAX; idx++) {
            if (q_offset.width[idx]) {
                chunk_size[idx] = q_offset.width[idx];
                total_width += chunk_size[idx];
            }
        }
    }

    _FP_QUAL_DATA_CLEAR(actual_data);
    _FP_QUAL_DATA_CLEAR(actual_mask);

    rv = _bcm_field_th_qual_hints_get(unit, qual, f_ent->group->hintid,
                                      &f_ent->group->qset,
                                      &hints_present, qual_bitmap);
    BCM_IF_ERROR_RETURN(rv);

    if (hints_present) {
        for (idx = 0; idx < _FP_QUAL_DATA_WORDS * 32; idx++) {
            if (SHR_BITGET(qual_bitmap, idx)) {
               if (-1 == get_start_bit) {
                  get_start_bit = idx;
               }
               width++;
            } else {
               if (-1 != get_start_bit) {

                  _FP_QUAL_DATA_CLEAR(out_data1);
                  _FP_QUAL_DATA_CLEAR(out_mask1);

                  rv = _bcm_field_qual_partial_data_get(data, get_start_bit,
                                                        width, out_data1);
                  BCM_IF_ERROR_RETURN(rv);

                  rv = _bcm_field_qual_partial_data_set(out_data1,
                                                        set_start_bit,
                                                        width, actual_data);
                  BCM_IF_ERROR_RETURN(rv);

                  rv = _bcm_field_qual_partial_data_get(mask, get_start_bit,
                                                        width, out_mask1);
                  BCM_IF_ERROR_RETURN(rv);

                  rv = _bcm_field_qual_partial_data_set(out_mask1,
                                                        set_start_bit,
                                                        width, actual_mask);
                  BCM_IF_ERROR_RETURN(rv);

                  set_start_bit += width;
                  get_start_bit = -1;
                  width = 0;
               }
            }
        }
    } else {
        rv = _bcm_field_qual_partial_data_set(data, 0,
                                              total_width, actual_data);
        BCM_IF_ERROR_RETURN(rv);

        rv = _bcm_field_qual_partial_data_set(mask, 0,
                                              total_width, actual_mask);
        BCM_IF_ERROR_RETURN(rv);
    }

    /* Update each chunk offset of the qualifier. offsets in q_offset
     * are local to the partition but chunk_offset array will have offsets
     * across the partitions.
     */
    for (idx = 0; idx < _BCM_FIELD_QUAL_OFFSET_MAX; idx++) {

        if (idx == 0) {
            chunk_offset[idx] = 0;
            continue;
        }

        if (chunk_size[idx]) {
           chunk_offset[idx] = chunk_offset[idx-1] + chunk_size[idx - 1];
        } else {
           break;
        }
    }

    for (part_idx = 0; part_idx < parts_cnt; ++part_idx) {
        /* Retrieve the Qualifier offsets for the particular entry part */
        rv = _bcm_field_th_qual_part_offset_get(unit, f_ent + part_idx,
                                                part_idx, qual, &q_offset);
        if (rv == BCM_E_NOT_FOUND) {
            miss_count += 1;
            continue;
        } else if (BCM_FAILURE(rv)) {
           return rv;
        }

        _FP_QUAL_DATA_CLEAR(out_data2);
        _FP_QUAL_DATA_CLEAR(out_mask2);

        start_offset = 0;

        /* Extract relevent data for this partion from user passed data. */
        for (idx = 0; idx < _BCM_FIELD_QUAL_OFFSET_MAX; idx++) {

            if (0 == q_offset.width[idx]) {
                continue;
            }

            _FP_QUAL_DATA_CLEAR(out_data1);
            _FP_QUAL_DATA_CLEAR(out_mask1);


            rv = _bcm_field_qual_partial_data_get(actual_data,
                                                  chunk_offset[idx],
                                                  q_offset.width[idx],
                                                  out_data1);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_qual_partial_data_set(out_data1, start_offset,
                                              q_offset.width[idx], out_data2);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_qual_partial_data_get(actual_mask,
                                                  chunk_offset[idx],
                                                  q_offset.width[idx],
                                                  out_mask1);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_qual_partial_data_set(out_mask1, start_offset,
                                              q_offset.width[idx], out_mask2);
            BCM_IF_ERROR_RETURN(rv);

            start_offset += q_offset.width[idx];

        }

        /* Program data/mask pair to tcam buffer. */
        /* coverity[callee_ptr_arith : FALSE] */
        rv = _bcm_field_qual_value_set(unit, &q_offset, f_ent + part_idx,
                                       out_data2, out_mask2);
        BCM_IF_ERROR_RETURN(rv);

    }

    /*
     * Verify whether qualifier offset is present in the qual Array.
     */
    if (miss_count == parts_cnt) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
              "Qualifier[%s] Offset not found for Entry:%d\n\r"),
               _field_qual_name(qual), entry));

        return BCM_E_NOT_FOUND;
    }

    f_ent->flags |= _FP_ENTRY_DIRTY;
    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_entry_qualifier_key_get
 *
 * Purpose:
 *     Get qualifier match value and mask.
 *
 * Parameters:
 *     unit      - BCM device number
 *     entry     - Entry id.
 *     qual_id   - qualifier id.
 *     q_data    - Qualifier data array.
 *     q_mask    - Qualifier mask array.
 * Returns:
 *     Nothing.
 */
int
_bcm_field_th_entry_qualifier_key_get(int unit,
                                      bcm_field_entry_t entry,
                                      int qual_id,
                                      _bcm_field_qual_data_t q_data,
                                      _bcm_field_qual_data_t q_mask)
{
    int     rv;         /* Operation return status.      */
    int     miss_count; /* Number of partitions having
                         * no offset info for qual_id.
                         */
    int     idx;        /* Temp variable used for indexing. */
    int     entry_parts; /* Number of TCAM partitions. */
    int     part_ct;     /* Varable to hold the current partiotion number. */
    int     get_start_bit = -1;
    int     set_start_bit = -1;
    uint8   hints_present = 0;
    uint16  total_width = 0;
    uint16  chunk_size[_BCM_FIELD_QUAL_OFFSET_MAX] = {0}; /* Size of all chunks
                                                   * of a qualifier distributed
                                               * across different partitions. */
    uint16  chunk_offset[_BCM_FIELD_QUAL_OFFSET_MAX] = {0}; /* offsets of all
                                               * chunks of a qualifier w.r.t
                                               * actual qualifier size. */
    uint32  width = 0;   /* Width of a qualifier in a partition. */

    uint32  start_offset = 0; /* Start offset for each chunk in a prtition*/
#if 0
    uint32  qual_width = 0; /* Actual width of qualifier in the shared chunk. */
    _field_stage_t  *stage_fc; /* Field stage operational structure. */
#endif
    _field_entry_t  *f_ent;      /* Field entry structure.        */
    _bcm_field_qual_data_t    part_data; /* Qualifier data in a partition. */
    _bcm_field_qual_data_t    part_mask; /* Qualifier mask in a partition. */
    _bcm_field_qual_data_t    chunk_data; /* Qual data of a particular chunk. */
    _bcm_field_qual_data_t    chunk_mask; /* Qual mask of a particular chunk. */
    _bcm_field_qual_data_t    actual_data;
    _bcm_field_qual_data_t    actual_mask;
    _bcm_field_qual_data_t    qual_bitmap;
    _bcm_field_qual_offset_t  q_offset; /* Qual offset in the tcam part. */

    /* Get entry part that contains requested qualifier. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    if ((f_ent->group->stage_id != _BCM_FIELD_STAGE_INGRESS) &&
        (f_ent->group->stage_id != _BCM_FIELD_STAGE_EXACTMATCH) &&
        (f_ent->group->stage_id != _BCM_FIELD_STAGE_FLOWTRACKER)) {
       return BCM_E_INTERNAL;
    }

    /* Get number of parts in field entry based on group flags. */
    rv = _bcm_field_th_entry_tcam_parts_count (unit, f_ent->group->flags,
                                               &entry_parts);
    BCM_IF_ERROR_RETURN(rv);

    /* Update each chunk size of the qualifier. */
    for (part_ct = 0; part_ct < entry_parts; ++part_ct) {

        sal_memset(&q_offset, 0, sizeof(_bcm_field_qual_offset_t));
        /* Retrieve the Qualifier offsets for the particular entry part */
        rv = _bcm_field_th_qual_part_offset_get(unit, f_ent + part_ct,
                                                part_ct, qual_id, &q_offset);

        if (rv == BCM_E_NOT_FOUND) {
            continue;
        } else if (BCM_FAILURE(rv)) {
           return rv;
        }

        for (idx = 0; idx < _BCM_FIELD_QUAL_OFFSET_MAX; idx++) {
             if (q_offset.width[idx]) {
                 chunk_size[idx] = q_offset.width[idx];
                 total_width += chunk_size[idx];
             }
        }
    }

    /* Update each chunk offset of the qualifier. offsets in q_offset
     * are local to the partition but chunk_offset array will have offsets
     * across the partitions.
     */
    for (idx = 0; idx < _BCM_FIELD_QUAL_OFFSET_MAX; idx++) {

        if (idx == 0) {
            chunk_offset[idx] = 0;
            continue;
        }

        if (chunk_size[idx]) {
           chunk_offset[idx] = chunk_offset[idx-1] + chunk_size[idx - 1];
        } else {
           break;
        }
    }

    miss_count = 0;
    _FP_QUAL_DATA_CLEAR(actual_data);
    _FP_QUAL_DATA_CLEAR(actual_mask);
    for (part_ct = 0; part_ct < entry_parts; part_ct++) {

        /* Initialize q_offset to NULL */
        sal_memset(&q_offset, 0x0, sizeof(q_offset));

        /* Retrieve the Qualifier offsets for the particular entry part */
        rv = _bcm_field_th_qual_part_offset_get(unit, f_ent, part_ct,
                                               qual_id, &q_offset);
        if (rv == BCM_E_NOT_FOUND) {
           miss_count += 1;
           continue;
        } else if (BCM_FAILURE(rv)) {
           return rv;
        }

        width = 0;
        _FP_QUAL_DATA_CLEAR(part_data);
        _FP_QUAL_DATA_CLEAR(part_mask);

        /* Combined width of a qualifier for a given part */
        _BCM_FIELD_QUAL_MULTI_OFFSET_WIDTH(&q_offset, width);
        if (width > 0) {
           /* Read qualifier match value and mask. */
           rv = _bcm_field_qual_value_get(unit, &q_offset, f_ent + part_ct,
                                          part_data, part_mask);
           BCM_IF_ERROR_RETURN(rv);
        } else {
           continue;
        }

        start_offset = 0;
        /* Extract relevent data for this partion from user passed data. */
        for (idx = 0; idx < _BCM_FIELD_QUAL_OFFSET_MAX; idx++) {

            if (0 == q_offset.width[idx]) {
                continue;
            }

            _FP_QUAL_DATA_CLEAR(chunk_data);
            _FP_QUAL_DATA_CLEAR(chunk_mask);


            rv = _bcm_field_qual_partial_data_get(part_data, start_offset,
                                               q_offset.width[idx], chunk_data);
            BCM_IF_ERROR_RETURN(rv);

            rv = _bcm_field_qual_partial_data_get(part_mask, start_offset,
                                               q_offset.width[idx], chunk_mask);
            BCM_IF_ERROR_RETURN(rv);

            /* Adjust Data and Mask based on the part offsets. */
            rv = _bcm_field_qual_partial_data_set(chunk_data, chunk_offset[idx],
                                              q_offset.width[idx], actual_data);
            BCM_IF_ERROR_RETURN(rv);
            rv = _bcm_field_qual_partial_data_set(chunk_mask, chunk_offset[idx],
                                              q_offset.width[idx], actual_mask);
            BCM_IF_ERROR_RETURN(rv);

            /* Increment the offset for the next part */
            start_offset += q_offset.width[idx];
        }
    }

    /*
     * Verify whether qualifier offset is present in the qual Array.
     */
    if (miss_count == entry_parts) {
        LOG_VERBOSE(BSL_LS_BCM_FP, (BSL_META_U(unit,
              "Qualifier[%s] Offset not found for Entry:%d\n\r"),
               _field_qual_name(qual_id), entry));

        return BCM_E_NOT_FOUND;
    }


    _FP_QUAL_DATA_CLEAR(q_data);
    _FP_QUAL_DATA_CLEAR(q_mask);

    rv = _bcm_field_th_qual_hints_get(unit, qual_id, f_ent->group->hintid,
                                      &f_ent->group->qset,
                                      &hints_present, qual_bitmap);
    BCM_IF_ERROR_RETURN(rv);

    width = 0;
    set_start_bit = -1;
    get_start_bit = 0;
    if (hints_present) {
        for (idx = 0; idx < _FP_QUAL_DATA_WORDS * 32; idx++) {
            if (SHR_BITGET(qual_bitmap, idx)) {
               if (-1 == set_start_bit) {
                  set_start_bit = idx;
               }

               width++;
            } else {
               if (-1 != set_start_bit) {

                  _FP_QUAL_DATA_CLEAR(part_data);
                  _FP_QUAL_DATA_CLEAR(part_mask);

                  rv = _bcm_field_qual_partial_data_get(actual_data,
                                                        get_start_bit,
                                                        width, part_data);
                  BCM_IF_ERROR_RETURN(rv);

                  rv = _bcm_field_qual_partial_data_set(part_data,
                                                        set_start_bit,
                                                        width, q_data);
                  BCM_IF_ERROR_RETURN(rv);

                  rv = _bcm_field_qual_partial_data_get(actual_mask,
                                                        get_start_bit,
                                                        width, part_mask);
                  BCM_IF_ERROR_RETURN(rv);

                  rv = _bcm_field_qual_partial_data_set(part_mask,
                                                        set_start_bit,
                                                        width, q_mask);
                  BCM_IF_ERROR_RETURN(rv);


                  get_start_bit += width;
                  set_start_bit = -1;
                  width = 0;
               }
            }
        }
    } else {
        sal_memcpy(q_data, actual_data, sizeof(actual_data));
        sal_memcpy(q_mask, actual_mask, sizeof(actual_mask));
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_field_th_qualifier_delete
 * Purpose:
 *      Remove match criteria from a field processor entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      qual_id - (IN) BCM field qualifier id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *   The assumption is that all qualifiers are less then 128 bit.
 */
int
_bcm_field_th_qualifier_delete(int unit, bcm_field_entry_t entry,
                               bcm_field_qualify_t qual_id)
{
    _bcm_field_qual_data_t    q_data;  /* Qualifier match data.     */
    _bcm_field_qual_data_t    q_mask;  /* Qualifier match mask.     */
    int rv = BCM_E_NONE;      /* Operation return status.  */
    _field_entry_t            *f_ent; /* Field Entry */

    sal_memset(q_data, 0, sizeof(_bcm_field_qual_data_t));
    sal_memset(q_mask, 0, sizeof(_bcm_field_qual_data_t));

    /* Retrieve the field entry. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    if ((BCM_FIELD_QSET_TEST(f_ent->group->qset, qual_id)) &&
        (_BCM_FIELD_IS_PBMP_QUALIFIER(qual_id))) {
        BCM_PBMP_CLEAR(f_ent->pbmp.data);
        BCM_PBMP_CLEAR(f_ent->pbmp.mask);
    }

    if (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE) {
       rv = _bcm_field_presel_qualify_set(unit, entry, qual_id,
                                          q_data, q_mask);

       if (qual_id == bcmFieldQualifyMixedSrcClassId) {
           rv = _bcm_field_th_qualifier_MixedSrcClassId_delete(unit, entry);
       }

    } else {
        if ((qual_id != bcmFieldQualifyExactMatchActionClassId) &&
            (qual_id != bcmFieldQualifyExactMatchHitStatus) &&
            (qual_id != bcmFieldQualifyExactMatchGroupClassId)) {
            rv = _bcm_field_th_qualify_set(unit, entry, qual_id,
                                                 q_data, q_mask,
                                                 _FP_QUALIFIER_DEL);
        } else {
            rv = _field_th_em_qualifier_set(unit, entry, qual_id,
                                                  q_data, q_mask);
        }
    }

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
              "Qualifier[%s] delete failed for Entry:%d (0x%x)\n\r"),
               _field_qual_name(qual_id), entry, entry));
    }
    return (rv);
}

/*
 * Function:
 *     _bcm_field_th_lt_tcam_data_mem_get
 *
 * Purpose:
 *     Retrieve Preselector tcam & data memories for a specific pipeline stage.
 *
 * Parameters:
 *     unit       -  (IN)  BCM device number.
 *     stage_fc   -  (IN)  Reference to Field Stage Control structure.
 *     instance   -  (IN)  Pipe Instance.
 *     mem_type   -  (IN)  Type of Memory (_BCM_FIELD_MEM_TYPE_xx).
 *     view_type  -  (IN)  Memory View type (_BCM_FIELD_MEM_VIEW_TYPE_xx).
 *     tcam_mem   -  (OUT) Reference to TCAM Memory id.
 *     data_mem   -  (OUT) Reference to DATA Memory id.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_lt_tcam_policy_mem_get(int unit, _field_stage_t *stage_fc,
                                     int instance, int mem_type, int view_type,
                                     soc_mem_t *tcam_mem, soc_mem_t *data_mem)
{
    soc_mem_t tcam_ptr, data_ptr, comb_ptr;

    /* Input parameters check. */
    if (NULL == stage_fc) {
        return (BCM_E_PARAM);
    }

    if ((((view_type & _BCM_FIELD_MEM_VIEW_TYPE_TCAM) ||
          (view_type & _BCM_FIELD_MEM_VIEW_TYPE_TCAM_DATA_COMB)) &&
         (tcam_mem == NULL)) ||
        ((view_type & _BCM_FIELD_MEM_VIEW_TYPE_DATA) &&
         (data_mem == NULL))) {
        return (BCM_E_PARAM);
    }

    /* Validate instance */
    if ((instance < 0) || (instance >= _FP_MAX_NUM_PIPES)) {
        return (BCM_E_PARAM);
    }

    if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
       instance = _FP_GLOBAL_INST;
    }

    switch (mem_type) {
       case _BCM_FIELD_MEM_TYPE_IFP_LT:
            if (stage_fc->stage_id != _BCM_FIELD_STAGE_INGRESS) {
               return BCM_E_PARAM;
            }
            BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                            IFP_LOGICAL_TABLE_SELECT_TCAM_ONLYm,
                                            instance, &tcam_ptr));
            BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                            IFP_LOGICAL_TABLE_SELECT_DATA_ONLYm,
                                            instance, &data_ptr));
            BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                            IFP_LOGICAL_TABLE_SELECTm,
                                            instance, &comb_ptr));

            break;

       case _BCM_FIELD_MEM_TYPE_EM_LT:
            if (stage_fc->stage_id != _BCM_FIELD_STAGE_EXACTMATCH) {
               return BCM_E_PARAM;
            }
            BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                    EXACT_MATCH_LOGICAL_TABLE_SELECT_TCAM_ONLYm,
                                    instance, &tcam_ptr));
            BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                    EXACT_MATCH_LOGICAL_TABLE_SELECT_DATA_ONLYm,
                                    instance, &data_ptr));
            BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                    EXACT_MATCH_LOGICAL_TABLE_SELECTm,
                                    instance, &comb_ptr));
            break;

#if defined(BCM_FLOWTRACKER_SUPPORT)
        case _BCM_FIELD_MEM_TYPE_FT_LT:
            if (stage_fc->stage_id != _BCM_FIELD_STAGE_FLOWTRACKER) {
                return BCM_E_PARAM;
            }
            /* Only global mode is supported */
            tcam_ptr = BSK_FTFP_LTS_LOGICAL_TBL_SEL_TCAMm;
            data_ptr = BSK_FTFP_LTS_LOGICAL_TBL_SEL_SRAMm;
            comb_ptr = INVALIDm;
            break;
#endif
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
        case _BCM_FIELD_MEM_TYPE_FT_LT_I(1):
            if (stage_fc->stage_id != _BCM_FIELD_STAGE_FLOWTRACKER) {
                return BCM_E_PARAM;
            }
            /* Only global mode is supported */
            tcam_ptr = BSK_FTFP2_LTS_LOGICAL_TBL_SEL_TCAMm;
            data_ptr = BSK_FTFP2_LTS_LOGICAL_TBL_SEL_SRAMm;
            comb_ptr = INVALIDm;
            break;
#endif

       default:
            return BCM_E_PARAM;
    }
    switch (view_type) {
       case _BCM_FIELD_MEM_VIEW_TYPE_TCAM:
           *tcam_mem = tcam_ptr;
           break;
       case _BCM_FIELD_MEM_VIEW_TYPE_DATA:
           *data_mem = data_ptr;
           break;
       case (_BCM_FIELD_MEM_VIEW_TYPE_TCAM |
             _BCM_FIELD_MEM_VIEW_TYPE_DATA):
           *tcam_mem = tcam_ptr;
           *data_mem = data_ptr;
         break;
       case _BCM_FIELD_MEM_VIEW_TYPE_TCAM_DATA_COMB:
           *tcam_mem = comb_ptr;
           break;
       default:
           return (BCM_E_PARAM);
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _field_th_write_slice_map_vfp
 *
 * Purpose:
 *     Write the VFP_SLICE_MAP (Lookup) or EFP_SLICE_MAP (Egress)
 *
 * Parameters:
 *     unit     - Device number.
 *     stage_fc - pointer to stage control block.
 *     fg       - Field Group Structure.
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_field_th_write_slice_map_vfp_efp(int unit,
                                  _field_stage_t *stage_fc,
                                  _field_group_t *fg)
{
    soc_reg_t reg;                   /* HW Register.             */
    soc_field_t field;               /* HW entry fields.         */
    uint32 map_entry;                /* HW entry buffer.         */
    int vmap_size;                   /* Virtual map index count. */
    uint32 value;                    /* Field entry value.       */
    int idx;                         /* Map fields iterator.     */
    int rv;                          /* Operation return status. */
    int inst;                        /* Pipe Instance.           */


    /* Input parameters check. */
    if (NULL == stage_fc || NULL == fg) {
        return (BCM_E_PARAM);
    }

    if ((stage_fc->stage_id != _BCM_FIELD_STAGE_LOOKUP) &&
        (stage_fc->stage_id != _BCM_FIELD_STAGE_EGRESS)) {
        return BCM_E_PARAM;
    }

    /* Calculate virtual map size. */
    rv = _bcm_field_virtual_map_size_get(unit, stage_fc, &vmap_size);
    BCM_IF_ERROR_RETURN(rv);

    if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
        inst = _FP_GLOBAL_INST;
    } else {
        inst = fg->instance;
    }

    if ((stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP)) {
         BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                            VFP_SLICE_MAPr,
                                                            inst, &reg));
    } else {
         BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                            EFP_SLICE_MAPr,
                                                            inst, &reg));
    }

    inst = fg->instance;

    rv = soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &map_entry);
    BCM_IF_ERROR_RETURN(rv);

    for (idx = 0; idx < vmap_size; idx++) {
        value = (stage_fc->vmap[inst][_FP_VMAP_DEFAULT][idx]).vmap_key;
        field = vfp_efp_virtual_to_physical_map[idx];
        soc_reg_field_set(unit, reg, &map_entry, field, value);

        value = (stage_fc->vmap[inst][_FP_VMAP_DEFAULT][idx]).virtual_group;
        field = vfp_efp_virtual_to_group_map[idx];
        soc_reg_field_set(unit, reg, &map_entry, field, value);
    }

    rv = soc_reg32_set(unit, reg, REG_PORT_ANY, 0, map_entry);
    BCM_IF_ERROR_RETURN(rv);

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_write_slice_map
 * Purpose:
 *     Write EFP_SLICE_MAP, VFP_SLICE_MAP for egress and lookup stages.
 * Parameters:
 *     unit       - (IN) BCM device number
 *     stage_fc   - (IN) stage control structure
 *     fg         - (IN) reference to field group structure.
 * Returns:
 *     BCM_E_XXX
 */

int
_bcm_field_th_write_slice_map(int unit,
                              _field_stage_t *stage_fc,
                              _field_group_t *fg)
{
    switch (stage_fc->stage_id) {
        case _BCM_FIELD_STAGE_LOOKUP:
        case _BCM_FIELD_STAGE_EGRESS:
            return (_field_th_write_slice_map_vfp_efp(unit, stage_fc, fg));

        default:
            ;
    }

    return (BCM_E_INTERNAL);
}

/*
 * Function:
 *      _field_th_qset_comb_set
 * Purpose:
 *      set combination for qset array
 * Parameters:
 *      unit   - (IN)    Unit number.
 *      arr    - (IN)    Qual data array
 *      start  - (IN)    Start index of iteration
 *      end    - (IN)    End index of iteration
 *      index  - (IN)    Last member index
 *      range  - (IN)    Combination Range
 *      fc     - (IN) field_control to accesss qset_comb
 * Returns:
 *      BCM_E_***
 * Notes:
 */
/* keep track qset_comb index */
static uint32 qset_count ;

void _field_th_qset_comb_set(int arr[], int data[], int start,
                             int end,   int index,  int range,
                             _field_control_t *fc)
{
    int qual_index, comb_index;

    if (index == range)
    {
        fc->extd_qset_comb[qset_count][0] = 0;

        for (qual_index = 0; qual_index < range; qual_index++) {
            fc->extd_qset_comb[qset_count][0]++;
            fc->extd_qset_comb[qset_count][qual_index+1]
                                = data[qual_index];
        }

        qset_count++;
    }

    /* replace index with all possible elements. */
    for (comb_index=start;
         comb_index<=end && end-comb_index+1 >= range-index; comb_index++)
    {
        data[index] = arr[comb_index];
        _field_th_qset_comb_set(arr, data, comb_index+1,
                                end, index+1, range, fc);
    }
}

/*
 * Function:
 *      _field_th_qset_comb_init
 * Purpose:
 *      initialize qset combination array
 * Parameters:
 *      unit   - (IN)    Unit number.
 *      fc     - (INOUT) field_control
 * Returns:
 *      BCM_E_***
 * Notes:
 */

int
_field_th_qset_comb_init(int unit, _field_control_t *fc)
{

    int qual_data_arr[] =
            {_bcmFieldQualifyData0, _bcmFieldQualifyData1,
             _bcmFieldQualifyData2, _bcmFieldQualifyData3,
             _bcmFieldQualifyData4, _bcmFieldQualifyData5,
             _bcmFieldQualifyData6, _bcmFieldQualifyData7,
             _bcmFieldQualifyData8, _bcmFieldQualifyData9};
    int temp_store_data[COUNTOF(qual_data_arr)];
    int range, max_range, array_size;

    qset_count = 0;
    max_range  = COUNTOF(fc->extd_qset_comb[0]) - 1;
    array_size = COUNTOF(qual_data_arr);
    sal_memset(fc->extd_qset_comb, -1, sizeof(fc->extd_qset_comb));

    for (range = 1; range <= max_range; range++) {
        /* Program all combination using qual_data_arr[] */
        _field_th_qset_comb_set(
                        qual_data_arr, temp_store_data,
                        0, array_size - 1,
                        0, range, fc);
    }

    fc->extd_qset_comb_init = 1;

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_field_th_udf_chunks_to_int_qset
 * Purpose:
 *      Sets internal data qualifiers corrspeonding to the
 *      offset chunks used by the UDF.
 * Parameters:
 *      unit                - (IN)  Unit number.
 *      udf_chunks_bmap     - (IN)  UDF offsets chunks map
 *      qset                - (OUT) Qualifier set
 * Returns:
 *      BCM_E_NONE
 * Notes:
 */
int
_bcm_field_th_udf_chunks_to_int_qset(int unit, uint32 udf_chunks_bmap,
                                      bcm_field_qset_t *qset)
{
    int idx, max_chunks = 0;

    max_chunks = BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit);


    for (idx = 0; idx < max_chunks; idx++) {
        if(udf_chunks_bmap & (1 << idx)) {
            if (idx == 0) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData0);
            }
            if (idx == 1) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData1);
            }
            if (idx == 2 || idx == 3) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
            }
            if (idx == 4 || idx == 5) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData3);
            }
            if (idx == 6 || idx == 7) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData4);
            }
            if (idx == 8) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData5);
            }
            if (idx == 9) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData6);
            }
            if (idx == 0xa || idx == 0xb) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData7);
            }
            if (idx == 0xc || idx == 0xd) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData8);
            }
            if (idx == 0xe || idx == 0xf) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData9);
            }
        }
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_field_th_qset_udf_offsets_alloc
 * Purpose:
 *      Allocates offset chunks based on the INPUT qset.
 * Parameters:
 *      unit          - (IN)  Unit number.
 *      stage         - (IN)  Field Group Stage.
 *      qset          - (IN)  Qualifier set.
 *      req_offsets   - (IN)  Number of chunks to be allocated.
 *      offset_array  - (OUT) Offset chunks in the order of availability.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_field_th_qset_udf_offsets_alloc(int unit, _field_stage_id_t stage,
     bcm_field_qset_t qset, int req_offsets, int offset_array[], int *max_chunks,
     int pipe_num)
{
    int group_flags[5] =  {
            /* SINGLE */
            (_FP_GROUP_SPAN_SINGLE_SLICE),
            /* DOUBLE_INTRA */
            (_FP_GROUP_SPAN_SINGLE_SLICE | _FP_GROUP_INTRASLICE_DOUBLEWIDE),
            /* DOUBLE */
            (_FP_GROUP_SPAN_DOUBLE_SLICE),
            /* QUAD_INTRA */
            (_FP_GROUP_SPAN_DOUBLE_SLICE | _FP_GROUP_INTRASLICE_DOUBLEWIDE),
            /* TRIPLE */
            (_FP_GROUP_SPAN_TRIPLE_SLICE)
        };

    int i, j;
    int qid;
    int qual_count;
    int rv = BCM_E_NONE;
    int num_chunks = 0;
    _field_group_t fg;
    bcm_field_qset_t qset_test;
    int idx;

    uint32 qset_comb_count;

    _field_control_t *fc = NULL;
    _field_group_add_fsm_t fsm_ptr;
    _field_stage_t *stage_fc; /* Stage Field control structure*/

    BCM_IF_ERROR_RETURN(
            _field_control_get(unit,  &fc));

    if (fc->extd_qset_comb_init != 1) {
        BCM_IF_ERROR_RETURN(_field_th_qset_comb_init(unit, fc));
    }

    qset_comb_count =  COUNTOF(fc->extd_qset_comb);

    /* Initialize group creation tracking structure. */
    sal_memset(&fg, 0, sizeof(fg));

    fg.stage_id = stage;

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, fg.stage_id,
        &stage_fc));

    for (i = 0; i < COUNTOF(group_flags); i++) {

        /* TD_TT family  support intra_double mode group only in VFP */
        if (soc_feature(unit, soc_feature_field_intraslice_double_wide)) {
            if (((i == 1) || (i == 4)) && (stage != _BCM_FIELD_STAGE_LOOKUP)) {
                continue;
            }
        }

        if ((soc_feature(unit, soc_feature_ifp_no_narrow_mode_support)) && (i == 0)) {
            continue;
        }
        if ((stage == _BCM_FIELD_STAGE_INGRESS) ||
            (stage == _BCM_FIELD_STAGE_EXACTMATCH)) {
            /* Skip quad mode for ingress and EM */
            if ( i == 3)  {
                continue;
            }
        }

        fg.flags = group_flags[i];

        for (j = 0; j < qset_comb_count; j++) {

            num_chunks = 0;
            qual_count = fc->extd_qset_comb[j][0];

            sal_memcpy(&qset_test, &qset, sizeof(bcm_field_qset_t));

            for (qid = 0; qid < qual_count; qid++) {
                BCM_FIELD_QSET_ADD_INTERNAL(qset_test, fc->extd_qset_comb[j][1 + qid]);
            }
            if (BCM_FIELD_QSET_TEST(qset_test, bcmFieldQualifyStageLookup) ||
                (_BCM_FIELD_STAGE_LOOKUP == stage)) {
                rv = _field_selcode_assign(unit, qset_test, 1, &fg);
            } else if
            (BCM_FIELD_QSET_TEST(qset_test, bcmFieldQualifyStageIngress) ||
            !(BCM_FIELD_QSET_TEST(qset_test, bcmFieldQualifyStageLookup)) ||
            BCM_FIELD_QSET_TEST(qset_test, bcmFieldQualifyStageEgress) ||
            BCM_FIELD_QSET_TEST(qset_test, bcmFieldQualifyStageClass) ||
            BCM_FIELD_QSET_TEST(qset_test, bcmFieldQualifyStageClassExactMatch) ||
            BCM_FIELD_QSET_TEST(qset_test, bcmFieldQualifyStageIngressExactMatch)) {
                sal_memset(&fsm_ptr, 0, sizeof(_field_group_add_fsm_t));
                fsm_ptr.fg = &fg;
                fsm_ptr.fc = fc;
                fsm_ptr.stage_fc = stage_fc;
                fg.qset = qset_test;
                fsm_ptr.flags |= _FP_GROUP_CONFIG_VALIDATE;
                rv = _field_th_ext_code_assign(unit, 1, &fsm_ptr);
            } else {
                return BCM_E_PARAM;
            }

            if (BCM_SUCCESS(rv)) {

                for (qid = 0; qid < qual_count; qid++) {
                    rv = _bcm_esw_field_qual_udf_offsets_get(unit,
                                     fc->extd_qset_comb[j][1 + qid], &fg,
                                     offset_array+num_chunks, &num_chunks,
                                     pipe_num);
                    if (BCM_FAILURE(rv)) {
                        if (BCM_FIELD_QSET_TEST(qset_test, bcmFieldQualifyStageLookup)) {
                            for (idx = 0; idx < _FP_MAX_ENTRY_WIDTH; idx++) {
                                BCM_IF_ERROR_RETURN(_bcm_field_group_qualifiers_free(&fg, idx));
                            }
                        }
                        return rv;
                    }
                }

                if (num_chunks >= req_offsets) {
                    break;
                }
            }
        }
        if (num_chunks >= req_offsets) {
            break;
        }
    }

#if 0
    if (BCM_FIELD_QSET_TEST(qset_test, bcmFieldQualifyStageLookup)) {
        for (idx = 0; idx < _FP_MAX_ENTRY_WIDTH; idx++) {
            BCM_IF_ERROR_RETURN(_bcm_field_group_qualifiers_free(&fg, idx));
        }
    }
#endif

    /* The UDF offset allocation to suit in an fp group
     * that consists of the user specified qset is not possible */
    if (num_chunks < req_offsets) {
        return BCM_E_RESOURCE;
    }

    *max_chunks = num_chunks;

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_field_th_qual_udf_offsets_get
 * Purpose:
 *      Gets list of udf id objects in a qset
 * Parameters:
 *      unit          - (IN)  Unit number.
 *      qid           - (IN)  Internal Data qualifier.
 *      chunk_order   - (IN)  Offset chunks in the order of availability.
 *      num_chunks    - (OUT) Number of chunks.
 * Returns:
 *      BCM_E_NONE
 * Notes:
 */
int
_bcm_field_th_qual_udf_offsets_get(int unit, int qid,
                                   int chunk_order[], int *num_chunks,
                                   uint32 hw_bmap)
{
    int idx;
    int alloc_count = 0;

    int max_chunks = BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit);

    _field_control_t *fc;

    BCM_IF_ERROR_RETURN(
            _field_control_get(unit,  &fc));


    for (idx = 0; idx < max_chunks; idx++) {
        /* coverity[ptr_arith] */
        if (SHR_BITGET(&hw_bmap, idx)) {
            continue;
        }


        if (((qid == _bcmFieldQualifyData0) && (idx == 0)) ||
            ((qid == _bcmFieldQualifyData1) && (idx == 1)) ||
            ((qid == _bcmFieldQualifyData2) && ((idx == 2) || (idx == 3))) ||
            ((qid == _bcmFieldQualifyData3) && ((idx == 4) || (idx == 5))) ||
            ((qid == _bcmFieldQualifyData4) && ((idx == 6) || (idx == 7))) ||
            ((qid == _bcmFieldQualifyData5) && ((idx == 8))) ||
            ((qid == _bcmFieldQualifyData6) && ((idx == 9))) ||
            ((qid == _bcmFieldQualifyData7) && ((idx == 0xa) || (idx == 0xb))) ||
            ((qid == _bcmFieldQualifyData8) && ((idx == 0xc) || (idx == 0xd))) ||
            ((qid == _bcmFieldQualifyData9) && ((idx == 0xe) || (idx == 0xf)))) {

                chunk_order[alloc_count] = idx;
                alloc_count++;

                if ((*num_chunks + alloc_count) >= max_chunks) {
                    break;
                }
            }
        }

    *num_chunks += alloc_count;

    return BCM_E_NONE;
}


/*
 * Function:
 *      _bcm_field_th_qualify_udf_data_elem_get
 * Purpose:
 *       get qualifier id based on udf chunk index
 * Parameters:
 *      unit       - (IN)  Unit number.
 *      idx        - (IN)  Index of UDF chunk
 *      max_chunks - (IN)  Total number of UDF chunk
 *      qid        - (INOUT)  Qualifier ID
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_field_th_qualify_udf_data_elem_get(int unit, int idx,
                                        int max_chunks,
                                        int *qid)
{
    if ((idx >= 0) && (idx < max_chunks)) {
        if (idx == 0) {
            *qid = _bcmFieldQualifyData0;
        }
        if (idx == 1) {
            *qid = _bcmFieldQualifyData1;
        }
        if (idx == 2 || idx == 3) {
            *qid = _bcmFieldQualifyData2;
        }
        if (idx == 4 || idx == 5) {
            *qid = _bcmFieldQualifyData3;
        }
        if (idx == 6 || idx == 7) {
            *qid = _bcmFieldQualifyData4;
        }
        if (idx == 8) {
            *qid = _bcmFieldQualifyData5;
        }
        if (idx == 9) {
            *qid = _bcmFieldQualifyData6;
        }
        if (idx == 0xa || idx == 0xb) {
            *qid = _bcmFieldQualifyData7;
        }
        if (idx == 0xc || idx == 0xd) {
            *qid = _bcmFieldQualifyData8;
        }
        if (idx == 0xe || idx == 0xf) {
            *qid = _bcmFieldQualifyData9;
        }
        return BCM_E_NONE;
    } else {
        return BCM_E_PARAM;
    }
}

/*
 * Function:
 *      bcm_field_th_qualify_udf_get
 * Purpose:
 *      Qualify the field entry with data/mask corresponding to an offset chunk.
 * Parameters:
 *      unit            - (IN)  Unit number.
 *      eid             - (IN)  Field Entry.
 *      udf_id          - (IN)  UDF ID.
 *      max_length      - (IN)  Length of bytes of data/mask to fetch.
 *      data            - (OUT) Data to qualify the entry.
 *      mask            - (OUT  Mask to qualify the entry.
 *      actual_length   - (OUT) Length of bytes of data/mask fetched.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcmi_field_th_qualify_udf_get(int unit, bcm_field_entry_t eid,
                              bcm_udf_id_t udf_id, int max_length,
                              uint8 *data, uint8 *mask, int *actual_length)
{
    _field_stage_t          *stage_fc;          /* Stage field control.       */
    _field_entry_t          *f_ent = NULL;
    _field_group_t          *fg;
    bcm_field_qset_t        *qset;
    _bcm_field_udf_data_t   q_data;
    _bcm_field_udf_data_t   q_mask;
    uint32 local_data, local_mask;
    bcmi_xgs4_udf_offset_info_t *offset_info = NULL;   /* UDF offset info.   */
    uint8 *p_data = (uint8 *) &q_data;  /* qualifier data pointer */
    uint8 *p_mask = (uint8 *) &q_mask;  /* qualifier mask pointer */
    uint8 *p_local_data = (uint8 *) &local_data;  /* 32bit qualifier data pointer      */
    uint8 *p_local_mask = (uint8 *) &local_mask;  /* 32bit qualifier mask pointer      */
    int  num_elems = 0;
    int  qid = 0, qual_index = 0;
    int  iter_idx = 0, hw_idx = 0;    /* HW bitmap iteration index. */
    int  rv;                          /* Operation return status.   */
    int  copy_mem = 0, shift = 2, num_qual = 0;
    int  copy_len;
    int  len = 0;
    int  offset_2_3 = 0;  /* HW offset 0 and 1 usage status. */
    int  offset_4_5 = 0;  /* HW offset 2 and 3 usage status. */
    int  offset_6_7 = 0;  /* HW offset 4 and 5 usage status. */
    int  offset_a_b = 0;  /* HW offset 8 and 9 usage status. */
    int  offset_c_d = 0;  /* HW offset a and b usage status. */
    int  offset_e_f = 0;  /* HW offset c and d usage status. */

#ifdef LE_HOST
    uint32 data_swap, mask_swap;
#endif /* LE_HOST */


    FP_LOCK(unit);
    UDF_LOCK(unit);

    /* Get UDF info. */
    rv = bcmi_xgs4_udf_offset_node_get(unit, udf_id,  &offset_info);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        UDF_UNLOCK(unit);
        return (rv);
    }

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        UDF_UNLOCK(unit);
        return (rv);
    }

    rv = _bcm_field_entry_get_by_id(unit, eid, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        UDF_UNLOCK(unit);
        return (rv);
    }

    /* Get field group */
    fg = f_ent->group;

    num_elems = BCMI_XGS4_UDF_CTRL_MAX_UDF_CHUNKS(unit);

    /* get qset */
    qset = &(fg->qset);

    for (qual_index = _bcmFieldQualifyData0;
         qual_index < _bcmFieldQualifyCount; qual_index++) {

        num_qual = 1;

        if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, qual_index) &&
            qual_index == _bcmFieldQualifyData0) {
            if (SHR_BITGET(qset->udf_map, 0x0)) {
                qid = _bcmFieldQualifyData0;
                hw_idx   = 0x0;
                copy_mem = 1;
            }
        }
        else if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, qual_index) &&
            qual_index == _bcmFieldQualifyData1) {
            if (SHR_BITGET(qset->udf_map, 0x1)) {
                qid = _bcmFieldQualifyData1;
                hw_idx   = 0x1;
                copy_mem = 1;
            }
        }
        else if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, qual_index) &&
            qual_index == _bcmFieldQualifyData5) {
            if (SHR_BITGET(qset->udf_map, 0x8)) {
                qid = _bcmFieldQualifyData5;
                hw_idx   = 0x8;
                copy_mem = 1;
            }
        }
        else if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, qual_index) &&
            qual_index == _bcmFieldQualifyData6) {
            if (SHR_BITGET(qset->udf_map, 0x9)) {
                qid = _bcmFieldQualifyData6;
                hw_idx   = 0x9;
                copy_mem = 1;
            }
        }
        else if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, qual_index) &&
            qual_index == _bcmFieldQualifyData2) {
            SHR_BITTEST_RANGE(qset->udf_map, 0x2, 2, offset_2_3);
            if (offset_2_3) {
                num_qual = 2;
                qid = _bcmFieldQualifyData2;
                hw_idx   = 0x2;
                copy_mem = 1;
            }
        }
        else if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, qual_index) &&
            qual_index == _bcmFieldQualifyData3) {
            SHR_BITTEST_RANGE(qset->udf_map, 0x4, 2, offset_4_5);
            if (offset_4_5) {
                num_qual = 2;
                qid = _bcmFieldQualifyData3;
                hw_idx   = 0x4;
                copy_mem = 1;
            }
        }
        else if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, qual_index) &&
            qual_index == _bcmFieldQualifyData4) {
            SHR_BITTEST_RANGE(qset->udf_map, 0x6, 2, offset_6_7);
            if (offset_6_7) {
                num_qual = 2;
                qid = _bcmFieldQualifyData4;
                hw_idx   = 0x6;
                copy_mem = 1;
            }
        }
        else if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, qual_index) &&
            qual_index == _bcmFieldQualifyData7) {
            SHR_BITTEST_RANGE(qset->udf_map, 0xa, 2, offset_a_b);
            if (offset_a_b) {
                num_qual = 2;
                qid = _bcmFieldQualifyData7;
                hw_idx   = 0xa;
                copy_mem = 1;
            }
        }
        else if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, qual_index) &&
            qual_index == _bcmFieldQualifyData8) {
            SHR_BITTEST_RANGE(qset->udf_map, 0xc, 2, offset_c_d);
            if (offset_c_d) {
                num_qual = 2;
                qid = _bcmFieldQualifyData8;
                hw_idx   = 0xc;
                copy_mem = 1;
            }
        }
        else if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, qual_index) &&
            qual_index == _bcmFieldQualifyData9) {
            SHR_BITTEST_RANGE(qset->udf_map, 0xe, 2, offset_e_f);
            if (offset_e_f) {
                num_qual = 2;
                qid = _bcmFieldQualifyData9;
                hw_idx   = 0xe;
                copy_mem = 1;
            }
        } else {
            hw_idx = 0;
            num_qual = 0;
        }

        if (copy_mem == 1) {
            _bcm_field_entry_qualifier_uint32_get(unit, eid, qid, &local_data, &local_mask);
        }


#ifdef LE_HOST
        data_swap = _shr_swap32(local_data);
        local_data = data_swap;

        mask_swap = _shr_swap32(local_mask);
        local_mask = mask_swap;

#endif /* LE_HOST */

        /* Copy the data and mask */
        if ((hw_idx < num_elems) && (copy_mem) &&
            (len < offset_info->width)) {

            for (iter_idx = 0; iter_idx < num_qual; iter_idx++) {
                if (!(offset_info->hw_bmap & (1 << hw_idx))) {
                    continue;
                }

                copy_len = ((offset_info->width - len) == 1)? 1 : 2;

                if (len == 0) {
                    sal_memcpy((p_data + len), p_local_data + offset_info->byte_offset, copy_len);
                    sal_memcpy((p_mask + len), p_local_mask + offset_info->byte_offset, copy_len);
                }
                else if ((num_qual == 1) || (iter_idx %2 == 0)) {
                    sal_memcpy((p_data + len), p_local_data, copy_len);
                    sal_memcpy((p_mask + len), p_local_mask, copy_len);
                } else {
                    sal_memcpy((p_data + len), p_local_data + shift, copy_len);
                    sal_memcpy((p_mask + len), p_local_mask + shift, copy_len);
                }

                len+= copy_len;
                hw_idx++;
            }
        }
        copy_mem = 0;

    } /* end of qual_index++ */

    sal_memcpy(data, p_data, offset_info->width);
    sal_memcpy(mask, p_mask, offset_info->width);

    *actual_length = offset_info->width;

    FP_UNLOCK(unit);
    UDF_UNLOCK(unit);

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_field_th_qualify_LoopbackType
 * Purpose:
 *      Encode the loopback type qualified for Stage Egress
 * Parameters:
 *      unit  - (IN) BCM device number
 *      loopback_type - (IN) Loopback Type
 *      tcam_data     - (OUT) Qualifier data
 *      tcam_mask     - (OUT) Qualifier mask
 * Returns:
 *      BCM_E_XXX
 */
int _bcm_field_th_qualify_LoopbackType(
        int                      unit,
        bcm_field_LoopbackType_t loopback_type,
        uint32                   *tcam_data,
        uint32                   *tcam_mask)
{
    switch (loopback_type) {
        case bcmFieldLoopbackTypeAny:
            *tcam_data = 0x10;
            *tcam_mask = 0x10;
            break;
        case bcmFieldLoopbackTypeTunnelAny:
            *tcam_data = 0x10;
            *tcam_mask = 0x1f;
            break;
        case bcmFieldLoopbackTypeTrillNetwork:
            *tcam_data = 0x11;
            *tcam_mask = 0x1f;
            break;
        case bcmFieldLoopbackTypeTrillAccess:
            *tcam_data = 0x12;
            *tcam_mask = 0x1f;
            break;
        case bcmFieldLoopbackTypeMasquerade:
            *tcam_data = 0x13;
            *tcam_mask = 0x1f;
            break;
        default:
            return (BCM_E_PARAM);
    }

    return (BCM_E_NONE);

}

/*
 * Function:
 *      _bcm_field_th_qualify_LoopbackType_get
 * Purpose:
 *      Decode the loopback type qualified in Stage Egress
 * Parameters:
 *      unit  - (IN) BCM device number
 *      tcam_data     - (IN) Qualifier data
 *      tcam_mask     - (IN) Qualifier mask
 *      loopback_type - (OUT) Loopback Type
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_th_qualify_LoopbackType_get(
            uint8                    tcam_data,
            uint8                    tcam_mask,
            bcm_field_LoopbackType_t *loopback_type)
{
    switch (tcam_data & tcam_mask) {
        case 0x10:
            if (tcam_mask == 0x10) {
                *loopback_type = bcmFieldLoopbackTypeAny;
            } else {
                *loopback_type = bcmFieldLoopbackTypeTunnelAny;
            }
            break;
        case 0x11:
            *loopback_type = bcmFieldLoopbackTypeTrillNetwork;
            break;
        case 0x12:
            *loopback_type = bcmFieldLoopbackTypeTrillAccess;
            break;
        case 0x13:
            *loopback_type = bcmFieldLoopbackTypeMasquerade;
            break;
        default:
            return (BCM_E_PARAM);
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *     _bcm_field_th_entry_tcam_index_get
 *
 * Purpose:
 *     Retrieve Field group entry's assigned TCAM index.
 *
 * Parameters:
 *     unit              - (IN)  BCM device number
 *     eid               - (IN)  Field entry ID.
 *     logical_tcam_idx  - (OUT) Reference to Entry's logical tcam index.
 *     physical_tcam_idx - (OUT) Reference to Entry's Physical tcam index.
 *
 * Returns:
 *     BCM_E_xx
 *
 * Note:
 *     In-case of IFP_TCAM narrow mode, the logical index is the free TCAM index
 *     assigned to the entry during creation and the physical index is the
 *     mapped HW index where the entry is actually written on priority basis.
 *     For wide mode TCAMs, the logical and physical indices are same.
 */

int _bcm_field_th_entry_tcam_index_get(int unit, bcm_field_entry_t eid,
                                       int *logical_tcam_idx,
                                       int *physical_tcam_idx)
{
    int                 rv;
    _field_entry_t      *f_ent;
    soc_mem_t           mem = INVALIDm;

    if (logical_tcam_idx == NULL || physical_tcam_idx == NULL) {
       return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_get_by_id(unit, eid, &f_ent));

    *logical_tcam_idx = *physical_tcam_idx = f_ent->slice_idx;

    if ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) &&
        ((f_ent->group->flags & _FP_GROUP_SPAN_SINGLE_SLICE) &&
         !(f_ent->group->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE))) {
        mem = IFP_TCAMm;
    } else {
        return BCM_E_NONE;
    }

    rv = soc_mem_field_nw_tcam_prio_order_index_get(unit, mem,
                                                    physical_tcam_idx);
    if (SOC_FAILURE(rv)) {
       return BCM_E_INTERNAL;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_field_th_ifp_slice_mode_get
 * Purpose:
 *      Retrieve the slice TCAM mode and enable status.
 * Parameters:
 *      unit       - (IN) BCM Device number.
 *      pipe       - (IN) Pipe Instance. (pipe < 0 indicates Global.)
 *      slice_num  - (IN) IFP TCAM Slice number.
 *      slice_mode - (OUT) IFP TCAM mode.
 *      slice_enabled - (OUT) Whether the slice is enabled.
 *
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_th_ifp_slice_mode_get(int unit, int pipe, int slice_num,
                                 int *slice_mode, int *slice_enabled)
{
   _field_slice_t  *fs = NULL;
   _field_stage_t  *stage_fc;
   int              inst;
   uint8            status;     /* Field Init status. */

   /* Validate input parameters */
   if ((slice_mode == NULL) || (slice_enabled == NULL) ||
       (pipe >= SOC_MAX_NUM_PIPES) ||
       (slice_num < 0 && slice_num > 11)) {
      return BCM_E_PARAM;
   }

   BCM_IF_ERROR_RETURN(_bcm_field_initialized_status_get(unit, &status));
   if (status == FALSE) {
      return BCM_E_INIT;
   }

   BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                       _BCM_FIELD_STAGE_INGRESS, &stage_fc));

   if ((stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) &&
       (pipe >= 0)) {
      return BCM_E_CONFIG;
   }

   inst = (pipe < 0) ? 0 : pipe;
   /* coverity[overrun-local : FALSE] */
   fs = stage_fc->slices[inst] + slice_num;
   if (_BCM_FIELD_SLICE_HW_ENABLE & fs->slice_flags) {
      *slice_enabled = TRUE;
      if (soc_feature(unit, soc_feature_ifp_no_narrow_mode_support)) {
          *slice_mode = _IFP_SLICE_MODE_WIDE;
      } else {
          /* Determine the slice mode based on group flags. */
          *slice_mode = _BCM_FIELD_IS_SLICE_MODE_PBMP_SUPPORTED(fs->group_flags) ?
                    _IFP_SLICE_MODE_WIDE : _IFP_SLICE_MODE_NARROW;
      }
   } else {
      *slice_enabled = FALSE;
      *slice_mode = _IFP_SLICE_MODE_WIDE; /* default mode */
   }

   return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_field_th_resync
 * Purpose:
 *      Sync HW entries with SW entries.
 * Parameters:
 *      unit       - (IN) BCM Device number.
 *      stage_fc   - (IN) Reference to Field stage structure.
 *
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_field_th_resync(int unit, _field_stage_t *stage_fc)
{

    int               rv, tcam_idx;
    _field_slice_t    *fs;
    soc_mem_t         mem = INVALIDm;
    soc_reg_t         reg = INVALIDr;
    soc_field_t       field = VALIDf;
    uint32            valid, e[SOC_MAX_MEM_FIELD_WORDS];
    uint32            regval = 0, enable = 0, mode = 0;
    int               slice = 0, slice_idx = 0;
    int               inst, mem_inst;
    soc_mem_t         ifp_tcam_wide;
    soc_mem_t         ifp_tcam_narrow;
    _field_control_t  *fc;            /* Field control structure.       */

    if (stage_fc == NULL) {
       return BCM_E_PARAM;
    }

    if (stage_fc->stage_id != _BCM_FIELD_STAGE_INGRESS) {
       return BCM_E_NONE;
    }

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    for (inst = 0; inst < stage_fc->num_instances; inst++) {
       if (!(fc->pipe_map & (1 << inst))) {
             continue;
       }
       if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
           mem_inst = _FP_GLOBAL_INST;
       } else {
           mem_inst = inst;
       }

       BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, IFP_CONFIGr,
                                                          mem_inst, &reg));
       BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                   IFP_TCAM_WIDEm,
                                   mem_inst,
                                   &ifp_tcam_wide));
       BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                   IFP_TCAMm,
                                   mem_inst,
                                   &ifp_tcam_narrow));

       for (slice = 0; slice < stage_fc->num_instances; slice++) {
          if (!(fc->pipe_map & (1 << slice))) {
               continue;
          }
          BCM_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, REG_PORT_ANY, slice, &regval));
          enable = soc_reg_field_get(unit, reg, regval, IFP_SLICE_ENABLEf);
          if (enable == 0) {
             continue;
          }

          if (soc_feature(unit, soc_feature_ifp_no_narrow_mode_support)) {
              mode = _IFP_SLICE_MODE_WIDE;
              mem = ifp_tcam_narrow;
          } else {
              mode = soc_reg_field_get(unit, reg, regval, IFP_SLICE_MODEf);
              mem = (mode == _IFP_SLICE_MODE_WIDE) ?
                     ifp_tcam_wide : ifp_tcam_narrow;
          }

          fs = &stage_fc->slices[inst][slice];

          for (slice_idx = 0; slice_idx < fs->entry_count; slice_idx++) {

             (void)_bcm_field_th_slice_offset_to_tcam_idx(unit, stage_fc, inst,
                                                          slice, slice_idx,
                                                          &tcam_idx);
             /* Read tcam entry. */
             sal_memset(e, 0, sizeof(uint32) * SOC_MAX_MEM_FIELD_WORDS);
             rv = soc_mem_read(unit, mem, MEM_BLOCK_ANY, tcam_idx, e);
             if (BCM_FAILURE(rv)) {
                return rv;
             }
             valid = soc_mem_field32_get(unit, mem, e, field);
             if ((valid) && (fs->entries[slice_idx] == NULL)) {
                soc_mem_field32_set(unit, mem, e, field, 0);
                rv = soc_mem_write(unit, mem, MEM_BLOCK_ANY, tcam_idx, e);
                if (BCM_FAILURE(rv)) {
                   return rv;
                }
             }
          }
          if (fs->entry_count == fs->free_count) {
             uint32 regval_old, regval_new;

             BCM_IF_ERROR_RETURN
               (soc_reg32_get(unit, reg, REG_PORT_ANY, slice, &regval_old));
             regval_new = regval_old;
             soc_reg_field_set(unit, reg, &regval_new, IFP_SLICE_ENABLEf, enable);
             soc_reg_field_set(unit, reg, &regval_new, IFP_SLICE_LOOKUP_ENABLEf, enable);

             if (!soc_feature(unit,
                 soc_feature_ifp_no_narrow_mode_support)) {
                 soc_reg_field_set(unit, reg, &regval_new,
                                   IFP_SLICE_MODEf, mode);
             }

             if (regval_new != regval_old) {
                BCM_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, REG_PORT_ANY, slice_idx, regval_new));
             }
          }
       }
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_th_entry_phys_dump
 *
 * Purpose:
 *     Show contents of a physical entry structure
 *
 * Parameters:
 *     unit       - BCM device number
 *     f_ent      - Physical entry to dump
 * Returns:
 *     Nothing.
 */
int
_bcm_field_th_entry_phys_dump(int unit, _field_entry_t *f_ent)
{
    int                       idx;
    int                       qual_idx;
    _field_group_t            *fg;
    _bcm_field_qual_data_t    q_data;
    _bcm_field_qual_data_t    q_mask;
    _bcm_field_qual_offset_t  q_offset;
    int                       rv, i;
    int                       entry_parts = 0;
    int                       part_ct;
    uint32                    data = 0;
    uint32                    mask = 0;
    _field_stage_t            *stage_fc;
#if defined(BCM_TOMAHAWK2_SUPPORT)
    bcm_pbmp_t                mask_pbmp;
    bcm_port_t                mask_port;
#endif
    _field_control_t    *fc = NULL;            /* Field control structure.       */
    uint32                    offset = 0;

    /* Input validation check */
    if (f_ent == NULL) {
       return BCM_E_PARAM;
    }

    /* Get field control structure. */
    BCM_IF_ERROR_RETURN(_field_control_get(unit, &fc));

    /* Get number of parts in field entry based on group flags. */
    rv = _bcm_field_th_entry_tcam_parts_count (unit, f_ent->group->flags,
                                               &entry_parts);
    BCM_IF_ERROR_RETURN(rv);

    if ((f_ent->group->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER) &&
        (soc_feature(unit, soc_feature_bscan_fae_port_flow_exclude))) {
        offset = 4;
    }

    for (part_ct = 0; part_ct < entry_parts; part_ct++) {

         if (part_ct) {
               LOG_CLI((BSL_META_U(unit,"\n")));
         }

         if ((f_ent + part_ct)->fs) {
            LOG_CLI((BSL_META_U(unit, " slice=%d, slice_idx=%#x,"),
                        (f_ent + part_ct)->fs->slice_number,
                        (f_ent + part_ct)->slice_idx + offset));
         }

         LOG_CLI((BSL_META_U(unit, " part=%d, prio=%#x, flags=%#x, "),
                    part_ct, (f_ent + part_ct)->prio, (f_ent + part_ct)->flags));

        if (!((f_ent + part_ct)->flags & _FP_ENTRY_INSTALLED)) {
            if ((f_ent + part_ct)->flags &
                 _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT) {
                LOG_CLI((BSL_META_U(unit,
                                    "Default, ")));
            }
            LOG_CLI((BSL_META_U(unit,
                                "Not installed")));
        } else {
            LOG_CLI((BSL_META_U(unit,
                                "Installed, ")));

            if (!((f_ent + part_ct)->flags & _FP_ENTRY_ENABLED)) {
                LOG_CLI((BSL_META_U(unit,
                                    "Disabled")));
            }

            else {
                LOG_CLI((BSL_META_U(unit,
                                    "Enabled")));
            }

            if ((f_ent + part_ct)->flags & _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT) {
                LOG_CLI((BSL_META_U(unit,
                                    ", Default")));
            }

            if ((f_ent + part_ct)->flags & _FP_ENTRY_DIRTY) {
                LOG_CLI((BSL_META_U(unit,
                                   ", Dirty")));
            }

        }

        LOG_CLI((BSL_META_U(unit,
                        ", color_indep=%d"),
            (((f_ent + part_ct)->flags & _FP_ENTRY_COLOR_INDEPENDENT) ? 1 : 0)));
    }
    LOG_CLI((BSL_META_U(unit,"\n")));

    rv = _bcm_field_qual_tcam_key_mask_get(unit, f_ent);
    if (BCM_FAILURE(rv)) {
        LOG_CLI((BSL_META_U(unit,
                            "\nUnit (%d) Entry (%d) tcam key read failure.\n"),
                 unit, f_ent->eid));
        return BCM_E_INTERNAL;
    }

    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    BCM_IF_ERROR_RETURN(rv);

    fg = f_ent->group;

    for (qual_idx = 0; qual_idx < _bcmFieldQualifyCount; qual_idx++) {

        if (0 == BCM_FIELD_QSET_TEST(fg->qset, qual_idx)
            || IS_SUDO_QUALIFIER(qual_idx)) {
           continue;
        }
#if defined(BCM_TRIDENT3_SUPPORT)
        if (soc_feature(unit, soc_feature_td3_style_fp)) {
           int           port, temp_p, set_data, inst;
           bcm_pbmp_t    ipbm[2], ipbm_mask[2];
           char          buf_ipbm[SOC_MAX_MEM_FIELD_WORDS];    /* s/w buffer to contain pbmp. */
           uint16        pbm_34_50[2] = {0};
           uint16        pbm_51_65[2] = {0};
           uint16        pbm_34_50_mask[2] = {0};
           uint16        pbm_51_65_mask[2] = {0};

           if (qual_idx == bcmFieldQualifyInPorts) {
               if (0 == _FP_TCAM_IPBMP_SIZE(unit)) {
                   return BCM_E_INTERNAL;
               }
               BCM_PBMP_CLEAR(ipbm[0]);
               BCM_PBMP_CLEAR(ipbm_mask[0]);
               BCM_PBMP_CLEAR(ipbm[1]);
               BCM_PBMP_CLEAR(ipbm_mask[1]);
               BCM_PBMP_ITER(f_ent->pbmp.mask, port) {
                   set_data = 0;
                   SOC_IF_ERROR_RETURN(soc_port_pipe_get(unit, port, &inst));
                   temp_p = (port >= _BCM_TD3_NUM_PIPE_PORTS) ?
                            (port - _BCM_TD3_NUM_PIPE_PORTS) : port;
                   if (BCM_PBMP_MEMBER(f_ent->pbmp.data, port)) {
                      set_data = 1;
                   }
                   if (temp_p < _FP_TCAM_IPBMP_SIZE(unit)) {
                      if (set_data == 1) {
                         BCM_PBMP_PORT_ADD(ipbm[inst], temp_p);
                      }
                      if (!IS_LB_PORT(unit, port)) {
                         BCM_PBMP_PORT_ADD(ipbm_mask[inst], temp_p);
                      }
                   } else if (temp_p < (_FP_TCAM_IPBMP_SIZE(unit) + 16)) {
                       temp_p = temp_p - _FP_TCAM_IPBMP_SIZE(unit);
                       /* coverity[BAD_SHIFT: FALSE] */
                       pbm_34_50_mask[inst] |= 1 << temp_p;
                       if (set_data == 1) {
                           /* coverity[BAD_SHIFT: FALSE] */
                           pbm_34_50[inst] |= 1 << temp_p;
                       }
                   } else if (temp_p < (_FP_TCAM_IPBMP_SIZE(unit) + 32)) {
                       temp_p = temp_p - (_FP_TCAM_IPBMP_SIZE(unit) + 16);
                       /* coverity[BAD_SHIFT: FALSE] */
                       pbm_51_65_mask[inst] |= 1 << temp_p;
                       if (set_data == 1) {
                           /* coverity[BAD_SHIFT: FALSE] */
                           pbm_51_65[inst] |= 1 << temp_p;
                       }
                   }
               }



               LOG_CLI((BSL_META_U(unit,
                    "\n %s "),  _field_qual_name(qual_idx)));
               LOG_CLI((BSL_META_U(unit,
                    "\n     DATA=%s"), SOC_PBMP_FMT(f_ent->pbmp.data, buf_ipbm)));
               LOG_CLI((BSL_META_U(unit,
                    "\n     MASK=%s"), SOC_PBMP_FMT(f_ent->pbmp.mask, buf_ipbm)));

               for (i = 0; i < 3; i++) {
                   LOG_CLI((BSL_META_U(unit, "\n %s "),
                    ((i == 0) ? "_InPorts_0" : ((i == 1) ? "_InPorts_1" : "_InPorts_2"))));
                  for (inst = 0; inst < stage_fc->num_pipes; inst++) {
                     if (!(fc->pipe_map & (1 << inst))) {
                          continue;
                     }
                     if (stage_fc->oper_mode == bcmFieldGroupOperModePipeLocal) {
                        if (inst != fg->instance) {
                           continue;
                        }
                     }
                     LOG_CLI((BSL_META_U(unit, "\n   Instance=%d"), inst));

                     if (i == 0) {
                        SOC_PBMP_FMT(ipbm[inst], buf_ipbm);
                        LOG_CLI((BSL_META_U(unit,
                              "\n     DATA=0x%s"), (char *)&buf_ipbm[56]));
                        SOC_PBMP_FMT(ipbm_mask[inst], buf_ipbm);
                        LOG_CLI((BSL_META_U(unit,
                              "\n     MASK=0x%s"), (char *)&buf_ipbm[56]));
                     } else if (i == 1) {
                        LOG_CLI((BSL_META_U(unit,
                              "\n     DATA=0x%x"), pbm_34_50[inst]));
                        LOG_CLI((BSL_META_U(unit,
                              "\n     MASK=0x%x"), pbm_34_50_mask[inst]));
                     } else if (i == 2) {
                        LOG_CLI((BSL_META_U(unit,
                              "\n     DATA=0x%x"), pbm_51_65[inst]));
                        LOG_CLI((BSL_META_U(unit,
                              "\n     MASK=0x%x"), pbm_51_65_mask[inst]));
                     }
                  }
               }
               continue;
           }

           if ((qual_idx == _bcmFieldQualifyInPorts_1) ||
               (qual_idx == _bcmFieldQualifyInPorts_2)) {
               continue;
           }
        }
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TOMAHAWK2_SUPPORT)
        if (_BCM_FIELD_IS_PBMP_QUALIFIER(qual_idx) &&
            soc_feature(unit, soc_feature_xy_tcam_x0y)) {
            char          buf_ipbm[100];    /* s/w buffer to contain pbmp. */
            LOG_CLI((BSL_META_U(unit,
                    "\n %s "),  _field_qual_name(qual_idx)));
            LOG_CLI((BSL_META_U(unit,
                     "\n    DATA=%s"), SOC_PBMP_FMT(f_ent->pbmp.data, buf_ipbm)));
            BCM_PBMP_ASSIGN(mask_pbmp, f_ent->pbmp.mask);
            BCM_PBMP_ITER(f_ent->pbmp.mask, mask_port) {
                if (IS_LB_PORT(unit, mask_port)) {
                    BCM_PBMP_PORT_REMOVE(mask_pbmp, mask_port);
                }
            }
            LOG_CLI((BSL_META_U(unit,
                     "\n    MASK=%s"), SOC_PBMP_FMT(mask_pbmp, buf_ipbm)));
            continue;
        }
#endif /* BCM_TOMAHAWK2_SUPPORT */
        _FP_QUAL_DATA_CLEAR(q_data);
        _FP_QUAL_DATA_CLEAR(q_mask);

        if ((_BCM_FIELD_IS_PBMP_QUALIFIER(qual_idx)) &&
            (bcmFieldGroupOperModeGlobal == stage_fc->oper_mode) &&
            (soc_property_get(unit, spn_FIELD_ATOMIC_UPDATE, FALSE) == FALSE)) {
            int      pipe_ports_max;   /* Max ports per pipe. */
            int        tcam_idx = 0;   /* Entry slice index. */
            char          buf[100];    /* s/w buffer to contain pbmp. */
            int           inst;        /* XGS pipe number */
            _field_pbmp_t pipe_pbmp;   /* Per pipe 36 bit pbmp. */
            _field_pbmp_t system_pbmp; /* System wide 144 bit pbmp.*/
            uint32        tcam_entry[SOC_MAX_MEM_FIELD_WORDS] = {0};
            bcm_port_t    port;        /* Holds physical port number. */
            bcm_port_t    system_port;
            soc_mem_t tcam_mem = INVALIDm;

            pipe_ports_max = SOC_MAX_NUM_PORTS/SOC_MAX_NUM_PIPES;

            (void)_bcm_field_th_slice_offset_to_tcam_idx(unit, stage_fc,
                                                   f_ent->group->instance,
                                                   f_ent->fs->slice_number,
                                                   f_ent->slice_idx, &tcam_idx);

            LOG_CLI((BSL_META_U(unit,
                    "\n %s "),  _field_qual_name(qual_idx)));

            sal_memset(&system_pbmp, 0x0, sizeof(_field_pbmp_t));
            for (inst = 0; inst < stage_fc->num_pipes; inst++) {
                if (!(fc->pipe_map & (1 << inst))) {
                     continue;
                }

                if (soc_feature(unit, soc_feature_th3_style_fp)) {
                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       IFP_TCAMm,
                                                       inst, &tcam_mem));
                } else {
                    BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                       IFP_TCAM_WIDEm,
                                                       inst, &tcam_mem));
                }

                rv = soc_th_ifp_mem_read(unit, tcam_mem, MEM_BLOCK_ANY,
                                         tcam_idx, tcam_entry);
                SOC_IF_ERROR_RETURN(rv);

                sal_memset(&pipe_pbmp, 0x0, sizeof(_field_pbmp_t));
                soc_mem_pbmp_field_get(unit, tcam_mem, tcam_entry,
                                            IPBMf, &pipe_pbmp.data);

                BCM_PBMP_ITER(pipe_pbmp.data, port) {
                    system_port = port + (inst * pipe_ports_max);
                    if (system_port <= SOC_MAX_NUM_PORTS) {
                        /* coverity[overrun-local] */
                        BCM_PBMP_PORT_ADD(system_pbmp.data, system_port);
                    }
                }

                soc_mem_pbmp_field_get(unit, tcam_mem, tcam_entry,
                                           IPBM_MASKf, &pipe_pbmp.mask);


                BCM_PBMP_ITER(pipe_pbmp.mask, port) {
                    system_port = port + (inst * pipe_ports_max);
                    if ((system_port <= SOC_MAX_NUM_PORTS) &&
                        (0 == IS_LB_PORT(unit, port))){
                        /* coverity[overrun-local] */
                        BCM_PBMP_PORT_ADD(system_pbmp.mask, system_port);
                    }
                }
            }
            LOG_CLI((BSL_META_U(unit,
                    "\n    DATA=%s"), SOC_PBMP_FMT(system_pbmp.data, buf)));
            LOG_CLI((BSL_META_U(unit,
                    "\n    MASK=%s"), SOC_PBMP_FMT(system_pbmp.mask, buf)));

            continue;
        }

        /* Get the data and mask for the current qualifier*/
	rv = _bcm_field_th_entry_qualifier_key_get(unit, f_ent->eid,
                                      qual_idx, q_data, q_mask);
	BCM_IF_ERROR_RETURN(rv);

        /* if mask is 0x0, no need to print the qualifier in entry dump*/
	if(q_mask[0] == 0 && q_mask[1] == 0
            && q_mask[2] == 0 && q_mask[3] == 0
            && q_mask[4] == 0 && q_mask[5] == 0
            && q_mask[6] == 0 && q_mask[7] == 0) {
            continue;
        }

	LOG_CLI((BSL_META_U(unit, "\n %s "),
                     _field_qual_name(qual_idx)));

        for (part_ct = 0; part_ct < entry_parts; part_ct++) {
            /* Initialize q_offset to NULL */
            sal_memset(&q_offset, 0x0, sizeof(q_offset));

            rv = _bcm_field_th_qual_part_offset_get(unit, f_ent, part_ct,
                                                    qual_idx, &q_offset);
            if (rv == BCM_E_NOT_FOUND) {
               continue;
            } else if (BCM_FAILURE(rv)) {
               return rv;
            }

            for (i = 0; i < q_offset.num_offsets; i++) {
               if (0 != q_offset.width[i]) {
                 int delta = 0;
                 if ((fg->flags & _FP_GROUP_SPAN_SINGLE_SLICE) &&
                     !(fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE)) {
                    delta = 80;
                 }
#if defined(BCM_FLOWTRACKER_SUPPORT)
                 if (fg->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER) {
                    delta = 0;
                 }
#endif
                  LOG_CLI((BSL_META_U(unit,
                                "\n    Part:%d Offset%d: %2d Width%d: %3d "),
                                part_ct, i, q_offset.offset[i]+delta, i,
                                q_offset.width[i]));
               }
            }
	}
        LOG_CLI((BSL_META_U(unit,
                           "\n    DATA=0x")));
        for (idx = 7; idx >= 0; idx--) {
            data = q_data[idx];
            mask = q_mask[idx];
            if (data == 0 && mask == 0) {
                continue;
            }
            /* Check if HW packet_res must be remmaped for API use */
            if (bcmFieldQualifyPacketRes == qual_idx) {
                _bcm_field_td2_qualify_PacketRes_get(unit,
                                  f_ent->eid, &data, &mask);
                q_mask[idx] = mask;
            }
            LOG_CLI((BSL_META_U(unit,
                               "%08x "), data));
        }

        LOG_CLI((BSL_META_U(unit,
                            "\n    MASK=0x")));
        for (idx = 7; idx >= 0; idx--) {
            data = q_data[idx];
            mask = q_mask[idx];
            if (data == 0 && mask == 0) {
                continue;
            }
            LOG_CLI((BSL_META_U(unit,
                                "%08x "), q_mask[idx]));
        }
    }

    LOG_CLI((BSL_META_U(unit,
                        "\n")));
    return BCM_E_NONE;
}

/*
 * Retrieve Action Format for a given index to the policy memory.
 * Supported only for IFP PDD formats.
 */
STATIC int
_field_action_ifp_policy_decoder_data_get(
         int unit,
         soc_mem_t policy_mem,
         int index,
         soc_field_t field,
         uint32 *fmt_val)
{
    int rv;
    int bit = 0, idx;
    uint32 ap_idx;
    soc_mem_t profile_mem;
    uint32 policy_entry[SOC_MAX_MEM_FIELD_WORDS] = {0};
    _bcm_field_action_set_t *action_prof_ptr = NULL;
    void *act_prof_entry;               /* Profile table buffer pointer */
    uint32 hw_bitmap[2] = {0};
    uint32 act_offset = 0;
    uint32 bitmap_size = 0;
    uint32 act_bitmap_sz = 0;
    uint32 size = 0, value = 0, offset = 0;
    uint32 data_buf[100] = {0};

    if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
       return BCM_E_NONE;
    }

    if ((policy_mem != IFP_POLICY_TABLEm) &&
        (policy_mem != IFP_POLICY_TABLE_PIPE0m) &&
        (policy_mem != IFP_POLICY_TABLE_PIPE1m) &&
        (policy_mem != IFP_POLICY_TABLE_WIDEm) &&
        (policy_mem != IFP_POLICY_TABLE_WIDE_PIPE0m) &&
        (policy_mem != IFP_POLICY_TABLE_WIDE_PIPE1m)) {
        return BCM_E_PARAM;
    }

    rv = soc_mem_read(unit, policy_mem, MEM_BLOCK_ANY, index, policy_entry);
    BCM_IF_ERROR_RETURN(rv);

    /* Get Action data from entry buffere */
    soc_mem_field_get(unit, policy_mem, policy_entry, DATAf, &data_buf[0]);

    /* Get Action Data type from entry Buffer. */
    ap_idx = soc_mem_field32_get(unit, policy_mem, policy_entry, DATA_TYPEf);

    /* Initialise variables */
    sal_memcpy(&act_prof_entry, soc_mem_entry_null(unit, policy_mem),
                soc_mem_entry_words(unit, policy_mem) * sizeof(uint32));

    if ((policy_mem == IFP_POLICY_TABLEm) || (policy_mem == IFP_POLICY_TABLE_WIDEm)) {
       profile_mem = IFP_POLICY_ACTION_PROFILEm;
       rv = soc_mem_read(unit, profile_mem, MEM_BLOCK_ANY, ap_idx, &hw_bitmap);
    }

     act_offset = 0;
    /* For TD3, policy data is filled from MSB to LSB */
    if(soc_feature(unit, soc_feature_td3_style_fp)) {
        if (policy_mem == IFP_POLICY_TABLEm
            || policy_mem == IFP_POLICY_TABLE_PIPE0m
            || policy_mem == IFP_POLICY_TABLE_PIPE1m) {
            act_offset = _FP_ASET_DATA_SIZE_FOR_POLICY_NARROW;
        } else if (policy_mem == IFP_POLICY_TABLE_WIDEm
                    || policy_mem == IFP_POLICY_TABLE_WIDE_PIPE0m
                    || policy_mem == IFP_POLICY_TABLE_WIDE_PIPE1m) {
            act_offset = _FP_ASET_DATA_SIZE_FOR_POLICY_WIDE;
        }

#if defined(BCM_FIREBOLT6_SUPPORT)
        if (SOC_IS_FIREBOLT6(unit)) {
            action_prof_ptr = bcm_field_fb6_ifp_action_set;
            bitmap_size = sizeof(bcm_field_fb6_ifp_action_set)/sizeof(_bcm_field_action_set_t);
        } else
#endif
#if defined(BCM_HURRICANE4_SUPPORT)
        if (SOC_IS_HURRICANE4(unit)) {
            action_prof_ptr = bcm_field_hr4_ifp_action_set;
            bitmap_size = sizeof(bcm_field_hr4_ifp_action_set)/sizeof(_bcm_field_action_set_t);
        } else
#endif
#if defined(BCM_HELIX5_SUPPORT)
        if (SOC_IS_HELIX5(unit)) {
            action_prof_ptr = bcm_field_hx5_ifp_action_set;
            bitmap_size = sizeof(bcm_field_hx5_ifp_action_set)/sizeof(_bcm_field_action_set_t);
        } else
#endif
        {
            action_prof_ptr = bcm_field_td3_ifp_action_set;
            bitmap_size = sizeof(bcm_field_td3_ifp_action_set)/sizeof(_bcm_field_action_set_t);
        }

        for (idx = (bitmap_size - 1); idx >= 0; idx--) {
            if (action_prof_ptr[idx].size == 0) {
               continue;
            }

            if (act_bitmap_sz == 0) {
               act_bitmap_sz = idx;
               bit = act_bitmap_sz;
            }

            if ((((bit >= 32) && (hw_bitmap[1] & (1 << (bit - 32)))) ||
                ((bit < 32) && (hw_bitmap[0] & (1 << bit)))) &&
                (idx < (bitmap_size - 1))) {
               value = 0;
               size = action_prof_ptr[idx + 1].size;
               offset = act_offset - size;

               if (field == action_prof_ptr[idx + 1].hw_field) {
                  _bcm_field_th_val_get(data_buf, &value, offset, size);
                  *fmt_val = value;
                  break;
               }
               act_offset -= size;
            }
            if (bit > 0) {
               bit--;
            } else {
               return BCM_E_INTERNAL;
            }
        }
    }

    return BCM_E_NONE;
}
/*
 * Function to retrieve Flex Counter fields for a given
 * index to the IFP Policy memory.
 */
int
_bcm_field_action_profile_hw_stat_fields_get(
                int unit,
                int index,
                soc_mem_t mem,
                uint32 *offset_mode,
                uint32 *pool_number,
                uint32 *base_idx)
{
    uint32 value;
    soc_format_t fmt = IFP_COUNTER_SETfmt;

    if (!soc_feature(unit, soc_feature_ifp_action_profiling)) {
       return BCM_E_NONE;
    }

    BCM_IF_ERROR_RETURN(_field_action_ifp_policy_decoder_data_get(
                               unit, mem, index, COUNTER_SETf, &value));

    if (base_idx != NULL) {
        *base_idx = soc_format_field32_get(unit, fmt, &value,
                                           FLEX_CTR_BASE_COUNTER_IDXf);
    }

    if (pool_number != NULL) {
        *pool_number = soc_format_field32_get(unit, fmt, &value,
                                              FLEX_CTR_POOL_NUMBERf);
    }

    if (offset_mode != NULL) {
        *offset_mode =  soc_format_field32_get(unit, fmt, &value,
                                               FLEX_CTR_OFFSET_MODEf);
    }


    return BCM_E_NONE;
}

int _fp_action_profile_dump(
        int unit,
        bcm_field_action_t action,
        soc_mem_t mem,
        int index)
{
   int rv;
   uint32 value = 0;
   soc_field_t field;
   soc_format_t fmt;
   int action_set;
   _field_stage_t *stage_fc; /* Field Stage Structure. */
   _bcm_field_action_conf_t *aconf; /* Field Action config structure. */

   if (action == bcmFieldActionStatGroup) {
      uint32 offset_mode, base_idx, pool;

      rv = _bcm_field_action_profile_hw_stat_fields_get(
                   unit, index, mem, &offset_mode, &pool, &base_idx);
      BCM_IF_ERROR_RETURN(rv);

      cli_out("%s :: base_idx: 0x%x pool_number: 0x%x offset_mode: 0x%x\n\r",
              _field_action_name(action), base_idx, pool, offset_mode);

      return BCM_E_NONE;
   }

   rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
   BCM_IF_ERROR_RETURN(rv);

   BCM_IF_ERROR_RETURN(_bcm_field_action_config_get(
                       unit, stage_fc, action, &aconf));

   action_set = aconf->offset->aset;
   field = bcm_field_td3_ifp_action_set[action_set].hw_field;

   if ((action == bcmFieldActionCopyToCpu) ||
       (action == bcmFieldActionGpCopyToCpu) ||
       (action == bcmFieldActionYpCopyToCpu) ||
       (action == bcmFieldActionRpCopyToCpu)) {
      uint32 r_copy2cpu, y_copy2cpu, g_copy2cpu, matched_rule;
      uint32 val = 0;

      uint8 copy_2_cpu_val[8][40] = {
                                  "NOOP",
                                  "COPY_TO_CPU",
                                  "DO_NOT_COPY_TO_CPU",
                                  "OVERRIDE_SWITCH_COPY_TO_CPU",
                                  "DO_NOT_OVERRIDE_SWITCH_COPY_TO_CPU",
                                  "COPY_WITH_TIMESTAMP",
                                  "CANCEL_COPY_AND_SWITCH_TO_CPU",
                                  "RESERVED_7"};


      BCM_IF_ERROR_RETURN(_field_action_ifp_policy_decoder_data_get(
                                   unit, mem, index, field, &value));
      fmt = IFP_COPY_TO_CPU_SETfmt;
      r_copy2cpu = soc_format_field32_get(unit, fmt, &value, R_COPY_TO_CPUf);
      y_copy2cpu = soc_format_field32_get(unit, fmt, &value, Y_COPY_TO_CPUf);
      g_copy2cpu = soc_format_field32_get(unit, fmt, &value, G_COPY_TO_CPUf);
      matched_rule = soc_format_field32_get(unit, fmt, &value, MATCHED_RULEf);

      if (action == bcmFieldActionGpCopyToCpu ||
          action == bcmFieldActionCopyToCpu) {
         val = g_copy2cpu;
      } else if (action == bcmFieldActionYpCopyToCpu) {
         val = y_copy2cpu;
      } else if (action == bcmFieldActionRpCopyToCpu) {
         val = r_copy2cpu;
      }

      cli_out("%s :: [%s] Matched_rule:[%d]\n\r",
                  _field_action_name(action), copy_2_cpu_val[val], matched_rule);
   } else {
      BCM_IF_ERROR_RETURN(_field_action_ifp_policy_decoder_data_get(
                                   unit, mem, index, field, &value));

      cli_out("%s :: value:%d \n\r", _field_action_name(action), value);
   }

   return BCM_E_NONE;
}

int
_bcm_field_th_qualify_PacketRes(int               unit,
                                 bcm_field_entry_t entry,
                                 uint32            *data,
                                 uint32            *mask
                                 )
{
    int rv = BCM_E_NONE;

    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
        if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
            /*Error fetching entry*/
            return (rv);
        }

        if (rv == BCM_E_NONE) { /*Stage is Ingress*/

            if ((soc_feature(unit, soc_feature_field_preselector_support)) &&
                (soc_feature(unit, soc_feature_th3_style_fp)) &&
                (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
                switch (*data) {
                    case BCM_FIELD_PKT_RES_IEEE1588:
                    case BCM_FIELD_PKT_RES_BFD:
                    case BCM_FIELD_PKT_RES_UNKNOWN:
                        break;
                    default:
                        return BCM_E_UNAVAIL;
                }
            } else {

                switch (*data) {
                    case BCM_FIELD_PKT_RES_ICNM:
                    case BCM_FIELD_PKT_RES_FCOEKNOWN:
                    case BCM_FIELD_PKT_RES_FCOEUNKNOWN:
                    case BCM_FIELD_PKT_RES_MPLSMCKNOWN:
                    case BCM_FIELD_PKT_RES_FCOE_ANY:
                    case BCM_FIELD_PKT_RES_MPLS_ANY:
                        return BCM_E_UNAVAIL;
                    case BCM_FIELD_PKT_RES_PIMBIDIRUNKNOWN:
#if defined(    BCM_TOMAHAWK2_SUPPORT)
                        if (soc_feature(unit, soc_feature_field_multi_pipe_enhanced)) {
                            break;
                        } else
#endif /*BCM    _TOMAHAWK2_SUPPORT*/
                        {
                            return BCM_E_UNAVAIL;
                        }
                    case BCM_FIELD_PKT_RES_OAM:
                    case BCM_FIELD_PKT_RES_MPLSL2KNOWN:
                    case BCM_FIELD_PKT_RES_MIMKNOWN:
                    case BCM_FIELD_PKT_RES_MIMUNKNOWN:
                    case BCM_FIELD_PKT_RES_TRILLKNOWN:
                    case BCM_FIELD_PKT_RES_TRILLUNKNOWN:
                    case BCM_FIELD_PKT_RES_NIVKNOWN:
                    case BCM_FIELD_PKT_RES_NIVUNKNOWN:
                    case BCM_FIELD_PKT_RES_L2GREKNOWN:
                    case BCM_FIELD_PKT_RES_VXLANKNOWN:
                    case BCM_FIELD_PKT_RES_TRILL_ANY:
                    case BCM_FIELD_PKT_RES_NIV_ANY:
                    case BCM_FIELD_PKT_RES_MIM_ANY:
                         if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
                            return BCM_E_UNAVAIL;
                         }
                        break;
                    default:
                        break;
                }
            }
        }
    }

    BCM_IF_ERROR_RETURN(_bcm_field_td2_qualify_PacketRes(unit, entry, data, mask));
    return rv;
}


int
_bcm_field_th_qualify_PacketRes_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    int  rv;            /* Operation return status. */

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifyPacketRes,
                                           data, mask);
    BCM_IF_ERROR_RETURN(rv);

    rv = _bcm_field_td2_qualify_PacketRes_get(unit, entry, data, mask);
    if (BCM_FAILURE(rv)) {
       return rv;
    }

    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {

       if ((soc_feature(unit, soc_feature_field_preselector_support)) &&
           (soc_feature(unit, soc_feature_th3_style_fp)) &&
           (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
           switch (*data) {
               case BCM_FIELD_PKT_RES_IEEE1588:
               case BCM_FIELD_PKT_RES_BFD:
               case BCM_FIELD_PKT_RES_UNKNOWN:
                   break;
               default:
                   return BCM_E_INTERNAL;
           }
       } else {

           switch (*data) {
             case BCM_FIELD_PKT_RES_ICNM:
             case BCM_FIELD_PKT_RES_FCOEKNOWN:
             case BCM_FIELD_PKT_RES_FCOEUNKNOWN:
             case BCM_FIELD_PKT_RES_MPLSMCKNOWN:
                  return BCM_E_INTERNAL;
             case BCM_FIELD_PKT_RES_PIMBIDIRUNKNOWN:
#if defined(BCM_TOMAHAWK2_SUPPORT)
                 if (soc_feature(unit, soc_feature_field_multi_pipe_enhanced)) {
                     break;
                 } else
#endif     /*BCM_TOMAHAWK2_SUPPORT*/
                 {
                     return BCM_E_UNAVAIL;
                 }
             case BCM_FIELD_PKT_RES_OAM:
             case BCM_FIELD_PKT_RES_MPLSL2KNOWN:
             case BCM_FIELD_PKT_RES_MIMKNOWN:
             case BCM_FIELD_PKT_RES_MIMUNKNOWN:
             case BCM_FIELD_PKT_RES_TRILLKNOWN:
             case BCM_FIELD_PKT_RES_TRILLUNKNOWN:
             case BCM_FIELD_PKT_RES_NIVKNOWN:
             case BCM_FIELD_PKT_RES_NIVUNKNOWN:
             case BCM_FIELD_PKT_RES_L2GREKNOWN:
             case BCM_FIELD_PKT_RES_VXLANKNOWN:
             case BCM_FIELD_PKT_RES_TRILL_ANY:
             case BCM_FIELD_PKT_RES_NIV_ANY:
             case BCM_FIELD_PKT_RES_MIM_ANY:
                  if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
                     return BCM_E_INTERNAL;
                  }
                  break;
             default:
                  break;
           }
       }
    }

    return rv;
}


int
_bcm_field_th_ddrop_profile_alloc(int unit, _field_entry_t *f_ent,
                                   _field_action_t *fa)
{
#if defined (BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_th3_style_fp)) {
        return _bcm_field_th3_ddrop_profile_alloc(unit, f_ent, fa);
    }
#endif
    return BCM_E_UNAVAIL;
}

int
_bcm_field_th_dredirect_profile_alloc(int unit, _field_entry_t *f_ent,
                                   _field_action_t *fa)
{
#if defined (BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_th3_style_fp)) {
        return _bcm_field_th3_dredirect_profile_alloc(unit, f_ent, fa);
    }
#endif
    return BCM_E_UNAVAIL;

}

#ifdef BCM_WARM_BOOT_SUPPORT

              /*  START OF WARMBOOT ROUTINES */
/*
 * Function:
 *  _field_th_slice_map_write
 *
 * Purpose:
 *  Sync's slice status to scache for a stage
 *  (Expanded, master slice idx, Pipe instance)
 *
 * Parameters:
 *     unit      - (IN) BCM device number
 *       fc      - (IN) FP control info.
 * instance      - (IN) Pipe Instance.
 * stage_fc      - (IN) FP stage control info.
 *
 * Returns:
 *   BCM_E_XXX
 */

int
_field_th_slice_map_write(int unit, _field_control_t *fc,
                          int instance, _field_stage_t *stage_fc)
{
    uint8               slice_id;        /* Slices iterator.    */
    _field_slice_t      *fs;             /* Slice pointer.      */
    uint8               *buf;            /* Scache pointer.     */

    if ((stage_fc == NULL) || (fc == NULL)) {
        return BCM_E_PARAM;
    }

    /* No need to sync external stage */
    if (stage_fc->stage_id != _BCM_FIELD_STAGE_LOOKUP &&
        stage_fc->stage_id != _BCM_FIELD_STAGE_EGRESS) {
        return BCM_E_PARAM;
    }

    if (instance < 0 || instance >= _FP_MAX_NUM_PIPES) {
       return BCM_E_PARAM;
    }

    buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];

    for (slice_id = 0; slice_id < stage_fc->tcam_slices; slice_id++) {
        fs = stage_fc->slices[instance] + slice_id;

        if ((fc->wb_current_version) < BCM_FIELD_WB_VERSION_1_26) {
            buf[fc->scache_pos] = (fs->prev != NULL) ? 1 : 0;
            /* Go to master slice */
            while (fs->prev != NULL) {
                fs = fs->prev;
            }
            buf[fc->scache_pos] |= (fs->slice_number << 1);

            /* Write the Pipe instance in the MSB 2-bits of the same byte */
            buf[fc->scache_pos] |= (instance << 6);

            LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                    "%s(): Writing inst[%d] expanded[%d] master_slice[%d]"
                    " for slice[%d] val:%d @ byte %d...\n\r"),
                    __func__, ((buf[fc->scache_pos] >> 6) & 0x3),
                    (buf[fc->scache_pos] & 0x1), ((buf[fc->scache_pos] >> 1) & 0x3),
                    slice_id, buf[fc->scache_pos], fc->scache_pos));

            fc->scache_pos++;
            fs = NULL;
        } else {

            /* 1 bit to save prev info */
            buf[fc->scache_pos] = (fs->prev != NULL) ? 1 : 0;
            /* Go to master slice */
            while (fs->prev != NULL) {
                fs = fs->prev;
            }
            /* 7 bits for slice number */
            buf[fc->scache_pos] |= (fs->slice_number << 1);

            LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                    "%s(): Writing expanded[%d] master_slice[%d]"
                    " for slice[%d] val:%d @ byte %d...\n\r"),
                    __func__, (buf[fc->scache_pos] & 0x1),
                    ((buf[fc->scache_pos] >> 1) & 0x3),
                    slice_id, buf[fc->scache_pos], fc->scache_pos));

            fc->scache_pos++;

            /* Write the Pipe instance in the LSB 4-bits of the next byte */
            buf[fc->scache_pos] = ((instance) & 0xf);

            LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                    "%s(): Writing inst[%d] at @ byte %d...\n\r"),
                    __func__,(buf[fc->scache_pos] & 0xf), fc->scache_pos));

            fc->scache_pos++;
            fs = NULL;

        }
    }
    return BCM_E_NONE;
}


/*
 * Function:
 *  _bcm_field_slice_index_bmp_write
 *
 * Purpose:
 *  Sync's slice index bmp to scache for a stage
 *
 * Parameters:
 *     unit      - (IN) BCM device number
 *       fc      - (IN) FP control info.
 * stage_fc      - (IN) FP stage control info.
 *
 * Returns:
 *   BCM_E_XXX
 */

int
_bcm_field_wb_slice_index_bmp_write(int unit, _field_control_t *fc,
                          _field_stage_t *stage_fc)
{
    uint8 *buf;            /* Scache pointer.     */
    int size;
    int slice_size;
    int entry_index;
    _field_sliceidx_bmp_t sliceidx_bmp;
    _field_group_t        *fgtemp;
    int slice_offset;
    int rv = BCM_E_NONE;
    int tcam_index = 0;
    sliceidx_bmp.w = NULL;

    if ((stage_fc == NULL) || (fc == NULL)) {
        return BCM_E_PARAM;
    }

    buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    /* get the total slice size*/
    slice_size = stage_fc->tcam_sz;
    size = SHR_BITALLOCSIZE(slice_size * _FP_MAX_NUM_PIPES);
    sliceidx_bmp.w = NULL;
    _FP_XGS3_ALLOC(sliceidx_bmp.w, size, "Sliceidx Bitmap");
    if (NULL == sliceidx_bmp.w) {
        return (BCM_E_MEMORY);
    }
    fgtemp = fc->groups;
    while (fgtemp != NULL) {
        if ((fgtemp->stage_id == stage_fc->stage_id)) {
            for (entry_index = 0;
                 entry_index < fgtemp->group_status.entry_count;
                 ++entry_index) {
                if ( ((fgtemp->entry_arr[entry_index]->flags) &
                    _FP_ENTRY_INSTALLED) &&
                    ((!(fgtemp->flags & _FP_GROUP_LOOKUP_ENABLED)) ||
                    (!(((fgtemp->entry_arr[entry_index]->flags) &
                    _FP_ENTRY_ENABLED) ==  _FP_ENTRY_ENABLED)))) {
                    slice_offset = (slice_size * fgtemp->instance);
                    rv = _bcm_field_entry_tcam_idx_get(unit,
                             fgtemp->entry_arr[entry_index],
                             &tcam_index);
                    if (BCM_FAILURE(rv)) {
                        sal_free(sliceidx_bmp.w);
                        sliceidx_bmp.w = NULL;
                        LOG_DEBUG(BSL_LS_BCM_FP,
                                   (BSL_META_U(unit,
                                   "Error: Failed to sync"
                                   " slice index of disabled entry [%d]\n"),
                                   entry_index));
                        return rv;
                    }
                    _FP_SLICEIDX_BMP_ADD(sliceidx_bmp,
                                          slice_offset + tcam_index);
                }
            }
        }
        fgtemp = fgtemp->next;
    }
    /* sync the data */
    sal_memcpy (&buf[fc->scache_pos], ((sliceidx_bmp).w), size);
    fc->scache_pos += size;

    sal_free(sliceidx_bmp.w);
    sliceidx_bmp.w = NULL;
    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_th_scache_sync
 *
 * Purpose:
 *     Save field module software state to external cache.
 *
 * Parameters:
 *     unit             - (IN) BCM device number
 *     fc               - (IN) Pointer to device field control structure
 *     stage_fc         - (IN) FP stage control info.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_scache_sync(int              unit,
                          _field_control_t *fc,
                          _field_stage_t   *stage_fc
                          )
{
    int                   idx;             /* Index to field entry.          */
    int                   mem_inst, inst;  /* Pipe Instance.                 */
    int                   rv = BCM_E_NONE; /* Operation return value.        */
    int                   efp_slice_mode;  /* Slice mode of EFP.             */
    int                   paired = 0;      /* TCAM paired status of a slice. */
    int                   ratio = 0;       /* TCAM entry ratio.              */
    int                   slice_idx;       /* Index of a slice in (V/I/E)FP  */
    uint8                 *buf;            /* Pointer to 1st scache part.    */
    uint8                 *buf1;           /* Pointer to 2nd scache part.    */
    uint32                start_char;      /* Start character for (V/I/E)FP  */
    uint32                end_char;        /* End caharacter for (V/I/E)FP.  */
    uint32                val;             /* Carry Register contents.       */
    uint64                rval;            /* Carry register contents.       */
    _field_slice_t        *fs;             /* Slice pointer.                 */
    _field_group_t        *fg;             /* Filed group pointer.           */
    _field_data_control_t *data_ctrl;      /* UDF control data pointer.      */
    _field_entry_t        *f_ent;          /* Pointer to field entry.        */
    soc_field_t           fld;             /* field in any memory/register.  */
    soc_reg_t             vfp_control_1_reg;
    soc_reg_t             efp_slice_control_reg;
#ifdef BCM_FIREBOLT6_SUPPORT
    int entry_dw, total_indexes;
    soc_info_t *si;
#endif

    soc_field_t _efp_slice_mode[] = {SLICE_0_MODEf, SLICE_1_MODEf,
                                     SLICE_2_MODEf, SLICE_3_MODEf};

    buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    buf1 = fc->scache_ptr[_FIELD_SCACHE_PART_1];


    switch (stage_fc->stage_id) {
        case _BCM_FIELD_STAGE_INGRESS:
            start_char = _FIELD_IFP_DATA_START;
            end_char = _FIELD_IFP_DATA_END;
            break;
        case _BCM_FIELD_STAGE_EGRESS:
            start_char = _FIELD_EFP_DATA_START;
            end_char = _FIELD_EFP_DATA_END;
            break;
        case _BCM_FIELD_STAGE_LOOKUP:
            start_char = _FIELD_VFP_DATA_START;
            end_char = _FIELD_VFP_DATA_END;
            break;
        case _BCM_FIELD_STAGE_EXTERNAL:
            /*
            if (_field_tr2_ext_scache_sync_chk(unit, fc, stage_fc)) {
                return (_field_tr2_ext_scache_sync(unit, fc, stage_fc));
            } */
            start_char = _FIELD_EXTFP_DATA_START;
            end_char   = _FIELD_EXTFP_DATA_END;
            break;
        case _BCM_FIELD_STAGE_CLASS:
            start_char = _FIELD_CLASS_DATA_START;
            end_char = _FIELD_CLASS_DATA_END;
            break;
        case _BCM_FIELD_STAGE_EXACTMATCH:
            start_char = _FIELD_EM_DATA_START;
            end_char = _FIELD_EM_DATA_END;
            break;
#if defined(BCM_HELIX5_SUPPORT)
        case _BCM_FIELD_STAGE_FLOWTRACKER:
            start_char = _FIELD_FT_DATA_START;
            end_char = _FIELD_FT_DATA_END;
            break;
#endif
#if defined(BCM_FIREBOLT6_SUPPORT)
        case _BCM_FIELD_STAGE_AMFTFP:
            start_char = _FIELD_AMFTFP_DATA_START;
            end_char = _FIELD_AMFTFP_DATA_END;
            break;
        case _BCM_FIELD_STAGE_AEFTFP:
            start_char = _FIELD_AEFTFP_DATA_START;
            end_char = _FIELD_AEFTFP_DATA_END;
            break;
#endif
        default:
            return BCM_E_PARAM;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d): _bcm_field_th_scache_sync() - "
                          "Synching scache for FP stage %d...\n"),
               unit, stage_fc->stage_id));


    if (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
        BCM_IF_ERROR_RETURN(_bcm_field_th_stage_ingress_sync(unit,
                                                             stage_fc));
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d): _bcm_field_th_scache_sync() -"
                              " Writing end of section @ byte %d.\n"),
                   unit, fc->scache_pos));

        /* Mark the end of the IFP section */
        buf[fc->scache_pos] = end_char & 0xFF;
        fc->scache_pos++;
        buf[fc->scache_pos] = (end_char >> 8) & 0xFF;
        fc->scache_pos++;
        buf[fc->scache_pos] = (end_char >> 16) & 0xFF;
        fc->scache_pos++;
        buf[fc->scache_pos] = (end_char >> 24) & 0xFF;
        fc->scache_pos++;
        fc->scache_usage = fc->scache_pos; /* Usage in bytes */

        return BCM_E_NONE;
    }

    _field_scache_stage_hdr_save(fc, start_char);

    if (stage_fc->stage_id == _BCM_FIELD_STAGE_CLASS) {
        BCM_IF_ERROR_RETURN(_bcm_field_th_stage_class_sync(unit, fc, stage_fc));
        _field_scache_stage_hdr_save(fc, end_char);
        return BCM_E_NONE;
    }

    if (stage_fc->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        BCM_IF_ERROR_RETURN(_bcm_field_th_stage_em_sync(unit, fc, stage_fc));
        _field_scache_stage_hdr_save(fc, end_char);
        return BCM_E_NONE;
    }

#if defined(BCM_HELIX5_SUPPORT)
    if (stage_fc->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER) {
        BCM_IF_ERROR_RETURN(_bcm_field_stage_ft_sync(unit, fc, stage_fc));
        _field_scache_stage_hdr_save(fc, end_char);
        return BCM_E_NONE;
    }
#endif

#if defined(BCM_FIREBOLT6_SUPPORT)
    if (stage_fc->stage_id == _BCM_FIELD_STAGE_AMFTFP) {
        BCM_IF_ERROR_RETURN(_bcm_field_stage_amftfp_sync(unit, fc, stage_fc));
        _field_scache_stage_hdr_save(fc, end_char);
        return BCM_E_NONE;
    }

    if (stage_fc->stage_id == _BCM_FIELD_STAGE_AEFTFP) {
        BCM_IF_ERROR_RETURN(_bcm_field_stage_aeftfp_sync(unit, fc, stage_fc));
        _field_scache_stage_hdr_save(fc, end_char);
        return BCM_E_NONE;
    }
#endif

    if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_10) {
       /* Save Stage operational mode in the first byte after Data Start */
       buf[fc->scache_pos] = stage_fc->oper_mode;

       LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                "%s(): Writing oper_mode[%d] for Stage:%d @ byte s_pos=%d s_pos=%d...\n\r"),
                __func__, buf[fc->scache_pos], stage_fc->stage_id,
                fc->scache_pos, fc->scache_pos1));
       fc->scache_pos++;
    }

#ifdef BCM_FIREBOLT6_SUPPORT
    if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_30) {
        if (soc_feature(unit, soc_feature_efp_meter_noread) &&
            (stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS) &&
            (SOC_MEM_IS_VALID(unit, EFP_METER_TABLE_PIPE0m))) {

            si = &SOC_INFO(unit);
            entry_dw = soc_mem_entry_words(unit, EFP_METER_TABLE_PIPE0m);
            total_indexes = soc_mem_index_count(unit, EFP_METER_TABLE_PIPE0m);

            sal_memcpy(&buf[fc->scache_pos], si->efp_meter_table,
                entry_dw * total_indexes * sizeof(uint32));

            fc->scache_pos += (entry_dw * total_indexes * sizeof(uint32));
        }
    }
#endif /* BCM_FIREBOLT6_SUPPORT */


    /* Save data qualifiers */
    if ((data_ctrl = stage_fc->data_ctrl) != 0) {
        if (soc_mem_is_valid(unit, FP_UDF_TCAMm)) {
            /* Device has UDF TCAM =>
               Save internal information regarding TCAM entry usage
            */

            _field_data_tcam_entry_t *p;
            unsigned                 n;

            for (p = data_ctrl->tcam_entry_arr,
                     n = soc_mem_index_count(unit, FP_UDF_TCAMm);
                 n;
                 --n, ++p
                 ) {
                buf[fc->scache_pos] = p->ref_count;
                fc->scache_pos++;
            }
        }

        _field_scache_sync_data_quals_write(fc, data_ctrl);
    }

    /* Iterate for stage's instances. */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {
              continue;
         }
       _field_th_slice_map_write(unit, fc, inst, stage_fc);
    }
    if (((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_27) &&
        ((stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP) ||
        (stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS) )) {
        /* create and sync the slice index bmp*/
        BCM_IF_ERROR_RETURN(_bcm_field_wb_slice_index_bmp_write(unit,
            fc, stage_fc));
    }

    /* Iterate for stage's instances. */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {
              continue;
         }
       if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
           mem_inst = _FP_GLOBAL_INST;
       } else {
           mem_inst = inst;
       }

       BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, VFP_KEY_CONTROL_1r,
                                                   mem_inst, &vfp_control_1_reg));

       BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, EFP_SLICE_CONTROLr,
                                                mem_inst, &efp_slice_control_reg));

       for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
          LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d): _bcm_field_th_scache_sync() - "
                              "Checking slice %d...\n"),
                   unit, slice_idx));
          /* Skip slices without groups */
          fs = stage_fc->slices[inst] + slice_idx;
          fg = fc->groups;
          while (fg != NULL) {
             if ((fg->instance == inst) &&
                 (fg->stage_id == stage_fc->stage_id) &&
                 (fg->slices[0].slice_number == slice_idx)) {
                 break;
             }
             fg = fg->next;
          }

          if (fg == NULL) {
             continue; /* No group found */
          }

          /* Also skip expanded slices */
          if (stage_fc->slices[inst][slice_idx].prev != NULL) {
              continue;
          }

          paired = 0;

          /* Ignore secondary slice in paired mode */
          switch (stage_fc->stage_id) {
              case _BCM_FIELD_STAGE_EGRESS:
                BCM_IF_ERROR_RETURN(soc_reg32_get(unit,
                                                  efp_slice_control_reg,
                                                  REG_PORT_ANY, 0, &val));
                efp_slice_mode = soc_reg_field_get(unit,
                                               efp_slice_control_reg,
                                               val, _efp_slice_mode[slice_idx]);

                if ((efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE)
                    || (efp_slice_mode
                    == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY)
                    || (efp_slice_mode
                    == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6)) {
                    paired = 1;
                }
                break;

              case _BCM_FIELD_STAGE_LOOKUP:
                BCM_IF_ERROR_RETURN(soc_reg_get(unit,
                                                vfp_control_1_reg,
                                                REG_PORT_ANY, 0, &rval));
                fld = _bcm_field_trx_slice_pairing_field[slice_idx / 2];
                paired = soc_reg64_field32_get(unit,
                                               vfp_control_1_reg,
                                               rval, fld);
                break;
              default:
                return BCM_E_PARAM;
                break;
          }

          if (paired && (slice_idx % 2)) {
             continue;
          }

          BCM_IF_ERROR_RETURN
              (_field_tr2_group_entry_write(unit, inst, slice_idx, fs,
                                            fc, stage_fc));
       }
    }

    /* Now sync the expanded slices */
    /* Iterate for stage's instances. */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {
              continue;
         }
       if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
           mem_inst = _FP_GLOBAL_INST;
       } else {
           mem_inst = inst;
       }

       BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, VFP_KEY_CONTROL_1r,
                                                   mem_inst, &vfp_control_1_reg));

       BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit, EFP_SLICE_CONTROLr,
                                                mem_inst, &efp_slice_control_reg));

       for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
          fs = stage_fc->slices[inst] + slice_idx;
          /* Skip empty slices */
          if (fs->entry_count == fs->free_count) {
              LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d): _bcm_field_th_scache_sync() - "
                                  "Slice is empty.\n"),
                       unit));
               continue;
          }

          /* Skip master slices */
          if (stage_fc->slices[inst][slice_idx].prev == NULL) {
              continue;
          }

         /*
          * Skip expanded slices with no entries installed in Hw
          * to match recovery logic.
          */
          if (fs->group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
              ratio = 2;
          } else {
              ratio = 1;
          }

          for (idx = 0; idx < fs->entry_count / ratio; idx++) {
             /* Find EID that matches this HW index */
             f_ent = fs->entries[idx];
             if (f_ent == NULL) {
                continue;
             }
             if (!(f_ent->flags & _FP_ENTRY_INSTALLED)) {
                continue;
             }
             break;
          }

          if (idx == (fs->entry_count / ratio)) {
             continue;
          }

          paired = 0;

          /* Ignore secondary slice in paired mode */
          switch (stage_fc->stage_id) {
              case _BCM_FIELD_STAGE_EGRESS:
                  BCM_IF_ERROR_RETURN(soc_reg32_get(unit,
                                                  efp_slice_control_reg,
                                                  REG_PORT_ANY, 0, &val));
                  efp_slice_mode = soc_reg_field_get(unit,
                                               efp_slice_control_reg,
                                               val, _efp_slice_mode[slice_idx]);
                  if ((efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE)
                      || (efp_slice_mode
                      == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY)
                      || (efp_slice_mode
                      == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6)) {
                      paired = 1;
                  }
                  break;

              case _BCM_FIELD_STAGE_LOOKUP:
                  BCM_IF_ERROR_RETURN(soc_reg_get(unit,
                                                  vfp_control_1_reg,
                                                  REG_PORT_ANY, 0, &rval));
                  fld = _bcm_field_trx_slice_pairing_field[slice_idx / 2];
                  paired = soc_reg64_field32_get(unit,
                                                 vfp_control_1_reg,
                                                 rval, fld);
                  break;
              default:
                 return BCM_E_PARAM;
                 break;
          }
          if (paired && (slice_idx % 2)) {
             continue;
          }
          BCM_IF_ERROR_RETURN
              (_field_tr2_group_entry_write(unit, inst, slice_idx,
                                            fs, fc, stage_fc));
       } /* Slices */
    } /* instance */

    if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_15) {
       /* Mark end of Slice Info */
       buf[fc->scache_pos] = _FP_WB_END_OF_SLICES;
       fc->scache_pos++;
    }

    if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_15) {
       if ( stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS ||
            stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP) {
           LOG_DEBUG(BSL_LS_BCM_FP,
                   (BSL_META_U(unit,"FP(unit %d) vverb:"
                               "_bcm_field_td2_scache_sync() -section "
                               "Writing  HintIds information @ byte %d.\n"),
                                                       unit, fc->scache_pos));
           BCM_IF_ERROR_RETURN (_bcm_hints_scache_hintid_sync (unit, stage_fc,
                       &buf[fc->scache_pos]));
       }
    }

    if ((fc->wb_current_version) >= BCM_FIELD_WB_VERSION_1_15) {
        /* Group Slice Selectors */
        if ((stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP)
             || (stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            BCM_IF_ERROR_RETURN(_field_group_slice_selectors_sync(unit,
                            &buf[fc->scache_pos], stage_fc->stage_id));
        }
    }

    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
               "%s(): Writing end of section scache1 for stage:%s @ byte %d.\n"),
               __func__,
              (stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP)?"Lookup":"Egress",
               fc->scache_pos));

    /* Mark the end of the section */
    buf[fc->scache_pos] = end_char & 0xFF;
    fc->scache_pos++;
    buf[fc->scache_pos] = (end_char >> 8) & 0xFF;
    fc->scache_pos++;
    buf[fc->scache_pos] = (end_char >> 16) & 0xFF;
    fc->scache_pos++;
    buf[fc->scache_pos] = (end_char >> 24) & 0xFF;
    fc->scache_pos++;
    fc->scache_usage = fc->scache_pos; /* Usage in bytes */

    if(NULL != buf1) {
        LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
               "%s(): Writing end of section scache2 for stage:%s @ byte %d.\n"),
               __func__,
              (stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP)?"Lookup":"Egress",
               fc->scache_pos1));
        /* Mark the end of the section */
        buf1[fc->scache_pos1] = end_char & 0xFF;
        fc->scache_pos1++;
        buf1[fc->scache_pos1] = (end_char >> 8) & 0xFF;
        fc->scache_pos1++;
        buf1[fc->scache_pos1] = (end_char >> 16) & 0xFF;
        fc->scache_pos1++;
        buf1[fc->scache_pos1] = (end_char >> 24) & 0xFF;
        fc->scache_pos1++;
    }

    /* Check for overflow */
    if (fc->scache_pos > fc->scache_size[_FIELD_SCACHE_PART_0]) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: Current Scache Position[%u] exceeds Scache size[%u]\n"),
                 unit, fc->scache_pos, fc->scache_size[_FIELD_SCACHE_PART_0]));
        return BCM_E_INTERNAL;
    }

    if (buf1 != NULL) {
        if (fc->scache_pos1 > fc->scache_size[_FIELD_SCACHE_PART_1]) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: Current Scache Position1[%u] exceeds Scache size[%u]\n"),
                     unit, fc->scache_pos1, fc->scache_size[_FIELD_SCACHE_PART_1]));
            return BCM_E_INTERNAL;
        }
    }

    return rv;
}

STATIC int
_field_th_slice_expanded_status_get(int unit, int inst,
                                    _field_control_t *fc,
                                    _field_stage_t *stage_fc,
                                    int *expanded, int *slice_master_idx)
{
    int i, vslice, slice_idx = 0, vgroup = -1, max = -1, slice_num_max = 0;
    uint32 map_entry;
    soc_reg_t  slice_map_reg = INVALIDr;
    soc_field_t fld;
    uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    int   mem_inst;
    int   instance;

    mem_inst = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                _FP_GLOBAL_INST : inst;

    switch (stage_fc->stage_id) {
        case _BCM_FIELD_STAGE_EGRESS:
             BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                                EFP_SLICE_MAPr,
                                                                mem_inst,
                                                               &slice_map_reg));
             slice_num_max = 4;
             break;
        case _BCM_FIELD_STAGE_LOOKUP:
             BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                                VFP_SLICE_MAPr,
                                                                mem_inst,
                                                               &slice_map_reg));
             slice_num_max = 4;
             break;
        default:
             return BCM_E_PARAM;
             break; /* Should never happen */
    }

    if ((fc->l2warm)
        && ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_8)) {
        for (i = 0; i < slice_num_max; i++) {
            if ((fc->wb_recovered_version) < BCM_FIELD_WB_VERSION_1_26) {
                expanded[i] = buf[fc->scache_pos] & 0x1;
                slice_master_idx[i] = (buf[fc->scache_pos] >> 1) & 0x3;
                instance = ((buf[fc->scache_pos] >> 6) & 0x3);

                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                    "%s(): Recovering inst[%d] expanded[%d] master_slice[%d]"
                    " for slice[%d] val:%d @ byte %d...\n\r"), __func__,
                    instance, expanded[i], slice_master_idx[i], i,
                    buf[fc->scache_pos], fc->scache_pos));

                if (instance != inst) {
                   LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                     "%s(): Wrong Instance:%d Recovered instead of inst:%d"
                     " @ byte %d...\n\r"),
                     __func__, instance, inst, fc->scache_pos));
                   return BCM_E_INTERNAL;
                }
            } else {
                expanded[i] = buf[fc->scache_pos] & 0x1;
                slice_master_idx[i] = (buf[fc->scache_pos] >> 1);

                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                    "%s(): Recovering expanded[%d] master_slice[%d]"
                    " for slice[%d] val:%d @ byte %d...\n\r"), __func__,
                    expanded[i], slice_master_idx[i], i,
                    buf[fc->scache_pos], fc->scache_pos));

                fc->scache_pos++;
                instance = ((buf[fc->scache_pos]) & 0xf);

                LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                    "%s(): Recovering instance[%d] @ byte %d...\n\r"), __func__,
                    instance,  fc->scache_pos));

                if (instance != inst) {
                   LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                     "%s(): Wrong Instance:%d Recovered instead of inst:%d"
                     " @ byte %d...\n\r"),
                     __func__, instance, inst, fc->scache_pos));
                   return BCM_E_INTERNAL;
                }
            }
            fc->scache_pos++;
        }
    }

    /* Iterate over virtual slices to get physical slices and virtual groups */
    for (vslice = 0; vslice < slice_num_max; vslice++) {
        BCM_IF_ERROR_RETURN(soc_reg32_get(unit, slice_map_reg,
                            REG_PORT_ANY, 0, &map_entry));
        fld = vfp_efp_virtual_to_physical_map[vslice];
        slice_idx = soc_reg_field_get(unit, slice_map_reg,
                                      map_entry, fld);
        /* Now get virtual group for this virtual slice */
        fld = vfp_efp_virtual_to_group_map[vslice];
        vgroup = soc_reg_field_get(unit, slice_map_reg,
                                   map_entry, fld);

        /* Phys slice_idx <=> virtual vslice <=> vgroup */
        stage_fc->vmap[inst][0][vslice].vmap_key = slice_idx;
        stage_fc->vmap[inst][0][vslice].virtual_group = vgroup;
        stage_fc->vmap[inst][0][vslice].priority = vgroup;
        
    }

    /* See if virtual slice is the highest number in the virtual group */
    for (vslice = 0; vslice < slice_num_max; vslice++) {
        max = -1;
        for (i = 0; i < slice_num_max; i++) {
           if ((stage_fc->vmap[inst][0][vslice].virtual_group ==
                stage_fc->vmap[inst][0][i].virtual_group)) {
                if (i > max) {
                    max = i;
                }
            }
        }
        if (!((fc->l2warm) && ((fc->wb_recovered_version)
            >= BCM_FIELD_WB_VERSION_1_8))) {
            if ((max != vslice) && (max != -1)) {
                expanded[stage_fc->vmap[inst][0][vslice].vmap_key] = 1;
            }
        }
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_field_th_egress_secondary_selcode_set
 *
 * Purpose:
 *     Sets the secondary select codes based on field values in different
 *     registers EFP_CLASSID_SELECTORr, EFP_KEY4_DVP_SELECTORr and
 *     EFP_KEY4_MDL_SELECTORr.
 *
 * Parameters:
 *     unit             - (IN) BCM unit number.
 *     fg               - (IN/OUT) Select code information filled into the group
 *     slice_idx        - (IN) Slice id
 *     part_idx         - (IN) Part id of the given slice in the given group
 *
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_bcm_field_th_egress_secondary_selcodes_set(int unit, _field_group_t *fg,
                                             int slice_idx, uint8 part_idx)
{
    soc_field_t field;   /* H/W Register field.            */
    uint64 reg_val64;    /* 64 bit H/W Register value.     */
    uint32 fldval;       /* Field in a H/W register value. */
    uint8  num_fields;   /* Number of fields.              */
    soc_reg_t reg;       /* H/W register.                  */
    int rv = BCM_E_NONE; /* Operation status.              */
    int idx;             /* Index.                         */
    int inst;            /* Instance.                      */
    _field_stage_t     *stage_fc = NULL;
    soc_reg_t       efp_classid_sel_reg;
    soc_reg_t       efp_key4_dvp_reg;
    soc_reg_t       efp_key4_mdl_reg;
    soc_reg_t       efp_key8_dvp_reg;
    soc_reg_t       efp_key4_class_reg;
    soc_reg_t       efp_key8_class_reg;

    if (NULL == fg) {
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit, _BCM_FIELD_STAGE_EGRESS, &stage_fc));
    if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
       inst = _FP_GLOBAL_INST;
    } else {
       inst = fg->instance;
    }

    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                       EFP_CLASSID_SELECTORr,
                                                       inst,
                                                       &efp_classid_sel_reg));
    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                   EFP_KEY4_DVP_SELECTORr,
                                                   inst, &efp_key4_dvp_reg));
    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                   EFP_KEY8_DVP_SELECTORr,
                                                   inst, &efp_key8_dvp_reg));
    BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                   EFP_KEY4_MDL_SELECTORr,
                                                   inst, &efp_key4_mdl_reg));
    if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                        EFP_KEY4_L3_CLASSID_SELECTORr,
                                                        inst,
                                                        &efp_key4_class_reg));
        BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                        EFP_KEY8_L3_CLASSID_SELECTORr,
                                                        inst,
                                                        &efp_key8_class_reg));
    }

    fg->sel_codes[part_idx].egr_class_f1_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_class_f2_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_class_f3_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_class_f4_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_class_f6_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_class_f7_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_class_f8_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_key4_dvp_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_key8_dvp_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_key4_mdl_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_key4_l3_classId_sel = _FP_SELCODE_DONT_CARE;
    fg->sel_codes[part_idx].egr_key8_l3_classId_sel = _FP_SELCODE_DONT_CARE;

    reg = efp_classid_sel_reg;
    rv = soc_reg_get(unit, reg, REG_PORT_ANY, 0, &reg_val64);
    num_fields = sizeof(classfldtbl[0]) /
                   sizeof(classfldtbl[0][0]);

    if (BCM_SUCCESS(rv)) {
        for (idx = 0 ; idx < num_fields; idx++) {
            field = classfldtbl[slice_idx][idx];
            if (!soc_reg_field_valid(unit, reg, field)) {
                continue;
            }

            fldval = soc_reg64_field_get(unit, reg, reg_val64, field);

            switch(idx) {
                case 0:
                     fg->sel_codes[part_idx].egr_class_f1_sel = fldval;
                     break;
                case 1:
                     fg->sel_codes[part_idx].egr_class_f2_sel = fldval;
                     break;
                case 2:
                     fg->sel_codes[part_idx].egr_class_f3_sel = fldval;
                     break;
                case 3:
                     fg->sel_codes[part_idx].egr_class_f4_sel = fldval;
                     break;
                case 4:
                     fg->sel_codes[part_idx].egr_class_f6_sel = fldval;
                     break;
                case 5:
                     fg->sel_codes[part_idx].egr_class_f7_sel = fldval;
                     break;
                case 6:
                     fg->sel_codes[part_idx].egr_class_f8_sel = fldval;
                     break;
                default:
                     LOG_ERROR(BSL_LS_BCM_FP,
                               (BSL_META_U(unit,
                                           "FP(unit %d) Error:Invalid field in efp classid selector \n"),
                                unit));
                     return BCM_E_INTERNAL;
            }
        }
    }

    if (!soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        reg = efp_key4_dvp_reg;
        rv = soc_reg_get(unit, reg, REG_PORT_ANY, 0, &reg_val64);

        if (BCM_SUCCESS(rv)) {
            field = dvpfldtbl[slice_idx];
            if (soc_reg_field_valid(unit, reg, field)) {
                fldval = soc_reg_field_get(unit, reg, reg_val64, field);
                fg->sel_codes[part_idx].egr_key4_dvp_sel = fldval;
            }
        }

        reg = efp_key8_dvp_reg;
        rv = soc_reg_get(unit, reg, REG_PORT_ANY, 0, &reg_val64);

        if (BCM_SUCCESS(rv)) {

            field = dvpfldtbl[slice_idx];
            if (soc_reg_field_valid(unit, reg, field)) {

                fldval = soc_reg_field_get(unit, reg, reg_val64, field);
                fg->sel_codes[part_idx].egr_key8_dvp_sel = fldval;
            }
        }
    }

    reg = efp_key4_mdl_reg;
    rv = soc_reg_get(unit, reg, REG_PORT_ANY, 0, &reg_val64);

    if (BCM_SUCCESS(rv)) {
        field = mdlfldtbl[slice_idx];
        if (soc_reg_field_valid(unit, reg, field)) {

            fldval = soc_reg_field_get(unit, reg, reg_val64, field);
            fg->sel_codes[part_idx].egr_key4_mdl_sel = fldval;
        }
    }

#if defined (BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        reg = efp_key4_class_reg;
        rv = soc_reg_get(unit, reg, REG_PORT_ANY, 0, &reg_val64);

        if (BCM_SUCCESS(rv)) {
            field = classIdBfldtbl[slice_idx];
            if (soc_reg_field_valid(unit, reg, field)) {

                fldval = soc_reg_field_get(unit, reg, reg_val64, field);
                fg->sel_codes[part_idx].egr_key4_l3_classId_sel = fldval;
            }
        }
        reg = efp_key8_class_reg;
        rv = soc_reg_get(unit, reg, REG_PORT_ANY, 0, &reg_val64);

        if (BCM_SUCCESS(rv)) {
            field = classIdBfldtbl[slice_idx];
            if (soc_reg_field_valid(unit, reg, field)) {

                fldval = soc_reg_field_get(unit, reg, reg_val64, field);
                fg->sel_codes[part_idx].egr_key8_l3_classId_sel = fldval;
            }
        }

    }
#endif

    return BCM_E_NONE;
}

/*
 * Function:
 *  _bcm_field_th_stage_egress_reinit
 * Description:
 *  Service routine used to retain the software sate of
 *  EFP(Egress Field Processor) configuration .
 * Parameters:
 *   unit     - (IN) BCM device number.
 *   fc       - (IN) Field control structure.
 *   stage_fc - (IN/OUT) Stage field control structure.
 * Returns:
 *  BCM_E_XXX
 * Notes:
 *  None.
 */
int
_bcm_field_th_stage_egress_reinit(int unit, _field_control_t *fc,
                               _field_stage_t *stage_fc)
{
    char *efp_policy_buf = NULL;  /* Buffer to read the EFP_POLICY table      */
    char *efp_policy_pipe_buf[_FP_MAX_NUM_PIPES+1] = {NULL};
                                  /* Buffer for EFP_POLICY_TABLE pipes.       */
    int  idx;                     /* Index to field entry.                    */
    int  idx1;
    int slice_idx;                /* Slice index in (V/I/E)FP.                */
    int vslice_idx;               /* Slice index in a virtual group.          */
    int index_min;                /* Min index of a memory.                   */
    int index_max;                /* Max index of a field memory.             */
    int rv = BCM_E_NONE;          /* Operation status.                        */
    int mem_sz;                   /* Size of the memory.                      */
    int slice_ent_cnt = 0;        /* Entry count in a slice.                  */
    int parts_count = 1;          /* Parts count in a field group.            */
    int i;                        /* Used to loop through parts i
                                     in a field group.                        */
    int pri_tcam_idx;             /* Priority of an entry in TCAM.            */
    int part_index;               /* Index to part(s) in a field group.       */
    int slice_number;             /* (V/I/E) slice number.                    */
    int phys_tcam_idx;            /* Index to physical TCAM in (V/I/E)FP.     */
    int prev_prio;                /* Priority of previous field entry.        */
    int expanded[_FP_MAX_NUM_PIPES][4];
                                  /* Expansion status of slices in (V/I/E)FP. */
    int slice_master_idx[_FP_MAX_NUM_PIPES][4];
                                  /* Expansion status of slices in (V/I/E)FP. */
    int priority;                 /* Priority of a field entry.               */
    int multigroup;               /* Field group's multigroup status.         */
    int max;                      /*Temporary variable.                       */
    int master_slice;             /* Master slice number for expanded group.  */
    uint8 *buf = NULL;            /* Pointer to 1st scache part.              */
    uint8 *buf1 = NULL;           /* Pointer to 2nd scache part.              */
    uint8 old_physical_slice;     /* Physical slice number.                   */
    uint8 slice_num;              /* Physical slice number.                   */
    uint16 default_key_1;         /* Default selcode of a field group in EFP. */
    uint16 default_key_2;         /* Default selcode of a field group in EFP. */
    uint32 *efp_tcam_buf = NULL;  /* Buffer to read the EFP_TCAM table.       */
    uint32 *efp_tcam_pipe_buf[_FP_MAX_NUM_PIPES+1] = {NULL};
                                  /* Buffer to read EFP_TCAM table.      */
    uint32 rval;                  /* Holds conetets of register.              */
    uint32 efp_slice_mode;        /* Mode of a slice in EFP.                  */
    uint32 efp_slice_ipv6_mode;   /* IPv6 mode of a slice in EFP.             */
    uint32 temp;                  /* Temporary varibale.                      */
    uint32 key_match_type[2];     /* Key match types of field group in EFP.   */
    uint32 entry_type = 0;        /* Type of entry of filed group in EFP.     */
    uint32 efp_key_type_offset = 0;/* Type of entry of filed group in EFP.     */
    uint32 entry_flags;           /* Flags set for a entry in field group.    */
    _field_slice_t *fs = NULL;    /* Slice pointer.                           */
    _field_group_t *fg = NULL;    /* Filed group pointer.                     */
    _field_entry_t *f_ent = NULL; /* Field entry pointer.                     */
    bcm_field_group_t gid;        /* Field group ID.                          */
    bcm_field_qset_t qset;        /* QSET of field group.                     */
    bcm_pbmp_t all_pbmp;          /* Port Bit Map.                            */
    bcm_pbmp_t group_pbmp;        /* Port Bit Map.                            */
    _field_action_t *fa = NULL;   /* Field Action Structure */
    int group_flags = 0;
    int action_res_id;
    int   inst, mem_inst, instance;   /* Pipe Instances */
    _field_entry_oam_wb_t *f_ent_oam_wb = NULL;
    _field_entry_policer_wb_t *f_ent_policer_wb = NULL;
    _field_slice_t *fs_temp = NULL;                    /* Slice pointer. */
    int8               efp_key_info[2];
    efp_tcam_entry_t *efp_tcam_entry = NULL;           /* Buffer to hold
                                                          contents of entry in
                                                          EFP_TCAM entry. */
    efp_policy_table_entry_t *efp_policy_entry = NULL; /* Buffer to hold
                                                          contetnts of entry in
                                                          EFP_POLICY_TABLE. */


    soc_field_t efp_en_flds[4] = {SLICE_ENABLE_SLICE_0f, SLICE_ENABLE_SLICE_1f,
                                  SLICE_ENABLE_SLICE_2f, SLICE_ENABLE_SLICE_3f};

    _field_action_bmp_t action_bmp;
    _field_entry_wb_info_t f_ent_wb_info;
    soc_reg_t efp_slice_control_reg;
    soc_mem_t efp_tcam;
    soc_mem_t efp_policy_table;

#ifdef BCM_FIREBOLT6_SUPPORT
    int entry_dw, total_indexes, indx;
    soc_info_t *si;
#endif

    int size;
    int slice_size;
    _field_sliceidx_bmp_t sliceidx_bmp;
    int slice_offset;
    int tcam_valid_val = 0;
    sliceidx_bmp.w = NULL;
    slice_size = 0;
    slice_offset = 0;
#if defined (BCM_TOMAHAWK3_SUPPORT)
    if (SOC_IS_TOMAHAWK3(unit)) {
        tcam_valid_val = 1;
    } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
    {
        tcam_valid_val = 3;
    }

    /* Reset Action bitmap to NULL. */
    action_bmp.w = NULL;
    buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    buf1 = fc->scache_ptr[_FIELD_SCACHE_PART_1];

    fc->scache_pos1 = 0;
    fc->scache_pos1 += SOC_WB_SCACHE_CONTROL_SIZE;

    sal_memset(expanded, 0, 4 * _FP_MAX_NUM_PIPES * sizeof(int));
    sal_memset(slice_master_idx, 0, 4 * _FP_MAX_NUM_PIPES * sizeof(int));

    /*
     * In Trident3, EFP_TCAM entry KEY field width is (272 + 2b VALID)
     * In Tomahawk, EFP_TCAM entry KEY field width is (240 + 2b VALID)
     */
#if defined (BCM_TOMAHAWK3_SUPPORT)
    if (SOC_IS_TOMAHAWK3(unit)) {
        /*for TH3, the KEY fields MINBIT is 1 as VALID is only 1 bit*/
        efp_key_type_offset = 236 + 1;
    } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
    {
        efp_key_type_offset = soc_feature(unit, soc_feature_td3_style_fp) ? \
                              (268 + 2) : (236 + 2);
    }

    if (fc->l2warm) {
        rv = _field_scache_stage_hdr_chk(fc, _FIELD_EFP_DATA_START);
        if (BCM_FAILURE(rv)) {
           return (rv);
        }

        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_10) {
           bcm_field_group_oper_mode_t oper_mode;

           /* Retrieve Stage Operational Mode. */
           oper_mode = buf[fc->scache_pos];

           LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                 "%s(): Recovering oper_mode:%d @ byte s_pos=%d s_po1=%d\n\r"),
                  __func__, oper_mode, fc->scache_pos, fc->scache_pos1));

           fc->scache_pos++;

           if (stage_fc->oper_mode != oper_mode) {
              /* Initialize the stage with the given operational mode. */
              rv = _bcm_field_th_group_oper_mode_set(unit,
                                                  bcmFieldQualifyStageEgress,
                                                  oper_mode);
              if (BCM_FAILURE(rv)) {
                 return rv;
              }

              rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_EGRESS,
                                         &stage_fc);
              BCM_IF_ERROR_RETURN(rv);
           }
        }
    }

#ifdef BCM_FIREBOLT6_SUPPORT
    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_30) {
        if (soc_feature(unit, soc_feature_efp_meter_noread) &&
            SOC_MEM_IS_VALID(unit, EFP_METER_TABLE_PIPE0m)) {

            si = &SOC_INFO(unit);
            entry_dw = soc_mem_entry_words(unit, EFP_METER_TABLE_PIPE0m);
            total_indexes = soc_mem_index_count(unit, EFP_METER_TABLE_PIPE0m);

            sal_memcpy((si->efp_meter_table), &(buf[fc->scache_pos]),
                entry_dw * total_indexes * sizeof(uint32));

            fc->scache_pos += (entry_dw * total_indexes * sizeof(uint32));

            /* Update the cache with this data. */
            for (indx=0; indx<total_indexes; indx++) {
                void *entry_data = NULL;

                entry_data = (si->efp_meter_table + (indx * entry_dw));
                _soc_mem_write_cache_update(unit, EFP_METER_TABLE_PIPE0m,
                    0, 0, indx, 0, entry_data, entry_data, NULL, NULL);
            }
        }
    }
#endif /* BCM_FIREBOLT6_SUPPORT */

    for (inst = 0; inst < stage_fc->num_instances; inst++) {
       if (!(fc->pipe_map & (1 << inst))) {
            continue;
       }
       mem_inst = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                   _FP_GLOBAL_INST : inst;
       instance = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                   _FP_MAX_NUM_PIPES : inst;

       BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit, EFP_TCAMm,
                                                          mem_inst, &efp_tcam));
       BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                          EFP_POLICY_TABLEm,
                                                          mem_inst,
                                                          &efp_policy_table));
       BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                             EFP_SLICE_CONTROLr,
                                             mem_inst, &efp_slice_control_reg));
       /* DMA various tables */
       efp_tcam_buf = soc_cm_salloc(unit, sizeof(efp_tcam_entry_t) *
                                soc_mem_index_count(unit, efp_tcam),
                                "EFP TCAM buffer");
       if (NULL == efp_tcam_buf) {
           rv = BCM_E_MEMORY;
           goto cleanup;
       }

       sal_memset(efp_tcam_buf, 0, sizeof(efp_tcam_entry_t) *
                       soc_mem_index_count(unit, EFP_TCAMm));

       index_min = soc_mem_index_min(unit, efp_tcam);
       index_max = soc_mem_index_max(unit, efp_tcam);
       fs = stage_fc->slices[inst];
       if (stage_fc->flags & _FP_STAGE_HALF_SLICE) {
           slice_ent_cnt = fs->entry_count * 2;
           /* DMA in chunks */
           for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
               fs = stage_fc->slices[inst] + slice_idx;
               if ((rv = soc_mem_read_range(unit,
                                efp_tcam, MEM_BLOCK_ALL,
                                slice_idx * slice_ent_cnt,
                                slice_idx * slice_ent_cnt + fs->entry_count - 1,
                                efp_tcam_buf + slice_idx * slice_ent_cnt *
                                soc_mem_entry_words(unit, efp_tcam)))
                   < 0 ) {
                   goto cleanup;
               }
           }
       } else {
           slice_ent_cnt = fs->entry_count;
           if ((rv = soc_mem_read_range(unit, efp_tcam, MEM_BLOCK_ALL,
                                        index_min, index_max,
                                        efp_tcam_buf)) < 0 ) {
               goto cleanup;
           }
       }

       efp_policy_buf = soc_cm_salloc(unit, SOC_MEM_TABLE_BYTES
                                     (unit, efp_policy_table),
                                     "EFP POLICY TABLE buffer");
       if (NULL == efp_policy_buf) {
           rv = BCM_E_MEMORY;
           goto cleanup;
       }
       sal_memset(efp_policy_buf, 0, SOC_MEM_TABLE_BYTES
                                    (unit, efp_policy_table));
       index_min = soc_mem_index_min(unit, efp_policy_table);
       index_max = soc_mem_index_max(unit, efp_policy_table);
       if ((rv = soc_mem_read_range(unit, efp_policy_table,
                                    MEM_BLOCK_ALL, index_min, index_max,
                                    efp_policy_buf)) < 0 ) {
            goto cleanup;
       }

       efp_tcam_pipe_buf[instance] = efp_tcam_buf;
       efp_policy_pipe_buf[instance] = efp_policy_buf;
       efp_tcam_buf = NULL;
       efp_policy_buf = NULL;
    }

    /* Get slice expansion status and virtual map for all the instances */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {

             continue;
        }
        if ((rv = _field_th_slice_expanded_status_get(unit, inst, fc, stage_fc,
                                 expanded[inst], slice_master_idx[inst])) < 0) {
             goto cleanup;
        }
    }

    slice_size = 0;
    if ((fc->l2warm) &&
        ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_27)) {
        /* get the total slice size*/
        slice_size = stage_fc->tcam_sz;
        size = SHR_BITALLOCSIZE(slice_size * _FP_MAX_NUM_PIPES);
        _FP_XGS3_ALLOC(sliceidx_bmp.w, size, "Sliceidx Bitmap");
        if (NULL == sliceidx_bmp.w) {
            rv = BCM_E_MEMORY;
            goto cleanup;
        }
        sal_memcpy (sliceidx_bmp.w, &buf[fc->scache_pos],
                    size);
        fc->scache_pos += size;
    }

    /* Iterate over the instances */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
       if (!(fc->pipe_map & (1 << inst))) {
            continue;
       }
       mem_inst = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                   _FP_GLOBAL_INST : inst;
       instance = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                   _FP_MAX_NUM_PIPES : inst;
       slice_offset = inst * slice_size;

       rv = _bcm_field_reg_instance_get(unit,
                                        EFP_SLICE_CONTROLr,
                                        mem_inst, &efp_slice_control_reg);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }
       rv = _bcm_field_mem_instance_get(unit, EFP_TCAMm,
                                        mem_inst, &efp_tcam);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }
       rv = _bcm_field_mem_instance_get(unit,
                                        EFP_POLICY_TABLEm,
                                        mem_inst,
                                        &efp_policy_table);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }

       if ((rv = soc_reg32_get(unit, efp_slice_control_reg,
                               REG_PORT_ANY, 0, &rval)) < 0) {
           goto cleanup;
       }

       /* Iterate over the slices */
       for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
           /* Ignore disabled slice */
           if (soc_reg_field_get(unit, efp_slice_control_reg, rval,
                                  efp_en_flds[slice_idx]) == 0) {
               continue;
           }

           /* Don't need to read selectors for expanded slice */
           if (expanded[inst][slice_idx]) {
              continue;
           }

           efp_slice_mode = soc_reg_field_get(unit,
                                          efp_slice_control_reg, rval,
                                          _th_efp_slice_mode[slice_idx][0]);
           efp_slice_ipv6_mode = soc_reg_field_get(unit,
                                          efp_slice_control_reg, rval,
                                          _th_efp_slice_mode[slice_idx][1]);

           /* Skip second part of slice pair */
           if (((efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE) ||
               (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY) ||
               (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6)) &&
               (slice_idx % 2)) {
               continue;
           }

           /* Skip if slice has no valid groups and entries */
           fs = stage_fc->slices[inst] + slice_idx;
           key_match_type[0] = ~0;
           key_match_type[1] = ~0;

           /* Get KEY_MATCH_TYPE from the valid entries of EFP_TCAM */
           for (idx = 0; idx < slice_ent_cnt; idx++) {
               efp_tcam_entry = soc_mem_table_idx_to_pointer(unit,
                                               efp_tcam,
                                               efp_tcam_entry_t *,
                                      efp_tcam_pipe_buf[instance],
                                 idx + slice_ent_cnt * slice_idx);

               if ((soc_mem_field32_get(unit, efp_tcam,
                   efp_tcam_entry, VALIDf) != 0) ||
                   ((fc->l2warm) &&
                   ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_27) &&
                   (_FP_SLICEIDX_BMP_TEST(sliceidx_bmp,
                   (idx + slice_ent_cnt * slice_idx) + slice_offset) ))) {

                   if (key_match_type[0] == ~0) {
                      _field_extract((uint32 *)efp_tcam_entry, efp_key_type_offset, 4,
                                     &key_match_type[0]);
                      continue;
                   }

                   if (key_match_type[1] == ~0) {
                      _field_extract((uint32 *)efp_tcam_entry, efp_key_type_offset, 4,
                                     &key_match_type[1]);
                      if (key_match_type[0] == key_match_type[1]) {
                          key_match_type[1] = ~0;
                      } else {
                         /* break once possible two key match types are
                          * extracted from the valid entries
                          */
                         break;
                      }
                   }
               }
           }

           if (key_match_type[0] == ~0 && !fc->l2warm) {
              continue;
           }

           fg = NULL;
           if (efp_slice_mode <= 5) { /* Valid values */
               /* If Level 2, retrieve the GIDs in this slice */
               if (fc->l2warm) {
                   rv = _field_trx_scache_slice_group_recover(unit,
                                                              fc,
                                                              inst,
                                                              slice_idx,
                                                              NULL,
                                                              stage_fc,
                                                              0);
                   if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
                      fc->l2warm = 0;
                      goto cleanup;
                   }
                   if (rv == BCM_E_NOT_FOUND) {
                      rv = BCM_E_NONE;
                      continue;
                   }
               }

               LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                 "# line[%d] inst[%d] slice[%d] byte @ s_pos=%d s_pos1=%d\n\r"),
                  __LINE__,inst,slice_idx, fc->scache_pos,fc->scache_pos1));
               LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                 "@ efp_slice_mode:[%d] inst[%d] slice[%d] key_match_type[0]=%d"
                 " key_match_type[1]=%d\n\r"), efp_slice_mode, inst, slice_idx,
                 key_match_type[0], key_match_type[1]));

               rv = _field_tr2_group_construct_alloc(unit, &fg);
               if (BCM_FAILURE(rv)) {
                  goto cleanup;
               }

               action_res_id = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;

               group_flags = 0;
               if (fc->l2warm) {
                  /* Get stored group ID and QSET for Level 2 */
                  rv = _field_group_info_retrieve(unit, -1, inst,
                                                  &gid, &priority,
                                                  &action_res_id,
                                                  &group_pbmp,
                                                  efp_key_info,
                                                  &group_flags,
                                                  &qset, fc);
                  sal_memcpy(&fg->qset, &qset, sizeof(bcm_field_qset_t));
               } else {
                  if ((rv = _bcm_field_group_id_generate(unit, &gid))
                                                      == BCM_E_NONE) {
                      unsigned vmap, vslice;

                      for (priority = -1, vmap = 0;
                           priority == -1 && vmap < _FP_VMAP_CNT; ++vmap) {
                          for (vslice = 0;
                               vslice < COUNTOF(stage_fc->vmap[inst][0]);
                               ++vslice) {
                             if (stage_fc->vmap[inst][vmap][vslice].vmap_key ==
                                                                   slice_idx) {
                                 priority =
                                    stage_fc->vmap[inst][vmap][vslice].priority;
                                 break;
                             }
                          }
                      }

                      if (priority == -1) {
                          rv = BCM_E_INTERNAL;
                      }
                  }
               }
               if (BCM_FAILURE(rv)) {
                  sal_free(fg);
                  goto cleanup;
               }

               fg->gid      = gid;
               fg->priority = priority;
               fg->action_res_id = action_res_id;
               fg->stage_id = stage_fc->stage_id;
               fg->instance = inst;

               if (fc->l2warm && ((fc->wb_recovered_version)
                   >= BCM_FIELD_WB_VERSION_1_16)) {
                   /* Update efp primary key value */
                   fg->sel_codes[0].fpf3 = efp_key_info[0];

                   /* Update efp secondary key value based on mode */
                   if ((efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE) ||
                           (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY) ||
                           (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6)) {
                       fg->sel_codes[1].fpf3 = efp_key_info[1];
                       parts_count = 2;
                       fg->flags |= _FP_GROUP_SPAN_DOUBLE_SLICE;
                   } else {
                       parts_count = 1;
                       fg->flags |= _FP_GROUP_SPAN_SINGLE_SLICE;
                   }

                   /* Update IPv6 mode */
                   if (efp_key_info[0] == _BCM_FIELD_EFP_KEY2) {
                       fg->sel_codes[0].ip6_addr_sel = efp_slice_ipv6_mode;
                   } else if (efp_key_info[1] == _BCM_FIELD_EFP_KEY2) {
                       fg->sel_codes[1].ip6_addr_sel = efp_slice_ipv6_mode;
                   }

                   for (part_index = 0; part_index < parts_count; part_index++) {
                       /* Populate all secondary selectors for the given group */
#if defined(BCM_TRIDENT3_SUPPORT)
                       if (soc_feature(unit, soc_feature_td3_style_fp)) {
                           rv = _bcm_field_td3_egress_secondary_selcodes_set(unit, fg,
                                   slice_idx + part_index,
                                   part_index);
                       } else
#endif
                       {
                           rv = _bcm_field_th_egress_secondary_selcodes_set(unit, fg,
                                   slice_idx + part_index,
                                   part_index);
                       }
                       if (BCM_FAILURE(rv)) {
                           sal_free(fg);
                           goto cleanup;
                       }
                   }

                   /* Store primary key's */
                   default_key_1 = fg->sel_codes[0].fpf3;
                   default_key_2 = fg->sel_codes[1].fpf3;

                   if (fg->flags & _FP_GROUP_SPAN_SINGLE_SLICE) {
                       rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                               stage_fc, _FP_ENTRY_TYPE_0, fg, -1, -1);
                       if (BCM_FAILURE(rv)) {
                           sal_free(fg);
                           goto cleanup;
                       }

                       /* Update secondary or default key for quals update */
                       fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY4;
                   } else {
                       switch(efp_slice_mode) {
                           case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6:
                           case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE:
                               rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                       stage_fc, _FP_ENTRY_TYPE_0, fg, -1, -1);
                               if (BCM_FAILURE(rv)) {
                                   sal_free(fg);
                                   goto cleanup;
                               }
                               /* Update secondary or default key for quals update */
                               fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY8;
                               fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
                               break;
                           case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY:
                               rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                       stage_fc, _FP_ENTRY_TYPE_0, fg, -1, -1);
                               if (BCM_FAILURE(rv)) {
                                   sal_free(fg);
                                   goto cleanup;
                               }
                               /* Update secondary or default key for quals update */
                               fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1;
                               fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
                               break;
                           default:
                               rv = BCM_E_INTERNAL;
                               sal_free(fg);
                               goto cleanup;
                       }
                   }

                   rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                           stage_fc, _FP_ENTRY_TYPE_1, fg,
                           default_key_1, default_key_2);
                   if (BCM_FAILURE(rv)) {
                       sal_free(fg);
                       goto cleanup;
                   }

                   /* Restore Primary Key */
                   fg->sel_codes[0].fpf3 = default_key_1;
                   fg->sel_codes[1].fpf3 = default_key_2;
               } else {
                   switch (efp_slice_mode) {

                       case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L2:
                           fg->flags |= _FP_GROUP_SPAN_SINGLE_SLICE;
                           fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY4;
                           parts_count = 1;

                           for (part_index = 0; part_index < parts_count; part_index++) {
                               /* Populate all secondary selectors for the given group */
#if defined(BCM_TRIDENT3_SUPPORT)
                               if (soc_feature(unit, soc_feature_td3_style_fp)) {
                                   rv = _bcm_field_td3_egress_secondary_selcodes_set(unit, fg,
                                           slice_idx + part_index,
                                           part_index);
                               } else
#endif
                               {
                                   rv = _bcm_field_th_egress_secondary_selcodes_set(unit, fg,
                                           slice_idx + part_index,
                                           part_index);
                               }
                               if (BCM_FAILURE(rv)) {
                                   sal_free(fg);
                                   goto cleanup;
                               }
                           }
                           rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                   stage_fc, _FP_ENTRY_TYPE_0, fg, -1, -1);
                           if (BCM_FAILURE(rv)) {
                               sal_free(fg);
                               goto cleanup;
                           }

                           rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                   stage_fc, _FP_ENTRY_TYPE_1, fg,
                                   fg->sel_codes[0].fpf3, -1);
                           if (BCM_FAILURE(rv)) {
                               sal_free(fg);
                               goto cleanup;
                           }
                           break;
                       case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3:
                           fg->flags |= _FP_GROUP_SPAN_SINGLE_SLICE;
                           parts_count = 1;


                           for (part_index = 0; part_index < parts_count; part_index++) {
                               /* Populate all secondary selectors for the given group */
#if defined(BCM_TRIDENT3_SUPPORT)
                               if (soc_feature(unit, soc_feature_td3_style_fp)) {
                                   rv = _bcm_field_td3_egress_secondary_selcodes_set(unit, fg,
                                           slice_idx + part_index,
                                           part_index);
                               } else
#endif
                               {
                                   rv = _bcm_field_th_egress_secondary_selcodes_set(unit, fg,
                                           slice_idx + part_index,
                                           part_index);
                               }
                               if (BCM_FAILURE(rv)) {
                                   sal_free(fg);
                                   goto cleanup;
                               }
                           }

                           if (efp_slice_ipv6_mode) {
                               fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY2;
                               default_key_1 = _BCM_FIELD_EFP_KEY2;
                               fg->sel_codes[0].ip6_addr_sel = efp_slice_ipv6_mode;
                           } else {
                               if ((key_match_type[0] == KEY_TYPE_IPv6_SINGLE) ||
                                       (key_match_type[1] == KEY_TYPE_IPv6_SINGLE) ||
                                   BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcIp6) ||
                                   BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyDstIp6) ||
                                   BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyIp6) ||
                                   BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifySrcIp6High) ||
                                   BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyDstIp6High)) {
                                   fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY2;
                                   default_key_1 = _BCM_FIELD_EFP_KEY2;
                                   fg->sel_codes[0].ip6_addr_sel = efp_slice_ipv6_mode;
                               } else {
                                   fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1;
                                   default_key_1 = _BCM_FIELD_EFP_KEY1;
                                   fg->sel_codes[0].ip6_addr_sel = _FP_SELCODE_DONT_CARE;
                               }
                           }

                           rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                   stage_fc, _FP_ENTRY_TYPE_0, fg, -1, -1);
                           if (BCM_FAILURE(rv)) {
                               sal_free(fg);
                               goto cleanup;
                           }

                           fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY4;
                           rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                   stage_fc, _FP_ENTRY_TYPE_1, fg,
                                   default_key_1, -1);
                           if (BCM_FAILURE(rv)) {
                               sal_free(fg);
                               goto cleanup;
                           }

                           fg->sel_codes[0].fpf3 = default_key_1;
                           if (efp_slice_ipv6_mode) {
                               fg->sel_codes[0].ip6_addr_sel = efp_slice_ipv6_mode;
                           }
                           else {
                               if (default_key_1 == _BCM_FIELD_EFP_KEY1) {
                                   fg->sel_codes[0].ip6_addr_sel = _FP_SELCODE_DONT_CARE;
                               }
                           }
                           break;
                       case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3_ANY:
                           fg->flags |= _FP_GROUP_SPAN_SINGLE_SLICE;
                           parts_count = 1;


                           for (part_index = 0; part_index < parts_count; part_index++) {
                               /* Populate all secondary selectors for the given group */
#if defined(BCM_TRIDENT3_SUPPORT)
                               if (soc_feature(unit, soc_feature_td3_style_fp)) {
                                   rv = _bcm_field_td3_egress_secondary_selcodes_set(unit, fg,
                                           slice_idx + part_index,
                                           part_index);
                               } else
#endif
                               {
                                   rv = _bcm_field_th_egress_secondary_selcodes_set(unit, fg,
                                           slice_idx + part_index,
                                           part_index);
                               }
                               if (BCM_FAILURE(rv)) {
                                   sal_free(fg);
                                   goto cleanup;
                               }
                           }

                           fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1;
                           fg->sel_codes[0].ip6_addr_sel = _FP_SELCODE_DONT_CARE;
                           rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                   stage_fc, _FP_ENTRY_TYPE_0, fg, -1, -1);
                           if (BCM_FAILURE(rv)) {
                               sal_free(fg);
                               goto cleanup;
                           }

                           fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY4;
                           rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                   stage_fc, _FP_ENTRY_TYPE_1, fg,
                                   _BCM_FIELD_EFP_KEY1, -1);
                           if (BCM_FAILURE(rv)) {
                               sal_free(fg);
                               goto cleanup;
                           }

                           fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1;
                           fg->sel_codes[0].ip6_addr_sel = _FP_SELCODE_DONT_CARE;
                           break;
                       case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE:
                           fg->flags |= _FP_GROUP_SPAN_DOUBLE_SLICE;
                           parts_count = 2;


                           for (part_index = 0; part_index < parts_count; part_index++) {
                               /* Populate all secondary selectors for the given group */
#if defined(BCM_TRIDENT3_SUPPORT)
                               if (soc_feature(unit, soc_feature_td3_style_fp)) {
                                   rv = _bcm_field_td3_egress_secondary_selcodes_set(unit, fg,
                                           slice_idx + part_index,
                                           part_index);
                               } else
#endif
                               {
                                   rv = _bcm_field_th_egress_secondary_selcodes_set(unit, fg,
                                           slice_idx + part_index,
                                           part_index);
                               }
                               if (BCM_FAILURE(rv)) {
                                   sal_free(fg);
                                   goto cleanup;
                               }
                           }

                           if (efp_slice_ipv6_mode) {
                               fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY3;
                               fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY2;
                               default_key_1 = _BCM_FIELD_EFP_KEY3;
                               default_key_2 = _BCM_FIELD_EFP_KEY2;
                               fg->sel_codes[0].ip6_addr_sel = _FP_SELCODE_DONT_CARE;
                               fg->sel_codes[1].ip6_addr_sel = efp_slice_ipv6_mode;
                           } else {
                               if ((key_match_type[0] == KEY_TYPE_IPv6_DOUBLE) ||
                                       (key_match_type[1] == KEY_TYPE_IPv6_DOUBLE)) {
                                   fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY3;
                                   fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY2;
                                   default_key_1 = _BCM_FIELD_EFP_KEY3;
                                   default_key_2 = _BCM_FIELD_EFP_KEY2;
                                   fg->sel_codes[0].ip6_addr_sel = _FP_SELCODE_DONT_CARE;
                                   fg->sel_codes[1].ip6_addr_sel = efp_slice_ipv6_mode;
                               } else if ((key_match_type[0] ==
                                           KEY_TYPE_IPv4_L2_L3_DOUBLE) ||
                                       (key_match_type[1] ==
                                        KEY_TYPE_IPv4_L2_L3_DOUBLE) ) {
                                   fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1;
                                   fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
                                   default_key_1 = _BCM_FIELD_EFP_KEY1;
                                   default_key_2 = _BCM_FIELD_EFP_KEY4;
                                   fg->sel_codes[0].ip6_addr_sel = _FP_SELCODE_DONT_CARE;
                                   fg->sel_codes[1].ip6_addr_sel = _FP_SELCODE_DONT_CARE;
                               } else {
                                   fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY8;
                                   fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
                                   default_key_1 = _BCM_FIELD_EFP_KEY8;
                                   default_key_2 = _BCM_FIELD_EFP_KEY4;
                                   fg->sel_codes[0].ip6_addr_sel = _FP_SELCODE_DONT_CARE;
                                   fg->sel_codes[1].ip6_addr_sel = _FP_SELCODE_DONT_CARE;
                               }
                           }

                           rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                   stage_fc, _FP_ENTRY_TYPE_0, fg, -1, -1);
                           if (BCM_FAILURE(rv)) {
                               sal_free(fg);
                               goto cleanup;
                           }

                           fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY8;
                           fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;

                           rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                   stage_fc, _FP_ENTRY_TYPE_1, fg,
                                   default_key_1, default_key_2);
                           if (BCM_FAILURE(rv)) {
                               sal_free(fg);
                               goto cleanup;
                           }

                           fg->sel_codes[0].fpf3 = default_key_1;
                           fg->sel_codes[1].fpf3 = default_key_2;
                           break;

                       case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY:
                           fg->flags |= _FP_GROUP_SPAN_DOUBLE_SLICE;
                           parts_count = 2;

                           for (part_index = 0; part_index < parts_count; part_index++) {
                               /* Populate all secondary selectors for the given group */
#if defined(BCM_TRIDENT3_SUPPORT)
                               if (soc_feature(unit, soc_feature_td3_style_fp)) {
                                   rv = _bcm_field_td3_egress_secondary_selcodes_set(unit, fg,
                                           slice_idx + part_index,
                                           part_index);
                               } else
#endif
                               {
                                   rv = _bcm_field_th_egress_secondary_selcodes_set(unit, fg,
                                           slice_idx + part_index,
                                           part_index);
                               }
                               if (BCM_FAILURE(rv)) {
                                   sal_free(fg);
                                   goto cleanup;
                               }
                           }

                           fg->sel_codes[0].ip6_addr_sel = _FP_SELCODE_DONT_CARE;
                           fg->sel_codes[1].ip6_addr_sel = _FP_SELCODE_DONT_CARE;

                           if ((key_match_type[0] == KEY_TYPE_HIGIG_DOUBLE) ||
                                   (key_match_type[1] == KEY_TYPE_HIGIG_DOUBLE)) {
                               fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY6;
                               fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
                               default_key_1 = _BCM_FIELD_EFP_KEY6;
                               default_key_2 = _BCM_FIELD_EFP_KEY4;
                           } else if ((key_match_type[0] ==
                                       KEY_TYPE_LOOPBACK_DOUBLE) ||
                                   (key_match_type[0] ==
                                    KEY_TYPE_LOOPBACK_DOUBLE) ) {
                               fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY7;
                               fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
                               default_key_1 = _BCM_FIELD_EFP_KEY7;
                               default_key_2 = _BCM_FIELD_EFP_KEY4;
                           } else {
                               fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1;
                               fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
                               default_key_1 = _BCM_FIELD_EFP_KEY1;
                               default_key_2 = _BCM_FIELD_EFP_KEY4;
                           }

                           rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                   stage_fc, _FP_ENTRY_TYPE_0, fg, -1, -1);
                           if (BCM_FAILURE(rv)) {
                               sal_free(fg);
                               goto cleanup;
                           }

                           fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY1;
                           fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;

                           rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                   stage_fc, _FP_ENTRY_TYPE_1, fg,
                                   default_key_1, default_key_2);
                           if (BCM_FAILURE(rv)) {
                               sal_free(fg);
                               goto cleanup;
                           }

                           fg->sel_codes[0].fpf3 = default_key_1;
                           fg->sel_codes[1].fpf3 = default_key_2;
                           break;

                       case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6:

                           fg->flags |= _FP_GROUP_SPAN_DOUBLE_SLICE;
                           parts_count = 2;

                           for (part_index = 0; part_index < parts_count; part_index++) {
                               /* Populate all secondary selectors for the given group */
#if defined(BCM_TRIDENT3_SUPPORT)
                               if (soc_feature(unit, soc_feature_td3_style_fp)) {
                                   rv = _bcm_field_td3_egress_secondary_selcodes_set(unit, fg,
                                           slice_idx + part_index,
                                           part_index);
                               } else
#endif
                               {
                                   rv = _bcm_field_th_egress_secondary_selcodes_set(unit, fg,
                                           slice_idx + part_index,
                                           part_index);
                               }
                               if (BCM_FAILURE(rv)) {
                                   sal_free(fg);
                                   goto cleanup;
                               }
                           }

                           fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY2;
                           fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
                           fg->sel_codes[0].ip6_addr_sel = efp_slice_ipv6_mode;
                           fg->sel_codes[1].ip6_addr_sel = _FP_SELCODE_DONT_CARE;

                           rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                   stage_fc, _FP_ENTRY_TYPE_0, fg, -1, -1);
                           if (BCM_FAILURE(rv)) {
                               sal_free(fg);
                               goto cleanup;
                           }

                           fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY8;
                           fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;

                           rv = _bcm_field_td2_group_construct_quals_add(unit, fc,
                                   stage_fc, _FP_ENTRY_TYPE_1, fg,
                                   _BCM_FIELD_EFP_KEY2, _BCM_FIELD_EFP_KEY4);
                           if (BCM_FAILURE(rv)) {
                               sal_free(fg);
                               goto cleanup;
                           }

                           fg->sel_codes[0].fpf3 = _BCM_FIELD_EFP_KEY2;
                           fg->sel_codes[1].fpf3 = _BCM_FIELD_EFP_KEY4;
                           break;

                       default:
                           rv = BCM_E_INTERNAL;
                           sal_free(fg);
                           goto cleanup;
                   }
               }

               /* Associate slice(s) to group */
               fg->slices = stage_fc->slices[inst] + slice_idx;
               SOC_PBMP_CLEAR(all_pbmp);
               if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
                  SOC_PBMP_ASSIGN(all_pbmp, PBMP_PORT_ALL(unit));
                  SOC_PBMP_OR(all_pbmp, PBMP_CMIC(unit));
               } else {
                  SOC_PBMP_ASSIGN(all_pbmp, PBMP_PIPE(unit, fg->instance));
                  SOC_PBMP_REMOVE(all_pbmp, PBMP_LB(unit));
               }
               SOC_PBMP_ASSIGN(fg->pbmp, all_pbmp);
               BCM_PBMP_OR(fs->pbmp, fg->pbmp);

               fs->group_flags = fg->flags & _FP_GROUP_STATUS_MASK;
               if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
                   BCM_PBMP_OR((fs + 1)->pbmp, fg->pbmp);
                   (fs + 1)->group_flags = fs->group_flags;
               }

               /* Initialize group default ASET list. */
               rv = _field_group_default_aset_set(unit, fg);
               if (BCM_FAILURE(rv)) {
                  sal_free(fg);
                  goto cleanup;
               }

               if (fc->l2warm
                       && ((fc->wb_recovered_version)
                       >= BCM_FIELD_WB_VERSION_1_15)) {
                   if (group_flags & _FP_GROUP_LOOKUP_ENABLED) {
                       fg->flags = fg->flags | _FP_GROUP_LOOKUP_ENABLED;
                   }
                   if (group_flags & _FP_GROUP_WLAN) {
                       fg->flags = fg->flags | _FP_GROUP_WLAN;
                   }
               } else {
                   fg->flags |= _FP_GROUP_LOOKUP_ENABLED;
               }

               if (group_flags & _FP_GROUP_SELECT_AUTO_EXPANSION) {
                   fg->flags |= _FP_GROUP_SELECT_AUTO_EXPANSION;
               }

               fg->next = fc->groups;
               fc->groups = fg;

               /* Now go over the entries in this slice */
               prev_prio = -1;
               for (idx = 0; idx < slice_ent_cnt; idx++) {
                   efp_tcam_entry = soc_mem_table_idx_to_pointer(unit,
                                                   efp_tcam,
                                                   efp_tcam_entry_t *,
                                          efp_tcam_pipe_buf[instance],
                                      idx + slice_ent_cnt * slice_idx);
                   if (soc_mem_field32_get(unit, efp_tcam,
                                           efp_tcam_entry, VALIDf) == 0) {
                       if (!(fc->l2warm)) {
                           continue;
                       } else {
                           if ((fc->wb_recovered_version) <
                               BCM_FIELD_WB_VERSION_1_27) {
                               continue;
                           } else if (!(_FP_SLICEIDX_BMP_TEST(sliceidx_bmp,
                               (idx + slice_ent_cnt * slice_idx) +slice_offset))) {
                               continue;
                           }
                       }
                   }

                   _field_extract((uint32 *)efp_tcam_entry, efp_key_type_offset, 4,
                                  &entry_type);

                   /* Allocate memory for this entry */
                   mem_sz = parts_count * sizeof (_field_entry_t);
                   _FP_XGS3_ALLOC(f_ent, mem_sz, "field entry");
                   if (f_ent == NULL) {
                      rv = BCM_E_MEMORY;
                      goto cleanup;
                   }
                   for (idx1 = 0; idx1 < _FP_POLICER_LEVEL_COUNT; idx1++) {
                       f_ent->policer[idx1].pid = _FP_INVALID_INDEX;
                   }
                   sal_memset(&f_ent_wb_info, 0, sizeof(_field_entry_wb_info_t));
                   f_ent_wb_info.sid = f_ent_wb_info.pid = -1;
                   if (fc->l2warm) {
                    /* Recover f_ent_oam_wb structure from here */
                    /* Allocate f_ent_oam_wb structure and pass it to
                     * corresponding function */
                    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_11) {
                        _FP_XGS3_ALLOC(f_ent_oam_wb, sizeof (_field_entry_oam_wb_t),
                                "Field Entry Warmboot");
                        if (f_ent_oam_wb == NULL) {
                            sal_free (f_ent);
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }
                    }
                    f_ent_wb_info.f_ent_oam_wb = f_ent_oam_wb;

                    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
                       action_bmp.w = NULL;
                       _FP_XGS3_ALLOC(action_bmp.w,
                            SHR_BITALLOCSIZE(_bcmFieldActionNoParamCount),
                            "Action No Param Bitmap");
                       if (action_bmp.w == NULL) {
                          rv = BCM_E_MEMORY;
                          sal_free(f_ent);
                          goto cleanup;
                       }
                    }
                    f_ent_wb_info.action_bmp = &action_bmp;

                    /* Recover f_ent_policer_wb structure from here */
                    /* Allocate f_ent_policer_wb structure and pass it to
                     * corresponding function */
                    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_17) {
                        _FP_XGS3_ALLOC(f_ent_policer_wb, sizeof (_field_entry_policer_wb_t),
                                "Field Entry Warmboot");
                        if (f_ent_policer_wb == NULL) {
                            rv = BCM_E_MEMORY;
                            sal_free (f_ent);
                            goto cleanup;
                        }
                    }
                    f_ent_wb_info.f_ent_policer_wb = f_ent_policer_wb;
                    rv = _field_trx_entry_info_retrieve(unit,
                                                        fc,
                                                        stage_fc,
                                                        0,
                                                        &prev_prio,
                                                        &f_ent_wb_info);
                    
                      if (BCM_FAILURE(rv)) {
                          _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                          sal_free(f_ent);
                          goto cleanup;
                      }
                   } else {
                      _bcm_field_last_alloc_eid_incr(unit);
                   }

                   switch(efp_slice_mode) {
                      case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L2:
                          f_ent->efp_key_match_type = 1;
                          break;
                      case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3:
                          if (fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1) {
                              if (KEY_TYPE_IPv4_SINGLE == entry_type) {
                                  f_ent->efp_key_match_type = 0;
                              } else {
                                  f_ent->efp_key_match_type = 1;
                              }
                          } else if (fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY5) {
                              if (KEY_TYPE_FCOE_SINGLE == entry_type) {
                                  f_ent->efp_key_match_type = 0;
                              } else {
                                  f_ent->efp_key_match_type = 1;
                              }
                          } else {
                              if (KEY_TYPE_IPv6_SINGLE == entry_type) {
                                  f_ent->efp_key_match_type = 0;
                              } else {
                                  f_ent->efp_key_match_type = 1;
                              }
                          }
                          break;
                      case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3_ANY:
                          if (KEY_TYPE_IPv4_SINGLE == entry_type) {
                              f_ent->efp_key_match_type = 0;
                          } else {
                              f_ent->efp_key_match_type = 1;
                          }
                          break;
                      case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE:
                          if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1) &&
                              (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)) {
                              if (KEY_TYPE_IPv4_L2_L3_DOUBLE == entry_type) {
                                  f_ent->efp_key_match_type = 0;
                                  (f_ent+1)->efp_key_match_type = 0;
                              } else {
                                  f_ent->efp_key_match_type = 1;
                                  (f_ent+1)->efp_key_match_type = 1;
                              }
                          } else if ((fg->sel_codes[0].fpf3 ==
                                     _BCM_FIELD_EFP_KEY3) &&
                                     (fg->sel_codes[1].fpf3 ==
                                      _BCM_FIELD_EFP_KEY2)) {
                              if (KEY_TYPE_IPv6_DOUBLE == entry_type) {
                                  f_ent->efp_key_match_type = 0;
                                  (f_ent+1)->efp_key_match_type = 0;
                              } else {
                                  f_ent->efp_key_match_type = 1;
                                  (f_ent+1)->efp_key_match_type = 1;
                              }
                          } else {
                              f_ent->efp_key_match_type = 1;
                              (f_ent+1)->efp_key_match_type = 1;
                          }
                          break;
                      case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY:
                          if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY6) &&
                              (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)) {
                              if (KEY_TYPE_HIGIG_DOUBLE == entry_type) {
                                  f_ent->efp_key_match_type = 0;
                                  (f_ent+1)->efp_key_match_type = 0;
                              } else {
                                  f_ent->efp_key_match_type = 1;
                                  (f_ent+1)->efp_key_match_type = 1;
                              }
                          } else if ((fg->sel_codes[0].fpf3 ==
                                      _BCM_FIELD_EFP_KEY7) &&
                                     (fg->sel_codes[1].fpf3 ==
                                      _BCM_FIELD_EFP_KEY4)) {
                              if (KEY_TYPE_LOOPBACK_DOUBLE == entry_type) {
                                  f_ent->efp_key_match_type = 0;
                                  (f_ent+1)->efp_key_match_type = 0;
                              } else {
                                  f_ent->efp_key_match_type = 1;
                                  (f_ent+1)->efp_key_match_type = 1;
                              }
                          } else {
                              f_ent->efp_key_match_type = 1;
                              (f_ent+1)->efp_key_match_type = 1;
                          }
                          break;
                      case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6:
                          if (KEY_TYPE_IPv4_IPv6_DOUBLE == entry_type) {
                              f_ent->efp_key_match_type = 0;
                              (f_ent+1)->efp_key_match_type = 0;
                          } else {
                              f_ent->efp_key_match_type = 1;
                              (f_ent+1)->efp_key_match_type = 1;
                          }
                          break;
                      default:
                          rv = BCM_E_INTERNAL;
                          _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                          sal_free(f_ent);
                          goto cleanup;
                   }

                   pri_tcam_idx = idx + slice_ent_cnt * slice_idx;
                   for (i = 0; i < parts_count; i++) {
                      if (fc->l2warm) {
                          f_ent[i].eid = f_ent_wb_info.eid;
                          /* Set retrieved dvp_type and svp_type */
                          f_ent[i].dvp_type = f_ent_wb_info.dvp_type[i];
                          f_ent[i].svp_type = f_ent_wb_info.svp_type[i];
                          f_ent[i].prio = f_ent_wb_info.prio;
                      } else {
                          f_ent[i].eid = _bcm_field_last_alloc_eid_get(unit);
                      }
                      f_ent[i].group = fg;

                      rv = _bcm_field_tcam_part_to_entry_flags(unit, i, fg,
                                                             &f_ent[i].flags);
                      if (BCM_FAILURE(rv)) {
                          _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                          sal_free(f_ent);
                          goto cleanup;
                      }
                      if (f_ent_wb_info.color_independent) {
                          f_ent[i].flags |= _FP_ENTRY_COLOR_INDEPENDENT;
                      }
                      rv = _bcm_field_entry_part_tcam_idx_get(unit, f_ent,
                                                             pri_tcam_idx,
                                                          i, &part_index);
                      if (BCM_FAILURE(rv)) {
                          _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                          sal_free(f_ent);
                          goto cleanup;
                      }
                      if (f_ent_wb_info.color_independent) {
                          f_ent[i].flags |= _FP_ENTRY_COLOR_INDEPENDENT;
                      }
                      rv = _bcm_field_tcam_idx_to_slice_offset(unit, stage_fc,
                                                               inst,
                                                               part_index,
                                                               &slice_number,
                                                  (int *)&f_ent[i].slice_idx);
                      if (BCM_FAILURE(rv)) {
                          _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                          sal_free(f_ent);
                          goto cleanup;
                      }
                      f_ent[i].fs = stage_fc->slices[inst] + slice_number;
                      if (0 == (f_ent[i].flags & _FP_ENTRY_SECOND_HALF)) {
                          /* Decrement slice free entry count for primary
                             entries. */
                          f_ent[i].fs->free_count--;
                      }

                      f_ent[i].fs->hw_ent_count++;

                      /* Assign entry to a slice */
                      f_ent[i].fs->entries[f_ent[i].slice_idx] = f_ent + i;
                      f_ent[i].flags |= _FP_ENTRY_INSTALLED;

                      if (soc_mem_field32_get(unit, efp_tcam,
                          efp_tcam_entry, VALIDf) == tcam_valid_val) {
                          f_ent[i].flags |= _FP_ENTRY_ENABLED;
                      } else {
                          if ((fc->l2warm) && (i != 0) &&
                              ((fc->wb_recovered_version) >=
                              BCM_FIELD_WB_VERSION_1_27) &&
                              ( _FP_SLICEIDX_BMP_TEST(sliceidx_bmp,
                              pri_tcam_idx + slice_offset) )) {

                              f_ent[i].flags |= _FP_ENTRY_ENABLED;
                          }
                      }

                      /* Get the actions associated with this entry part */
                      efp_policy_entry = soc_mem_table_idx_to_pointer
                                              (unit, efp_policy_table,
                                               efp_policy_table_entry_t *,
                                               efp_policy_pipe_buf[instance],
                                               part_index);
                      rv = _field_tr2_actions_recover(unit,
                                                    efp_policy_table,
                                                    (uint32 *) efp_policy_entry,
                                                    f_ent,
                                                    i,
                                                    &f_ent_wb_info);
                      if (BCM_FAILURE(rv)) {
                          _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                          sal_free(f_ent);
                          goto cleanup;
                      }
                      if (action_bmp.w != NULL) {
                        _FP_ACTION_BMP_FREE(action_bmp);
                        action_bmp.w = NULL;
                      }
                  }
                  /* Set action stat flags */
                  fa = f_ent->actions;
                  while (fa != NULL) {
                        rv = _bcm_field_action_stat_flag_update(unit, f_ent,
                                                                fa, TRUE);
                        if (rv < 0) {
                            _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                            sal_free(f_ent);
                            goto cleanup;
                        }
                        fa = fa->next;
                  }
                  /* Add to the group */
                  rv = _field_group_entry_add(unit, fg, f_ent);
                  if (BCM_FAILURE(rv)) {
                      _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                      sal_free(f_ent);
                      goto cleanup;
                  }
                  f_ent = NULL;

                  /* Entry has been added to group,
                   * so free f_ent_oam_wb structure */
                  _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                  if (f_ent_policer_wb != NULL) {
                      sal_free(f_ent_policer_wb);
                      f_ent_policer_wb = NULL;
                  }

               }
           }

           /* Free up the temporary slice group info */
           if (fc->l2warm) {
              _field_scache_slice_group_free(unit, fc, slice_idx);
           }
           LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
               "# Done reading for inst[%d] slice[%d] byte @ %d\n\r"),
               inst, slice_idx, fc->scache_pos));
       }
       LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
               "## Done reading for inst[%d] byte @ s_pos=%d s_pos1=%d\n\r"),
               inst, fc->scache_pos, fc->scache_pos1));
    }

    /* Iterate over the instances */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
       if (!(fc->pipe_map & (1 << inst))) {
            continue;
       }
       mem_inst = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                   _FP_GLOBAL_INST : inst;
       instance = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                   _FP_MAX_NUM_PIPES : inst;
       slice_offset = inst * slice_size;

       rv = _bcm_field_reg_instance_get(unit,
                                        EFP_SLICE_CONTROLr,
                                        mem_inst, &efp_slice_control_reg);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }
       rv = _bcm_field_mem_instance_get(unit, EFP_TCAMm,
                                        mem_inst, &efp_tcam);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }
       rv = _bcm_field_mem_instance_get(unit,
                                        EFP_POLICY_TABLEm,
                                        mem_inst,
                                        &efp_policy_table);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }

       if ((rv = soc_reg32_get(unit, efp_slice_control_reg,
                               REG_PORT_ANY, 0, &rval)) < 0) {
           goto cleanup;
       }
       /* Now go over the expanded slices */
       for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
          if (!expanded[inst][slice_idx]) {
              continue;
          }
          LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "# inst[%d] slice[%d] expanded[%d][%d]=[%d] byte @ %d\n\r"), inst,
            slice_idx, inst, slice_idx, expanded[inst][slice_idx],
            fc->scache_pos));

          /* Ignore secondary slice in paired mode */
          efp_slice_mode = soc_reg_field_get(unit,
                                             efp_slice_control_reg,
                                             rval,
                                             _th_efp_slice_mode[slice_idx][0]);
          if (((efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE) ||
              (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY) ||
              (efp_slice_mode == _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6)) &&
              (slice_idx % 2)) {
              continue;
          }
          /* Skip if slice has no valid entries */
          fs = stage_fc->slices[inst] + slice_idx;
          slice_ent_cnt = fs->entry_count;
          for (idx = 0; idx < slice_ent_cnt; idx++) {
              if (_bcm_field_slice_offset_to_tcam_idx(unit, stage_fc, inst,
                             slice_idx, idx, &phys_tcam_idx) != BCM_E_NONE) {
                  rv = BCM_E_INTERNAL;
                  goto cleanup;
              }
              efp_tcam_entry = soc_mem_table_idx_to_pointer(unit,
                               efp_tcam, efp_tcam_entry_t *,
                           efp_tcam_pipe_buf[instance], phys_tcam_idx);
              if (soc_mem_field32_get(unit, efp_tcam,
                                      efp_tcam_entry, VALIDf) != 0) {
                  break;
              } else {
                  if ((fc->l2warm) &&
                     ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_27)
                     && (_FP_SLICEIDX_BMP_TEST(sliceidx_bmp,
                     phys_tcam_idx + slice_offset))) {
                      break;
                  }
              }
          }
          if (idx == slice_ent_cnt) {
              continue;
          }
          /* If Level 2, retrieve the GIDs in this slice */
          if (fc->l2warm) {
              rv = _field_trx_scache_slice_group_recover(unit,
                                                         fc,
                                                         inst,
                                                         slice_idx,
                                                         &multigroup,
                                                         stage_fc,
                                                         0);;
              if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
                  fc->l2warm = 0;
                  goto cleanup;
              }
              if (rv == BCM_E_NOT_FOUND) {
                  rv = BCM_E_NONE;
                  continue;
              }
          }
          /* Now find the master slice for this virtual group */
          vslice_idx = _field_physical_to_virtual(unit, inst, slice_idx,
                                                  stage_fc);
          if (vslice_idx < 0) {
              rv = BCM_E_INTERNAL;
              goto cleanup;
          }

          if (fc->l2warm && ((fc->wb_recovered_version)
              >=BCM_FIELD_WB_VERSION_1_8)) {
              master_slice = slice_master_idx[inst][slice_idx];
          } else {
              max = -1;
              for (i = 0; i < stage_fc->tcam_slices; i++) {
                 if ((stage_fc->vmap[inst][0][vslice_idx].virtual_group ==
                      stage_fc->vmap[inst][0][i].virtual_group)
                      && (i != vslice_idx)) {
                     if (i > max) {
                        max = i;
                     }
                 }
              }
              if (max < 0) {
                 rv = BCM_E_INTERNAL;
                 goto cleanup;
              }

              master_slice = stage_fc->vmap[inst][0][max].vmap_key;
          }
          /* See which group is in this slice - can be only one */
          fg = fc->groups;
          while (fg != NULL) {
              /* Check if group is in this slice */
              fs = &fg->slices[0];
              if ((fg->instance == inst) &&
                  (fg->stage_id == stage_fc->stage_id) &&
                  (fs->slice_number == master_slice)) {
                  break;
              }
              fg = fg->next;
          }
          if (fg == NULL) {
              rv = BCM_E_INTERNAL;
              goto cleanup;
          }

          old_physical_slice = fs->slice_number;

          /* Set up the new physical slice parameters in Software */
          for(part_index = parts_count - 1; part_index >= 0; part_index--) {
              /* Get entry flags. */
              rv = _bcm_field_tcam_part_to_entry_flags(unit, part_index, fg,
                                                       &entry_flags);

              if (BCM_FAILURE(rv)) {
                  goto cleanup;
              }
              /* Get slice id for entry part */
              rv = _bcm_field_tcam_part_to_slice_number(unit, part_index,
                                                        fg, &slice_num);
              if (BCM_FAILURE(rv)) {
                  goto cleanup;
              }

              /* Get slice pointer. */
              fs = stage_fc->slices[inst] + slice_idx + slice_num;

              if (0 == (entry_flags & _FP_ENTRY_SECOND_HALF)) {
                 /*
                  * Set per slice configuration &  number of free entries in the
                  * slice.
                  */
                  fs->free_count = fs->entry_count;
                  if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                      fs->free_count >>= 1;
                  }
                  /* Set group flags in in slice.*/
                  fs->group_flags = fg->flags & _FP_GROUP_STATUS_MASK;

                  /* Add slice to slices linked list . */
                  fs_temp = stage_fc->slices[inst] +
                            old_physical_slice + slice_num;
                  /* To handle more than one auto expanded slice in a group */
                  while (fs_temp->next != NULL) {
                      fs_temp = fs_temp->next;
                  }
                  fs_temp->next = fs;
                  fs->prev = fs_temp;
              }
          }

          fs = stage_fc->slices[inst] + slice_idx;
          fs->group_flags = fg->flags & _FP_GROUP_STATUS_MASK;

          prev_prio = -1;
          SOC_PBMP_CLEAR(all_pbmp);
          if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
              SOC_PBMP_ASSIGN(all_pbmp, PBMP_PORT_ALL(unit));
              SOC_PBMP_OR(all_pbmp, PBMP_CMIC(unit));
          } else {
              SOC_PBMP_ASSIGN(all_pbmp, PBMP_PIPE(unit, fg->instance));
              SOC_PBMP_REMOVE(all_pbmp, PBMP_LB(unit));
          }
          SOC_PBMP_ASSIGN(fg->pbmp, all_pbmp);
          BCM_PBMP_OR(fs->pbmp, fg->pbmp);
          if (fg->flags & _FP_GROUP_SPAN_DOUBLE_SLICE) {
              BCM_PBMP_OR((fs + 1)->pbmp, fg->pbmp);
              (fs + 1)->group_flags = fs->group_flags;
          }

          for (idx = 0; idx < slice_ent_cnt; idx++) {
              if (_bcm_field_slice_offset_to_tcam_idx(unit, stage_fc,
                  inst, slice_idx, idx, &phys_tcam_idx) != BCM_E_NONE) {
                  rv = BCM_E_INTERNAL;
                  goto cleanup;
              }
              efp_tcam_entry = soc_mem_table_idx_to_pointer(unit,
                                  efp_tcam, efp_tcam_entry_t *,
                             efp_tcam_pipe_buf[instance], phys_tcam_idx);
              if (soc_mem_field32_get(unit, efp_tcam,
                                      efp_tcam_entry, VALIDf) == 0) {
                  if (!(fc->l2warm)) {
                      continue;
                  } else {
                      if ((fc->wb_recovered_version) <
                          BCM_FIELD_WB_VERSION_1_27) {
                          continue;
                      } else if (!(_FP_SLICEIDX_BMP_TEST(sliceidx_bmp,
                                   phys_tcam_idx + slice_offset))) {
                          continue;
                      }
                  }
              }

              _field_extract((uint32 *)efp_tcam_entry, efp_key_type_offset, 4,
                      &entry_type);

              /* Allocate memory for the entry */
              rv = _bcm_field_entry_tcam_parts_count(unit, fg->stage_id,
                                                     fg->flags, &parts_count);
              if (BCM_FAILURE(rv)) {
                  goto cleanup;
              }
              mem_sz = parts_count * sizeof (_field_entry_t);
              _FP_XGS3_ALLOC(f_ent, mem_sz, "field entry");
              if (f_ent == NULL) {
                  rv = BCM_E_MEMORY;
                  goto cleanup;
              }

              for (idx1 = 0; idx1 < _FP_POLICER_LEVEL_COUNT; idx1++) {
                   f_ent->policer[idx1].pid = _FP_INVALID_INDEX;
              }

              sal_memset(&f_ent_wb_info, 0, sizeof(_field_entry_wb_info_t));
              f_ent_wb_info.sid = f_ent_wb_info.pid = -1;
              if (fc->l2warm) {
                  /* Recover f_ent_oam_wb structure from here */
                  /* Allocate f_ent_oam_wb structure and pass it to
                    * corresponding function */
                  if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_11) {
                     _FP_XGS3_ALLOC(f_ent_oam_wb, sizeof (_field_entry_oam_wb_t),
                            "Field Entry Warmboot");
                     if (f_ent_oam_wb == NULL) {
                        sal_free (f_ent);
                        rv = BCM_E_MEMORY;
                        goto cleanup;
                     }
                  }
                  f_ent_wb_info.f_ent_oam_wb = f_ent_oam_wb;

                  if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
                      action_bmp.w = NULL;
                      _FP_XGS3_ALLOC(action_bmp.w,
                           SHR_BITALLOCSIZE(_bcmFieldActionNoParamCount),
                           "Action No Param Bitmap");
                      if (action_bmp.w == NULL) {
                         rv = BCM_E_MEMORY;
                         sal_free(f_ent);
                         goto cleanup;
                      }
                  }
                  f_ent_wb_info.action_bmp = &action_bmp;

                  /* Recover f_ent_policer_wb structure from here */
                  /* Allocate f_ent_policer_wb structure and pass it to
                   * corresponding function */
                  if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_17) {
                      _FP_XGS3_ALLOC(f_ent_policer_wb, sizeof (_field_entry_policer_wb_t),
                              "Field Entry Warmboot");
                      if (f_ent_policer_wb == NULL) {
                          rv = BCM_E_MEMORY;
                          sal_free (f_ent);
                          goto cleanup;
                      }
                  }
                  f_ent_wb_info.f_ent_policer_wb = f_ent_policer_wb;

                  rv = _field_trx_entry_info_retrieve(unit,
                         fc, stage_fc, multigroup, &prev_prio, &f_ent_wb_info);
                  
                  if (BCM_FAILURE(rv)) {
                      _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                      sal_free(f_ent);
                      goto cleanup;
                  }
              } else {
                  _bcm_field_last_alloc_eid_incr(unit);
              }

              switch(efp_slice_mode) {
                  case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L2:
                      f_ent->efp_key_match_type = 1;
                      break;
                  case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3:
                      if (fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1) {
                          if (KEY_TYPE_IPv4_SINGLE == entry_type) {
                              f_ent->efp_key_match_type = 0;
                          } else {
                              f_ent->efp_key_match_type = 1;
                          }
                      } else if (fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY5) {
                          if (KEY_TYPE_FCOE_SINGLE == entry_type) {
                              f_ent->efp_key_match_type = 0;
                          } else {
                              f_ent->efp_key_match_type = 1;
                          }
                      } else {
                          if (KEY_TYPE_IPv6_SINGLE == entry_type) {
                              f_ent->efp_key_match_type = 0;
                          } else {
                              f_ent->efp_key_match_type = 1;
                          }
                      }
                      break;
                  case _BCM_FIELD_EGRESS_SLICE_MODE_SINGLE_L3_ANY:
                      if (KEY_TYPE_IPv4_SINGLE == entry_type) {
                          f_ent->efp_key_match_type = 0;
                      } else {
                          f_ent->efp_key_match_type = 1;
                      }
                      break;
                  case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE:
                      if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY1) &&
                              (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)) {
                          if (KEY_TYPE_IPv4_L2_L3_DOUBLE == entry_type) {
                              f_ent->efp_key_match_type = 0;
                              (f_ent+1)->efp_key_match_type = 0;
                          } else {
                              f_ent->efp_key_match_type = 1;
                              (f_ent+1)->efp_key_match_type = 1;
                          }
                      } else if ((fg->sel_codes[0].fpf3 ==
                                  _BCM_FIELD_EFP_KEY3) &&
                              (fg->sel_codes[1].fpf3 ==
                               _BCM_FIELD_EFP_KEY2)) {
                          if (KEY_TYPE_IPv6_DOUBLE == entry_type) {
                              f_ent->efp_key_match_type = 0;
                              (f_ent+1)->efp_key_match_type = 0;
                          } else {
                              f_ent->efp_key_match_type = 1;
                              (f_ent+1)->efp_key_match_type = 1;
                          }
                      } else {
                          f_ent->efp_key_match_type = 1;
                          (f_ent+1)->efp_key_match_type = 1;
                      }
                      break;
                  case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_ANY:
                      if ((fg->sel_codes[0].fpf3 == _BCM_FIELD_EFP_KEY6) &&
                              (fg->sel_codes[1].fpf3 == _BCM_FIELD_EFP_KEY4)) {
                          if (KEY_TYPE_HIGIG_DOUBLE == entry_type) {
                              f_ent->efp_key_match_type = 0;
                              (f_ent+1)->efp_key_match_type = 0;
                          } else {
                              f_ent->efp_key_match_type = 1;
                              (f_ent+1)->efp_key_match_type = 1;
                          }
                      } else if ((fg->sel_codes[0].fpf3 ==
                                  _BCM_FIELD_EFP_KEY7) &&
                              (fg->sel_codes[1].fpf3 ==
                               _BCM_FIELD_EFP_KEY4)) {
                          if (KEY_TYPE_LOOPBACK_DOUBLE == entry_type) {
                              f_ent->efp_key_match_type = 0;
                              (f_ent+1)->efp_key_match_type = 0;
                          } else {
                              f_ent->efp_key_match_type = 1;
                              (f_ent+1)->efp_key_match_type = 1;
                          }
                      } else {
                          f_ent->efp_key_match_type = 1;
                          (f_ent+1)->efp_key_match_type = 1;
                      }
                      break;
                  case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_L3_V6:
                      if (KEY_TYPE_IPv4_IPv6_DOUBLE == entry_type) {
                          f_ent->efp_key_match_type = 0;
                          (f_ent+1)->efp_key_match_type = 0;
                      } else {
                          f_ent->efp_key_match_type = 1;
                          (f_ent+1)->efp_key_match_type = 1;
                      }
                      break;
                 case _BCM_FIELD_EGRESS_SLICE_MODE_DOUBLE_FCOE:
                     if ((_BCM_FIELD_EFP_KEY5 == fg->sel_codes[0].fpf3)
                             && (_BCM_FIELD_EFP_KEY4 == fg->sel_codes[1].fpf3)
                             && (KEY_TYPE_FCOE_DOUBLE == entry_type)) {
                         f_ent->efp_key_match_type = 0;
                         (f_ent+1)->efp_key_match_type = 0;
                     } else {
                         f_ent->efp_key_match_type = 1;
                         (f_ent+1)->efp_key_match_type = 1;
                     }
                     break;
                  default:
                      rv = BCM_E_INTERNAL;
                      _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                      sal_free(f_ent);
                      goto cleanup;
              }

              pri_tcam_idx = phys_tcam_idx;
              for (i = 0; i < parts_count; i++) {
                  if (fc->l2warm) {
                      /* Use retrieved EID */
                      f_ent[i].eid = f_ent_wb_info.eid;
                      /* Set retrieved dvp_type and svp_type */
                      f_ent[i].dvp_type = f_ent_wb_info.dvp_type[i];
                      f_ent[i].svp_type = f_ent_wb_info.svp_type[i];
                      f_ent[i].prio = f_ent_wb_info.prio;
                  } else {
                      f_ent[i].eid = _bcm_field_last_alloc_eid_get(unit);
                  }
                  f_ent[i].group = fg;

                  rv = _bcm_field_tcam_part_to_entry_flags(unit, i, fg,
                                                           &f_ent[i].flags);
                  if (BCM_FAILURE(rv)) {
                      _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                      sal_free(f_ent);
                      goto cleanup;
                  }

                  rv = _bcm_field_entry_part_tcam_idx_get(unit,
                           f_ent, pri_tcam_idx, i, &part_index);
                  if (BCM_FAILURE(rv)) {
                      _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                      sal_free(f_ent);
                      goto cleanup;
                  }
                  if (f_ent_wb_info.color_independent) {
                      f_ent[i].flags |= _FP_ENTRY_COLOR_INDEPENDENT;
                  }
                  rv = _bcm_field_tcam_idx_to_slice_offset(unit,
                           stage_fc, inst, part_index, &slice_number,
                           (int *)&f_ent[i].slice_idx);
                  if (BCM_FAILURE(rv)) {
                      _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                      sal_free(f_ent);
                      goto cleanup;
                  }
                  f_ent[i].fs = stage_fc->slices[inst] + slice_number;
                  if (0 == (f_ent[i].flags & _FP_ENTRY_SECOND_HALF)) {
                      /* Decrement slice free entry count for primary
                         entries. */
                      f_ent[i].fs->free_count--;
                  }

                  f_ent[i].fs->hw_ent_count++;

                  /* Assign entry to a slice */
                  f_ent[i].fs->entries[f_ent[i].slice_idx] = f_ent + i;
                  f_ent[i].flags |= _FP_ENTRY_INSTALLED;

                  if (soc_mem_field32_get(unit, efp_tcam,
                                      efp_tcam_entry, VALIDf) == tcam_valid_val) {
                      f_ent[i].flags |= _FP_ENTRY_ENABLED;
                  } else {
                      if ((fc->l2warm) && (i != 0) &&
                          ((fc->wb_recovered_version) >=
                          BCM_FIELD_WB_VERSION_1_27) &&
                          ( _FP_SLICEIDX_BMP_TEST(sliceidx_bmp,
                          pri_tcam_idx + slice_offset) )) {

                          f_ent[i].flags |= _FP_ENTRY_ENABLED;
                      }
                  }


                  /* Get the actions associated with this part of the entry */
                  efp_policy_entry = soc_mem_table_idx_to_pointer(
                                            unit, efp_policy_table,
                                            efp_policy_table_entry_t *,
                                            efp_policy_pipe_buf[instance],
                                            part_index);
                  rv = _field_tr2_actions_recover(unit,
                                            efp_policy_table,
                                            (uint32 *) efp_policy_entry,
                                            f_ent, i, &f_ent_wb_info);
                  if (BCM_FAILURE(rv)) {
                      _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                      sal_free(f_ent);
                      goto cleanup;
                  }
                  if (action_bmp.w != NULL) {
                      _FP_ACTION_BMP_FREE(action_bmp);
                      action_bmp.w = NULL;
                  }
              }
              /* Set action stat flags */
              fa = f_ent->actions;
              while (fa != NULL) {
                    rv = _bcm_field_action_stat_flag_update(unit, f_ent,
                                                            fa, TRUE);
                    if (rv < 0) {
                        _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                        sal_free(f_ent);
                        goto cleanup;
                    }
                    fa = fa->next;
              }

              rv = _field_group_entry_add(unit, fg, f_ent);
              if (BCM_FAILURE(rv)) {
                  _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
                  sal_free(f_ent);
                  goto cleanup;
              }
              f_ent = NULL;

              /* Entry has been added to group,
               * so free f_ent_oam_wb structure */
              _field_entry_oam_wb_free (unit, &f_ent_oam_wb);
              if (f_ent_policer_wb != NULL) {
                  sal_free(f_ent_policer_wb);
                  f_ent_policer_wb = NULL;
              }

          }
          /* Free up the temporary slice group info */
          if (fc->l2warm) {
              _field_scache_slice_group_free(unit, fc, slice_idx);
          }
          LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
           "# Expansion Done reading for inst[%d] slice[%d] byte @ %d\n\r"),
           inst, slice_idx, fc->scache_pos));
       }
       LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
        "## Expansion Done reading for inst[%d] byte @ s_pos=%d s_pos1=%d\n\r"),
        inst, fc->scache_pos, fc->scache_pos1));
    }

    if (fc->l2warm) {

        /* Mark end of Slice Info */
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
            fc->scache_pos++;
        }

        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
            if (stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,"Recovering hint Ids "
                                    "from pos = %d\r\n"), fc->scache_pos));
                 rv = _bcm_hints_scache_hintid_recover(unit, stage_fc,
                             fc, &buf[fc->scache_pos]);
                 if (BCM_FAILURE(rv)) {
                     goto cleanup;
                 }
            }
        }

        /* Group Slice Selectors */
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
            rv = (_field_group_slice_selectors_recover(unit,
                          &buf[fc->scache_pos], stage_fc->stage_id));
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }
        }

        temp = 0;
        temp |= buf[fc->scache_pos];
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 8;
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 16;
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 24;
        fc->scache_pos++;
        if (temp != _FIELD_EFP_DATA_END) {
           LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
               "%s(): Unable to find buf EFP_DATA_END [0x%x] @ byte %d.\n"),
               __func__, temp, fc->scache_pos));
            fc->l2warm = 0;
            rv = BCM_E_INTERNAL;
        }

        if (NULL != buf1) {
            temp = 0;
            temp |= buf1[fc->scache_pos1];
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 8;
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 16;
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 24;
            fc->scache_pos1++;
            if (temp != _FIELD_EFP_DATA_END) {
                fc->l2warm = 0;
                rv = BCM_E_INTERNAL;
                LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
                  "%s(): Unable to find buf1 EFP_DATA_END [0x%x] @ byte %d.\n"),
                   __func__, temp, fc->scache_pos1));
            }
        }

    }

    if (BCM_SUCCESS(rv)) {
        _field_group_slice_vmap_recovery(unit, fc, stage_fc);
    }

    _field_tr2_stage_reinit_all_groups_cleanup(unit, fc,
                                               _BCM_FIELD_STAGE_EGRESS,
                                               NULL);
cleanup:
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {

             continue;
        }
        instance = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                   _FP_MAX_NUM_PIPES : inst;

        if (efp_tcam_pipe_buf[instance]) {
           soc_cm_sfree(unit, efp_tcam_pipe_buf[instance]);
        }
        if (efp_policy_pipe_buf[instance]) {
           soc_cm_sfree(unit, efp_policy_pipe_buf[instance]);
        }
    }
    if (efp_tcam_buf) {
       soc_cm_sfree(unit, efp_tcam_buf);
    }
    if (efp_policy_buf) {
       soc_cm_sfree(unit, efp_policy_buf);
    }
    if (action_bmp.w != NULL) {
       _FP_ACTION_BMP_FREE(action_bmp);
       action_bmp.w = NULL;
    }
    if (f_ent_policer_wb != NULL) {
        sal_free(f_ent_policer_wb);
        f_ent_policer_wb = NULL;
    }

    if (NULL != sliceidx_bmp.w) {
        sal_free(sliceidx_bmp.w);
        sliceidx_bmp.w = NULL;
    }
    return rv;
}

/*
 * Function:
 *     _bcm_field_th_stage_lookup_reinit
 *
 * Purpose:
 *     Reconstruct's VFP/Lookup stage groups and entries.
 *
 * Parameters:
 *     unit             - (IN) BCM device number.
 *     fc               - (IN) Device field control structure pointer.
 *     stage_fc         - (IN) FP stage control info.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_th_stage_lookup_reinit(int unit,
                               _field_control_t *fc,
                               _field_stage_t *stage_fc)
{
    int vslice_idx, max, master_slice;
    int idx, idx1, slice_idx, index_min, index_max, ratio, rv = BCM_E_NONE;
    int mem_sz, parts_count, slice_ent_cnt = 0;
    int expanded[_FP_MAX_NUM_PIPES][4];
                                  /* Expansion status of slices in (V/I/E)FP. */
    int slice_master_idx[_FP_MAX_NUM_PIPES][4];
                                  /* Expansion status of slices in (V/I/E)FP. */
    int i, pri_tcam_idx, part_index, slice_number, prev_prio;
    int paired, intraslice;
    char *vfp_policy_buf = NULL; /* Buffer to read the VFP_POLICY table */
    char *vfp_policy_pipe_buf[_FP_MAX_NUM_PIPES+1] = {NULL};
                              /* Buffer to read VFP_POLICY table in all pipes */
    uint8 *buf = fc->scache_ptr[_FIELD_SCACHE_PART_0];
    uint8 *buf1 = fc->scache_ptr[_FIELD_SCACHE_PART_1];
    uint32 rval, dbl_wide_key, dbl_wide_key_sec;
    uint32 *vfp_tcam_buf = NULL; /* Buffer to read the VFP_TCAM table */
    uint32 *vfp_tcam_pipe_buf[_FP_MAX_NUM_PIPES+1] = {NULL};
                              /* Buffer to read VFP_TCAM table in all pipes */
    uint32 vfp_key2 = 0;
    uint32 temp;
    uint64 vfp_key_1;
    soc_field_t fld;
    vfp_tcam_entry_t *vfp_tcam_entry;
    vfp_policy_table_entry_t *vfp_policy_entry;
    _field_hw_qual_info_t hw_sels;
    _field_slice_t *fs;
    _field_group_t *fg;
    _field_entry_t *f_ent = NULL;
    bcm_pbmp_t entry_pbmp, temp_pbmp;
    uint8 old_physical_slice, slice_num;
    uint32 entry_flags;
    _field_slice_t *fs_temp = NULL;
    int inst, mem_inst, instance;  /* Pipe Instance. */
    uint8 valid_enable;
    soc_field_t vfp_en_flds[4] = {SLICE_ENABLE_SLICE_0f,
                                  SLICE_ENABLE_SLICE_1f,
                                  SLICE_ENABLE_SLICE_2f,
                                  SLICE_ENABLE_SLICE_3f};

    soc_reg_t vfp_control_1_reg;
    soc_reg_t vfp_control_2_reg;
    soc_reg_t vfp_slice_control_reg;
    soc_mem_t vfp_tcam;
    soc_mem_t vfp_policy_table;

    int size;
    int slice_size;
    _field_sliceidx_bmp_t sliceidx_bmp;
    int slice_offset;

    /* VALIDf in VFP_TCAM on TH2 only has one bit */
    int vfp_tcam_enabled;
    _field_action_bmp_t action_bmp;
    _field_entry_wb_info_t f_ent_wb_info;
    sliceidx_bmp.w = NULL;
    slice_size = 0;
    slice_offset = 0;
#if defined(BCM_TOMAHAWK2_SUPPORT) || defined (BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_enhanced) ||
        SOC_IS_TOMAHAWK3(unit)) {
        vfp_tcam_enabled = 1;
    } else
#endif /* BCM_TOMAHAWK2_SUPPORT */
    {
        vfp_tcam_enabled = 3;
    }

    /* Reset Action bitmap to NULL. */
    action_bmp.w = NULL;
    SOC_PBMP_CLEAR(entry_pbmp);
    sal_memset(expanded, 0, 4 * _FP_MAX_NUM_PIPES * sizeof(int));
    sal_memset(slice_master_idx, 0, 4 * _FP_MAX_NUM_PIPES * sizeof(int));

    /* Valid entry value */
    if ((soc_feature(unit, soc_feature_td3_style_fp)) ||
        (soc_feature(unit, soc_feature_th3_style_fp))) {
        valid_enable = 1;
    } else {
        valid_enable = 3;
    }

    if (fc->l2warm) {
        rv = _field_scache_stage_hdr_chk(fc, _FIELD_VFP_DATA_START);
        if (BCM_FAILURE(rv)) {
            return (rv);
        }

        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_10) {
           bcm_field_group_oper_mode_t oper_mode;

           /* Retrieve Stage Operational Mode. */
           oper_mode = buf[fc->scache_pos];

           LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                 "%s(): Recovering oper_mode:%d @ byte %d...\n\r"),
                  __func__, oper_mode, fc->scache_pos));

           fc->scache_pos++;

           if (stage_fc->oper_mode != oper_mode) {
              /* Initialize the stage with the given operational mode. */
              rv = _bcm_field_th_group_oper_mode_set(unit,
                                                  bcmFieldQualifyStageLookup,
                                                  oper_mode);
              if (BCM_FAILURE(rv)) {
                 return rv;
              }

              rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_LOOKUP,
                                         &stage_fc);
              BCM_IF_ERROR_RETURN(rv);
           }
        }
     }

    for (inst = 0; inst < stage_fc->num_instances; inst++) {
       if (!(fc->pipe_map & (1 << inst))) {
            continue;
       }
       mem_inst = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                   _FP_GLOBAL_INST : inst;
       instance = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                   _FP_MAX_NUM_PIPES : inst;

       BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                          VFP_KEY_CONTROL_1r,
                                                          mem_inst,
                                                          &vfp_control_1_reg));
       BCM_IF_ERROR_RETURN(_bcm_field_reg_instance_get(unit,
                                                          VFP_KEY_CONTROL_2r,
                                                          mem_inst,
                                                          &vfp_control_2_reg));

       BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit, VFP_TCAMm,
                                                          mem_inst, &vfp_tcam));
       BCM_IF_ERROR_RETURN(_bcm_field_mem_instance_get(unit,
                                                          VFP_POLICY_TABLEm,
                                                          mem_inst,
                                                          &vfp_policy_table));

       /* DMA various tables */
       vfp_tcam_buf = soc_cm_salloc(unit, sizeof(vfp_tcam_entry_t) *
                       soc_mem_index_count(unit, vfp_tcam),
                       "VFP TCAM buffer");
       if (NULL == vfp_tcam_buf) {
          rv = BCM_E_MEMORY;
          goto cleanup;
       }

       sal_memset(vfp_tcam_buf, 0, sizeof(vfp_tcam_entry_t) *
                         soc_mem_index_count(unit, vfp_tcam));
       index_min = soc_mem_index_min(unit, vfp_tcam);
       index_max = soc_mem_index_max(unit, vfp_tcam);

       fs = stage_fc->slices[inst];

       if (stage_fc->flags & _FP_STAGE_HALF_SLICE) {
           slice_ent_cnt = fs->entry_count * 2;
           /* DMA in chunks */
           for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
               fs = stage_fc->slices[inst] + slice_idx;
               if ((rv = soc_mem_read_range(unit, vfp_tcam,
                                MEM_BLOCK_ALL, slice_idx * slice_ent_cnt,
                     slice_idx * slice_ent_cnt + fs->entry_count / 2 - 1,
                               vfp_tcam_buf + slice_idx * slice_ent_cnt *
                         soc_mem_entry_words(unit, vfp_tcam))) < 0) {
                   goto cleanup;
               }

               if ((rv = soc_mem_read_range(unit, vfp_tcam,
                         MEM_BLOCK_ALL,
                         slice_idx * slice_ent_cnt + fs->entry_count,
                         slice_idx * slice_ent_cnt + fs->entry_count +
                         fs->entry_count / 2 - 1, vfp_tcam_buf +
                        (slice_idx * slice_ent_cnt + fs->entry_count)
                       * soc_mem_entry_words(unit, vfp_tcam))) < 0 ) {
                   goto cleanup;
               }
           }
       } else {
           slice_ent_cnt = fs->entry_count;
           if ((rv = soc_mem_read_range(unit, vfp_tcam, MEM_BLOCK_ALL,
                                    index_min, index_max, vfp_tcam_buf)) < 0 ) {
                goto cleanup;
           }
       }

       vfp_policy_buf = soc_cm_salloc(unit,
                        SOC_MEM_TABLE_BYTES(unit, vfp_policy_table),
                        "VFP POLICY TABLE buffer");
       if (NULL == vfp_policy_buf) {
          rv = BCM_E_MEMORY;
          goto cleanup;
       }
       sal_memset(vfp_policy_buf, 0, SOC_MEM_TABLE_BYTES
                                    (unit, vfp_policy_table));
       index_min = soc_mem_index_min(unit, vfp_policy_table);
       index_max = soc_mem_index_max(unit, vfp_policy_table);
       if ((rv = soc_mem_read_range(unit, vfp_policy_table,
                                    MEM_BLOCK_ALL, index_min, index_max,
                                    vfp_policy_buf)) < 0 ) {
             goto cleanup;
       }

       vfp_tcam_pipe_buf[instance] = vfp_tcam_buf;
       vfp_policy_pipe_buf[instance] = vfp_policy_buf;
       vfp_tcam_buf = NULL;
       vfp_policy_buf = NULL;
    }

    /* Get slice expansion status and virtual map for all the instances */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
       if (!(fc->pipe_map & (1 << inst))) {
            continue;
       }
       if ((rv = _field_th_slice_expanded_status_get(unit, inst, fc, stage_fc,
                                 expanded[inst], slice_master_idx[inst])) < 0) {
            goto cleanup;
       }
    }

    slice_offset = 0;
    if ((fc->l2warm) &&
        ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_27)) {
        /* get the total slice size*/
        slice_size = stage_fc->tcam_sz;
        size = SHR_BITALLOCSIZE(slice_size * _FP_MAX_NUM_PIPES);
        _FP_XGS3_ALLOC(sliceidx_bmp.w, size, "Sliceidx Bitmap");
        if (NULL == sliceidx_bmp.w) {
            rv = BCM_E_MEMORY;
            goto cleanup;
        }
        sal_memcpy (sliceidx_bmp.w, &buf[fc->scache_pos], size);
        fc->scache_pos += size;
    }


    /* Iterate over the instances. */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
       if (!(fc->pipe_map & (1 << inst))) {
            continue;
       }
       mem_inst = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                   _FP_GLOBAL_INST : inst;
       instance = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                   _FP_MAX_NUM_PIPES : inst;
       slice_offset = inst * slice_size;

       rv = _bcm_field_reg_instance_get(unit,
                                        VFP_KEY_CONTROL_1r,
                                        mem_inst, &vfp_control_1_reg);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }
       rv = _bcm_field_reg_instance_get(unit,
                                        VFP_KEY_CONTROL_2r,
                                        mem_inst, &vfp_control_2_reg);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }
       rv = _bcm_field_reg_instance_get(unit,
                                        VFP_SLICE_CONTROLr,
                                        mem_inst, &vfp_slice_control_reg);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }
       rv = _bcm_field_mem_instance_get(unit, VFP_TCAMm,
                                        mem_inst, &vfp_tcam);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }
       rv = _bcm_field_mem_instance_get(unit,
                                        VFP_POLICY_TABLEm,
                                        mem_inst,
                                        &vfp_policy_table);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }

       /* Iterate over the slices */
       if ((rv = soc_reg32_get(unit, vfp_slice_control_reg,
                               REG_PORT_ANY, 0, &rval)) < 0) {
           goto cleanup;
       }

       if ((rv = soc_reg_get(unit, vfp_control_1_reg, REG_PORT_ANY,
                             0, &vfp_key_1)) < 0) {
          goto cleanup;
       }
       /* In TD3, vfp_key_control_2 register is not avaliable.
        * we cannot match on Inner Ip header fields */
       if (!soc_feature(unit, soc_feature_vfp_no_inner_ip_fields_support)) {
           if ((rv = soc_reg32_get(unit, vfp_control_2_reg, REG_PORT_ANY,
                             0, &vfp_key2)) < 0) {
               goto cleanup;
           }
       }
       for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
           /* Ignore disabled slice */
           if (soc_reg_field_get(unit, vfp_slice_control_reg,
                                   rval, vfp_en_flds[slice_idx]) == 0) {
                continue;
           }
           /* Ignore secondary slice in paired mode */
           fld = _bcm_field_trx_slice_pairing_field[slice_idx / 2];
           paired = soc_reg64_field32_get(unit, vfp_control_1_reg,
                                          vfp_key_1, fld);

           fld = vfp_slice_wide_mode_flds[slice_idx];
           intraslice = soc_reg64_field32_get(unit,
                                              vfp_control_1_reg,
                                              vfp_key_1, fld);
           if (paired && (slice_idx % 2)) {
               continue;
           }

           /* Don't need to read selectors for expanded slice */
           if (expanded[inst][slice_idx]) {
               continue;
           }

           /* Skip if slice has no valid groups and entries */
           fs = stage_fc->slices[inst] + slice_idx;
           for (idx = 0; idx < slice_ent_cnt; idx++) {
               vfp_tcam_entry = soc_mem_table_idx_to_pointer
                                   (unit,
                                    vfp_tcam,
                                    vfp_tcam_entry_t *,
                                    vfp_tcam_pipe_buf[instance],
                                    idx + slice_ent_cnt * slice_idx);
               if (soc_mem_field32_get(unit, vfp_tcam,
                                       vfp_tcam_entry, VALIDf) != 0) {
                   break;
               } else {
                   if ((fc->l2warm) &&
                       ((fc->wb_recovered_version) >=
                       BCM_FIELD_WB_VERSION_1_27) &&
                       (_FP_SLICEIDX_BMP_TEST(sliceidx_bmp,
                       (idx + slice_ent_cnt * slice_idx) + slice_offset))) {
                       break;
                   }
               }
           }
           if (idx == slice_ent_cnt && !fc->l2warm) {
               continue;
           }
           /* If Level 2, retrieve the GIDs in this slice */
           if (fc->l2warm) {
               rv = _field_trx_scache_slice_group_recover(unit,
                                                          fc, inst,
                                                          slice_idx,
                                                          NULL,
                                                          stage_fc,
                                                          0);
               if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
                   fc->l2warm = 0;
                   goto cleanup;
               }
               if (rv == BCM_E_NOT_FOUND) {
                   rv = BCM_E_NONE;
                   continue;
               }
           }

           /* Construct the group based on HW selector values */
           _FIELD_SELCODE_CLEAR(hw_sels.pri_slice[0]);
           hw_sels.pri_slice[0].intraslice = _FP_SELCODE_DONT_USE;
           _FIELD_SELCODE_CLEAR(hw_sels.pri_slice[1]);
           hw_sels.pri_slice[1].intraslice = _FP_SELCODE_DONT_USE;
           _FIELD_SELCODE_CLEAR(hw_sels.sec_slice[0]);
           hw_sels.sec_slice[0].intraslice = _FP_SELCODE_DONT_USE;
           _FIELD_SELCODE_CLEAR(hw_sels.sec_slice[1]);
           hw_sels.sec_slice[1].intraslice = _FP_SELCODE_DONT_USE;

           /* Get primary slice's selectors */
           hw_sels.pri_slice[0].fpf1 = 0;
           hw_sels.pri_slice[0].fpf2
               = soc_reg64_field32_get(unit, vfp_control_1_reg,
                        vfp_key_1, _bcm_field_trx_vfp_field_sel[slice_idx][0]);

           hw_sels.pri_slice[0].fpf3
               = soc_reg64_field32_get(unit, vfp_control_1_reg,
                        vfp_key_1, _bcm_field_trx_vfp_field_sel[slice_idx][1]);
           hw_sels.pri_slice[0].ip_header_sel = 0;
          /* In TD3, vfp_key_control_2 register is not avaliable.
           * we cannot match on Inner Ip header fields */
           if (!soc_feature(unit, soc_feature_vfp_no_inner_ip_fields_support)) {
               hw_sels.pri_slice[0].ip_header_sel
                   = soc_reg_field_get(unit, vfp_control_2_reg,
                        vfp_key2, _bcm_field_trx_vfp_ip_header_sel[slice_idx]);
           }
           /* If intraslice, get double-wide key - only 2 options */
           if (intraslice) {
               dbl_wide_key = soc_reg64_field32_get(unit,
                                vfp_control_1_reg,
                                vfp_key_1,
                                _bcm_field_trx_vfp_double_wide_sel[slice_idx]);

               hw_sels.pri_slice[1].intraslice = TRUE;
               hw_sels.pri_slice[1].fpf2 = dbl_wide_key;
               hw_sels.pri_slice[1].fpf3 = 0;
               hw_sels.pri_slice[1].ip_header_sel = 0;
              /* In TD3, vfp_key_control_2 register is not avaliable.
               * we cannot match on Inner Ip header fields */
	       if (!soc_feature(unit, soc_feature_vfp_no_inner_ip_fields_support)) {
                   hw_sels.pri_slice[1].ip_header_sel
                       = soc_reg_field_get(unit, vfp_control_2_reg,
                            vfp_key2, _bcm_field_trx_vfp_ip_header_sel[slice_idx]);
	       }
           }

           /* If paired, get secondary slice's selectors */
           if (paired) {
               hw_sels.sec_slice[0].fpf1 = 0;
               hw_sels.sec_slice[0].fpf2
                   = soc_reg64_field32_get(unit, vfp_control_1_reg,
                    vfp_key_1, _bcm_field_trx_vfp_field_sel[slice_idx + 1][0]);

               hw_sels.sec_slice[0].fpf3
                   = soc_reg64_field32_get(unit, vfp_control_1_reg,
                    vfp_key_1, _bcm_field_trx_vfp_field_sel[slice_idx + 1][1]);
               hw_sels.sec_slice[0].ip_header_sel = 0;
               /* In TD3, vfp_key_control_2 register is not avaliable.
                * we cannot match on Inner Ip header fields */
               if (!soc_feature(unit, soc_feature_vfp_no_inner_ip_fields_support)) {
                   hw_sels.sec_slice[0].ip_header_sel
                       = soc_reg_field_get(unit, vfp_control_2_reg,
                         vfp_key2, _bcm_field_trx_vfp_ip_header_sel[slice_idx + 1]);
               }
               /* If in intraslie double wide mode, get DW keysel value. */
               if (intraslice) {
                   dbl_wide_key_sec
                       = soc_reg64_field32_get(unit,
                              vfp_control_1_reg, vfp_key_1,
                             _bcm_field_trx_vfp_double_wide_sel[slice_idx + 1]);

                   hw_sels.sec_slice[1].intraslice = TRUE;
                   hw_sels.sec_slice[1].fpf2 = dbl_wide_key_sec;
                   hw_sels.sec_slice[1].fpf3 = 0;
                   hw_sels.sec_slice[1].ip_header_sel = 0;
                   /* In TD3, vfp_key_control_2 register is not avaliable.
                    * we cannot match on Inner Ip header fields */
                   if (!soc_feature(unit, soc_feature_vfp_no_inner_ip_fields_support)) {
                       hw_sels.sec_slice[1].ip_header_sel
                           = soc_reg_field_get(unit,
                              vfp_control_2_reg, vfp_key2,
                              _bcm_field_trx_vfp_ip_header_sel[slice_idx + 1]);
                   }
               }
           }

           /* Create a group based on HW qualifiers (or find existing) */
           rv = _field_tr2_group_construct(unit, inst, &hw_sels, intraslice,
                        paired, fc, -1, _BCM_FIELD_STAGE_LOOKUP, slice_idx);

           if (BCM_FAILURE(rv)) {
               goto cleanup;
           }
           /* Now go over the entries */
           fs = stage_fc->slices[inst] + slice_idx;
           if (fs->group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
               fs->free_count >>= 1;
               ratio = 2;
           } else {
               ratio = 1;
           }
           prev_prio = -1;
           for (idx = 0; idx < slice_ent_cnt / ratio; idx++) {
               vfp_tcam_entry = soc_mem_table_idx_to_pointer
                                    (unit, vfp_tcam,
                                     vfp_tcam_entry_t *,
                                     vfp_tcam_pipe_buf[instance],
                                     idx + slice_ent_cnt * slice_idx);
               if (soc_mem_field32_get(unit, vfp_tcam,
                                       vfp_tcam_entry, VALIDf) == 0) {
                   if (!(fc->l2warm)) {
                       continue;
                   } else {
                       if ((fc->wb_recovered_version) <
                            BCM_FIELD_WB_VERSION_1_27) {
                           continue;
                       } else if (!(_FP_SLICEIDX_BMP_TEST(sliceidx_bmp,
                           (idx + slice_ent_cnt * slice_idx)+slice_offset))) {
                           continue;
                       }
                   }
               }

               /* Search groups to find match */
               fg = fc->groups;
               while (fg != NULL) {
                   /* Check if group is in this slice */
                   fs = &fg->slices[0];
                   if ((fg->instance != inst) ||
                       (fg->stage_id != stage_fc->stage_id) ||
                       (fs->slice_number != slice_idx)) {
                       fg = fg->next;
                       continue;
                   }
                   break;
               }

               if (fg == NULL) {
                  rv = BCM_E_INTERNAL;
                  goto cleanup;
               }

               SOC_PBMP_CLEAR(entry_pbmp);
               if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
                  SOC_PBMP_ASSIGN(entry_pbmp, PBMP_PORT_ALL(unit));
                  SOC_PBMP_OR(entry_pbmp, PBMP_CMIC(unit));
               } else {
                  SOC_PBMP_ASSIGN(entry_pbmp, PBMP_PIPE(unit, fg->instance));
                  BCM_PBMP_REMOVE(entry_pbmp, PBMP_LB(unit));
               }
               SOC_PBMP_ASSIGN(fg->pbmp, entry_pbmp);
               BCM_PBMP_OR(fs->pbmp, fg->pbmp);

               /* Allocate memory for the entry */
               rv = _bcm_field_entry_tcam_parts_count(unit, fg->stage_id,
                                                      fg->flags, &parts_count);
               if (BCM_FAILURE(rv)) {
                   goto cleanup;
               }

               mem_sz = parts_count * sizeof (_field_entry_t);
               _FP_XGS3_ALLOC(f_ent, mem_sz, "field entry");
               if (f_ent == NULL) {
                   rv = BCM_E_MEMORY;
                   goto cleanup;
               }
               for (idx1 = 0; idx1 < _FP_POLICER_LEVEL_COUNT; idx1++) {
                    f_ent->policer[idx1].pid = _FP_INVALID_INDEX;
               }


               sal_memset(&f_ent_wb_info, 0, sizeof(_field_entry_wb_info_t));
               f_ent_wb_info.action_bmp = &action_bmp;
               f_ent_wb_info.sid = f_ent_wb_info.pid = -1;
               if (fc->l2warm) {
                   if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
                       action_bmp.w = NULL;
                       _FP_XGS3_ALLOC(action_bmp.w,
                            SHR_BITALLOCSIZE(_bcmFieldActionNoParamCount),
                            "Action No Param Bitmap");
                       if (action_bmp.w == NULL) {
                          rv = BCM_E_MEMORY;
                          sal_free(f_ent);
                          goto cleanup;
                       }
                   }
                   rv = _field_trx_entry_info_retrieve(unit, fc, stage_fc,
                                                       0, &prev_prio,
                                                       &f_ent_wb_info);
                   if (BCM_FAILURE(rv)) {
                       sal_free(f_ent);
                       goto cleanup;
                   }
               } else {
                   _bcm_field_last_alloc_eid_incr(unit);
               }

               pri_tcam_idx = idx + slice_ent_cnt * slice_idx;
               for (i = 0; i < parts_count; i++) {
                   if (fc->l2warm) {
                       /* Use retrieved EID */
                       f_ent[i].eid = f_ent_wb_info.eid;
                      /* Set retrieved dvp_type and svp_type */
                       f_ent[i].dvp_type = f_ent_wb_info.dvp_type[i];
                       f_ent[i].svp_type = f_ent_wb_info.svp_type[i];
                       f_ent[i].prio = f_ent_wb_info.prio;
                   } else {
                       f_ent[i].eid = _bcm_field_last_alloc_eid_get(unit);
                   }
                   f_ent[i].group = fg;

                   rv = _bcm_field_tcam_part_to_entry_flags
                           (unit, i, fg, &f_ent[i].flags);
                   if (BCM_FAILURE(rv)) {
                       sal_free(f_ent);
                       goto cleanup;
                   }

                   if (f_ent_wb_info.color_independent) {
                       f_ent[i].flags |= _FP_ENTRY_COLOR_INDEPENDENT;
                   }
                   if (f_ent_wb_info.vfp_gport_type) {
                       f_ent[i].flags |= _FP_ENTRY_QUAL_PORT_TYPE_TRUNK;
                   }
                   rv = _bcm_field_entry_part_tcam_idx_get
                           (unit, f_ent, pri_tcam_idx, i, &part_index);
                   if (BCM_FAILURE(rv)) {
                       sal_free(f_ent);
                       goto cleanup;
                   }
                   rv = _bcm_field_tcam_idx_to_slice_offset(unit, stage_fc,
                                           inst, part_index, &slice_number,
                                               (int *)&f_ent[i].slice_idx);
                   if (BCM_FAILURE(rv)) {
                       sal_free(f_ent);
                       goto cleanup;
                   }
                   f_ent[i].fs = stage_fc->slices[inst] + slice_number;
                   if (0 == (f_ent[i].flags & _FP_ENTRY_SECOND_HALF)) {
                       /* Decrement slice free entry count for primary
                          entries. */
                       f_ent[i].fs->free_count--;
                   }

                   f_ent[i].fs->hw_ent_count++;

                   /* Assign entry to a slice */
                   f_ent[i].fs->entries[f_ent[i].slice_idx] = f_ent + i;
                   BCM_PBMP_OR(f_ent[i].fs->pbmp, fg->pbmp);
                   f_ent[i].flags |= _FP_ENTRY_INSTALLED;

                   if (soc_mem_field32_get(unit, vfp_tcam,
                                       vfp_tcam_entry, VALIDf) == valid_enable) {
                       f_ent[i].flags |= _FP_ENTRY_ENABLED;
                   } else {
                        if ((fc->l2warm) && (i != 0) &&
                            ((fc->wb_recovered_version) >=
                            BCM_FIELD_WB_VERSION_1_27) &&
                            ( _FP_SLICEIDX_BMP_TEST(sliceidx_bmp,
                            pri_tcam_idx + slice_offset) )) {

                            f_ent[i].flags |= _FP_ENTRY_ENABLED;
                        }
                    }

                   /* Get the actions associated with this part of the entry */
                   vfp_policy_entry = soc_mem_table_idx_to_pointer
                                       (unit,
                                        vfp_policy_table,
                                        vfp_policy_table_entry_t *,
                                        vfp_policy_pipe_buf[instance],
                                        part_index);
                   rv = _field_tr2_actions_recover
                           (unit,
                            vfp_policy_table,
                            (uint32 *) vfp_policy_entry,
                            f_ent, i, &f_ent_wb_info);
                   if (BCM_FAILURE(rv)) {
                       sal_free(f_ent);
                       goto cleanup;
                   }
                   if (action_bmp.w != NULL) {
                       _FP_ACTION_BMP_FREE(action_bmp);
                       action_bmp.w = NULL;
                   }

                   if (soc_feature(unit, soc_feature_advanced_flex_counter)) {
                       _field_adv_flex_stat_info_retrieve(unit,
                                         f_ent->statistic.sid);
                   }
               }
               rv = _field_group_entry_add(unit, fg, f_ent);
               if (BCM_FAILURE(rv)) {
                   sal_free(f_ent);
                   goto cleanup;
               }
               f_ent = NULL;
           }
           /* Free up the temporary slice group info */
           if (fc->l2warm) {
               if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_18) {
                   /* update selcode and construct group qual offset */
                   rv = _field_tr2_group_construct_quals_with_sel_update(unit, fc, stage_fc);
                   if (BCM_FAILURE(rv)) {
                       goto cleanup;
                   }
               }
               _field_scache_slice_group_free(unit, fc, slice_idx);
           }
       }
    }

    /* Iterate over the instances. */
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
       if (!(fc->pipe_map & (1 << inst))) {
            continue;
       }
       mem_inst = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                   _FP_GLOBAL_INST : inst;
       instance = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                   _FP_MAX_NUM_PIPES : inst;
       slice_offset = inst * slice_size;

       rv = _bcm_field_reg_instance_get(unit,
                                        VFP_KEY_CONTROL_1r,
                                        mem_inst,
                                        &vfp_control_1_reg);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }
       rv = _bcm_field_reg_instance_get(unit,
                                        VFP_KEY_CONTROL_2r,
                                        mem_inst,
                                        &vfp_control_2_reg);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }
       rv = _bcm_field_mem_instance_get(unit, VFP_TCAMm,
                                        mem_inst, &vfp_tcam);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }
       rv = _bcm_field_mem_instance_get(unit,
                                        VFP_POLICY_TABLEm,
                                        mem_inst,
                                        &vfp_policy_table);
       if (BCM_FAILURE(rv)) {
           goto cleanup;
       }

       /* Now go over the expanded slices */
       for (slice_idx = 0; slice_idx < stage_fc->tcam_slices; slice_idx++) {
            if (!expanded[inst][slice_idx]) {
               continue;
            }
            /* Ignore secondary slice in paired mode */
            fld = _bcm_field_trx_slice_pairing_field[slice_idx / 2];
            paired = soc_reg64_field32_get
                        (unit, vfp_control_1_reg,
                         vfp_key_1, fld);
            if (paired && (slice_idx % 2)) {
                continue;
            }
            /* Skip if slice has no valid groups and entries */
            fs = stage_fc->slices[inst] + slice_idx;
            for (idx = 0; idx < slice_ent_cnt; idx++) {
                vfp_tcam_entry = soc_mem_table_idx_to_pointer
                                     (unit, vfp_tcam,
                                      vfp_tcam_entry_t *,
                                      vfp_tcam_pipe_buf[instance],
                                      idx + slice_ent_cnt * slice_idx);
                if (soc_mem_field32_get(unit, vfp_tcam,
                                       vfp_tcam_entry, VALIDf) != 0) {
                    break;
                } else {
                    if ((fc->l2warm) &&
                        ((fc->wb_recovered_version) >=
                        BCM_FIELD_WB_VERSION_1_27) &&
                        (_FP_SLICEIDX_BMP_TEST(sliceidx_bmp,
                        (idx + slice_ent_cnt * slice_idx) + slice_offset))) {
                       break;
                    }
                }
            }

            if (idx == slice_ent_cnt) {
                continue;
            }

            /* If Level 2, retrieve the GIDs in this slice */
            if (fc->l2warm) {
                rv = _field_trx_scache_slice_group_recover
                        (unit,
                         fc, inst,
                         slice_idx,
                         NULL,
                         stage_fc,
                         0);
                if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
                    fc->l2warm = 0;
                    goto cleanup;
                }
                if (rv == BCM_E_NOT_FOUND) {
                    rv = BCM_E_NONE;
                    continue;
                }
            }

            /* Now find the master slice for this virtual group */
            vslice_idx = _field_physical_to_virtual(unit, inst,
                                                    slice_idx, stage_fc);
            if (vslice_idx < 0) {
                rv = BCM_E_INTERNAL;
                goto cleanup;
            }

            if (fc->l2warm
                    && ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_8)) {
                master_slice = slice_master_idx[inst][slice_idx];
            } else {
            max = -1;
              for (i = 0; i < stage_fc->tcam_slices; i++) {
                  if ((stage_fc->vmap[inst][0][vslice_idx].virtual_group ==
                       stage_fc->vmap[inst][0][i].virtual_group) &&
                       (i != vslice_idx)) {
                      if (i > max) {
                          max = i;
                      }
                  }
              }
              if (max < 0) {
                  rv = BCM_E_INTERNAL;
                  goto cleanup;
              }

              master_slice = stage_fc->vmap[inst][0][max].vmap_key;
            }
            /* See which group is in this slice - can be only one */
            fg = fc->groups;
            while (fg != NULL) {
                /* Check if group is in this slice */
                fs = &fg->slices[0];
                if ((fg->instance == inst) &&
                    (fg->stage_id == stage_fc->stage_id) &&
                    (fs->slice_number == master_slice)) {
                    break;
                }
                fg = fg->next;
            }
            if (fg == NULL) {
                rv = BCM_E_INTERNAL;
                goto cleanup;
            }

            /* Get number of entry parts for the group. */
            rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                                    fg->flags, &parts_count);
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }

            old_physical_slice = fs->slice_number;

            /* Set up the new physical slice parameters in Software */
            for(part_index = parts_count - 1; part_index >= 0; part_index--) {
                /* Get entry flags. */
                rv = _bcm_field_tcam_part_to_entry_flags(unit, part_index, fg,
                                                         &entry_flags);
                if (BCM_FAILURE(rv)) {
                    goto cleanup;
                }

                /* Get slice id for entry part */
                rv = _bcm_field_tcam_part_to_slice_number(unit, part_index,
                                                          fg, &slice_num);
                if (BCM_FAILURE(rv)) {
                    goto cleanup;
                }

                /* Get slice pointer. */
                fs = stage_fc->slices[inst] + slice_idx + slice_num;

                if (0 == (entry_flags & _FP_ENTRY_SECOND_HALF)) {
                    /* Set per slice configuration & number of
                     * free entries in the slice.*/
                    fs->free_count = fs->entry_count;
                    if (fg->flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                        fs->free_count >>= 1;
                    }
                    /* Set group flags in in slice.*/
                    fs->group_flags = fg->flags & _FP_GROUP_STATUS_MASK;

                    /* Add slice to slices linked list . */
                    fs_temp = stage_fc->slices[inst] +
                              old_physical_slice + slice_num;
                    /* To handle more than one auto expanded slice in a group */
                    while (fs_temp->next != NULL) {
                        fs_temp = fs_temp->next;
                    }
                    fs_temp->next = fs;
                    fs->prev = fs_temp;
                }
            }

            /* Now go over the entries */
            fs = stage_fc->slices[inst] + slice_idx;
            fs->group_flags = fg->flags & _FP_GROUP_STATUS_MASK;
            if (fs->group_flags & _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                ratio = 2;
            } else {
                ratio = 1;
            }

            prev_prio = -1;
            for (idx = 0; idx < slice_ent_cnt / ratio; idx++) {
                vfp_tcam_entry = soc_mem_table_idx_to_pointer
                                     (unit,
                                      vfp_tcam,
                                      vfp_tcam_entry_t *,
                                      vfp_tcam_pipe_buf[instance],
                                      idx + slice_ent_cnt * slice_idx);
                if (soc_mem_field32_get(unit, vfp_tcam,
                                       vfp_tcam_entry, VALIDf) == 0) {
                    if (!(fc->l2warm)) {
                        continue;
                    } else {
                        if ((fc->wb_recovered_version) <
                            BCM_FIELD_WB_VERSION_1_27){
                            continue;
                        } else if (!(_FP_SLICEIDX_BMP_TEST(sliceidx_bmp,
                            (idx + slice_ent_cnt * slice_idx)+slice_offset))) {
                            continue;
                        }
                    }
                }

                /* All ports are applicable to this entry */
                SOC_PBMP_CLEAR(entry_pbmp);
                if (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) {
                   SOC_PBMP_ASSIGN(entry_pbmp, PBMP_PORT_ALL(unit));
                   SOC_PBMP_OR(entry_pbmp, PBMP_CMIC(unit));
                } else {
                   SOC_PBMP_ASSIGN(entry_pbmp, PBMP_PIPE(unit, fg->instance));
                   BCM_PBMP_REMOVE(entry_pbmp, PBMP_LB(unit));
                }


                /* Search groups to find match */
                fg = fc->groups;
                while (fg != NULL) {
                    /* Check if group is in this slice */
                    fs = &fg->slices[0];
                    if ((fg->instance != inst) ||
                        (fg->stage_id != stage_fc->stage_id) ||
                        (fs->slice_number != master_slice)) {
                        fg = fg->next;
                        continue;
                    }

                    /* Check if entry_pbmp is a subset of group pbmp */
                    SOC_PBMP_ASSIGN(temp_pbmp, fg->pbmp);
                    SOC_PBMP_AND(temp_pbmp, entry_pbmp);
                    if (SOC_PBMP_EQ(temp_pbmp, entry_pbmp)) {
                        break;
                    }
                    fg = fg->next;
                }

                if (fg == NULL) {
                    goto cleanup;
                }

                /* Allocate memory for the entry */
                rv = _bcm_field_entry_tcam_parts_count(unit,fg->stage_id,
                                                       fg->flags, &parts_count);
                if (BCM_FAILURE(rv)) {
                    goto cleanup;
                }
                mem_sz = parts_count * sizeof (_field_entry_t);
                _FP_XGS3_ALLOC(f_ent, mem_sz, "field entry");
                if (f_ent == NULL) {
                    rv = BCM_E_MEMORY;
                    goto cleanup;
                }

                for (idx1 = 0; idx1 < _FP_POLICER_LEVEL_COUNT; idx1++) {
                     f_ent->policer[idx1].pid = _FP_INVALID_INDEX;
                }

                sal_memset(&f_ent_wb_info, 0, sizeof(_field_entry_wb_info_t));
                f_ent_wb_info.action_bmp = &action_bmp;
                f_ent_wb_info.sid = f_ent_wb_info.pid = -1;
                if (fc->l2warm) {
                    if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
                        action_bmp.w = NULL;
                        _FP_XGS3_ALLOC(action_bmp.w,
                            SHR_BITALLOCSIZE(_bcmFieldActionNoParamCount),
                            "Action No Param Bitmap");
                        if (action_bmp.w == NULL) {
                          rv = BCM_E_MEMORY;
                          sal_free(f_ent);
                          goto cleanup;
                        }
                    }
                    rv = _field_trx_entry_info_retrieve
                            (unit, fc, stage_fc, 0, &prev_prio,
                             &f_ent_wb_info);
                    if (BCM_FAILURE(rv)) {
                        sal_free(f_ent);
                        goto cleanup;
                    }
                } else {
                    _bcm_field_last_alloc_eid_incr(unit);
                }
                pri_tcam_idx = idx + slice_ent_cnt * slice_idx;
                for (i = 0; i < parts_count; i++) {
                    if (fc->l2warm) {
                        /* Use retrieved EID */
                        f_ent[i].eid = f_ent_wb_info.eid;
                        /* Set retrieved dvp_type and svp_type */
                        f_ent[i].dvp_type = f_ent_wb_info.dvp_type[i];
                        f_ent[i].svp_type = f_ent_wb_info.svp_type[i];
                        f_ent[i].prio = f_ent_wb_info.prio;
                    } else {
                        f_ent[i].eid = _bcm_field_last_alloc_eid_get(unit);
                    }
                    f_ent[i].group = fg;

                    rv = _bcm_field_tcam_part_to_entry_flags(unit, i, fg,
                                                        &f_ent[i].flags);
                    if (BCM_FAILURE(rv)) {
                        sal_free(f_ent);
                        goto cleanup;
                    }

                    if (f_ent_wb_info.color_independent) {
                        f_ent[i].flags |= _FP_ENTRY_COLOR_INDEPENDENT;
                    }
                    if (f_ent_wb_info.vfp_gport_type) {
                       f_ent[i].flags |= _FP_ENTRY_QUAL_PORT_TYPE_TRUNK;
                    }
                    rv = _bcm_field_entry_part_tcam_idx_get(unit, f_ent,
                                          pri_tcam_idx, i, &part_index);
                    if (BCM_FAILURE(rv)) {
                        sal_free(f_ent);
                        goto cleanup;
                    }
                    rv = _bcm_field_tcam_idx_to_slice_offset(unit, stage_fc,
                                            inst, part_index, &slice_number,
                                                (int *)&f_ent[i].slice_idx);
                    if (BCM_FAILURE(rv)) {
                        sal_free(f_ent);
                        goto cleanup;
                    }
                    f_ent[i].fs = stage_fc->slices[inst] + slice_number;
                    if (0 == (f_ent[i].flags & _FP_ENTRY_SECOND_HALF)) {
                        /* Decrement slice free entry count for primary
                           entries. */
                        f_ent[i].fs->free_count--;
                    }

                    f_ent[i].fs->hw_ent_count++;

                    /* Assign entry to a slice */
                    f_ent[i].fs->entries[f_ent[i].slice_idx] = f_ent + i;
                    BCM_PBMP_OR(f_ent[i].fs->pbmp, fg->pbmp);
                    f_ent[i].flags |= _FP_ENTRY_INSTALLED;

                    if (soc_mem_field32_get(unit, vfp_tcam,
                                            vfp_tcam_entry, VALIDf) == vfp_tcam_enabled) {
                        f_ent[i].flags |= _FP_ENTRY_ENABLED;
                    } else {
                        if ((fc->l2warm) && (i != 0) &&
                            ((fc->wb_recovered_version) >=
                            BCM_FIELD_WB_VERSION_1_27) &&
                            ( _FP_SLICEIDX_BMP_TEST(sliceidx_bmp,
                            pri_tcam_idx + slice_offset) )) {
                            f_ent[i].flags |= _FP_ENTRY_ENABLED;
                        }
                    }

                    /* Get the actions associated with this part of the entry */
                    vfp_policy_entry = soc_mem_table_idx_to_pointer
                                        (unit,
                                         vfp_policy_table,
                                         vfp_policy_table_entry_t *,
                                         vfp_policy_pipe_buf[instance],
                                         part_index);
                    rv = _field_tr2_actions_recover(unit,
                                                    vfp_policy_table,
                                            (uint32 *) vfp_policy_entry, f_ent,
                                                    i, &f_ent_wb_info);
                    if (BCM_FAILURE(rv)) {
                        sal_free(f_ent);
                        goto cleanup;
                    }
                    if (action_bmp.w != NULL) {
                       _FP_ACTION_BMP_FREE(action_bmp);
                       action_bmp.w = NULL;
                    }

                    if (soc_feature(unit, soc_feature_advanced_flex_counter)) {
                        _field_adv_flex_stat_info_retrieve(unit,
                                                          f_ent->statistic.sid);
                    }
                }
                rv = _field_group_entry_add(unit, fg, f_ent);
                if (BCM_FAILURE(rv)) {
                    sal_free(f_ent);
                    goto cleanup;
                }
                f_ent = NULL;
            }
            /* Free up the temporary slice group info */
            if (fc->l2warm) {
                _field_scache_slice_group_free(unit, fc, slice_idx);
            }
        }
    }


    if (fc->l2warm) {

        /* Mark end of Slice Info */
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
            fc->scache_pos++;
        }

        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
            if (stage_fc->stage_id == _BCM_FIELD_STAGE_LOOKUP) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,"Recovering hint Ids "
                                    "from pos = %d\r\n"), fc->scache_pos));
                rv = _bcm_hints_scache_hintid_recover(unit, stage_fc,
                            fc, &buf[fc->scache_pos]);
                if (BCM_FAILURE(rv)) {
                    goto cleanup;
                }
            }
        }

        /* Group Slice Selectors */
        if ((fc->wb_recovered_version) >= BCM_FIELD_WB_VERSION_1_15) {
            rv = (_field_group_slice_selectors_recover(unit,
                        &buf[fc->scache_pos], stage_fc->stage_id));
            if (BCM_FAILURE(rv)) {
                goto cleanup;
            }
        }

        temp = 0;
        temp |= buf[fc->scache_pos];
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 8;
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 16;
        fc->scache_pos++;
        temp |= buf[fc->scache_pos] << 24;
        fc->scache_pos++;
        if (temp != _FIELD_VFP_DATA_END) {
            fc->l2warm = 0;
            rv = BCM_E_INTERNAL;
        }

        if (NULL != buf1) {
            temp = 0;
            temp |= buf1[fc->scache_pos1];
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 8;
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 16;
            fc->scache_pos1++;
            temp |= buf1[fc->scache_pos1] << 24;
            fc->scache_pos1++;
            if (temp != _FIELD_VFP_DATA_END) {
                fc->l2warm = 0;
                rv = BCM_E_INTERNAL;
            }
        }
    }

    if (BCM_SUCCESS(rv)) {
        _field_group_slice_vmap_recovery(unit, fc, stage_fc);
    }

    _field_tr2_stage_reinit_all_groups_cleanup(unit, fc,
                          _BCM_FIELD_STAGE_LOOKUP, NULL);

cleanup:
    for (inst = 0; inst < stage_fc->num_instances; inst++) {
        if (!(fc->pipe_map & (1 << inst))) {

             continue;
        }
         instance = (stage_fc->oper_mode == bcmFieldGroupOperModeGlobal) ?
                     _FP_MAX_NUM_PIPES : inst;

        if (vfp_tcam_pipe_buf[instance]) {
           soc_cm_sfree(unit, vfp_tcam_pipe_buf[instance]);
        }
        if (vfp_policy_pipe_buf[instance]) {
           soc_cm_sfree(unit, vfp_policy_pipe_buf[instance]);
        }
    }
    if (vfp_tcam_buf) {
       soc_cm_sfree(unit, vfp_tcam_buf);
    }
    if (vfp_policy_buf) {
       soc_cm_sfree(unit, vfp_policy_buf);
    }
    if (action_bmp.w != NULL) {
       _FP_ACTION_BMP_FREE(action_bmp);
       action_bmp.w = NULL;
    }
    if (NULL != sliceidx_bmp.w) {
        sal_free(sliceidx_bmp.w);
        sliceidx_bmp.w = NULL;
    }
    return rv;

}


               /*  END OF WARMBOOT ROUTINES */
#endif  /* BCM_WARM_BOOT_SUPPORT */

#else /* BCM_TOMAHAWK_SUPPORT && BCM_FIELD_SUPPORT */
typedef int _th_field_not_empty; /* Make ISO compilers happy. */
#endif  /* BCM_TOMAHAWK_SUPPORT && BCM_FIELD_SUPPORT */
