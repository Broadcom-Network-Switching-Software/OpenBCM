/*
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * File:        port.c
 * Purpose:     Tracks and manages ports.
 *              P-VLAN table is managed directly.
 *              MAC/PHY interfaces are managed through respective drivers.
 */

#include <shared/bsl.h>

#include <assert.h>

#include <sal/core/libc.h>
#include <sal/core/boot.h>
#include <shared/bsl.h>

#include <soc/cm.h>
#include <soc/drv.h>
#include <soc/scache.h>
#include <soc/phy.h>
#include <soc/ll.h>
#include <soc/ptable.h>
#include <soc/firebolt.h>
#include <soc/xaui.h>
#include <soc/phyctrl.h>
#include <soc/phyreg.h>
#include <soc/higig.h>
#include <soc/hash.h>
#include <soc/macutil.h>

#include <bcm/port.h>
#include <bcm/error.h>
#include <bcm/mirror.h>

#ifdef SW_AUTONEG_SUPPORT
#include <bcm_int/common/sw_an.h>
#endif

#include <bcm_int/api_xlate_port.h>
#include <bcm_int/common/lock.h>
#include <bcm_int/common/tx.h>
#include <bcm_int/common/sat.h>
#include <bcm_int/esw/mbcm.h>
#include <bcm_int/esw/port.h>
#include <bcm_int/esw/link.h>
#include <bcm_int/esw/mirror.h>
#include <bcm_int/esw/stack.h>
#include <bcm_int/esw/stat.h>
#include <bcm_int/esw/timesync.h>
#include <bcm_int/esw/firebolt.h>
#include <bcm_int/esw/portctrl.h>
#include <bcm_int/esw/vxlan.h>
#if defined(BCM_TRIUMPH_SUPPORT)
#include <bcm_int/esw/triumph.h>
#include <bcm_int/esw/virtual.h>
#endif /* BCM_TRIUMPH_SUPPORT */
#if defined(BCM_SCORPION_SUPPORT)
#include <bcm_int/esw/scorpion.h>
#include <bcm_int/esw/triumph.h>
#endif /* BCM_SCORPION_SUPPORT */
#if defined(BCM_TRX_SUPPORT)
#include <bcm_int/esw/trx.h>
#endif /* BCM_TRX_SUPPORT */
#if defined(BCM_TRIUMPH2_SUPPORT)
#include <bcm_int/esw/triumph2.h>
#include <soc/triumph2.h>
#endif /* BCM_TRIUMPH2_SUPPORT */
#if defined(BCM_TRIDENT_SUPPORT)
#include <bcm_int/esw/trident.h>
#endif /* BCM_TRIUMPH2_SUPPORT */
#if defined(BCM_KATANA_SUPPORT)
#include <bcm_int/esw/katana.h>
#endif /* BCM_KATANA_SUPPORT */
#if defined(BCM_APACHE_SUPPORT)
#include <bcm_int/esw/monterey.h>
#include <soc/monterey.h>
#endif /* BCM_MONTEREY_SUPPORT */
#if defined(BCM_APACHE_SUPPORT)
#include <bcm_int/esw/apache.h>
#include <soc/apache.h>
#endif /* BCM_APACHE_SUPPORT */
#if defined(BCM_ENDURO_SUPPORT)
#include <bcm_int/esw/enduro.h>
#endif /* BCM_ENDURO_SUPPORT */
#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_HURRICANE2_SUPPORT)
#include <bcm_int/esw/hurricane.h>
#endif /* BCM_HURRICANE_SUPPORT */
#if defined(BCM_HURRICANE2_SUPPORT)
#include <soc/hurricane2.h>
#endif /* BCM_HURRICANE_SUPPORT */
#if defined(BCM_SHADOW_SUPPORT)
#include <soc/shadow.h>
#endif /* BCM_SHADOW_SUPPORT */
#if defined(BCM_TRIUMPH3_SUPPORT)
#include <bcm_int/esw/triumph3.h>
#include <soc/triumph3.h>
#include <bcm_int/esw/extender.h>
#endif /* BCM_TRIUMPH3_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT)
#include <bcm_int/esw/trident2.h>
#include <soc/trident2.h>
#include <bcm_int/esw/trunk.h>
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TOMAHAWK_SUPPORT)
#include <bcm_int/esw/tomahawk.h>
#include <soc/tomahawk.h>
#endif /* BCM_TOMAHAWK_SUPPORT */
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
#include <bcm_int/esw/trident2plus.h>
#include  <soc/td2_td2p.h>
#include <bcm_int/esw/subport.h>
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
#if defined(BCM_TRIDENT3_SUPPORT)
#include <soc/esw/cancun.h>
#include <bcm_int/esw/trident3.h>
#include <soc/trident3.h>
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_HELIX5_SUPPORT)
#include <soc/esw/cancun.h>
#include <bcm_int/esw/helix5.h>
#include <soc/helix5.h>
#endif /* BCM_HELIX5_SUPPORT */
#if defined(BCM_MAVERICK2_SUPPORT)
#include <soc/esw/cancun.h>
#include <bcm_int/esw/maverick2.h>
#include <soc/maverick2.h>
#endif /* BCM_MAVERICK2_SUPPORT */
#if defined(BCM_TOMAHAWK3_SUPPORT)
#include <bcm_int/esw/tomahawk3.h>
#include <bcm_int/esw/pfc.h>
#include <bcm_int/esw/xgs5.h>
#include <soc/tomahawk3.h>
#endif /* BCM_TOMAHAWK3_SUPPORT */
#if defined(BCM_HURRICANE4_SUPPORT)
#include <soc/esw/cancun.h>
#include <bcm_int/esw/hurricane4.h>
#include <soc/hurricane4.h>
#endif /* BCM_HURRICANE4_SUPPORT */
#if defined(BCM_FIREBOLT6_SUPPORT)
#include <soc/esw/cancun.h>
#include <bcm_int/esw/firebolt6.h>
#include <soc/firebolt6.h>
#endif /* BCM_FIREBOLT6_SUPPORT */
#if defined (BCM_HGPROXY_COE_SUPPORT)
#include <bcm_int/esw/xgs5.h>
#include <bcm_int/esw/subport.h>
#endif /* BCM_HGPROXY_COE_SUPPORT */
#if defined(BCM_TOMAHAWK2_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
#include <bcm_int/esw/tomahawk2.h>
#endif /* BCM_TOMAHAWK2_SUPPORT || BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TOMAHAWK2_SUPPORT)
#include <bcm_int/esw/xgs5.h>
#include <soc/tomahawk2.h>
#endif /* BCM_TOMAHAWK2_SUPPORT */
#include <bcm_int/esw/xgs3.h>

#include <bcm_int/esw/flex_ctr.h>
#include <bcm_int/esw/policer.h>
#if defined(BCM_KATANA2_SUPPORT)
#include <bcm_int/esw/subport.h>
#include <bcm_int/esw/katana2.h>
#include <soc/katana2.h>
#include <bcm/subport.h>
#endif /* BCM_KATANA2_SUPPORT */
#if defined(BCM_SABER2_SUPPORT)
#include <bcm_int/esw/saber2.h>
#include <soc/saber2.h>
#endif /* BCM_SABER2_SUPPORT */
#if defined(BCM_METROLITE_SUPPORT)
#include <bcm_int/esw/metrolite.h>
#include <soc/metrolite.h>
#endif /* BCM_METROLITE_SUPPORT */
#if defined(BCM_GREYHOUND_SUPPORT)
#include <bcm_int/esw/greyhound.h>
#endif /* BCM_GREYHOUND_SUPPORT */
#if defined(BCM_HURRICANE3_SUPPORT)
#include <bcm_int/esw/hurricane3.h>
#include <soc/hurricane3.h>
#endif /* BCM_HURRICANE3_SUPPORT */
#if defined(BCM_GREYHOUND2_SUPPORT)
#include <bcm_int/esw/greyhound2.h>
#endif /* BCM_GREYHOUND2_SUPPORT */
#if defined (BCM_EP_REDIRECT_VERSION_2)
#include <bcm_int/esw/xgs5.h>
#endif
#if defined(BCM_HGPROXY_COE_SUPPORT)
#include <bcm_int/esw/subport.h>
#include <bcm_int/esw/xgs5.h>
#endif /* BCM_HGPROXY_COE_SUPPORT */
#if defined(BCM_PREEMPTION_SUPPORT)
#include <bcm_int/esw/preemption.h>
#include <bcm_int/esw/preemption_cnt.h>
#endif /* BCM_PREEMPTION_SUPPORT */
#include <bcm_int/esw_dispatch.h>

#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_WARM_BOOT_SUPPORT)
#include <bcm_int/esw/switch.h>
#endif /* BCM_WARM_BOOT_SUPPORT */

#if defined(BCM_TRIUMPH2_SUPPORT)
#include <bcm_int/esw/qos.h>
#endif /* BCM_TRIUMPH2_SUPPORT */

#ifdef PORTMOD_SUPPORT
#include <soc/portmod/portmod.h>
#endif /* PORTMOD_SUPPORT */

#ifdef BCM_XGS5_SWITCH_PORT_SUPPORT
#include <bcm_int/esw/xgs5.h>
#endif /* BCM_XGS5_SWITCH_PORT_SUPPORT */

#ifdef INCLUDE_FCMAP
#include <../../phyident.h>
#endif

#define BCMI_GPORT_TYPE_VALID(port)         \
        (BCM_GPORT_IS_VLAN_PORT(port) ||     \
         BCM_GPORT_IS_NIV_PORT(port) ||      \
         BCM_GPORT_IS_EXTENDER_PORT(port) || \
         BCM_GPORT_IS_SUBPORT_PORT(port) ||  \
         BCM_GPORT_IS_VXLAN_PORT(port) ||  \
         BCM_GPORT_IS_L2GRE_PORT(port) ||  \
         BCM_GPORT_IS_MIM_PORT(port) || \
         BCM_GPORT_IS_MPLS_PORT(port) || \
         BCM_GPORT_IS_FLOW_PORT(port) || \
         BCM_GPORT_IS_TRUNK(port))


#if defined (BCM_EP_REDIRECT_VERSION_2)
#define BCMI_EP_REDIRECT_PORT (74)
#endif

#define _BCM_QOS_MAP_CHUNK_EGR_DSCP 64
#define _BCM_I2E_CLASS_ID_MAX   0x1ff

/*
 * Define the macro for measuring the benchmark of speed change.
 */
#define BCM_PORT_SPEED_CHANGE_BENCHMARK

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
#define MODULE_ID_LOWER_6_BITS(a) ((a) = ((a) & 0x3f))
#endif

/*
 * Port Function Vector Driver
 */
bcm_esw_port_drv_t    *bcm_esw_port_drv[BCM_MAX_NUM_UNITS] = {0};

/*
 * Variable:
 *      bcm_port_info
 * Purpose:
 *      One entry for each SOC device containing port information
 *      for that device.  Use the PORT macro to access it.
 */
static _bcm_port_info_t     *bcm_port_info[BCM_MAX_NUM_UNITS];

STATIC _bcm_port_force_forward_linkstate_t p_linkstate[BCM_MAX_NUM_UNITS];

#define PORT(unit, port)        bcm_port_info[unit][port]

extern int inside_bcm_shutdown[BCM_MAX_NUM_UNITS];

#if defined(BCM_XMAC_SUPPORT)
extern int _mac_x_reinit(int unit, soc_port_t port);
#endif

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
extern src_modid_base_index_bookkeeping_t *src_modid_base_index_bk[BCM_MAX_NUM_UNITS];
#endif

#if defined(BCM_TRIDENT3_SUPPORT)
extern int
_bcm_fb2_egr_vlan_control_field_get(int unit, bcm_port_t port,
soc_field_t field, uint32 *value);
extern int
_bcm_fb2_port_tpid_enable_set(int unit, bcm_port_t port, uint32 tpid_enable);
extern int
_bcm_fb2_port_tpid_enable_get(int unit, bcm_port_t port, uint32 *tpid_enable);
#endif

/* Accessor to bcm_port_info used by other modules */
void _bcm_port_info_access(int unit, bcm_port_t port, _bcm_port_info_t **info)
{
    (bcm_port_info[unit] != NULL) ? (*info = &PORT(unit, port)):(*info = NULL);
    return;
}

/* Return On error with port mutex unlocked */
#define _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(op)  \
    do {                                        \
        int __rv__;                             \
        if (((__rv__ = (op)) < 0)) {            \
            PORT_UNLOCK(unit);                  \
            _SHR_ERROR_TRACE(__rv__);           \
            return(__rv__);                     \
        }                                       \
    } while(0)

int
_bcm_esw_port_gport_phyn_validate(int unit, bcm_port_t port,
                                  bcm_port_t *local_port, int *phyn,
                                  int *phy_lane, int *sys_side);

#if defined(BCM_KATANA2_SUPPORT)
   int _bcm_kt2_update_port_mode(int unit, uint8 port, int speed);
   int _bcm_kt2_cosq_dynamic_port_encap_change(int unit, bcm_port_t port);
#endif

#if defined(BCM_METROLITE_SUPPORT)
int _bcm_ml_update_port_mode(int unit, uint8 port, int speed);
#endif
#if defined(BCM_SABER2_SUPPORT)
int _bcm_sb2_update_port_mode(int unit, uint8 port, int speed);
#ifdef BCM_WARM_BOOT_SUPPORT
int bcm_sb2_wb_v2_flexio_update = 0;
#endif
#endif
#if defined(BCM_TRIUMPH3_SUPPORT)
STATIC int
_bcm_port_force_forward_add(int unit, bcm_port_t local_port,
                                    bcm_port_t egr_port);

STATIC int
_bcm_port_force_forward_init(int unit);

STATIC int
_bcm_port_force_forward_deinit(int unit);

#ifdef BCM_WARM_BOOT_SUPPORT
STATIC int
_bcm_port_force_forward_sync(int unit, uint8 **scache_ptr);

STATIC int
_bcm_port_force_forward_reinit(int unit, uint8 **scache_ptr);

STATIC int
_bcm_port_force_forward_scache_size(int unit, int *size);
#endif /* BCM_WARM_BOOT_SUPPORT */
#endif /* defined(BCM_TRIUMPH3_SUPPORT) */

/*
 * Define:
 *      PORT_INIT
 * Purpose:
 *      Causes a routine to return BCM_E_INIT if port is not yet initialized.
 */

#define PORT_INIT(unit) \
        if (bcm_port_info[unit] == NULL) { return BCM_E_INIT; }

/*
 * Define:
 *      PORT_PARAM_CHECK
 * Purpose:
 *      Check unit and port parameters for most bcm_port api calls
 */
#define PORT_PARAM_CHECK(unit, port) do { \
        PORT_INIT(unit); \
        if (!SOC_PORT_VALID(unit, port)) { return BCM_E_PORT; } \
        } while (0);

/*
 * Define:
 *      PORT_SWITCHED_CHECK
 * Purpose:
 *      Check unit and port for switching feature support
 */
#define PORT_SWITCHED_CHECK(unit, port) do { \
        if (IS_ST_PORT(unit, port)) { \
            return BCM_E_PORT; \
        } else { \
            if (IS_CPU_PORT(unit, port)) { \
                if (!soc_feature(unit, soc_feature_cpuport_switched)) { \
                    return BCM_E_PORT; \
                } \
            } \
        } \
        } while (0);


/*
 * Define:
 *      PORT_INFO_RX_LOS_SET
 * Purpose:
 *      Records the SW RX LOS configuration used for warmboot recovery
 */
#define PORT_INFO_RX_LOS_SET(_u, _p, _type, _val) do {                  \
        if (_type == BCM_PORT_PHY_CONTROL_SOFTWARE_RX_LOS) {            \
            PORT(_u, _p).rx_los = _val;                                 \
        }                                                               \
    } while (0);


#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_KATANA2_SUPPORT) \
    || defined(BCM_TRIUMPH3_SUPPORT)
 #define BCM_MAX_PORTS_SUPPORT_FOR_DMVOQ 64
#endif
#ifdef BCM_TRIUMPH2_SUPPORT
typedef int _port_src_mod_egr_prof_ptr_t;
STATIC _port_src_mod_egr_prof_ptr_t
    port_src_mod_egr_prof_ptr[BCM_MAX_NUM_UNITS][SOC_MAX_NUM_PORTS];
#define PORT_SRC_MOD_EGR_PROF_PTR(_u, _p) port_src_mod_egr_prof_ptr[_u][_p]

STATIC soc_profile_mem_t *_bcm_src_mod_egr_profile[BCM_MAX_NUM_UNITS];
#define PORT_SRC_MOD_EGR_PROFILE(_u) _bcm_src_mod_egr_profile[_u]

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
STATIC
bcm_error_t _bcm_esw_port_stat_get_table_info(
                   int                        unit,
                   bcm_gport_t                port,
                   uint32                     *num_of_tables,
                   bcm_stat_flex_table_info_t *table_info);
#endif /* BCM_KATANA_SUPPORT || BCM_TRIUMPH3_SUPPORT */
#endif /* BCM_TRIUMPH2_SUPPORT */

#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_TRIDENT_SUPPORT) ||\
defined(BCM_HAWKEYE_SUPPORT) || defined(BCM_SHADOW_SUPPORT) || defined(BCM_HURRICANE2_SUPPORT)
/* EEE standard compliance Work Around:
 * To Maintain software state of native eee in MAC*/
STATIC int eee_cfg[BCM_MAX_NUM_UNITS][SOC_MAX_NUM_PORTS];
#endif

#ifdef BCM_TRIUMPH3_SUPPORT
STATIC int _bcm_tr3_port_lanes_set(int unit, bcm_port_t port, int value);
STATIC int _bcm_tr3_port_lanes_get(int unit, bcm_port_t port, int *value);
#endif /* BCM_TRIUMPH3_SUPPORT */

/*
 * The Port Monitor Thread is intended for handling work-arounds
 * that are unneeded in most cases. In order to avoid unnecessary
 * processing overhead the thread is not started by default, but
 * only if so requested through configuration parameters.
 */

typedef struct _port_mon_ctrl_s
{
    char taskname[16];
    sal_sem_t sema;
    int interval;
    int running;
    int stop;
    int unit;
    uint32 gtuc;
    uint32 gtmca;
    uint32 gtbca;
    uint32 gtlcl;
    uint32 gtpok;
} _port_mon_ctrl_t;

STATIC _port_mon_ctrl_t _bcm_esw_port_mon_ctrl[BCM_MAX_NUM_UNITS];

#define PORT_MON_CTRL(_u) (&_bcm_esw_port_mon_ctrl[_u])

#define PORT_MON_INTERVAL_MIN   100000

int
_bcm_port_mac_init(int unit, bcm_port_t port, int *okay);

#if defined(BCM_TRIDENT3_SUPPORT)
STATIC int
_bcm_esw_td3_asf_init(int unit, soc_td3_asf_mode_e asf_mode);
STATIC int
_bcm_esw_td3_port_asf_mode_set(int unit, bcm_port_t port, int mode);
#endif

#if defined(BCM_MAVERICK2_SUPPORT)
STATIC int
_bcm_esw_mv2_asf_init(int unit, soc_mv2_asf_mode_e asf_mode);
STATIC int
_bcm_esw_mv2_port_asf_mode_set(int unit, bcm_port_t port, int mode);
#endif

#if defined(BCM_TOMAHAWK_SUPPORT)
STATIC int
_bcm_esw_asf_init(int unit, soc_th_asf_mode_e asf_mode);

STATIC int
_bcm_esw_asf_deinit(int unit);

#ifdef BCM_WARM_BOOT_SUPPORT
STATIC int
_bcm_esw_asf_wb_memsz_get(int unit, uint32* const mem_sz, uint16 scache_ver);

STATIC int
_bcm_esw_asf_wb_sync(int unit, uint8* wb_data);

STATIC int
_bcm_esw_asf_wb_recover(int unit, uint8* const wb_data, uint16 scache_ver);

STATIC int
_bcm_esw_sflow_wb_recover(int unit);

STATIC int
_bcm_esw_sflow_counter_wb_recover(int unit, soc_mem_t mem);
#endif /* BCM_WARM_BOOT_SUPPORT */
#endif /* BCM_TOMAHAWK_SUPPORT */

#ifdef BCM_WARM_BOOT_SUPPORT

/* Enum mapped to string for scache printing.
 * Usage format is SPT_<enum> */
#define SCACHE_PORT_DEFS                                            \
    SCACHE_PORT_DEF(PBVL, "pbvl")                                   \
    SCACHE_PORT_DEF(VLAN_PROT_PTR, "vlan_prot_ptr")                 \
    SCACHE_PORT_DEF(VP_COUNT, "vp_count")                           \
    SCACHE_PORT_DEF(DTM_PBMP, "dtm_pbmp")                           \
    SCACHE_PORT_DEF(COSMASK, "cosmask")                             \
    SCACHE_PORT_DEF(METERING_INFO, "metering_info")                 \
    SCACHE_PORT_DEF(PORT_FLAGS, "port_flags")                       \
    SCACHE_PORT_DEF(PORT_NUM_LANES, "port_num_lanes")               \
    SCACHE_PORT_DEF(RX_LOS, "rx_los")                               \
    SCACHE_PORT_DEF(PORT_ENABLE, "port_enable")                     \
    SCACHE_PORT_DEF(ASF, "asf")                                     \
    SCACHE_PORT_DEF(LATENCY, "latency")                             \
    SCACHE_PORT_DEF(IFG, "ifg")                                     \
    SCACHE_PORT_DEF(DSCP_MAP, "dscp_map")                           \
    SCACHE_PORT_DEF(PORT_INTF_TYPE, "port_intf_type")

typedef enum scache_port_type_e {
#define SCACHE_PORT_DEF(_e, _s) SPT_##_e,
    SCACHE_PORT_DEFS
#undef SCACHE_PORT_DEF
    SCACHE_PORT_TYPE_MAX
} scache_port_type_t;

static const char *port_scache_strs[] = {
#define SCACHE_PORT_DEF(_e, _s) _s,
    SCACHE_PORT_DEFS
#undef SCACHE_PORT_DEF
    "invalid"
};

typedef struct scache_port_print_port_s {
    struct scache_port_print_port_s *next; /* pointer to next */
    uint8 *val;                     /* pointer to value in scache */
    int len;                        /* len of value in scache */
    int port;                       /* logical port number */
} scache_port_print_port_t;

/* pointers to head of linked list */
static scache_port_print_port_t *scache_head[SCACHE_PORT_TYPE_MAX];
/* pointers to tail of linked list */
static scache_port_print_port_t *scache_tail[SCACHE_PORT_TYPE_MAX];

STATIC int
_bcm_esw_port_ifg_wb_sync(int unit, uint8 **scache_ptr);

STATIC int
_bcm_esw_port_ifg_wb_reinit(int unit, uint8 **scache_ptr);
#endif

STATIC int
bcmi_esw_port_encap_validate(int unit, bcm_port_t port, int mode, int speed);
STATIC int
_bcm_esw_port_encap_set(int unit, bcm_port_t port, int mode);


#if defined(BCM_GREYHOUND_SUPPORT)
/* Treat Packet Priority as dot1p ref_cnt structure */
typedef struct bcmi_esw_treat_pktpri_as_dot1p_s {
    sal_mutex_t ref_cnt_mutex;
    int ref_cnt;
} bcmi_esw_treat_pktpri_as_dot1p_t;

STATIC bcmi_esw_treat_pktpri_as_dot1p_t
    bcmi_treat_pktpri_as_dot1p[BCM_MAX_NUM_UNITS];

/* Treat Packet Priority as dot1p ref_cnt lock/unlock */
#define TREAT_PKTPRI_AS_DOT1P_LOCK(_unit_)                           \
    sal_mutex_take(bcmi_treat_pktpri_as_dot1p[_unit_].ref_cnt_mutex, \
                   sal_mutex_FOREVER)
#define TREAT_PKTPRI_AS_DOT1P_UNLOCK(_unit_)                         \
    sal_mutex_give(bcmi_treat_pktpri_as_dot1p[_unit_].ref_cnt_mutex)

/*
 * Function:
 *    bcmi_esw_port_treat_pktpri_as_dot1p_cleanup
 * Purpose:
 *    cleanup resource after detach
 * Parameters:
 *    unit - (IN) Device Number
 * Return Value:
 *    BCM_E_XXX
 * Notes:
 */
STATIC int
bcmi_esw_port_treat_pktpri_as_dot1p_cleanup(int unit)
{
    if (bcmi_treat_pktpri_as_dot1p[unit].ref_cnt_mutex != NULL) {
        sal_mutex_destroy(bcmi_treat_pktpri_as_dot1p[unit].ref_cnt_mutex);
        bcmi_treat_pktpri_as_dot1p[unit].ref_cnt_mutex = NULL;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *    bcmi_esw_port_treat_pktpri_as_dot1p_init
 * Purpose:
 *    Initialize the ref_cnt of enabling treat packet priority
 *    as dot1p priority for different packet types or port controls.
 * Parameters:
 *    unit - (IN) Device Number
 * Return Value:
 *    BCM_E_XXX
 * Notes:
 *    The ref_cnt of treat packet priority as dot1p priority is system-wise.
 */
STATIC int
bcmi_esw_port_treat_pktpri_as_dot1p_init(int unit)
{
    if (!soc_feature(unit, soc_feature_pktpri_as_dot1p)) {
        return BCM_E_UNAVAIL;
    }

    /* Create protection mutex. */
    if (NULL == bcmi_treat_pktpri_as_dot1p[unit].ref_cnt_mutex) {
        bcmi_treat_pktpri_as_dot1p[unit].ref_cnt_mutex =
            sal_mutex_create("treat_pktpri_as_dot1p.lock");
        if (NULL == bcmi_treat_pktpri_as_dot1p[unit].ref_cnt_mutex) {
            return BCM_E_RESOURCE;
        }
    }

    bcmi_treat_pktpri_as_dot1p[unit].ref_cnt = 0;

    return BCM_E_NONE;
}

/*
 * Function:
 *    bcmi_esw_port_treat_pktpri_as_dot1p_ref_cnt_update
 * Purpose:
 *    Update the ref_cnt of enabling treat packet priority
 *    as dot1p priority for various packet types or port controls.
 * Parameters:
 *    unit - (IN) Device Number
 *    incr_decr_flag - (IN) If TRUE, increment ref_cnt, else decrease ref_cnt
 * Return Value:
 *    BCM_E_XXX
 * Notes:
 *    The ref_cnt of treat packet priority as dot1p priority is system-wise.
 */
STATIC int
bcmi_esw_port_treat_pktpri_as_dot1p_ref_cnt_update(
    int unit, int incr_decr_flag)
{
    int rv = BCM_E_NONE;
    uint64 regval64;

    if (!soc_feature(unit, soc_feature_pktpri_as_dot1p)) {
        return BCM_E_UNAVAIL;
    }

    /* Input parameter check */
    if ((incr_decr_flag != 1) && (incr_decr_flag != -1)) {
        return BCM_E_PARAM;
    }

    TREAT_PKTPRI_AS_DOT1P_LOCK(unit);
    if (incr_decr_flag == 1) {
        /* Increment */
        /* Need to set TREAT_PKTPRI_AS_DOT1Pf for the first ref_cnt */
        if (bcmi_treat_pktpri_as_dot1p[unit].ref_cnt == 0) {
            COMPILER_64_ZERO(regval64);
            rv = READ_ING_CONFIG_64r(unit, &regval64);
            if (BCM_FAILURE(rv)) {
                TREAT_PKTPRI_AS_DOT1P_UNLOCK(unit);
                return rv;
            }
            soc_reg64_field32_set(unit, ING_CONFIG_64r, &regval64,
                                  TREAT_PKTPRI_AS_DOT1Pf, 1);
            rv = WRITE_ING_CONFIG_64r(unit, regval64);
            if (BCM_FAILURE(rv)) {
                TREAT_PKTPRI_AS_DOT1P_UNLOCK(unit);
                return rv;
            }
        }
        bcmi_treat_pktpri_as_dot1p[unit].ref_cnt++;
    } else {
        /* Decrement */
        if (bcmi_treat_pktpri_as_dot1p[unit].ref_cnt >= 1) {
            bcmi_treat_pktpri_as_dot1p[unit].ref_cnt--;
            /* Need to unset TREAT_PKTPRI_AS_DOT1Pf when ref_cnt = 0 */
            if (bcmi_treat_pktpri_as_dot1p[unit].ref_cnt == 0) {
                COMPILER_64_ZERO(regval64);
                rv = READ_ING_CONFIG_64r(unit, &regval64);
                if (BCM_FAILURE(rv)) {
                    TREAT_PKTPRI_AS_DOT1P_UNLOCK(unit);
                    return rv;
                }
                soc_reg64_field32_set(unit, ING_CONFIG_64r, &regval64,
                                      TREAT_PKTPRI_AS_DOT1Pf, 0);
                rv = WRITE_ING_CONFIG_64r(unit, regval64);
                if (BCM_FAILURE(rv)) {
                    TREAT_PKTPRI_AS_DOT1P_UNLOCK(unit);
                    return rv;
                }
            }
        }
    }
    TREAT_PKTPRI_AS_DOT1P_UNLOCK(unit);

    return rv;
}

#ifdef BCM_WARM_BOOT_SUPPORT
/*
 * Function:
 *    bcmi_esw_port_treat_pktpri_as_dot1p_reinit
 * Purpose:
 *    Recovery the ref_cnt of enabling treat packet priority
 *    as dot1p priority for different packet types or port contols.
 * Parameters:
 *    unit - (IN) Device Number
 * Return Value:
 *    BCM_E_XXX
 */
STATIC int
bcmi_esw_port_treat_pktpri_as_dot1p_reinit(int unit)
{
    int rv = BCM_E_NONE;
    bcm_port_t port_idx;
    int pri_en = 0;
    uint64 regval64;

    if (!soc_feature(unit, soc_feature_pktpri_as_dot1p)) {
        return BCM_E_UNAVAIL;
    }

    bcmi_treat_pktpri_as_dot1p[unit].ref_cnt = 0;

    COMPILER_64_ZERO(regval64);
    BCM_IF_ERROR_RETURN(
        READ_ING_CONFIG_64r(unit, &regval64));
    if (soc_reg64_field32_get(unit, ING_CONFIG_64r, regval64,
                              TREAT_PKTPRI_AS_DOT1Pf) == 0x1) {
        BCM_PBMP_ITER(PBMP_PORT_ALL(unit), port_idx) {
            /* Recover ref_cnt for Egress VLAN internal priority mapping */
            rv = bcm_esw_port_control_get
                     (unit, port_idx,
                      bcmPortControlEgressVlanPriUsesPktPri, &pri_en);
            if (BCM_FAILURE(rv)) {
                return rv;
            }
            if (pri_en) {
                BCM_IF_ERROR_RETURN(
                    bcmi_esw_port_treat_pktpri_as_dot1p_ref_cnt_update
                        (unit, 1));
            }

            /* Recover ref_cnt for ETAG internal priority mapping */
            if (soc_feature(unit, soc_feature_port_extension)) {
                rv = bcm_esw_port_control_get(unit, port_idx,
                                              bcmPortControlUseEtagPri, &pri_en);
                if (BCM_FAILURE(rv)) {
                    return rv;
                }
                if (pri_en) {
                    BCM_IF_ERROR_RETURN(
                        bcmi_esw_port_treat_pktpri_as_dot1p_ref_cnt_update
                            (unit, 1));
                }
            }
#ifdef BCM_HURRICANE3_SUPPORT
            /* Recover ref_cnt for MiML internal priority mapping */
            if (soc_feature(unit, soc_feature_miml)) {
                rv = bcm_esw_port_control_get(unit, port_idx,
                                              bcmPortControlTrustMimlPri, &pri_en);
                if (BCM_FAILURE(rv)) {
                    return rv;
                }
                if (pri_en) {
                    BCM_IF_ERROR_RETURN(
                        bcmi_esw_port_treat_pktpri_as_dot1p_ref_cnt_update
                            (unit, 1));
                }
            }
#endif /* BCM_HURRICANE3_SUPPORT */
        }
    }

    return rv;
}
#endif /* BCM_WARM_BOOT_SUPPORT */
#endif /* BCM_GREYHOUND_SUPPORT */

/*
 * Function:
 *      _bcm_esw_port_mon_unimac_lock_up
 * Description:
 *      Check for UniMAC half duplex collision lock-up issue
 * Parameters:
 *      pmc  - (IN) port monitor control data
 * Return Value:
 *      None
 * Notes:
 *      See errata 56020-ES105-R for additional details.
 */
STATIC void
_bcm_esw_port_mon_unimac_lock_up(_port_mon_ctrl_t *pmc)
{
    int unit = pmc->unit;
    int port, rv, link_up, fulld, lock_up;
    uint32 gtuc, gtmca, gtbca, gtlcl, gtpok;
    uint32 ccnt, rcnt, txfifo;

    if (!soc_feature(unit, soc_feature_unimac)) {
        return;
    }

    PBMP_E_ITER(unit, port) {
        /* Check only half duplex ports */
        rv = _bcm_esw_link_get(unit, port, &link_up);
        if (BCM_FAILURE(rv) || !link_up) {
            continue;
        }
        rv = MAC_DUPLEX_GET(PORT(unit, port).p_mac, unit, port, &fulld);
        if (BCM_FAILURE(rv) || fulld) {
            continue;
        }

        lock_up = 0;
        rv = 0;

        /* Collect test counters */
        rv += soc_counter_get32(unit, port, GTUCr, 0, &gtuc);
        rv += soc_counter_get32(unit, port, GTMCAr, 0, &gtmca);
        rv += soc_counter_get32(unit, port, GTBCAr, 0, &gtbca);
        rv += soc_counter_get32(unit, port, GTLCLr, 0, &gtlcl);
        rv += soc_counter_get32(unit, port, GTPOKr, 0, &gtpok);

        /* Test lock-up conditions */
        if (gtuc == pmc->gtuc &&
            gtmca == pmc->gtmca &&
            gtbca == pmc->gtbca) {
            if (gtlcl != pmc->gtlcl &&
                gtpok != pmc->gtpok) {
                lock_up = 2;
            } else {
                rcnt = ccnt = 0;
                if (SOC_REG_IS_VALID(unit, GE0_GBODE_CELL_CNTr)) {
                    uint32 reg, addr, idx;
                    idx = (port < 6) ? (port - 1) : ((port - 6) % 12);
                    reg = GE0_GBODE_CELL_CNTr;
                    addr = soc_reg_addr(unit, reg, port, 0);
                    addr += idx;
                    rv += soc_reg32_read(unit, addr, &ccnt);
                    reg = GE0_GBODE_CELL_REQ_CNTr;
                    addr = soc_reg_addr(unit, reg, port, 0);
                    addr += idx;
                    rv += soc_reg32_read(unit, addr, &rcnt);
                } else if (SOC_REG_IS_VALID(unit, GE_GBODE_CELL_CNTr)) {
                    rv += READ_GE_GBODE_CELL_CNTr(unit, port, &ccnt);
                    rv += READ_GE_GBODE_CELL_REQ_CNTr(unit, port, &rcnt);
                }
                if (gtlcl && rcnt == 0 && ccnt == 4) {
                    lock_up = 1;
                }
            }
        }
        if (lock_up == 0) {
            rv += READ_TXFIFO_STATr(unit, port, &txfifo);
            if (soc_reg_field_get(unit, TXFIFO_STATr,
                                  txfifo, TXFIFO_UNDERRUNf)) {
                lock_up = 2;
            }
        }

        /* Reset MAC if lock-up is detected */
        if (rv == 0 && lock_up) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "Port %s: UniMAC lock up (%d) detected\n"),
                         SOC_PORT_NAME(unit, port), lock_up));
            PORT_LOCK(unit);
            MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                            SOC_MAC_CONTROL_SW_RESET, TRUE);
            MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                            SOC_MAC_CONTROL_SW_RESET, FALSE);
            PORT_UNLOCK(unit);
        }

        /* Sync test counters */
        pmc->gtuc = gtuc;
        pmc->gtmca = gtmca;
        pmc->gtbca = gtbca;
        pmc->gtlcl = gtlcl;
        pmc->gtpok = gtpok;
    }
}

/*
 * Function:
 *      _bcm_esw_port_mon_ctrl_thread
 * Description:
 *      Port monitor thread
 * Parameters:
 *      context  - (IN) Port monitor control data
 * Return Value:
 *      None
 */
STATIC void
_bcm_esw_port_mon_ctrl_thread(void *context)
{
    _port_mon_ctrl_t *pmc = (_port_mon_ctrl_t *)context;

    LOG_VERBOSE(BSL_LS_BCM_PORT,
                (BSL_META("Port monitor started on unit %d\n"), pmc->unit));

    pmc->running = 1;
    while (!pmc->stop) {
        _bcm_esw_port_mon_unimac_lock_up(pmc);
        (void)sal_sem_take(pmc->sema, pmc->interval);
    }
    pmc->running = 0;
}

/*
 * Function:
 *      _bcm_esw_port_mon_start
 * Description:
 *      Start port monitor thread
 * Parameters:
 *      unit  - (IN) BCM device number
 * Return Value:
 *      BCM_E_NONE if thread started successfully
 */
int
_bcm_esw_port_mon_start(int unit)
{
    _port_mon_ctrl_t *pmc = PORT_MON_CTRL(unit);
    int cnt;

    pmc->interval = soc_property_get(unit, spn_PORTMON_INTERVAL, 0);
    if (pmc->interval == 0) {
        return BCM_E_NONE;
    }

    if (pmc->interval < PORT_MON_INTERVAL_MIN) {
        pmc->interval = PORT_MON_INTERVAL_MIN;
    }

    pmc->unit = unit;
    if (pmc->running) {
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Port monitor already running on unit %d\n"),
                     pmc->unit));
    } else {
        if (pmc->sema == NULL) {
            pmc->sema = sal_sem_create("port_mon_SLEEP", sal_sem_BINARY, 0);
            if (pmc->sema == NULL) {
                return BCM_E_MEMORY;
            }
        }
        sal_snprintf(pmc->taskname, sizeof (pmc->taskname),
                     "bcmPortMon.%d", unit);
        pmc->stop = 0;
        if (sal_thread_create(pmc->taskname, SAL_THREAD_STKSZ,
                              soc_property_get(unit,
                                               spn_PORTMON_THREAD_PRI,
                                               50),
                              _bcm_esw_port_mon_ctrl_thread,
                              pmc) == SAL_THREAD_ERROR) {
            return BCM_E_MEMORY;
        }
        cnt = 10;
        while (!pmc->running && cnt--) {
            sal_usleep(100000);
        }
        if (!pmc->running) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "%s: Thread did not start\n"), pmc->taskname));
            return BCM_E_TIMEOUT;
        }
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_port_mon_stop
 * Description:
 *      Stop port monitor thread
 * Parameters:
 *      unit  - (IN) BCM device number
 * Return Value:
 *      BCM_E_NONE if thread stopped successfully
 */
int
_bcm_esw_port_mon_stop(int unit)
{
    int cnt;
    _port_mon_ctrl_t *pmc = PORT_MON_CTRL(unit);

    if (pmc->sema == NULL) {
        return BCM_E_NONE;
    }

    pmc->stop = 1;
    sal_sem_give(pmc->sema);
    cnt = 10;
    while (pmc->running && cnt--) {
        sal_usleep(100000);
    }
    if (pmc->running) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit,
                              "%s: Thread did not start\n"), pmc->taskname));
        return BCM_E_TIMEOUT;
    }
    sal_sem_destroy(pmc->sema);
    pmc->sema = NULL;

    return BCM_E_NONE;
}

#ifdef BCM_TRIUMPH3_SUPPORT
static _port_ibod_ctrl_t *_port_ibod_ctrl[BCM_MAX_NUM_UNITS];
static int txerr_trigger_flag[SOC_MAX_NUM_PORTS];

#define IBOD_RECOVERY_GROUP_MAX  ((SOC_MAX_NUM_PORTS + 3) /4)
#define IBOD_RECOVERY_GROUP_VALID(grp) ((grp) >= 0 && (grp) < IBOD_RECOVERY_GROUP_MAX)
#define IBOD_RECOVERY_GROUP(phy_port) ((phy_port - 1)/4)
static sal_mutex_t ibod_port_group_recovery_lock[BCM_MAX_NUM_UNITS][IBOD_RECOVERY_GROUP_MAX];

#define TR3_IARB_TDM_TABLE_LENGTH      512

#define IBOD_IF_ERROR_RETURN_UNLOCK(unit,port,rv) \
        if (SOC_FAILURE(rv)) {   \
            soc_ibod_recovery_in_progress_set(unit, 0); \
            _bcm_esw_ibod_recovery_port_unlock(unit, port); \
            PORT_UNLOCK(unit);       \
            return rv;               \
        }

#define TXERR_IF_ERROR_RETURN_UNLOCK(unit,port,rv) \
        if (SOC_FAILURE(rv)) {   \
            _bcm_esw_ibod_recovery_port_unlock(unit, port); \
            PORT_UNLOCK(unit);       \
            _bcm_esw_lc_unlock(unit);\
            return rv;               \
        }

/*#define IBOD_DEBUG
#define TXERR_DEBUG */

int _ibod_debug_flag = 0;

void _bcm_esw_ibod_debug_flag_set(int unit, int flag)
{
    _ibod_debug_flag = flag;
    cli_out("IBOD debug flag:0X%x\n", _ibod_debug_flag);
}

static int _bcm_esw_ibod_recovery_lock_init(int unit)
{
    int rv = BCM_E_NONE;
    int group, rollback_group;

    for (group = 0; group < IBOD_RECOVERY_GROUP_MAX; group++) {
        ibod_port_group_recovery_lock[unit][group] = sal_mutex_create("IBOD_GROUP_LOCK");
        if (ibod_port_group_recovery_lock[unit][group] == NULL) {
            rv = BCM_E_MEMORY;
            break;
        }
    }
    /* Recycle the memory */
    if (SOC_FAILURE(rv)) {
        for (rollback_group = group - 1; rollback_group >= 0; rollback_group--) {
            sal_mutex_destroy(ibod_port_group_recovery_lock[unit][rollback_group]);
        }
    }
    return BCM_E_NONE;
}

static void _bcm_esw_ibod_recovery_lock_deinit(int unit)
{
    int group;

    for (group = 0; group < IBOD_RECOVERY_GROUP_MAX; group++) {
        if (ibod_port_group_recovery_lock[unit][group] != NULL) {
            sal_mutex_destroy(ibod_port_group_recovery_lock[unit][group]);
        }
    }
}

void _bcm_esw_ibod_recovery_port_lock(int unit, bcm_port_t port)
{
    int phy_port;
    int group;
    /* coverity[overrun-local : FALSE] */
    phy_port = SOC_INFO(unit).port_l2p_mapping[port];
    group = IBOD_RECOVERY_GROUP(phy_port);
    if (IBOD_RECOVERY_GROUP_VALID(group) &&
        ibod_port_group_recovery_lock[unit][group] != NULL) {
        sal_mutex_take(ibod_port_group_recovery_lock[unit][group], sal_mutex_FOREVER);
    }
}

void _bcm_esw_ibod_recovery_port_unlock(int unit, bcm_port_t port)
{
    int phy_port;
    int group;

    phy_port = SOC_INFO(unit).port_l2p_mapping[port];
    group = IBOD_RECOVERY_GROUP(phy_port);
    if (IBOD_RECOVERY_GROUP_VALID(group) &&
        ibod_port_group_recovery_lock[unit][group] != NULL) {
        sal_mutex_give(ibod_port_group_recovery_lock[unit][group]);
    }
}

STATIC int _bcm_tr3_port_is_control_port(int unit, soc_port_t port)
{
    int phy_port, phy_port_base;
    soc_info_t *si = &SOC_INFO(unit);

    phy_port = si->port_l2p_mapping[port];
    if (phy_port == -1) {
        return FALSE;
    }

    phy_port_base = ((phy_port - 1) & ~0x3) + 1;
    if (phy_port == phy_port_base) {
        return TRUE;
    }

    return FALSE;
}

STATIC int
_bcm_tr3_ibod_mac_x_enable_set(int unit, soc_port_t port, int enable)
{
    uint64 ctrl, octrl;
    pbmp_t mask;

    SOC_IF_ERROR_RETURN(READ_XMAC_CTRLr(unit, port, &ctrl));
    octrl = ctrl;
    /* Don't disable TX since it stops egress and hangs if CPU sends */
    soc_reg64_field32_set(unit, XMAC_CTRLr, &ctrl, TX_ENf, 1);
    if (enable) {
        soc_reg64_field32_set(unit, XMAC_CTRLr, &ctrl, RX_ENf, 1);
    } else {
        soc_reg64_field32_set(unit, XMAC_CTRLr, &ctrl, RX_ENf, 0);
    }
    if (COMPILER_64_NE(ctrl, octrl)) {
        SOC_IF_ERROR_RETURN(WRITE_XMAC_CTRLr(unit, port, ctrl));
        sal_udelay(10);
    }

    /* Put the XMAC in a soft reset state when disabled to allow packets to
     * drain from the TX FIFO */
    soc_reg64_field32_set(unit, XMAC_CTRLr, &ctrl, SOFT_RESETf,
                          enable ? 0 : 1);
    if (COMPILER_64_NE(ctrl, octrl)) {
        SOC_IF_ERROR_RETURN(WRITE_XMAC_CTRLr(unit, port, ctrl));
    }

    if (enable) {
        SOC_IF_ERROR_RETURN(soc_phyctrl_notify(unit, port, phyEventResume,
                                               PHY_STOP_MAC_DIS));
    } else {
        soc_link_mask2_get(unit, &mask);
        SOC_PBMP_PORT_REMOVE(mask, port);
        SOC_IF_ERROR_RETURN(soc_link_mask2_set(unit, mask));
        SOC_IF_ERROR_RETURN(_mac_x_drain_cells(unit, port, 0));
        SOC_IF_ERROR_RETURN(soc_phyctrl_notify(unit, port, phyEventStop,
                                               PHY_STOP_MAC_DIS));
    }

    return SOC_E_NONE;
}

STATIC int
_bcm_tr3_ibod_port_isolate(int unit, int port_enable, bcm_port_t port,
                                  int *port_dis_untag, int *port_dis_tag)
{
    port_tab_entry_t ptab_entry;

    /* Isolate, drain and remove port from epc link */
    BCM_IF_ERROR_RETURN
        (_bcm_tr3_ibod_mac_x_enable_set(unit, port, FALSE));

    if (port_enable) {
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                               "Port %d enable case..\n"), port));
        /* Enable phy so that packets can loopback */
        SOC_IF_ERROR_RETURN
            (soc_phyctrl_enable_set(unit, port, TRUE));
    } else {
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Port %d Runt received case..\n"), port));
    }

    SOC_IF_ERROR_RETURN(MAC_LOOPBACK_SET(PORT(unit, port).p_mac, unit, port, TRUE));

    /* Enable MAC so that packets can loopback from phy */
    BCM_IF_ERROR_RETURN
        (_bcm_tr3_ibod_mac_x_enable_set(unit, port, TRUE));

    /* Discard tag and untag packet at IP before send packets */
    BCM_IF_ERROR_RETURN(soc_mem_read(unit, PORT_TABm, MEM_BLOCK_ANY, port, &ptab_entry));
    *port_dis_untag = soc_mem_field32_get(unit, PORT_TABm, &ptab_entry, PORT_DIS_UNTAGf);
    *port_dis_tag = soc_mem_field32_get(unit, PORT_TABm, &ptab_entry, PORT_DIS_TAGf);
    soc_mem_field32_set(unit, PORT_TABm, &ptab_entry, PORT_DIS_UNTAGf, 1);
    soc_mem_field32_set(unit, PORT_TABm, &ptab_entry, PORT_DIS_TAGf, 1);
    BCM_IF_ERROR_RETURN(soc_mem_write(unit, PORT_TABm, MEM_BLOCK_ALL, port, &ptab_entry));

    return SOC_E_NONE;
}

STATIC int
_bcm_tr3_ibod_port_resume(int unit, bcm_port_t port, int port_dis_untag, int port_dis_tag)
{
    pbmp_t epc_pbm;
    port_tab_entry_t ptab_entry;

    /* Remove MAC loopback */
    SOC_IF_ERROR_RETURN(MAC_LOOPBACK_SET(PORT(unit, port).p_mac, unit, port, FALSE));

    /* Restore port discard tag and untag at IP  */
    BCM_IF_ERROR_RETURN(soc_mem_read(unit, PORT_TABm, MEM_BLOCK_ANY, port, &ptab_entry));
    soc_mem_field32_set(unit, PORT_TABm, &ptab_entry, PORT_DIS_UNTAGf, port_dis_untag);
    soc_mem_field32_set(unit, PORT_TABm, &ptab_entry, PORT_DIS_TAGf, port_dis_tag);
    BCM_IF_ERROR_RETURN(soc_mem_write(unit, PORT_TABm, MEM_BLOCK_ALL, port, &ptab_entry));

    /* Restore port in epc link bmap */
    soc_link_mask2_get(unit, &epc_pbm);
    SOC_PBMP_PORT_ADD(epc_pbm, port);
    SOC_IF_ERROR_RETURN(soc_link_mask2_set(unit, epc_pbm));

    return SOC_E_NONE;
}

STATIC int
_bcm_hx4_ibod_sync_recovery_port(_port_ibod_ctrl_t *ibod_ctrl, int port_group_iter,
                                 bcm_port_t port)
{
    bcm_pbmp_t pbmp;
    bcm_port_t port_iter;
    uint32 port_mode;
    uint32 rval, rval_1, port_dis_tag=0, port_dis_untag=0, xmac_mode=0;
    uint64 rval64,tmp64;
    uint64 egress_meter[4];
    int unit=ibod_ctrl->unit;
    int rv = BCM_E_NONE;
    bcm_pkt_t *pkt = &ibod_ctrl->pkt;
    pbmp_t mask, mask1, mask1_restore, mask_restore;
    uint64 rrpkt, rrbyt, count64, count64_1;
    int count, count_1, i;
    soc_timeout_t timeout;
    egr_enable_entry_t egr_en;
    soc_info_t *si = &SOC_INFO(unit);
    port_tab_entry_t ptab_entry;
    egr_mmu_requests_entry_t mmu_entry;
    int rx_llfc_en[4], rx_pfc_en[4], pause_rx[4], rx_lss[4], rx_lss_1[4], rx_en[4];
    uint32 max_used_entry, ep_level, overflow0, overflow1, total_cell;
    static const soc_reg_t lls_port_credit_reg[] = {
        LLS_PORT_0_CREDITr, LLS_PORT_1_CREDITr, LLS_PORT_2_CREDITr,
        LLS_PORT_3_CREDITr, LLS_PORT_4_CREDITr, LLS_PORT_5_CREDITr,
        LLS_PORT_6_CREDITr, LLS_PORT_7_CREDITr, LLS_PORT_8_CREDITr,
        LLS_PORT_9_CREDITr, LLS_PORT_10_CREDITr, LLS_PORT_11_CREDITr,
        LLS_PORT_12_CREDITr, LLS_PORT_13_CREDITr, LLS_PORT_14_CREDITr,
        LLS_PORT_15_CREDITr, LLS_PORT_16_CREDITr, LLS_PORT_17_CREDITr,
        LLS_PORT_18_CREDITr, LLS_PORT_19_CREDITr, LLS_PORT_20_CREDITr,
        LLS_PORT_21_CREDITr, LLS_PORT_22_CREDITr, LLS_PORT_23_CREDITr,
        LLS_PORT_24_CREDITr, LLS_PORT_25_CREDITr, LLS_PORT_26_CREDITr,
        LLS_PORT_27_CREDITr, LLS_PORT_28_CREDITr, LLS_PORT_29_CREDITr,
        LLS_PORT_30_CREDITr, LLS_PORT_31_CREDITr, LLS_PORT_32_CREDITr,
        LLS_PORT_33_CREDITr, LLS_PORT_34_CREDITr, LLS_PORT_35_CREDITr,
        LLS_PORT_36_CREDITr, LLS_PORT_37_CREDITr, LLS_PORT_38_CREDITr,
        LLS_PORT_39_CREDITr, LLS_PORT_40_CREDITr, LLS_PORT_41_CREDITr,
        LLS_PORT_42_CREDITr, LLS_PORT_43_CREDITr, LLS_PORT_44_CREDITr,
        LLS_PORT_45_CREDITr, LLS_PORT_46_CREDITr, LLS_PORT_47_CREDITr,
        LLS_PORT_48_CREDITr, LLS_PORT_49_CREDITr, LLS_PORT_50_CREDITr,
        LLS_PORT_51_CREDITr, LLS_PORT_52_CREDITr, LLS_PORT_53_CREDITr,
        LLS_PORT_54_CREDITr, LLS_PORT_55_CREDITr, LLS_PORT_56_CREDITr,
        LLS_PORT_57_CREDITr, LLS_PORT_58_CREDITr, LLS_PORT_59_CREDITr,
        LLS_PORT_60_CREDITr, LLS_PORT_61_CREDITr, LLS_PORT_62_CREDITr
    }; 
    sal_usecs_t time1, time2;

    time1 = SAL_USECS_SUB(sal_time_usecs(), ibod_ctrl->start_time);

    rv = bcm_esw_port_subsidiary_ports_get(unit, port, &pbmp);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit, "\n Error in retreiving the subsidiary ports"
                  "for port %s"), SOC_PORT_NAME(unit,port)));
        return BCM_E_NONE;
    }

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_MODEr(unit, port_iter, &rval64);
        if (BCM_FAILURE(rv)) {
            return BCM_E_NONE;
        }
        xmac_mode = soc_reg64_field32_get(unit, XMAC_MODEr,rval64, HDR_MODEf);
        if ((xmac_mode == 1) || (xmac_mode == 2)) {
            count++;
        }
    }

    if (!count) {
         return BCM_E_NONE;
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        SOC_IF_ERROR_RETURN(READ_PORT_CDC_TXFIFO_OVRFLWr(unit, port_iter, &rval));
        if (rval) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit, "ENTER VALIDATE PORT_CDC_TXFIFO_OVRFLW ERR"
                      " failed on port:%d\n\r"), port_iter ));
        }
    }

    _bcm_esw_lc_lock(unit);

    soc_link_fwd_get(unit, &mask1);
    SOC_PBMP_ASSIGN(mask1_restore,mask1);
     BCM_PBMP_ITER(pbmp, port_iter) {
        BCM_PBMP_PORT_REMOVE(mask1,port_iter);
     }
    rv = soc_link_fwd_set(unit, mask1);
    if (BCM_FAILURE(rv)) {
        _bcm_esw_lc_unlock(unit);
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit, "\n Error in setting the mask FWD"
                  " for WAR on port %s"), SOC_PORT_NAME(unit,port)));
        return BCM_E_NONE;
    }

    /* Hold the ibod recovery port group lock */
    _bcm_esw_ibod_recovery_port_lock(unit, port);
    PORT_LOCK(unit);

    soc_link_mask2_get(unit, &mask);
    SOC_PBMP_ASSIGN(mask_restore, mask);
    BCM_PBMP_ITER(pbmp, port_iter) {
        BCM_PBMP_PORT_REMOVE(mask,port_iter);
    }
    rv = soc_link_mask2_set(unit, mask);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);


    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = soc_mem_read(unit, PORT_TABm, MEM_BLOCK_ANY, port_iter,
                          &ptab_entry);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        port_dis_untag = soc_mem_field32_get(unit, PORT_TABm, &ptab_entry, PORT_DIS_UNTAGf);
        port_dis_tag = soc_mem_field32_get(unit, PORT_TABm, &ptab_entry, PORT_DIS_TAGf);
        soc_mem_field32_set(unit, PORT_TABm, &ptab_entry, PORT_DIS_UNTAGf, 1);
        soc_mem_field32_set(unit, PORT_TABm, &ptab_entry, PORT_DIS_TAGf, 1);
        rv = soc_mem_write(unit, PORT_TABm, MEM_BLOCK_ALL, port_iter,
                           &ptab_entry);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        rx_en[count] = soc_reg64_field32_get(unit, XMAC_CTRLr, rval64, RX_ENf);
        count++;
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, RX_ENf, 0);
        rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, TX_ENf, 0);
        rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_TX_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_TX_CTRLr, &rval64, DISCARDf, 1);
        rv = WRITE_XMAC_TX_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XPORT_TO_MMU_BKPr(unit, port_iter, &rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg_field_set(unit, XPORT_TO_MMU_BKPr, &rval, PRI15_0_BKPf, 0);
        rv = WRITE_XPORT_TO_MMU_BKPr(unit, port_iter, 0);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_PAUSE_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        pause_rx[count] = soc_reg64_field32_get(unit, XMAC_PAUSE_CTRLr, rval64, RX_PAUSE_ENf);
        soc_reg64_field32_set(unit, XMAC_PAUSE_CTRLr, &rval64, RX_PAUSE_ENf, 0);
        rv = WRITE_XMAC_PAUSE_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

        rv = READ_XMAC_PFC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        rx_pfc_en[count] = soc_reg64_field32_get(unit, XMAC_PFC_CTRLr, rval64, RX_PFC_ENf);
        soc_reg64_field32_set(unit, XMAC_PFC_CTRLr, &rval64, RX_PFC_ENf, 0);
        rv = WRITE_XMAC_PFC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

        rv = READ_XMAC_LLFC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        rx_llfc_en[count] = soc_reg64_field32_get(unit, XMAC_LLFC_CTRLr, rval64, RX_LLFC_ENf);
        soc_reg64_field32_set(unit, XMAC_LLFC_CTRLr, &rval64, RX_LLFC_ENf, 0);
        rv = WRITE_XMAC_LLFC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count++;
    }

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_EGRMETERINGCONFIG_64r(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        egress_meter[count]=rval64;
        COMPILER_64_ZERO(tmp64);
        rv = WRITE_EGRMETERINGCONFIG_64r(unit, port_iter, tmp64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count++;
    }

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_RX_LSS_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        rx_lss[count] = soc_reg64_field32_get(unit, XMAC_RX_LSS_CTRLr, rval64,
                                       DROP_TX_DATA_ON_LOCAL_FAULTf);
        rx_lss_1[count] = soc_reg64_field32_get(unit, XMAC_RX_LSS_CTRLr, rval64,
                                       DROP_TX_DATA_ON_REMOTE_FAULTf);
        soc_reg64_field32_set(unit, XMAC_RX_LSS_CTRLr, &rval64, DROP_TX_DATA_ON_LOCAL_FAULTf, 1);
        soc_reg64_field32_set(unit, XMAC_RX_LSS_CTRLr, &rval64, DROP_TX_DATA_ON_REMOTE_FAULTf, 1);
        rv = WRITE_XMAC_RX_LSS_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count++;
    }

    COMPILER_64_SET(tmp64, pbmp.pbits[1], pbmp.pbits[0]);
    rv = READ_MCQ_IPMC_FAST_FLUSHr(unit, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg64_field_set(unit, MCQ_IPMC_FAST_FLUSHr, &rval64, ENABLEf, tmp64);
    rv = WRITE_MCQ_IPMC_FAST_FLUSHr(unit, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_PORT_TXFIFO_PKT_DROP_CTLr(unit, port_iter, &rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg_field_set(unit, PORT_TXFIFO_PKT_DROP_CTLr, &rval, DROP_ENf, 1);
        rv = WRITE_PORT_TXFIFO_PKT_DROP_CTLr(unit, port_iter, rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    count_1=0;
    soc_timeout_init(&timeout, 30000, 0);
    do {
        if (soc_timeout_check(&timeout)) {
            rv = READ_EGR_EDB_MISC_CTRLr(unit, &rval);
            TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
            soc_reg_field_set(unit, EGR_EDB_MISC_CTRLr, &rval, SELECT_CURRENT_USED_ENTRIESf, 1);
            rv = WRITE_EGR_EDB_MISC_CTRLr(unit, rval);
            TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
            /* coverity[overrun-local : FALSE] */
            rv = READ_EGR_MAX_USED_ENTRIESm(unit, MEM_BLOCK_ALL,
                                            si->port_l2p_mapping[port],
                                            &max_used_entry);
            TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
            ep_level = soc_mem_field32_get(unit, EGR_MAX_USED_ENTRIESm, &max_used_entry, LEVELf);
            if(ep_level == 0) {
                ibod_ctrl->drain_timeout_flag = 1;
            }
            else {
                rv = READ_PQEFIFOOVERFLOW0r(unit, &overflow0);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                rv = READ_PQEFIFOOVERFLOW1r(unit, &overflow1);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                rv = READ_OP_PORT_TOTAL_COUNT_CELLr(unit, port, &total_cell);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                LOG_ERROR(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit, "\n IBOD recovery Timeout Drain packets %d PORT: %s, "
                    "ep_level:%d, overflow0:%d, overflow1:%d,total_cell:%d\n"),
                    ibod_ctrl->unit, SOC_PORT_NAME(unit,port), ep_level, overflow0, overflow1,total_cell));
            }
            break;
        } else {
            BCM_PBMP_ITER(pbmp, port_iter) {
               rv = soc_reg32_get(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port_iter]]],
                             REG_PORT_ANY, 0, &rval);
               TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
               if (!rval) {
                   count_1++;
                   rv = soc_mem_read(unit, EGR_MMU_REQUESTSm, MEM_BLOCK_ANY,
                                     si->port_l2p_mapping[port_iter],
                                     &mmu_entry);
                   TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                   rval = soc_mem_field32_get(unit, EGR_MMU_REQUESTSm, &mmu_entry, OUTSTANDING_MMU_REQUESTSf);
                   rv = soc_reg32_set(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port_iter]]],
                                 REG_PORT_ANY, 0, rval);
                   TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
               }
            }
            count=0;
            BCM_PBMP_ITER(pbmp, port_iter) {
                rv = READ_OP_PORT_TOTAL_COUNT_CELLr(unit, port_iter, &rval);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                count += soc_reg_field_get(unit, OP_PORT_TOTAL_COUNT_CELLr,rval, TOTAL_COUNTf);
                rv = READ_PORT_TXFIFO_CELL_CNTr(unit, port_iter, &rval);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                count += soc_reg_field_get(unit, PORT_TXFIFO_CELL_CNTr, rval, CELL_CNTf);
            }
       }
    } while (count);

    BCM_PBMP_ITER(pbmp, port_iter) {
        /* coverity[overrun-local : FALSE] */
        rv = soc_mem_read(unit, EGR_MMU_REQUESTSm, MEM_BLOCK_ANY,
                          si->port_l2p_mapping[port_iter], &mmu_entry);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        rval = soc_mem_field32_get(unit, EGR_MMU_REQUESTSm, &mmu_entry, OUTSTANDING_MMU_REQUESTSf);
        /* coverity[overrun-local : FALSE] */
        rv = soc_reg32_get(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port_iter]]],
                      REG_PORT_ANY, 0, &rval_1);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        if (rval != rval_1) {
            /* coverity[overrun-local : FALSE] */
            rv = soc_reg32_set(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port_iter]]],
                          REG_PORT_ANY, 0, rval);
            TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        }
    }

    count = 0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = WRITE_EGRMETERINGCONFIG_64r(unit, port_iter, egress_meter[count]);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count++;
    }

    rv = READ_PORT_MODE_REGr(unit, port, &rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    port_mode = soc_reg_field_get(unit, PORT_MODE_REGr,
                                rval, XPORT0_CORE_PORT_MODEf);

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CLEAR_FIFO_STATUSr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CLEAR_FIFO_STATUSr, &rval64, CLEAR_TX_PKT_UNDERFLOWf, 1);
        rv = WRITE_XMAC_CLEAR_FIFO_STATUSr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CLEAR_FIFO_STATUSr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CLEAR_FIFO_STATUSr, &rval64, CLEAR_TX_PKT_UNDERFLOWf, 0);
        rv = WRITE_XMAC_CLEAR_FIFO_STATUSr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    rv = READ_MCQ_IPMC_FAST_FLUSHr(unit, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg64_field32_set(unit, MCQ_IPMC_FAST_FLUSHr, &rval64, ENABLEf, 0);
    rv = WRITE_MCQ_IPMC_FAST_FLUSHr(unit, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_PORT_TXFIFO_PKT_DROP_CTLr(unit, port_iter, &rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg_field_set(unit, PORT_TXFIFO_PKT_DROP_CTLr, &rval, DROP_ENf, 0);
        rv = WRITE_PORT_TXFIFO_PKT_DROP_CTLr(unit, port_iter, rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_RRPKTr(unit, port_iter, &rrpkt);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        rv = READ_RRBYTr(unit, port_iter, &rrbyt);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        /* coverity[overrun-local : FALSE] */
        ibod_ctrl->rrpkt[port_iter] = rrpkt;
        ibod_ctrl->rrbyt[port_iter] = rrbyt;
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        /* coverity[overrun-local : FALSE] */
        rv = READ_EGR_ENABLEm(
                unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port_iter], &egr_en);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_EGR_ENABLEm_field32_set(unit, &egr_en, PRT_ENABLEf, 0);
        rv = WRITE_EGR_ENABLEm(
                unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port_iter], &egr_en);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, SOFT_RESETf, 1);
        rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    rv = READ_PORT_ENABLE_REGr(unit, port, &rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT0f , 0);
    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT1f , 0);
    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT2f , 0);
    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT3f , 0);
    rv = WRITE_PORT_ENABLE_REGr(unit, port, rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_PORT_MODE_REGr(unit, port, &rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    port_mode=soc_reg_field_get(unit, PORT_MODE_REGr,
                                rval, XPORT0_CORE_PORT_MODEf);
    if(port_mode) {
        soc_reg_field_set(unit, PORT_MODE_REGr,
                           &rval, XPORT0_CORE_PORT_MODEf,0);
    }
    else {
        soc_reg_field_set(unit, PORT_MODE_REGr,
                           &rval, XPORT0_CORE_PORT_MODEf,1);
    }
    rv = WRITE_PORT_MODE_REGr(unit, port, rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    rv = READ_PORT_MODE_REGr(unit, port, &rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg_field_set(unit, PORT_MODE_REGr,
                      &rval, XPORT0_CORE_PORT_MODEf,port_mode);
    rv = WRITE_PORT_MODE_REGr(unit, port, rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_PORT_ENABLE_REGr(unit, port, &rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT0f , 1);
    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT2f , 1);
    if (port_mode == 2) {
        soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT1f , 1);
        soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT3f , 1);
    }
    rv = WRITE_PORT_ENABLE_REGr(unit, port, rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, SOFT_RESETf, 0);
        rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_EGR_ENABLEm(
                unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port_iter], &egr_en);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_EGR_ENABLEm_field32_set(unit, &egr_en, PRT_ENABLEf, 1);
        rv = WRITE_EGR_ENABLEm(
                unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port_iter], &egr_en);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, LINE_LOCAL_LPBKf, 1);
        rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, TX_ENf, 1);
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, RX_ENf, 1);
        rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_TX_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_TX_CTRLr, &rval64, DISCARDf, 0);
        rv = WRITE_XMAC_TX_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }
    sal_udelay(200);
    /* Send 80-byte packets to fill IBOD FIFO */
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_RPKTr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count64 = soc_reg64_field_get(unit, RPKTr, rval64, COUNTf);
        for (i=0;i<2;i++)
        {
            BCM_PKT_TX_LEN_SET(pkt, 68);
            BCM_PKT_HDR_VTAG_CONTROL_SET(pkt, VLAN_CTRL(0, 0, 1));
            BCM_PKT_PORT_SET(pkt, port_iter, FALSE, FALSE);
            rv = bcm_common_tx(unit, pkt, NULL);
            if (BCM_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_PORT,(BSL_META_U(unit,"IBOD 80-byte packet transmit"
                          "failed[%d] on port:%d\n\r"), rv, port_iter));
                ibod_ctrl->port_recovery_failed_flag = 1;
                break;
            }
            sal_udelay(200);

        }
        if (ibod_ctrl->port_recovery_failed_flag) {
            break;
        }

        rv = READ_RPKTr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count64_1 =  soc_reg64_field_get(unit, RPKTr, rval64, COUNTf);
        COMPILER_64_SET(tmp64, 0, 2);
        COMPILER_64_SUB_64(count64_1, count64);
        if (COMPILER_64_LT(count64_1, tmp64)) {
            sal_udelay(1000);
            rv = READ_RPKTr(unit, port_iter, &rval64);
            TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
            count64_1 =  soc_reg64_field_get(unit, RPKTr, rval64, COUNTf);
            COMPILER_64_SUB_64(count64_1, count64);
            if (COMPILER_64_LT(count64_1, tmp64)) {
                LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,"\n HELIX4 IBOD loopback packet"
                                 " not received in port %s"),SOC_PORT_NAME(unit,port_iter)));
            }
        }
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, RX_ENf, 0);
        rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, TX_ENf, 0);
        rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_TX_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_TX_CTRLr, &rval64, DISCARDf, 1);
        rv = WRITE_XMAC_TX_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_EGR_ENABLEm(
                unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port_iter], &egr_en);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_EGR_ENABLEm_field32_set(unit, &egr_en, PRT_ENABLEf, 0);
        rv = WRITE_EGR_ENABLEm(
                unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port_iter], &egr_en);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, SOFT_RESETf, 1);
        rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    rv = READ_PORT_ENABLE_REGr(unit, port, &rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT0f , 0);
    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT1f , 0);
    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT2f , 0);
    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT3f , 0);
    rv = WRITE_PORT_ENABLE_REGr(unit, port, rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_PORT_MODE_REGr(unit, port, &rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    port_mode=soc_reg_field_get(unit, PORT_MODE_REGr,
                                rval, XPORT0_CORE_PORT_MODEf);
    if(port_mode) {
        soc_reg_field_set(unit, PORT_MODE_REGr,
                           &rval, XPORT0_CORE_PORT_MODEf,0);
    }
    else {
        soc_reg_field_set(unit, PORT_MODE_REGr,
                           &rval, XPORT0_CORE_PORT_MODEf,1);
    }
    rv = WRITE_PORT_MODE_REGr(unit, port, rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    rv = READ_PORT_MODE_REGr(unit, port, &rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg_field_set(unit, PORT_MODE_REGr,
                      &rval, XPORT0_CORE_PORT_MODEf,port_mode);
    rv = WRITE_PORT_MODE_REGr(unit, port, rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_PORT_ENABLE_REGr(unit, port, &rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT0f , 1);
    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT2f , 1);
    if (port_mode == 2) {
        soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT1f , 1);
        soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval, PORT3f , 1);
    }
    rv = WRITE_PORT_ENABLE_REGr(unit, port, rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, SOFT_RESETf, 0);
        rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_EGR_ENABLEm(
                unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port_iter], &egr_en);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_EGR_ENABLEm_field32_set(unit, &egr_en, PRT_ENABLEf, 1);
        rv = WRITE_EGR_ENABLEm(
                unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port_iter], &egr_en);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    switch(port_group_iter) {
        case 0:
          rv = READ_IBOD_INTR_STATUSr(unit, &rval);
          TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
          soc_reg_field_set(unit, IBOD_INTR_STATUSr,
                 &rval, CL0_DATA_FIFO_FULL_ERR_INTR_STATUSf, 1);
          soc_reg_field_set(unit, IBOD_INTR_STATUSr,
                 &rval, CL0_CTRL_FIFO_FULL_ERR_INTR_STATUSf, 1);
          rv = WRITE_IBOD_INTR_STATUSr(unit, rval);
          TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
          break;
        case 1:
          rv = READ_IBOD_INTR_STATUSr(unit, &rval);
          TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
          soc_reg_field_set(unit, IBOD_INTR_STATUSr,
                 &rval, CL1_DATA_FIFO_FULL_ERR_INTR_STATUSf, 1);
          soc_reg_field_set(unit, IBOD_INTR_STATUSr,
                 &rval, CL1_CTRL_FIFO_FULL_ERR_INTR_STATUSf, 1);
          rv = WRITE_IBOD_INTR_STATUSr(unit, rval);
          TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
          break;
        case 2:
          rv = READ_IBOD_INTR_STATUSr(unit, &rval);
          TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
          soc_reg_field_set(unit, IBOD_INTR_STATUSr,
                 &rval, CL2_DATA_FIFO_FULL_ERR_INTR_STATUSf, 1);
          soc_reg_field_set(unit, IBOD_INTR_STATUSr,
                 &rval, CL2_CTRL_FIFO_FULL_ERR_INTR_STATUSf, 1);
          rv = WRITE_IBOD_INTR_STATUSr(unit, rval);
          TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
          break;
        default:
          break;
    }

    rv = READ_MEM_FAIL_INT_STAT_64r(unit, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg64_field32_set(unit, MEM_FAIL_INT_STAT_64r,
                          &rval64, START_BY_START_ERRf, 0);
    rv = WRITE_MEM_FAIL_INT_STAT_64r(unit, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_MEM_FAIL_INT_CTRr(unit, &rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg_field_set(unit, MEM_FAIL_INT_CTRr, &rval, INT_CTRf, 0);
    rv = WRITE_MEM_FAIL_INT_CTRr(unit, rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, LINE_LOCAL_LPBKf, 0);
        rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = soc_mem_read(
                unit, PORT_TABm, MEM_BLOCK_ANY, port_iter, &ptab_entry);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_mem_field32_set(unit, PORT_TABm, &ptab_entry, PORT_DIS_UNTAGf, port_dis_untag);
        soc_mem_field32_set(unit, PORT_TABm, &ptab_entry, PORT_DIS_TAGf, port_dis_tag);
        rv = soc_mem_write(
                unit, PORT_TABm, MEM_BLOCK_ALL, port_iter, &ptab_entry);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_RX_LSS_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_RX_LSS_CTRLr, &rval64, DROP_TX_DATA_ON_LOCAL_FAULTf, rx_lss[count]);
        soc_reg64_field32_set(unit, XMAC_RX_LSS_CTRLr, &rval64, DROP_TX_DATA_ON_REMOTE_FAULTf, rx_lss_1[count]);
        rv = WRITE_XMAC_RX_LSS_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count++;
    }

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_PAUSE_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_PAUSE_CTRLr, &rval64, RX_PAUSE_ENf, pause_rx[count]);
        rv = WRITE_XMAC_PAUSE_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

        rv = READ_XMAC_PFC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_PFC_CTRLr, &rval64, RX_PFC_ENf, rx_pfc_en[count]);
        rv = WRITE_XMAC_PFC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

        rv = READ_XMAC_LLFC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_LLFC_CTRLr, &rval64, RX_LLFC_ENf, rx_llfc_en[count]);
        rv = WRITE_XMAC_LLFC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count++;
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_TX_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_TX_CTRLr, &rval64, DISCARDf, 0);
        rv = WRITE_XMAC_TX_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, TX_ENf, 1);
        soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, RX_ENf, rx_en[count]);
        count++;
        rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }
    sal_udelay(200);
    rv = soc_link_mask2_set(unit, mask_restore);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    PORT_UNLOCK(unit);
    /* Release the ibod recovery port group lock */
    _bcm_esw_ibod_recovery_port_unlock(unit, port);

    rv = soc_link_fwd_set(unit, mask1_restore);
    if (BCM_FAILURE(rv)) {
        _bcm_esw_lc_unlock(unit);
        LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,"\n Error in re-setting the mask FWD"
                                 " for WAR on port %s"), SOC_PORT_NAME(unit,port)));
        return BCM_E_NONE;
    }
    _bcm_esw_lc_unlock(unit);

    BCM_PBMP_ITER(pbmp, port_iter) {
        SOC_IF_ERROR_RETURN(
            READ_PORT_CDC_TXFIFO_OVRFLWr(unit, port_iter, &rval));
        if (rval) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit," EXIT VALIDATE PORT_CDC_TXFIFO_OVRFLW ERR"
                             " failed on port:%d\n\r"), port_iter));
        }
    }
    time2 = SAL_USECS_SUB(sal_time_usecs(), ibod_ctrl->start_time);
    ibod_ctrl->event_count++;
    ibod_ctrl->port_avg_time = (ibod_ctrl->port_avg_time*(ibod_ctrl->event_count - 1) +
            time2 - time1) /ibod_ctrl->event_count;

    return SOC_E_NONE;

}

STATIC int
_bcm_hx4_txerr_recovery_port(_port_ibod_ctrl_t *ibod_ctrl,
                                 bcm_port_t port)
{
    bcm_pbmp_t pbmp;
    bcm_port_t port_iter;
    uint32 port_mode;
    uint32 rval, rval_1;
    uint64 rval64, txerr, flush_enable_pbm, tmp64;
    uint64 egress_meter[4];
    int unit=ibod_ctrl->unit, okay=0, rv = BCM_E_NONE;
    pbmp_t      mask, mask1, mask1_restore, mask_restore;
    soc_timeout_t timeout;
    int count,count_1;
    soc_info_t *si = &SOC_INFO(unit);
    egr_mmu_requests_entry_t mmu_entry;
    int rx_llfc_en[4],rx_pfc_en[4],pause_rx[4], rx_lss[4], rx_lss_1[4];
    uint32 max_used_entry, ep_level, overflow0, overflow1;
    static const soc_reg_t lls_port_credit_reg[] = {
        LLS_PORT_0_CREDITr, LLS_PORT_1_CREDITr, LLS_PORT_2_CREDITr,
        LLS_PORT_3_CREDITr, LLS_PORT_4_CREDITr, LLS_PORT_5_CREDITr,
        LLS_PORT_6_CREDITr, LLS_PORT_7_CREDITr, LLS_PORT_8_CREDITr,
        LLS_PORT_9_CREDITr, LLS_PORT_10_CREDITr, LLS_PORT_11_CREDITr,
        LLS_PORT_12_CREDITr, LLS_PORT_13_CREDITr, LLS_PORT_14_CREDITr,
        LLS_PORT_15_CREDITr, LLS_PORT_16_CREDITr, LLS_PORT_17_CREDITr,
        LLS_PORT_18_CREDITr, LLS_PORT_19_CREDITr, LLS_PORT_20_CREDITr,
        LLS_PORT_21_CREDITr, LLS_PORT_22_CREDITr, LLS_PORT_23_CREDITr,
        LLS_PORT_24_CREDITr, LLS_PORT_25_CREDITr, LLS_PORT_26_CREDITr,
        LLS_PORT_27_CREDITr, LLS_PORT_28_CREDITr, LLS_PORT_29_CREDITr,
        LLS_PORT_30_CREDITr, LLS_PORT_31_CREDITr, LLS_PORT_32_CREDITr,
        LLS_PORT_33_CREDITr, LLS_PORT_34_CREDITr, LLS_PORT_35_CREDITr,
        LLS_PORT_36_CREDITr, LLS_PORT_37_CREDITr, LLS_PORT_38_CREDITr,
        LLS_PORT_39_CREDITr, LLS_PORT_40_CREDITr, LLS_PORT_41_CREDITr,
        LLS_PORT_42_CREDITr, LLS_PORT_43_CREDITr, LLS_PORT_44_CREDITr,
        LLS_PORT_45_CREDITr, LLS_PORT_46_CREDITr, LLS_PORT_47_CREDITr,
        LLS_PORT_48_CREDITr, LLS_PORT_49_CREDITr, LLS_PORT_50_CREDITr,
        LLS_PORT_51_CREDITr, LLS_PORT_52_CREDITr, LLS_PORT_53_CREDITr,
        LLS_PORT_54_CREDITr, LLS_PORT_55_CREDITr, LLS_PORT_56_CREDITr,
        LLS_PORT_57_CREDITr, LLS_PORT_58_CREDITr, LLS_PORT_59_CREDITr,
        LLS_PORT_60_CREDITr, LLS_PORT_61_CREDITr, LLS_PORT_62_CREDITr
    }; 
    sal_usecs_t time1, time2;

    time1 = SAL_USECS_SUB(sal_time_usecs(), ibod_ctrl->start_time);

    SOC_IF_ERROR_RETURN(READ_PORT_MODE_REGr(unit, port, &rval));
    port_mode=soc_reg_field_get(unit, PORT_MODE_REGr,
                                rval, XPORT0_CORE_PORT_MODEf);
    sal_memset(&pbmp, 0, sizeof(bcm_pbmp_t));
    if (port_mode) {
        rv = bcm_esw_port_subsidiary_ports_get(unit, port, &pbmp);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,"\n Error in retreiving the subsidiary ports"
                                     " for port %s"), SOC_PORT_NAME(unit,port)));
            return BCM_E_NONE;
        }
    } else {
        SOC_IF_ERROR_RETURN(bcm_esw_port_enable_get(unit, port, &okay));
        if (okay) {
            SOC_PBMP_PORT_ADD(pbmp, port);
        } else {
            return SOC_E_NONE;
        }
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        SOC_IF_ERROR_RETURN(READ_PORT_CDC_TXFIFO_OVRFLWr(unit, port_iter, &rval));
        if (rval) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,"IBOD PORT_CDC_TXFIFO_OVRFLW ERR"
                         " failed on port:%d\n\r"), port_iter));
        }
    }

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
       SOC_IF_ERROR_RETURN(READ_TERRr(unit, port_iter, &txerr));
       /* coverity[overrun-local : FALSE] */
       if (COMPILER_64_NE(ibod_ctrl->txerrpkt[port_iter], txerr)) {
           ibod_ctrl->txerrpkt[port_iter] = txerr;
           count++;
       }
    }
    BCM_PBMP_ITER(pbmp, port_iter) {
        SOC_IF_ERROR_RETURN(READ_XMAC_FIFO_STATUSr(unit, port_iter, &rval64));
        if (!count) {
            count = soc_reg64_field32_get(unit, XMAC_FIFO_STATUSr, rval64, TX_PKT_UNDERFLOWf);
        }
    }

    if (!count) {
        return SOC_E_NONE;
    }

    LOG_VERBOSE(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,"\n WAR Trigerred by TXERR in subports %s"),SOC_PORT_NAME(unit,port)));

    _bcm_esw_lc_lock(unit);
    soc_link_fwd_get(unit, &mask1);
    SOC_PBMP_ASSIGN(mask1_restore,mask1);
    BCM_PBMP_ITER(pbmp, port_iter) {
        BCM_PBMP_PORT_REMOVE(mask1,port_iter);
    }
    rv = soc_link_fwd_set(unit, mask1);
    if (BCM_FAILURE(rv)) {
        _bcm_esw_lc_unlock(unit);
        LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,"\n Error in setting the mask FWD"
                                 " for WAR on port %s"), SOC_PORT_NAME(unit,port)));
        return BCM_E_NONE;
    }

    /* Hold the ibod recovery port group lock */
    _bcm_esw_ibod_recovery_port_lock(unit, port);
    PORT_LOCK(unit);

    soc_link_mask2_get(unit, &mask);
    SOC_PBMP_ASSIGN(mask_restore,mask);
    BCM_PBMP_ITER(pbmp, port_iter) {
        BCM_PBMP_PORT_REMOVE(mask,port_iter);
    }
    rv = soc_link_mask2_set(unit, mask);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);


    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_PAUSE_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        pause_rx[count] = soc_reg64_field32_get(unit, XMAC_PAUSE_CTRLr, rval64, RX_PAUSE_ENf);
        soc_reg64_field32_set(unit, XMAC_PAUSE_CTRLr, &rval64, RX_PAUSE_ENf, 0);
        rv = WRITE_XMAC_PAUSE_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

        rv = READ_XMAC_PFC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        rx_pfc_en[count] = soc_reg64_field32_get(unit, XMAC_PFC_CTRLr, rval64, RX_PFC_ENf);
        soc_reg64_field32_set(unit, XMAC_PFC_CTRLr, &rval64, RX_PFC_ENf, 0);
        rv = WRITE_XMAC_PFC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

        rv = READ_XMAC_LLFC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        rx_llfc_en[count] = soc_reg64_field32_get(unit, XMAC_LLFC_CTRLr, rval64, RX_LLFC_ENf);
        soc_reg64_field32_set(unit, XMAC_LLFC_CTRLr, &rval64, RX_LLFC_ENf, 0);
        rv = WRITE_XMAC_LLFC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count++;
    }

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_EGRMETERINGCONFIG_64r(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        egress_meter[count] = rval64;
        COMPILER_64_ZERO(tmp64);
        rv = WRITE_EGRMETERINGCONFIG_64r(unit, port_iter, tmp64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count++;
    }

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_RX_LSS_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        rx_lss[count] = soc_reg64_field32_get(unit, XMAC_RX_LSS_CTRLr, rval64,
                                       DROP_TX_DATA_ON_LOCAL_FAULTf);
        rx_lss_1[count] = soc_reg64_field32_get(unit, XMAC_RX_LSS_CTRLr, rval64,
                                       DROP_TX_DATA_ON_REMOTE_FAULTf);
        soc_reg64_field32_set(unit, XMAC_RX_LSS_CTRLr, &rval64, DROP_TX_DATA_ON_LOCAL_FAULTf, 1);
        soc_reg64_field32_set(unit, XMAC_RX_LSS_CTRLr, &rval64, DROP_TX_DATA_ON_REMOTE_FAULTf, 1);
        rv = WRITE_XMAC_RX_LSS_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count++;
    }

    rv = READ_MCQ_IPMC_FAST_FLUSHr(unit, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    COMPILER_64_SET(flush_enable_pbm, pbmp.pbits[1], pbmp.pbits[0]);
    soc_reg64_field_set(unit, MCQ_IPMC_FAST_FLUSHr, &rval64, ENABLEf, flush_enable_pbm);
    rv = WRITE_MCQ_IPMC_FAST_FLUSHr(unit, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_PORT_TXFIFO_PKT_DROP_CTLr(unit, port_iter, &rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg_field_set(unit, PORT_TXFIFO_PKT_DROP_CTLr, &rval, DROP_ENf, 1);
        rv = WRITE_PORT_TXFIFO_PKT_DROP_CTLr(unit, port_iter, rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }
    rv = READ_PORT_MODE_REGr(unit, port, &rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    port_mode = soc_reg_field_get(unit, PORT_MODE_REGr,
                                  rval, XPORT0_CORE_PORT_MODEf);

    soc_timeout_init(&timeout, 30000, 0);
    count_1=0;
    do {
        if (soc_timeout_check(&timeout)) {
            ep_level = 0;
            BCM_PBMP_ITER(pbmp, port_iter) {
                rv = READ_EGR_EDB_MISC_CTRLr(unit, &rval);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                soc_reg_field_set(unit, EGR_EDB_MISC_CTRLr, &rval, SELECT_CURRENT_USED_ENTRIESf, 1);
                rv = WRITE_EGR_EDB_MISC_CTRLr(unit, rval);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                /* coverity[overrun-local : FALSE] */
                rv = READ_EGR_MAX_USED_ENTRIESm(
                        unit, MEM_BLOCK_ALL, si->port_l2p_mapping[port_iter],
                        &max_used_entry);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                ep_level += soc_mem_field32_get(unit, EGR_MAX_USED_ENTRIESm, &max_used_entry, LEVELf);
            }
            if(ep_level == 0) {
                ibod_ctrl->drain_timeout_flag = 1;
            }
            else {
                rv = READ_PQEFIFOOVERFLOW0r(unit, &overflow0);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                rv = READ_PQEFIFOOVERFLOW1r(unit, &overflow1);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                LOG_ERROR(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit, "\n IBOD recovery Timeout Drain packets %d PORT: %s, "
                        "total ep_level:%d, overflow0:%d, overflow1:%d\n"),
                        ibod_ctrl->unit, SOC_PORT_NAME(unit,port), ep_level, overflow0, overflow1));
            }
            break;
        } else {
            BCM_PBMP_ITER(pbmp, port_iter) {
                rv = soc_reg32_get(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port_iter]]],
                                     REG_PORT_ANY, 0, &rval);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                if (!rval) {
                    count_1++;
                    rv = soc_mem_read(unit, EGR_MMU_REQUESTSm, MEM_BLOCK_ANY,
                                      si->port_l2p_mapping[port_iter],
                                      &mmu_entry);
                    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                    rval = soc_mem_field32_get(unit, EGR_MMU_REQUESTSm, &mmu_entry, OUTSTANDING_MMU_REQUESTSf);
                    rv = soc_reg32_set(unit,
                        lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port_iter]]],
                        REG_PORT_ANY, 0, rval);
                    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                }
            }
            count=0;
            BCM_PBMP_ITER(pbmp, port_iter) {
                rv = READ_OP_PORT_TOTAL_COUNT_CELLr(unit, port_iter, &rval);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                count += soc_reg_field_get(unit, OP_PORT_TOTAL_COUNT_CELLr,rval, TOTAL_COUNTf);
                rv = READ_PORT_TXFIFO_CELL_CNTr(unit, port_iter, &rval);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                count += soc_reg_field_get(unit, PORT_TXFIFO_CELL_CNTr, rval, CELL_CNTf);

            }
       }
    } while (count);

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = soc_mem_read(unit, EGR_MMU_REQUESTSm, MEM_BLOCK_ANY,
                          si->port_l2p_mapping[port_iter], &mmu_entry);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        rval = soc_mem_field32_get(unit, EGR_MMU_REQUESTSm, &mmu_entry, OUTSTANDING_MMU_REQUESTSf);
        rv = soc_reg32_get(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port_iter]]],
                                            REG_PORT_ANY, 0, &rval_1);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        if (rval != rval_1) {
            rv = soc_reg32_set(unit,
                lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port_iter]]],
                REG_PORT_ANY, 0, rval);
            TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        }
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CLEAR_FIFO_STATUSr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CLEAR_FIFO_STATUSr, &rval64, CLEAR_TX_PKT_UNDERFLOWf, 1);
        rv = WRITE_XMAC_CLEAR_FIFO_STATUSr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_CLEAR_FIFO_STATUSr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_CLEAR_FIFO_STATUSr, &rval64, CLEAR_TX_PKT_UNDERFLOWf, 0);
        rv = WRITE_XMAC_CLEAR_FIFO_STATUSr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = WRITE_EGRMETERINGCONFIG_64r(unit, port_iter, egress_meter[count]);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count++;
    }

    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_PORT_TXFIFO_PKT_DROP_CTLr(unit, port_iter, &rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg_field_set(unit, PORT_TXFIFO_PKT_DROP_CTLr, &rval, DROP_ENf, 0);
        rv = WRITE_PORT_TXFIFO_PKT_DROP_CTLr(unit, port_iter, rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    }

    rv = READ_MCQ_IPMC_FAST_FLUSHr(unit, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg64_field32_set(unit, MCQ_IPMC_FAST_FLUSHr, &rval64, ENABLEf, 0);
    rv = WRITE_MCQ_IPMC_FAST_FLUSHr(unit, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_RX_LSS_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_RX_LSS_CTRLr, &rval64, DROP_TX_DATA_ON_LOCAL_FAULTf, rx_lss[count]);
        soc_reg64_field32_set(unit, XMAC_RX_LSS_CTRLr, &rval64, DROP_TX_DATA_ON_REMOTE_FAULTf, rx_lss_1[count]);
        rv = WRITE_XMAC_RX_LSS_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count++;
    }

    count=0;
    BCM_PBMP_ITER(pbmp, port_iter) {
        rv = READ_XMAC_PAUSE_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_PAUSE_CTRLr, &rval64, RX_PAUSE_ENf, pause_rx[count]);
        rv = WRITE_XMAC_PAUSE_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

        rv = READ_XMAC_PFC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_PFC_CTRLr, &rval64, RX_PFC_ENf, rx_pfc_en[count]);
        rv = WRITE_XMAC_PFC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

        rv = READ_XMAC_LLFC_CTRLr(unit, port_iter, &rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg64_field32_set(unit, XMAC_LLFC_CTRLr, &rval64, RX_LLFC_ENf, rx_llfc_en[count]);
        rv = WRITE_XMAC_LLFC_CTRLr(unit, port_iter, rval64);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        count++;
    }

    rv = soc_link_mask2_set(unit, mask_restore);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    PORT_UNLOCK(unit);
    /* Release the ibod recovery port group lock */
    _bcm_esw_ibod_recovery_port_unlock(unit, port);

    rv = soc_link_fwd_set(unit, mask1_restore);
    if (BCM_FAILURE(rv)) {
        _bcm_esw_lc_unlock(unit);
        LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,"\n Error in re-setting the mask FWD"
                                 " for WAR on port %s"), SOC_PORT_NAME(unit,port)));
        return BCM_E_NONE;
    }

    _bcm_esw_lc_unlock(unit);
    time2 = SAL_USECS_SUB(sal_time_usecs(), ibod_ctrl->start_time);
    ibod_ctrl->txerr_count++;
    ibod_ctrl->txerr_avg_time = (ibod_ctrl->txerr_avg_time*(ibod_ctrl->txerr_count-1) +
            time2 - time1) /ibod_ctrl->txerr_count;

    return SOC_E_NONE;
}


STATIC int
_bcm_tr3_mmu_recovery(_port_ibod_ctrl_t *ibod_ctrl)
{
    mac_driver_t *macd;
    bcm_port_t port_iter;
    uint32 rval, rval_1, count;
    uint64 rval64,txerr, val64;
    int unit=ibod_ctrl->unit, rv = BCM_E_NONE;
    soc_info_t *si = &SOC_INFO(unit);
    egr_mmu_requests_entry_t mmu_entry;
    int linkscan_interval, counter_interval;
    uint32 counter_flags;
    uint32    l2x_flags;
    int scan_rate, l2x_running = 0, mem_scan_running = 0;
    sal_usecs_t l2x_interval, scan_interval;
    bcm_pbmp_t rx_en_pbmp, rx_llfc_en_pbmp, tx_llfc_en_pbmp;
    bcm_pbmp_t rx_pfc_en_pbmp, tx_pfc_en_pbmp;
    bcm_pbmp_t pause_rx_pbmp, pause_tx_pbmp;
    bcm_pbmp_t rx_lss_local_pbmp,rx_lss_remote_pbmp, counter_pbmp;
    uint64 egrmeteringconfig[_SOC_TR3_MAX_NUM_LPORTS];
    soc_timeout_t timeout;
    int num_mmu_port, mmu_port, phy_port, port;
    pbmp_t  pbm;
    epc_link_bmap_entry_t entry, epc_lin_bmap_entry;
    static const soc_reg_t lls_port_credit_reg[] = {
        LLS_PORT_0_CREDITr, LLS_PORT_1_CREDITr, LLS_PORT_2_CREDITr,
        LLS_PORT_3_CREDITr, LLS_PORT_4_CREDITr, LLS_PORT_5_CREDITr,
        LLS_PORT_6_CREDITr, LLS_PORT_7_CREDITr, LLS_PORT_8_CREDITr,
        LLS_PORT_9_CREDITr, LLS_PORT_10_CREDITr, LLS_PORT_11_CREDITr,
        LLS_PORT_12_CREDITr, LLS_PORT_13_CREDITr, LLS_PORT_14_CREDITr,
        LLS_PORT_15_CREDITr, LLS_PORT_16_CREDITr, LLS_PORT_17_CREDITr,
        LLS_PORT_18_CREDITr, LLS_PORT_19_CREDITr, LLS_PORT_20_CREDITr,
        LLS_PORT_21_CREDITr, LLS_PORT_22_CREDITr, LLS_PORT_23_CREDITr,
        LLS_PORT_24_CREDITr, LLS_PORT_25_CREDITr, LLS_PORT_26_CREDITr,
        LLS_PORT_27_CREDITr, LLS_PORT_28_CREDITr, LLS_PORT_29_CREDITr,
        LLS_PORT_30_CREDITr, LLS_PORT_31_CREDITr, LLS_PORT_32_CREDITr,
        LLS_PORT_33_CREDITr, LLS_PORT_34_CREDITr, LLS_PORT_35_CREDITr,
        LLS_PORT_36_CREDITr, LLS_PORT_37_CREDITr, LLS_PORT_38_CREDITr,
        LLS_PORT_39_CREDITr, LLS_PORT_40_CREDITr, LLS_PORT_41_CREDITr,
        LLS_PORT_42_CREDITr, LLS_PORT_43_CREDITr, LLS_PORT_44_CREDITr,
        LLS_PORT_45_CREDITr, LLS_PORT_46_CREDITr, LLS_PORT_47_CREDITr,
        LLS_PORT_48_CREDITr, LLS_PORT_49_CREDITr, LLS_PORT_50_CREDITr,
        LLS_PORT_51_CREDITr, LLS_PORT_52_CREDITr, LLS_PORT_53_CREDITr,
        LLS_PORT_54_CREDITr, LLS_PORT_55_CREDITr, LLS_PORT_56_CREDITr,
        LLS_PORT_57_CREDITr, LLS_PORT_58_CREDITr, LLS_PORT_59_CREDITr,
        LLS_PORT_60_CREDITr, LLS_PORT_61_CREDITr, LLS_PORT_62_CREDITr
    }; 
    sal_usecs_t time1, time2;

    time1 = SAL_USECS_SUB(sal_time_usecs(), ibod_ctrl->start_time);

    /*****"Preparation and Stop ingress traffic Start*****/
    /*1.  Disable all back ground threads to prevent any SBUS acitivities (software handling)*/
    BCM_IF_ERROR_RETURN(bcm_esw_linkscan_enable_get(unit, &linkscan_interval));
    BCM_IF_ERROR_RETURN(bcm_esw_linkscan_enable_set(unit, 0));
    BCM_IF_ERROR_RETURN(soc_counter_status(unit, &counter_flags,
                    &counter_interval, &counter_pbmp));
    BCM_IF_ERROR_RETURN(soc_counter_stop(unit));
    if (soc_l2x_running(unit, &l2x_flags, &l2x_interval)) {
        l2x_running = 1;
        BCM_IF_ERROR_RETURN(soc_l2x_stop(unit));
    }
#ifdef INCLUDE_MEM_SCAN
    if (soc_mem_scan_running(unit, &scan_rate, &scan_interval)) {
        mem_scan_running = 1;
        BCM_IF_ERROR_RETURN(soc_mem_scan_stop(unit));
    }
#endif

    /*2.  Disable "TX" API to prevent CPU packet from going into MMU (software handling)*/
    PBMP_PORT_ITER(unit, port_iter){
        _bcm_esw_ibod_recovery_port_lock(unit, port_iter);
    }

    /*3. Stop all ingress ports traffic to prevent any packet from going into MMU */
    sal_memset(&rx_en_pbmp, 0, sizeof(bcm_pbmp_t));
    PBMP_PORT_ITER(unit, port_iter){
        macd = PORT(unit, port_iter).p_mac;
        rv = MAC_CONTROL_GET(macd,unit, port_iter, SOC_MAC_CONTROL_RX_SET, (int *)&rval);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        if (rval) {
            BCM_PBMP_PORT_ADD(rx_en_pbmp, port_iter);
        }
        rv = MAC_CONTROL_SET(macd, unit, port_iter, SOC_MAC_CONTROL_RX_SET, 0);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }

    /*4. Stop all AXP traffic to prevent any packet from going into MMU */
    sal_memset(&pbm, 0, sizeof(pbmp_t));
    /*    coverity[check_return]    */
    rv = READ_EPC_LINK_BMAPm(unit, MEM_BLOCK_ALL, 0,&entry);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    sal_memcpy(&epc_lin_bmap_entry, &entry, sizeof(epc_link_bmap_entry_t));
    soc_mem_pbmp_field_set(unit, EPC_LINK_BMAPm, &entry, PORT_BITMAPf, &pbm);
    rv = WRITE_EPC_LINK_BMAPm(unit, MEM_BLOCK_ALL, 0,&entry);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    /*****"Preparation and Stop ingress traffic End*****/

    /*****Packet Drain Start*****/
    /* 1.Stop all pauses to speed up draining*/
    sal_memset(&pause_rx_pbmp, 0, sizeof(bcm_pbmp_t));
    sal_memset(&pause_tx_pbmp, 0, sizeof(bcm_pbmp_t));

    PBMP_PORT_ITER(unit, port_iter){
        macd = PORT(unit, port_iter).p_mac;
        rv = MAC_PAUSE_GET(macd, unit, port_iter, (int *)&rval, (int *)&rval_1);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        if (rval) {
            BCM_PBMP_PORT_ADD(pause_tx_pbmp, port_iter);
        }
        if (rval_1) {
            BCM_PBMP_PORT_ADD(pause_rx_pbmp, port_iter);
        }
        rv = MAC_PAUSE_SET(macd, unit, port_iter, 0, 0);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }

    sal_memset(&rx_llfc_en_pbmp, 0, sizeof(bcm_pbmp_t));
    sal_memset(&tx_llfc_en_pbmp, 0, sizeof(bcm_pbmp_t));
    PBMP_PORT_ITER(unit, port_iter){
        macd = PORT(unit, port_iter).p_mac;
        rv = MAC_CONTROL_GET(macd, unit, port_iter, SOC_MAC_CONTROL_LLFC_TX_ENABLE, (int *)&rval);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        if (rval) {
            BCM_PBMP_PORT_ADD(tx_llfc_en_pbmp, port_iter);
        }
        rv = MAC_CONTROL_SET(macd, unit, port_iter, SOC_MAC_CONTROL_LLFC_TX_ENABLE, 0);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        rv = MAC_CONTROL_GET(macd, unit, port_iter, SOC_MAC_CONTROL_LLFC_RX_ENABLE, (int *)&rval);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        if (rval) {
            BCM_PBMP_PORT_ADD(rx_llfc_en_pbmp, port_iter);
        }
        rv = MAC_CONTROL_SET(macd, unit, port_iter, SOC_MAC_CONTROL_LLFC_RX_ENABLE, 0);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }

    sal_memset(&tx_pfc_en_pbmp, 0, sizeof(bcm_pbmp_t));
    sal_memset(&rx_pfc_en_pbmp, 0, sizeof(bcm_pbmp_t));
    PBMP_PORT_ITER(unit, port_iter){
        macd = PORT(unit, port_iter).p_mac;
        rv = MAC_CONTROL_GET(macd, unit, port_iter, SOC_MAC_CONTROL_PFC_TX_ENABLE, (int *)&rval);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        if (rval) {
            BCM_PBMP_PORT_ADD(tx_pfc_en_pbmp, port_iter);
        }
        rv = MAC_CONTROL_SET(macd, unit, port_iter, SOC_MAC_CONTROL_PFC_TX_ENABLE, 0);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        rv = MAC_CONTROL_GET(macd, unit, port_iter, SOC_MAC_CONTROL_PFC_RX_ENABLE, (int *)&rval);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        if (rval) {
            BCM_PBMP_PORT_ADD(rx_pfc_en_pbmp, port_iter);
        }
        rv = MAC_CONTROL_SET(macd, unit, port_iter, SOC_MAC_CONTROL_PFC_RX_ENABLE, 0);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }

    /*2. Set XMAC LLS CTRL to ignore Serdes fault signal which may prevent packets from draining at cable unplug case*/
    sal_memset(&rx_lss_local_pbmp, 0, sizeof(bcm_pbmp_t));
    sal_memset(&rx_lss_remote_pbmp, 0, sizeof(bcm_pbmp_t));
    PBMP_PORT_ITER(unit, port_iter){
        rv = READ_XMAC_RX_LSS_CTRLr(unit, port_iter, &rval64);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        rval = soc_reg64_field32_get(unit, XMAC_RX_LSS_CTRLr, rval64,
                                        DROP_TX_DATA_ON_LOCAL_FAULTf);
        if (0 == rval) {
            BCM_PBMP_PORT_ADD(rx_lss_local_pbmp, port_iter);
            soc_reg64_field32_set(unit, XMAC_RX_LSS_CTRLr, &rval64, DROP_TX_DATA_ON_LOCAL_FAULTf, 1);
        }

        rval = soc_reg64_field32_get(unit, XMAC_RX_LSS_CTRLr, rval64,
                                        DROP_TX_DATA_ON_REMOTE_FAULTf);
        if (0 == rval) {
            BCM_PBMP_PORT_ADD(rx_lss_remote_pbmp, port_iter);
            soc_reg64_field32_set(unit, XMAC_RX_LSS_CTRLr, &rval64, DROP_TX_DATA_ON_REMOTE_FAULTf, 1);
        }
        rv = WRITE_XMAC_RX_LSS_CTRLr(unit, port_iter, rval64);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }

    /*3. Enable IPMC fast flush */
    rv = READ_MCQ_IPMC_FAST_FLUSHr(unit, &rval64);
    if (BCM_FAILURE(rv)) {
        goto end;
    }

    COMPILER_64_SET(val64, 0x3fffffff, 0xffffffff);
    soc_reg64_field_set(unit, MCQ_IPMC_FAST_FLUSHr, &rval64, ENABLEf, val64);
    rv = WRITE_MCQ_IPMC_FAST_FLUSHr(unit, rval64);
    if (BCM_FAILURE(rv)) {
        goto end;
    }

    /*4. Set PORT fast flush */
    PBMP_PORT_ITER(unit, port_iter){
        rv = soc_reg_field32_modify(unit, PORT_TXFIFO_PKT_DROP_CTLr, port_iter,
                DROP_ENf, 1);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }

    /*5.Stop MMU egress */
    PBMP_PORT_ITER(unit, port_iter){
        rv = READ_EGRMETERINGCONFIG_64r(unit, port_iter, &rval64);
        if (BCM_FAILURE(rv)) {
            goto end;
        }

        COMPILER_64_SET(egrmeteringconfig[port_iter], COMPILER_64_HI(rval64), COMPILER_64_LO(rval64));
        COMPILER_64_SET(val64, 0, 0);
        soc_reg64_field_set(unit, EGRMETERINGCONFIG_64r, &rval64, REFRESHf, val64);
        COMPILER_64_SET(val64, 0, 1);
        soc_reg64_field_set(unit, EGRMETERINGCONFIG_64r, &rval64, THD_SELf, val64);
        COMPILER_64_SET(val64, 0, 0);
        soc_reg64_field_set(unit, EGRMETERINGCONFIG_64r, &rval64, METER_GRANf, val64);
        rv = WRITE_EGRMETERINGCONFIG_64r(unit, port_iter, rval64);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }

    /*6.Wait until all PORT TXFIFO count == 0*/
    soc_timeout_init(&timeout, 30000, 0);
    do {
        if (soc_timeout_check(&timeout)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit, "\n MMU Recovery Timeout Ports Drain packets unit:%d"), ibod_ctrl->unit));
            break;
        }
        count=0;
        PBMP_PORT_ITER(unit, port_iter){
            rv = READ_PORT_CDC_TXFIFO_CELL_CNTr(unit, port_iter, &rval);
            if (BCM_FAILURE(rv)) {
                goto end;
            }
            count += soc_reg_field_get(unit, PORT_CDC_TXFIFO_CELL_CNTr,rval, CELL_CNTf);
            rv = READ_PORT_TXFIFO_CELL_CNTr(unit, port_iter, &rval);
            if (BCM_FAILURE(rv)) {
                goto end;
            }
            count += soc_reg_field_get(unit, PORT_TXFIFO_CELL_CNTr, rval, CELL_CNTf);
        }
    } while (count);

    /*****Packet Drain End*****/

    /*****MMU reset Start*****/
    /*1. Backup all necessary MMU configurations */
    rv = soc_tr3_mmu_register_store(unit);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    rv = soc_tr3_mmu_memory_store(unit);
    if (BCM_FAILURE(rv)) {
        goto end;
    }

    /*2. Do TOP level MMU reset*/
    rv = READ_TOP_SOFT_RESET_REGr(unit, &rval);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_MMU_RST_Lf, 0);
    rv = WRITE_TOP_SOFT_RESET_REGr(unit, rval);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_MMU_RST_Lf, 1);
    rv = WRITE_TOP_SOFT_RESET_REGr(unit, rval);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
     /* 3. REFRESH_ENF*/
    rv = soc_reg32_get(unit, MISCCONFIGr, REG_PORT_ANY, 0, &rval);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    soc_reg_field_set(unit, MISCCONFIGr, &rval, METERING_CLK_ENf, 1);
    rv = soc_reg32_set(unit, MISCCONFIGr, REG_PORT_ANY, 0, rval);
    if(BCM_FAILURE(rv)) {
        goto end;
    }

    /*4. Call soc_mmu_init to init MMU*/
    rv = soc_mmu_init(unit);
    if (BCM_FAILURE(rv)) {
        goto end;
    }

     /*5.Restore Registers/Memories which are called in MMU init (following MMU init sequence)*/
    rv = soc_tr3_mmu_init_restore(unit);
    if (BCM_FAILURE(rv)) {
    goto end;
    }

    /*6.Restore other MMU registers without sequence*/
    rv = soc_tr3_mmu_register_restore(unit);
    if (BCM_FAILURE(rv)) {
        goto end;
    }

    /*7.Restore other MMU memories without sequence*/
    rv = soc_tr3_mmu_memory_restore(unit);
    if (BCM_FAILURE(rv)) {
        goto end;
    }

    /*8.Restore MMU2PHY port mapping and MMU2LOGIC port mapping*/
    num_mmu_port = SOC_REG_NUMELS(unit, MMU_TO_PHY_PORT_MAPPINGr);
    for (mmu_port = 0; mmu_port < num_mmu_port; mmu_port++) {
        phy_port = si->port_m2p_mapping[mmu_port];
        port = phy_port == -1 ? -1 : si->port_p2l_mapping[phy_port];

        rval = 0;
        soc_reg_field_set(unit, MMU_TO_PHY_PORT_MAPPINGr, &rval, PHY_PORTf,
                          phy_port == -1 ? 0x7f : phy_port);
        rv = WRITE_MMU_TO_PHY_PORT_MAPPINGr(unit, mmu_port, rval);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        rval = 0;
        soc_reg_field_set(unit, MMU_TO_LOGIC_PORT_MAPPINGr, &rval, LOGIC_PORTf,
                          port == -1 ? 0x3f : port);
        rv = WRITE_MMU_TO_LOGIC_PORT_MAPPINGr(unit, mmu_port, rval);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }

    /* 9. Restore MMU to EP credicts after EP restore because EP port enable will update EGR_MMU_REQUESTSm*/
    PBMP_ALL_ITER(unit, port_iter){
        if (!IS_CPU_PORT(unit, port_iter) && !IS_PORT(unit, port_iter)) {
            continue;
        }
        rv = soc_mem_read(unit, EGR_MMU_REQUESTSm, MEM_BLOCK_ANY, si->port_l2p_mapping[port_iter], &mmu_entry);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        rval = soc_mem_field32_get(unit, EGR_MMU_REQUESTSm, &mmu_entry, OUTSTANDING_MMU_REQUESTSf);
        rv = soc_reg32_get(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port_iter]]],
                           REG_PORT_ANY, 0, &rval_1);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        if (rval != rval_1) {
            rv = soc_reg32_set(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port_iter]]],
                              REG_PORT_ANY, 0, rval);
            if(BCM_FAILURE(rv)) {
                goto end;
            }
        }
    }
    /*restore axp credit*/
    rv = soc_reg32_set(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[58]]],
                      REG_PORT_ANY, 0, 0x14);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    rv = soc_reg32_set(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[59]]],
                      REG_PORT_ANY, 0, 0x14);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    rv = soc_reg32_set(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[60]]],
                      REG_PORT_ANY, 0, 4);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    rv = soc_reg32_set(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[61]]],
                      REG_PORT_ANY, 0, 0x14);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    /*****MMU reset End*****/

    /***** Resume ingress traffic Start*****/
    /*1.Restore XMAC_RX_LSS_CTRL setting*/
    BCM_PBMP_ITER(rx_lss_local_pbmp, port_iter){
        rv = READ_XMAC_RX_LSS_CTRLr(unit, port_iter, &rval64);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        soc_reg64_field32_set(unit, XMAC_RX_LSS_CTRLr, &rval64, DROP_TX_DATA_ON_LOCAL_FAULTf, 0);
        rv = WRITE_XMAC_RX_LSS_CTRLr(unit, port_iter, rval64);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }
    BCM_PBMP_ITER(rx_lss_remote_pbmp, port_iter){
        rv = READ_XMAC_RX_LSS_CTRLr(unit, port_iter, &rval64);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        soc_reg64_field32_set(unit, XMAC_RX_LSS_CTRLr, &rval64, DROP_TX_DATA_ON_LOCAL_FAULTf, 0);
        soc_reg64_field32_set(unit, XMAC_RX_LSS_CTRLr, &rval64, DROP_TX_DATA_ON_REMOTE_FAULTf, 0);
        rv = WRITE_XMAC_RX_LSS_CTRLr(unit, port_iter, rval64);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }

    /*2.Restore MMU egress */
    PBMP_PORT_ITER(unit, port_iter){
        rv = WRITE_EGRMETERINGCONFIG_64r(unit, port_iter, egrmeteringconfig[port_iter]);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }

    /*3.Disable PORT fast flush*/
    PBMP_PORT_ITER(unit, port_iter){
        rv = soc_reg_field32_modify(unit, PORT_TXFIFO_PKT_DROP_CTLr, port_iter,
                DROP_ENf, 0);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }
    /*4.Disable IPMC fast flush  */
    rv = READ_MCQ_IPMC_FAST_FLUSHr(unit, &rval64);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    soc_reg64_field32_set(unit, MCQ_IPMC_FAST_FLUSHr, &rval64, ENABLEf, 0);
    rv = WRITE_MCQ_IPMC_FAST_FLUSHr(unit, rval64);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    /* 5.Restore pause settings*/
    BCM_PBMP_ITER(pause_tx_pbmp, port_iter){
        macd = PORT(unit, port_iter).p_mac;
        rv = MAC_PAUSE_GET(macd, unit, port_iter, (int *)&rval, (int *)&rval_1);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        rv = MAC_PAUSE_SET(macd, unit, port_iter, 1, rval_1);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }
    BCM_PBMP_ITER(pause_rx_pbmp, port_iter){
        macd = PORT(unit, port_iter).p_mac;
        rv = MAC_PAUSE_GET(macd, unit, port_iter, (int *)&rval, (int *)&rval_1);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        rv = MAC_PAUSE_SET(macd, unit, port_iter, rval, 1);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }
    BCM_PBMP_ITER(tx_llfc_en_pbmp, port_iter){
        macd = PORT(unit, port_iter).p_mac;
        rv = MAC_CONTROL_SET(macd, unit, port_iter, SOC_MAC_CONTROL_LLFC_TX_ENABLE, 1);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }
    BCM_PBMP_ITER(rx_llfc_en_pbmp, port_iter){
        macd = PORT(unit, port_iter).p_mac;
        rv = MAC_CONTROL_SET(macd, unit, port_iter, SOC_MAC_CONTROL_LLFC_RX_ENABLE, 1);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }
    BCM_PBMP_ITER(tx_pfc_en_pbmp, port_iter){
        macd = PORT(unit, port_iter).p_mac;
        rv = MAC_CONTROL_SET(macd, unit, port_iter, SOC_MAC_CONTROL_PFC_TX_ENABLE, 1);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }
    BCM_PBMP_ITER(rx_pfc_en_pbmp, port_iter){
        macd = PORT(unit, port_iter).p_mac;
        rv = MAC_CONTROL_SET(macd, unit, port_iter, SOC_MAC_CONTROL_PFC_RX_ENABLE, 1);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }
    /* 6. Refresh FLOW CONTROL XOFF state*/
    PBMP_PORT_ITER(unit, port_iter){
        rv = WRITE_FLOW_CONTROL_XOFF_STATEr(unit, port_iter, 0xff);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
        rv = WRITE_FLOW_CONTROL_XOFF_STATEr(unit, port_iter, 0);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }
    /*Wait until all EDATABUF FIFO count == 0 (Optional ?)*/
    /*7.Do IBOD reset for all ports*/
    rv = READ_IBOD_BOD_FIFO_CONTROLr(unit, &rval);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    soc_reg_field_set(unit, IBOD_BOD_FIFO_CONTROLr, &rval, BOD_SW_RST_Lf, 0);
    rv = WRITE_IBOD_BOD_FIFO_CONTROLr(unit, rval);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    soc_reg_field_set(unit, IBOD_BOD_FIFO_CONTROLr, &rval, BOD_SW_RST_Lf, 1);
    rv = WRITE_IBOD_BOD_FIFO_CONTROLr(unit, rval);
    if (BCM_FAILURE(rv)) {
        goto end;
    }

    /*8. Restore EPC  link*/
    rv = WRITE_EPC_LINK_BMAPm(unit, MEM_BLOCK_ALL, 0,&epc_lin_bmap_entry);
    if (BCM_FAILURE(rv)) {
        goto end;
    }

    if (SOC_IS_HELIX4(unit)) {
    /*9. Update txerrpkt after modules reset*/
        PBMP_ITER(PBMP_XW_ALL(unit), port) {
            rv = READ_TERRr(unit, port, &txerr);
            if (SOC_FAILURE(rv)) {
                continue;
            }
            /* coverity[overrun-local : FALSE] */
            ibod_ctrl->txerrpkt[port] = txerr;
        }
    }
    else {
        /*9. Update txerrpkt and tuflpkt after modules reset*/
        PBMP_CL_ITER(unit, port_iter){
            rv = READ_TERRr(unit, port_iter, &rval64);
            if(BCM_FAILURE(rv)) {
                goto end;
            }
            COMPILER_64_SET(ibod_ctrl->txerrpkt[port_iter],
                             COMPILER_64_HI(rval64), COMPILER_64_LO(rval64));
            rv = READ_TUFLr(unit, port_iter, &rval64);
            if(BCM_FAILURE(rv)) {
                goto end;
            }
            COMPILER_64_SET(ibod_ctrl->tuflpkt[port_iter],
                             COMPILER_64_HI(rval64), COMPILER_64_LO(rval64));
        }

        /* MAC RESET*/
        PBMP_PORT_ITER(unit, port_iter){
            SOC_IF_ERROR_RETURN(READ_XMAC_CTRLr(unit, port_iter, &rval64));
            soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, SOFT_RESETf, 1);
            rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
            if (BCM_FAILURE(rv)) {
                goto end;
            }
            soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, SOFT_RESETf, 0);
            rv = WRITE_XMAC_CTRLr(unit, port_iter, rval64);
            if (BCM_FAILURE(rv)) {
                goto end;
            }
        }
    }

    /*10.Resume ingress traffic*/
    BCM_PBMP_ITER(rx_en_pbmp, port_iter){
        macd = PORT(unit, port_iter).p_mac;
        rv = MAC_CONTROL_SET(macd, unit, port_iter, SOC_MAC_CONTROL_RX_SET, 1);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }
    /***** Resume ingress traffic End*****/

    /***** Enable software handling Start*****/
    /*1.  Enable all back ground threads to prevent any SBUS acitivities (software handling)*/
    rv = bcm_esw_linkscan_enable_set(unit, linkscan_interval);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    rv = soc_counter_start(unit, counter_flags, counter_interval, counter_pbmp);
    if (BCM_FAILURE(rv)) {
        goto end;
    }
    if (l2x_running) {
        rv = soc_l2x_start(unit, l2x_flags, l2x_interval);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }
#ifdef INCLUDE_MEM_SCAN
    if (mem_scan_running) {
        rv = soc_mem_scan_start(unit, scan_rate, scan_interval);
        if (BCM_FAILURE(rv)) {
            goto end;
        }
    }
#endif

end:
    /*2.  Enable "TX" API to prevent CPU packet from going into MMU (software handling)*/
    PBMP_PORT_ITER(unit, port_iter){
        _bcm_esw_ibod_recovery_port_unlock(unit, port_iter);
    }

    /***** Enable software handling End*****/
    time2 = SAL_USECS_SUB(sal_time_usecs(), ibod_ctrl->start_time);
    ibod_ctrl->mmu_war_count++;
    ibod_ctrl->mmu_avg_time= (ibod_ctrl->mmu_avg_time*(ibod_ctrl->mmu_war_count-1)
                                + time2 - time1) /ibod_ctrl->mmu_war_count;

    return rv;
}

STATIC int
_bcm_tr3_mmu_check_and_recovery(_port_ibod_ctrl_t *ibod_ctrl)
{
    int rv = BCM_E_NONE;
    uint32 overflow0,overflow1;
    int ibod_timeout_flag = 0;
    int txerr_timeout_flag = 0;
    int port_recovery_failed_flag = 0;
    int unit = ibod_ctrl->unit;

    overflow0 = 0;
    overflow1 = 0;

    rv = READ_PQEFIFOOVERFLOW0r(unit, &overflow0);
    if (SOC_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                   (BSL_META_U(unit, "\n Error in ibod recovery thread when reading register PQEFIFOOVERFLOW0")));
        return rv;
    }
    rv = READ_PQEFIFOOVERFLOW1r(unit, &overflow1);
    if (SOC_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                   (BSL_META_U(unit, "\n Error in ibod recovery thread when reading register PQEFIFOOVERFLOW1")));
        return rv;
    }

    _soc_egress_drain_timeout_flag_get(unit, &ibod_timeout_flag);
    txerr_timeout_flag = ibod_ctrl->drain_timeout_flag;
    port_recovery_failed_flag = ibod_ctrl->port_recovery_failed_flag;

    if ((overflow0 != 0) || (overflow1 != 0) || ibod_timeout_flag || txerr_timeout_flag
        || port_recovery_failed_flag || (_ibod_debug_flag & _PORT_IBOD_FLAG_MMU_TRIGGER)) {
        rv = _bcm_tr3_mmu_recovery(ibod_ctrl);
        if (txerr_timeout_flag) {
            ibod_ctrl->drain_timeout_flag = 0;
            ibod_ctrl->drain_timeout_count++;
        }
        if  (port_recovery_failed_flag) {
            ibod_ctrl->port_recovery_failed_flag = 0;
            ibod_ctrl->port_recovery_failed_count++;
        }
        if (ibod_timeout_flag) {
            _soc_egress_drain_timeout_flag_set(unit, 0);
            ibod_ctrl->egress_drain_timeout_count++;
        }
        if (_ibod_debug_flag & _PORT_IBOD_FLAG_MMU_TRIGGER) {
            _ibod_debug_flag &= (~_PORT_IBOD_FLAG_MMU_TRIGGER);
        }
        if (SOC_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit, "\n Error in MMU recovery ")));
        }
    }

    return rv;
}

STATIC int
_bcm_tr3_txerr_recovery_port(_port_ibod_ctrl_t *ibod_ctrl,
                                 bcm_port_t port)
{
    bcm_pbmp_t pbmp;
    uint32 rval;
    uint64 rval64, txerr, tufl, flush_enable_pbm, tmp64;
    uint64 egress_meter;
    int unit=ibod_ctrl->unit, okay=0, rv = BCM_E_NONE;
    pbmp_t      mask, mask1, mask1_restore, mask_restore;
    soc_timeout_t timeout;
    int txerr_status,tufl_status, underflow_status, lanes;
    uint32 cur_cells, new_cells, mmu_cells,credit_set;
    uint32 cdc_fifo_cells, tx_fifo_cells;
    uint32 overflow0, overflow1, total_cell;
    soc_info_t *si = &SOC_INFO(unit);
    egr_mmu_requests_entry_t mmu_entry;
    uint32 max_used_entry;
#ifdef TXERR_DEBUG
    uint64 tpkt, tfcs;
    uint32 ep_max_level = 0;
#endif
    uint32 credit, mmu_req, ep_level;
    int rx_llfc_en,rx_pfc_en,pause_rx, rx_lss, rx_lss_1;
    soc_reg_t temp_reg_id;
    static const soc_reg_t lls_port_credit_reg[] = {
        LLS_PORT_0_CREDITr, LLS_PORT_1_CREDITr, LLS_PORT_2_CREDITr,
        LLS_PORT_3_CREDITr, LLS_PORT_4_CREDITr, LLS_PORT_5_CREDITr,
        LLS_PORT_6_CREDITr, LLS_PORT_7_CREDITr, LLS_PORT_8_CREDITr,
        LLS_PORT_9_CREDITr, LLS_PORT_10_CREDITr, LLS_PORT_11_CREDITr,
        LLS_PORT_12_CREDITr, LLS_PORT_13_CREDITr, LLS_PORT_14_CREDITr,
        LLS_PORT_15_CREDITr, LLS_PORT_16_CREDITr, LLS_PORT_17_CREDITr,
        LLS_PORT_18_CREDITr, LLS_PORT_19_CREDITr, LLS_PORT_20_CREDITr,
        LLS_PORT_21_CREDITr, LLS_PORT_22_CREDITr, LLS_PORT_23_CREDITr,
        LLS_PORT_24_CREDITr, LLS_PORT_25_CREDITr, LLS_PORT_26_CREDITr,
        LLS_PORT_27_CREDITr, LLS_PORT_28_CREDITr, LLS_PORT_29_CREDITr,
        LLS_PORT_30_CREDITr, LLS_PORT_31_CREDITr, LLS_PORT_32_CREDITr,
        LLS_PORT_33_CREDITr, LLS_PORT_34_CREDITr, LLS_PORT_35_CREDITr,
        LLS_PORT_36_CREDITr, LLS_PORT_37_CREDITr, LLS_PORT_38_CREDITr,
        LLS_PORT_39_CREDITr, LLS_PORT_40_CREDITr, LLS_PORT_41_CREDITr,
        LLS_PORT_42_CREDITr, LLS_PORT_43_CREDITr, LLS_PORT_44_CREDITr,
        LLS_PORT_45_CREDITr, LLS_PORT_46_CREDITr, LLS_PORT_47_CREDITr,
        LLS_PORT_48_CREDITr, LLS_PORT_49_CREDITr, LLS_PORT_50_CREDITr,
        LLS_PORT_51_CREDITr, LLS_PORT_52_CREDITr, LLS_PORT_53_CREDITr,
        LLS_PORT_54_CREDITr, LLS_PORT_55_CREDITr, LLS_PORT_56_CREDITr,
        LLS_PORT_57_CREDITr, LLS_PORT_58_CREDITr, LLS_PORT_59_CREDITr,
        LLS_PORT_60_CREDITr, LLS_PORT_61_CREDITr, LLS_PORT_62_CREDITr
    }; 
    sal_usecs_t time1, time2;

    sal_memset(&pbmp, 0, sizeof(bcm_pbmp_t));
    SOC_IF_ERROR_RETURN(bcm_esw_port_enable_get(unit, port, &okay));
    if (okay) {
        SOC_PBMP_PORT_ADD(pbmp, port);
    } else {
        return SOC_E_NONE;
    }

    txerr_status = 0;
    /* check and update tx err counter */
    SOC_IF_ERROR_RETURN(READ_TERRr(unit, port, &txerr));
    if (COMPILER_64_NE(ibod_ctrl->txerrpkt[port], txerr)) {
       ibod_ctrl->txerrpkt[port] = txerr;
       txerr_status = 1;
    }

    tufl_status = 0;
    /* check and update tx underflow counter */
    SOC_IF_ERROR_RETURN(READ_TUFLr(unit, port, &tufl));
    if (COMPILER_64_NE(ibod_ctrl->tuflpkt[port], tufl)) {
       ibod_ctrl->tuflpkt[port] = tufl;
       tufl_status = 1;
    }
    temp_reg_id = IS_C_PORT(unit, port) ? CMAC_FIFO_STATUSr : XMAC_FIFO_STATUSr;
    BCM_IF_ERROR_RETURN(soc_reg64_get(unit, temp_reg_id, port, 0, &rval64));
    underflow_status = soc_reg64_field32_get(unit, temp_reg_id, rval64, TX_PKT_UNDERFLOWf);

    /* check tx error and tx underflow */
    if ((txerr_status == 0) && (tufl_status == 0) &&(underflow_status == 0) &&
        (txerr_trigger_flag[port] == 0)) {
        return SOC_E_NONE;
    }

    if ((txerr_status != 0) || (tufl_status != 0) || (underflow_status != 0)) {
        txerr_trigger_flag[port] = 1;
    }
    else if (txerr_trigger_flag[port] == 1) {
        txerr_trigger_flag[port] = 0;
    }

#ifdef TXERR_DEBUG
    cli_out("WAR TER Trigerred  [port %d]:txerr_status:%d, tufl_status:%d, underflow_status:%d\r\n",
            port, txerr_status,  tufl_status, underflow_status);
#endif
    rv = (soc_tr3_port_lanes_get(unit, port, &lanes));
    if (BCM_FAILURE(rv)) {
       return rv;
    }

    switch (lanes) {
    case 10: /* 100G */
        si->port_credit[port] = 108;
        break;
    case 4: /* SINGLE  */
        si->port_credit[port] = 36;
        break;
    case 2: /* DUAL */
        si->port_credit[port] = 18;
        break;
    case 1: /* QUAD */
        si->port_credit[port] = 9;
        break;
    default:
        si->port_credit[port] = 36;
        break;
    }

    time1 = SAL_USECS_SUB(sal_time_usecs(), ibod_ctrl->start_time);

    _bcm_esw_lc_lock(unit);
    soc_link_fwd_get(unit, &mask1);
    SOC_PBMP_ASSIGN(mask1_restore,mask1);
    BCM_PBMP_PORT_REMOVE(mask1,port);
    rv = soc_link_fwd_set(unit, mask1);
    if (BCM_FAILURE(rv)) {
        _bcm_esw_lc_unlock(unit);
        LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,"\n Error in setting the mask FWD"
                                 " for WAR on port %s"), SOC_PORT_NAME(unit,port)));
        return BCM_E_NONE;
    }

    PORT_LOCK(unit);
    _bcm_esw_ibod_recovery_port_lock(unit, port);

    /* move port from EPC_LINK_BMAP */
    soc_link_mask2_get(unit, &mask);
    SOC_PBMP_ASSIGN(mask_restore,mask);
    BCM_PBMP_PORT_REMOVE(mask,port);
    rv = soc_link_mask2_set(unit, mask);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    temp_reg_id = IS_C_PORT(unit, port) ? CMAC_PAUSE_CTRLr : XMAC_PAUSE_CTRLr;
    rv = soc_reg64_get(unit, temp_reg_id, port, 0, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    pause_rx = soc_reg64_field32_get(unit, temp_reg_id, rval64, RX_PAUSE_ENf);
    soc_reg64_field32_set(unit, temp_reg_id, &rval64, RX_PAUSE_ENf, 0);
    rv = soc_reg64_set(unit, temp_reg_id, port, 0, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    temp_reg_id = IS_C_PORT(unit, port) ? CMAC_PFC_CTRLr : XMAC_PFC_CTRLr;
    rv = soc_reg64_get(unit, temp_reg_id, port, 0, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    rx_pfc_en = soc_reg64_field32_get(unit, temp_reg_id, rval64, RX_PFC_ENf);
    soc_reg64_field32_set(unit, temp_reg_id, &rval64, RX_PFC_ENf, 0);
    rv = soc_reg64_set(unit, temp_reg_id, port, 0, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    temp_reg_id = IS_C_PORT(unit, port) ? CMAC_LLFC_CTRLr : XMAC_LLFC_CTRLr;
    rv = soc_reg64_get(unit, temp_reg_id, port, 0, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    rx_llfc_en = soc_reg64_field32_get(unit, temp_reg_id, rval64, RX_LLFC_ENf);
    soc_reg64_field32_set(unit, temp_reg_id, &rval64, RX_LLFC_ENf, 0);
    rv = soc_reg64_set(unit, temp_reg_id, port, 0, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_EGRMETERINGCONFIG_64r(unit, port, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    egress_meter = rval64;
    COMPILER_64_ZERO(tmp64);
    rv = WRITE_EGRMETERINGCONFIG_64r(unit, port, tmp64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    temp_reg_id = IS_C_PORT(unit, port) ? CMAC_RX_LSS_CTRLr : XMAC_RX_LSS_CTRLr;
    rv = soc_reg64_get(unit, temp_reg_id, port, 0, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    rx_lss = soc_reg64_field32_get(unit, temp_reg_id, rval64,
                                   DROP_TX_DATA_ON_LOCAL_FAULTf);
    rx_lss_1 = soc_reg64_field32_get(unit, temp_reg_id, rval64,
                                   DROP_TX_DATA_ON_REMOTE_FAULTf);
    soc_reg64_field32_set(unit, temp_reg_id, &rval64, DROP_TX_DATA_ON_LOCAL_FAULTf, 1);
    soc_reg64_field32_set(unit, temp_reg_id, &rval64, DROP_TX_DATA_ON_REMOTE_FAULTf, 1);
    rv = soc_reg64_set(unit, temp_reg_id, port, 0, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_MCQ_IPMC_FAST_FLUSHr(unit, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    COMPILER_64_SET(flush_enable_pbm, pbmp.pbits[1], pbmp.pbits[0]);
    soc_reg64_field_set(unit, MCQ_IPMC_FAST_FLUSHr, &rval64, ENABLEf, flush_enable_pbm);
    rv = WRITE_MCQ_IPMC_FAST_FLUSHr(unit, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    /* drop packets */
    rv = READ_PORT_TXFIFO_PKT_DROP_CTLr(unit, port, &rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg_field_set(unit, PORT_TXFIFO_PKT_DROP_CTLr, &rval, DROP_ENf, 1);
    rv = WRITE_PORT_TXFIFO_PKT_DROP_CTLr(unit, port, rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    cur_cells = 0xffffffff;
    soc_timeout_init(&timeout, 30000, 0);

    while(1) {
#ifdef TXERR_DEBUG
        /* check epc_link_bmap for debug */
        pbmp_t  pbm;
        epc_link_bmap_entry_t entry;
        READ_EPC_LINK_BMAPm(unit, MEM_BLOCK_ALL, 0,&entry);
        soc_mem_pbmp_field_get(unit, EPC_LINK_BMAPm, &entry, PORT_BITMAPf, &pbm);
        if (SOC_PBMP_MEMBER(pbm, port)) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit, "TXERR recovery:uint %d port %d still in epc link bitmap 0x%x\r\n"),
                      unit, port, pbm.pbits[0]));
        }
#endif
        new_cells=0;

        /*1. check MMU cell */
        rv = READ_OP_PORT_TOTAL_COUNT_CELLr(unit, port, &rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        mmu_cells = soc_reg_field_get(unit, OP_PORT_TOTAL_COUNT_CELLr,rval, TOTAL_COUNTf);
        new_cells += mmu_cells;

        /*2. check port CDC fifo */
        rv = READ_PORT_CDC_TXFIFO_CELL_CNTr(unit, port, &rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        cdc_fifo_cells = soc_reg_field_get(unit, PORT_CDC_TXFIFO_CELL_CNTr, rval, CELL_CNTf);
        new_cells += cdc_fifo_cells;

        /*3. check port tx fifo */
        rv = READ_PORT_TXFIFO_CELL_CNTr(unit, port, &rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        tx_fifo_cells = soc_reg_field_get(unit, PORT_TXFIFO_CELL_CNTr, rval, CELL_CNTf);
        new_cells += tx_fifo_cells;

        /* read MMU credit */
        rv = soc_reg32_get(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port]]], REG_PORT_ANY, 0, &credit);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

        rv = soc_mem_read(unit, EGR_MMU_REQUESTSm, MEM_BLOCK_ANY, si->port_l2p_mapping[port], &mmu_entry);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        mmu_req = soc_mem_field32_get(unit, EGR_MMU_REQUESTSm, &mmu_entry, OUTSTANDING_MMU_REQUESTSf);

        /* read EP level */
        rv = READ_EGR_EDB_MISC_CTRLr(unit, &rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        soc_reg_field_set(unit, EGR_EDB_MISC_CTRLr, &rval, SELECT_CURRENT_USED_ENTRIESf, 1);
        rv = WRITE_EGR_EDB_MISC_CTRLr(unit, rval);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        rv = READ_EGR_MAX_USED_ENTRIESm(unit, MEM_BLOCK_ALL, si->port_l2p_mapping[port], &max_used_entry);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        ep_level = soc_mem_field32_get(unit, EGR_MAX_USED_ENTRIESm, &max_used_entry, LEVELf);

        /* Update cur_cells and give more time to drain packets.  */
        if (new_cells < cur_cells) {
            soc_timeout_init(&timeout, 30000, 0);
            cur_cells = new_cells;
        }
        else {
#ifdef TXERR_DEBUG
            cli_out("TXERR reovery: mmu cells not draining 1: %d cells remain,cur_cells %d, mmu_cells %d, level %d, credit %d mmu_req %d \r\n",
                     new_cells, cur_cells, mmu_cells, ep_level, credit, mmu_req);
#endif
            rv = soc_reg32_set(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port]]], REG_PORT_ANY, 0, si->port_credit[port]);
            TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        }

        if (soc_timeout_check(&timeout)) {
            if(ep_level == 0) {
                ibod_ctrl->drain_timeout_flag = 1;
            }
            else {
                rv = READ_PQEFIFOOVERFLOW0r(unit, &overflow0);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                rv = READ_PQEFIFOOVERFLOW1r(unit, &overflow1);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                rv = READ_OP_PORT_TOTAL_COUNT_CELLr(unit,port, &total_cell);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                LOG_ERROR(BSL_LS_BCM_PORT,
                          (BSL_META_U(unit, "\n TXERR recovery Timeout Drain packets %d PORT: %s, "
                            "ep_level:%d, overflow0:%d, overflow1:%d total_cell %d "
                            "credit %d mmu_req %d \n"),
                            ibod_ctrl->unit, SOC_PORT_NAME(unit,port), ep_level, overflow0,
                            overflow1, total_cell, credit, mmu_req));
            }
            break;
        }
#ifdef TXERR_DEBUG
        /* for debug */
        uint32 mmu_req_1;

        rv = soc_mem_read(unit, EGR_MMU_REQUESTSm, MEM_BLOCK_ANY, si->port_l2p_mapping[port], &mmu_entry);
        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        mmu_req_1 = soc_mem_field32_get(unit, EGR_MMU_REQUESTSm, &mmu_entry, OUTSTANDING_MMU_REQUESTSf);
        if(mmu_req_1 != mmu_req){
            cli_out("TXERR recovery: credit %d mmu_req %d is not equal mmu_req_1 %d  !!!!!\r\n",credit, mmu_req, mmu_req_1);

        }
#endif
        /* All packets were drained */
        if (new_cells == 0) {
            if (_soc_egress_drain_credit_calc(credit, si->port_credit[port], mmu_req, ep_level, &credit_set)) {
                rv = soc_reg32_set(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port]]], REG_PORT_ANY, 0, credit_set);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
            }
#ifdef TXERR_DEBUG
            rv = _soc_egress_drain_ep_max_level_get(unit, port, &ep_max_level);
            if(rv == BCM_E_NONE)
            {
                 cli_out("TXERR recovery: MacDrainOK max_level %d  !!!!!\r\n", ep_max_level);
            }

            rv = READ_TPKTr(unit, port, &tpkt);
            TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
            rv = READ_TFCSr(unit, port, &tfcs);
            TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

            cli_out("TXERR recovery: MacDrainOK credit = %d, Port:%d, tpkt:%lld, tfcs=%lld\r\n",  credit, port, tpkt, tfcs);
#endif
            rv = soc_reg32_get(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port]]], REG_PORT_ANY, 0, &credit);
            TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
            if(credit == 0) {
                rv = soc_reg32_set(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port]]],
                    REG_PORT_ANY, 0, si->port_credit[port]);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
            }
            break;
        }
        else if (mmu_cells){  /* some packets still stay in MMU */
            if((credit == 0)) {
                rv = soc_reg32_get(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port]]], REG_PORT_ANY, 0, &credit);
                TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                if(credit == 0) {
                    rv = soc_mem_read(unit, EGR_MMU_REQUESTSm, MEM_BLOCK_ANY, si->port_l2p_mapping[port], &mmu_entry);
                    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                    mmu_req = soc_mem_field32_get(unit, EGR_MMU_REQUESTSm, &mmu_entry, OUTSTANDING_MMU_REQUESTSf);

                    if (_soc_egress_drain_credit_calc(credit, si->port_credit[port], mmu_req, ep_level, &credit_set)) {
                        rv = soc_reg32_set(unit,lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port]]], REG_PORT_ANY, 0, credit_set);
                        TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
                    }
                }
                else {
#ifdef TXERR_DEBUG
                    _soc_egress_drain_debug(unit, port, lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port]]]);
#endif
                }
            }
            else {
#ifdef TXERR_DEBUG
                _soc_egress_drain_debug(unit, port, lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port]]]);
#endif
            }
        }
    }

    temp_reg_id = IS_C_PORT(unit, port) ? CMAC_CLEAR_FIFO_STATUSr : XMAC_CLEAR_FIFO_STATUSr;
    rv = soc_reg64_get(unit, temp_reg_id, port, 0, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg64_field32_set(unit, temp_reg_id, &rval64, CLEAR_TX_PKT_UNDERFLOWf, 1);
    rv = soc_reg64_set(unit, temp_reg_id, port, 0, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = soc_reg64_get(unit, temp_reg_id, port, 0, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg64_field32_set(unit, temp_reg_id, &rval64, CLEAR_TX_PKT_UNDERFLOWf, 0);
    rv = soc_reg64_set(unit, temp_reg_id, port, 0, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = WRITE_EGRMETERINGCONFIG_64r(unit, port, egress_meter);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_PORT_TXFIFO_PKT_DROP_CTLr(unit, port, &rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg_field_set(unit, PORT_TXFIFO_PKT_DROP_CTLr, &rval, DROP_ENf, 0);
    rv = WRITE_PORT_TXFIFO_PKT_DROP_CTLr(unit, port, rval);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_MCQ_IPMC_FAST_FLUSHr(unit, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg64_field32_set(unit, MCQ_IPMC_FAST_FLUSHr, &rval64, ENABLEf, 0);
    rv = WRITE_MCQ_IPMC_FAST_FLUSHr(unit, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    temp_reg_id = IS_C_PORT(unit, port) ? CMAC_RX_LSS_CTRLr : XMAC_RX_LSS_CTRLr;
    rv = soc_reg64_get(unit, temp_reg_id, port, 0, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg64_field32_set(unit, temp_reg_id, &rval64, DROP_TX_DATA_ON_LOCAL_FAULTf, rx_lss);
    soc_reg64_field32_set(unit, temp_reg_id, &rval64, DROP_TX_DATA_ON_REMOTE_FAULTf, rx_lss_1);
    rv = soc_reg64_set(unit, temp_reg_id, port, 0, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    temp_reg_id = IS_C_PORT(unit, port) ? CMAC_PAUSE_CTRLr : XMAC_PAUSE_CTRLr;
    rv = soc_reg64_get(unit, temp_reg_id, port, 0, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg64_field32_set(unit, temp_reg_id, &rval64, RX_PAUSE_ENf, pause_rx);
    rv = soc_reg64_set(unit, temp_reg_id, port, 0, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    temp_reg_id = IS_C_PORT(unit, port) ? CMAC_PFC_CTRLr : XMAC_PFC_CTRLr;
    rv = soc_reg64_get(unit, temp_reg_id, port, 0, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg64_field32_set(unit, temp_reg_id, &rval64, RX_PFC_ENf, rx_pfc_en);
    rv = soc_reg64_set(unit, temp_reg_id, port, 0, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    temp_reg_id = IS_C_PORT(unit, port) ? CMAC_LLFC_CTRLr : XMAC_LLFC_CTRLr;
    rv = soc_reg64_get(unit, temp_reg_id, port, 0, &rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    soc_reg64_field32_set(unit, temp_reg_id, &rval64, RX_LLFC_ENf, rx_llfc_en);
    rv = soc_reg64_set(unit, temp_reg_id, port, 0, rval64);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    /* restore port from EPC_LINK_BMAP */
    rv = soc_link_mask2_set(unit, mask_restore);
    TXERR_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    _bcm_esw_ibod_recovery_port_unlock(unit, port);
    PORT_UNLOCK(unit);
    rv = soc_link_fwd_set(unit, mask1_restore);
    if (BCM_FAILURE(rv)) {
        _bcm_esw_lc_unlock(unit);
        LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,"\n Error in re-setting the mask FWD"
                                 " for WAR on port %s"), SOC_PORT_NAME(unit,port)));
        return BCM_E_NONE;
    }

    _bcm_esw_lc_unlock(unit);

    time2 = SAL_USECS_SUB(sal_time_usecs(), ibod_ctrl->start_time);
    ibod_ctrl->txerr_count++;
    ibod_ctrl->txerr_avg_time = (ibod_ctrl->txerr_avg_time*(ibod_ctrl->txerr_count-1) +
            time2 - time1) /ibod_ctrl->txerr_count;

    return SOC_E_NONE;
}

STATIC int
_bcm_tr3_ibod_port_check(
_port_ibod_ctrl_t *ibod_ctrl, bcm_port_t port, int *need_recovery)
{
    int rv, unit = ibod_ctrl->unit;
    uint64 rrpkt, rrbyt;
    uint64 rrpkt_diff, rrbyt_diff;
    uint64 rval64;
    int runt_threshold;

    /* Only check HG port */
    if (!IS_HG_PORT(unit, port)) {
        return BCM_E_NONE;
    }

    /* Check if any new runt packet logged in RRPKT */
    rv = READ_RRPKTr(unit, port, &rrpkt);
    if (SOC_FAILURE(rv)) {
        return BCM_E_FAIL;
    }
    if (COMPILER_64_EQ(rrpkt, ibod_ctrl->rrpkt[port])) {
        return BCM_E_NONE;
    }

    /* Check total runt byte count */
    rv = READ_RRBYTr(unit, port, &rrbyt);
    if (SOC_FAILURE(rv)) {
        return BCM_E_FAIL;
    }

    /* It's very unlikely both packet and byte counters wrap around
               * and stop at 0, the code assume this is from clear counter */
    if (COMPILER_64_IS_ZERO(rrpkt) && COMPILER_64_IS_ZERO(rrbyt)) {
        ibod_ctrl->rrpkt_old[port] = ibod_ctrl->rrpkt[port];
        ibod_ctrl->rrbyt_old[port] = ibod_ctrl->rrbyt[port];
        ibod_ctrl->rrpkt[port] = rrpkt;
        ibod_ctrl->rrbyt[port] = rrbyt;
        return BCM_E_NONE;
    }

    rrpkt_diff = rrpkt;
    rrbyt_diff = rrbyt;
    COMPILER_64_SUB_64(rrpkt_diff, ibod_ctrl->rrpkt[port]);
    COMPILER_64_SUB_64(rrbyt_diff, ibod_ctrl->rrbyt[port]);
    ibod_ctrl->rrpkt_old[port] = ibod_ctrl->rrpkt[port];
    ibod_ctrl->rrbyt_old[port] = ibod_ctrl->rrbyt[port];
    ibod_ctrl->rrpkt[port] = rrpkt;
    ibod_ctrl->rrbyt[port] = rrbyt;
#ifdef IBOD_DEBUG
    cli_out("WAR IBOD Check [port %d] rrbyt %lld rrpkt %lld, rrpkt_diff %lld rrbyt_diff %lld\r\n",
            port, ibod_ctrl->rrbyt[port], ibod_ctrl->rrpkt[port], rrpkt_diff, rrbyt_diff);
#endif
    rv = READ_XMAC_RX_CTRLr(unit,port, &rval64);
    if (SOC_FAILURE(rv)) {
        return BCM_E_FAIL;
    }

    runt_threshold = soc_reg64_field32_get(unit, XMAC_RX_CTRLr, rval64, RUNT_THRESHOLDf);

    /* Recovery is needed only for packet size between 33 and threshold */
    if (COMPILER_64_HI(rrpkt_diff) == 0 &&
        COMPILER_64_LO(rrpkt_diff) == 1) {
        if (COMPILER_64_LO(rrbyt_diff) >= runt_threshold) {
            return BCM_E_NONE;
        }
    }
    if (COMPILER_64_HI(rrbyt_diff) == 0 &&
        COMPILER_64_LO(rrbyt_diff) <= 32) {
        return BCM_E_NONE;
    }

    *need_recovery = TRUE;

    return BCM_E_NONE;
}

STATIC int
_bcm_tr3_ibod_sync_recovery_port(_port_ibod_ctrl_t *ibod_ctrl, int port_set,
                                 bcm_port_t port)
{
    int idx, fifo_len, send_time;
    int rv = BCM_E_NONE;
    int rv1 = BCM_E_NONE;
    int enable, tdm_length;
    uint64 rrpkt, rrbyt;
    uint64 rpkt, tpkt;
    pbmp_t  pbm;
    epc_link_bmap_entry_t entry;
    int lanes, unit = ibod_ctrl->unit;
    soc_info_t *si = &SOC_INFO(unit);
    int phy_port = SOC_INFO(unit).port_l2p_mapping[port];
    uint32 *tdm_array;
    int port_dis_tag=0, port_dis_untag=0;
    bcm_pkt_t *pkt = &ibod_ctrl->pkt;
    SHR_BITDCLNAME(used_bmp, TR3_IARB_TDM_TABLE_LENGTH);
    uint32 _tdm_array_hw[380] = {-1};
    int pause_tx, pause_rx, pfc_rx, llfc_rx;
    iarb_tdm_table_entry_t new_entry;
    uint32 rval;
    pbmp_t mask, mask1, mask1_restore;
    int ibod_data_fifo_full_intr_status = 0;
    soc_field_t cl_data_fifo_full_err_intr_status = 0;
    soc_field_t cl_ctrl_fifo_full_err_intr_status = 0;
#ifdef IBOD_DEBUG
    uint64 rpkt, tpkt;
    uint64 rpkt_fin, tpkt_fin, rrpkt_fin, rrbyt_fin;
#endif

    phy_port = SOC_INFO(unit).port_l2p_mapping[port];
    rv = (soc_tr3_port_lanes_get(unit, port, &lanes));
    if (BCM_FAILURE(rv)) {
       return rv;
    }

    switch (lanes) {
    case 10: /* 100G */
        fifo_len = 34;
        si->port_credit[port] = 108;
        break;
    case 4: /* SINGLE  */
        fifo_len = 34;
        si->port_credit[port] = 36;
        break;
    case 2: /* DUAL */
        fifo_len = 34;
        si->port_credit[port] = 18;
        break;
    case 1: /* QUAD */
        fifo_len = 34;
        si->port_credit[port] = 9;
        break;
    default:
        fifo_len = 34;
        si->port_credit[port] = 36;
        break;
    }

    
    if ((phy_port >= 53)  && (phy_port <= 64 )){
        cl_data_fifo_full_err_intr_status = CL0_DATA_FIFO_FULL_ERR_INTR_STATUSf;
        cl_ctrl_fifo_full_err_intr_status = CL0_CTRL_FIFO_FULL_ERR_INTR_STATUSf;
    }
    else if ((phy_port >= 69) && (phy_port <= 80)) {
        cl_data_fifo_full_err_intr_status = CL1_DATA_FIFO_FULL_ERR_INTR_STATUSf;
        cl_ctrl_fifo_full_err_intr_status = CL1_CTRL_FIFO_FULL_ERR_INTR_STATUSf;
    }
    else {
        LOG_ERROR(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit, "IBOD port:%d is not CL port\n\r"), port));
        return BCM_E_PORT;
    }
    fifo_len = soc_property_get(unit, "ibod_fifo_len", fifo_len);

    soc_link_fwd_get(unit, &mask1);
    SOC_PBMP_ASSIGN(mask1_restore,mask1);
    BCM_PBMP_PORT_REMOVE(mask1,port);
    rv = soc_link_fwd_set(unit, mask1);
    if (BCM_FAILURE(rv)) {
       LOG_ERROR(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit,
                  "IBOD Link fwd set failed[%d] on port:%d\n\r"),
                  rv, port));
       return rv;
    }

    PORT_LOCK(unit); /* Begin port atomic */
    _bcm_esw_ibod_recovery_port_lock(unit, port);
    soc_ibod_recovery_in_progress_set(unit, 1);

    if (port_set == 0) {
        soc_link_mask2_get(unit, &mask);
        rv = bcm_esw_port_enable_get(unit, port, &enable);
        IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        /* port is disabled */
        if ((enable == 0) || !SOC_PBMP_MEMBER(mask, port)) {
            soc_ibod_recovery_in_progress_set(unit, 0);
            _bcm_esw_ibod_recovery_port_unlock(unit, port);
            PORT_UNLOCK(unit);
            rv = soc_link_fwd_set(unit, mask1_restore);
            /*
             *  Since the recovery is not run when the port is down the
             *  rrpkt is updated back to the original value, as the
             *  recovery will happen when the port is up
             */
            ibod_ctrl->rrpkt[port] = ibod_ctrl->rrpkt_old[port];
            ibod_ctrl->rrbyt[port] = ibod_ctrl->rrbyt_old[port];
            LOG_INFO(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "Skip ibod sync war if port %d is disabled %d.\n"),
                                  port, enable));
            return rv;
        }
    }

    /* Isolate port */
    rv = _bcm_tr3_ibod_port_isolate(unit, port_set, port, &port_dis_untag, &port_dis_tag);
    if (BCM_FAILURE(rv)) {
        soc_ibod_recovery_in_progress_set(unit, 0);
        _bcm_esw_ibod_recovery_port_unlock(unit, port);
        PORT_UNLOCK(unit);
        rv1 = soc_link_fwd_set(unit, mask1_restore);
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit, "IBOD port(%d) isolate Failed[%d %d]\n\r"),
                   port, rv, rv1));
        return rv;
    }

    sal_memset(&used_bmp, 0, sizeof(used_bmp));

    /* Remove the port from IARB_TDM_TABLE */
    tdm_length = _soc_tr3_tdm_size;
    for (idx = 0; idx < _soc_tr3_tdm_size; idx++) {
        /*    coverity[unchecked_value]    */
        (void)soc_mem_read(unit, IARB_TDM_TABLEm, MEM_BLOCK_ALL, idx,&new_entry);
        _tdm_array_hw[idx] =
              soc_mem_field32_get(unit, IARB_TDM_TABLEm, &new_entry, PORT_NUMf);
    }
    tdm_array = _tdm_array_hw;

    sal_memset(&new_entry, 0, sizeof(iarb_tdm_table_entry_t));
    soc_mem_field32_set(unit, IARB_TDM_TABLEm, &new_entry, PORT_NUMf, 127);
    for (idx = 0; idx < _soc_tr3_tdm_size; idx++) {
        if (tdm_array[idx] != phy_port) {
            continue;
        }
        (void)soc_mem_write(unit, IARB_TDM_TABLEm, MEM_BLOCK_ALL, idx,
                            &new_entry);
        SHR_BITSET(used_bmp, idx);
    }
    sal_udelay(10000);

    /* Disable pause/pfc/llfc function */
    rv = soc_mac_x.md_pause_get(unit, port, &pause_tx, &pause_rx);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = soc_mac_x.md_pause_set(unit, port, 0, 0);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = soc_mac_x.md_control_get(unit, port, SOC_MAC_CONTROL_PFC_RX_ENABLE, &pfc_rx);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = soc_mac_x.md_control_set(unit, port, SOC_MAC_CONTROL_PFC_RX_ENABLE, 0);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = soc_mac_x.md_control_get(unit, port, SOC_MAC_CONTROL_LLFC_RX_ENABLE,&llfc_rx);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = soc_mac_x.md_control_set(unit, port, SOC_MAC_CONTROL_LLFC_RX_ENABLE,0);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    /* check epc_link_bmap */
    /* coverity[check_return] */
    READ_EPC_LINK_BMAPm(unit, MEM_BLOCK_ALL, 0,&entry);
    soc_mem_pbmp_field_get(unit, EPC_LINK_BMAPm, &entry, PORT_BITMAPf, &pbm);
    if (SOC_PBMP_MEMBER(pbm, port)) {
        LOG_WARN(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit, "uint %d port %d still in epc link bitmap 0x%x\r\n"),
                   unit, port, pbm.pbits[0]));
    }

    rv = READ_RRBYTr(unit, port, &rrbyt);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_RRPKTr(unit, port, &rrpkt);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_RPKTr(unit, port, &rpkt);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    rv = READ_TPKTr(unit, port, &tpkt);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
#ifdef IBOD_DEBUG
    cli_out("WAR Trigerred IBOD recovery [port %d] enable %d orign rrbyt %lld rrpkt %lld rpkt %lld tpkt %lld\r\n",
        port, port_set, rrbyt, rrpkt, rpkt, tpkt );
#endif
    send_time = 0;

    /* send loopback packets untill fifo full error occurred. */
    do {
        /* Send 80-byte packets to fill IBOD FIFO */
        for (idx = 0; idx < fifo_len; idx++) {
            BCM_PKT_TX_LEN_SET(pkt, 68);
            BCM_PKT_PORT_SET(pkt, port, TRUE, FALSE);
            BCM_PKT_HGHDR_REQUIRE(pkt);
            rv = bcm_common_tx(unit, pkt, NULL);
            if (BCM_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                          (BSL_META_U(unit, "IBOD 80-byte packet transmit"
                           " failed[%d] on port:%d, send_time:%d\n\r"), rv, port, send_time));
                ibod_ctrl->port_recovery_failed_flag = 1;
                break;
            }
        }
        if (ibod_ctrl->port_recovery_failed_flag) {
            break;
        }

        send_time ++;
        rv = READ_IBOD_INTR_STATUSr(unit, &rval);
        IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
        ibod_data_fifo_full_intr_status = soc_reg_field_get(unit, IBOD_INTR_STATUSr,
             rval, cl_data_fifo_full_err_intr_status);
#ifdef IBOD_DEBUG
        if (!ibod_data_fifo_full_intr_status){
            cli_out("%s IBOD intr data fifo full err status is 0 !!!!!!!%d\r\n",
            (cl_data_fifo_full_err_intr_status == CL0_DATA_FIFO_FULL_ERR_INTR_STATUSf)?"CL0":"CL1", ibod_data_fifo_full_intr_status);
        }
#endif

        if (send_time >= 5) {
#ifdef IBOD_DEBUG
            int lb = 0;
            MAC_LOOPBACK_GET(PORT(unit, port).p_mac, unit, port, &lb);

            rv = READ_RPKTr(unit, port, &rpkt_fin);
            IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
            rv = READ_TPKTr(unit, port, &tpkt_fin);
            IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

            LOG_ERROR(BSL_LS_BCM_PORT, (BSL_META_U(unit,"\n IBOD recovery (unit %d PORT: %s) fill IBOD FIFO full failed: rpkt_fin %lld tpkt_fin %lld loopback %d\r\n"),
                      ibod_ctrl->unit, SOC_PORT_NAME(unit,port),rpkt_fin,tpkt_fin, lb));
#else
            LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit,"\n IBOD recovery (unit %d PORT: %s) fill IBOD FIFO full failed\r\n"),
                  unit, SOC_PORT_NAME(unit,port)));
#endif
           ibod_ctrl->port_recovery_failed_flag = 1;
           break;
        }
    }while (ibod_data_fifo_full_intr_status == 0);

#ifdef IBOD_DEBUG
    rv = READ_RRBYTr(unit, port, &rrbyt);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_RRPKTr(unit, port, &rrpkt);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_RPKTr(unit, port, &rpkt_fin);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = READ_TPKTr(unit, port, &tpkt_fin);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    cli_out("WAR Trigerred IBOD recovery [port %d] normal rrbyt %lld rrpkt %lld rpkt_fin %lld tpkt_fin %lld send_time %d\r\n",
        port, rrbyt, rrpkt, rpkt_fin,tpkt_fin, send_time);
    if((rpkt_fin - rpkt) != fifo_len * send_time ) {
        cli_out("IBOD recovery loopback regular counter is not right!!!!!!! \r\n");
        if((rpkt_fin - rpkt) < fifo_len * send_time ) {
            cli_out("IBOD recovery loopback regular counter is less than tx!!!!!!!! \r\n");
        }
    }
#endif
    /* Restore IARB_TDM_TABLE */
    soc_mem_field32_set(unit, IARB_TDM_TABLEm, &new_entry, PORT_NUMf,
                        phy_port);
    for (idx = 0; idx < tdm_length; idx++) {
        if (!SHR_BITGET(used_bmp, idx)) {
            continue;
        }
        (void)soc_mem_write(unit, IARB_TDM_TABLEm, MEM_BLOCK_ALL, idx,
                            &new_entry);
    }

    for (idx = 0; idx < tdm_length; idx++) {
        if (tdm_array[idx] != phy_port) {
            continue;
        }
#ifdef IBOD_DEBUG
        (void)soc_mem_read(unit, IARB_TDM_TABLEm, MEM_BLOCK_ALL, idx,&new_entry);
        _tdm_array_hw[idx] = soc_mem_field32_get(unit, IARB_TDM_TABLEm, &new_entry, PORT_NUMf);
        if(_tdm_array_hw[idx] != phy_port){
            cli_out("IBOD IARB TDM port number idx %d _tdm_array_hw[idx] %d !!!!!!\r\n",idx, _tdm_array_hw[idx]);
        }
#endif
    }
    /* waiting for IARB_TDM_TABLE ready */
    sal_udelay(30000);
    /* Send 72-byte RUNT packet */
    if (BCM_SUCCESS(rv)) {
        BCM_PKT_TX_LEN_SET(pkt, 60);
        BCM_PKT_PORT_SET(pkt, port, TRUE, FALSE);
        rv = bcm_common_tx(unit, pkt, NULL);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                       "IBOD Runt Pkt transmit failed[%d] on port:%d\n\r"),
                       rv, port));
            ibod_ctrl->port_recovery_failed_flag = 1;
        }
    }

#ifdef IBOD_DEBUG
    rv = READ_RRPKTr(unit, port, &rrpkt_fin);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    rv = READ_RRBYTr(unit, port, &rrbyt_fin);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    rv = READ_RPKTr(unit, port, &rpkt_fin);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    rv = READ_TPKTr(unit, port, &tpkt_fin);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    cli_out("recovery runt rrbyt_fin %lld rrpkt_fin %lld rpkt_fin %lld tpkt_fin %lld\r\n",rrbyt_fin, rrpkt_fin,
    rpkt_fin, tpkt_fin);

    if((rrpkt_fin - rrpkt) != 1 ) {
        cli_out("IBOD recovery loopback runt counter is not right!!!! \r\n");
    }
#endif
    /* Update ibod_ctrl rrbyt and rrpkt */
    rv = READ_RRPKTr(unit, port, &rrpkt);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    rv = READ_RRBYTr(unit, port, &rrbyt);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    ibod_ctrl->rrpkt[port] = rrpkt;
    ibod_ctrl->rrbyt[port] = rrbyt;

    /* Restore original pause/pfc/llfc configuration */
    rv = soc_mac_x.md_pause_set(unit, port, pause_tx, pause_rx);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    rv = soc_mac_x.md_control_set(unit, port, SOC_MAC_CONTROL_PFC_RX_ENABLE, pfc_rx);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    rv = soc_mac_x.md_control_set(unit, port, SOC_MAC_CONTROL_LLFC_RX_ENABLE,llfc_rx);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);

    /* clear and check IBOD FIFO full interrupt */
    rv = READ_IBOD_INTR_STATUSr(unit, &rval);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
    ibod_data_fifo_full_intr_status = soc_reg_field_get(unit, IBOD_INTR_STATUSr,
         rval, cl_data_fifo_full_err_intr_status);
    soc_reg_field_set(unit, IBOD_INTR_STATUSr,
         &rval, cl_data_fifo_full_err_intr_status, 1);
    soc_reg_field_set(unit, IBOD_INTR_STATUSr,
         &rval, cl_ctrl_fifo_full_err_intr_status, 1);
    rv = WRITE_IBOD_INTR_STATUSr(unit, rval);
    IBOD_IF_ERROR_RETURN_UNLOCK(unit, port, rv);
#ifdef IBOD_DEBUG
    READ_IBOD_INTR_STATUSr(unit, &rval);
    ibod_data_fifo_full_intr_status = soc_reg_field_get(unit, IBOD_INTR_STATUSr,
         rval, cl_data_fifo_full_err_intr_status);
    cli_out("after set. %s IBOD intr data fifo full err status %d\r\n",
        (cl_data_fifo_full_err_intr_status == CL0_DATA_FIFO_FULL_ERR_INTR_STATUSf)?"CL0":"CL1", ibod_data_fifo_full_intr_status);
#endif
    /* Restore port operation */
    rv = _bcm_tr3_ibod_port_resume(unit, port, port_dis_untag, port_dis_tag);
    if (BCM_FAILURE(rv)) {
        soc_ibod_recovery_in_progress_set(unit, 0);
        _bcm_esw_ibod_recovery_port_unlock(unit, port);
        PORT_UNLOCK(unit);
        rv1 = soc_link_fwd_set(unit, mask1_restore);
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit,
                  "IBOD Port[%d] Resume failed[%d %d]\n\r"), port, rv, rv1));
        return rv;
    }

    soc_ibod_recovery_in_progress_set(unit, 0);
    _bcm_esw_ibod_recovery_port_unlock(unit, port);
    PORT_UNLOCK(unit); /* End port atomic */

    rv = soc_link_fwd_set(unit, mask1_restore);
    if (BCM_FAILURE(rv)) {
       LOG_ERROR(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit,
                 "IBOD link fwd set failed[%d] on port:%d\n\r"), rv, port));
       return rv;
    }

    return rv;
}

STATIC int
_bcm_tr3_ibod_recovery_port(_port_ibod_ctrl_t *ibod_ctrl, bcm_port_t port)
{
    int rv = BCM_E_NONE;
    int need_recovery = FALSE;
    sal_usecs_t time1, time2;

    /* Check and update runt counter */
    rv = _bcm_tr3_ibod_port_check(ibod_ctrl, port, &need_recovery);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(ibod_ctrl->unit,
                                  "Ibod recovery port %d check error\n"), port));
       return rv;
    }
    else if(need_recovery == FALSE){
        return BCM_E_NONE;
    }

    time1 = SAL_USECS_SUB(sal_time_usecs(), ibod_ctrl->start_time);

    rv = _bcm_tr3_ibod_sync_recovery_port(ibod_ctrl, 0, port);

    time2 = SAL_USECS_SUB(sal_time_usecs(), ibod_ctrl->start_time);
    ibod_ctrl->event_count++;
    ibod_ctrl->port_avg_time = (ibod_ctrl->port_avg_time*(ibod_ctrl->event_count-1) +
            time2 - time1) /ibod_ctrl->event_count;

    return rv;
}

STATIC void
_bcm_tr3_ibod_sync_recovery_thread(void *context)
{
    _port_ibod_ctrl_t *ibod_ctrl = context;
    int port, rv, unit = ibod_ctrl->unit;

    LOG_VERBOSE(BSL_LS_BCM_PORT,
                (BSL_META_U(unit,
                            "IBOD recovery started on unit %d\n"), ibod_ctrl->unit));

    ibod_ctrl->running = 1;
    while (!ibod_ctrl->stop) {
        if (!SOC_IS_DONE_INIT(unit)) {
            (void)sal_sem_take(ibod_ctrl->sema, ibod_ctrl->interval);
            continue;
        }
        /* Need to wait until warmboot recovery of ibod related stats is done */
        if (!SOC_WARM_BOOT(unit)) {
            PBMP_CL_ITER(unit, port) {
                if (SOC_PBMP_MEMBER(SOC_PORT_DISABLED_BITMAP(unit,all), port)) {
                    continue;
                }
                ibod_ctrl->start_time = sal_time_usecs();
                if(!IS_C_PORT(unit, port)) {
                    (void)_bcm_tr3_ibod_recovery_port(ibod_ctrl, port);
                }

                rv = _bcm_tr3_txerr_recovery_port(ibod_ctrl, port);
                if (SOC_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                                 (BSL_META_U(unit, "\n Error in TXERR WAR %s"),SOC_PORT_NAME(unit,port)));
                }
            }

            rv = _bcm_tr3_mmu_check_and_recovery(ibod_ctrl);
            if (SOC_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit, "\n Error in MMU recovery ")));
            }

        }
        (void)sal_sem_take(ibod_ctrl->sema, ibod_ctrl->interval);
    }
    ibod_ctrl->running = 0;
}

STATIC void
_bcm_hx4_ibod_sync_recovery_thread(void *context)
{
    _port_ibod_ctrl_t *ibod_ctrl = context;
    int port, flex_port=0, rv, unit = ibod_ctrl->unit;
    uint64 rrpkt, rrbyt;
    uint64 rrpkt_diff, rrbyt_diff;
    uint32 rval,rval_1,port_mode=0,encap_mode=0,next_flex_port=0;
    int port_group_iter;
    int flex_port_arr[3]={-1,-1,-1},cou,i;
    uint64 rval64;
    int runt_threshold;
    uint64 txerr;
    int egress_drain_timeout, port_drain_timeout, port_recovery_failed_flag;

    LOG_VERBOSE(BSL_LS_BCM_PORT,
                (BSL_META_U(unit, "IBOD recovery started on unit %d\n"),ibod_ctrl->unit));

    cou=0;
    PBMP_ITER(PBMP_XW_ALL(unit), port) {
        (void) READ_PORT_MODE_REGr(unit, port, &rval);
        port_mode=soc_reg_field_get(unit, PORT_MODE_REGr,
                                    rval, XPORT0_CORE_PORT_MODEf);

        if (port_mode != 3) {
            /* coverity[overrun-call : FALSE] */
            if (_bcm_tr3_port_is_control_port(unit, port)) {
                flex_port_arr[cou] = port;
                cou++;
            }
        }
        rv = READ_RRPKTr(unit, port, &rrpkt);
        if (SOC_FAILURE(rv)) {
           LOG_ERROR(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit, "Error in reading RRPKTr %d\n"),ibod_ctrl->unit));

        }

        rv = READ_RRBYTr(unit, port, &rrbyt);
        if (SOC_FAILURE(rv)) {
           LOG_ERROR(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit, "Error in reading RRBYTr %d\n"),ibod_ctrl->unit));
        }
        /* coverity[overrun-local : FALSE] */
        ibod_ctrl->rrpkt[port] = rrpkt;
        /* coverity[overrun-local : FALSE] */
        ibod_ctrl->rrbyt[port] = rrbyt;
    }

    ibod_ctrl->running = 1;
    while (!ibod_ctrl->stop) {
        if (!SOC_IS_DONE_INIT(unit)) {
            (void)sal_sem_take(ibod_ctrl->sema, ibod_ctrl->interval);
            continue;
        }
        /* Need to wait until warmboot recovery of ibod related stats is done */
        if (!SOC_WARM_BOOT(unit)) {
            next_flex_port=0;
            port_group_iter=-1;
            PBMP_ITER(PBMP_XW_ALL(unit), port) {
                if (!((IS_HG_PORT(unit,port)) || (IS_XE_PORT(unit,port)))) {
                    continue;
                }
                /* coverity[overrun-local : FALSE] */
                if (SOC_INFO(unit).port_speed_max[port] >= 100000) {
                    continue;
                }
                ibod_ctrl->start_time = sal_time_usecs();
                /* coverity[overrun-call : FALSE] */
                if (_bcm_tr3_port_is_control_port(unit, port)) {
                    flex_port=port;
                    next_flex_port=0;
                    port_group_iter++;
                }
                if (next_flex_port) {
                    continue;
                }
                (void) READ_PORT_EHG_RX_CONTROLr(unit, port, &rval);
                encap_mode = soc_reg_field_get(unit, PORT_EHG_RX_CONTROLr,
                                            rval, MODEf);
                if (encap_mode) {
                    (void) READ_PORT_EHG_RX_PKT_DROPr(unit, port, &rval);
                    if (rval) {
                        LOG_VERBOSE(BSL_LS_BCM_PORT,
                                     (BSL_META_U(unit, "\n WAR Trigerred by Embedded HG RX control")));
                        rv = BCM_E_NONE;
                        /* coverity[overrun-call : FALSE] */
                        rv = _bcm_hx4_ibod_sync_recovery_port(ibod_ctrl, port_group_iter, flex_port);
                        if (SOC_FAILURE(rv)) {
                            PORT_UNLOCK(unit);
                            /* Release the ibod recovery port group lock */
                            /* coverity[overrun-call : FALSE] */
                            _bcm_esw_ibod_recovery_port_unlock(unit, flex_port);
                            _bcm_esw_lc_unlock(unit);
                            LOG_ERROR(BSL_LS_BCM_PORT,
                                     (BSL_META_U(unit, "\n Error in RRPKT WAR %s"),SOC_PORT_NAME(unit,flex_port)));
                        }
                        soc_event_generate(unit, SOC_SWITCH_EVENT_RUNT_DETECT, port, 0, 0);
                        for (i=0; i<3; i++) {
                        if ((flex_port_arr[i] != flex_port) && (flex_port_arr[i] != -1)) {
                             rv = BCM_E_NONE;
                             rv = _bcm_hx4_txerr_recovery_port(ibod_ctrl, flex_port_arr[i]);
                             if (SOC_FAILURE(rv)) {
                                 PORT_UNLOCK(unit);
                                 /* Release the ibod recovery port group lock */
                                _bcm_esw_ibod_recovery_port_unlock(unit, flex_port_arr[i]);
                                 _bcm_esw_lc_unlock(unit);
                                 LOG_ERROR(BSL_LS_BCM_PORT,
                                     (BSL_META_U(unit, "\n Error in TXERR WAR %s"),SOC_PORT_NAME(unit,flex_port_arr[i])));
                             }
                            }
                        }
                        next_flex_port=1;
                        continue;
                    }
                }

                rv = READ_TERRr(unit, port, &txerr);
                if (SOC_FAILURE(rv)) {
                    continue;
                }
                /* coverity[overrun-local : FALSE] */
                if (COMPILER_64_NE(txerr, ibod_ctrl->txerrpkt[port])) {
                    /* coverity[overrun-call : FALSE] */
                    rv = _bcm_hx4_txerr_recovery_port(ibod_ctrl, flex_port);
                    if (SOC_FAILURE(rv)) {
                        PORT_UNLOCK(unit);
                        /* Release the ibod recovery port group lock */
                        /* coverity[overrun-call : FALSE] */
                        _bcm_esw_ibod_recovery_port_unlock(unit, flex_port);
                        _bcm_esw_lc_unlock(unit);
                        LOG_ERROR(BSL_LS_BCM_PORT,
                                     (BSL_META_U(unit, "\n Error in TXERR WAR %s"),SOC_PORT_NAME(unit,flex_port)));
                    }
                }
                /* Check if any new runt packet logged in RRPKT */
                rv = READ_RRPKTr(unit, port, &rrpkt);
                if (SOC_FAILURE(rv)) {
                    continue;
                }
                if (COMPILER_64_EQ(rrpkt, ibod_ctrl->rrpkt[port])) {
                    continue;
                }
                /* Check total runt byte count */
                rv = READ_RRBYTr(unit, port, &rrbyt);
                if (SOC_FAILURE(rv)) {
                    continue;
                }

                /* It's very unlikely both packet and byte counters wrap around
                 * and stop at 0, the code assume this is from clear counter */
                if (COMPILER_64_IS_ZERO(rrpkt) && COMPILER_64_IS_ZERO(rrbyt)) {
                    ibod_ctrl->rrpkt[port] = rrpkt;
                    ibod_ctrl->rrbyt[port] = rrbyt;
                    continue;
                }

                rrpkt_diff = rrpkt;
                rrbyt_diff = rrbyt;
                COMPILER_64_SUB_64(rrpkt_diff, ibod_ctrl->rrpkt[port]);
                COMPILER_64_SUB_64(rrbyt_diff, ibod_ctrl->rrbyt[port]);
                ibod_ctrl->rrpkt[port] = rrpkt;
                ibod_ctrl->rrbyt[port] = rrbyt;

                rv = READ_XMAC_RX_CTRLr(unit,port, &rval64);
                if (SOC_FAILURE(rv)) {
                    continue;
                }
                runt_threshold = soc_reg64_field32_get(unit, XMAC_RX_CTRLr, rval64, RUNT_THRESHOLDf);

                /* Recovery is needed only for packet size between 33 and 76 */
                if (COMPILER_64_HI(rrpkt_diff) == 0 &&
                    COMPILER_64_LO(rrpkt_diff) == 1) {
                    if (COMPILER_64_LO(rrbyt_diff) >= runt_threshold) {
                        continue;
                    }
                }
                if (COMPILER_64_HI(rrbyt_diff) == 0 &&
                    COMPILER_64_LO(rrbyt_diff) <= 32) {
                    continue;
                }
                LOG_VERBOSE(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,"\n WAR Trigerred by RRPKT/RRBYT")));
                /* coverity[overrun-call : FALSE] */
                rv = _bcm_hx4_ibod_sync_recovery_port(ibod_ctrl, port_group_iter, flex_port);
                if (SOC_FAILURE(rv)) {
                    PORT_UNLOCK(unit);
                    /* Release the ibod recovery port group lock */
                    /* coverity[overrun-call : FALSE] */
                    _bcm_esw_ibod_recovery_port_unlock(unit, flex_port);
                    _bcm_esw_lc_unlock(unit);
                    LOG_ERROR(BSL_LS_BCM_PORT,
                                     (BSL_META_U(unit, "\n Error in RRPKT WAR %s"),SOC_PORT_NAME(unit,flex_port)));
                }
                soc_event_generate(unit, SOC_SWITCH_EVENT_RUNT_DETECT, port, 0, 0);
                for (i=0; i<3; i++) {
                    if ((flex_port_arr[i] != flex_port) && (flex_port_arr[i] != -1)) {
                        rv = BCM_E_NONE;
                        rv = _bcm_hx4_txerr_recovery_port(ibod_ctrl, flex_port_arr[i]);
                        if (SOC_FAILURE(rv)) {
                            PORT_UNLOCK(unit);
                            /* Release the ibod recovery port group lock */
                            /* coverity[overrun-call : FALSE] */
                            _bcm_esw_ibod_recovery_port_unlock(unit, flex_port_arr[i]);
                            _bcm_esw_lc_unlock(unit);
                            LOG_ERROR(BSL_LS_BCM_PORT,
                                     (BSL_META_U(unit, "\n Error in TXERR WAR %s"),SOC_PORT_NAME(unit,flex_port_arr[i])));
                        }
                    }
                }
                next_flex_port=1;
            }

             _soc_egress_drain_timeout_flag_get(unit, &egress_drain_timeout);
             port_drain_timeout = ibod_ctrl->drain_timeout_flag;
             port_recovery_failed_flag = ibod_ctrl->port_recovery_failed_flag;

            rv = READ_PQEFIFOOVERFLOW0r(unit, &rval);
            if (SOC_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit, "\n Error in ibod recovery thread when reading register PQEFIFOOVERFLOW0")));
            }
            rv = READ_PQEFIFOOVERFLOW1r(unit, &rval_1);
            if (SOC_FAILURE(rv)) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit, "\n Error in ibod recovery thread when reading register PQEFIFOOVERFLOW1")));
            }

            if ((rval != 0) || (rval_1 != 0) || (egress_drain_timeout != 0) || (port_drain_timeout != 0)
                    || port_recovery_failed_flag || (_ibod_debug_flag & _PORT_IBOD_FLAG_MMU_TRIGGER)) {
                rv = _bcm_tr3_mmu_recovery(ibod_ctrl);
                ibod_ctrl->drain_timeout_flag = 0;
                _soc_egress_drain_timeout_flag_set(unit, 0);
                if (port_drain_timeout) {
                    ibod_ctrl->drain_timeout_flag = 0;
                    ibod_ctrl->drain_timeout_count++;
                }
                if (egress_drain_timeout) {
                    _soc_egress_drain_timeout_flag_set(unit, 0);
                    ibod_ctrl->egress_drain_timeout_count++;
                }
                if (port_recovery_failed_flag) {
                    ibod_ctrl->port_recovery_failed_flag = 0;
                    ibod_ctrl->port_recovery_failed_count++;
                }
                if (_ibod_debug_flag & _PORT_IBOD_FLAG_MMU_TRIGGER) {
                    _ibod_debug_flag &= (~_PORT_IBOD_FLAG_MMU_TRIGGER);
                }
                if (SOC_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                            (BSL_META_U(unit, "\n Error in MMU recovery ")));
                }
            }
        }
        (void)sal_sem_take(ibod_ctrl->sema, ibod_ctrl->interval);
    }
    ibod_ctrl->running = 0;
}

int _bcm_esw_ibod_syn_port_down (int unit, int port)
{
    _port_ibod_ctrl_t *ibod_ctrl = _port_ibod_ctrl[unit];
    int rv;
    uint64 rrpkt, rrbyt,rval64;
    uint64 rrpkt_diff, rrbyt_diff;
    int runt_threshold;
    uint32 port_mode, rval;

    if (!SOC_IS_TRIUMPH3(unit) || !ibod_ctrl) {
        return BCM_E_NONE;
    }

    if (SOC_IS_HELIX4(unit)) {
        if (!IS_XE_PORT(unit, port) && !IS_HG_PORT(unit, port)) {
            return SOC_E_NONE;
        }
    } else {
        if (!IS_HG_PORT(unit, port)) {
            return SOC_E_NONE;
        }
    }

     if (SOC_INFO(unit).port_speed_max[port] >= 100000 ||
        !(SOC_CONTROL(unit)->soc_flags & SOC_F_INITED)) {
         return SOC_E_NONE;
     }

     BCM_IF_ERROR_RETURN(READ_PORT_MODE_REGr(unit, port, &rval));
     port_mode=soc_reg_field_get(unit, PORT_MODE_REGr,
                                 rval, XPORT0_CORE_PORT_MODEf);

     /* Port mode must be Dual or Qual */
     if ((port_mode != 1) && (port_mode != 2)) {
         return SOC_E_NONE;
     }

     /* Check if any new runt packet logged in RRPKT */
     rv = READ_RRPKTr(unit, port, &rrpkt);
     if (SOC_FAILURE(rv)) {
         return SOC_E_NONE;
     }
     if (COMPILER_64_EQ(rrpkt, ibod_ctrl->rrpkt[port])) {
         return SOC_E_NONE;
     }
     /* Check total runt byte count */
     rv = READ_RRBYTr(unit, port, &rrbyt);
     if (SOC_FAILURE(rv)) {
         return SOC_E_NONE;
     }

     /* It's very unlikely both packet and byte counters wrap around
     * and stop at 0, the code assume this is from clear counter */
     if (COMPILER_64_IS_ZERO(rrpkt) && COMPILER_64_IS_ZERO(rrbyt)) {
         ibod_ctrl->rrpkt[port] = rrpkt;
         ibod_ctrl->rrbyt[port] = rrbyt;
         return SOC_E_NONE;
     }

     rrpkt_diff = rrpkt;
     rrbyt_diff = rrbyt;
     COMPILER_64_SUB_64(rrpkt_diff, ibod_ctrl->rrpkt[port]);
     COMPILER_64_SUB_64(rrbyt_diff, ibod_ctrl->rrbyt[port]);
     ibod_ctrl->rrpkt[port] = rrpkt;
     ibod_ctrl->rrbyt[port] = rrbyt;

     rv = READ_XMAC_RX_CTRLr(unit,port, &rval64);
     if (SOC_FAILURE(rv)) {
         return SOC_E_NONE;
     }
     runt_threshold = soc_reg64_field32_get(unit, XMAC_RX_CTRLr, rval64, RUNT_THRESHOLDf);

     /* Recovery is needed only for packet size between 33 and 76 */
     if (COMPILER_64_HI(rrpkt_diff) == 0 &&
         COMPILER_64_LO(rrpkt_diff) == 1) {
         if (COMPILER_64_LO(rrbyt_diff) >= runt_threshold) {
             return SOC_E_NONE;
         }
     }
     if (COMPILER_64_HI(rrbyt_diff) == 0 &&
         COMPILER_64_LO(rrbyt_diff) <= 32) {
         return SOC_E_NONE;
     }

     ibod_ctrl->start_time = sal_time_usecs();
     if (SOC_IS_HELIX4(unit)) {
         int port_group_iter, port_iter, flex_port=0;
         bcm_pbmp_t pbmp;

         port_group_iter=-1;
         PBMP_ITER(PBMP_XW_ALL(unit), port_iter) {
             /* coverity[overrun-call : FALSE] */
             if (!(_bcm_tr3_port_is_control_port(unit, port_iter))) {
                 continue;
             }
             flex_port = port_iter;
             port_group_iter++;
             BCM_IF_ERROR_RETURN(bcm_esw_port_subsidiary_ports_get(unit, flex_port, &pbmp));
             if (SOC_PBMP_MEMBER(pbmp, port)) {
                 break;
             }
         }
         /* coverity[overrun-call : FALSE] */
         rv = _bcm_hx4_ibod_sync_recovery_port(ibod_ctrl, port_group_iter, flex_port);
         if (SOC_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            /* Release the ibod recovery port group lock */
            _bcm_esw_ibod_recovery_port_unlock(unit, flex_port);
            _bcm_esw_lc_unlock(unit);
         }
     } else {
         rv = _bcm_tr3_ibod_sync_recovery_port(ibod_ctrl, 1, port);
     }

     if (SOC_FAILURE(rv)) {
         LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit, "\n Error in RRPKT WAR %s"), SOC_PORT_NAME(unit, port)));
     }
     return SOC_E_NONE;

}

int
_bcm_esw_ibod_sync_recovery_start(int unit, sal_usecs_t interval)
{
    int cnt;
    bcm_pkt_t *pkt;
    uint8 *buf;
    int buf_size = 72;
    uint32 rval;
    int rv = BCM_E_NONE;
    _port_ibod_ctrl_t *ibod_ctrl;

    if (!SOC_IS_TRIUMPH3(unit)) {
        return BCM_E_NONE;
    }

    ibod_ctrl = _port_ibod_ctrl[unit];
    if (ibod_ctrl == NULL) {
        ibod_ctrl = sal_alloc(sizeof(_port_ibod_ctrl_t), "_port_ibod_ctrl_t");
        if (ibod_ctrl == NULL) {
            return BCM_E_MEMORY;
        }
        sal_memset(ibod_ctrl, 0, sizeof(_port_ibod_ctrl_t));
        _port_ibod_ctrl[unit] = ibod_ctrl;
    }

    ibod_ctrl->interval = interval;

    if (ibod_ctrl->interval < IBOD_SYNC_INTERVAL_MIN) {
        ibod_ctrl->interval = IBOD_SYNC_INTERVAL_MIN;
    }

    if (ibod_ctrl->running) {
        return BCM_E_NONE;
    }

    ibod_ctrl->unit = unit;

    /* Setup packet field */
    pkt = &ibod_ctrl->pkt;
    buf = soc_cm_salloc(unit, buf_size, "pkt alloc data");
    if (buf == NULL) {
        return BCM_E_MEMORY;
    }
    BCM_PKT_ONE_BUF_SETUP(pkt, buf, buf_size);
    pkt->unit = unit;
    pkt->flags = BCM_TX_CRC_APPEND | BCM_TX_HG_READY | BCM_TX_NO_PAD |
                 BCM_TX_LINKDOWN_TRANSMIT;
    pkt->opcode = BCM_PKT_OPCODE_UC; /* do not to CPU */

    if (ibod_ctrl->sema == NULL) {
        ibod_ctrl->sema = sal_sem_create("ibod recovery", sal_sem_BINARY, 0);
        if (ibod_ctrl->sema == NULL) {
            return BCM_E_MEMORY;
        }
    }

    sal_snprintf(ibod_ctrl->taskname, sizeof (ibod_ctrl->taskname),
                 "bcmIbodSync.%d", unit);
    ibod_ctrl->stop = 0;
    SOC_IF_ERROR_RETURN(_bcm_esw_ibod_recovery_lock_init(unit));
    rv = soc_tr3_mmu_store_alloc(unit);
    if(BCM_FAILURE(rv)) {
        return rv;
    }
    soc_ibod_recovery_in_progress_set(unit, 0);
    _soc_egress_drain_timeout_flag_set(unit, 0);
    sal_memset(txerr_trigger_flag, 0, sizeof(txerr_trigger_flag));
    if (SOC_IS_HELIX4(unit)) {
        SOC_IF_ERROR_RETURN(READ_IBOD_INTR_MASKr(unit, &rval));
        soc_reg_field_set(unit, IBOD_INTR_MASKr, &rval, CL0_CTRL_FIFO_FULL_ERR_INTR_MASKf, 1);
        soc_reg_field_set(unit, IBOD_INTR_MASKr, &rval, CL0_DATA_FIFO_FULL_ERR_INTR_MASKf, 1);
        soc_reg_field_set(unit, IBOD_INTR_MASKr, &rval, CL1_CTRL_FIFO_FULL_ERR_INTR_MASKf, 1);
        soc_reg_field_set(unit, IBOD_INTR_MASKr, &rval, CL1_DATA_FIFO_FULL_ERR_INTR_MASKf, 1);
        soc_reg_field_set(unit, IBOD_INTR_MASKr, &rval, CL2_CTRL_FIFO_FULL_ERR_INTR_MASKf, 1);
        soc_reg_field_set(unit, IBOD_INTR_MASKr, &rval, CL2_DATA_FIFO_FULL_ERR_INTR_MASKf, 1);
        SOC_IF_ERROR_RETURN(WRITE_IBOD_INTR_MASKr(unit, rval));
        if (sal_thread_create(ibod_ctrl->taskname, SAL_THREAD_STKSZ,
                              soc_property_get(unit, spn_IBOD_SYNC_THREAD_PRI, 50),
                              _bcm_hx4_ibod_sync_recovery_thread,
                              ibod_ctrl) == SAL_THREAD_ERROR) {
            return BCM_E_MEMORY;
        }
    } else {
        if (sal_thread_create(ibod_ctrl->taskname, SAL_THREAD_STKSZ,
                              soc_property_get(unit, spn_IBOD_SYNC_THREAD_PRI, 50),
                              _bcm_tr3_ibod_sync_recovery_thread,
                              ibod_ctrl) == SAL_THREAD_ERROR) {
            return BCM_E_MEMORY;
        }
    }
    cnt = 10;
    while (!ibod_ctrl->running && cnt--) {
        sal_usleep(100000);
    }
    if (!ibod_ctrl->running) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit,
                              "%s: Thread did not start\n"), ibod_ctrl->taskname));
        return BCM_E_TIMEOUT;
    }
    return BCM_E_NONE;
}

int
_bcm_esw_ibod_sync_recovery_stop(int unit)
{
    int cnt;
    bcm_pkt_t *pkt;
    _port_ibod_ctrl_t *ibod_ctrl = _port_ibod_ctrl[unit];

    if (ibod_ctrl == NULL) {
        return BCM_E_NONE;
    }

    ibod_ctrl->stop = 1;
    if (ibod_ctrl->sema != NULL) {
        sal_sem_give(ibod_ctrl->sema);
    }
    cnt = 10;
    while (ibod_ctrl->running && cnt--) {
        sal_usleep(100000);
    }
    if (ibod_ctrl->running) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit,
                              "%s: Thread did not start\n"), ibod_ctrl->taskname));
        return BCM_E_TIMEOUT;
    }
    pkt = &ibod_ctrl->pkt;
    if (pkt->_pkt_data.data != NULL) {
        soc_cm_sfree(unit, pkt->_pkt_data.data);
        pkt->_pkt_data.data = NULL;
        pkt->_pkt_data.len = 0;
    }
    if (ibod_ctrl->sema != NULL) {
        sal_sem_destroy(ibod_ctrl->sema);
    }

    sal_free(ibod_ctrl);
    _port_ibod_ctrl[unit] = NULL;

    _bcm_esw_ibod_recovery_lock_deinit(unit);

    soc_tr3_mmu_store_free(unit);
    return BCM_E_NONE;
}

int _bcm_esw_ibod_sync_recovery_running(int unit, _port_ibod_ctrl_t *ibod_ctrl)
{
    if (_port_ibod_ctrl[unit] == NULL) {
        return BCM_E_FAIL;
    }
    if(ibod_ctrl != NULL) {
        sal_memcpy(ibod_ctrl, _port_ibod_ctrl[unit], sizeof(_port_ibod_ctrl_t));
    }
    return BCM_E_NONE;
}

STATIC int _bcm_tr3_xmac_fifo_check(int unit, bcm_port_t port, uint8 lu_tpo)
{
    int rv_xmac_fifo = BCM_E_NONE;
    int rv = BCM_E_NONE;
    bcm_pkt_t *pkt = NULL;
    uint8 *payload;
    uint32 req_cnt = 0, cell_cnt = 0;
    uint64 rval64;
    int rx_enable_org = 0,speed_mode=0,port_enable;
    pbmp_t act_tx_pbmp, tx_pbmp;

    COMPILER_64_ZERO(rval64);
    SOC_PBMP_CLEAR(act_tx_pbmp);
    SOC_PBMP_CLEAR(tx_pbmp);

    /* Create test packet */
    pkt = soc_cm_salloc(unit, sizeof(bcm_pkt_t), "pkt buffer");
    if (pkt == NULL) {
        return BCM_E_FAIL;
    }

    sal_memset(pkt, 0, sizeof(bcm_pkt_t));
    payload = soc_cm_salloc(unit, _SOC_HX4_XMAC_FIFO_CHK_PKT_SZ,
                            "pkt alloc data");
    if (payload == NULL) {
        soc_cm_sfree(unit, pkt);
        return BCM_E_FAIL;
    }
    sal_memset(payload, 0, _SOC_HX4_XMAC_FIFO_CHK_PKT_SZ);
    BCM_PKT_ONE_BUF_SETUP(pkt, payload, _SOC_HX4_XMAC_FIFO_CHK_PKT_SZ);
    pkt->unit = unit;
    pkt->flags = BCM_TX_CRC_APPEND | BCM_TX_HG_READY | BCM_TX_NO_PAD |
                BCM_TX_LINKDOWN_TRANSMIT;
    pkt->call_back = NULL;

#ifdef BCM_PORT_DEFAULT_DISABLE
    port_enable = FALSE;
#else
    port_enable = TRUE;
#endif  /* BCM_PORT_DEFAULT_DISABLE */

    if (BCM_E_NONE !=
        (rv = MAC_ENABLE_GET(PORT(unit, port).p_mac, unit, port, &port_enable))) {
        goto cleanup;
    }
    /* Put the port in MAC loopback and enable it for transmit */
    if (BCM_E_NONE !=
        (rv = MAC_LOOPBACK_SET(PORT(unit, port).p_mac, unit, port, TRUE))) {
        goto cleanup;
    }
    if (BCM_E_NONE !=
        (rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, TRUE))) {
        goto cleanup;
    }
    /* Ensure that we are in MAC line-side loopback */
    if (SOC_E_NONE != (rv = READ_XMAC_CTRLr(unit, port, &rval64))) {
        goto cleanup;
    }

    rx_enable_org = soc_reg64_field32_get(unit, XMAC_CTRLr, rval64, RX_ENf);
    /* RX Disable */
    soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, RX_ENf, 0);
    /* Line local LB  */
    soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, LINE_LOCAL_LPBKf, 1);
    /* Core local LB */
    soc_reg64_field32_set(unit, XMAC_CTRLr, &rval64, CORE_LOCAL_LPBKf, 0);
    if (SOC_E_NONE != (rv = WRITE_XMAC_CTRLr(unit, port, rval64))) {
        goto cleanup;
    }
    /* Ensure that we are back in same MAC MODE*/
    if (SOC_E_NONE != (rv = READ_XMAC_MODEr(unit, port, &rval64))) {
        goto cleanup;
    }
    speed_mode = soc_reg64_field32_get(unit, XMAC_MODEr, rval64, SPEED_MODEf);

    /* Stall the XMAC's transmit FIFO */
    if (SOC_E_NONE !=
        (rv = soc_reg_field32_modify(unit, XMAC_MODEr, port, SPEED_MODEf, 4))) {
        goto cleanup;
    }

    if (SOC_E_NONE !=
        (rv = soc_reg_field32_modify(unit, XMAC_MACSEC_CTRLr, port,
                                     MACSEC_TX_LAUNCH_ENf, 1))) {
        goto cleanup;
    }

    /* EPC_LINK */
    soc_link_mask2_get(unit, &act_tx_pbmp);
    SOC_PBMP_PORT_ADD(tx_pbmp, port);
    if (!lu_tpo) {
        /* Use original state and add new ports as well */
        SOC_PBMP_OR(tx_pbmp, act_tx_pbmp);
    }
    if (SOC_E_NONE != (rv = soc_link_mask2_set(unit, tx_pbmp))) {
        goto cleanup;
    }
    /* Transmit the test packet */
    BCM_PKT_TX_LEN_SET(pkt, _SOC_HX4_XMAC_FIFO_CHK_PKT_SZ);
    BCM_PKT_PORT_SET(pkt, port, TRUE, FALSE);
    rv = bcm_esw_tx(unit, pkt, NULL);
    if (BCM_FAILURE(rv)) {
        rv = BCM_E_FAIL;
        goto cleanup;
    }

    /* Wait for a short period of time to allow
       the packet to reach the end of the EP */
    sal_udelay(1000);

    /* Read the request count value */
    if (SOC_E_NONE !=
        (rv = READ_PORT_TXFIFO_CELL_REQ_CNTr(unit, port, &req_cnt))) {
        goto cleanup;
    }
    /* Read the cell count value */
    if (SOC_E_NONE !=
        (rv = READ_PORT_TXFIFO_CELL_CNTr(unit, port, &cell_cnt))) {
        goto cleanup;
    }
    LOG_VERBOSE(BSL_LS_BCM_PORT,
                (BSL_META_U(unit,
                            "Check: cell_req_cnt: %d cell_cnt: %d\n"),
                 req_cnt, cell_cnt));
    /* Check to make sure that the request count is exactly zero */
    if (req_cnt != 0) {
        rv_xmac_fifo = BCM_E_INTERNAL;
        goto cleanup;
    }

cleanup:
    /* free packet memory */
    if (payload != NULL) {
        soc_cm_sfree(unit, payload);
    }
    if (pkt != NULL) {
        soc_cm_sfree(unit, pkt);
    }
    /* Clear the MAC loopback (flushes the test packet) */
    if (SOC_E_NONE != MAC_LOOPBACK_SET(PORT(unit, port).p_mac,
                                            unit, port, FALSE)) {
        rv = BCM_E_FAIL;
    }
    /* Clear the MAC Enable Set */
    if (SOC_E_NONE != MAC_ENABLE_SET(PORT(unit, port).p_mac,
                                          unit, port, FALSE)) {
        rv = BCM_E_FAIL;
    }
    /* Restoring the MAC Enable Set */
    if (port_enable) {
        if (SOC_E_NONE !=
            (rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, TRUE))) {
             rv = BCM_E_FAIL;
        }
    }
    /* Remove the MAC FIFO stall */
    if (SOC_E_NONE != soc_reg_field32_modify(unit, XMAC_MODEr, port,
                                             SPEED_MODEf, speed_mode)) {
        rv = BCM_E_FAIL;
    }
    if (SOC_E_NONE != soc_reg_field32_modify(unit, XMAC_MACSEC_CTRLr, port,
                                             MACSEC_TX_LAUNCH_ENf, 0)) {
        rv = BCM_E_FAIL;
    }
    /* revert rx_enable */
    if (SOC_E_NONE != soc_reg_field32_modify(unit, XMAC_CTRLr, port, RX_ENf,
                                             rx_enable_org)) {
        rv = BCM_E_FAIL;
    }
    /* EPC_LINK restore */
    if (SOC_E_NONE != soc_link_mask2_set(unit, act_tx_pbmp)) {
        rv = BCM_E_FAIL;
    }
    /* Clear the counters from tx port*/
    SOC_PBMP_PORT_SET(tx_pbmp, port);
    if (SOC_E_NONE != soc_counter_set32_by_port(unit, tx_pbmp, 0))  {
        rv = BCM_E_FAIL;
    }
    if (BCM_E_NONE != rv) {
        return rv;
    } else {
        return rv_xmac_fifo;
    }
}

#define _BCM_TR3_PORT_UR_RETRY_MAX 15
int _bcm_tr3_port_ur_chk(int unit, int num_ports, bcm_port_t port)
{
    uint8 lu_tpo = 0; /* link up test port only */
    int retry = _BCM_TR3_PORT_UR_RETRY_MAX;
    int fifo_underrun = FALSE, issue_overcome = TRUE;
    soc_info_t *si = &SOC_INFO(unit);
    int rv = BCM_E_NONE;
    int okay = 0;
    uint32 expected_cell_req_cnt, cell_req_cnt, cell_cnt;
    soc_block_type_t pbt;
    int _num_ports = (num_ports == -1) ? 4 : num_ports;
    int phy_port = SOC_IS_HELIX4(unit) ?
                   _SOC_HX4_MGMT_PHY_PORT : _SOC_TR3_MGMT_PHY_PORT;

#ifdef BCM_TRIUMPH3_SUPPORT
    if (!(SOC_IS_HELIX4(unit))) {
        /* Skipping in for Disabled Ports */
        SOC_IF_ERROR_RETURN(bcm_esw_port_enable_get(unit, port, &okay));
        if (!okay) {
            return BCM_E_NONE;
        }
    }
#endif
#ifdef BCM_HELIX4_SUPPORT
     if ( SOC_IS_HELIX4(unit) &&
     ((_tr3_port_config_id[unit] == 463)||
        (_tr3_port_config_id[unit] == 413)) &&
        (57 == si->port_l2p_mapping[port] || 61 == si->port_l2p_mapping[port]))
     {
        switch (_num_ports) {
          case 1: expected_cell_req_cnt = 8; break;
          case 2: expected_cell_req_cnt = 4; break;
          case 4: expected_cell_req_cnt = 4; break;
          default: expected_cell_req_cnt = 4;
        }
     }else
#endif
    {
        switch (_num_ports) {
         case 1: expected_cell_req_cnt = 16; break;
         case 2: expected_cell_req_cnt = 8; break;
         case 4: expected_cell_req_cnt = 4; break;
         default: expected_cell_req_cnt = 4;
       }
    }
    if (-1 == port) {
        lu_tpo = 1;
        port = si->port_p2l_mapping[phy_port];
    } else {
        phy_port = SOC_INFO(unit).port_l2p_mapping[port];
    }
    LOG_VERBOSE(BSL_LS_BCM_PORT,
                (BSL_META_U(unit,
                            "UR test: %s\n"), SOC_PORT_NAME(unit, port)));

    /* nothing to do if port is not a valid port */
    if (!SOC_PORT_VALID(unit, port)) {
        LOG_VERBOSE(BSL_LS_BCM_PORT, (BSL_META_U(unit,
                    "Port %s is not valid - skipping WAR\n"),
                    SOC_PORT_NAME(unit, port)));
        return BCM_E_NONE;
    }

    pbt = SOC_BLOCK_TYPE(unit, SOC_PORT_BLOCK(unit, phy_port));
    while (retry--) {
        rv = _bcm_tr3_xmac_fifo_check(unit, port, lu_tpo);
        if (BCM_E_INTERNAL == rv) {
            if (num_ports != -1 && (_num_ports > 1)) {
                /* This is a case of flex port transform to dual or quad lane
                   mode and one of the newly created ports is failing */
                return BCM_E_PORT;
            }
            fifo_underrun = TRUE;
            issue_overcome = FALSE;

            if (SOC_E_NONE != (rv = _soc_tr3_ur_port_reset(unit, _num_ports, port, pbt))) {
                rv = BCM_E_INTERNAL;
                goto cleanup;
            }
            if ((rv = _bcm_port_mac_init(unit, port, &okay)) != BCM_E_NONE) {
                goto cleanup;
            }
            /* Read cell req count value to see if reset cleared it */
            if ((rv = READ_PORT_TXFIFO_CELL_REQ_CNTr(
                          unit, port, &cell_req_cnt)) != SOC_E_NONE) {
                goto cleanup;
            }
            /* Read cell count value again to see if reset cleared it */
            if ((rv = READ_PORT_TXFIFO_CELL_CNTr(
                          unit, port, &cell_cnt))!= SOC_E_NONE) {
                goto cleanup;
            }
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "After reset: cell_req_cnt: "
                                    "%d cell_cnt: %d\n"), cell_req_cnt, cell_cnt));
            /* Check to make sure that the request count is exactly zero */
            if ((cell_req_cnt != expected_cell_req_cnt) || (cell_cnt != 0)) {
                rv = BCM_E_INTERNAL;
                goto cleanup;
            }
        } else {
            if (BCM_E_NONE != rv) {
                goto cleanup;
            }
            if (TRUE == fifo_underrun) {
                issue_overcome = TRUE;
            }
            /* either underrun didn't occur or war fixed it */
            break;
        }
    }/* while */

    if (fifo_underrun) {
        rv = BCM_E_INTERNAL;
        if (issue_overcome) {
            rv = BCM_E_NONE;
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "Port %s recovered from XMAC FIFO underrun\n"),
                         SOC_PORT_NAME(unit, port)));
        } else {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "Port %s did not recover from XMAC FIFO underrun\n"),
                       SOC_PORT_NAME(unit, port)));
        }
    }

cleanup:
    if (BCM_E_NONE != rv) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit,
                              "Port %s, failed while checking/recovering "
                              "XL port underrun\n"),
                   SOC_PORT_NAME(unit, port)));
    }

    return rv;
}
#endif /* BCM_TRIUMPH3_SUPPORT */


/*
 * Function:
 *      _bcm_esw_port_gport_validate
 * Description:
 *      Helper funtion to validate port/gport parameter
 * Parameters:
 *      unit  - (IN) BCM device number
 *      port_in  - (IN) Port / Gport to validate
 *      port_out - (OUT) Port number if valid.
 * Return Value:
 *      BCM_E_NONE - Port OK
 *      BCM_E_INIT - Not initialized
 *      BCM_E_PORT - Port Invalid
 */
int
_bcm_esw_port_gport_validate(int unit, bcm_port_t port_in, bcm_port_t *port_out)
{
    if (bcm_port_info[unit] == NULL) {
        return BCM_E_INIT;
    }

#if defined (BCM_HGPROXY_COE_SUPPORT)
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        soc_feature(unit, soc_feature_channelized_switching)) &&
        BCM_GPORT_IS_SUBPORT_PORT(port_in)) {
        return _bcm_xgs5_subport_gport_validate(unit,
                                                port_in,
                                                port_out);
    } else
#endif /* defined (BCM_HGPROXY_COE_SUPPORT) */

#ifdef BCM_KATANA2_SUPPORT
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        return _bcm_kt2_port_gport_validate(unit, port_in, port_out);
    }
#endif

    if (BCM_GPORT_IS_SET(port_in)) {
        BCM_IF_ERROR_RETURN(
            bcm_esw_port_local_get(unit, port_in, port_out));
    } else if (SOC_PORT_VALID(unit, port_in)) {
        *port_out = port_in;
    } else {
        return BCM_E_PORT;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_link_delay_update
 * Description:
 *      Helper funtion: Update link delay based on configured values
 * Parameters:
 *      unit  - (IN) BCM device number
 *      port  - (IN) Port number
 *      speed - (IN) New speed
 * Return Value:
 *      BCM_E_XXX
 */
int
_bcm_esw_port_link_delay_update(int unit, bcm_port_t port, int speed)
{
    int32 link_delay;
    int mac_rx_latency = 0;
    _bcm_port_info_t *port_info;
    int rv;

    _bcm_port_info_access(unit, port, &port_info);
    rv = MAC_CONTROL_GET(port_info->p_mac, unit, port,
                         SOC_MAC_CONTROL_EXPECTED_RX_LATENCY,
                         &mac_rx_latency);
    if (rv != BCM_E_NONE) {
        LOG_INFO(BSL_LS_BCM_PORT, (BSL_META(
           "Port updating LINK_DELAY, but MAC doesn't have a default value\n")
        ));
    }

    link_delay = (int32)soc_property_port_get(unit, port, spn_LINK_DELAY(speed), mac_rx_latency);
    /* use bcmPortControl1588P2PDelay control field as an offset from this value */
    link_delay += PORT(unit, port).link_delay_offset;

    if (SOC_REG_PORT_VALID(unit, EGR_1588_LINK_DELAYr, port)) {
        BCM_IF_ERROR_RETURN(
            soc_reg_field32_modify(unit, EGR_1588_LINK_DELAYr,
                port, LINK_DELAYf, (uint32)link_delay));
    } else if (SOC_REG_PORT_VALID(unit, EGR_1588_LINK_DELAY_64r, port)) {
        BCM_IF_ERROR_RETURN(
            soc_reg_above_64_field32_modify(unit, EGR_1588_LINK_DELAY_64r,
                port, 0, LINK_DELAYf, (uint32)link_delay));
    } else {
        /* No LINK_DELAY register, so no-op */
    }

    return BCM_E_NONE;
}

STATIC int
_bcm_esw_port_link_delay_recover(int unit, bcm_port_t port, int speed)
{
    uint32 link_delay = 0;
    uint32 mac_rx_latency = 0;

    mac_rx_latency = soc_property_port_get(unit, port, spn_LINK_DELAY(speed), mac_rx_latency);

    if (SOC_REG_PORT_VALID(unit, EGR_1588_LINK_DELAYr, port)) {
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, EGR_1588_LINK_DELAYr, port, LINK_DELAYf, &link_delay));
    } else if (SOC_REG_PORT_VALID(unit, EGR_1588_LINK_DELAY_64r, port)) {
        SOC_IF_ERROR_RETURN(soc_reg_above_64_field32_read(unit, EGR_1588_LINK_DELAY_64r,
                                                          port, 0, LINK_DELAYf, &link_delay));
    }

    PORT(unit, port).link_delay_offset = link_delay - mac_rx_latency;

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_info_get
 * Description:
 *      Helper funtion
 * Parameters:
 *      unit  - (IN) BCM device number
 *      port  - (IN) Port number
 *      pinfo - (OUT) Port info.
 * Return Value:
 *      BCM_E_XXX
 */
int
_bcm_port_info_get(int unit, bcm_port_t port, _bcm_port_info_t **pinfo)
{
    /* Input parameters check. */
    if (NULL == pinfo) {
        return (BCM_E_PARAM);
    }

    PORT_INIT(unit);

    *pinfo = &PORT(unit, port);
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_esw_iport_tab_set
 * Description:
 *      Set field in either IPORT_TABLE or the special CPU Higig entry in
 *      the PORT_TAB.
 * Parameters:
 *      unit  - Device number
 *      port  - Port number
 *      field - Field name within PORT_TAB table entry
 *      value - new field value
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX - an error occurred accessing PORT_TAB table.
 */
int
_bcm_esw_iport_tab_set(int unit, bcm_port_t port,
                       soc_field_t field, int value)

{
    port_tab_entry_t pent;
    soc_mem_t mem;
    int rv, index, cpu_hg_index, cur_val;

    cpu_hg_index = SOC_IS_KATANA2(unit) ?
                   SOC_INFO(unit).cpu_hg_pp_port_index :
                   SOC_INFO(unit).cpu_hg_index;

    if (SOC_MEM_IS_VALID(unit, IPORT_TABLEm)) {
        mem = IPORT_TABLEm;
        index = SOC_PORT_MOD_OFFSET(unit, port);
    } else if (IS_CPU_PORT(unit, port) && cpu_hg_index != -1) {
        mem = PORT_TABm;
        index = cpu_hg_index;
    } else {
        return BCM_E_NONE;
    }

    if (!SOC_MEM_FIELD_VALID(unit, mem, field)) {
        return (BCM_E_UNAVAIL);
    }

    rv = soc_mem_read(unit, mem, MEM_BLOCK_ANY, index, &pent);
    if (BCM_SUCCESS(rv)) {
        cur_val = soc_mem_field32_get(unit, mem, &pent, field);
        if (value != cur_val) {
            soc_mem_field32_set(unit, mem, &pent, field, value);
            rv = soc_mem_write(unit, mem, MEM_BLOCK_ALL, index, &pent);
        }
    }
    return rv;
}

/*
 * Function:
 *      _bcm_phy_cb_xlate_port
 * Description:
 *      Provides port translation for API call-backs
 * Parameter:
 *      unit -- unit number
 *      port -- port number to be translated
 * Returns:
 *      SOC_E_xxx
 */
STATIC int
_bcm_phy_cb_xlate_port(int unit, int *port)
{
    BCM_API_XLATE_PORT_P2A(unit, port);

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_autoneg_advert_remote_get
 * Purpose:
 *      Main part of bcm_port_advert_get_remote
 */

STATIC int
_bcm_port_autoneg_advert_remote_get(int unit, bcm_port_t port,
                            bcm_port_ability_t *ability_mask)
{
    int                 an, an_done;

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    SOC_IF_ERROR_RETURN
        (soc_phyctrl_auto_negotiate_get(unit,  port,
                                &an, &an_done));

    if (an && an_done) {
        SOC_IF_ERROR_RETURN
            (soc_phyctrl_ability_remote_get(unit, port, ability_mask));
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_ability_local_get
 * Purpose:
 *      Main part of bcm_port_ability_local_get
 */

STATIC int
_bcm_port_ability_local_get(int unit, bcm_port_t port,
                           bcm_port_ability_t *ability_mask)
{
    soc_port_ability_t             mac_ability, phy_ability;
    soc_pa_encap_t                 encap_ability;
#ifdef BCM_TRIUMPH3_SUPPORT
    int lanes;
#endif
#ifdef INCLUDE_MACSEC
    phy_ctrl_t         *ext_pc;
    ext_pc = EXT_PHY_SW_STATE(unit, port);
#endif /* INCLUDE_MACSEC */
    sal_memset(&phy_ability, 0, sizeof(soc_port_ability_t));
    sal_memset(&mac_ability, 0, sizeof(soc_port_ability_t));

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    SOC_IF_ERROR_RETURN
        (soc_phyctrl_ability_local_get(unit, port, &phy_ability));

    if (!(IS_TDM_PORT(unit, port))) {
        SOC_IF_ERROR_RETURN
            (MAC_ABILITY_LOCAL_GET(PORT(unit, port).p_mac, unit,
                                   port, &mac_ability));
    }

    /* Combine MAC and PHY abilities */

#ifdef INCLUDE_MACSEC
    /*
	   MACSEC phys have their own MAC. If macsec is enabled,
       phy's MAC is used for MAC operation on the line side.
       Check added to use half duplex ability of phy/MAC.
    */
    if((NULL != ext_pc) && ext_pc->macsec_enable) {
        ability_mask->speed_half_duplex = phy_ability.speed_half_duplex;
    } else
#endif /* INCLUDE_MACSEC */
    {
        ability_mask->speed_half_duplex =
            mac_ability.speed_half_duplex & phy_ability.speed_half_duplex;
    }
    ability_mask->speed_full_duplex =
        mac_ability.speed_full_duplex & phy_ability.speed_full_duplex;
    ability_mask->pause     = mac_ability.pause & phy_ability.pause;
    if (phy_ability.interface == 0) {
        ability_mask->interface = mac_ability.interface;
    } else {
        ability_mask->interface = phy_ability.interface;
    }
    ability_mask->medium    = phy_ability.medium;
    ability_mask->channel   = phy_ability.channel;
    ability_mask->fec       = phy_ability.fec;
    /* mac_ability.eee without phy_ability.eee makes no sense */
    ability_mask->eee    = phy_ability.eee;
    ability_mask->loopback  = mac_ability.loopback | phy_ability.loopback |
                               BCM_PORT_ABILITY_LB_NONE;
    ability_mask->flags     = mac_ability.flags | phy_ability.flags;

    /* Get port encapsulation ability */
    encap_ability = mac_ability.encap;

    if ((soc_feature(unit, soc_feature_embedded_higig))
        && IS_E_PORT(unit, port)) {
        encap_ability |= BCM_PA_ENCAP_HIGIG2_L2;
        encap_ability |= BCM_PA_ENCAP_HIGIG2_IP_GRE;
    }

#if defined(BCM_RAPTOR_SUPPORT)
    if ((SOC_IS_RAPTOR(unit) || SOC_IS_RAVEN(unit)) &&
        IS_S_PORT(unit, port)) {
        encap_ability |= BCM_PA_ENCAP_HIGIG2;
        /* should be HiGig-Lite, not Higig2 */
        encap_ability |= BCM_PA_ENCAP_HIGIG2_LITE;
    }
#endif

#ifdef BCM_TRIUMPH2_SUPPORT
   if (IS_HL_PORT(unit, port) && (SOC_IS_APOLLO(unit) ||
                                  SOC_IS_TRIUMPH2(unit) ||
                                  SOC_IS_VALKYRIE2(unit))) {
       /* HiGig-Lite port */
       encap_ability |= BCM_PA_ENCAP_HIGIG2_LITE;
   }
#endif

    if (IS_HL_PORT(unit, port) &&
         (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANEX(unit) ||
          SOC_IS_KATANA2(unit) )) {
        encap_ability |= BCM_PA_ENCAP_HIGIG2;
        /* should be HiGig-Lite, not Higig2 */
        encap_ability |= BCM_PA_ENCAP_HIGIG2_LITE;
    }

#ifdef BCM_GREYHOUND_SUPPORT
    if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
        SOC_IS_GREYHOUND2(unit)) {
        if (IS_HL_PORT(unit, port)) {
            encap_ability |= BCM_PA_ENCAP_HIGIG2;
            encap_ability |= BCM_PA_ENCAP_HIGIG2_LITE;
        } else if (IS_HG_PORT(unit, port)) {
            encap_ability |= BCM_PA_ENCAP_HIGIG;
        }
    }
#endif /* BCM_GREYHOUND_SUPPORT */

#if defined (BCM_HURRICANE_SUPPORT)
    if (IS_XQ_PORT(unit, port) && SOC_IS_HURRICANEX(unit) && (CMDEV(unit).dev.rev_id == BCM56142_A0_REV_ID) ) {
        ability_mask->speed_half_duplex &= ~(BCM_PORT_ABILITY_100MB);
        ability_mask->speed_full_duplex &= ~(BCM_PORT_ABILITY_100MB);
    }
#endif

#if defined (BCM_TRIUMPH3_SUPPORT)
   if (SOC_IS_TRIUMPH3(unit) && !SOC_IS_HELIX4(unit) &&
       (_tr3_port_config_id[unit] == 112 || _tr3_port_config_id[unit] == 12) &&
       (port == 54 || port == 55)) {
        if (IS_XE_PORT(unit, port)) {
            BCM_IF_ERROR_RETURN(_bcm_tr3_port_lanes_get(unit, port, &lanes));
            if (lanes == 1) {
                /* In one lanes mode, only support 100Mbps&1000Mbps */
                ability_mask->speed_full_duplex =  (BCM_PORT_ABILITY_100MB|BCM_PORT_ABILITY_1000MB);
            } else if (lanes == 4) {
                /* In four lanes mode, remove the 100Mbps&1000Mbps ability */
                ability_mask->speed_full_duplex &=  ~(BCM_PORT_ABILITY_100MB|BCM_PORT_ABILITY_1000MB);
            }
        }
    }
#endif

#ifdef BCM_SABER2_SUPPORT
   if (SOC_IS_SABER2(unit)) {
        if (IS_XE_PORT(unit, port) && IS_MXQ_PORT(unit, port)) {
                /*  XE port, only support 10Gbps */
                ability_mask->speed_full_duplex =  (BCM_PORT_ABILITY_10GB);
       }
   }
#endif

    ability_mask->encap = encap_ability;
    return BCM_E_NONE;
}

int
bcm_esw_port_lport_prof_src_check(int unit, int port_type, int *src_tbl_is_stm)
{
    int rv = BCM_E_NONE;
#if defined(CANCUN_SUPPORT)
    if (soc_feature(unit, soc_feature_cancun)) {
        if (src_tbl_is_stm != NULL) {
            switch (port_type) {
                case _BCM_ESW_PT_COE:
                case _BCM_ESW_PT_HGPROXY:
                    *src_tbl_is_stm = 1;
                    break;
                default:
                    *src_tbl_is_stm = 0;
                    break;
            }
        }
    }
#endif
    return rv;
}

#ifdef BCM_TRIUMPH2_SUPPORT
/*
 * Function:
 *      bcm_esw_port_lport_profile_recover
 * Description:
 *      Recovers the LPORT profile reference count in the
 *      Source Trunk Map Table.
 * Parameters:
 *      unit        - (IN) Device number
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Note:
 *     - Called when LPORT profile is supported.
 */
STATIC int
bcm_esw_port_lport_profile_recover(int unit)
{
    int rv = BCM_E_NONE;
#ifdef BCM_TOMAHAWK3_SUPPORT
    int entries_per_pipe;
#endif
#if defined(BCM_TRX_SUPPORT)
    int i, m;
    uint32 lport_index;
    soc_mem_t src_mem[2] = {SOURCE_TRUNK_MAP_TABLEm, INVALIDm};
    int entry_count;
    int table_sz;
    uint32 *src_table;
    uint32 *src_entry;
    uint32 rtag7_index;
    lport_tab_entry_t lport_entry;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_MEM_IS_VALID(unit, ING_DEVICE_PORTm)) {
        src_mem[1] = ING_DEVICE_PORTm;
    }

    for (m = 0; m < 2; m++) {
        if (src_mem[m] == INVALIDm) {
            continue;
        }

        /* Alloc DMA memory */
        entry_count = soc_mem_index_count(unit, src_mem[m]);
        table_sz = SOC_MEM_TABLE_BYTES(unit, src_mem[m]);
        src_table = soc_cm_salloc(unit, table_sz, "LPORT index recover\n");
        if (src_table == NULL) {
            return BCM_E_MEMORY;
        }
        sal_memset(src_table, 0, table_sz);

        /* DMA Read */
        rv = soc_mem_read_range(unit, src_mem[m], MEM_BLOCK_ANY,
                                soc_mem_index_min(unit, src_mem[m]),
                                soc_mem_index_max(unit, src_mem[m]),
                                src_table);
        /* Recover LPORT index reference count from Source Trunk Map table */
        if (BCM_SUCCESS(rv)) {
            for (i = 0; i < entry_count; i++) {
                src_entry =
                    soc_mem_table_idx_to_pointer(unit, src_mem[m], void *,
                                                 src_table, i);
                lport_index = soc_mem_field32_get(unit, src_mem[m], src_entry,
                                                  LPORT_PROFILE_IDXf);

                if (soc_feature(unit, soc_feature_separate_ing_lport_rtag7_profile)) {
                    rv = _bcm_lport_ind_profile_mem_reference(unit, lport_index, 1);
                    if (BCM_FAILURE(rv)) {
                        break;
                    }
                    rv = READ_LPORT_TABm(unit, MEM_BLOCK_ANY, lport_index, &lport_entry);
                    if (BCM_FAILURE(rv)) {
                        break;
                    }
                    rtag7_index = soc_LPORT_TABm_field32_get(
                            unit, &lport_entry, RTAG7_PORT_PROFILE_INDEXf);
                    rv = _bcm_rtag7_ind_profile_mem_reference(unit, rtag7_index, 1);

                } else {
#ifdef BCM_TOMAHAWK3_SUPPORT
                    if (SOC_MEM_UNIQUE_ACC(unit, LPORT_TABm)) {
                        entries_per_pipe = SOC_MEM_SIZE(unit, LPORT_TABm);
                        rv = _bcm_lport_profile_mem_reference_unique(unit, lport_index,
                                                                1, i/entries_per_pipe);
                    } else
#endif
                    {
                        rv = _bcm_lport_profile_mem_reference(unit, lport_index, 1);
                    }
                }
                if (BCM_FAILURE(rv)) {
                    break;
                }
            }
        }

        soc_cm_sfree(unit, src_table);
        if (BCM_FAILURE(rv)) {
            break;
        }
    }

#endif /* BCM_TRX_SUPPORT */

    return rv;
}

STATIC int
_bcm_td3_port_egr_lport_profile_recover(int unit)
{
    int rv = BCM_E_NONE;
    int i, m;
    uint32 egr_lport_index;
    soc_mem_t ep_mem[2] = {EGR_GPP_ATTRIBUTESm, INVALIDm};
    int ega_num_entries;
    int ega_table_size;
    void *ep_tbl;
    void *ep_ent;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_IS_TRIDENT3X(unit)) {
        ep_mem[1] = EGR_PORTm;
    }

    /* Alloc DMA memory */
    for (m = 0; m < 2; m++) {
        if (ep_mem[m] == INVALIDm) {
            continue;
        }
        ega_num_entries = soc_mem_index_count(unit, ep_mem[m]);
        ega_table_size = soc_mem_entry_words(unit, ep_mem[m]) * 4 * ega_num_entries;
        ep_tbl = soc_cm_salloc(unit, ega_table_size,
                                  "EGA for EGR LPORT index recover\n");
        if (ep_tbl == NULL) {
            return BCM_E_MEMORY;
        }
        sal_memset(ep_tbl, 0, ega_table_size);

        /* DMA Read */
        rv = soc_mem_read_range(unit, ep_mem[m], MEM_BLOCK_ANY,
                                soc_mem_index_min(unit, ep_mem[m]),
                                soc_mem_index_max(unit, ep_mem[m]),
                                ep_tbl);
        /* Recover EGR LPORT index reference count from EGR GPP Attributes table */
        if (SOC_SUCCESS(rv)) {
            for (i = 0; i < ega_num_entries; i++) {
                ep_ent =
                    soc_mem_table_idx_to_pointer(unit, ep_mem[m],
                                                 void *, ep_tbl, i);
                egr_lport_index =
                    soc_mem_field32_get(unit, ep_mem[m], ep_ent, EGR_LPORT_PROFILE_IDXf);
                rv = _bcm_egr_lport_profile_mem_reference(unit, egr_lport_index, 1);
                if (BCM_FAILURE(rv)) {
                    break;
                }
            }
        }

        soc_cm_sfree(unit, ep_tbl);

        if (BCM_FAILURE(rv)) {
            break;
        }
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_egr_lport_profile_recover
 * Description:
 *      Recovers the EGR LPORT profile reference count in the
 *      EGR GPP Attributes Table.
 * Parameters:
 *      unit        - (IN) Device number
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Note:
 *     - Called when EGR LPORT profile is supported.
 */
STATIC int
bcm_esw_port_egr_lport_profile_recover(int unit)
{
    int rv = BCM_E_NONE;
    int i;
    uint32 egr_lport_index;
    soc_mem_t ega_mem;
    int ega_num_entries;
    int ega_table_size;
    egr_gpp_attributes_entry_t *ega_table;
    egr_gpp_attributes_entry_t *ega_entry;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_IS_TRIDENT3X(unit)) {
        return _bcm_td3_port_egr_lport_profile_recover(unit);
    }

    /* Alloc DMA memory */
    ega_mem = EGR_GPP_ATTRIBUTESm;
    ega_num_entries = soc_mem_index_count(unit, ega_mem);
    ega_table_size = sizeof(egr_gpp_attributes_entry_t ) * ega_num_entries;
    ega_table = soc_cm_salloc(unit, ega_table_size,
                              "EGA for EGR LPORT index recover\n");
    if (ega_table == NULL) {
        return BCM_E_MEMORY;
    }
    sal_memset(ega_table, 0, ega_table_size);

    /* DMA Read */
    rv = soc_mem_read_range(unit, ega_mem, MEM_BLOCK_ANY,
                            soc_mem_index_min(unit, ega_mem),
                            soc_mem_index_max(unit, ega_mem),
                            ega_table);

    /* Recover EGR LPORT index reference count from EGR GPP Attributes table */
    if (SOC_SUCCESS(rv)) {
        for (i = 0; i < ega_num_entries; i++) {
            ega_entry =
                soc_mem_table_idx_to_pointer(unit, ega_mem,
                                             egr_gpp_attributes_entry_t *,
                                             ega_table, i);
            egr_lport_index =
                soc_EGR_GPP_ATTRIBUTESm_field32_get(unit, ega_entry,
                                                        EGR_LPORT_PROFILE_IDXf);
            rv = _bcm_egr_lport_profile_mem_reference(unit, egr_lport_index, 1);
            if (BCM_FAILURE(rv)) {
                break;
            }
        }
    }

    soc_cm_sfree(unit, ega_table);

    return rv;
}
#endif /* BCM_TRIUMPH2_SUPPORT */

int
bcm_esw_port_egr_lport_prof_src_get(int unit,
    bcm_module_t modid, bcm_port_t port, int *src_tbl_is_gpp)
{
    int rv = BCM_E_NONE;
#if defined(INCLUDE_XFLOW_MACSEC) && defined(BCM_HURRICANE4_SUPPORT)
    bcm_xflow_macsec_port_info_t port_info;
    port_info.enable = 0;
#endif

#if defined(CANCUN_SUPPORT)
    bcm_gport_t gport;

    if (soc_feature(unit, soc_feature_cancun)) {
        soc_mem_t pfs_mem = EGR_PKT_FLOW_SELECT_TCAMm;

        gport = _bcm_esw_port_gport_get_from_modport(unit, modid, port);
        /* COE flows use the port attrs from the EGR_GPP_ATTRIBUTES
           table, rest all flows use the EGR_PORT table */
        if (_BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, gport)) {
            *src_tbl_is_gpp = 1;
#if defined(INCLUDE_XFLOW_MACSEC) && defined(BCM_HURRICANE4_SUPPORT)
        } else if (SOC_IS_HURRICANE4(unit) && soc_feature(unit, soc_feature_xflow_macsec) &&
       (BCM_E_NONE == bcm_common_xflow_macsec_port_info_get(unit, port, &port_info)) &&
       (port_info.enable == 1)) {
            *src_tbl_is_gpp = 1;
#endif
        } else if (SOC_MEM_IS_VALID(unit, pfs_mem)) {
            *src_tbl_is_gpp = 0;
        }
    }
#endif

    return rv;
}

#if defined(BCM_TRX_SUPPORT)
/*
 * Function:
 *      bcm_esw_port_separate_lport_rtag7_profile_fields_set
 * Description:
 *      Sets the fields in the LPORT Profile Table and updates
 *      the corresponding reference index in the Source Trunk Map Table.
 * Parameters:
 *      unit        - (IN) Device number
 *      modid       - (IN) Module number for port
 *      port        - (IN) Port number (NON gport)
 *      table_id    - (IN) Index of table to modify, LPORT or RTAG7
 *      field_count - (IN) Number of fields to modify
 *      fields      - (IN) Array of fields to modify
 *      values      - (IN) Array of new field values
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Note:
 *     - Assumes: lock,
 *                valid bcm module id and port number,
 *                valid table id,
 *                valid HW fields.
 *     - Called when LPORT profile is supported.
 *     - Helper routine for bcm_esw_port_lport_fields_set();
 *       callers should be calling bcm_esw_port_lport_fields_set() instead.
 */
STATIC int
bcm_esw_port_separate_lport_rtag7_profile_fields_set(int unit, int port_type,
                                      bcm_module_t modid, bcm_port_t port,
                                      int table_id, int field_count,
                                      soc_field_t *fields, uint32 *values)
{
    int i, rv;
    int src_index;
    uint32 src_ent[SOC_MAX_MEM_FIELD_WORDS];
    lport_tab_entry_t lport_entry;
    rtag7_port_based_hash_entry_t  rtag7_entry;
    uint32 lport_index, rtag7_index, old_lport_index, old_rtag7_index = 0;
    soc_mem_t mem;
    void *entries[2], *entry;

    int src_tbl_is_stm = 1;
    soc_mem_t src_mem = SOURCE_TRUNK_MAP_TABLEm;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN
        (bcm_esw_port_lport_prof_src_check(unit, port_type, &src_tbl_is_stm));
    if (!src_tbl_is_stm) {
        src_mem = ING_DEVICE_PORTm;
    }

    soc_mem_lock(unit, src_mem);

    if (src_tbl_is_stm) {
        rv = _bcm_esw_src_mod_port_table_index_get(unit, modid, port,
                                                   &src_index);
        if (BCM_FAILURE(rv)) {
            soc_mem_unlock(unit, src_mem);
            return rv;
        }
    } else {
        src_index = port;
    }

    rv = soc_mem_read(unit, src_mem, MEM_BLOCK_ANY, src_index, src_ent);
    if (BCM_FAILURE(rv)) {
        soc_mem_unlock(unit, src_mem);
        return rv;
    }

    old_lport_index =
        soc_mem_field32_get(unit, src_mem, src_ent, LPORT_PROFILE_IDXf);

    if (table_id == LPORT_PROFILE_RTAG7_TAB) {

        /* Get the associated LPORT entry */
        rv = READ_LPORT_TABm(unit, MEM_BLOCK_ANY, old_lport_index,
                             &lport_entry);
        if(BCM_FAILURE(rv)) {
            soc_mem_unlock(unit, src_mem);
            return rv;
        }

        /* Get the current RTAG7 index from there */
        old_rtag7_index =
            soc_LPORT_TABm_field32_get(unit, &lport_entry,
                                                    RTAG7_PORT_PROFILE_INDEXf);
    }

    if (table_id == LPORT_PROFILE_LPORT_TAB) {
        entries[0] = &lport_entry;
        rv = _bcm_lport_ind_profile_entry_get(unit, old_lport_index,
                                              1, entries);
    } else {
        entries[0] = &rtag7_entry;
        rv = _bcm_rtag7_ind_profile_entry_get(unit, old_rtag7_index,
                                              1, entries);
    }

    if(BCM_FAILURE(rv)) {
        soc_mem_unlock(unit, src_mem);
        return rv;
    }

    /* Update fields */
    entry = entries[0];
    if (table_id == LPORT_PROFILE_LPORT_TAB) {
        mem = LPORT_TABm;
    } else if (table_id == LPORT_PROFILE_RTAG7_TAB) {
        mem = RTAG7_PORT_BASED_HASHm;
    } else {
        soc_mem_unlock(unit, src_mem);
        return BCM_E_INTERNAL;
    }

    for (i = 0; i < field_count; i++) {
        soc_mem_field32_set(unit, mem, entry, fields[i], values[i]);
    }

    /* Note that when 'soc_feature_separate_ing_lport_rtag7_profiling' is in
       effect, the LPORT and RTAG7 tables are profiled separately, due to which
       we will be making separate calls and not a generic single call like
       earlier */
    if (table_id == LPORT_PROFILE_LPORT_TAB) {

#ifdef BCM_MONTEREY_SUPPORT
        if (SOC_IS_MONTEREY(unit)) {
            soc_mem_field32_set(unit, mem, entry, MISC_PORT_PROFILE_INDEXf, port);
        }
#endif

        rv = _bcm_lport_ind_profile_entry_add(unit, entries, 1, &lport_index);

    } else {
        rv = _bcm_rtag7_ind_profile_entry_add(unit, entries, 1, &rtag7_index);
    }

    if(BCM_FAILURE(rv)) {
        soc_mem_unlock(unit, src_mem);
        return rv;
    }

    if (table_id == LPORT_PROFILE_LPORT_TAB) {
        /* Update Source Table LPORT profile index  */
        soc_mem_field32_set(unit, src_mem, src_ent, LPORT_PROFILE_IDXf,
                            lport_index);
        rv = soc_mem_write(unit, src_mem, MEM_BLOCK_ALL, src_index, src_ent);
    } else {
        /* Write to the LPORT table here */
        soc_LPORT_TABm_field32_set(unit, &lport_entry, RTAG7_PORT_PROFILE_INDEXf,
                                         rtag7_index);
        if (SOC_IS_TRIDENT3X(unit)) {
            entries[0] = &lport_entry;
            rv = _bcm_lport_ind_profile_entry_add(unit, entries, 1, &lport_index);

            if(BCM_FAILURE(rv)) {
               soc_mem_unlock(unit, src_mem);
               return rv;
            }
            /* Update Source Table LPORT profile index  */
            soc_mem_field32_set(unit, src_mem, src_ent, LPORT_PROFILE_IDXf,
                                lport_index);
            rv = soc_mem_write(unit, src_mem, MEM_BLOCK_ALL,
                               src_index, src_ent);
        } else {
            rv = WRITE_LPORT_TABm(unit, MEM_BLOCK_ANY, old_lport_index, &lport_entry);
        }
    }

    soc_mem_unlock(unit, src_mem);
    if(BCM_FAILURE(rv)) {
        return rv;
    }
#if defined(INCLUDE_XFLOW_MACSEC) && defined(BCM_HURRICANE4_SUPPORT)
    if (SOC_IS_HURRICANE4(unit) &&
        (port_type == _BCM_ESW_PT_MACSEC_PORT)) {
        /* Also update STM LPORT profile index  */
        src_mem = SOURCE_TRUNK_MAP_TABLEm;
        soc_mem_lock(unit, src_mem);
        rv = _bcm_esw_src_mod_port_table_index_get(unit, modid, port, &src_index);
        if (BCM_FAILURE(rv)) {
            soc_mem_unlock(unit, src_mem);
            return rv;
        }
        rv = soc_mem_read(unit, src_mem, MEM_BLOCK_ANY, src_index, src_ent);
        if (BCM_FAILURE(rv)) {
            soc_mem_unlock(unit, src_mem);
            return rv;
        }
        if (old_lport_index != lport_index) {
            soc_mem_field32_set(unit, src_mem, src_ent,
                                LPORT_PROFILE_IDXf, lport_index);
            rv = soc_mem_write(unit, src_mem, MEM_BLOCK_ALL,
                               src_index, src_ent);
        }
        soc_mem_unlock(unit, src_mem);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
    }
#endif

    /*
     * Entry must be 'deleted' because the mem profile 'add' routine
     * always increments count even though the same entry is used.
     */
    if (table_id == LPORT_PROFILE_LPORT_TAB) {
        BCM_IF_ERROR_RETURN
            (_bcm_lport_ind_profile_entry_delete(unit, old_lport_index));

    } else {
        if (SOC_IS_TRIDENT3X(unit)) {
            BCM_IF_ERROR_RETURN
                  (_bcm_lport_ind_profile_entry_delete(unit, old_lport_index));
        }
        BCM_IF_ERROR_RETURN
            (_bcm_rtag7_ind_profile_entry_delete(unit, old_rtag7_index));
    }

    return BCM_E_NONE;
}
#endif /* BCM_TRX_SUPPORT */

/*
 * Function:
 *      bcm_esw_port_lport_profile_fields_set
 * Description:
 *      Sets the fields in the LPORT Profile Table and updates
 *      the corresponding reference index in the Source Trunk Map Table.
 * Parameters:
 *      unit        - (IN) Device number
 *      modid       - (IN) Module number for port
 *      port        - (IN) Port number (NON gport)
 *      table_id    - (IN) Index of table to modify, LPORT or RTAG7
 *      field_count - (IN) Number of fields to modify
 *      fields      - (IN) Array of fields to modify
 *      values      - (IN) Array of new field values
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Note:
 *     - Assumes: lock,
 *                valid bcm module id and port number,
 *                valid table id,
 *                valid HW fields.
 *     - Called when LPORT profile is supported.
 *     - Helper routine for bcm_esw_port_lport_fields_set();
 *       callers should be calling bcm_esw_port_lport_fields_set() instead.
 */
STATIC int
bcm_esw_port_lport_profile_fields_set(int unit, int port_type,
                                      bcm_module_t modid, bcm_port_t port,
                                      int table_id, int field_count,
                                      soc_field_t *fields, uint32 *values)
{
#if defined(BCM_TRX_SUPPORT)
    int i;
    int src_index;
    uint32 src_ent[SOC_MAX_MEM_FIELD_WORDS];
    int src_tbl_is_stm = 1;
    soc_mem_t src_mem = SOURCE_TRUNK_MAP_TABLEm;
    lport_tab_entry_t lport_entry;
    rtag7_port_based_hash_entry_t  rtag7_entry;
    uint32 lport_index, old_lport_index;
    void *entries[2];
    soc_mem_t mem;
    void *entry;
    int rv;
    int pipe = 0;
    int num_entries_per_pipe = 0;

    if (soc_feature(unit, soc_feature_separate_ing_lport_rtag7_profile)) {
        return bcm_esw_port_separate_lport_rtag7_profile_fields_set(unit,
                    port_type, modid, port, table_id, field_count,
                    fields, values);
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN
        (bcm_esw_port_lport_prof_src_check(unit, port_type, &src_tbl_is_stm));
#if defined(CANCUN_SUPPORT)
    if (soc_feature(unit, soc_feature_cancun) && src_tbl_is_stm == 0) {
        src_mem = ING_DEVICE_PORTm;
    }
#endif

    soc_mem_lock(unit, src_mem);

    /* Get LPORT profile index Source table */
    if (src_tbl_is_stm) {
        rv = _bcm_esw_src_mod_port_table_index_get(unit, modid, port, &src_index);
        if (BCM_FAILURE(rv)) {
            soc_mem_unlock(unit, src_mem);
            return rv;
        }
    } else {
        src_index = port;
    }

    rv = soc_mem_read(unit, src_mem, MEM_BLOCK_ANY, src_index, src_ent);
    if (BCM_FAILURE(rv)) {
        soc_mem_unlock(unit, src_mem);
        return rv;
    }

    old_lport_index =
        soc_mem_field32_get(unit, src_mem, src_ent, LPORT_PROFILE_IDXf);

    /* Get LPORT profile entry */
    entries[0] = &lport_entry;
    entries[1] = &rtag7_entry;

    /* Tomahawk 3 split this memory into a per pipe unique access,
     * so it is indexed in SOURCE_TRUNK_MAP on a per pipe basis */
    if (SOC_MEM_UNIQUE_ACC(unit, LPORT_TABm)) {
        pipe = SOC_INFO(unit).port_pipe[src_index];
        mem = SOC_MEM_UNIQUE_ACC(unit, LPORT_TABm)[pipe];
        num_entries_per_pipe = SOC_MEM_SIZE(unit, mem);

        /* the profile cache is stored in one large logical table (all the pipes
         * put together), so we need to index into the pipe being used so that
         * we can access the index of that one big logical table */
        old_lport_index += pipe*num_entries_per_pipe;
    }

    rv = _bcm_lport_profile_entry_get(unit, old_lport_index, 1, entries);
    if (BCM_FAILURE(rv)) {
        soc_mem_unlock(unit, src_mem);
        return rv;
    }

    /* Update fields */
    if (table_id == LPORT_PROFILE_LPORT_TAB) {
        mem = LPORT_TABm;
        entry = entries[0];
    } else if (table_id == LPORT_PROFILE_RTAG7_TAB) {
        mem = RTAG7_PORT_BASED_HASHm;
        entry = entries[1];
    } else {
        soc_mem_unlock(unit, src_mem);
        return BCM_E_INTERNAL;
    }

    for (i = 0; i < field_count; i++) {
        soc_mem_field32_set(unit, mem, entry, fields[i], values[i]);
    }

    /* Tomahawk 3 split this memory into a per pipe unique access,
     * so it must be handled differently */
    if (SOC_MEM_UNIQUE_ACC(unit, LPORT_TABm)) {
        /* Restore the old_lport_index to its per pipe index because the call
         * below to entry_add_unique will get its lport_index based on a per
         * pipe index and they will be compared. */
        old_lport_index -= pipe*num_entries_per_pipe;

        rv = _bcm_lport_profile_entry_add_unique(unit, entries, 1, pipe, &lport_index);
    } else {
        rv = _bcm_lport_profile_entry_add(unit, entries, 1, &lport_index);
    }
    if(BCM_FAILURE(rv)) {
        soc_mem_unlock(unit, src_mem);
        return rv;
    }

    /* Update STM LPORT profile index  */
    if (old_lport_index != lport_index) {
        soc_mem_field32_set(unit, src_mem, src_ent,
                            LPORT_PROFILE_IDXf, lport_index);
        rv = soc_mem_write(unit, src_mem, MEM_BLOCK_ALL,
                           src_index, src_ent);
    }

    soc_mem_unlock(unit, src_mem);
    if (BCM_FAILURE(rv)) {
        return rv;
    }
    /*
     * Entry must be 'deleted' because the mem profile 'add' routine
     * always increments count even though the same entry is used.
     */
    if (SOC_MEM_UNIQUE_ACC(unit, LPORT_TABm)) {
        BCM_IF_ERROR_RETURN
            (_bcm_lport_profile_entry_delete_unique(unit, old_lport_index, pipe));
    } else {
        BCM_IF_ERROR_RETURN
            (_bcm_lport_profile_entry_delete(unit, old_lport_index));
    }

    return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif /* BCM_TRX_SUPPORT */
}

/*
 * Function:
 *      bcm_esw_port_egr_lport_profile_fields_set
 * Description:
 *      Sets the fields in the EGR_LPORT Profile Table and updates
 *      the corresponding reference index in the Source Trunk Map Table.
 * Parameters:
 *      unit        - (IN) Device number
 *      modid       - (IN) Module number for port
 *      port        - (IN) Port number (NON gport)
 *      mem         - (IN) Table to modify
 *      field_count - (IN) Number of fields to modify
 *      fields      - (IN) Array of fields to modify
 *      values      - (IN) Array of new field values
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Note:
 *     - Assumes: lock,
 *                valid bcm module id and port number,
 *                valid table id,
 *                valid HW fields.
 *     - Called when EGR_LPORT profile is supported.
 *     - Helper routine for bcm_esw_port_egr_lport_fields_set();
 *       callers should be calling bcm_esw_port_egr_lport_fields_set() instead.
 */
STATIC int
bcm_esw_port_egr_lport_profile_fields_set(int unit,
                                      bcm_module_t modid, bcm_port_t port,
                                      soc_mem_t mem, int field_count,
                                      soc_field_t *fields, uint32 *values)
{
#if defined(BCM_TRX_SUPPORT)
    int i, index;
    int egr_gpp_index = 0;
    egr_gpp_attributes_entry_t egr_gpp_entry;
    egr_lport_profile_entry_t egr_lport_entry;
    egr_vlan_control_1_entry_t egr_vlan_control_1;
    egr_vlan_control_2_entry_t egr_vlan_control_2;
    egr_vlan_control_3_entry_t egr_vlan_control_3;
    egr_ipmc_cfg2_entry_t egr_ipmc_cfg2;
    egr_mtu_entry_t egr_mtu;
    egr_port_1_entry_t egr_port_1;
    egr_counter_control_entry_t egr_counter_control;
    egr_shaping_control_entry_t egr_shaping_control;
    egr_port_entry_t egr_port;
    uint32 egr_lport_index, old_egr_lport_index;
    void *entries[_BCM_EGR_LPROF_MEM_COUNT];
    void *entry;
    int use_gpp_index = 1;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (mem == EGR_GPP_ATTRIBUTESm) {
        BCM_IF_ERROR_RETURN
            (_bcm_esw_src_mod_port_table_index_get(unit, modid, port,
                                                   &egr_gpp_index));
        BCM_IF_ERROR_RETURN
            (READ_EGR_GPP_ATTRIBUTESm(unit, MEM_BLOCK_ANY,
                                      egr_gpp_index, &egr_gpp_entry));
        for (i = 0; i < field_count; i++) {
            soc_mem_field32_set(unit, EGR_GPP_ATTRIBUTESm,
                                &egr_gpp_entry, fields[i], values[i]);
        }
        BCM_IF_ERROR_RETURN
            (WRITE_EGR_GPP_ATTRIBUTESm(unit, MEM_BLOCK_ALL,
                                       egr_gpp_index, &egr_gpp_entry));

        return BCM_E_NONE;
    }

    BCM_IF_ERROR_RETURN(
        bcm_esw_port_egr_lport_prof_src_get(unit, modid, port, &use_gpp_index));

    if (use_gpp_index) {
        /* Get LPORT profile index Source Trunk Map table */
        BCM_IF_ERROR_RETURN
            (_bcm_esw_src_mod_port_table_index_get(unit, modid, port,
                                                   &egr_gpp_index));
        BCM_IF_ERROR_RETURN
            (READ_EGR_GPP_ATTRIBUTESm(unit, MEM_BLOCK_ANY,
                                      egr_gpp_index, &egr_gpp_entry));
        old_egr_lport_index =
            soc_EGR_GPP_ATTRIBUTESm_field32_get(unit, &egr_gpp_entry,
                                                EGR_LPORT_PROFILE_IDXf);
    } else {
        BCM_IF_ERROR_RETURN
            (READ_EGR_PORTm(unit, MEM_BLOCK_ANY, port, &egr_port));
        old_egr_lport_index =
            soc_mem_field32_get(unit, EGR_PORTm, &egr_port,
                                EGR_LPORT_PROFILE_IDXf);
    }

    /* Get LPORT profile entry */
    index = 0;
    if (SOC_MEM_IS_VALID(unit, EGR_LPORT_PROFILEm)) {
        entries[index++] = &egr_lport_entry;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_VLAN_CONTROL_1m)) {
        entries[index++] = &egr_vlan_control_1;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_VLAN_CONTROL_2m)) {
        entries[index++] = &egr_vlan_control_2;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_VLAN_CONTROL_3m)) {
        entries[index++] = &egr_vlan_control_3;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_IPMC_CFG2m)) {
        entries[index++] = &egr_ipmc_cfg2;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_MTUm)) {
        entries[index++] = &egr_mtu;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_PORT_1m)) {
        entries[index++] = &egr_port_1;
    }
    if (soc_feature(unit, soc_feature_egr_all_profile) == 0) {
        if (SOC_MEM_IS_VALID(unit, EGR_COUNTER_CONTROLm)) {
            entries[index++] = &egr_counter_control;
        }
        if (SOC_MEM_IS_VALID(unit, EGR_SHAPING_CONTROLm)) {
            entries[index++] = &egr_shaping_control;
        }
    }

    BCM_IF_ERROR_RETURN
        (_bcm_egr_lport_profile_entry_get(unit, old_egr_lport_index, 1, entries));

    BCM_IF_ERROR_RETURN
        (_bcm_egr_lport_profile_mem_index_get(unit, mem, &index));
    entry = entries[index];
    /* Update fields */
    for (i = 0; i < field_count; i++) {
        soc_mem_field32_set(unit, mem, entry, fields[i], values[i]);
    }

    BCM_IF_ERROR_RETURN
        (_bcm_egr_lport_profile_entry_add(unit, entries, 1, &egr_lport_index));

    /* Update STM LPORT profile index  */
    if (use_gpp_index) {
        soc_EGR_GPP_ATTRIBUTESm_field32_set(unit, &egr_gpp_entry,
                                            EGR_LPORT_PROFILE_IDXf,
                                            egr_lport_index);
        BCM_IF_ERROR_RETURN
            (WRITE_EGR_GPP_ATTRIBUTESm(unit, MEM_BLOCK_ANY,
                                       egr_gpp_index, &egr_gpp_entry));
    } else {
        soc_mem_field32_set(unit, EGR_PORTm, &egr_port,
                            EGR_LPORT_PROFILE_IDXf, egr_lport_index);
        BCM_IF_ERROR_RETURN
            (WRITE_EGR_PORTm(unit, MEM_BLOCK_ALL, port, &egr_port));
    }
    /*
     * Entry must be 'deleted' because the mem profile 'add' routine
     * always increments count even though the same entry is used.
     */
    if (old_egr_lport_index != 0) {
        BCM_IF_ERROR_RETURN
            (_bcm_egr_lport_profile_entry_delete(unit, old_egr_lport_index));
    }

    return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif /* BCM_TRX_SUPPORT */
}

/*
 * Function:
 *      bcm_esw_port_egr_lport_profile_clear
 * Description:
 *      Similar function as bcm_esw_port_egr_lport_profile_fields_set,
 *      for clear purpose only.
 */
STATIC int
bcm_esw_port_egr_lport_profile_clear(int unit,
                                     bcm_module_t modid, bcm_port_t port,
                                     soc_mem_t mem)
{
#if defined(BCM_TRX_SUPPORT)
    int index;
    int egr_gpp_index = 0;
    egr_gpp_attributes_entry_t egr_gpp_entry;
    egr_lport_profile_entry_t egr_lport_entry;
    egr_vlan_control_1_entry_t egr_vlan_control_1;
    egr_vlan_control_2_entry_t egr_vlan_control_2;
    egr_vlan_control_3_entry_t egr_vlan_control_3;
    egr_ipmc_cfg2_entry_t egr_ipmc_cfg2;
    egr_mtu_entry_t egr_mtu;
    egr_port_1_entry_t egr_port_1;
    egr_counter_control_entry_t egr_counter_control;
    egr_shaping_control_entry_t egr_shaping_control;
    egr_port_entry_t egr_port;
    uint32 egr_lport_index, old_egr_lport_index;
    void *entries[_BCM_EGR_LPROF_MEM_COUNT];
    void *entry;
    int ent_size[_BCM_EGR_LPROF_MEM_COUNT] = {0};
    int use_gpp_index = 1;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (mem == EGR_GPP_ATTRIBUTESm) {
        BCM_IF_ERROR_RETURN
            (_bcm_esw_src_mod_port_table_index_get(unit, modid, port,
                                                   &egr_gpp_index));
        BCM_IF_ERROR_RETURN
            (READ_EGR_GPP_ATTRIBUTESm(unit, MEM_BLOCK_ANY,
                                      egr_gpp_index, &egr_gpp_entry));
        sal_memset(&egr_gpp_entry, 0, sizeof(egr_gpp_entry));
        BCM_IF_ERROR_RETURN
            (WRITE_EGR_GPP_ATTRIBUTESm(unit, MEM_BLOCK_ALL,
                                       egr_gpp_index, &egr_gpp_entry));

        return BCM_E_NONE;
    }

    BCM_IF_ERROR_RETURN(
        bcm_esw_port_egr_lport_prof_src_get(unit, modid, port, &use_gpp_index));

    if (use_gpp_index) {
        /* Get LPORT profile index Source Trunk Map table */
        BCM_IF_ERROR_RETURN
            (_bcm_esw_src_mod_port_table_index_get(unit, modid, port,
                                                   &egr_gpp_index));
        BCM_IF_ERROR_RETURN
            (READ_EGR_GPP_ATTRIBUTESm(unit, MEM_BLOCK_ANY,
                                      egr_gpp_index, &egr_gpp_entry));
        old_egr_lport_index =
            soc_EGR_GPP_ATTRIBUTESm_field32_get(unit, &egr_gpp_entry,
                                                EGR_LPORT_PROFILE_IDXf);
    } else {
        BCM_IF_ERROR_RETURN
            (READ_EGR_PORTm(unit, MEM_BLOCK_ANY, port, &egr_port));
        old_egr_lport_index =
            soc_mem_field32_get(unit, EGR_PORTm, &egr_port,
                                EGR_LPORT_PROFILE_IDXf);
    }

    /* Get LPORT profile entry */
    index = 0;
    if (SOC_MEM_IS_VALID(unit, EGR_LPORT_PROFILEm)) {
        ent_size[index] = sizeof(egr_lport_entry);
        entries[index++] = &egr_lport_entry;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_VLAN_CONTROL_1m)) {
        ent_size[index] = sizeof(egr_vlan_control_1);
        entries[index++] = &egr_vlan_control_1;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_VLAN_CONTROL_2m)) {
        ent_size[index] = sizeof(egr_vlan_control_2);
        entries[index++] = &egr_vlan_control_2;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_VLAN_CONTROL_3m)) {
        ent_size[index] = sizeof(egr_vlan_control_3);
        entries[index++] = &egr_vlan_control_3;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_IPMC_CFG2m)) {
        ent_size[index] = sizeof(egr_ipmc_cfg2);
        entries[index++] = &egr_ipmc_cfg2;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_MTUm)) {
        ent_size[index] = sizeof(egr_mtu);
        entries[index++] = &egr_mtu;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_PORT_1m)) {
        ent_size[index] = sizeof(egr_port_1);
        entries[index++] = &egr_port_1;
    }
    if (soc_feature(unit, soc_feature_egr_all_profile) == 0) {
        if (SOC_MEM_IS_VALID(unit, EGR_COUNTER_CONTROLm)) {
            ent_size[index] = sizeof(egr_counter_control);
            entries[index++] = &egr_counter_control;
        }
        if (SOC_MEM_IS_VALID(unit, EGR_SHAPING_CONTROLm)) {
            ent_size[index] = sizeof(egr_shaping_control);
            entries[index++] = &egr_shaping_control;
        }
    }

    BCM_IF_ERROR_RETURN
        (_bcm_egr_lport_profile_entry_get(unit, old_egr_lport_index, 1, entries));

    BCM_IF_ERROR_RETURN
        (_bcm_egr_lport_profile_mem_index_get(unit, mem, &index));
    entry = entries[index];
    /* Clear fields */
    sal_memset(entry, 0, ent_size[index]);

    BCM_IF_ERROR_RETURN
        (_bcm_egr_lport_profile_entry_add(unit, entries, 1, &egr_lport_index));

    /* Update STM LPORT profile index  */
    if (use_gpp_index) {
        soc_EGR_GPP_ATTRIBUTESm_field32_set(unit, &egr_gpp_entry,
                                            EGR_LPORT_PROFILE_IDXf,
                                            egr_lport_index);
        BCM_IF_ERROR_RETURN
            (WRITE_EGR_GPP_ATTRIBUTESm(unit, MEM_BLOCK_ANY,
                                       egr_gpp_index, &egr_gpp_entry));
    } else {
        soc_mem_field32_set(unit, EGR_PORTm, &egr_port,
                            EGR_LPORT_PROFILE_IDXf, egr_lport_index);
        BCM_IF_ERROR_RETURN
            (WRITE_EGR_PORTm(unit, MEM_BLOCK_ALL, port, &egr_port));
    }
    /*
     * Entry must be 'deleted' because the mem profile 'add' routine
     * always increments count even though the same entry is used.
     */
    if (old_egr_lport_index != 0) {
        BCM_IF_ERROR_RETURN
            (_bcm_egr_lport_profile_entry_delete(unit, old_egr_lport_index));
    }

    return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif /* BCM_TRX_SUPPORT */
}

/*
 * Function:
 *      _bcm_esw_egr_port_tab_multi_set
 * Description:
 *      Function to set multiple fields in EGR port tables
 * Parameters:
 *      unit        - Device number
 *      port        - Port number
 *      field_count - Number of fields to modify
 *      fields      - Array of fields to modify
 *      values      - Array of new field values
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX - an error occurred accessing EGR_PORT table.
 */
int
_bcm_esw_egr_port_tab_multi_set(int unit, bcm_port_t port, int field_count,
        soc_field_t *fields, uint32 *values)

{
    soc_mem_t mem = EGR_PORTm;
    int rv = BCM_E_NONE, i, index;

    soc_field_t egr_port_tab_fields[SOC_MAX_MEM_FIELD_NUM];
    uint32 egr_port_tab_values[SOC_MAX_MEM_FIELD_NUM];
    int egr_port_tab_field_count = 0;
    soc_field_t egr_lport_tab_fields[SOC_MAX_MEM_FIELD_NUM];
    uint32 egr_lport_tab_values[SOC_MAX_MEM_FIELD_NUM];
    int egr_lport_tab_field_count = 0;
    soc_field_t egr_gpp_fields[SOC_MAX_MEM_FIELD_NUM];
    uint32 egr_gpp_values[SOC_MAX_MEM_FIELD_NUM];
    int egr_gpp_field_count = 0;
#if defined BCM_HGPROXY_COE_SUPPORT
    int is_lport_cfg = 0;
#endif


    if ((fields == NULL) || (values == NULL) ) {
        return BCM_E_PARAM;
    }
    if (field_count <= 0) {
        return BCM_E_NONE;
    }

#if defined BCM_HGPROXY_COE_SUPPORT
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        (soc_feature(unit, soc_feature_channelized_switching))) &&
        _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
        is_lport_cfg = 1;
    }

    if (is_lport_cfg == 1) {
        mem = EGR_LPORT_PROFILEm;
    } else
#endif
    if (BCM_GPORT_IS_SET(port)) {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    }

    for(i = 0; i < field_count; i++) {
#if defined(CANCUN_SUPPORT)
        if (SOC_IS_TRIDENT3X(unit)) {
            if (soc_cancun_cmh_check(unit, mem, fields[i]) == SOC_E_NONE) {
                rv = soc_cancun_cmh_mem_set(unit, mem, port, fields[i],
                                            values[i]);
            }
            _bcm_td3_egr_port_tab_conv(unit, &fields[i], &mem);
        }
#endif
        if (!SOC_MEM_FIELD_VALID(unit, mem, fields[i])) {
            return (SOC_E_UNAVAIL);
        }

        switch (mem) {
            case EGR_GPP_ATTRIBUTESm:
                soc_mem_set_field_value_array(egr_gpp_fields, fields[i],
                                              egr_gpp_values, values[i],
                                              egr_gpp_field_count);
                break;
            case EGR_PORTm:
                soc_mem_set_field_value_array(egr_port_tab_fields, fields[i],
                                              egr_port_tab_values, values[i],
                                              egr_port_tab_field_count);
                break;
            case EGR_LPORT_PROFILEm:
                soc_mem_set_field_value_array(egr_lport_tab_fields, fields[i],
                                              egr_lport_tab_values, values[i],
                                              egr_lport_tab_field_count);
                break;
            default:
                BCM_IF_ERROR_RETURN
                    (soc_mem_field32_modify(unit, mem, port, fields[i],
                                            values[i]));
                break;
        }
    }

#if defined BCM_HGPROXY_COE_SUPPORT
    if (is_lport_cfg == 1) { /* remote port */
        return bcm_esw_port_egr_lport_fields_set(unit, port,
                                                 EGR_LPORT_PROFILEm,
                                                 egr_lport_tab_field_count,
                                                 egr_lport_tab_fields,
                                                 egr_lport_tab_values);
    }
#endif

    index = SOC_PORT_MOD_OFFSET(unit, port);

    if (egr_port_tab_field_count) {
        rv = soc_mem_fields32_modify(unit, EGR_PORTm, index,
                                     egr_port_tab_field_count,
                                     egr_port_tab_fields, egr_port_tab_values);
    }

    if (egr_lport_tab_field_count && BCM_SUCCESS(rv)) {
        rv = bcm_esw_port_egr_lport_fields_set(unit, index,
                EGR_LPORT_PROFILEm, egr_lport_tab_field_count,
                egr_lport_tab_fields, egr_lport_tab_values);
    }

    if (egr_gpp_field_count && BCM_SUCCESS(rv)) {
        rv = bcm_esw_port_egr_lport_fields_set(unit, index,
                EGR_GPP_ATTRIBUTESm, egr_gpp_field_count,
                egr_gpp_fields, egr_gpp_values);
    }

    return rv;
}

/*
 * Function:
 *      _bcm_esw_egr_port_tab_set
 * Description:
 *      Helper funtion for bcm_esw_port_control_set.
 * Parameters:
 *      unit  - Device number
 *      port  - Port number
 *      field - Field name within EGR_PORT table entry
 *      value - new field value
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX - an error occurred accessing EGR_PORT table.
 */
int
_bcm_esw_egr_port_tab_set(int unit, bcm_port_t port,
        soc_field_t field, uint32 value)

{
    return (_bcm_esw_egr_port_tab_multi_set(unit, port, 1, &field, &value));
}

/*
 * Function:
 *      _bcm_esw_egr_port_tab_get
 * Description:
 *      Helper funtion for bcm_esw_port_control_get.
 * Parameters:
 *      unit  - Device number
 *      port  - Port number
 *      field - Field name within PORT_TAB table entry
 *      value - (OUT) field value
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX - an error occurred accessing PORT_TAB table.
 * Notes:
 *      Due to the large number of callers for this routine,
 *      function is expanded to take a GPORT PROXY, which
 *      get the property from the LPORT profile table.
 *
 *      Current valid port types are:
 *          GPORT SUBPORT
 *          BCM port (non-gport), assumes a valid local physical port
 */

int
_bcm_esw_egr_port_tab_get(int unit, bcm_port_t port,
                          soc_field_t field, int *value)
{
    int rv = BCM_E_UNAVAIL;
    egr_port_entry_t pent;
    soc_mem_t mem;
    int index, is_lport_cfg = 0, is_gpp_attr = 0;
    uint32 value32;

    mem = EGR_PORTm;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (SOC_IS_TRIDENT3X(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_td3_egr_port_tab_conv(unit, &field, &mem));
        if (mem == EGR_GPP_ATTRIBUTESm) {
            is_gpp_attr = 1;
        } else if (mem != EGR_PORTm) {
            is_lport_cfg = 1;
        }
    }
#endif

    if (!SOC_MEM_FIELD_VALID(unit, mem, field)) {
        return (BCM_E_UNAVAIL);
    }

#if defined BCM_HGPROXY_COE_SUPPORT
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        soc_feature(unit, soc_feature_channelized_switching)) &&
        _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
        is_lport_cfg = 1;
    } else
#endif
    if (BCM_GPORT_IS_PROXY(port)) {
        is_lport_cfg = 1;
    }

    /* If LPORT, then get property from LPORT table */
    if (is_lport_cfg) {
        rv = bcm_esw_port_egr_lport_field_get(unit, port,
                                              EGR_LPORT_PROFILEm,
                                              field, &value32);
        *value = value32;
        return rv;
    } else if (is_gpp_attr) {
        rv = bcm_esw_port_egr_lport_field_get(unit, port,
                                              EGR_GPP_ATTRIBUTESm,
                                              field, &value32);
        *value = value32;
        return rv;
    }

    /* At this point, 'port' needs to be a BCM port (non-gport) */
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    index = SOC_PORT_MOD_OFFSET(unit, port);
    rv = soc_mem_read(unit, mem, MEM_BLOCK_ANY, index, &pent);

    if (BCM_SUCCESS(rv)) {
        *value = soc_mem_field32_get(unit, mem, &pent, field);
    }

    return rv;
}


#if defined(BCM_TRX_SUPPORT)
/*
 * Function:
 *      bcm_esw_port_separate_lport_rtag7_profile_fields_get
 * Description:
 *      Gets the fields from the LPORT Profile Table.
 * Parameters:
 *      unit        - (IN) Device number
 *      modid       - (IN) Module number for port
 *      port        - (IN) Port number (NON gport)
 *      table_id    - (IN) Index of table to modify, LPORT or RTAG7
 *      field_count - (IN) Number of fields to read
 *      fields      - (IN) Array of fields to return
 *      values      - (OUT) Array of return values
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Note:
 *     - Assumes: lock,
 *                valid bcm module id and port number,
 *                valid table id,
 *                valid HW fields.
 *     - Called when LPORT profile is supported.
 *     - Helper routine for bcm_esw_port_lport_fields_get();
 *       callers should be calling bcm_esw_port_lport_fields_get() instead.
 */
STATIC int
bcm_esw_port_separate_lport_rtag7_profile_fields_get(int unit, int port_type,
                                      bcm_module_t modid, bcm_port_t port,
                                      int table_id, int field_count,
                                      soc_field_t *fields, uint32 *values)
{
    int i;
    int src_index;
    uint32 src_ent[SOC_MAX_MEM_FIELD_WORDS];
    int src_tbl_is_stm = 1;
    soc_mem_t src_mem = SOURCE_TRUNK_MAP_TABLEm;
    lport_tab_entry_t lport_entry;
    rtag7_port_based_hash_entry_t  rtag7_entry;
    uint32 lport_index = 0, rtag7_index = 0;
    void *entries[1];
    soc_mem_t mem;
    void *entry;

    BCM_IF_ERROR_RETURN
        (bcm_esw_port_lport_prof_src_check(unit, port_type, &src_tbl_is_stm));

    /* Get LPORT profile index Source table */
    if (src_tbl_is_stm) {
        BCM_IF_ERROR_RETURN
            (_bcm_esw_src_mod_port_table_index_get(unit, modid, port, &src_index));
    } else {
        src_mem = ING_DEVICE_PORTm;
        src_index = port;
    }

    BCM_IF_ERROR_RETURN
        (soc_mem_read(unit, src_mem, MEM_BLOCK_ANY,
                      src_index, src_ent));

    lport_index =
        soc_mem_field32_get(unit, src_mem, src_ent, LPORT_PROFILE_IDXf);

    /* If this is a RTAG7 table, extract the RTAG7 index from the LPORT table */
    if(table_id == LPORT_PROFILE_RTAG7_TAB) {

        /* Get the associated LPORT entry */
        BCM_IF_ERROR_RETURN
            (READ_LPORT_TABm(unit, MEM_BLOCK_ANY, lport_index, &lport_entry));

        rtag7_index =
            soc_LPORT_TABm_field32_get(unit, &lport_entry,
                                                    RTAG7_PORT_PROFILE_INDEXf);
    }

    /* Read the appropriate profile table entry */
    if (table_id == LPORT_PROFILE_LPORT_TAB) {
        mem = LPORT_TABm;
        entries[0] = &lport_entry;
        entry = entries[0];
        BCM_IF_ERROR_RETURN
            (_bcm_lport_ind_profile_entry_get(unit, lport_index,
                                            1, entries));
    } else if (table_id == LPORT_PROFILE_RTAG7_TAB) {
        mem = RTAG7_PORT_BASED_HASHm;
        entries[0] = &rtag7_entry;
        entry = entries[0];
        BCM_IF_ERROR_RETURN
            (_bcm_rtag7_ind_profile_entry_get(unit, rtag7_index,
                                            1, entries));
    } else {
        return BCM_E_INTERNAL;
    }

    for (i = 0; i < field_count; i++) {
        values[i] = soc_mem_field32_get(unit, mem, entry, fields[i]);
    }

    return BCM_E_NONE;
}
#endif /* BCM_TRX_SUPPORT */


/*
 * Function:
 *      bcm_esw_port_egr_lport_profile_fields_get
 * Description:
 *      Gets the fields from the LPORT Profile Table.
 * Parameters:
 *      unit        - (IN) Device number
 *      modid       - (IN) Module number for port
 *      port        - (IN) Port number (NON gport)
 *      mem         - (IN) Table to modify
 *      field_count - (IN) Number of fields to read
 *      fields      - (IN) Array of fields to return
 *      values      - (OUT) Array of return values
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Note:
 *     - Assumes: lock,
 *                valid bcm module id and port number,
 *                valid table id,
 *                valid HW fields.
 *     - Called when LPORT profile is supported.
 *     - Helper routine for bcm_esw_port_egr_lport_fields_get();
 *       callers should be calling bcm_esw_port_egr_lport_fields_get() instead.
 */
STATIC int
bcm_esw_port_egr_lport_profile_fields_get(int unit,
                                      bcm_module_t modid, bcm_port_t port,
                                      soc_mem_t mem, int field_count,
                                      soc_field_t *fields, uint32 *values)
{
#if defined(BCM_TRX_SUPPORT)
    int i, index;
    int egr_gpp_index = 0;
    egr_gpp_attributes_entry_t egr_gpp_entry;
    egr_lport_profile_entry_t egr_lport_entry;
    egr_vlan_control_1_entry_t egr_vlan_control_1;
    egr_vlan_control_2_entry_t egr_vlan_control_2;
    egr_vlan_control_3_entry_t egr_vlan_control_3;
    egr_ipmc_cfg2_entry_t egr_ipmc_cfg2;
    egr_mtu_entry_t egr_mtu;
    egr_port_1_entry_t egr_port_1;
    egr_counter_control_entry_t egr_counter_control;
    egr_shaping_control_entry_t egr_shaping_control;
    uint32 egr_lport_index;
    void *entries[_BCM_EGR_LPROF_MEM_COUNT];
    void *entry = NULL;
    int use_gpp_index = 1;

    if (mem == EGR_GPP_ATTRIBUTESm) {
        BCM_IF_ERROR_RETURN
            (_bcm_esw_src_mod_port_table_index_get(unit, modid, port,
                                                   &egr_gpp_index));
        BCM_IF_ERROR_RETURN
            (READ_EGR_GPP_ATTRIBUTESm(unit, MEM_BLOCK_ANY,
                                      egr_gpp_index, &egr_gpp_entry));
        for (i = 0; i < field_count; i++) {
            values[i] = soc_mem_field32_get(unit, EGR_GPP_ATTRIBUTESm,
                                            &egr_gpp_entry, fields[i]);
        }
        return BCM_E_NONE;
    }

    BCM_IF_ERROR_RETURN(
        bcm_esw_port_egr_lport_prof_src_get(unit, modid, port, &use_gpp_index));

    if (use_gpp_index) {
        /* Get LPORT profile index Source Trunk Map table */
        BCM_IF_ERROR_RETURN
            (_bcm_esw_src_mod_port_table_index_get(unit, modid, port,
                                                   &egr_gpp_index));
        BCM_IF_ERROR_RETURN
            (READ_EGR_GPP_ATTRIBUTESm(unit, MEM_BLOCK_ANY,
                                      egr_gpp_index, &egr_gpp_entry));
        egr_lport_index =
            soc_EGR_GPP_ATTRIBUTESm_field32_get(unit, &egr_gpp_entry,
                                                EGR_LPORT_PROFILE_IDXf);
    } else {
        egr_port_entry_t entry2;
        BCM_IF_ERROR_RETURN
            (READ_EGR_PORTm(unit, MEM_BLOCK_ANY, port, &entry2));
        egr_lport_index =
            soc_mem_field32_get(unit, EGR_PORTm, &entry2,
                                EGR_LPORT_PROFILE_IDXf);
    }

    /* Get EGR_LPORT profile entry */
    index = 0;
    if (SOC_MEM_IS_VALID(unit, EGR_LPORT_PROFILEm)) {
        entries[index++] = &egr_lport_entry;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_VLAN_CONTROL_1m)) {
        entries[index++] = &egr_vlan_control_1;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_VLAN_CONTROL_2m)) {
        entries[index++] = &egr_vlan_control_2;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_VLAN_CONTROL_3m)) {
        entries[index++] = &egr_vlan_control_3;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_IPMC_CFG2m)) {
        entries[index++] = &egr_ipmc_cfg2;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_MTUm)) {
        entries[index++] = &egr_mtu;
    }
    if (SOC_MEM_IS_VALID(unit, EGR_PORT_1m)) {
        entries[index++] = &egr_port_1;
    }
    if (soc_feature(unit, soc_feature_egr_all_profile) == 0) {
        if (SOC_MEM_IS_VALID(unit, EGR_COUNTER_CONTROLm)) {
            entries[index++] = &egr_counter_control;
        }
        if (SOC_MEM_IS_VALID(unit, EGR_SHAPING_CONTROLm)) {
            entries[index++] = &egr_shaping_control;
        }
    }

    BCM_IF_ERROR_RETURN
            (_bcm_egr_lport_profile_entry_get(unit, egr_lport_index, 1, entries));

    BCM_IF_ERROR_RETURN
        (_bcm_egr_lport_profile_mem_index_get(unit, mem, &index));
    entry = entries[index];
    /* Get fields */

    for (i = 0; i < field_count; i++) {
        values[i] = soc_mem_field32_get(unit, mem, entry, fields[i]);
    }

    return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif /* BCM_TRX_SUPPORT */
}

/*
 * Function:
 *      bcm_esw_port_lport_profile_fields_get
 * Description:
 *      Gets the fields from the LPORT Profile Table.
 * Parameters:
 *      unit        - (IN) Device number
 *      modid       - (IN) Module number for port
 *      port        - (IN) Port number (NON gport)
 *      table_id    - (IN) Index of table to modify, LPORT or RTAG7
 *      field_count - (IN) Number of fields to read
 *      fields      - (IN) Array of fields to return
 *      values      - (OUT) Array of return values
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Note:
 *     - Assumes: lock,
 *                valid bcm module id and port number,
 *                valid table id,
 *                valid HW fields.
 *     - Called when LPORT profile is supported.
 *     - Helper routine for bcm_esw_port_lport_fields_get();
 *       callers should be calling bcm_esw_port_lport_fields_get() instead.
 */
STATIC int
bcm_esw_port_lport_profile_fields_get(int unit, int port_type,
                                      bcm_module_t modid, bcm_port_t port,
                                      int table_id, int field_count,
                                      soc_field_t *fields, uint32 *values)
{
#if defined(BCM_TRX_SUPPORT)
    int i;
    int src_index;
    uint32 src_ent[SOC_MAX_MEM_FIELD_WORDS];
    int src_tbl_is_stm = 1;
    soc_mem_t src_mem = SOURCE_TRUNK_MAP_TABLEm;
    lport_tab_entry_t lport_entry;
    rtag7_port_based_hash_entry_t  rtag7_entry;
    uint32 lport_index;
    void *entries[2];
    soc_mem_t mem;
    void *entry;
    int pipe;

    if (soc_feature(unit, soc_feature_separate_ing_lport_rtag7_profile)) {
        return bcm_esw_port_separate_lport_rtag7_profile_fields_get(unit,
                port_type, modid, port, table_id, field_count, fields, values);
    }

    BCM_IF_ERROR_RETURN
        (bcm_esw_port_lport_prof_src_check(unit, port_type, &src_tbl_is_stm));

    /* Get LPORT profile index Source table */
    if (src_tbl_is_stm) {
        BCM_IF_ERROR_RETURN
            (_bcm_esw_src_mod_port_table_index_get(unit, modid, port, &src_index));
    } else {
        src_mem = ING_DEVICE_PORTm;
        src_index = port;
    }

    BCM_IF_ERROR_RETURN
        (soc_mem_read(unit, src_mem, MEM_BLOCK_ANY, src_index, src_ent));

    lport_index =
        soc_mem_field32_get(unit, src_mem, src_ent, LPORT_PROFILE_IDXf);

    /* Get LPORT profile entry */
    entries[0] = &lport_entry;
    entries[1] = &rtag7_entry;
    if (SOC_MEM_UNIQUE_ACC(unit, LPORT_TABm)) {
        pipe = SOC_INFO(unit).port_pipe[src_index];
        mem = SOC_MEM_UNIQUE_ACC(unit, LPORT_TABm)[pipe];
        /* Need to index into the proper entry of the profile table,
         * which is stored as one logical table while LPORT_PROFILE_IDX
         * is from 0-19 of each pipe */
        lport_index += pipe*SOC_MEM_SIZE(unit, mem);
    }

    BCM_IF_ERROR_RETURN
            (_bcm_lport_profile_entry_get(unit, lport_index, 1, entries));

    /* Get fields */
    if (table_id == LPORT_PROFILE_LPORT_TAB) {
        mem = LPORT_TABm;
        if (SOC_MEM_UNIQUE_ACC(unit, mem)) {
            int pipe = SOC_INFO(unit).port_pipe[src_index];
            mem = SOC_MEM_UNIQUE_ACC(unit, mem)[pipe];
        }
        entry = entries[0];
    } else if (table_id == LPORT_PROFILE_RTAG7_TAB) {
        mem = RTAG7_PORT_BASED_HASHm;
        entry = entries[1];
    } else {
        return BCM_E_INTERNAL;
    }

    for (i = 0; i < field_count; i++) {
        values[i] = soc_mem_field32_get(unit, mem, entry, fields[i]);
    }

    return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif /* BCM_TRX_SUPPORT */
}

/*
 * Function:
 *      bcm_esw_port_lport_non_profile_fields_set
 * Description:
 *      Sets the fields only in the LPORT Table for local HG ports.
 *      There is no reference update to the SOURCE TRUNK MAP table.
 * Parameters:
 *      unit        - (IN) Device number
 *      port        - (IN) Local Port number (NON gport)
 *      field_count - (IN) Number of fields to modify
 *      fields      - (IN) Array of fields to modify
 *      values      - (IN) Array of new field values
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Note:
 *     Assumes: lock,
 *              valid bcm port number,
 *              valid HW fields.
 *     - Maintained for backwards compatibility with old code.  This only
 *       updates local HG ports.
 *     - Called when LPORT profile is NOT supported.
 *     - Helper routine for bcm_esw_port_lport_fields_set();
 *       callers should be calling bcm_esw_port_lport_fields_set() instead.
 */
STATIC int
bcm_esw_port_lport_non_profile_fields_set(int unit, bcm_port_t port,
                                          int field_count,
                                          soc_field_t *fields, uint32 *values)
{
    bcm_port_config_t port_config;
    soc_mem_t mem = LPORT_TABm;
    int lport_index;

    BCM_IF_ERROR_RETURN(bcm_esw_port_config_get(unit, &port_config));

    if (PBMP_MEMBER(port_config.hg, port) == 0) {
        return BCM_E_NONE;
    }

    lport_index = SOC_PORT_MOD_OFFSET(unit, port);

    return soc_mem_fields32_modify(unit, mem, lport_index,
                                   field_count, fields, values);
}

/*
 * Function:
 *      bcm_esw_port_lport_non_profile_fields_get
 * Description:
 *      Gets the fields from the LPORT Table for local HG ports.
 * Parameters:
 *      unit        - (IN) Device number
 *      port        - (IN) Local Port number (NON gport)
 *      field_count - (IN) Number of fields to read
 *      fields      - (IN) Array of fields to return
 *      values      - (OUT) Array of return values
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Note:
 *     Assumes: lock,
 *              valid bcm port number,
 *              valid HW fields.
 *     - Maintained for backwards compatibility with old code.  This only
 *       updates local HG ports.
 *     - Called when LPORT profile is NOT supported.
 *     - Helper routine for bcm_esw_port_lport_fields_get();
 *       callers should be calling bcm_esw_port_lport_fields_get() instead.
 */
STATIC int
bcm_esw_port_lport_non_profile_fields_get(int unit, bcm_port_t port,
                                          int field_count,
                                          soc_field_t *fields, uint32 *values)
{
    lport_tab_entry_t lport_entry;
    int lport_index;
    int i;

    if (!IS_HG_PORT(unit,port)) {
        return BCM_E_NONE;
    }

    lport_index = SOC_PORT_MOD_OFFSET(unit, port);

    BCM_IF_ERROR_RETURN
        (READ_LPORT_TABm(unit, MEM_BLOCK_ANY, lport_index, &lport_entry));

    for (i = 0; i < field_count; i++) {
        values[i] = soc_LPORT_TABm_field32_get(unit, &lport_entry, fields[i]);
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_port_lport_resolve
 * Description:
 *      Resolves given port to use in the LPORT table as follows.
 *      Current valid "port" for LPORT are:
 *        GPORT_PROXY  - Resolve to module ID and port
 *        GPORT_xxx    - Should result in a valid local physical port
 *        Not GPORT    - Should be a valid local port number
 * Parameters:
 *      unit        - (IN) Device number
 *      port        - (IN) Port number or GPORT
 *      modid_out   - (OUT) Module ID
 *      port_out    - (OUT) Port number
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      If port is GPORT_PROXY, then module-id is derived from GPORT.
 *      Else, module-is is the id of the local device.
 */
STATIC int
bcm_esw_port_lport_resolve(int unit, bcm_port_t port,
                           bcm_module_t *modid_out, bcm_port_t *port_out)
{
    bcm_trunk_t trunk;
    int id, rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Resolve port */
    if (BCM_GPORT_IS_PROXY(port)) {
        if (!soc_feature(unit, soc_feature_proxy_port_property)) {
            return BCM_E_PORT;
        }
        BCM_IF_ERROR_RETURN
            (_bcm_esw_gport_resolve(unit, port,
                                    modid_out, port_out,
                                    &trunk, &id));
    } else {

#if defined BCM_HGPROXY_COE_SUPPORT
        if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
            soc_feature(unit, soc_feature_channelized_switching)) &&
             _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
                BCM_IF_ERROR_RETURN
                    (_bcm_esw_gport_resolve(unit, port,
                                        modid_out, port_out,
                                        &trunk, &id));
        } else
#endif

#if defined(BCM_KATANA2_SUPPORT)
        if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit, port) &&
                (soc_feature(unit, soc_feature_subtag_coe) ||
                 soc_feature(unit, soc_feature_linkphy_coe))) {
            BCM_IF_ERROR_RETURN
                (_bcm_esw_gport_resolve(unit, port,
                                    modid_out, port_out,
                                    &trunk, &id));
        } else
#endif

        {
            /* Gport should resolve to a local valid port */
            BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, modid_out));
            rv = _bcm_esw_port_gport_validate(unit, port, port_out);

            if (rv == BCM_E_PORT &&
                SOC_IS_TRIDENT3X(unit) &&
                SOC_INFO(unit).cpu_hg_index == port) {
                *port_out = port;
                rv = BCM_E_NONE;
            }
            BCM_IF_ERROR_RETURN(rv);
        }
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_port_egr_lport_resolve
 * Description:
 *      Resolves given port to use in the EGR_LPORT table as follows.
 *      Current valid "port" for EGR_LPORT are:
 *        GPORT_SUBPORT - Resolve to module ID and port
 * Parameters:
 *      unit        - (IN) Device number
 *      port        - (IN) Port number or GPORT
 *      modid_out   - (OUT) Module ID
 *      port_out    - (OUT) Port number
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      If port is GPORT_PROXY, then module-id is derived from GPORT.
 *      Else, module-is is the id of the local device.
 */
STATIC int
bcm_esw_port_egr_lport_resolve(int unit, bcm_port_t port,
                           bcm_module_t *modid_out, bcm_port_t *port_out)
{
#if defined BCM_HGPROXY_COE_SUPPORT
    bcm_trunk_t trunk;
    int         id;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Resolve port */
#if defined BCM_HGPROXY_COE_SUPPORT
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        (soc_feature(unit, soc_feature_channelized_switching))) &&
         _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
            BCM_IF_ERROR_RETURN
                (_bcm_esw_gport_resolve(unit, port,
                                    modid_out, port_out,
                                    &trunk, &id));
    } else
#endif
    {
        /* Gport should resolve to a local valid port */
        BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, modid_out));
        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_gport_validate(unit, port, port_out));
    }

    return BCM_E_NONE;
}


/*
 * Function:
 *      bcm_esw_port_lport_fields_set
 * Description:
 *      Sets the fields in the LPORT Table as follows:
 *      - If LPORT profile is available, update fields in the
 *        LPORT Profile Table and corresponding index in the
 *        Source Trunk Map table.
 *      - Else, update fields in the LPORT table only (old logic).
 * Parameters:
 *      unit        - (IN) Device number
 *      port        - (IN) Port number or GPORT (see Notes)
 *      table_id    - (IN) Index of table to modify, LPORT or RTAG7
 *      field_count - (IN) Number of fields to modify
 *      fields      - (IN) Array of fields to modify
 *      values      - (IN) Array of new field values
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      Current valid port/gport types:
 *        GPORT_PROXY
 *        GPORT_xxx    - should result in a valid local physical port
 *        Not GPORT    - assumes a valid local port number
 */
int
bcm_esw_port_lport_fields_set(int unit, bcm_port_t port,
                              int table_id, int field_count,
                              soc_field_t *fields, uint32 *values)
{
    int rv = BCM_E_NONE;
    int i;
    soc_mem_t mem;
    bcm_module_t lmodid;
    bcm_port_t lport;
    int ptype = _BCM_ESW_PT_PORT;
#if defined(INCLUDE_XFLOW_MACSEC) && defined(BCM_HURRICANE4_SUPPORT)
    bcm_xflow_macsec_port_info_t port_info;
    port_info.enable =0;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined BCM_HGPROXY_COE_SUPPORT
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        (soc_feature(unit, soc_feature_channelized_switching))) &&
         _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
        ptype = _BCM_ESW_PT_COE;
    } else
#endif
#if defined(INCLUDE_XFLOW_MACSEC) && defined(BCM_HURRICANE4_SUPPORT)
    if (SOC_IS_HURRICANE4(unit) && soc_feature(unit, soc_feature_xflow_macsec) &&
        (BCM_E_NONE == bcm_common_xflow_macsec_port_info_get(unit, port, &port_info)) &&
        (port_info.enable == 1)) {
        ptype = _BCM_ESW_PT_MACSEC_PORT;
    } else
#endif
    if (BCM_GPORT_IS_PROXY(port)) {
        ptype = _BCM_ESW_PT_HGPROXY;
    }

    /* Check table */
    if (table_id == LPORT_PROFILE_LPORT_TAB) {
        mem = LPORT_TABm;
    } else if (table_id == LPORT_PROFILE_RTAG7_TAB) {
        if (!SOC_MEM_IS_VALID(unit, RTAG7_PORT_BASED_HASHm)) {
            return BCM_E_UNAVAIL;
        }
        mem = RTAG7_PORT_BASED_HASHm;
    } else {
        return BCM_E_INTERNAL;
    }

    /* Check all fields are valid */
    for (i = 0; i < field_count; i++) {
        if (!SOC_MEM_FIELD_VALID(unit, mem, fields[i])) {
            return BCM_E_UNAVAIL;
        }
    }

    /* Resolve port */
    BCM_IF_ERROR_RETURN
        (bcm_esw_port_lport_resolve(unit, port,
                                    &lmodid, &lport));

    if (soc_feature(unit, soc_feature_lport_tab_profile)) {
        rv = bcm_esw_port_lport_profile_fields_set(unit, ptype,
                lmodid, lport, table_id, field_count, fields, values);
    } else {
        rv = bcm_esw_port_lport_non_profile_fields_set(unit,
                lport, field_count, fields, values);
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_egr_lport_fields_set
 * Description:
 *      Sets the fields in the LPORT Table as follows:
 *      - If LPORT profile is available, update fields in the
 *        LPORT Profile Table and corresponding index in the
 *        Source Trunk Map table.
 *      - Else, update fields in the LPORT table only (old logic).
 * Parameters:
 *      unit        - (IN) Device number
 *      port        - (IN) Port number or GPORT (see Notes)
 *      mem         - (IN) Table to modify
 *      field_count - (IN) Number of fields to modify
 *      fields      - (IN) Array of fields to modify
 *      values      - (IN) Array of new field values
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      Current valid port/gport types:
 *        GPORT_PROXY
 *        GPORT_xxx    - should result in a valid local physical port
 *        Not GPORT    - assumes a valid local port number
 */
int
bcm_esw_port_egr_lport_fields_set(int unit, bcm_port_t port,
                              soc_mem_t mem, int field_count,
                              soc_field_t *fields, uint32 *values)
{
    int rv = BCM_E_NONE;
    int i;
    bcm_module_t lmodid;
    bcm_port_t lport;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Check all fields are valid */
    for (i = 0; i < field_count; i++) {
        if (!SOC_MEM_FIELD_VALID(unit, mem, fields[i])) {
            return BCM_E_UNAVAIL;
        }
    }

    /* Resolve port */
    BCM_IF_ERROR_RETURN
        (bcm_esw_port_egr_lport_resolve(unit, port,
                                    &lmodid, &lport));

    PORT_LOCK(unit);
    if (soc_feature(unit, soc_feature_egr_lport_tab_profile)) {
        rv = bcm_esw_port_egr_lport_profile_fields_set(unit, lmodid, lport,
                                                   mem, field_count,
                                                   fields, values);
    }

    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_egr_lport_fields_clear
 * Description:
 *      Similar function as bcm_esw_port_egr_lport_fields_set.
 *      For clear purpose only.
 * Parameters:
 *      unit        - (IN) Device number
 *      port        - (IN) Port number or GPORT (see Notes)
 *      mem         - (IN) Table to modify
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      Current valid port/gport types:
 *        GPORT_PROXY
 *        GPORT_xxx    - should result in a valid local physical port
 *        Not GPORT    - assumes a valid local port number
 */
int
bcm_esw_port_egr_lport_fields_clear(int unit, bcm_port_t port,
                                    soc_mem_t mem)
{
    int rv = BCM_E_NONE;
    bcm_module_t lmodid;
    bcm_port_t lport;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Resolve port */
    BCM_IF_ERROR_RETURN
        (bcm_esw_port_egr_lport_resolve(unit, port,
                                    &lmodid, &lport));

    PORT_LOCK(unit);
    if (soc_feature(unit, soc_feature_egr_lport_tab_profile)) {
        rv = bcm_esw_port_egr_lport_profile_clear(unit, lmodid, lport, mem);
    }

    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_lport_fields_get
 * Description:
 *      Gets the values from the LPORT Table fields as follows:
 *      - If LPORT profile is available, gets fields from the
 *        LPORT Profile Table and corresponding index in the
 *        Source Trunk Map table.
 *      - Else, get fields from the LPORT table only (old logic).
 * Parameters:
 *      unit        - (IN) Device number
 *      port        - (IN) Port number or GPORT (see Notes)
 *      table_id    - (IN) Index of table to modify, LPORT or RTAG7
 *      field_count - (IN) Number of fields to get
 *      fields      - (IN) Array of fields values to get
 *      values      - (OUT) Array of returned values
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      Current valid port/gport types:
 *        GPORT_PROXY
 *        GPORT_xxx    - should result in a valid local physical port
 *        Not GPORT    - assumes a valid local port number
 */
int
bcm_esw_port_lport_fields_get(int unit, bcm_port_t port,
                              int table_id, int field_count,
                              soc_field_t *fields, uint32 *values)
{
    int rv = BCM_E_NONE;
    int i;
    soc_mem_t mem;
    bcm_module_t lmodid;
    bcm_port_t lport;
    int ptype = _BCM_ESW_PT_PORT;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined BCM_HGPROXY_COE_SUPPORT
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        (soc_feature(unit, soc_feature_channelized_switching))) &&
         _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
        ptype = _BCM_ESW_PT_COE;
    } else
#endif
    if (BCM_GPORT_IS_PROXY(port)) {
        ptype = _BCM_ESW_PT_HGPROXY;
    }

    /* Check table */
    if (table_id == LPORT_PROFILE_LPORT_TAB) {
        mem = LPORT_TABm;
    } else if (table_id == LPORT_PROFILE_RTAG7_TAB) {
        if (!SOC_MEM_IS_VALID(unit, RTAG7_PORT_BASED_HASHm)) {
            return BCM_E_UNAVAIL;
        }
        mem = RTAG7_PORT_BASED_HASHm;
    } else {
        return BCM_E_INTERNAL;
    }

    /* Check all fields are valid */
    for (i = 0; i < field_count; i++) {
        if (!SOC_MEM_FIELD_VALID(unit, mem, fields[i])) {
            return BCM_E_UNAVAIL;
        }
    }

    /* Resolve port */
    BCM_IF_ERROR_RETURN
        (bcm_esw_port_lport_resolve(unit, port,
                                    &lmodid, &lport));

    if (soc_feature(unit, soc_feature_lport_tab_profile)) {
        rv = bcm_esw_port_lport_profile_fields_get(unit, ptype,
                lmodid, lport, table_id, field_count, fields, values);
    } else {
        rv = bcm_esw_port_lport_non_profile_fields_get(unit, lport,
                field_count, fields, values);
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_egr_lport_fields_get
 * Description:
 *      Gets the values from the LPORT Table fields as follows:
 *      - If LPORT profile is available, gets fields from the
 *        LPORT Profile Table and corresponding index in the
 *        Source Trunk Map table.
 *      - Else, get fields from the LPORT table only (old logic).
 * Parameters:
 *      unit        - (IN) Device number
 *      port        - (IN) Port number or GPORT (see Notes)
 *      mem         - (IN) Table to modify
 *      field_count - (IN) Number of fields to get
 *      fields      - (IN) Array of fields values to get
 *      values      - (OUT) Array of returned values
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      Current valid port/gport types:
 *        GPORT_PROXY
 *        GPORT_xxx    - should result in a valid local physical port
 *        Not GPORT    - assumes a valid local port number
 */
int
bcm_esw_port_egr_lport_fields_get(int unit, bcm_port_t port,
                              soc_mem_t mem, int field_count,
                              soc_field_t *fields, uint32 *values)
{
    int rv = BCM_E_NONE;
    int i;
    bcm_module_t lmodid;
    bcm_port_t lport;

    /* Sanity check */
    if ((fields == NULL) || (values == NULL)) {
        return BCM_E_PARAM;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Check all fields are valid */
    for (i = 0; i < field_count; i++) {
        if (!SOC_MEM_FIELD_VALID(unit, mem, fields[i])) {
            return BCM_E_UNAVAIL;
        }
    }

    /* Resolve port */
    BCM_IF_ERROR_RETURN
        (bcm_esw_port_egr_lport_resolve(unit, port,
                                    &lmodid, &lport));

    PORT_LOCK(unit);
    rv = bcm_esw_port_egr_lport_profile_fields_get(unit, lmodid, lport,
                                               mem, field_count,
                                               fields, values);
    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_lport_field_set
 * Description:
 *      Sets given field in the LPORT Table as follows:
 *      - If LPORT profile is available, update field in the
 *        LPORT Profile Table and corresponding index in the
 *        Source Trunk Map table.
 *      - Else, update field in the LPORT table only (old logic).
 * Parameters:
 *      unit        - (IN) Device number
 *      port        - (IN) Port number or GPORT (see Notes)
 *      table_id    - (IN) Index of table to modify, LPORT or RTAG7
 *      field       - (IN) Field to modify
 *      value       - (IN) New field value
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      See bcm_esw_port_lport_fields_set().
 */
int
bcm_esw_port_lport_field_set(int unit, bcm_port_t port,
                             int table_id, soc_field_t field, uint32 value)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    return bcm_esw_port_lport_fields_set(unit, port,
                                         table_id, 1, &field, &value);
}

/*
 * Function:
 *      bcm_esw_port_egr_lport_field_set
 * Description:
 *      Sets given field in the LPORT Table as follows:
 *      - If LPORT profile is available, update field in the
 *        LPORT Profile Table and corresponding index in the
 *        Source Trunk Map table.
 *      - Else, update field in the LPORT table only (old logic).
 * Parameters:
 *      unit        - (IN) Device number
 *      port        - (IN) Port number or GPORT (see Notes)
 *      mem         - (IN) Table to modify
 *      field       - (IN) Field to modify
 *      value       - (IN) New field value
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      See bcm_esw_port_egr_lport_fields_set().
 */
int
bcm_esw_port_egr_lport_field_set(int unit, bcm_port_t port, soc_mem_t mem,
                                 soc_field_t field, uint32 value)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    return bcm_esw_port_egr_lport_fields_set(unit, port, mem, 1, &field, &value);
}


/*
 * Function:
 *      bcm_esw_port_lport_field_get
 * Description:
 *      Gets given field from the LPORT Table as follows:
 *      - If LPORT profile is available, gets fields from the
 *        LPORT Profile Table and corresponding index in the
 *        Source Trunk Map table.
 *      - Else, get fields from the LPORT table only (old logic).
 * Parameters:
 *      unit        - (IN) Device number
 *      port        - (IN) Port number or GPORT (see Notes)
 *      table_id    - (IN) Index of table to modify, LPORT or RTAG7
 *      field       - (IN) Field value to get
 *      value       - (OUT) Returned value
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      See bcm_esw_port_lport_fields_get().
 */
int
bcm_esw_port_lport_field_get(int unit, bcm_port_t port,
                             int table_id, soc_field_t field, uint32 *value)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    return bcm_esw_port_lport_fields_get(unit, port,
                                         table_id, 1, &field, value);
}


/*
 * Function:
 *      bcm_esw_port_egr_lport_field_get
 * Description:
 *      Gets given field from the LPORT Table as follows:
 *      - If LPORT profile is available, gets fields from the
 *        LPORT Profile Table and corresponding index in the
 *        Source Trunk Map table.
 *      - Else, get fields from the LPORT table only (old logic).
 * Parameters:
 *      unit        - (IN) Device number
 *      port        - (IN) Port number or GPORT (see Notes)
 *      mem         - (IN) Table to modify
 *      field       - (IN) Field value to get
 *      value       - (OUT) Returned value
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      See bcm_esw_port_egr_lport_fields_get().
 */
int
bcm_esw_port_egr_lport_field_get(int unit, bcm_port_t port, soc_mem_t mem,
                                 soc_field_t field, uint32 *value)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    return bcm_esw_port_egr_lport_fields_get(unit, port, mem, 1, &field, value);
}

/*
 * Function:
 *      _bcm_esw_port_tab_multi_set
 * Description:
 *      Sets multiple port property fields in the HW table.
 *      Helper funtion for bcm_esw_port_control_set.
 * Parameters:
 *      unit        - Device number
 *      port        - Port number (see Notes for valid port formats)
 *      cpu_tabs - If CPU port, which ingress tables should be written?
 *      field_count - Number of fields to modify
 *      fields      - Array of fields to modify
 *      values      - Array of new field values
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX - an error occurred accessing PORT_TAB table.
 * Notes:
 *      Due to the large number of callers for this routine,
 *      function is expanded to take a GPORT PROXY, which
 *      sets the property in the LPORT profile table (similar
 *      to what was done for the GPORT_WLAN_PORT).
 *
 *      Current valid port types are:
 *          GPORT WLAN
 *          GPORT PROXY
 *          GPORT SUBPORT
 *          BCM port (non-gport), assumes a valid local physical port
 *
 *     For GPORT PROXY port, this routine only accesses the properties
 *     in the LPORT table (not the RTAG7).
 */
int
_bcm_esw_port_tab_multi_set(int unit, bcm_port_t port, int cpu_tabs,
                            int field_count, soc_field_t *fields,
                            uint32 *values)
{
    soc_mem_t port_tab_mem = PORT_TABm;
    int rv = BCM_E_NONE, i, cpu_hg_index = -1;
    int is_lport_cfg=0, is_wlan_cfg = 0, is_in_warm_boot = 0;
    int index = 0, is_local_port = 0;
    int ptype = _BCM_ESW_PT_PORT;
#if ((defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)) \
     && defined(INCLUDE_L3))
    bcm_port_t wport = 0;
#endif
    port_tab_entry_t pent;

    soc_field_t port_tab_fields[SOC_MAX_MEM_FIELD_NUM];
    uint32 port_tab_values[SOC_MAX_MEM_FIELD_NUM];
    int port_tab_field_count = 0;
    soc_field_t lport_tab_fields[SOC_MAX_MEM_FIELD_NUM];
    uint32 lport_tab_values[SOC_MAX_MEM_FIELD_NUM];
    int lport_tab_field_count = 0;
    soc_field_t ing_dev_port_fields[SOC_MAX_MEM_FIELD_NUM];
    uint32 ing_dev_port_values[SOC_MAX_MEM_FIELD_NUM];
    int ing_dev_port_field_count = 0;
#if defined(INCLUDE_XFLOW_MACSEC) && defined(BCM_HURRICANE4_SUPPORT)
    bcm_xflow_macsec_port_info_t port_info;
    port_info.enable =0;
#endif

    if ((fields == NULL) || (values == NULL) ) {
        return BCM_E_PARAM;
    }
    if (field_count <= 0) {
        return BCM_E_NONE;
    }

#if defined BCM_HGPROXY_COE_SUPPORT
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        (soc_feature(unit, soc_feature_channelized_switching))) &&
         _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
        is_lport_cfg = 1;
        ptype = _BCM_ESW_PT_COE;
    } else
#endif
#if defined(INCLUDE_XFLOW_MACSEC) && defined(BCM_HURRICANE4_SUPPORT)
    if (SOC_IS_HURRICANE4(unit) && soc_feature(unit, soc_feature_xflow_macsec) &&
        (BCM_E_NONE == bcm_common_xflow_macsec_port_info_get(unit, port, &port_info)) &&
        (port_info.enable == 1)) {
        ptype = _BCM_ESW_PT_MACSEC_PORT;
    } else
#endif
    if (BCM_GPORT_IS_PROXY(port)) {
        is_lport_cfg = 1;
        ptype = _BCM_ESW_PT_HGPROXY;
        if(bcm_esw_port_local_get(unit, port, &port) == BCM_E_NONE) {
            is_local_port = 1;
            index = SOC_PORT_MOD_OFFSET(unit, port);
        }
    }
#if ((defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)) \
     && defined(INCLUDE_L3))
    else if (BCM_GPORT_IS_WLAN_PORT(port)) {
        is_wlan_cfg = 1;
        wport = port;
    }
#endif

    if (is_lport_cfg) {
        port_tab_mem = LPORT_TABm;
    } else if (!is_wlan_cfg) {
        /*
         * At this point, 'port' needs to be a BCM port (non-gport)
         * convert the gport to local port
         */
        if (BCM_GPORT_IS_SET(port)) {
            BCM_IF_ERROR_RETURN(
                _bcm_esw_port_gport_validate(unit, port, &port));
        }
        index = SOC_PORT_MOD_OFFSET(unit, port);
        port_tab_mem = SOC_PORT_MEM_TAB(unit, port);
    }

    if (!is_wlan_cfg && port_tab_mem == PORT_TABm &&
        (!IS_CPU_PORT(unit, port) || (cpu_tabs & _BCM_CPU_TABS_ETHER))) {
        sal_memset(&pent, 0, sizeof(pent));
        if (port_tab_mem == PORT_TABm &&
            SOC_MEM_IS_VALID(unit, ING_DEVICE_PORTm)) {
            port_tab_mem = ING_DEVICE_PORTm;
        }
        BCM_IF_ERROR_RETURN(
            soc_mem_read(unit, port_tab_mem, MEM_BLOCK_ANY, index, &pent));
    }

    /* Loop to set field values into corresponding memory */
    for (i = 0; i < field_count; i++) {
        /* If LPORT, then set property in LPORT table */
        if (is_lport_cfg) {
#if defined(CANCUN_SUPPORT)
            if(SOC_IS_TRIDENT3X(unit)) {
                if(soc_cancun_cmh_check(unit, port_tab_mem, fields[i])
                       == SOC_E_NONE) {
                    rv = soc_cancun_cmh_mem_set(unit, port_tab_mem, port,
                             fields[i], values[i]);
                }
                _bcm_td3_port_tab_conv(unit, &fields[i], &port_tab_mem);
            }
#endif
            soc_mem_set_field_value_array(lport_tab_fields, fields[i],
                                          lport_tab_values, values[i],
                                          lport_tab_field_count);

            /* Synchronize PORT and LPORT profile tables if port is local*/
            if(is_local_port) {
                if(SOC_MEM_FIELD_VALID(unit, port_tab_mem, fields[i])) {
                    soc_mem_set_field_value_array(port_tab_fields, fields[i],
                                                  port_tab_values, values[i],
                                                  port_tab_field_count);
                }
            }

            continue;
        }

        /* GPORT WLAN */
#if ((defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)) \
     && defined(INCLUDE_L3))
        
        if (is_wlan_cfg) {
#if defined(BCM_TRIUMPH3_SUPPORT)
            if (soc_feature(unit, soc_feature_axp)) {
                rv = _bcm_tr3_wlan_port_set(unit, wport, fields[i], values[i]);
            } else
#endif /* BCM_TRIUMPH3_SUPPORT */
            if (soc_feature(unit, soc_feature_wlan)) {
                rv = _bcm_tr2_wlan_port_set(unit, wport, fields[i], values[i]);
            }
            if (rv != BCM_E_NONE) {
                return rv;
            }
            continue;
        }
#endif

        /*  BCM port (non-gport)  */
#if defined(CANCUN_SUPPORT)
        if (SOC_IS_TRIDENT3X(unit)) {
            port_tab_mem = PORT_TABm;
            if (soc_cancun_cmh_check(unit, port_tab_mem, fields[i])
                   == SOC_E_NONE) {
                rv = soc_cancun_cmh_mem_set(unit, port_tab_mem, port,
                         fields[i], values[i]);
                continue;
            }
            _bcm_td3_port_tab_conv(unit, &fields[i], &port_tab_mem);
        }
#endif
        if (!SOC_MEM_FIELD_VALID(unit, port_tab_mem, fields[i])) {
            LOG_INFO(BSL_LS_SOC_CANCUN, (BSL_META_U(unit,
                "%s.%s is INVALID\n"),
                    SOC_MEM_NAME(unit, port_tab_mem),
                    SOC_FIELD_NAME(unit, fields[i])));
            return (BCM_E_UNAVAIL);
        }

        if ((!IS_CPU_PORT(unit, port) || (cpu_tabs & _BCM_CPU_TABS_ETHER)) ||
            (IS_CPU_PORT(unit, port) &&
             (cpu_tabs & _BCM_CPU_TABS_HIGIG) &&
             (port_tab_mem == PORT_TABm))) {
            switch (port_tab_mem) {
#ifdef  BCM_TUCANA_SUPPORT
                case PORT_TAB1m:
#endif
                case PORT_TABm:
                    if ((soc_mem_field32_get(unit, port_tab_mem,
                                             &pent, fields[i]) != values[i]) ||
                        (fields[i] == TRILL_ENABLEf) ||
                        (fields[i] == ALLOW_TRILL_FRAMESf) ||
                        (fields[i] == ALLOW_NON_TRILL_FRAMESf) ||
                        (fields[i] == COPY_CORE_IS_IS_TO_CPUf) ||
                        (fields[i] == RTAG7_HASH_CFG_SEL_TRILL_ECMPf)) {
                        soc_mem_field32_set(unit, port_tab_mem,
                                            &pent, fields[i], values[i]);
                        soc_mem_set_field_value_array(port_tab_fields,
                            fields[i], port_tab_values, values[i],
                            port_tab_field_count);
                        if ((SOC_MEM_IS_VALID(unit, LPORT_TABm)) &&
                            (SOC_IS_TOMAHAWKX(unit) || SOC_IS_TD2P_TT2P(unit) ||
                             SOC_IS_APACHE(unit) ||
                             soc_feature(unit,
                                         soc_feature_sync_port_lport_tab))) {
                            soc_mem_set_field_value_array(lport_tab_fields,
                                fields[i], lport_tab_values, values[i],
                                lport_tab_field_count);
                        }
                    }
                    break;
                case LPORT_TABm:
                    soc_mem_set_field_value_array(lport_tab_fields, fields[i],
                                                  lport_tab_values, values[i],
                                                  lport_tab_field_count);
                    break;
                case ING_DEVICE_PORTm:
                    soc_mem_set_field_value_array(ing_dev_port_fields,
                                                  fields[i],
                                                  ing_dev_port_values,
                                                  values[i],
                                                  ing_dev_port_field_count);
                    break;
                default:
                    soc_mem_field32_modify(unit, port_tab_mem, port,
                                                fields[i], values[i]);
                    continue;
            }
        }
    }

    /* wlan_cfg is handled outside of this function */
    if (is_wlan_cfg == 1) {
        return BCM_E_NONE;
    }

    is_in_warm_boot = (inside_bcm_shutdown[unit] == TRUE) ||
                      SOC_WARM_BOOT(unit);

    /* Apply the changes to tables their field_count is not 0 */
    if (port_tab_field_count != 0) {
        if (port_tab_mem == PORT_TABm &&
            (!IS_CPU_PORT(unit, port) || (cpu_tabs & _BCM_CPU_TABS_ETHER))) {
            BCM_IF_ERROR_RETURN
                (soc_mem_write(unit, port_tab_mem, MEM_BLOCK_ALL, index, &pent));
        } else {
            if ((!IS_CPU_PORT(unit, port)) ||
                (IS_CPU_PORT(unit, port) && (cpu_tabs & _BCM_CPU_TABS_ETHER))) {
            BCM_IF_ERROR_RETURN
                (soc_mem_fields32_modify(unit, port_tab_mem, index,
                                         port_tab_field_count, port_tab_fields,
                                         port_tab_values));
        }
    }
    }

    if (ing_dev_port_field_count != 0) {
        if(is_in_warm_boot) {
            SOC_WARM_BOOT_DONE(unit);
        }

        BCM_IF_ERROR_RETURN
            (soc_mem_fields32_modify(unit, ING_DEVICE_PORTm, index,
                                     ing_dev_port_field_count,
                                     ing_dev_port_fields,
                                     ing_dev_port_values));
        if(is_in_warm_boot) {
            SOC_WARM_BOOT_START(unit);
        }
    }

    if (lport_tab_field_count != 0) {
#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit) && (port > KT2_MAX_PHYSICAL_PORTS)) {
            /* Skip programming */;
        } else
#endif
#if defined(BCM_SABER2_SUPPORT)
        if (SOC_IS_SABER2(unit) && (port > SB2_MAX_PHYSICAL_PORTS)) {
            /* Skip programming */;
        } else
#endif
        {
            if (is_in_warm_boot) {
                SOC_WARM_BOOT_DONE(unit);
            }

            if (is_lport_cfg == 1) { /* remote port */
                rv = bcm_esw_port_lport_fields_set(unit, port,
                                                   LPORT_PROFILE_LPORT_TAB,
                                                   lport_tab_field_count,
                                                   lport_tab_fields,
                                                   lport_tab_values);

                if (is_in_warm_boot) {
                    SOC_WARM_BOOT_START(unit);
                }
                return rv;
            }

            BCM_IF_ERROR_RETURN
                (bcm_esw_port_lport_fields_set(unit,
                                               index,
                                               LPORT_PROFILE_LPORT_TAB,
                                               lport_tab_field_count,
                                               lport_tab_fields,
                                               lport_tab_values));
            if (is_in_warm_boot) {
                SOC_WARM_BOOT_START(unit);
            }
        }
    }

    /* Copy to Higig port if needed */
    if (IS_CPU_PORT(unit, port) && (cpu_tabs & _BCM_CPU_TABS_HIGIG)) {
        cpu_hg_index = SOC_IS_KATANA2(unit) ?
                       SOC_INFO(unit).cpu_hg_pp_port_index :
                       SOC_INFO(unit).cpu_hg_index;

        if (SOC_MEM_IS_VALID(unit, IPORT_TABLEm)) {
            if (port_tab_field_count != 0) {
                BCM_IF_ERROR_RETURN
                    (soc_mem_fields32_modify(unit, IPORT_TABLEm, index,
                                             port_tab_field_count,
                                             port_tab_fields, port_tab_values));
            }
        } else if (cpu_hg_index != -1) {
            if (port_tab_field_count != 0) {
                BCM_IF_ERROR_RETURN
                    (soc_mem_fields32_modify(unit, port_tab_mem, cpu_hg_index,
                                             port_tab_field_count,
                                             port_tab_fields,
                                             port_tab_values));
            }
            if (ing_dev_port_field_count != 0) {
                BCM_IF_ERROR_RETURN
                    (soc_mem_fields32_modify(unit, ING_DEVICE_PORTm,
                                             cpu_hg_index,
                                             ing_dev_port_field_count,
                                             ing_dev_port_fields,
                                             ing_dev_port_values));
            }
            if (lport_tab_field_count != 0) {
                if (SOC_IS_TRIDENT3X(unit)) {
                    /* TD3TBD Should use a feature check? */
                    int my_modid = 0;
                    BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, &my_modid));
                    if (soc_feature(unit, soc_feature_lport_tab_profile)) {
                        BCM_IF_ERROR_RETURN(
                            bcm_esw_port_lport_profile_fields_set(unit, ptype,
                                my_modid, cpu_hg_index, LPORT_PROFILE_LPORT_TAB,
                                lport_tab_field_count, lport_tab_fields,
                                lport_tab_values));
                    }
                }
            }
        }
    }

    return rv;
}

int
_bcm_esw_port_tab_set_without_portlock(int unit, bcm_port_t port, int cpu_tabs,
                                       soc_field_t field, int value)
{
    return (_bcm_esw_port_tab_multi_set(unit, port, cpu_tabs, 1, &field,
                                (uint32*) &value));
}

/*
 * Function:
 *      _bcm_esw_port_tab_set
 * Description:
 *      Sets the port property field in the HW table.
 *      Helper funtion for bcm_esw_port_control_set.
 * Parameters:
 *      unit  - Device number
 *      port  - Port number (see Notes for valid port formats)
 *      cpu_tabs - If CPU port, which ingress tables should be written?
 *      field - Field name within PORT_TAB table entry
 *      value - new field value
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX - an error occurred accessing PORT_TAB table.
 * Notes:
 *      Due to the large number of callers for this routine,
 *      function is expanded to take a GPORT PROXY, which
 *      sets the property in the LPORT profile table (similar
 *      to what was done for the GPORT_WLAN_PORT).
 *
 *      Current valid port types are:
 *          GPORT WLAN
 *          GPORT PROXY
 *          GPORT SUBPORT
 *          BCM port (non-gport), assumes a valid local physical port
 *
 *     For GPORT PROXY port, this routine only accesses the properties
 *     in the LPORT table (not the RTAG7).
 */
int
_bcm_esw_port_tab_set(int unit, bcm_port_t port, int cpu_tabs,
                      soc_field_t field, int value)
{
    int rv = BCM_E_UNAVAIL;

    PORT_LOCK(unit);
    rv = _bcm_esw_port_tab_set_without_portlock(unit, port, cpu_tabs, field,
                                                value);
    PORT_UNLOCK(unit);

    return rv;
}

#if defined(BCM_TRX_SUPPORT)
/*
 * Function:
 *      _bcm_esw_iport_tab_get
 * Description:
 *      Helper funtion for bcm_esw_port_control_get.
 * Parameters:
 *      unit  - Device number
 *      port  - Port number
 *      field - Field name within IPORT_TAB table entry
 *      value - (OUT) field value
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX - an error occurred accessing IPORT_TAB table.
 */
STATIC int
_bcm_esw_iport_tab_get(int unit, bcm_port_t port,
                      soc_field_t field, int *value)
{
    port_tab_entry_t pent;
    soc_mem_t mem = INVALIDm;
    int rv, index = -1;

    if (SOC_MEM_IS_VALID(unit, IPORT_TABLEm)) {
        mem = IPORT_TABLEm;
        index = SOC_PORT_MOD_OFFSET(unit, port);
    } else if (IS_CPU_PORT(unit, port)) {
        int cpu_hg_index;

        cpu_hg_index = SOC_IS_KATANA2(unit) ?
                       SOC_INFO(unit).cpu_hg_pp_port_index :
                       SOC_INFO(unit).cpu_hg_index;
        if (cpu_hg_index != -1){
            mem = PORT_TABm;
            index = cpu_hg_index;
        }
    }
    if (index == -1) {
        return BCM_E_UNAVAIL;
    }

    if (!SOC_MEM_FIELD_VALID(unit, mem, field)) {
        return (BCM_E_UNAVAIL);
    }
    rv = soc_mem_read(unit, mem, MEM_BLOCK_ANY,
                      index, &pent);

    if (BCM_SUCCESS(rv)) {
        *value = soc_mem_field32_get(unit, mem, &pent, field);
    }

    return rv;
}
#endif /* BCM_TRX_SUPPORT */

/*
 * Function:
 *      _bcm_esw_port_tab_get
 * Description:
 *      Helper funtion for bcm_esw_port_control_get.
 * Parameters:
 *      unit  - Device number
 *      port  - Port number
 *      field - Field name within PORT_TAB table entry
 *      value - (OUT) field value
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_XXX - an error occurred accessing PORT_TAB table.
 * Notes:
 *      Due to the large number of callers for this routine,
 *      function is expanded to take a GPORT PROXY, which
 *      get the property from the LPORT profile table (similar
 *      to what was done for the GPORT_WLAN_PORT).
 *
 *      Current valid port types are:
 *          GPORT WLAN
 *          GPORT PROXY
 *          GPORT SUBPORT
 *          BCM port (non-gport), assumes a valid local physical port
 *          GPORT Local
 *
 *     For GPORT PROXY port, this routine only accesses the properties
 *     in the LPORT table (not the RTAG7).
 */
int
_bcm_esw_port_tab_get(int unit, bcm_port_t port,
                      soc_field_t field, int *value)
{
    int rv = BCM_E_UNAVAIL;
    port_tab_entry_t pent;
    soc_mem_t mem;
    int index, is_lport_cfg = 0;
    uint32 value32;

    mem = SOC_PORT_MEM_TAB(unit, port);
#if defined(BCM_TRIDENT3_SUPPORT)
    if (SOC_IS_TRIDENT3X(unit)) {
        _bcm_td3_port_tab_conv(unit, &field, &mem);
        if (mem == LPORT_TABm) {
            is_lport_cfg = 1;
        }
    }
#endif

#if defined BCM_HGPROXY_COE_SUPPORT
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        (soc_feature(unit, soc_feature_channelized_switching))) &&
         _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
            is_lport_cfg = 1;
    } else
#endif
    if (BCM_GPORT_IS_PROXY(port)) {
        is_lport_cfg = 1;
    }

    /* If LPORT, then get property from LPORT table */
    if (is_lport_cfg) {
        rv = bcm_esw_port_lport_field_get(unit, port,
                                          LPORT_PROFILE_LPORT_TAB,
                                          field, &value32);
        *value = value32;
        return rv;
    }

    /* GPORT WLAN */
#if ((defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)) \
     && defined(INCLUDE_L3))
    if (BCM_GPORT_IS_WLAN_PORT(port)) {
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_axp)) {
            rv = bcm_tr3_wlan_lport_field_get(unit, port, field, value);
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        if (soc_feature(unit, soc_feature_wlan)) {
            rv = bcm_tr2_wlan_lport_field_get(unit, port, field, value);
        }
        return rv;
    }
#endif

    /* At this point, 'port' needs to be a BCM port (non-gport).
     * convert the gport to local port.
     */
    if (BCM_GPORT_IS_SET(port)) {
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_gport_validate(unit, port, &port));
    }

#if defined(CANCUN_SUPPORT)
    if (soc_feature(unit, soc_feature_cancun)) {
        if (soc_cancun_cmh_check(unit, mem, field) == SOC_E_NONE) {
            rv = soc_cancun_cmh_mem_get(unit, mem, port,
                     field, (void *)value);
            if (!BCM_SUCCESS(rv)) {
                return rv;
            }
        }
    }
#endif

    index = SOC_PORT_MOD_OFFSET(unit, port);
    if (!SOC_MEM_FIELD_VALID(unit, mem, field)) {
        return (BCM_E_UNAVAIL);
    }

    rv = soc_mem_read(unit, mem, MEM_BLOCK_ANY,
                      index, &pent);

    if (BCM_SUCCESS(rv)) {
        *value = soc_mem_field32_get(unit, mem, &pent, field);
    }

    return rv;
}

/*
 * Function:
 *      bcm_port_untagged_vlan_get
 * Purpose:
 *      Retrieve the default VLAN ID for the port.
 *      This is the VLAN ID assigned to received untagged packets.
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      port - StrataSwitch port number of port to get info for
 *      vid_ptr - (OUT) Pointer to VLAN ID for return
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL if table read failed.
 */

int
bcm_esw_port_untagged_vlan_get(int unit, bcm_port_t port, bcm_vlan_t *vid_ptr)
{
    bcm_port_cfg_t              pcfg;
    int                         vid;
    int                         rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if ((defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)) \
     && defined(INCLUDE_L3))
    if (BCM_GPORT_IS_WLAN_PORT(port)) {
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return bcm_tr3_wlan_port_untagged_vlan_get(unit, port, vid_ptr);
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
            return bcm_tr2_wlan_port_untagged_vlan_get(unit, port, vid_ptr);
        }
    }
#endif

#if defined(BCM_TRIDENT_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_NIV_PORT(port)) {
        return bcm_trident_niv_port_untagged_vlan_get(unit, port, vid_ptr);
    }
#endif

#if defined(BCM_TRIUMPH3_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_EXTENDER_PORT(port)) {
        return bcm_tr3_extender_port_untagged_vlan_get(unit, port, vid_ptr);
    }
#endif

#ifdef BCM_HGPROXY_COE_SUPPORT
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        (soc_feature(unit, soc_feature_channelized_switching))) &&
         _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
        rv = _bcm_esw_port_tab_get(unit, port, PORT_VIDf, &vid);
    } else
#endif
    {
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_gport_validate(unit, port, &port));

        PORT_LOCK(unit);
        rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg);
        PORT_UNLOCK(unit);
        vid = pcfg.pc_vlan;
    }

    if (BCM_SUCCESS(rv)) {
        *vid_ptr = vid;
    } else {
        *vid_ptr = BCM_VLAN_INVALID;
    }

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_untagged_vlan_get: u=%d p=%d vid=%d rv=%d\n"),
              unit, port, *vid_ptr, rv));

    return rv;
}


#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_SCORPION_SUPPORT)
/*
 * Function:
 *      _bcm_port_mmu_update
 * Purpose:
 *      Adjust MMU settings depending on port status.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      link -  True if link is active, false if link is inactive.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

STATIC int
_bcm_port_mmu_update(int unit, bcm_port_t port, int link)
{
    int pause_tx, pause_rx, q_limit_enable, cos;
    uint32 psl_rval, opc_rval, oqc_rval;

    if (!SOC_IS_HBX(unit)) {
        return (BCM_E_UNAVAIL);
    }

    if (link < 0) {
        SOC_IF_ERROR_RETURN
            (bcm_esw_port_link_status_get(unit, port, &link));
    }

    SOC_IF_ERROR_RETURN
        (MAC_PAUSE_GET(PORT(unit, port).p_mac, unit, port,
                       &pause_tx, &pause_rx));

    SOC_IF_ERROR_RETURN(READ_PORT_SHARED_LIMITr(unit, port, &psl_rval));
    SOC_IF_ERROR_RETURN(READ_OP_PORT_CONFIGr(unit, port, &opc_rval));
    if (link && pause_tx) {
        soc_reg_field_set(unit, PORT_SHARED_LIMITr, &psl_rval,
                          PORT_SHARED_LIMITf,
                          SOC_IS_SC_CQ(unit) ? 0x5 : 0x3);
        soc_reg_field_set(unit, PORT_SHARED_LIMITr, &psl_rval,
                          PORT_SHARED_DYNAMICf, 1);
        soc_reg_field_set(unit, OP_PORT_CONFIGr, &opc_rval,
                          PORT_LIMIT_ENABLEf, 1);
        q_limit_enable = 0;
    } else {
        /* Turn off */
        soc_reg_field_set(unit, PORT_SHARED_LIMITr, &psl_rval,
                          PORT_SHARED_LIMITf,
                          SOC_IS_SC_CQ(unit) ? 0x3fff : 0x3000);
        soc_reg_field_set(unit, PORT_SHARED_LIMITr, &psl_rval,
                          PORT_SHARED_DYNAMICf, 0);
        soc_reg_field_set(unit, OP_PORT_CONFIGr, &opc_rval,
                          PORT_LIMIT_ENABLEf, 0);
        q_limit_enable = 1;
    }
    SOC_IF_ERROR_RETURN(WRITE_PORT_SHARED_LIMITr(unit, port, psl_rval));
    SOC_IF_ERROR_RETURN(WRITE_OP_PORT_CONFIGr(unit, port, opc_rval));
    for (cos = 0; cos < NUM_COS(unit); cos++) {
        SOC_IF_ERROR_RETURN
            (READ_OP_QUEUE_CONFIGr(unit, port, cos, &oqc_rval));
        soc_reg_field_set(unit, OP_QUEUE_CONFIGr, &oqc_rval,
                          Q_LIMIT_ENABLEf, q_limit_enable);
        SOC_IF_ERROR_RETURN
            (WRITE_OP_QUEUE_CONFIGr(unit, port, cos, oqc_rval));
    }

    return (BCM_E_NONE);
}
#endif /* BCM_BRADLEY_SUPPORT || BCM_SCORPION_SUPPORT */

/*
 * Function:
 *      _bcm_port_untagged_vlan_set
 * Purpose:
 *      Main part of bcm_port_untagged_vlan_set.
 * Notes:
 *      Port does not have to be a member of the VLAN.
 */

STATIC int
_bcm_port_untagged_vlan_set(int unit, bcm_port_t port, bcm_vlan_t vid)
{
    bcm_port_cfg_t      pcfg;
    int                 ut_prio;
#if defined(BCM_FIREBOLT_SUPPORT)
    bcm_vlan_t          pdvid;
#endif /* BCM_FIREBOLT_SUPPORT */

#ifdef BCM_TRX_SUPPORT
    if (soc_feature(unit, soc_feature_vlan_action)) {
        bcm_port_t local_port;
        bcm_vlan_action_set_t action;
#if defined(BCM_TOMAHAWK_SUPPORT)
        bcm_port_cfg_t pcfg;
#endif
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_gport_validate(unit, port, &local_port));

#if defined(BCM_TOMAHAWK3_SUPPORT)
		if (SOC_IS_TOMAHAWK3(unit)) {
             BCM_IF_ERROR_RETURN
                 (_bcm_th3_vlan_port_default_action_get(unit, port, &action));
		} else
#endif
		{
             BCM_IF_ERROR_RETURN
                 (_bcm_trx_vlan_port_default_action_get(unit, port, &action));
        }
        action.new_outer_vlan = vid;
        action.priority = PORT(unit, local_port).p_ut_prio;
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (soc_feature(unit, soc_feature_decouple_protocol_vlan)){
            BCM_IF_ERROR_RETURN(_bcm_trx_vlan_action_verify(unit, &action));
            BCM_IF_ERROR_RETURN
                (mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg));
            pcfg.pc_vlan = action.new_outer_vlan;
            if (action.priority >= BCM_PRIO_MIN &&
                action.priority <= BCM_PRIO_MAX) {
                pcfg.pc_new_opri = action.priority;
            }
            return (mbcm_driver[unit]->mbcm_port_cfg_set(unit, port, &pcfg));
        }
#endif /* BCM_TOMAHAWK2_SUPPORT */
#if defined(BCM_TOMAHAWK3_SUPPORT)
		if(SOC_IS_TOMAHAWK3(unit)) {
			return _bcm_th3_vlan_port_default_action_set(unit, port, &action);
		} else
#endif
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
        if (SOC_IS_KATANA2(unit) || SOC_IS_TOMAHAWKX(unit) || SOC_IS_TRIDENT3X(unit)) {
            return _bcm_trx_vlan_port_default_action_profile_set(unit, port, &action);
        } else
#endif
        {
            return _bcm_trx_vlan_port_default_action_set(unit, port, &action);
        }
    }
#endif

    BCM_IF_ERROR_RETURN
        (mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg));

#if defined(BCM_FIREBOLT_SUPPORT)
    pdvid = pcfg.pc_vlan;
#endif /* BCM_FIREBOLT_SUPPORT */
    pcfg.pc_vlan = vid;

    BCM_IF_ERROR_RETURN
        (mbcm_driver[unit]->mbcm_port_cfg_set(unit, port, &pcfg));

#if defined(BCM_FIREBOLT_SUPPORT)
    if (SOC_IS_FBX(unit)) {
        /*
         * Update default VLAN ID in VLAN_PROTOCOL_DATA
         */
        int rv = _bcm_fb_port_untagged_vlan_data_update(unit, port,
                                                        pdvid, vid);
        if (rv != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "failed updating default VLAN ID "
                                  "in VLAN_PROTOCOL_DATA: %s\n"), bcm_errmsg(rv)));
        }
    }
#endif /* BCM_FIREBOLT_SUPPORT */

    if (!soc_feature(unit, soc_feature_remap_ut_prio)) {
        /* Reset the untagged port priority filter entry, if any */

        BCM_IF_ERROR_RETURN
            (bcm_esw_port_untagged_priority_get(unit, port, &ut_prio));

        BCM_IF_ERROR_RETURN
            (bcm_esw_port_untagged_priority_set(unit, port, ut_prio));
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_untagged_vlan_set
 * Purpose:
 *      Set the default VLAN ID for the port.
 *      This is the VLAN ID assigned to received untagged packets.
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      port - StrataSwitch port number.
 *      vid -  VLAN ID used for packets that ingress the port untagged
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_NOT_FOUND if vid not in VTABLE
 *      BCM_E_INTERNAL if table read failed.
 *      BCM_E_CONFIG - port does not belong to the VLAN
 * Notes:
 *      BCM_LOCK is used because bcm_vlan_port_get is called internally
 *      which also takes it.  BCM_LOCK must be taken before PORT_LOCK.
 */

int
bcm_esw_port_untagged_vlan_set(int unit, bcm_port_t port, bcm_vlan_t vid)
{
    int rv;

    VLAN_CHK_ID(unit, vid);

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if ((defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)) \
     && defined(INCLUDE_L3))
    if (BCM_GPORT_IS_WLAN_PORT(port)) {
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return bcm_tr3_wlan_port_untagged_vlan_set(unit, port, vid);
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
            return bcm_tr2_wlan_port_untagged_vlan_set(unit, port, vid);
        }
    }
#endif

#if defined(BCM_TRIDENT_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_NIV_PORT(port)) {
        return bcm_trident_niv_port_untagged_vlan_set(unit, port, vid);
    }
#endif

#if defined(BCM_TRIUMPH3_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_EXTENDER_PORT(port)) {
        return bcm_tr3_extender_port_untagged_vlan_set(unit, port, vid);
    }
#endif

#ifdef BCM_HGPROXY_COE_SUPPORT
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        (soc_feature(unit, soc_feature_channelized_switching))) &&
         _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
    } else
#endif
    {
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_gport_validate(unit, port, &port));
    }

    if (SOC_IS_TOMAHAWKX(unit) || SOC_IS_TD2P_TT2P(unit) ||
        SOC_IS_TRIDENT3X(unit) ||
        SOC_IS_KATANAX(unit) || SOC_IS_SABER2(unit)) {
        BCM_IF_ERROR_RETURN
        (_bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                               PORT_VIDf, vid));
    }

    PORT_LOCK(unit);
    rv = _bcm_port_untagged_vlan_set(unit, port, vid);
    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_untagged_vlan_set: u=%d p=%d vid=%d rv=%d\n"),
              unit, port, vid, rv));

    return rv;
}

/*
 * Function:
 *      _bcm_esw_port_ingress_dest_enable
 * Purpose:
 *      Enables/disables all forwarding to port in the last stage
 *      of the ingress pipeline, including SOBMH and all
 *      other types of traffic.  Works for all egress ports,
 *      including CPU port.
 * Parameters:
 *      unit   - (IN) Device number.
 *      port   - (IN) Port number.
 *      enable - (IN) TRUE, forward traffic
 *                    FALSE, block traffic
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_esw_port_ingress_dest_enable(int unit, bcm_port_t port, int enable)
{
#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TOMAHAWK2_SUPPORT)
    ing_dest_port_enable_entry_t dest_e;
    bcm_pbmp_t dest_e_pbmp;
    sal_usecs_t delay;
    int speed;
    int change = FALSE;

    SOC_IF_ERROR_RETURN
        (READ_ING_DEST_PORT_ENABLEm(unit, MEM_BLOCK_ANY, 0, &dest_e));

    soc_mem_pbmp_field_get(unit, ING_DEST_PORT_ENABLEm,
                           &dest_e, PORT_BITMAPf, &dest_e_pbmp);

    if (enable) {
        if (!SOC_PBMP_MEMBER(dest_e_pbmp, port)) {
            SOC_PBMP_PORT_ADD(dest_e_pbmp, port);
            change = TRUE;
        }
    } else {
        if (SOC_PBMP_MEMBER(dest_e_pbmp, port)) {
            SOC_PBMP_PORT_REMOVE(dest_e_pbmp, port);
            change = TRUE;
        }
    }

    if (change) {
        soc_mem_pbmp_field_set(unit, ING_DEST_PORT_ENABLEm,
                               &dest_e, PORT_BITMAPf, &dest_e_pbmp);
        SOC_IF_ERROR_RETURN
            (WRITE_ING_DEST_PORT_ENABLEm(unit, MEM_BLOCK_ANY, 0, &dest_e));

        /*
         * On a disable operation, ensure that no further cells
         * arrive to MMU in order to reconfigure the MMU safely,
         * and the flush mechanism in the MMU to work properly.
         *
         * This requires a delay to ensure packet EOP has arrived at MMU
         * (the is the only method.  The time is based on the largest
         * possible frame at the slowest possible source port speed.
         */
        if (!enable) {
            BCM_IF_ERROR_RETURN
                (bcm_esw_port_speed_get(unit, port, &speed));

            if ((speed == 10) || (speed == 100)) {
                delay = 8000;  /* 8 msecs */
            } else {
                /*
                 * This assumes the CPU port can sustain 1GE performance
                 * over the duration of an MTU.
                 */
                delay = 80;    /* 80 usecs */
            }
            sal_udelay(delay);
        }
    }

    return BCM_E_NONE;
#else  /* BCM_TRIDENT2PLUS_SUPPORT */
    return BCM_E_UNAVAIL;
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
}

/*
 * Function:
 *      _bcmi_esw_port_linkphy_subport_dfc_update
 * Purpose:
 *      Updates the DFC for the stream ids associated with Linkphy gport.
 * Parameters:
 *      unit   - (IN) Device number.
 *      subport_gport - (IN) Linkphy gport.
 *      enable - (IN) Port enable/disable status.
 * Returns:
 *      BCM_E_XXX
 */

#ifdef BCM_KATANA2_SUPPORT
int
_bcmi_esw_port_linkphy_subport_dfc_update(int unit, bcm_port_t subport_gport,
                                          int enable)
{
    bcm_subport_config_t config;
    int stream_id = 0;

    BCM_IF_ERROR_RETURN(bcm_esw_subport_port_get(unit, subport_gport, &config));

    /* Run through the streams and perform needed actions */
    for (stream_id = 0; stream_id < config.num_streams; stream_id++) {
            BCM_IF_ERROR_RETURN(_bcmi_linkphy_subport_stream_dfc_update(unit,
                                   &config,
                                  _BCM_KT2_SUBPORT_PORT_ID_GET(subport_gport),
                                   config.stream_id_array[stream_id], enable));
    }

    return BCM_E_NONE;
}

int
_bcmi_esw_port_linkphy_subport_flush(int unit, bcm_port_t subport_gport)
{
    bcm_subport_config_t config;
    int stream_id = 0;

    BCM_IF_ERROR_RETURN(bcm_esw_subport_port_get(unit, subport_gport, &config));

    /* Run through the streams and perform needed actions */
    for (stream_id = 0; stream_id < config.num_streams; stream_id++) {
            BCM_IF_ERROR_RETURN(_bcmi_linkphy_subport_stream_flush(unit,
                                   &config,
                                  _BCM_KT2_SUBPORT_PORT_ID_GET(subport_gport),
                                   config.stream_id_array[stream_id]));
    }

    return BCM_E_NONE;
}
#endif

/*
 * Function:
 *      _bcmi_esw_port_subport_enable_set
 * Purpose:
 *      Enable/disable a subport.
 * Parameters:
 *      unit - StrataSwitch unit #.
 *      port - StrataSwitch port #.
 *      is_subtag_port - TRUE if this is subtag port, linkphy otherwise
 *      enable - TRUE, port is enabled, FALSE port is disabled.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcmi_esw_port_subport_enable_set(int unit, bcm_port_t port,
                                  int is_subtag_port, int enable)
{

    int rv = BCM_E_NONE;

#ifdef BCM_KATANA2_SUPPORT
    pbmp_t      mask;
    int         subport_gport = port;

    BCM_IF_ERROR_RETURN(
        _bcm_esw_port_gport_validate(unit, port, &port));

    /* Set/Unset the port in the relevant enabled pbmp */
    if(is_subtag_port) {

        /* Check if the setting is already in effect */
        if((enable &&
            BCM_PBMP_MEMBER(SOC_INFO(unit).enabled_subtag_pp_port_pbm,
                                  port)) ||
           (!enable &&
            !(BCM_PBMP_MEMBER(SOC_INFO(unit).enabled_subtag_pp_port_pbm,
                                  port)))) {
            /* Already in effect, return OK */
            return  BCM_E_NONE;
        }

        if(enable) {
            BCM_PBMP_PORT_ADD(SOC_INFO(unit).enabled_subtag_pp_port_pbm,
                              port);
        } else {
            BCM_PBMP_PORT_REMOVE(SOC_INFO(unit).enabled_subtag_pp_port_pbm,
                              port);
        }
    } else {

        /* Check if the setting is already in effect */
        if((enable &&
            BCM_PBMP_MEMBER(SOC_INFO(unit).enabled_linkphy_pp_port_pbm,
                                  port)) ||
           (!enable &&
            !(BCM_PBMP_MEMBER(SOC_INFO(unit).enabled_linkphy_pp_port_pbm,
                                  port)))) {
            /* Already in effect, return OK */
            return  BCM_E_NONE;
        }

        if(enable) {
            BCM_PBMP_PORT_ADD(SOC_INFO(unit).enabled_linkphy_pp_port_pbm,
                              port);
        } else {
            BCM_PBMP_PORT_REMOVE(SOC_INFO(unit).enabled_linkphy_pp_port_pbm,
                              port);
        }
    }

    /* Get the current mask */
    soc_link_mask2_get(unit, &mask);
    /* Make a call so that the enable/disable we did above take effect,
     * note that 'soc_link_mask2_set' works on the pbmps we updated above,
     * we still pass the existing bpmp since it gets re-assigned
     */
    SOC_IF_ERROR_RETURN(soc_link_mask2_set(unit, mask));

    /* Some special processing needed for enable/disable of LinkPhy ports */
    if (!is_subtag_port) {

        /* Updates DFC for the streams */
        BCM_IF_ERROR_RETURN(_bcmi_esw_port_linkphy_subport_dfc_update(unit,
                            subport_gport, enable));
        if (!enable) {
        /* Flush the related MMU queues */
        BCM_IF_ERROR_RETURN(bcm_kt2_cosq_port_flush(unit,
                                  port, bcmCosqFlushTypeQueue));

        /* Flush the relevant RXLP */
        BCM_IF_ERROR_RETURN(_bcmi_esw_port_linkphy_subport_flush(unit,
                                                 subport_gport));
    }
    }

#endif

    return rv;
}

/*
 * Function:
 *      _bcmi_esw_port_subport_enable_get
 * Purpose:
 *      Get Enable/disable state of a subport.
 * Parameters:
 *      unit - StrataSwitch unit #.
 *      port - StrataSwitch port #.
 *      is_subtag_port - TRUE if this is subtag port, linkphy otherwise
 *      *enable - Return enable value.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcmi_esw_port_subport_enable_get(int unit, bcm_port_t port,
                                  int is_subtag_port, int *enable)
{
    int rv = BCM_E_NONE;

#ifdef BCM_KATANA2_SUPPORT
    /* Start with enabled set to 0 */
    *enable = 0;

    BCM_IF_ERROR_RETURN(
        _bcm_esw_port_gport_validate(unit, port, &port));

    /* Depending on subtag/linkphy, check if the port is enabled */
    if(is_subtag_port) {
        if (BCM_PBMP_MEMBER(SOC_INFO(unit).enabled_subtag_pp_port_pbm,
                        port)) {
            *enable = 1;
        }
    } else {
        if (BCM_PBMP_MEMBER(SOC_INFO(unit).enabled_linkphy_pp_port_pbm,
                        port)) {
            *enable = 1;
        }
    }
    rv = BCM_E_NONE;
#endif

    return rv;
}

/*
 * Function:
 *      bcm_port_enable_set
 * Purpose:
 *      Physically enable/disable the MAC/PHY on this port.
 * Parameters:
 *      unit - StrataSwitch unit #.
 *      port - StrataSwitch port #.
 *      enable - TRUE, port is enabled, FALSE port is disabled.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      If linkscan is running, it also controls the MAC enable state.
 */

int
bcm_esw_port_enable_set(int unit, bcm_port_t port, int enable)
{
    int         rv = BCM_E_NONE;
    int         link, loopback = BCM_PORT_LOOPBACK_NONE;
    pbmp_t      mask;

#if defined (BCM_TRIUMPH3_SUPPORT) || defined (BCM_MONTEREY_SUPPPORT)
    int         skip_phy_en = 0;
#endif /* BCM_TRIUMPH3_SUPPORT */
    soc_persist_t       *sop = SOC_PERSIST(unit);

#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
    uint8 is_subtag_port = FALSE, is_linkphy_port = FALSE;
#endif
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#ifdef BCM_KATANA2_SUPPORT
    if(BCM_GPORT_IS_SUBPORT_PORT(port)) {
        if (soc_feature(unit, soc_feature_subtag_coe) &&
            _BCM_KT2_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
           is_subtag_port = TRUE;
       } else if (soc_feature(unit, soc_feature_linkphy_coe) &&
                  _BCM_KT2_GPORT_IS_LINKPHY_SUBPORT_PORT(unit, port)) {
           is_linkphy_port = TRUE;
       }
       if(is_subtag_port || is_linkphy_port) {
           PORT_LOCK(unit);
           rv = _bcmi_esw_port_subport_enable_set(unit, port,
                                                  is_subtag_port, enable);
           PORT_UNLOCK(unit);
           return rv;
        }
    }
#endif

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return (bcmi_esw_portctrl_enable_set(unit, port, enable));
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot enable OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    if (!BCM_GPORT_IS_SET(port)) {
        if (!SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit),port)) {
            return BCM_E_PORT;
        }
    }

    BCM_IF_ERROR_RETURN(
        _bcm_esw_port_gport_validate(unit, port, &port));

#ifdef BCM_RCPU_SUPPORT
    if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, port)) {
        return BCM_E_PORT;
    }
#endif /* BCM_RCPU_SUPPORT */

#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit) && !enable) {
        _bcm_esw_ibod_syn_port_down(unit, port);
    }
#endif /* BCM_TRIUMPH3_SUPPORT */

    PORT_LOCK(unit);

    bcm_esw_port_loopback_get(unit, port, &loopback);

    if (enable) {
        if (SOC_PBMP_MEMBER(SOC_PORT_DISABLED_BITMAP(unit,all), port)) {
            PORT_UNLOCK(unit);
            return BCM_E_NONE;
        }

#ifdef BCM_TRIUMPH3_SUPPORT
        if (!skip_phy_en) {
#endif /* BCM_TRIUMPH3_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
            /*
             * When the PHY is TSC and port is configured to MAC loopback,
             * need to unsquelch TX LANE.
             */
            if ((SOC_IS_TD2_TT2(unit) && !SOC_IS_TOMAHAWKX(unit))
                && !(SOC_IS_HURRICANE4(unit) && IS_EGPHY_PORT(unit, port))
                && (loopback == BCM_PORT_LOOPBACK_MAC)) {
                (void)soc_phyctrl_notify(unit, port, phyEventTxSquelch, FALSE);
            }
#endif /* BCM_TRIDENT2_SUPPORT */
            rv = soc_phyctrl_enable_set(unit, port, TRUE);
#ifdef BCM_TRIUMPH3_SUPPORT
        }
#endif /* BCM_TRIUMPH3_SUPPORT */
        if (SOC_SUCCESS(rv)) {
            /* Get link status after PHY state has been set */
            rv = bcm_esw_port_link_status_get(unit, port, &link);
            if (BCM_FAILURE(rv)) {
                if (rv == BCM_E_INIT) {
                    link = FALSE;
                    rv = BCM_E_NONE;
                } else {
                    PORT_UNLOCK(unit);
                    return rv;
                }
            }

            if (link || (loopback != BCM_PORT_LOOPBACK_NONE)
                || SOC_PBMP_MEMBER(sop->lc_pbm_fc, port)
                || SOC_PBMP_MEMBER(sop->lc_pbm_linkdown_tx, port)) {
                rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, TRUE);
                if (loopback == BCM_PORT_LOOPBACK_MAC) {
                    /* Add port to EPC_LINK */
                    soc_link_mask2_get(unit, &mask);
                    SOC_PBMP_PORT_ADD(mask, port);
                    rv = soc_link_mask2_set(unit, mask);
                    if (BCM_FAILURE(rv)) {
                        PORT_UNLOCK(unit);
                        return (rv);
                    }
                }
            }
        }

        if (SOC_SUCCESS(rv)) {
            /* Enable forwarding traffic */
            if (soc_feature(unit, soc_feature_ingress_dest_port_enable)) {
                rv = _bcm_esw_port_ingress_dest_enable(unit, port, enable);
                if (BCM_FAILURE(rv)) {
                    PORT_UNLOCK(unit);
                    return rv;
                }
            }
        }

    } else {

        /* Disable all forwarding traffic */
        if (soc_feature(unit, soc_feature_ingress_dest_port_enable)) {
            rv = _bcm_esw_port_ingress_dest_enable(unit, port, enable);
            if (BCM_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return rv;
            }
        }
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_HELIX4_SUPPORT)
    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
        bcm_port_info_t tmp_port_info;
        bcm_port_info_t_init(&tmp_port_info);
        tmp_port_info.linkstatus = BCM_PORT_LINK_STATUS_DOWN;
        SOC_LINKSCAN_MODPORT_MAP_LOCK(unit);
        rv = _bcm_td_stk_modport_map_linkscan_handler(unit, port,
                                                      &tmp_port_info);
        SOC_LINKSCAN_MODPORT_MAP_UNLOCK(unit);
        if (BCM_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
    }
#endif /* #(BCM_TRIUMPH3_SUPPORT) || defined(BCM_HELIX4_SUPPORT) */
        /* Remove from EPC_LINK to prevent packet queued to this port from TX */
        soc_link_mask2_get(unit, &mask);
        SOC_PBMP_PORT_REMOVE(mask, port);
        rv = soc_link_mask2_set(unit, mask);
        if (BCM_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
#ifdef BCM_HURRICANE4_SUPPORT
        /* Wait 8ms. For non-MAC LB case its handled in MAC RESET */
        if (SOC_IS_HURRICANE4(unit) && IS_EGPHY_PORT(unit, port) &&
            (loopback == BCM_PORT_LOOPBACK_MAC)) {
            int wait_us = 8000;
            if (SAL_BOOT_QUICKTURN) {
                wait_us += 10000;
            }
            sal_usleep(wait_us);
        }
#endif
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Disable and isolate port %d..\n"),
                     port));
        if ((!SOC_IS_TD2_TT2(unit) && (loopback != BCM_PORT_LOOPBACK_MAC)) ||
            (SOC_IS_TOMAHAWKX(unit) && (loopback != BCM_PORT_LOOPBACK_MAC))) {
            /* Disable MAC RX to prevent traffic going into this port */
            MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                            SOC_MAC_CONTROL_RX_SET, FALSE);
            sal_udelay(100); /* Wait for 1 jumbo packet transmission time */
        }

#ifdef BCM_KATANA_SUPPORT
        if (SOC_IS_KATANA(unit)) {
            /*
             * When the port is configured to MAC loopback,
             * can't disabling MAC.
             * But in Saber2, credits are released when MAC goes down.
             */
            if (SOC_IS_SABER2(unit) || (loopback != BCM_PORT_LOOPBACK_MAC)) {
                rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, FALSE);
            }
            if ((SOC_SUCCESS(rv))) {
                MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                SOC_MAC_CONTROL_DISABLE_PHY, TRUE);
                rv = soc_phyctrl_enable_set(unit, port, FALSE);
                if (BCM_FAILURE(rv)) {
                    LOG_WARN(BSL_LS_BCM_PORT,
                             (BSL_META_U(unit,
                                         "u=%d p=%d soc_phyctrl_enable_set rv=%d\n"),
                              unit, port, rv));
                }
                MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                SOC_MAC_CONTROL_DISABLE_PHY, FALSE);
            }
        } else
#endif /* BCM_KATANA_SUPPORT */
        {
            MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                            SOC_MAC_CONTROL_DISABLE_PHY, TRUE);

#ifdef BCM_TRIDENT2_SUPPORT
            /*
             * When the PHY is TSC and port is configured to MAC loopback,
             * need to squelch the TX lane instead of disabling PHY.
             */
            if ((SOC_IS_TD2_TT2(unit) && !SOC_IS_TOMAHAWKX(unit))
                && !(SOC_IS_HURRICANE4(unit) && IS_EGPHY_PORT(unit, port))
                && (loopback == BCM_PORT_LOOPBACK_MAC)) {
                (void)soc_phyctrl_notify(unit, port, phyEventTxSquelch, TRUE);
            } else
#endif /* BCM_TRIDENT2_SUPPORT */
            {
                rv = soc_phyctrl_enable_set(unit, port, FALSE);
            }

            MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                            SOC_MAC_CONTROL_DISABLE_PHY, FALSE);
            /*
             * When the port is configured to MAC loopback,
             * can't disabling MAC.
             */
            if (SOC_IS_SABER2(unit) || (loopback != BCM_PORT_LOOPBACK_MAC)) {
                if (SOC_SUCCESS(rv)) {
                    rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, FALSE);
                }
            }
        }
    }

#ifdef BCM_SABER2_SUPPORT
    if (SOC_IS_SABER2(unit)) {
        rv = soc_saber2_port_enable_set(unit, port, enable);
        if (BCM_FAILURE(rv)) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "u=%d p=%d soc_saber2_port_enable_set rv=%d\n"),
                      unit, port, rv));
        }
    } else
#endif
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        rv = soc_katana2_port_enable_set(unit, port, enable);
        if (BCM_FAILURE(rv)) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "u=%d p=%d soc_katana2_port_enable_set rv=%d\n"),
                      unit, port, rv));
        }
    }
#endif
#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        PORT(unit, port).enable = enable;
    }
#endif /* BCM_TRIDENT2_SUPPORT */

#ifdef SW_AUTONEG_SUPPORT
    rv = _bcm_esw_port_notify_link_down_evt(unit, port);
    if (BCM_FAILURE(rv)) {
        LOG_WARN(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit,
                             "u=%d p=%d NOTIFY LINK DOWN EVT rv=%d\n"),
                  unit, port, rv));
        PORT_UNLOCK(unit);
        return rv;
    }
#endif

    PORT_UNLOCK(unit);

    if (loopback != BCM_PORT_LOOPBACK_NONE) {
        if (loopback == BCM_PORT_LOOPBACK_MAC) {
            rv = _bcm_esw_link_force(unit, 0 /*flags*/, port, TRUE, TRUE);
        } else {
            rv = _bcm_esw_link_force(unit, 0 /*flags*/, port, TRUE, enable);
        }
    }
    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_enable_set: u=%d p=%d enable=%d rv=%d\n"),
              unit, port, enable, rv));

#ifdef BCM_WARM_BOOT_SUPPORT
    SOC_CONTROL_LOCK(unit);
    SOC_CONTROL(unit)->scache_dirty = 1;
    SOC_CONTROL_UNLOCK(unit);
#endif

    return rv;
}

/*
 * Function:
 *      bcm_port_enable_get
 * Purpose:
 *      Gets the enable state as defined by bcm_port_enable_set()
 * Parameters:
 *      unit - StrataSwitch unit #.
 *      port - StrataSwitch port #.
 *      enable - (OUT) TRUE, port is enabled, FALSE port is disabled.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      The PHY enable holds the port enable state set by the user.
 *      The MAC enable transitions up and down automatically via linkscan
 *      even if user port enable is always up.
 */

int
bcm_esw_port_enable_get(int unit, bcm_port_t port, int *enable)
{
    int                 rv=BCM_E_NONE;
#if defined(BCM_KATANA2_SUPPORT)
    uint8       is_subtag_port = FALSE, is_linkphy_port = FALSE;
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Check for PortMod */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_enable_get(unit, port, enable);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif


#ifdef BCM_KATANA2_SUPPORT
    if(BCM_GPORT_IS_SUBPORT_PORT(port)) {
        if (soc_feature(unit, soc_feature_subtag_coe) &&
           _BCM_KT2_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
           is_subtag_port = TRUE;
       } else if (soc_feature(unit, soc_feature_linkphy_coe) &&
           _BCM_KT2_GPORT_IS_LINKPHY_SUBPORT_PORT(unit, port)) {
           is_linkphy_port = TRUE;
       }

       if (is_subtag_port || is_linkphy_port) {
            return _bcmi_esw_port_subport_enable_get(unit, port,
                                                     is_subtag_port, enable);
       }
    }
#endif

    BCM_IF_ERROR_RETURN(
        _bcm_esw_port_gport_validate(unit, port, &port));

    if (SOC_PBMP_MEMBER(SOC_PORT_DISABLED_BITMAP(unit,all), port)) {
        *enable = 0;
        return BCM_E_NONE;
    }

    PORT_LOCK(unit);
    rv = soc_phyctrl_enable_get(unit, port, enable);
#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        *enable = (PORT(unit, port).enable) & (*enable);
    }
#endif /* BCM_TRIDENT2_SUPPORT */

    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_enable_get: u=%d p=%d rv=%d enable=%d\n"),
              unit, port, rv, *enable));

    return rv;
}

/*
 * Function:
 *      _bcm_port_mode_setup
 * Purpose:
 *      Set initial operating mode for a port.
 * Parameters:
 *      unit - StrataSwitch unit #.
 *      port - StrataSwitch port #.
 *      enable - Whether to enable or disable
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      Must be called with PORT_LOCK held.
 */

int
_bcm_port_mode_setup(int unit, bcm_port_t port, int enable)
{
    soc_port_if_t       pif;
    bcm_port_ability_t  local_pa, advert_pa;

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return (bcmi_esw_portctrl_mode_setup(unit, port, enable));
    }

    sal_memset(&local_pa,  0, sizeof(bcm_port_ability_t));
    sal_memset(&advert_pa, 0, sizeof(bcm_port_ability_t));

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "_bcm_port_mode_setup: u=%d p=%d\n"), unit, port));

    SOC_IF_ERROR_RETURN(bcm_esw_port_ability_local_get(unit, port, &local_pa));

    if (IS_TDM_PORT(unit, port)) {
        return BCM_E_NONE;
    }

    /* If MII supported, enable it, otherwise use TBI */
    if (local_pa.interface & (SOC_PA_INTF_MII | SOC_PA_INTF_GMII |
                              SOC_PA_INTF_SGMII | SOC_PA_INTF_XGMII)) {
        if (IS_GE_PORT(unit, port)) {
            pif = SOC_PORT_IF_GMII;
        } else if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port)) {
            if (local_pa.interface & SOC_PA_INTF_XGMII) {
                pif = SOC_PORT_IF_XGMII;
            } else { /*  external GbE phy in xe port mode */
                pif = SOC_PORT_IF_SGMII;
            }
        } else {
            pif = SOC_PORT_IF_MII;
        }
    } else if (local_pa.interface & SOC_PA_INTF_CGMII) {
        pif = SOC_PORT_IF_CGMII;
    } else {
        pif = SOC_PORT_IF_TBI;
    }

    SOC_IF_ERROR_RETURN
        (soc_phyctrl_interface_set(unit, port, pif));
    SOC_IF_ERROR_RETURN
        (MAC_INTERFACE_SET(PORT(unit, port).p_mac, unit, port, pif));

    if (IS_ST_PORT(unit, port)) {

        /* Since stacking port doesn't support flow control,
         * make sure that PHY is not advertising flow control capabilities.
         */
        SOC_IF_ERROR_RETURN(
            soc_phyctrl_ability_advert_get(unit, port, &advert_pa));
        advert_pa.pause &= ~(SOC_PA_PAUSE | SOC_PA_PAUSE_ASYMM);
        SOC_IF_ERROR_RETURN(
            soc_phyctrl_ability_advert_set(unit, port, &advert_pa));
    }

    if (!SOC_WARM_BOOT(unit) &&
        !(SOC_PBMP_MEMBER(SOC_PORT_DISABLED_BITMAP(unit,all), port)) ) {
#ifdef BCM_RCPU_SUPPORT
        if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, port)) {
            /* Do not enable/disable rcpu port. */
            return BCM_E_NONE;
        }
#endif /* BCM_RCPU_SUPPORT */
        SOC_IF_ERROR_RETURN
            (MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, enable));
    }

    return BCM_E_NONE;
}

STATIC int
_bcm_esw_port_e2ecc_hdr_set(int unit, int port, soc_higig_e2ecc_hdr_t *e2ecc_hdr)
{
    uint64 rval64;

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_e2ecc_hdr_set(unit, port, e2ecc_hdr);
    }

    if (!e2ecc_hdr) {
        return BCM_E_PARAM;
    }

    if (SOC_IS_TD2_TT2(unit) || SOC_IS_SABER2(unit) ||
        SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
        if (IS_CL_PORT(unit, port)) {
            COMPILER_64_ZERO(rval64);
            soc_reg64_field32_set(unit, CLMAC_E2ECC_MODULE_HDR_0r, &rval64,
                                  E2ECC_MODULE_HDR_0_HIf, e2ecc_hdr->overlay1.words[0]);
            soc_reg64_field32_set(unit, CLMAC_E2ECC_MODULE_HDR_0r, &rval64,
                                  E2ECC_MODULE_HDR_0_LOf, e2ecc_hdr->overlay1.words[1]);
            BCM_IF_ERROR_RETURN(soc_reg_set(unit, CLMAC_E2ECC_MODULE_HDR_0r,
                                            port, 0, rval64));

            COMPILER_64_ZERO(rval64);
            soc_reg64_field32_set(unit, CLMAC_E2ECC_MODULE_HDR_1r, &rval64,
                                  E2ECC_MODULE_HDR_1_HIf, e2ecc_hdr->overlay1.words[2]);
            soc_reg64_field32_set(unit, CLMAC_E2ECC_MODULE_HDR_1r, &rval64,
                                  E2ECC_MODULE_HDR_1_LOf, e2ecc_hdr->overlay1.words[3]);
            BCM_IF_ERROR_RETURN(soc_reg_set(unit, CLMAC_E2ECC_MODULE_HDR_1r,
                                            port, 0, rval64));

            COMPILER_64_ZERO(rval64);
            soc_reg64_field32_set(unit, CLMAC_E2ECC_DATA_HDR_0r, &rval64,
                                  E2ECC_DATA_HDR_0_HIf, e2ecc_hdr->overlay1.words[4]);
            soc_reg64_field32_set(unit, CLMAC_E2ECC_DATA_HDR_0r, &rval64,
                                  E2ECC_DATA_HDR_0_LOf, e2ecc_hdr->overlay1.words[5]);
            BCM_IF_ERROR_RETURN(soc_reg_set(unit, CLMAC_E2ECC_DATA_HDR_0r,
                                            port, 0, rval64));

            COMPILER_64_ZERO(rval64);
            soc_reg64_field32_set(unit, CLMAC_E2ECC_DATA_HDR_1r, &rval64,
                                  E2ECC_DATA_HDR_1_HIf, e2ecc_hdr->overlay1.words[6]);
            soc_reg64_field32_set(unit, CLMAC_E2ECC_DATA_HDR_1r, &rval64,
                                  E2ECC_DATA_HDR_1_LOf, e2ecc_hdr->overlay1.words[7]);
            BCM_IF_ERROR_RETURN(soc_reg_set(unit, CLMAC_E2ECC_DATA_HDR_1r,
                                            port, 0, rval64));
        } else {
            COMPILER_64_ZERO(rval64);
            soc_reg64_field32_set(unit, XLMAC_E2ECC_MODULE_HDR_0r, &rval64,
                                  E2ECC_MODULE_HDR_0_HIf, e2ecc_hdr->overlay1.words[0]);
            soc_reg64_field32_set(unit, XLMAC_E2ECC_MODULE_HDR_0r, &rval64,
                                  E2ECC_MODULE_HDR_0_LOf, e2ecc_hdr->overlay1.words[1]);
            BCM_IF_ERROR_RETURN(soc_reg_set(unit, XLMAC_E2ECC_MODULE_HDR_0r,
                                            port, 0, rval64));

            COMPILER_64_ZERO(rval64);
            soc_reg64_field32_set(unit, XLMAC_E2ECC_MODULE_HDR_1r, &rval64,
                                  E2ECC_MODULE_HDR_1_HIf, e2ecc_hdr->overlay1.words[2]);
            soc_reg64_field32_set(unit, XLMAC_E2ECC_MODULE_HDR_1r, &rval64,
                                  E2ECC_MODULE_HDR_1_LOf, e2ecc_hdr->overlay1.words[3]);
            BCM_IF_ERROR_RETURN(soc_reg_set(unit, XLMAC_E2ECC_MODULE_HDR_1r,
                                            port, 0, rval64));

            COMPILER_64_ZERO(rval64);
            soc_reg64_field32_set(unit, XLMAC_E2ECC_DATA_HDR_0r, &rval64,
                                  E2ECC_DATA_HDR_0_HIf, e2ecc_hdr->overlay1.words[4]);
            soc_reg64_field32_set(unit, XLMAC_E2ECC_DATA_HDR_0r, &rval64,
                                  E2ECC_DATA_HDR_0_LOf, e2ecc_hdr->overlay1.words[5]);
            BCM_IF_ERROR_RETURN(soc_reg_set(unit, XLMAC_E2ECC_DATA_HDR_0r,
                                            port, 0, rval64));

            COMPILER_64_ZERO(rval64);
            soc_reg64_field32_set(unit, XLMAC_E2ECC_DATA_HDR_1r, &rval64,
                                  E2ECC_DATA_HDR_1_HIf, e2ecc_hdr->overlay1.words[6]);
            soc_reg64_field32_set(unit, XLMAC_E2ECC_DATA_HDR_1r, &rval64,
                                  E2ECC_DATA_HDR_1_LOf, e2ecc_hdr->overlay1.words[7]);
            BCM_IF_ERROR_RETURN(soc_reg_set(unit, XLMAC_E2ECC_DATA_HDR_1r,
                                            port, 0, rval64));
        }
    } else {
        SOC_IF_ERROR_RETURN
            (WRITE_XHOL_MH0r(unit, port, e2ecc_hdr->overlay1.words[0]));
        SOC_IF_ERROR_RETURN
            (WRITE_XHOL_MH1r(unit, port, e2ecc_hdr->overlay1.words[1]));
        SOC_IF_ERROR_RETURN
            (WRITE_XHOL_MH2r(unit, port, e2ecc_hdr->overlay1.words[2]));
        SOC_IF_ERROR_RETURN
            (WRITE_XHOL_MH3r(unit, port, e2ecc_hdr->overlay1.words[3]));

        SOC_IF_ERROR_RETURN
            (WRITE_XHOL_D0r(unit, port, e2ecc_hdr->overlay1.words[4]));
        SOC_IF_ERROR_RETURN
            (WRITE_XHOL_D1r(unit, port, e2ecc_hdr->overlay1.words[5]));
        SOC_IF_ERROR_RETURN
            (WRITE_XHOL_D2r(unit, port, e2ecc_hdr->overlay1.words[6]));
        SOC_IF_ERROR_RETURN
            (WRITE_XHOL_D3r(unit, port, e2ecc_hdr->overlay1.words[7]));
    }

    return BCM_E_NONE;
}

#ifdef BCM_WARM_BOOT_SUPPORT
#if defined(BCM_TRX_SUPPORT)
STATIC int
_bcm_esw_port_e2ecc_hdr_get(int unit, int port, soc_higig_e2ecc_hdr_t *e2ecc_hdr)
{
    uint64 rval64;

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_e2ecc_hdr_get(unit, port, e2ecc_hdr);
    }

    if (!e2ecc_hdr) {
        return BCM_E_PARAM;
    }

    sal_memset(e2ecc_hdr, 0, sizeof(soc_higig_e2ecc_hdr_t));

    if (SOC_IS_TD2_TT2(unit) || SOC_IS_SABER2(unit) ||
        SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
        if (IS_CL_PORT(unit, port)) {
            BCM_IF_ERROR_RETURN(soc_reg_get(unit, CLMAC_E2ECC_MODULE_HDR_0r,
                                            port, 0, &rval64));
            e2ecc_hdr->overlay1.words[0] = soc_reg64_field32_get(unit,
                CLMAC_E2ECC_MODULE_HDR_0r, rval64, E2ECC_MODULE_HDR_0_HIf);
            e2ecc_hdr->overlay1.words[1] = soc_reg64_field32_get(unit,
                CLMAC_E2ECC_MODULE_HDR_0r, rval64, E2ECC_MODULE_HDR_0_LOf);

            BCM_IF_ERROR_RETURN(soc_reg_get(unit, CLMAC_E2ECC_MODULE_HDR_1r,
                                            port, 0, &rval64));
            e2ecc_hdr->overlay1.words[2] = soc_reg64_field32_get(unit,
                CLMAC_E2ECC_MODULE_HDR_1r, rval64, E2ECC_MODULE_HDR_1_HIf);
            e2ecc_hdr->overlay1.words[3] = soc_reg64_field32_get(unit,
                CLMAC_E2ECC_MODULE_HDR_1r, rval64, E2ECC_MODULE_HDR_1_LOf);

            BCM_IF_ERROR_RETURN(soc_reg_get(unit, CLMAC_E2ECC_DATA_HDR_0r,
                                            port, 0, &rval64));
            e2ecc_hdr->overlay1.words[4] = soc_reg64_field32_get(unit,
                CLMAC_E2ECC_DATA_HDR_0r, rval64, E2ECC_DATA_HDR_0_HIf);
            e2ecc_hdr->overlay1.words[5] = soc_reg64_field32_get(unit,
                CLMAC_E2ECC_DATA_HDR_0r, rval64, E2ECC_DATA_HDR_0_LOf);

            BCM_IF_ERROR_RETURN(soc_reg_get(unit, CLMAC_E2ECC_DATA_HDR_1r,
                                            port, 0, &rval64));
            e2ecc_hdr->overlay1.words[6] = soc_reg64_field32_get(unit,
                CLMAC_E2ECC_DATA_HDR_1r, rval64, E2ECC_DATA_HDR_1_HIf);
            e2ecc_hdr->overlay1.words[7] = soc_reg64_field32_get(unit,
                CLMAC_E2ECC_DATA_HDR_1r, rval64, E2ECC_DATA_HDR_1_LOf);
        } else {
            BCM_IF_ERROR_RETURN(soc_reg_get(unit, XLMAC_E2ECC_MODULE_HDR_0r,
                                            port, 0, &rval64));
            e2ecc_hdr->overlay1.words[0] = soc_reg64_field32_get(unit,
                XLMAC_E2ECC_MODULE_HDR_0r, rval64, E2ECC_MODULE_HDR_0_HIf);
            e2ecc_hdr->overlay1.words[1] = soc_reg64_field32_get(unit,
                XLMAC_E2ECC_MODULE_HDR_0r, rval64, E2ECC_MODULE_HDR_0_LOf);

            BCM_IF_ERROR_RETURN(soc_reg_get(unit, XLMAC_E2ECC_MODULE_HDR_1r,
                                            port, 0, &rval64));
            e2ecc_hdr->overlay1.words[2] = soc_reg64_field32_get(unit,
                XLMAC_E2ECC_MODULE_HDR_1r, rval64, E2ECC_MODULE_HDR_1_HIf);
            e2ecc_hdr->overlay1.words[3] = soc_reg64_field32_get(unit,
                XLMAC_E2ECC_MODULE_HDR_1r, rval64, E2ECC_MODULE_HDR_1_LOf);

            BCM_IF_ERROR_RETURN(soc_reg_get(unit, XLMAC_E2ECC_DATA_HDR_0r,
                                            port, 0, &rval64));
            e2ecc_hdr->overlay1.words[4] = soc_reg64_field32_get(unit,
                XLMAC_E2ECC_DATA_HDR_0r, rval64, E2ECC_DATA_HDR_0_HIf);
            e2ecc_hdr->overlay1.words[5] = soc_reg64_field32_get(unit,
                XLMAC_E2ECC_DATA_HDR_0r, rval64, E2ECC_DATA_HDR_0_LOf);

            BCM_IF_ERROR_RETURN(soc_reg_get(unit, XLMAC_E2ECC_DATA_HDR_1r,
                                            port, 0, &rval64));
            e2ecc_hdr->overlay1.words[6] = soc_reg64_field32_get(unit,
                XLMAC_E2ECC_DATA_HDR_1r, rval64, E2ECC_DATA_HDR_1_HIf);
            e2ecc_hdr->overlay1.words[7] = soc_reg64_field32_get(unit,
                XLMAC_E2ECC_DATA_HDR_1r, rval64, E2ECC_DATA_HDR_1_LOf);
        }
    } else {
        SOC_IF_ERROR_RETURN
            (READ_XHOL_MH0r(unit, port, &e2ecc_hdr->overlay1.words[0]));
        SOC_IF_ERROR_RETURN
            (READ_XHOL_MH1r(unit, port, &e2ecc_hdr->overlay1.words[1]));
        SOC_IF_ERROR_RETURN
            (READ_XHOL_MH2r(unit, port, &e2ecc_hdr->overlay1.words[2]));
        SOC_IF_ERROR_RETURN
            (READ_XHOL_MH3r(unit, port, &e2ecc_hdr->overlay1.words[3]));

        SOC_IF_ERROR_RETURN
            (READ_XHOL_D0r(unit, port, &e2ecc_hdr->overlay1.words[4]));
        SOC_IF_ERROR_RETURN
            (READ_XHOL_D1r(unit, port, &e2ecc_hdr->overlay1.words[5]));
        SOC_IF_ERROR_RETURN
            (READ_XHOL_D2r(unit, port, &e2ecc_hdr->overlay1.words[6]));
        SOC_IF_ERROR_RETURN
            (READ_XHOL_D3r(unit, port, &e2ecc_hdr->overlay1.words[7]));
    }

    return BCM_E_NONE;
}
#endif
#endif /* BCM_WARM_BOOT_SUPPORT */

#ifdef BCM_WARM_BOOT_SUPPORT

STATIC int
_bcm_port_vd_pbvl_reinit(int unit)
{

#if defined(BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit)) {
        /*
         * Reinit of vd_pbvl takes place at the end of function
         * _bcm_trx_vlan_action_profile_init().  This routine initializes
         * the VLAN profile tables first, which need to happen before
         * the vd_pbvl data is recovered.
         */
        return BCM_E_NONE;
    }
#endif /* BCM_TRX_SUPPORT */

#ifdef BCM_FIREBOLT_SUPPORT
    if (SOC_IS_FBX(unit)) {
        bcm_port_t port;
        _bcm_port_info_t *pinfo;
        int        idxmin, idx, i, index;
        int start, end;
        vlan_protocol_data_entry_t   vde;
        vlan_protocol_entry_t vpe;
        bcm_vlan_t            cvid, defvid;
        uint32                ft;
        bcm_pbmp_t            all_pbmp;

        BCM_PBMP_CLEAR(all_pbmp);
        BCM_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

#ifdef BCM_KATANA2_SUPPORT
        if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
            BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
        }
        if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
        }
#endif

        idxmin = soc_mem_index_min(unit, VLAN_PROTOCOL_DATAm);
        idx = soc_mem_index_min(unit, VLAN_PROTOCOLm);
        PBMP_ITER(all_pbmp, port) {

            start = idxmin + port*16;
            end   = start + 16;
            BCM_IF_ERROR_RETURN
                (bcm_esw_port_untagged_vlan_get(unit, port, &defvid));
            for (i = start; i < end; i++) {

                SOC_IF_ERROR_RETURN
                    (READ_VLAN_PROTOCOL_DATAm(unit, MEM_BLOCK_ANY,
                                              i, &vde));
                cvid = soc_VLAN_PROTOCOL_DATAm_field32_get(unit, &vde,
                                                           VLAN_IDf);
                if ((cvid == 0) || (cvid == defvid)) {
                    
                    continue;
                }

                /*
                 * Check against the VLAN_PROTOCOL table to see if a
                 * valid entry exists for matching the packet protocol
                 */
                index = i - start;
                SOC_IF_ERROR_RETURN
                    (READ_VLAN_PROTOCOLm(unit, MEM_BLOCK_ANY,
                                         idx+index, &vpe));
                ft = 0;
                if (soc_VLAN_PROTOCOLm_field32_get(unit, &vpe, ETHERIIf)) {
                    ft |= BCM_PORT_FRAMETYPE_ETHER2;
                }
                if (soc_VLAN_PROTOCOLm_field32_get(unit, &vpe, SNAPf)) {
                    ft |= BCM_PORT_FRAMETYPE_8023;
                }
                if (soc_VLAN_PROTOCOLm_field32_get(unit, &vpe, LLCf)) {
                    ft |= BCM_PORT_FRAMETYPE_LLC;
                }
                if (ft == 0) {
                    /*
                     * Something wrong here.. bail out
                     */
                    continue;
                }
                BCM_IF_ERROR_RETURN(_bcm_port_info_get(unit, port, &pinfo));
                if (!_BCM_PORT_VD_PBVL_IS_SET(pinfo, idx+index)) {
                    /* Set as explicit VID */
                    _BCM_PORT_VD_PBVL_SET(pinfo, idx+index);
                }
            }
        }
        return BCM_E_NONE;
    }
#endif /* BCM_FIREBOLT_SUPPORT */

    return BCM_E_NONE;
}

#if defined(BCM_TRX_SUPPORT)
/* Recover the port dtag_mode from Warm Boot cached info, if available. */
STATIC int
_bcm_trx_port_dtag_mode_reinit(int unit, bcm_pbmp_t dtm_pbmp, int use_pbmp)
{
    uint32   tpid_enable;
    bcm_port_t port;
    _bcm_port_info_t *pinfo;
    bcm_vlan_action_set_t action;
    bcm_pbmp_t all_pbmp;

    BCM_PBMP_CLEAR(all_pbmp);
    BCM_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));
    sal_memset(&action, 0, sizeof(bcm_vlan_action_set_t));

#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
    }
#endif

#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)){
        int oamp_enable;
        (void)bcm_sb2_sat_oamp_enable_get(unit, &oamp_enable);
        /* Skip OAMP port for saber2 device */
        if(oamp_enable) {
            SOC_PBMP_PORT_REMOVE(all_pbmp,
                    _BCM_SB2_SAT_OAMP_PHY_PORT_NUMBER);
        }
    }
#endif

    PBMP_ITER(all_pbmp, port) {
        BCM_IF_ERROR_RETURN(_bcm_port_info_get(unit, port, &pinfo));
        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_tab_get(unit, port, OUTER_TPID_ENABLEf, (int *)&tpid_enable));

        if (0 == tpid_enable) {
            if (use_pbmp && !BCM_PBMP_MEMBER(dtm_pbmp, port)) {
                /* Bitmap claims this is DT mode NONE, but it is
                 * configured for EXTERNAL */
                BCM_IF_ERROR_RETURN
                    (soc_event_generate(unit,
                                        BCM_SWITCH_EVENT_STABLE_ERROR,
                                        SOC_STABLE_STALE,
                                        SOC_STABLE_BASIC, 0));
                use_pbmp = FALSE; /* Cached info is not trustworthy */
            } else {
                pinfo->dtag_mode = BCM_PORT_DTAG_MODE_EXTERNAL;
            }
        } else {
            if (use_pbmp && BCM_PBMP_MEMBER(dtm_pbmp, port)) {
                pinfo->dtag_mode = BCM_PORT_DTAG_MODE_INTERNAL;
            } else {
                pinfo->dtag_mode = BCM_PORT_DTAG_MODE_NONE;
            }
        }

        if (!SOC_IS_SHADOW(unit) && !SOC_IS_TOMAHAWK3(unit)) {
            if (soc_feature(unit, soc_feature_vlan_action)) {
                BCM_IF_ERROR_RETURN
                    (_bcm_trx_vlan_port_default_action_get(unit, port, &action));


                if (bcmVlanActionAdd == action.ut_inner) {
                    pinfo->dtag_mode |= BCM_PORT_DTAG_ADD_EXTERNAL_TAG;
                }


                BCM_IF_ERROR_RETURN
                    (_bcm_trx_vlan_port_egress_default_action_get(unit, port,
                                                                  &action));
                if ((bcmVlanActionDelete == action.dt_inner) &&
                    (bcmVlanActionDelete == action.dt_inner_prio)) {
                    pinfo->dtag_mode |= BCM_PORT_DTAG_REMOVE_EXTERNAL_TAG;
                }
            }
        }
    }
    return BCM_E_NONE;
}

/**
 * Function:
 *      _bcm_esw_hcfc_ingress_enable_check();
 * Purpose:
 *      check HCFC ingress enable status of unit. If any port ingress enable, enable =1;
 *
 * Parameters:
 *      unit     - (IN)device number
 *      enable - (OUT) hcfc ingress enable
 *
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
STATIC int
_bcm_esw_hcfc_ingress_enable_check(int unit, int *enable)
{
    soc_reg_t reg0, reg1;
    uint64 rval64, fval64;

    if (SOC_REG_IS_VALID(unit, OOBFC_ING_PORT_EN0_64r)) {
        reg0 = OOBFC_ING_PORT_EN0_64r;
        reg1 = OOBFC_ING_PORT_EN1_64r;
    } else {
        reg0 = OOBFC_ING_PORT_EN_0_64r;
        reg1 = OOBFC_ING_PORT_EN_1_64r;
    }

    if (!(SOC_REG_IS_VALID(unit, reg0) && SOC_REG_IS_VALID(unit, reg1))) {
        *enable = 0;
        return BCM_E_NONE;
    }

    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg0, REG_PORT_ANY, 0, &rval64));
    fval64 = soc_reg64_field_get(unit, reg0, rval64, ING_PORT_ENf);
    if(0 != fval64) {
        *enable = 1;
        return BCM_E_NONE;
    }
    else {
        SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg1, REG_PORT_ANY, 0, &rval64));
        fval64 = soc_reg64_field_get(unit, reg1, rval64, ING_PORT_ENf);
        if(0 != fval64) {
            *enable = 1;
            return BCM_E_NONE;
        }
    }

    return BCM_E_NONE;
}

/**
 * Function:
 *      _bcm_esw_hcfc_egress_enable_check();
 * Purpose:
 *      check HCFC ingress enable status of unit. If any port egress enable, enable =1;
 *
 * Parameters:
 *      unit     - (IN)device number
 *      enable - (OUT) hcfc egress enable
 *
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
STATIC int
_bcm_esw_hcfc_egress_enable_check(int unit, int *enable)
{
    soc_reg_t reg0, reg1;
    uint64 rval64, fval64;

    if (SOC_REG_IS_VALID(unit, OOBFC_ENG_PORT_EN0_64r)) {
        reg0 = OOBFC_ENG_PORT_EN0_64r;
        reg1 = OOBFC_ENG_PORT_EN1_64r;
    } else {
        reg0 = OOBFC_ENG_PORT_EN_0_64r;
        reg1 = OOBFC_ENG_PORT_EN_1_64r;
    }

    if (!(SOC_REG_IS_VALID(unit, reg0) && SOC_REG_IS_VALID(unit, reg1))) {
       *enable = 0;
       return BCM_E_NONE;
    }

    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg0, REG_PORT_ANY, 0, &rval64));
    fval64 = soc_reg64_field_get(unit, reg0, rval64, ENG_PORT_ENf);
    if(0 != fval64) {
        *enable = 1;
        return BCM_E_NONE;
    }
    else {
        SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg1, REG_PORT_ANY, 0, &rval64));
        fval64 = soc_reg64_field_get(unit, reg1, rval64, ENG_PORT_ENf);
        if(0 != fval64) {
            *enable = 1;
            return BCM_E_NONE;
        }
    }

    return BCM_E_NONE;
}

/**
 * Function:
 *      _bcm_esw_port_hcfc_ingress_enable_check();
 * Purpose:
 *     check HCFC ingress enable status of given port.
 *
 * Parameters:
 *      unit     - (IN)device number
 *      port     - (IN)port number
 *      enable - (OUT)hcfc ingress enable
 *
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
STATIC int
_bcm_esw_port_hcfc_ingress_enable_check(int unit, bcm_port_t port, int *enable)
{
    soc_reg_t reg, reg0, reg1;
    int len;
    uint64 rval64, fval64;
    uint32 fval_hi, fval_lo;

    if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }

    if (SOC_REG_IS_VALID(unit, OOBFC_ING_PORT_EN0_64r)) {
        reg0 = OOBFC_ING_PORT_EN0_64r;
        reg1 = OOBFC_ING_PORT_EN1_64r;
    } else {
        reg0 = OOBFC_ING_PORT_EN_0_64r;
        reg1 = OOBFC_ING_PORT_EN_1_64r;
    }
    if (!(SOC_REG_IS_VALID(unit, reg0)) || !(SOC_REG_IS_VALID(unit, reg1))) {
        *enable = 0;
        return BCM_E_NONE;
    }

    /* Configure ingress status reporting */
    len = soc_reg_field_length(unit, reg0, ING_PORT_ENf);
    if (len < 1) {
        return BCM_E_PORT;
    }
    if (port < len) { /* First half of logical ports (not mmu port) */
        reg = reg0;
    } else {          /* Second half of logical ports (not mmu port) */
        reg = reg1;
    }
    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, REG_PORT_ANY, 0, &rval64));
    fval64 = soc_reg64_field_get(unit, reg, rval64, ING_PORT_ENf);
    fval_hi = COMPILER_64_HI(fval64);
    fval_lo = COMPILER_64_LO(fval64);

    if (port < len) {
        if ( port < 32 ) {
            *enable = fval_lo & (1 << port);
        } else {
            /* coverity[large_shift : FALSE] */
            *enable = fval_hi & (1 << (port - 32));
        }
    } else {
        int port_offset = port - len;
        if ( port_offset < 32 ) {
            *enable = fval_lo & (1 << port_offset);
        } else {
            *enable = fval_hi & (1 << (port_offset - 32));
        }
    }

    return BCM_E_NONE;
}

/**
 * Function:
 *      _bcm_esw_port_hcfc_egress_enable_check();
 * Purpose:
 *      check HCFC egress enable status of given port.
 *
 * Parameters:
 *      unit     - (IN)device number
 *      port     - (IN)port number
 *      enable - (OUT)hcfc egress enable
 *
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
STATIC int
_bcm_esw_port_hcfc_egress_enable_check(int unit, bcm_port_t port, int *enable)
{
    soc_reg_t reg, reg0, reg1;
    int len;
    uint64 rval64, fval64;
    uint32 fval_hi, fval_lo;

    if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }

    if (SOC_REG_IS_VALID(unit, OOBFC_ENG_PORT_EN0_64r)) {
        reg0 = OOBFC_ENG_PORT_EN0_64r;
        reg1 = OOBFC_ENG_PORT_EN1_64r;
    } else {
        reg0 = OOBFC_ENG_PORT_EN_0_64r;
        reg1 = OOBFC_ENG_PORT_EN_1_64r;
    }
    if (!(SOC_REG_IS_VALID(unit, reg0)) || !(SOC_REG_IS_VALID(unit, reg1))) {
        *enable = 0;
        return BCM_E_NONE;
    }

    /* Configure egress status reporting */
    len = soc_reg_field_length(unit, reg0, ENG_PORT_ENf);
    if (len < 1) {
        return BCM_E_PORT;
    }
    if (port < len) { /* First half of logical ports (not mmu port) */
        reg = reg0;
    } else {          /* Second half of logical ports (not mmu port) */
        reg = reg1;
    }
    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, REG_PORT_ANY, 0, &rval64));
    fval64 = soc_reg64_field_get(unit, reg, rval64, ENG_PORT_ENf);
    fval_hi = COMPILER_64_HI(fval64);
    fval_lo = COMPILER_64_LO(fval64);
    if (port < len) {
        if ( port < 32 ) {
            *enable = fval_lo & (1 << port);
        } else {
            /* coverity[large_shift : FALSE] */
            *enable = fval_hi & (1 << (port - 32));
        }
    } else {
        int port_offset = port - len;
        if ( port_offset < 32 ) {
            *enable = fval_lo & (1 << port_offset);
        } else {
            *enable = fval_hi & (1 << (port_offset - 32));
        }
    }

    return BCM_E_NONE;
}


STATIC int
_bcm_esw_port_e2ecc_reinit(int unit)
{
    bcm_port_t port, phy_port;
    bcm_port_congestion_config_t *config;
    int    time_unit_sel = 0, time_units = 0;
    soc_higig_e2ecc_hdr_t e2ecc_hdr;
    int    src_modid, src_pid;
    uint64 regval64;
    uint32 regval, field_val = 0;
    int tx_enabled = FALSE, rx_enabled = FALSE;
    int port_tx_enabled, port_rx_enabled, voqfc = 0;
    int hcfc_tx = 0, hcfc_rx = 0;
    int port_hcfc_tx = 0, port_hcfc_rx = 0;
    int blk, blk_num = -1, bindex = 0;
#ifdef  BCM_KATANA2_SUPPORT
    uint16      dev_id;
    uint8       rev_id;
    int e2ecc_coe = 0;
    int e2ecc_strict = 0;
#endif
#ifdef  BCM_TRIDENT2PLUS_SUPPORT
    int fc_format;
    int copy_to_cpu = 0 ;
#endif
    if (SOC_IS_SC_CQ(unit)) {
        SOC_IF_ERROR_RETURN(READ_E2E_HOL_ENr(unit, &regval));
        if (0 != soc_reg_field_get(unit, E2E_HOL_ENr, regval, ENf)) {
            tx_enabled = TRUE;
        }
    } else {
        SOC_IF_ERROR_RETURN(READ_E2ECC_HOL_ENr(unit, &regval));
        if (0 != soc_reg_field_get(unit, E2ECC_HOL_ENr, regval, ENf)) {
            tx_enabled = TRUE;
        }
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_hcfc_egress_enable_check(unit, &hcfc_tx));
    if (hcfc_tx) {
        tx_enabled = TRUE;
    }

    SOC_IF_ERROR_RETURN(READ_ING_CONFIG_64r(unit, &regval64));
    if (0 == soc_reg64_field32_get(unit, ING_CONFIG_64r, regval64,
                              DISABLE_E2E_HOL_CHECKf)) {
        rx_enabled = TRUE;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_hcfc_ingress_enable_check(unit, &hcfc_rx));
    if (hcfc_rx) {
        rx_enabled = TRUE;
    }

    if (!tx_enabled && !rx_enabled) {
        /* Nothing further to do */
        return BCM_E_NONE;
    }

    PBMP_HG_ITER(unit, port) {
        port_tx_enabled = port_rx_enabled = FALSE;

        if (tx_enabled) {
            if (hcfc_tx) {
                port_hcfc_tx = 0;
                BCM_IF_ERROR_RETURN(_bcm_esw_port_hcfc_egress_enable_check(unit, port, &port_hcfc_tx));
                if (port_hcfc_tx) {
                    port_tx_enabled = 1;
                }
            }
            else {
                if (soc_reg_field_valid(unit, XPORT_CONFIGr, E2E_HOL_ENf)) {
                    SOC_IF_ERROR_RETURN(READ_XPORT_CONFIGr(unit, port, &regval));
                    port_tx_enabled =
                        (0 != soc_reg_field_get(unit, XPORT_CONFIGr, regval,
                                                E2E_HOL_ENf));
                } else {
                    if (soc_feature(unit, soc_feature_logical_port_num)) {
                        phy_port = SOC_INFO(unit).port_l2p_mapping[port];
                    } else {
                        phy_port = port;
                    }
                    blk = SOC_PORT_BLOCK(unit, phy_port);
#if defined(BCM_APACHE_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)
                   if (SOC_IS_TRIDENT2X(unit)) {
                       blk_num = SOC_INFO(unit).port_serdes[port];
                   } else
#endif
                   {
                    blk_num = SOC_BLOCK_INFO(unit, blk).number;
                   }
                    bindex = SOC_PORT_BINDEX(unit, phy_port);
                    /* In TR3 E2ECC is implemented only in blocks CL, XL1 */
                    if (!SOC_IS_TRIUMPH3(unit) || (IS_CL_PORT(unit, port) || (blk == 13))) {
                        if (SOC_IS_TRIUMPH3(unit)) {
                            if (IS_CL_PORT(unit, port)) {
                                blk_num = (blk_num ?  4 + bindex/4 : bindex/4);
                                bindex = bindex%4;
                            } else {
                                blk_num = 3;
                            }
                        }
                        if (SOC_IS_KATANA2(unit)) {
                        /* In KT2 E2ECC is implemented only in blocks 6..9 */
                            if (blk_num >= 6) {
                                blk_num -= 6;
                            }
                        }
                        SOC_IF_ERROR_RETURN(READ_E2ECC_TX_ENABLE_BMPr(unit, blk_num,
                                                                      &regval));
                        if ((regval & (1 << bindex))) {
                            port_tx_enabled= TRUE;
                        }
                    }
                }
            }
        }

        if (rx_enabled) {
            if (hcfc_rx) {
                port_hcfc_rx = 0;
                BCM_IF_ERROR_RETURN(_bcm_esw_port_hcfc_ingress_enable_check(unit, port, &port_hcfc_rx));
                if (port_hcfc_rx) {
                    port_rx_enabled = 1;
                }
            }
            else {
                SOC_IF_ERROR_RETURN(READ_IE2E_CONTROLr(unit, port, &regval));
                port_rx_enabled = 0;
                voqfc = 0;
                if (0 != soc_reg_field_get(unit, IE2E_CONTROLr, regval, HOL_ENABLEf)) {
                    port_rx_enabled = 1;
                }

                if (soc_reg_field_valid(unit, IE2E_CONTROLr, VOQFC_ENABLEf)) {
                    if (0 != soc_reg_field_get(unit, IE2E_CONTROLr,
                                               regval, VOQFC_ENABLEf)) {
                        port_rx_enabled = 1;
                        voqfc = 1;
                    }
                }
            }
        }

        /* For HX4 and TR3, tx restore from OP_QUEUE_CONFIG1_CELLr */
        if (SOC_IS_TRIUMPH3(unit)) {
            BCM_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_CELLr(unit, port, 0, &regval));
            port_tx_enabled = soc_reg_field_get(unit,OP_QUEUE_CONFIG1_CELLr, regval, Q_E2E_DS_EN_CELLf);
        }

        if (!port_tx_enabled && !port_rx_enabled) {
            /* On to the next port */
            continue;
        }

        /* Allocate space for the E2ECC configuration */
        if (PORT(unit, port).e2ecc_config == NULL) {
            PORT(unit, port).e2ecc_config =
                sal_alloc(sizeof(bcm_port_congestion_config_t),
                          "bcm_port_congestion_config");
            if (PORT(unit, port).e2ecc_config == NULL) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                          (BSL_META_U(unit,
                                      "Error: unable to allocate memory for"
                                      " bcm_port_congestion_config.\n")));
                return BCM_E_MEMORY;
            }
        } else {
            /* This is initialized to NULL pointers by
             * port init.  How did it get changed? */
            return BCM_E_INTERNAL;
        }

        config = PORT(unit, port).e2ecc_config;
        bcm_port_congestion_config_t_init(config);

        if (port_tx_enabled) {
            if (port_hcfc_tx) {
                config->flags |= BCM_PORT_CONGESTION_CONFIG_HCFC|
                   BCM_PORT_CONGESTION_CONFIG_TX;
            } else {
                /* Recover TX state */
                config->flags |= BCM_PORT_CONGESTION_CONFIG_E2ECC |
                    BCM_PORT_CONGESTION_CONFIG_TX;

                /* Message timer paramters to packets/sec */
                if (SOC_IS_SC_CQ(unit)) {
                    SOC_IF_ERROR_RETURN(READ_E2E_MAX_TX_TIMERr(unit, &regval));
                    time_unit_sel = soc_reg_field_get(unit, E2E_MAX_TX_TIMERr,
                                                      regval, LGf);
                    time_units = soc_reg_field_get(unit, E2E_MAX_TX_TIMERr,
                                                   regval, TIMERf);
                } else {
                    SOC_IF_ERROR_RETURN(READ_E2ECC_MAX_TX_TIMERr(unit, &regval));
                    time_unit_sel = soc_reg_field_get(unit, E2ECC_MAX_TX_TIMERr,
                                                      regval, LGf);
                    time_units = soc_reg_field_get(unit, E2ECC_MAX_TX_TIMERr,
                                                   regval, TIMERf);
                    SOC_IF_ERROR_RETURN(WRITE_E2ECC_MAX_TX_TIMERr(unit, regval));
                }

                /* See _bcm_esw_port_e2ecc_tx for an explanation of
                 * the timer calculation. */
                config->packets_per_sec = time_unit_sel ?
                    (40000 / time_units) : (4000000 / time_units);

                /* Recover the E2ECC module header
                 * (see _bcm_esw_port_e2ecc_tx for the header format) */
                BCM_IF_ERROR_RETURN(_bcm_esw_port_e2ecc_hdr_get(unit, port, &e2ecc_hdr));

                config->traffic_class =
                    (e2ecc_hdr.overlay1.words[0] >> 16) & 0x0F;
                config->multicast_id  = e2ecc_hdr.overlay1.words[0] & 0xFFFF;

                src_modid = (e2ecc_hdr.overlay1.words[1] >> 24) & 0xFF;
                src_pid = (e2ecc_hdr.overlay1.words[1] >> 16) & 0xFF;
                BCM_GPORT_MODPORT_SET(config->src_port, src_modid, src_pid);

                config->color = (e2ecc_hdr.overlay1.words[1] >> 6) & 0x3;

                config->pri = (e2ecc_hdr.overlay1.words[3] >> 29) & 0x7;
                config->cfi = (e2ecc_hdr.overlay1.words[3] >> 28) & 0x1;
                config->vlan = (e2ecc_hdr.overlay1.words[3] >> 16) & 0xfff;

                config->dest_mac[0] =
                    ((e2ecc_hdr.overlay1.words[4] >> 24) & 0xff);
                config->dest_mac[1] =
                    ((e2ecc_hdr.overlay1.words[4] >> 16) & 0xff);
                config->dest_mac[2] =
                    ((e2ecc_hdr.overlay1.words[4] >> 8) & 0xff);
                config->dest_mac[3] =
                    (e2ecc_hdr.overlay1.words[4] & 0xff);
                config->dest_mac[4] =
                    ((e2ecc_hdr.overlay1.words[5] >> 24) & 0xff);
                config->dest_mac[5] =
                    ((e2ecc_hdr.overlay1.words[5] >> 16) & 0xff);

                config->src_mac[0] =
                    ((e2ecc_hdr.overlay1.words[5] >> 8) & 0xff);
                config->src_mac[1] =
                    (e2ecc_hdr.overlay1.words[5] & 0xff);
                config->src_mac[2] =
                    ((e2ecc_hdr.overlay1.words[6] >> 24) & 0xff);
                config->src_mac[3] =
                    ((e2ecc_hdr.overlay1.words[6] >> 16) & 0xff);
                config->src_mac[4] =
                    ((e2ecc_hdr.overlay1.words[6] >> 8) & 0xff);
                config->src_mac[5] =
                    (e2ecc_hdr.overlay1.words[6] & 0xff);

                config->ethertype =
                    (e2ecc_hdr.overlay1.words[7] >> 16) & 0xFFFF;
                config->opcode = e2ecc_hdr.overlay1.words[7] & 0xFFFF;

                /* All the info from RX is encoded in the header, so
                 * just mark if it is enabled. */
                if (port_rx_enabled) {
                    config->flags |= BCM_PORT_CONGESTION_CONFIG_RX;
                }
            }
        } else if (port_rx_enabled) {
            /* Recover RX state */
            config->flags |= BCM_PORT_CONGESTION_CONFIG_RX;

            if (port_hcfc_rx) {
                config->flags |= BCM_PORT_CONGESTION_CONFIG_HCFC;
            } else if (voqfc) {
                config->flags |= BCM_PORT_CONGESTION_CONFIG_DESTMOD_FLOW_CONTROL;
                SOC_IF_ERROR_RETURN(READ_ING_VOQFC_MACDA_MSr(unit, &regval));
                field_val = soc_reg_field_get(unit, ING_VOQFC_MACDA_MSr,
                                              regval, DAf);
                config->dest_mac[0] = ((field_val >> 8) & 0xff);
                config->dest_mac[1] = (field_val & 0xff);

                SOC_IF_ERROR_RETURN(READ_ING_VOQFC_MACDA_LSr(unit, &regval));
                field_val = soc_reg_field_get(unit, ING_VOQFC_MACDA_LSr,
                                              regval, DAf);
                config->dest_mac[2] = ((field_val >> 24) & 0xff);
                config->dest_mac[3] = ((field_val >> 16) & 0xff);
                config->dest_mac[4] = ((field_val >> 8) & 0xff);
                config->dest_mac[5] = (field_val & 0xff);

                SOC_IF_ERROR_RETURN(READ_ING_VOQFC_IDr(unit, &regval));
                config->ethertype =
                    soc_reg_field_get(unit, ING_VOQFC_IDr, regval, LENGTH_TYPEf);
                config->opcode =
                    soc_reg_field_get(unit, ING_VOQFC_IDr, regval, OPCODEf);

            } else {
                config->flags |= BCM_PORT_CONGESTION_CONFIG_E2ECC;
                SOC_IF_ERROR_RETURN(READ_E2E_HOL_RX_DA_MSr(unit, &regval));
                field_val = soc_reg_field_get(unit, E2E_HOL_RX_DA_MSr,
                                              regval, DAf);
                config->dest_mac[0] = ((field_val >> 8) & 0xff);
                config->dest_mac[1] = (field_val & 0xff);

                SOC_IF_ERROR_RETURN(READ_E2E_HOL_RX_DA_LSr(unit, &regval));
                field_val = soc_reg_field_get(unit, E2E_HOL_RX_DA_LSr,
                                              regval, DAf);
                config->dest_mac[2] = ((field_val >> 24) & 0xff);
                config->dest_mac[3] = ((field_val >> 16) & 0xff);
                config->dest_mac[4] = ((field_val >> 8) & 0xff);
                config->dest_mac[5] = (field_val & 0xff);

                SOC_IF_ERROR_RETURN
                    (READ_E2E_HOL_RX_LENGTH_TYPEr(unit, &regval));
                config->ethertype =
                    soc_reg_field_get(unit, E2E_HOL_RX_LENGTH_TYPEr,
                                      regval, LENGTH_TYPEf);

                SOC_IF_ERROR_RETURN
                    (READ_E2E_HOL_RX_OPCODEr(unit, &regval));
                config->opcode =
                    soc_reg_field_get(unit, E2E_HOL_RX_OPCODEr,
                                      regval, OPCODEf);
            }
        }
    }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit) ||
        (SOC_IS_APACHE(unit) && !SOC_IS_MONTEREY(unit))) {
        PBMP_ALL_ITER(unit, port) {

            if (IS_HG_PORT(unit, port)) {
                continue;
            }
            SOC_IF_ERROR_RETURN(
               READ_COE_FLOW_CONTROL_CONFIGr (unit, port, &regval));

           fc_format = soc_reg_field_get(unit, COE_FLOW_CONTROL_CONFIGr,
                                regval, FLOW_CONTROL_FORMATf);
           copy_to_cpu = soc_reg_field_get(unit, COE_FLOW_CONTROL_CONFIGr,
                                regval, COPY_TO_CPUf);
           if(!fc_format)
           {
              continue;
           }

            /* Allocate space for the E2ECC configuration */
            if (PORT(unit, port).e2ecc_config == NULL) {
                PORT(unit, port).e2ecc_config =
                    sal_alloc(sizeof(bcm_port_congestion_config_t),
                              "bcm_port_congestion_config");
                if (PORT(unit, port).e2ecc_config == NULL) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                                 "Error: unable to allocate memory for"
                                 " bcm_port_congestion_config.\n")));
                    return BCM_E_MEMORY;
                }
            } else {
                /* This is initialized to NULL pointers by
                 * port init.  How did it get changed? */
                return BCM_E_INTERNAL;
            }

            config = PORT(unit, port).e2ecc_config;
            bcm_port_congestion_config_t_init(config);

            /* Recover RX state */
            config->flags |= BCM_PORT_CONGESTION_CONFIG_RX;
            if (copy_to_cpu == 1) {
                config->flags |=
                BCM_PORT_CONGESTION_CONFIG_COPY_TO_CPU;
            }
            if (fc_format == 1) {
                config->flags |=
                BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_STRICT_MODE;
                SOC_IF_ERROR_RETURN(
                        READ_ING_VOQFC_MACDA_MSr(unit, &regval));
                field_val = soc_reg_field_get(unit, ING_VOQFC_MACDA_MSr,
                                            regval, DAf);
                config->dest_mac[0] = ((field_val >> 8) & 0xff);
                config->dest_mac[1] = (field_val & 0xff);
                SOC_IF_ERROR_RETURN(
                         READ_ING_VOQFC_MACDA_LSr(unit, &regval));
                field_val = soc_reg_field_get(unit, ING_VOQFC_MACDA_LSr,
                                              regval, DAf);
                config->dest_mac[2] = ((field_val >> 24) & 0xff);
                config->dest_mac[3] = ((field_val >> 16) & 0xff);
                config->dest_mac[4] = ((field_val >> 8) & 0xff);
                config->dest_mac[5] = (field_val & 0xff);
                SOC_IF_ERROR_RETURN(READ_ING_VOQFC_IDr(unit, &regval));
                config->ethertype =
                  soc_reg_field_get(unit, ING_VOQFC_IDr,
                                             regval, LENGTH_TYPEf);
                config->opcode =
                   soc_reg_field_get(unit, ING_VOQFC_IDr,
                                         regval, OPCODEf);

            } else if (fc_format == 2) {
                config->flags |=
                BCM_PORT_CONGESTION_CONFIG_VLAN_PAUSE_COE;
                SOC_IF_ERROR_RETURN(
                        READ_COE_VLAN_PAUSE_MACDA_MSr(unit, &regval));
                field_val = soc_reg_field_get(unit, COE_VLAN_PAUSE_MACDA_MSr,
                                            regval, DAf);
                config->dest_mac[0] = ((field_val >> 8) & 0xff);
                config->dest_mac[1] = (field_val & 0xff);
                SOC_IF_ERROR_RETURN(
                        READ_COE_VLAN_PAUSE_MACDA_LSr(unit, &regval));
                field_val = soc_reg_field_get(unit, COE_VLAN_PAUSE_MACDA_LSr,
                                            regval, DAf);
                config->dest_mac[2] = ((field_val >> 24) & 0xff);
                config->dest_mac[3] = ((field_val >> 16) & 0xff);
                config->dest_mac[4] = ((field_val >> 8) & 0xff);
                config->dest_mac[5] = (field_val & 0xff);
                SOC_IF_ERROR_RETURN(READ_COE_VLAN_PAUSE_IDr(unit, &regval));
                config->ethertype =
                  soc_reg_field_get(unit, COE_VLAN_PAUSE_IDr,
                                             regval, LENGTH_TYPEf);
                config->opcode =
                   soc_reg_field_get(unit, COE_VLAN_PAUSE_IDr,
                                         regval, OPCODEf);
            }

        }
     }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
#ifdef     BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        PBMP_ALL_ITER(unit, port) {
            port_rx_enabled = 0;
            e2ecc_coe = 0;

            if (IS_HG_PORT(unit, port)) {
                continue;
            }
            soc_cm_get_id(unit, &dev_id, &rev_id);

            if ((rev_id >= BCM56450_B0_REV_ID) || SOC_IS_SABER2(unit)) {
                SOC_IF_ERROR_RETURN(
                  READ_COE_FLOW_CONTROL_CONFIGr (unit, port, &regval));

                if (soc_reg_field_valid(unit, COE_FLOW_CONTROL_CONFIGr,
                         FLOW_CONTROL_FORMATf)) {
                    if (0 != soc_reg_field_get(unit, COE_FLOW_CONTROL_CONFIGr,
                                regval, FLOW_CONTROL_FORMATf)) {
                        port_rx_enabled = 1;
                        e2ecc_coe = 1;
                        e2ecc_strict = soc_reg_field_get(unit,
                                         COE_FLOW_CONTROL_CONFIGr,
                                         regval, E2ECC_MODEf);
                     }
                }
            } else if (rev_id == BCM56450_A0_REV_ID) {
                SOC_IF_ERROR_RETURN(READ_IE2E_CONTROLr(unit, port, &regval));
                if (soc_reg_field_valid(unit, IE2E_CONTROLr, VOQFC_ENABLEf)) {
                    if (0 != soc_reg_field_get(unit, IE2E_CONTROLr,
                                               regval, VOQFC_ENABLEf)) {
                        port_rx_enabled = 1;
                        e2ecc_coe = 1;
                    }
                }
            }
            if (!port_rx_enabled) {
                /* On to the next port */
                continue;
            }

            /* Allocate space for the E2ECC configuration */
            if (PORT(unit, port).e2ecc_config == NULL) {
                PORT(unit, port).e2ecc_config =

                    sal_alloc(sizeof(bcm_port_congestion_config_t),
                              "bcm_port_congestion_config");
                if (PORT(unit, port).e2ecc_config == NULL) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                                 "Error: unable to allocate memory for"
                                 " bcm_port_congestion_config.\n")));
                    return BCM_E_MEMORY;
                }
            } else {
                /* This is initialized to NULL pointers by
                 * port init.  How did it get changed? */
                return BCM_E_INTERNAL;
            }

            config = PORT(unit, port).e2ecc_config;
            bcm_port_congestion_config_t_init(config);

            if (port_rx_enabled) {
                /* Recover RX state */
                config->flags |= BCM_PORT_CONGESTION_CONFIG_RX;
                if (e2ecc_coe) {
                    if ((rev_id >= BCM56450_B0_REV_ID) || SOC_IS_SABER2(unit)) {
                        if (e2ecc_strict) {
                            config->flags |=
                              BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_STRICT_MODE;
                        } else {
                            config->flags |=
                              BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_FLEX_MODE;
                        }
                    } else if (rev_id == BCM56450_A0_REV_ID) {
                        config->flags |=
                             BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_FLEX_MODE;
                    }
                    SOC_IF_ERROR_RETURN(
                               READ_ING_VOQFC_MACDA_MSr(unit, &regval));
                    field_val = soc_reg_field_get(unit, ING_VOQFC_MACDA_MSr,
                                                  regval, DAf);
                    config->dest_mac[0] = ((field_val >> 8) & 0xff);
                    config->dest_mac[1] = (field_val & 0xff);

                    SOC_IF_ERROR_RETURN(
                               READ_ING_VOQFC_MACDA_LSr(unit, &regval));
                    field_val = soc_reg_field_get(unit, ING_VOQFC_MACDA_LSr,
                                                  regval, DAf);
                    config->dest_mac[2] = ((field_val >> 24) & 0xff);
                    config->dest_mac[3] = ((field_val >> 16) & 0xff);
                    config->dest_mac[4] = ((field_val >> 8) & 0xff);
                    config->dest_mac[5] = (field_val & 0xff);

                    SOC_IF_ERROR_RETURN(READ_ING_VOQFC_IDr(unit, &regval));
                    config->ethertype =
                        soc_reg_field_get(unit, ING_VOQFC_IDr,
                                               regval, LENGTH_TYPEf);
                    config->opcode =
                        soc_reg_field_get(unit, ING_VOQFC_IDr,
                                               regval, OPCODEf);
                }
            }
        }
    }
#endif /* BCM_KATANA2_SUPPORT */

    return BCM_E_NONE;
}
#endif /* BCM_TRX_SUPPORT */

STATIC void
_scache_port_print_ll_init(int unit)
{
    int i;

    for (i = 0; i < SCACHE_PORT_TYPE_MAX; i++) {
        scache_head[i] = NULL;
        scache_tail[i] = NULL;
    }
}

STATIC void
_scache_port_print_clear_ll(int unit, scache_port_type_t type)
{
    scache_port_print_port_t *entry;

    if (bsl_check(bslLayerShared, bslSourceScache,
                bslSeverityVerbose, unit)) {
        assert(type < SCACHE_PORT_TYPE_MAX);

        /* delete from the head */
        while (scache_head[type] != NULL) {
            entry = scache_head[type];
            scache_head[type] = scache_head[type]->next;
            sal_free(entry);
        }
        /* now that the list is empty and head is NULL, make tail pointer NULL */
        scache_tail[type] = NULL;
    }
}

STATIC void
_scache_port_print_clear_all(int unit)
{
    int i;

    for (i = 0; i < SCACHE_PORT_TYPE_MAX; i++) {
        _scache_port_print_clear_ll(unit, i);
    }
}

STATIC void
_scache_port_print_add_ll(int unit, scache_port_type_t type,
                                scache_port_print_port_t * entry)
{
    if (NULL == entry) {
        return;
    }

    /* Head of linked list is NULL */
    if (scache_head[type] == NULL) {
        scache_head[type] = entry;
        scache_tail[type] = entry;
    } else {
        /* put the entry at the end */

        /* Update the current tail's next */
        scache_tail[type]->next = entry;

        /* Store the entry at the end */
        scache_tail[type] = entry;
    }
}

STATIC int
_scache_port_print_add(int unit, int port, scache_port_type_t type, int len,
                        uint8 *val)
{
    scache_port_print_port_t *new_entry;

    if (bsl_check(bslLayerShared, bslSourceScache,
                bslSeverityVerbose, unit)) {
        assert(type < SCACHE_PORT_TYPE_MAX);

        new_entry = (scache_port_print_port_t *)
            sal_alloc(sizeof(scache_port_print_port_t), "scache_port");
        if (NULL == new_entry) {
            return BCM_E_MEMORY;
        }

        new_entry->next = NULL;
        new_entry->val = val;
        new_entry->len = len;
        new_entry->port = port;

        _scache_port_print_add_ll(unit, type, new_entry);
    }

    return BCM_E_NONE;
}

STATIC void
_scache_port_print(int unit, scache_port_type_t type)
{
    uint8 *scache_runner;
    scache_port_print_port_t *runner;

    if (bsl_check(bslLayerShared, bslSourceScache,
                bslSeverityVerbose, unit)) {
        assert(type < SCACHE_PORT_TYPE_MAX);

        runner = scache_head[type];

        /* No scache entries in this type */
        if (runner == NULL) {
            return;
        }

        /* If port == -1, not a port based entry */
        if (runner->port == -1) {
            LOG_VERBOSE(BSL_LS_SHARED_SCACHE,
                (BSL_META_U(unit,
                            "\nS$BEGIN:<port>:<%s>"),
                            port_scache_strs[type]));

            while(NULL != runner) {
                if (runner->len == sizeof(uint8)) {
                    LOG_VERBOSE(BSL_LS_SHARED_SCACHE,
                            (BSL_META_U(unit,
                                        "\n{0x%02x}"),
                             *(int *)(runner->val) & 0xff));
                } else if (runner->len == sizeof(uint16) ||
                        runner->len == sizeof(uint32)) {
                    LOG_VERBOSE(BSL_LS_SHARED_SCACHE,
                            (BSL_META_U(unit,
                                        "\n{%d}"),
                             *(int *)(runner->val)));
                } else {
                    /* larger than 32 bits */
                    scache_runner = runner->val;
                    LOG_VERBOSE(BSL_LS_SHARED_SCACHE,
                            (BSL_META_U(unit,
                                        "\n{")));
                    while (scache_runner < runner->val + runner->len) {
                        LOG_VERBOSE(BSL_LS_SHARED_SCACHE,
                                (BSL_META_U(unit,
                                            "%d%s"), *(int *)(runner->val),
                                 ((scache_runner+sizeof(int)) <
                                  (runner->val + runner->len))?" ":""));
                        scache_runner += sizeof(int);
                    }
                    LOG_VERBOSE(BSL_LS_SHARED_SCACHE,
                            (BSL_META_U(unit,
                                        "}")));
                }

                /* Go to the next entry */
                runner = runner->next;
            }
        } else {
            LOG_VERBOSE(BSL_LS_SHARED_SCACHE,
                (BSL_META_U(unit,
                            "\nS$BEGIN:<port>:<port;%s>"),
                            port_scache_strs[type]));

            while(NULL != runner) {
                if (runner->len == sizeof(uint8)) {
                    LOG_VERBOSE(BSL_LS_SHARED_SCACHE,
                            (BSL_META_U(unit,
                                        "\n{%d;0x%02x}"), runner->port,
                             *(int *)(runner->val) & 0xff));
                } else if (runner->len == sizeof(uint16) ||
                        runner->len == sizeof(uint32)) {
                    LOG_VERBOSE(BSL_LS_SHARED_SCACHE,
                            (BSL_META_U(unit,
                                        "\n{%d;%d}"), runner->port,
                             *(int *)(runner->val)));
                } else {
                    /* larger than 32 bits */
                    scache_runner = runner->val;
                    LOG_VERBOSE(BSL_LS_SHARED_SCACHE,
                            (BSL_META_U(unit,
                                        "\n{%d;"), runner->port));
                    while (scache_runner < runner->val + runner->len) {
                        LOG_VERBOSE(BSL_LS_SHARED_SCACHE,
                                (BSL_META_U(unit,
                                            "%d%s"), *(int *)(runner->val),
                                 ((scache_runner+sizeof(int)) <
                                  (runner->val + runner->len))?" ":""));
                        scache_runner += sizeof(int);
                    }
                    LOG_VERBOSE(BSL_LS_SHARED_SCACHE,
                            (BSL_META_U(unit,
                                        "}")));
                }

                /* Go to the next entry */
                runner = runner->next;
            }
        }


        LOG_VERBOSE(BSL_LS_SHARED_SCACHE,
                (BSL_META_U(unit,
                            "\nS$END:port\n")));
    }
}

STATIC void
_scache_port_print_all(int unit)
{
    int i;

    for (i = 0; i < SCACHE_PORT_TYPE_MAX; i++) {
        _scache_port_print(unit, i);
    }
}

STATIC int
_bcm_esw_port_sync_scache(int unit, uint8 *port_state, int stable_size,
                            uint32 asf_wbmem_sz, uint32 latency_wbmem_sz,
                            bcm_pbmp_t *all_pbmp)
{
    bcm_port_t port;
    bcm_pbmp_t dtm_pbmp;
    _bcm_port_info_t *pinfo = NULL;
    int rv = BCM_E_NONE;
#ifdef BCM_TRIDENT_SUPPORT
        soc_info_t *si = &SOC_INFO(unit);
#endif

    BCM_PBMP_CLEAR(dtm_pbmp);

    PBMP_ITER(*all_pbmp, port) {
        if (port < SOC_MAX_NUM_PORTS) {
            BCM_IF_ERROR_RETURN(_bcm_port_info_get(unit, port, &pinfo));
        }
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
        if ((SOC_IS_KATANA2(unit) || SOC_IS_TOMAHAWK2(unit) || SOC_IS_TRIDENT3X(unit))) {
            int idxmin, idxmax, idx;
            idxmin = soc_mem_index_min(unit, VLAN_PROTOCOLm);
            idxmax = soc_mem_index_max(unit, VLAN_PROTOCOLm);

            for (idx = idxmin; idx <= idxmax; idx++) {
                if (_BCM_PORT_VD_PBVL_IS_SET(pinfo, idx)) {
                    sal_memcpy(port_state, &idx, sizeof(int));
                    port_state += sizeof(int);

                    BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port,
                                SPT_PBVL, sizeof(int), port_state - sizeof(int)));
                    break;
                }
            }
            if (idx > idxmax) {
                idx = -1;
                sal_memcpy(port_state, &idx, sizeof(int));
                port_state += sizeof(int);

                BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port, SPT_PBVL,
                            sizeof(int), port_state - sizeof(int)));
            }

            sal_memcpy(port_state, &(pinfo->vlan_prot_ptr),
                    sizeof(uint32));
            port_state += sizeof(uint32);

            BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port,
                        SPT_VLAN_PROT_PTR, sizeof(uint32),
                        port_state - sizeof(uint32)));
        }
#endif
        /* In Apache information is saved and recovered for 76 ports which is
         * greater than SOC_MAX_NUM_PORTS value of 75. These checks are
         * needed to prevent invalid memory access.
         */
        if (port < SOC_MAX_NUM_PORTS) {
            if (0 != (pinfo->dtag_mode &
                        (BCM_PORT_DTAG_MODE_INTERNAL | BCM_PORT_DTAG_MODE_EXTERNAL))) {
                /* Some sort of double-tagged mode */
                BCM_PBMP_PORT_ADD(dtm_pbmp, port);
            }
            sal_memcpy(port_state, &(pinfo->vp_count), sizeof(pinfo->vp_count));
        }
        port_state += sizeof(int);

        BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port, SPT_VP_COUNT,
                            sizeof(int), port_state - sizeof(int)));
    }
    sal_memcpy(port_state, &dtm_pbmp, sizeof(dtm_pbmp));
    port_state += sizeof(dtm_pbmp);
    BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, -1, SPT_DTM_PBMP,
                sizeof(dtm_pbmp), port_state - sizeof(dtm_pbmp)));

    PBMP_ITER(*all_pbmp, port) {
        if (!SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit) && (stable_size > 0)) {
            if (SOC_REG_IS_VALID(unit, COSMASKr)) {
                if (port < SOC_MAX_NUM_PORTS) {
                    sal_memcpy(port_state, &(PORT(unit, port).cosmask), sizeof(uint32));
                }
                port_state += sizeof(uint32);

                BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port,
                            SPT_COSMASK, sizeof(uint32), port_state - sizeof(uint32)));
            } else {
                if (port < SOC_MAX_NUM_PORTS) {
                    sal_memcpy(port_state, &(PORT(unit, port).m_info),
                            sizeof(_bcm_port_metering_info_t));
                }
                port_state += sizeof(_bcm_port_metering_info_t);

                BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port, SPT_METERING_INFO,
                        sizeof(_bcm_port_metering_info_t),
                        port_state - sizeof(_bcm_port_metering_info_t)));
            }
            if (port < SOC_MAX_NUM_PORTS) {
                sal_memcpy(port_state, &(PORT(unit, port).flags), sizeof(uint8));
            }
            port_state += sizeof(uint8);

            BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port,
                        SPT_PORT_FLAGS, sizeof(uint8),
                        port_state - sizeof(uint8)));
        }

    }
#ifdef BCM_TRIDENT_SUPPORT
    if ((SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit)) &&
            soc_feature(unit, soc_feature_flex_port)) {
        /* coverity[overrun-local] */
        PBMP_ALL_ITER(unit, port) {
            if (port < SOC_MAX_NUM_PORTS) {
                sal_memcpy(port_state, &(si->port_num_lanes[port]), sizeof(int));
            }
            port_state += sizeof(int);

            BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port,
                        SPT_PORT_NUM_LANES, sizeof(int),
                        port_state - sizeof(int)));
        }
    }
#endif

    /* Restore SW RX LOS status */
    PBMP_ITER(*all_pbmp, port) {
        if (port < SOC_MAX_NUM_PORTS) {
            sal_memcpy(port_state, &(PORT(unit, port).rx_los), sizeof(uint8));
        }
        port_state += sizeof(uint8);

        BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port, SPT_RX_LOS,
                    sizeof(uint8), port_state - sizeof(uint8)));
    }


#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_FIRELIGHT_SUPPORT)
    if (SOC_IS_TD2_TT2(unit) || SOC_IS_FIRELIGHT(unit)) {
        /* Restore port enable status */
        PBMP_ITER(*all_pbmp, port) {
            if (port < SOC_MAX_NUM_PORTS) {
                sal_memcpy(port_state, &(PORT(unit, port).enable), sizeof(int));
            }
            port_state += sizeof(int);

            BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port,
                        SPT_PORT_ENABLE, sizeof(int), port_state - sizeof(int)));
        }
    }
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit) && !SOC_IS_HELIX4(unit)) {
        if (_port_ibod_ctrl[unit]) {
            sal_memcpy(port_state, _port_ibod_ctrl[unit]->rrbyt,
                    sizeof(((_port_ibod_ctrl_t *)0)->rrbyt));
            port_state += sizeof(((_port_ibod_ctrl_t *)0)->rrbyt);
            sal_memcpy(port_state, _port_ibod_ctrl[unit]->rrpkt,
                    sizeof(((_port_ibod_ctrl_t *)0)->rrpkt));
            port_state += sizeof(((_port_ibod_ctrl_t *)0)->rrpkt);
            sal_memcpy(port_state, &(_port_ibod_ctrl[unit]->event_count),
                    sizeof(((_port_ibod_ctrl_t *)0)->event_count));
            port_state += sizeof(((_port_ibod_ctrl_t *)0)->event_count);
        }  else {
            sal_memset(port_state, 0,
                    2 * sizeof(((_port_ibod_ctrl_t *)0)->rrbyt)
                    + sizeof((((_port_ibod_ctrl_t *)0)->event_count)));
            port_state += 2 * sizeof(((_port_ibod_ctrl_t *)0)->rrbyt)
                + sizeof((((_port_ibod_ctrl_t *)0)->event_count));
        }

    }
    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
        BCM_IF_ERROR_RETURN(_bcm_port_force_forward_sync(unit, &port_state));
    }
#endif /* BCM_TRIUMPH3_SUPPORT */

#ifdef  BCM_TOMAHAWK_SUPPORT
    /* ASF WB */
    BCM_IF_ERROR_RETURN(_bcm_esw_asf_wb_sync(unit, port_state));
    port_state += asf_wbmem_sz;

    BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, -1, SPT_ASF, asf_wbmem_sz,
                        port_state - asf_wbmem_sz));

    /* Switch Latency Bypass WB */
    BCM_IF_ERROR_RETURN(bcmi_esw_switch_latency_wb_sync(unit, port_state));
    port_state += latency_wbmem_sz;

    BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, -1, SPT_LATENCY,
                latency_wbmem_sz, port_state - latency_wbmem_sz));

#endif /* BCM_TOMAHAWK_SUPPORT */

    /*IFG WB*/
    if (soc_feature(unit, soc_feature_xmac) ||
            soc_feature(unit, soc_feature_xlmac) ||
            soc_feature(unit, soc_feature_cmac) ||
            soc_feature(unit, soc_feature_clmac)) {

        BCM_IF_ERROR_RETURN(_bcm_esw_port_ifg_wb_sync(unit, &port_state));
    }
    /* PORT DSCP MAP SETTING */
    if (soc_feature(unit, soc_feature_dscp) &&
            soc_feature(unit, soc_feature_egr_dscp_map_per_port)) {
        /* Allocate size for port dscp map setting status */
        PBMP_ITER(*all_pbmp, port) {
            sal_memcpy(port_state, &(PORT(unit, port).port_dscp_map_set), sizeof(int));
            port_state += sizeof(int);

            BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port, SPT_DSCP_MAP,
                        sizeof(int), port_state - sizeof(int)));
        }
    }

#if defined(BCM_CLMAC_SUPPORT)
    if (SOC_IS_TOMAHAWK(unit)) {
        soc_port_if_t       pif;
        /* Restore port interface type */
        PBMP_ITER(*all_pbmp, port) {
            if (IS_XE_PORT(unit, port) ||
                    IS_CE_PORT(unit, port) ||
                    IS_HG_PORT(unit, port) ||
                    IS_GE_PORT(unit, port) ||
                    IS_MANAGEMENT_PORT(unit, port)) {
                BCM_IF_ERROR_RETURN(soc_phyctrl_interface_get(unit, port, &pif));
                sal_memcpy(port_state, &pif, sizeof(int));
                port_state += sizeof(int);

                BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port,
                            SPT_PORT_INTF_TYPE, sizeof(int),
                            port_state - sizeof(int)));
            }
        }
    }
#endif

    if (soc_feature(unit, soc_feature_phy_interface_wb)) {
        soc_port_if_t       pif;

        /* Restore port interface type */
        PBMP_ITER(PBMP_PORT_ALL(unit), port) {
            rv = soc_phyctrl_interface_get(unit, port, &pif);
            if (BCM_FAILURE(rv)) {
                pif = 0;
            }
            sal_memcpy(port_state, &pif, sizeof(int));
            port_state += sizeof(int);

            BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port,
                        SPT_PORT_INTF_TYPE,
                        sizeof(int), port_state - sizeof(int)));
        }
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *      _bcm_esw_port_sync
 * Purpose:
 *      Record Port module persisitent info for Level 2 Warm Boot
 *
 * Warm Boot Version Map:
 *      Fields for previous version to be documented
 *  BCM_PORT_WB_VERSION_1_0
 *      ...
 *  BCM_PORT_WB_VERSION_1_1
 *      ...
 *  BCM_PORT_WB_VERSION_1_2
 *    rx_los            SW RX LOS
 *      ...
 *  BCM_PORT_WB_VERSION_1_3
 *    enable            port eanble status
 *
 * Parameters:
 *      unit - StrataSwitch unit number.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_esw_port_sync(int unit)
{
    int rv = BCM_E_NONE;

#if defined(BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit)) {
        int alloc_sz;
        bcm_port_t port;
        uint8 *port_state;
        bcm_pbmp_t dtm_pbmp;
        int stable_size;
        soc_scache_handle_t scache_handle;
        bcm_pbmp_t all_pbmp;
        uint32 asf_wbmem_sz = 0;
        /* Switch Latency Bypass WB will move to a different module later */
        uint32 latency_wbmem_sz = 0;

        BCM_PBMP_CLEAR(all_pbmp);
        BCM_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

#ifdef BCM_KATANA2_SUPPORT
        if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
            BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
        }
        if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
        }
#endif

#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            BCM_IF_ERROR_RETURN(bcm_td2p_flexport_pbmp_update(unit,
                                                 &all_pbmp));
        }
#endif
#ifdef BCM_MONTEREY_SUPPORT
            if (SOC_IS_MONTEREY(unit)) {
                BCM_IF_ERROR_RETURN(bcm_monterey_flexport_pbmp_update(unit, &all_pbmp));
            }
#endif
#ifdef BCM_APACHE_SUPPORT
        if (SOC_IS_APACHE(unit) && !SOC_IS_MONTEREY(unit)) {
            BCM_IF_ERROR_RETURN(bcm_apache_flexport_pbmp_update(unit, &all_pbmp));
        }
#endif

        alloc_sz = 0;
        SOC_IF_ERROR_RETURN(soc_stable_size_get(unit, &stable_size));
        PBMP_ITER(all_pbmp, port) {
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
            if ((SOC_IS_KATANA2(unit) || SOC_IS_TOMAHAWK2(unit) || SOC_IS_TRIDENT3X(unit))) {
                /* vp entry and vlan prot ptr */
                alloc_sz += (sizeof(int) + sizeof(uint32));
            }
#endif
            alloc_sz += sizeof(int); /* vp count */
        }
        alloc_sz += sizeof(dtm_pbmp); /* Bitmap of dtag_mode set */

        PBMP_ITER(all_pbmp, port) {
            if (!SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit) && (stable_size > 0)) {
                if (SOC_REG_IS_VALID(unit, COSMASKr)) {
                    alloc_sz += sizeof(uint32);
                } else {
                    alloc_sz += sizeof(_bcm_port_metering_info_t);
                }
                alloc_sz += sizeof(uint8); /* flags */
            }
        }

#ifdef BCM_TRIDENT_SUPPORT
        if ((SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit)) &&
            soc_feature(unit, soc_feature_flex_port)) {
            /* Number of lanes per port needs to be stored.*/
            alloc_sz += (SOC_MAX_NUM_PORTS * sizeof(int));
        }
#endif

        /* Size for SW RX LOS status */
        PBMP_ITER(all_pbmp, port) {
            alloc_sz += sizeof(uint8);
        }

#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_FIRELIGHT_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) || SOC_IS_FIRELIGHT(unit)) {
            /* Size for port enable status */
            PBMP_ITER(all_pbmp, port) {
                alloc_sz += sizeof(int);
            }
        }
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIUMPH3_SUPPORT
        if (SOC_IS_TRIUMPH3(unit) && !SOC_IS_HELIX4(unit)) {
            alloc_sz += 2 * sizeof(((_port_ibod_ctrl_t *)0)->rrbyt)
                        + sizeof((((_port_ibod_ctrl_t *)0)->event_count));
        }
#endif /* BCM_TRIUMPH3_SUPPORT */
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
            int port_forward_size;
            BCM_IF_ERROR_RETURN(
                _bcm_port_force_forward_scache_size(unit,
                                                    &port_forward_size));
            alloc_sz += port_forward_size;
        }
#endif

#ifdef  BCM_TOMAHAWK_SUPPORT
        /* ASF WB */
        rv = _bcm_esw_asf_wb_memsz_get(unit, &asf_wbmem_sz,
                                       BCM_PORT_WB_DEFAULT_VERSION);
        if (BCM_E_NONE == rv) {
            alloc_sz += asf_wbmem_sz;
        }

        /* Switch Latency Bypass WB */
        rv = bcmi_esw_switch_latency_wb_memsz_get(unit, &latency_wbmem_sz,
                                                  BCM_PORT_WB_DEFAULT_VERSION);
        if (BCM_E_NONE == rv) {
            alloc_sz += latency_wbmem_sz;
        }
#endif /* BCM_TOMAHAWK_SUPPORT */

        /*IFG WB*/
        if (soc_feature(unit, soc_feature_xmac) ||
                soc_feature(unit, soc_feature_xlmac) ||
                soc_feature(unit, soc_feature_cmac) ||
                soc_feature(unit, soc_feature_clmac)) {
            PBMP_ITER(all_pbmp, port) {
                alloc_sz += sizeof(uint32);
            }
        }
        /* PORT DSCP MAP SETTING */
        if (soc_feature(unit, soc_feature_dscp) &&
            soc_feature(unit, soc_feature_egr_dscp_map_per_port)) {
            /* Allocate size for port dscp map setting status */
            PBMP_ITER(all_pbmp, port) {
                alloc_sz += sizeof(int);
            }
        }

#ifdef  BCM_TOMAHAWK_SUPPORT
        if (SOC_IS_TOMAHAWK(unit)) {
            /* Allocate size for port interface type */
            PBMP_ITER(all_pbmp, port) {
                alloc_sz += sizeof(int);
            }
        }
#endif /* BCM_TOMAHAWK_SUPPORT */

       if (soc_feature(unit, soc_feature_phy_interface_wb)) {
            /* Allocate size for port interface type */
            PBMP_ITER(PBMP_PORT_ALL(unit), port) {
                alloc_sz += sizeof(int);
            }
       }

        SOC_SCACHE_HANDLE_SET(scache_handle,
                              unit, BCM_MODULE_PORT,
                              BCM_PORT_WB_SCACHE_PART_DEFAULT);
        rv = _bcm_esw_scache_ptr_get(unit, scache_handle, FALSE,
                                     alloc_sz, (uint8**)&port_state,
                                     BCM_PORT_WB_DEFAULT_VERSION, NULL);
        if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
            return rv;
        }

        _scache_port_print_ll_init(unit);

        PORT_LOCK(unit);

        rv = _bcm_esw_port_sync_scache(unit, port_state, stable_size, asf_wbmem_sz, latency_wbmem_sz,
                            &all_pbmp);

        PORT_UNLOCK(unit);

        if (BCM_SUCCESS(rv)) {
            _scache_port_print_all(unit);
        }
        _scache_port_print_clear_all(unit);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
    }
#endif /* BCM_TRX_SUPPORT */

#ifdef BCM_PREEMPTION_SUPPORT
    if (BCM_SUCCESS(rv) && soc_feature(unit, soc_feature_preemption)) {
        soc_scache_handle_t scache_handle;

        SOC_SCACHE_HANDLE_SET(scache_handle,
                              unit, BCM_MODULE_PORT,
                              BCM_PORT_WB_SCACHE_PART_PREMMPTION);

        rv = bcmi_esw_preemption_sync(unit, scache_handle);
    }
#endif /* BCM_PREEMPTION_SUPPORT */
    return rv;
}

int
_bcm_esw_port_wb_alloc(int unit)
{

#if defined(BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit)) {
        int alloc_sz, rv = BCM_E_NONE;
        bcm_port_t port;
        uint8 *port_state;
        int stable_size;
        bcm_pbmp_t all_pbmp;
        soc_scache_handle_t scache_handle;
#ifdef  BCM_TOMAHAWK_SUPPORT
        uint32 asf_wbmem_sz = 0;

        /* Switch Latency Bypass WB will move to a different module later */
        uint32 latency_wbmem_sz = 0;
#endif /* BCM_TOMAHAWK_SUPPORT */

        BCM_PBMP_CLEAR(all_pbmp);
        BCM_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

#ifdef BCM_KATANA2_SUPPORT
        if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
            BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
        }
        if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
        }
#endif

#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            BCM_IF_ERROR_RETURN(bcm_td2p_flexport_pbmp_update(unit,
                                                 &all_pbmp));
        }
#endif
#ifdef BCM_MONTEREY_SUPPORT
            if (SOC_IS_MONTEREY(unit)) {
                BCM_IF_ERROR_RETURN(bcm_monterey_flexport_pbmp_update(unit, &all_pbmp));
            }
#endif
#ifdef BCM_APACHE_SUPPORT
        if (SOC_IS_APACHE(unit) && !SOC_IS_MONTEREY(unit)) {
            BCM_IF_ERROR_RETURN(bcm_apache_flexport_pbmp_update(unit, &all_pbmp));
        }
#endif
        alloc_sz = 0;
        SOC_IF_ERROR_RETURN(soc_stable_size_get(unit, &stable_size));
        PBMP_ITER(all_pbmp, port) {
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
            if ((SOC_IS_KATANA2(unit) || SOC_IS_TOMAHAWK2(unit) || SOC_IS_TRIDENT3X(unit))) {
                /* vp entry and vlan prot ptr */
                alloc_sz += (sizeof(int) + sizeof(uint32));
            }
#endif
            alloc_sz += sizeof(int); /* vp count */
        }
        alloc_sz += sizeof(bcm_pbmp_t); /* Bitmap of dtag_mode == NONE */
        PBMP_ITER(all_pbmp, port) {
            if (!SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit) && (stable_size > 0)) {
                if (SOC_REG_IS_VALID(unit, COSMASKr)) {
                    alloc_sz += sizeof(uint32);
                } else {
                    alloc_sz += sizeof(_bcm_port_metering_info_t);
                }
                alloc_sz += sizeof(uint8); /* flags */
            }
        }

#ifdef BCM_TRIDENT_SUPPORT
        if ((SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit)) &&
            soc_feature(unit, soc_feature_flex_port)) {
            alloc_sz += (SOC_MAX_NUM_PORTS * sizeof(int));
        }
#endif

        /* Restore SW RX LOS status */
        PBMP_ITER(all_pbmp, port) {
            alloc_sz += sizeof(uint8);
        }

#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_FIRELIGHT_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) || SOC_IS_FIRELIGHT(unit)) {
            /* Allocate size for port enable status */
            PBMP_ITER(all_pbmp, port) {
                alloc_sz += sizeof(int);
            }
        }
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIUMPH3_SUPPORT
        if (SOC_IS_TRIUMPH3(unit) && !SOC_IS_HELIX4(unit)) {
            alloc_sz += 2 * sizeof(((_port_ibod_ctrl_t *)0)->rrbyt)
                         + sizeof((((_port_ibod_ctrl_t *)0)->event_count));
        }
#endif /* BCM_TRIUMPH3_SUPPORT */
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
            int port_forward_size;
            BCM_IF_ERROR_RETURN(
                _bcm_port_force_forward_scache_size(unit, &port_forward_size));
            alloc_sz += port_forward_size;
        }
#endif /* defined(BCM_TRIUMPH3_SUPPORT) */

#ifdef  BCM_TOMAHAWK_SUPPORT
        /* ASF WB */
        rv = _bcm_esw_asf_wb_memsz_get(unit, &asf_wbmem_sz, BCM_PORT_WB_DEFAULT_VERSION);
        if (BCM_E_NONE == rv) {
            alloc_sz += asf_wbmem_sz;
        }

        /* Switch Latency Bypass WB */
        rv = bcmi_esw_switch_latency_wb_memsz_get(unit, &latency_wbmem_sz,
                                                  BCM_PORT_WB_DEFAULT_VERSION);
        if (BCM_E_NONE == rv) {
            alloc_sz += latency_wbmem_sz;
        }
#endif /* BCM_TOMAHAWK_SUPPORT */

        /*IFG WB*/
        if (soc_feature(unit, soc_feature_xmac) ||
                soc_feature(unit, soc_feature_xlmac) ||
                soc_feature(unit, soc_feature_cmac) ||
                soc_feature(unit, soc_feature_clmac)) {
            PBMP_ITER(all_pbmp, port) {
                alloc_sz += sizeof(uint32);
            }
        }
        /* PORT DSCP MAP SETTING */
        if (soc_feature(unit, soc_feature_dscp) &&
            soc_feature(unit, soc_feature_egr_dscp_map_per_port)) {
            /* Allocate size for port dscp map setting status */
            PBMP_ITER(all_pbmp, port) {
                alloc_sz += sizeof(int);
            }
        }

#ifdef  BCM_TOMAHAWK_SUPPORT
        if (SOC_IS_TOMAHAWK(unit)) {
            /* Allocate size for port interface type */
            PBMP_ITER(all_pbmp, port) {
                alloc_sz += sizeof(int);
            }
        }
#endif /* BCM_TOMAHAWK_SUPPORT */

        if (soc_feature(unit, soc_feature_phy_interface_wb)) {
            /* Allocate size for port interface type */
            PBMP_ITER(PBMP_PORT_ALL(unit), port) {
                alloc_sz += sizeof(int);
            }
        }

        SOC_SCACHE_HANDLE_SET(scache_handle,
                              unit, BCM_MODULE_PORT,
                              BCM_PORT_WB_SCACHE_PART_DEFAULT);
        rv = _bcm_esw_scache_ptr_get(unit, scache_handle, TRUE,
                                     alloc_sz, (uint8**)&port_state,
                                     BCM_PORT_WB_DEFAULT_VERSION, NULL);
        if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
            return rv;
        }
    }
#endif /* BCM_TRX_SUPPORT */

#ifdef BCM_PREEMPTION_SUPPORT
    if (soc_feature(unit, soc_feature_preemption)) {
        soc_scache_handle_t scache_handle;

        SOC_SCACHE_HANDLE_SET(scache_handle,
                              unit, BCM_MODULE_PORT,
                              BCM_PORT_WB_SCACHE_PART_PREMMPTION);
        BCM_IF_ERROR_RETURN(
            bcmi_esw_preemption_wb_alloc(unit, scache_handle));
    }
#endif /* BCM_PREEMPTION_SUPPORT */

    return BCM_E_NONE;
}

#ifdef BCM_TRIUMPH2_SUPPORT
/*
 * Function:
 *      _bcm_tr2_flexport_recover
 * Purpose:
 *     To recover/reconstruct the HL port configuration
 *     during warmboot. This is a 'level one' warmboot
 *     recovery. It depends on the reg configuration of
 *     EDATABUF_XQP_FLEXPORT_CONFIGr which maintains the
 *     flexport config of the HL ports that was done
 *     in coldboot mode.
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      port - Port number of the HL
 *             flexport controlling port.
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_tr2_flexport_recover(int unit, bcm_port_t port)
{
    uint8 rev_id;
    uint16 dev_id;
    uint32 port_type;
    int i, old_value, rv;
    bcm_port_t it_port;
    port_tab_entry_t pent;
    soc_info_t *si = &SOC_INFO(unit);

    soc_cm_get_id(unit, &dev_id, &rev_id);
    BCM_IF_ERROR_RETURN(_bcm_tr2_port_lanes_get(unit, port, &old_value));

#define RECONFIGURE_TR2_PORT_TYPE_INFO(ptype) \
    si->ptype.num = 0; \
    si->ptype.min = si->ptype.max = -1; \
    PBMP_ITER(si->ptype.bitmap, it_port) { \
        si->ptype.port[si->ptype.num++] = it_port; \
        if (si->ptype.min < 0) { \
            si->ptype.min = it_port; \
        } \
        if (it_port > si->ptype.max) { \
            si->ptype.max = it_port; \
        } \
    }

    /* Step 1: Change the SOC bitmaps */
    if ((old_value == 1)) {
        /* The block originally had 4 GE ports */
        SOC_CONTROL_LOCK(unit);
        SOC_PBMP_PORT_REMOVE(si->st.bitmap, port);
        SOC_PBMP_PORT_REMOVE(si->hg.bitmap, port);
        SOC_PBMP_PORT_REMOVE(si->xe.bitmap, port);
        SOC_PBMP_PORT_ADD(si->ether.bitmap, port);
        SOC_PBMP_PORT_ADD(si->ge.bitmap, port);
        si->port_speed_max[port] = 1000;
        soc_port_cmap_set(unit, port, SOC_CTR_TYPE_GE);
        for (i = port + 1; i < port + 4; i++) {
            SOC_PBMP_PORT_REMOVE(si->ge.disabled_bitmap, i);
            SOC_PBMP_PORT_REMOVE(si->ether.disabled_bitmap, i);
            SOC_PBMP_PORT_REMOVE(si->port.disabled_bitmap, i);
            SOC_PBMP_PORT_REMOVE(si->all.disabled_bitmap, i);
            si->port_speed_max[i] = 1000;
            soc_port_cmap_set(unit, i, SOC_CTR_TYPE_GE);
        }
        RECONFIGURE_TR2_PORT_TYPE_INFO(ether);
        RECONFIGURE_TR2_PORT_TYPE_INFO(st);
        RECONFIGURE_TR2_PORT_TYPE_INFO(hg);
        RECONFIGURE_TR2_PORT_TYPE_INFO(xe);
        RECONFIGURE_TR2_PORT_TYPE_INFO(ge);
        SOC_CONTROL_UNLOCK(unit);
    } else if (old_value == 4) {
        /* The block was originally a single high-speed port */
        SOC_CONTROL_LOCK(unit);
        rv = soc_mem_read(unit, SOC_PORT_MEM_TAB(unit, port),
                MEM_BLOCK_ANY, SOC_PORT_MOD_OFFSET(unit, port), &pent);
        if (BCM_FAILURE(rv)) {
            SOC_CONTROL_UNLOCK(unit);
            return rv;
        }
        port_type = soc_PORT_TABm_field32_get(unit, &pent, PORT_TYPEf);
        switch(port_type) {
          case 0 : /* xe */
            SOC_PBMP_PORT_ADD(si->xe.bitmap, port);
            SOC_PBMP_PORT_ADD(si->ether.bitmap, port);
            SOC_PBMP_PORT_REMOVE(si->hg.bitmap, port);
            SOC_PBMP_PORT_REMOVE(si->st.bitmap, port);
            break;
          case 1 : /* hg */
            SOC_PBMP_PORT_ADD(si->hg.bitmap, port);
            SOC_PBMP_PORT_ADD(si->st.bitmap, port);
            SOC_PBMP_PORT_REMOVE(si->xe.bitmap, port);
            SOC_PBMP_PORT_REMOVE(si->ether.bitmap, port);
          default:
            break;
        }
        SOC_PBMP_PORT_REMOVE(si->ge.bitmap, port);
	switch (dev_id) {
	case BCM56526_DEVICE_ID:
	  si->port_speed_max[port] = 13000;
	  break;
	case BCM56636_DEVICE_ID:
	case BCM56638_DEVICE_ID:
	  si->port_speed_max[port] = 12000;
	  break;
	default:
	  si->port_speed_max[port] = 10000;
	}
        soc_port_cmap_set(unit, port, SOC_CTR_TYPE_XE);
        for (i = port + 1; i < port + 4; i++) {
            SOC_PBMP_PORT_ADD(si->ge.disabled_bitmap, i);
            SOC_PBMP_PORT_ADD(si->ether.disabled_bitmap, i);
            SOC_PBMP_PORT_ADD(si->port.disabled_bitmap, i);
            SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, i);
        }
        RECONFIGURE_TR2_PORT_TYPE_INFO(ether);
        RECONFIGURE_TR2_PORT_TYPE_INFO(st);
        RECONFIGURE_TR2_PORT_TYPE_INFO(hg);
        RECONFIGURE_TR2_PORT_TYPE_INFO(ge);
        SOC_CONTROL_UNLOCK(unit);
    }
#undef RECONFIGURE_PORT_TYPE_INFO
    soc_dport_map_update(unit);

    return BCM_E_NONE;
}
#endif /* BCM_TRIUMPH2_SUPPORT */

#ifdef BCM_TRIDENT2_SUPPORT
/*
 * Function:
 *      _bcm_td2_flexport_recover
 * Purpose:
 *     To recover/reconstruct the HL port configuration
 *     during warmboot. This is a 'level one' warmboot
 *     recovery. It depends on the reg configuration of
 *     XLPORT_MODE_REGr which maintains the
 *     flexport config of the HL ports that was done
 *     in coldboot mode.
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      port - Port number of the HL
 *             flexport controlling port.
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_td2_flexport_recover(int unit, bcm_port_t port)
{
    soc_info_t *si = &SOC_INFO(unit);
    int i, phy_port, phy_port_base, port_base, lp;
    int mode, phy_port_actived[4];
    uint32 rval;

    phy_port      = si->port_l2p_mapping[port];
    phy_port_base = (phy_port & ~0x3) + 1;
    port_base     = si->port_p2l_mapping[phy_port_base];

    if (phy_port == -1 || phy_port != phy_port_base) {
        return BCM_E_NONE;
    }

    sal_memset(phy_port_actived, 0, sizeof(phy_port_actived));

    /* Get the current mode */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        BCM_IF_ERROR_RETURN(bcmi_esw_portctrl_mode_get(unit, port, &mode));
    } else {
        SOC_IF_ERROR_RETURN(READ_XLPORT_MODE_REGr(unit, port_base, &rval));
        mode = soc_reg_field_get(unit, XLPORT_MODE_REGr, rval,
                                 XPORT0_CORE_PORT_MODEf);
    }

    switch(mode) {
    case SOC_TD2_PORT_MODE_QUAD:
        phy_port_actived[0] =
        phy_port_actived[1] =
        phy_port_actived[2] =
        phy_port_actived[3] = 1;
        break;
    case SOC_TD2_PORT_MODE_TRI_012:
        phy_port_actived[0] =
        phy_port_actived[1] =
        phy_port_actived[2] = 1;
        break;
    case SOC_TD2_PORT_MODE_TRI_023:
        phy_port_actived[0] =
        phy_port_actived[2] =
        phy_port_actived[3] = 1;
        break;
    case SOC_TD2_PORT_MODE_DUAL:
        phy_port_actived[0] =
        phy_port_actived[2] = 1;
        break;
    case SOC_TD2_PORT_MODE_SINGLE:
        phy_port_actived[0] = 1;
        break;
    default:
        return SOC_E_FAIL;
    }

    SOC_CONTROL_LOCK(unit);
    for (i = 0; i < 4; i++) {
        lp = si->port_p2l_mapping[phy_port_base + i];
        if (lp != -1 &&
            BCM_PBMP_MEMBER(PBMP_PORT_ALL(unit), lp)) {
            if (phy_port_actived[i]) {
                SOC_PBMP_PORT_REMOVE(/* port(s) to be added */
                    SOC_PORT_DISABLED_BITMAP(unit, all), lp);
            } else {
                SOC_PBMP_PORT_ADD(   /* port(s) to be removed */
                    SOC_PORT_DISABLED_BITMAP(unit, all), lp);
            }
        }
    }
    SOC_CONTROL_UNLOCK(unit);

    return SOC_E_NONE;
}
#endif /* BCM_TRIDENT2_SUPPORT */

void bcm_esw_port_mdix_wb_update(int unit)
{
    int p;
    bcm_port_mdix_t mdix;

    PBMP_ITER(PBMP_PORT_ALL(unit), p) {
       /* Intentionally return value is not checked as this function
        * is called to wb update mdix value for the port, if it exists.
        */
#ifdef BCM_HURRICANE4_SUPPORT
        if (SOC_IS_HURRICANE4(unit) &&
            !IS_EGPHY_PORT(unit, p)) {
            continue;
        }
#endif /* BCM_HURRICANE4_SUPPORT */
        bcm_esw_port_mdix_get(unit,p,&mdix);
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                       (BSL_META_U(unit, "Port %d MDIX udate in wb !!\n"), p));
    }
}

STATIC int
_bcm_esw_port_wb_recover_scache(int unit, uint16 recovered_ver,
            uint8 *port_state, int stable_size, uint32 asf_wbmem_sz,
            uint32 latency_wbmem_sz, uint32 oamp_status,
            soc_scache_handle_t scache_handle, int *use_pbmp, pbmp_t *port_bitmap,
            bcm_pbmp_t *dtm_pbmp, bcm_pbmp_t *all_pbmp)
{
    int rv = BCM_E_NONE;
#if defined(BCM_TRX_SUPPORT)
    bcm_port_t port;
    _bcm_port_info_t *pinfo;
    int realloc_size = 0;
#ifdef BCM_TRIUMPH2_SUPPORT
#ifdef BCM_TRIDENT_SUPPORT
        soc_info_t *si = &SOC_INFO(unit);
        int _port_lanes_valid = 0;
#ifdef BCM_TRIUMPH3_SUPPORT
        int _port_num_lanes[SOC_MAX_NUM_PORTS] = {0};
#endif /* BCM_TRIUMPH3_SUPPORT */
#endif /* BCM_TRIDENT_SUPPORT */
#endif /* BCM_TRIUMPH2_SUPPORT */

    PBMP_ITER(*all_pbmp, port) {
        BCM_IF_ERROR_RETURN(_bcm_port_info_get(unit, port, &pinfo));
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
        if ((SOC_IS_KATANA2(unit) || SOC_IS_TOMAHAWK2(unit) || SOC_IS_TRIDENT3X(unit)) &&
                (recovered_ver >= BCM_PORT_WB_VERSION_1_9)) {
            /* Recover vp entry and vlan prot ptr */
            uint32 vlan_protocol_data_index = 0;
            int idxmin, idxmax, vpentry = 0;
            idxmin = soc_mem_index_min(unit, VLAN_PROTOCOLm);
            idxmax = soc_mem_index_max(unit, VLAN_PROTOCOLm);

            sal_memcpy(&vpentry, port_state, sizeof(int));
            port_state += sizeof(int);

            BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port, SPT_PBVL,
                            sizeof(int), port_state - sizeof(int)));

            if ((vpentry >= idxmin) && (vpentry <= idxmax) &&
                    (!_BCM_PORT_VD_PBVL_IS_SET(pinfo, vpentry))) {
                /* Set as explicit VID */
                _BCM_PORT_VD_PBVL_SET(pinfo, vpentry);
            }

            sal_memcpy(&vlan_protocol_data_index, port_state,
                    sizeof(uint32));
            port_state += sizeof(uint32);

            BCM_IF_ERROR_RETURN(_scache_port_print_add(unit, port,
                            SPT_VLAN_PROT_PTR,
                            sizeof(uint32), port_state - sizeof(uint32)));

            pinfo->vp_count = 0;
            /* update vlan port protocol data memory */
            if (!IS_LB_PORT(unit, port)) {
                BCM_IF_ERROR_RETURN(_bcm_esw_port_tab_set(unit, port,
                            _BCM_CPU_TABS_ETHER,
                            VLAN_PROTOCOL_DATA_INDEXf,
                            vlan_protocol_data_index / 16));

                pinfo->vlan_prot_ptr = vlan_protocol_data_index;
                BCM_IF_ERROR_RETURN(
                        _bcm_port_vlan_protocol_data_entry_reference (unit,
                            vlan_protocol_data_index, 16));
            }
        }
#endif
        /* In Apache information is saved and recovered for 76 ports which is
         * greater than SOC_MAX_NUM_PORTS value of 75. These checks are
         * needed to prevent invalid memory access.
         */
        if (port < SOC_MAX_NUM_PORTS) {
            /* Recover VP reference counts */
            sal_memcpy(&(pinfo->vp_count), port_state, sizeof(pinfo->vp_count));
        }
        port_state += sizeof(int);

        BCM_IF_ERROR_RETURN(
                _scache_port_print_add(unit, port, SPT_VP_COUNT, sizeof(int),
                                    port_state - sizeof(int)));
    }
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && (recovered_ver >= BCM_PORT_WB_VERSION_1_9)) {
        /* Keep one extra reference to the default profile */
        BCM_IF_ERROR_RETURN(
                _bcm_port_vlan_protocol_data_entry_reference (unit,
                    0, 16));
    }
#endif
    /* Recover dtag_mode port bitmap */
    sal_memcpy(dtm_pbmp, port_state, sizeof(bcm_pbmp_t));
    port_state += sizeof(bcm_pbmp_t);
    *use_pbmp = TRUE; /* Cached info available */

    BCM_IF_ERROR_RETURN(
            _scache_port_print_add(unit, -1, SPT_DTM_PBMP, sizeof(bcm_pbmp_t),
                                port_state - sizeof(bcm_pbmp_t)));

    if (recovered_ver >= BCM_PORT_WB_VERSION_1_1) {
        PBMP_ITER(*all_pbmp, port) {
            if (!SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit) && (stable_size > 0)) {
                /* Recover port tx stop related info */
                if (SOC_REG_IS_VALID(unit, COSMASKr)) {
                    if (port < SOC_MAX_NUM_PORTS) {
                        sal_memcpy(&(PORT(unit, port).cosmask), port_state,
                                   sizeof(uint32));
                    }
                    port_state += sizeof(uint32);

                    BCM_IF_ERROR_RETURN(
                            _scache_port_print_add(unit, port, SPT_COSMASK,
                            sizeof(uint32), port_state - sizeof(uint32)));
                } else {
                    if (port < SOC_MAX_NUM_PORTS) {
                        sal_memcpy(&(PORT(unit, port).m_info), port_state,
                                   sizeof(_bcm_port_metering_info_t));
                    }
                    port_state += sizeof(_bcm_port_metering_info_t);

                    BCM_IF_ERROR_RETURN(
                            _scache_port_print_add(unit, port, SPT_METERING_INFO,
                                            sizeof(_bcm_port_metering_info_t),
                            port_state - sizeof(_bcm_port_metering_info_t)));
                }
                if (port < SOC_MAX_NUM_PORTS) {
                    /* Recover flags */
                    sal_memcpy(&(PORT(unit, port).flags), port_state, sizeof(uint8));
                }
                port_state += sizeof(uint8);

                BCM_IF_ERROR_RETURN(
                        _scache_port_print_add(unit, port, SPT_PORT_FLAGS, sizeof(uint8),
                        port_state - sizeof(uint8)));
            }
        }
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (SOC_IS_TOMAHAWK(unit)) {
            PBMP_ALL_ITER(unit, port) {
                BCM_IF_ERROR_RETURN(soc_th_port_speed_recover(unit, port));
            }
        }
#endif
#ifdef BCM_TRIDENT_SUPPORT
        if ((SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit)) &&
            soc_feature(unit, soc_feature_flex_port)) {
            int num_lanes = 0;
            if (SOC_IS_TD_TT(unit)) {
                PBMP_ALL_ITER(unit, port) {
                    sal_memcpy(&num_lanes, port_state, sizeof(int));
                    port_state += sizeof(int);

                    BCM_IF_ERROR_RETURN(
                            _scache_port_print_add(unit, port, SPT_PORT_NUM_LANES,
                            sizeof(int), port_state - sizeof(int)));
#ifdef BCM_HURRICANE4_SUPPORT
                    if (SOC_IS_HURRICANE4(unit) &&
                        (IS_MACSEC_PORT(unit, port) ||
                        IS_LB_PORT(unit,port))) {
                        continue;
                    }
#endif
                    if (si->port_num_lanes[port] != num_lanes) {
#if defined(BCM_TOMAHAWK_SUPPORT)
                        if (SOC_IS_TOMAHAWK(unit)) {
                           BCM_IF_ERROR_RETURN(
                                   soc_th_flexport_recover(unit, port));
                        }
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
                        if (SOC_IS_TD2_TT2(unit) &&
                           (!(SOC_IS_TD2P_TT2P(unit) ||
                              SOC_IS_APACHE(unit) ||
                              SOC_IS_TOMAHAWK2(unit)))) {
                            BCM_IF_ERROR_RETURN(
                                    _bcm_td2_flexport_recover(unit, port));
                        }
#endif /* BCM_TRIDENT2_SUPPORT */
                        si->port_num_lanes[port] = num_lanes;
                        _port_lanes_valid++;
                    }
                }
            }
#ifdef BCM_TRIUMPH3_SUPPORT
            else if (SOC_IS_TRIUMPH3(unit)) {
                PBMP_ALL_ITER(unit, port) {
                    sal_memcpy(&_port_num_lanes[port], port_state,
                               sizeof(int));
                    port_state += sizeof(int);
                    _port_lanes_valid++;
                }
            }
#endif /* BCM_TRIUMPH2_SUPPORT */
            if (SOC_IS_TD_TT(unit) && (_port_lanes_valid > 0)) {
                /* Call PHY probe for flex port config to take effect */
                if ((rv = bcm_esw_port_probe(unit, PBMP_PORT_ALL(unit),
                       port_bitmap)) != BCM_E_NONE) {
                    LOG_ERROR(BSL_LS_BCM_PORT, \
                              (BSL_META_U(unit, \
                                          "Error unit %d:\
                                          Failed port probe: %s\n"),
                               unit, bcm_errmsg(rv)));
                    return rv;
                }
            }
        }
#endif /* BCM_TRIDENT_SUPPORT */
    } else {
        PBMP_ITER(*all_pbmp, port) {
            if (!SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit) && (stable_size > 0)) {
                /* Recover port tx stop related info */
                if (SOC_REG_IS_VALID(unit, COSMASKr)) {
                    realloc_size += sizeof(uint32);
                } else {
                    realloc_size += sizeof(_bcm_port_metering_info_t);
                }
                /* Recover flags */
                realloc_size += sizeof(uint8);
            }
        }
    }

    if (recovered_ver >= BCM_PORT_WB_VERSION_1_2) {
        uint8 rx_los = 0;
        PBMP_ITER(*all_pbmp, port) {
#if defined(BCM_SABER2_SUPPORT)
            if(SOC_IS_SABER2(unit)) {
                if ((port == SOC_SB2_SAT_OAMP_PHY_PORT_NUMBER) && (oamp_status == 1)){
                    continue;
                }
            }
#endif
            /* Recover RX_LOS */
            rx_los = *port_state;
            port_state += sizeof(uint8);

            BCM_IF_ERROR_RETURN(
                    _scache_port_print_add(unit, port, SPT_RX_LOS, sizeof(uint8),
                    port_state - sizeof(uint8)));

            if (IS_E_PORT(unit, port)) {
                /* Call PHY control for RX_lOS config to take effect */
                if (rx_los == BCM_PORT_PHY_CONTROL_RX_LOS_NONE ||
                    rx_los == BCM_PORT_PHY_CONTROL_RX_LOS_SOFTWARE) {

                    if (!soc_feature(unit, soc_feature_no_sw_rx_los)){
                        rv = bcm_esw_port_phy_control_set(unit, port,
                        BCM_PORT_PHY_CONTROL_SOFTWARE_RX_LOS, rx_los);
                        if (BCM_FAILURE(rv) && (rv != BCM_E_UNAVAIL)) {
                            LOG_ERROR(BSL_LS_BCM_PORT,
                                  (BSL_META_U(unit,
                                              "Error unit %d: "
                                              "Failed port phy control set: %s\n"),
                                   unit, bcm_errmsg(rv)));
                            return rv;
                        }
                    }
                }
            }
        }
    } else {
        PBMP_ITER(*all_pbmp, port) {
            if (!SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit)
                && (stable_size > 0)) {
                /* Recover SW RX LOS status */
                realloc_size += sizeof(uint8);
            }
        }
    }

#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_FIRELIGHT_SUPPORT)
    if (SOC_IS_TD2_TT2(unit) || SOC_IS_FIRELIGHT(unit)) {
        if (recovered_ver >= BCM_PORT_WB_VERSION_1_3) {
            PBMP_ITER(*all_pbmp, port) {
                if (!SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit)
                    && (stable_size > 0)) {
                    if (port < SOC_MAX_NUM_PORTS) {
                        /* Recover port enable status */
                        sal_memcpy(&(PORT(unit, port).enable),
                                   port_state, sizeof(int));
                    }
                    port_state += sizeof(int);

                    BCM_IF_ERROR_RETURN(
                            _scache_port_print_add(unit, port, SPT_PORT_ENABLE,
                            sizeof(int), port_state - sizeof(int)));
                }
            }
        } else {
            PBMP_ITER(*all_pbmp, port) {
                if (!SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit)
                    && (stable_size > 0)) {
                    /* Recover SW port enable status */
                    realloc_size += sizeof(int);
                }
            }
        }
    }
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit) && !SOC_IS_HELIX4(unit)) {
        if ((recovered_ver >= BCM_PORT_WB_VERSION_1_4) && _port_ibod_ctrl[unit]) {
            sal_memcpy(_port_ibod_ctrl[unit]->rrbyt, port_state,
                    sizeof(((_port_ibod_ctrl_t *)0)->rrbyt));
            port_state += sizeof(((_port_ibod_ctrl_t *)0)->rrbyt);
            sal_memcpy(_port_ibod_ctrl[unit]->rrpkt, port_state,
                    sizeof(((_port_ibod_ctrl_t *)0)->rrpkt));
            port_state += sizeof(((_port_ibod_ctrl_t *)0)->rrpkt);
            sal_memcpy(&(_port_ibod_ctrl[unit]->event_count), port_state,
                    sizeof(((_port_ibod_ctrl_t *)0)->event_count));
            port_state += sizeof(((_port_ibod_ctrl_t *)0)->event_count);
        } else {
            realloc_size +=  sizeof(((_port_ibod_ctrl_t *)0)->rrbyt);
            realloc_size +=  sizeof(((_port_ibod_ctrl_t *)0)->rrpkt);
            realloc_size += sizeof(((_port_ibod_ctrl_t *)0)->event_count);
        }
    }
    /*
     * Recover the port force forward information from scache.
     * If the recovered version is lower than 1.5, allocate
     * space in scache for any further sync.
     */
    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
       if (recovered_ver >= BCM_PORT_WB_VERSION_1_5) {
           BCM_IF_ERROR_RETURN(
                   _bcm_port_force_forward_reinit(unit, &port_state));
       } else {
           bcm_port_t egr_port;
           int enabled = 0;
           int port_forward_size = 0;
           PBMP_ITER(*all_pbmp, port) {
              BCM_IF_ERROR_RETURN(
                      bcm_esw_port_force_forward_get(unit, port,
                                           &egr_port, &enabled));
              if (enabled) {
                  _bcm_port_force_forward_add(unit, port,
                          egr_port);
              }
           }
           BCM_IF_ERROR_RETURN(_bcm_port_force_forward_scache_size(unit,
                                &port_forward_size));
           realloc_size += port_forward_size;
       }
    }
#endif /* defined(BCM_TRIUMPH3_SUPPORT) */

#ifdef  BCM_TOMAHAWK_SUPPORT
    if (recovered_ver >= BCM_PORT_WB_VERSION_1_6) {
        /* ASF WB Recovery */
        rv = _bcm_esw_asf_wb_recover(unit, port_state, recovered_ver);
        if (BCM_E_NONE != rv) {
            LOG_ERROR(BSL_LS_BCM_PORT, \
                      (BSL_META_U(unit, \
                                  "Error unit %d:\
                                  ASF Warmboot Recovery Failed: %s\n"), \
                       unit, bcm_errmsg(rv)));
            return rv;
        }
        port_state += asf_wbmem_sz;

        BCM_IF_ERROR_RETURN(
            _scache_port_print_add(unit, -1, SPT_ASF, asf_wbmem_sz,
            port_state - asf_wbmem_sz));
    }

    if (recovered_ver >= BCM_PORT_WB_VERSION_1_6) {
        /* Switch Latency Bypass WB Recovery */
        rv = bcmi_esw_switch_latency_wb_recover(unit, port_state, recovered_ver);
        if (BCM_E_NONE != rv) {
            LOG_ERROR(BSL_LS_BCM_PORT, \
                      (BSL_META_U(unit, \
                                  "Error unit %d:\
                                  Switch Latency Bypass \
                                  Warmboot Recovery Failed: %s\n"), \
                       unit, bcm_errmsg(rv)));
            return rv;
        }
        port_state += latency_wbmem_sz;

        BCM_IF_ERROR_RETURN(
            _scache_port_print_add(unit, -1, SPT_LATENCY, latency_wbmem_sz,
            port_state - latency_wbmem_sz));
    }

    /* sflow WB recovery */
    rv = _bcm_esw_sflow_wb_recover(unit);
    if (BCM_E_NONE != rv) {
        LOG_ERROR(BSL_LS_BCM_PORT, (BSL_META_U(unit, "Error \
              unit %d: sflow Warmboot Recovery Failed: %s\n"), unit,
              bcm_errmsg(rv)));
        return rv;
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
    /*IFG WB*/
    if (soc_feature(unit, soc_feature_xmac) ||
            soc_feature(unit, soc_feature_xlmac) ||
            soc_feature(unit, soc_feature_cmac) ||
            soc_feature(unit, soc_feature_clmac)) {
        if (recovered_ver >= BCM_PORT_WB_VERSION_1_7) {
            BCM_IF_ERROR_RETURN(
                    _bcm_esw_port_ifg_wb_reinit(unit, &port_state));
        } else {
            PBMP_ITER(*all_pbmp, port) {
                if (!SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit)
                    && (stable_size > 0)) {
                    realloc_size += sizeof(uint32);
                }
            }
        }
    }
    /* PORT DSCP MAP SETTING */
    if (soc_feature(unit, soc_feature_dscp) &&
        soc_feature(unit, soc_feature_egr_dscp_map_per_port)) {
        if (recovered_ver >= BCM_PORT_WB_VERSION_1_11) {
            PBMP_ITER(*all_pbmp, port) {
                if (!SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit)
                    && (stable_size > 0)) {
                    /* Recover port dscp map status */
                    sal_memcpy(&(PORT(unit, port).port_dscp_map_set),
                                port_state, sizeof(int));
                    port_state += sizeof(int);

                    BCM_IF_ERROR_RETURN(
                            _scache_port_print_add(unit, port, SPT_DSCP_MAP,
                            sizeof(int), port_state - sizeof(int)));

                    if (PORT(unit, port).port_dscp_map_set) {
                        BCM_IF_ERROR_RETURN(
                                _bcm_egr_dscp_table_entry_reference(
                                unit, port * _BCM_QOS_MAP_CHUNK_EGR_DSCP,
                                _BCM_QOS_MAP_CHUNK_EGR_DSCP));
                    }
                }
            }
        } else {
            PBMP_ITER(*all_pbmp, port) {
                if (!SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit)
                    && (stable_size > 0)) {
                    /* Recover SW port dscp map status */
                    realloc_size += sizeof(int);
                }
            }
        }
    }

#ifdef  BCM_TOMAHAWK_SUPPORT
    if (SOC_IS_TOMAHAWK(unit) && recovered_ver >= BCM_PORT_WB_VERSION_1_12) {
        /* Recover port interface type */
        int pif;
        PBMP_ITER(*all_pbmp, port) {
            if (IS_XE_PORT(unit, port) ||
                IS_CE_PORT(unit, port) ||
                IS_HG_PORT(unit, port) ||
                IS_GE_PORT(unit, port) ||
                IS_MANAGEMENT_PORT(unit, port)) {

                sal_memcpy(&pif, port_state, sizeof(int));
                port_state += sizeof(int);

                BCM_IF_ERROR_RETURN(
                        _scache_port_print_add(unit, port, SPT_PORT_INTF_TYPE,
                            sizeof(int), port_state - sizeof(int)));

                BCM_IF_ERROR_RETURN(soc_phyctrl_interface_set(unit, port, pif));
            }
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
    if (soc_feature(unit, soc_feature_phy_interface_wb) &&
        (recovered_ver >= BCM_PORT_WB_VERSION_1_13)) {
        /* Recover port interface type */
        int pif;

        PBMP_ITER(PBMP_PORT_ALL(unit), port) {
            sal_memcpy(&pif, port_state, sizeof(int));
            port_state += sizeof(int);

            BCM_IF_ERROR_RETURN(
                    _scache_port_print_add(unit, port, SPT_PORT_INTF_TYPE,
                    sizeof(int), port_state - sizeof(int)));

            if (pif) {
                BCM_IF_ERROR_RETURN(
                        soc_phyctrl_interface_set(unit, port, pif));
            }
        }
    }

    if (realloc_size > 0) {
       BCM_IF_ERROR_RETURN(
               soc_scache_realloc(unit, scache_handle, realloc_size));
    }
#endif /* BCM_TRX_SUPPORT */

    return rv;
}

int
_bcm_esw_port_wb_recover(int unit)
{
    int rv = BCM_E_NONE;

#if defined(BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit)) {
        int alloc_sz, use_pbmp = FALSE;
        uint8 *port_state;
        uint16 recovered_ver;
        bcm_port_t port;
        bcm_pbmp_t dtm_pbmp;
        int stable_size;
        soc_scache_handle_t scache_handle;
        uint32 oamp_status = 0;
#if defined(BCM_SABER2_SUPPORT)
        uint32 rval = 0;
#endif
        pbmp_t port_bitmap;
        bcm_pbmp_t all_pbmp;
        uint32 asf_wbmem_sz = 0;
        /* Switch Latency Bypass WB will move to a different module later */
        uint32 latency_wbmem_sz = 0;
#ifdef  BCM_TOMAHAWK_SUPPORT
        uint16 scache_ver = BCM_PORT_WB_DEFAULT_VERSION;

#endif

        BCM_PBMP_CLEAR(all_pbmp);
        BCM_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

        SOC_SCACHE_HANDLE_SET(scache_handle, unit, BCM_MODULE_PORT,
                              BCM_PORT_WB_SCACHE_PART_DEFAULT);
        rv = _bcm_esw_scache_ptr_get(unit, scache_handle, FALSE,
                                     0, (uint8**)&port_state,
                                     BCM_PORT_WB_DEFAULT_VERSION, &recovered_ver);
        if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
            return rv;
        }

#if defined(BCM_SABER2_SUPPORT)
        if(SOC_IS_SABER2(unit)) {
            SOC_IF_ERROR_RETURN(READ_OAMP_ENABLEr(unit, &rval));
            oamp_status = soc_reg_field_get(unit, OAMP_ENABLEr, rval, ENABLEf);
        }
#endif
#ifdef BCM_KATANA2_SUPPORT
        if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
#if defined(BCM_SABER2_SUPPORT)
            if ( SOC_IS_SABER2(unit) && !SOC_IS_METROLITE(unit) &&
                (recovered_ver < BCM_PORT_WB_VERSION_1_10) ) {
                BCM_IF_ERROR_RETURN(_bcm_sb2_wb_v1_flexio_pbmp_update(unit, &all_pbmp));
            } else
#endif
            {
                BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
#if defined(BCM_SABER2_SUPPORT)
                bcm_sb2_wb_v2_flexio_update = 1;
#endif
            }
        }
        if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
        }
#endif
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (SOC_IS_TD2P_TT2P(unit)) {
            BCM_IF_ERROR_RETURN(bcm_td2p_flexport_pbmp_update(unit,
                                                 &all_pbmp));
        }
#endif
#ifdef BCM_MONTEREY_SUPPORT
        if (SOC_IS_MONTEREY(unit)) {
            BCM_IF_ERROR_RETURN(bcm_monterey_flexport_pbmp_update(unit, &all_pbmp));
        }
#endif
#ifdef BCM_APACHE_SUPPORT
        if (SOC_IS_APACHE(unit) && !SOC_IS_MONTEREY(unit)) {
            BCM_IF_ERROR_RETURN(bcm_apache_flexport_pbmp_update(unit, &all_pbmp));
        }
#endif

        alloc_sz = 0;
        SOC_IF_ERROR_RETURN(soc_stable_size_get(unit, &stable_size));
        PBMP_ITER(all_pbmp, port) {
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
            if ((SOC_IS_KATANA2(unit) || SOC_IS_TOMAHAWK2(unit) || SOC_IS_TRIDENT3X(unit))) {
                /* vp entry and vlan prot ptr */
                alloc_sz += (sizeof(int) + sizeof(uint32));
            }
#endif
            alloc_sz += sizeof(int); /* vp count */
        }
        alloc_sz += sizeof(bcm_pbmp_t); /* Bitmap of dtag_mode == NONE */
        PBMP_ITER(all_pbmp, port) {
            if (!SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit) && (stable_size > 0)) {
                if (SOC_REG_IS_VALID(unit, COSMASKr)) {
                    alloc_sz += sizeof(uint32);
                } else {
                    alloc_sz += sizeof(_bcm_port_metering_info_t);
                }
                alloc_sz += sizeof(uint8);
            }
        }

#ifdef BCM_TRIDENT_SUPPORT
        if ((SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit)) &&
            soc_feature(unit, soc_feature_flex_port)) {
            alloc_sz += (SOC_MAX_NUM_PORTS * sizeof(int));
        }
#endif

        /* Restore SW RX LOS status */
        PBMP_ITER(all_pbmp, port) {
            alloc_sz += sizeof(uint8);
        }

#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_FIRELIGHT_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) || SOC_IS_FIRELIGHT(unit)) {
            /* Allocate size for port enable status */
            PBMP_ITER(all_pbmp, port) {
                alloc_sz += sizeof(int);
            }
        }
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIUMPH3_SUPPORT
        if (SOC_IS_TRIUMPH3(unit) && !SOC_IS_HELIX4(unit)) {
            alloc_sz += 2 * sizeof(((_port_ibod_ctrl_t *)0)->rrbyt)
                            + sizeof((((_port_ibod_ctrl_t *)0)->event_count));
        }
#endif /* BCM_TRIUMPH3_SUPPORT */
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
            int port_forward_size;
            BCM_IF_ERROR_RETURN(
                _bcm_port_force_forward_scache_size(unit, &port_forward_size));
            alloc_sz += port_forward_size;
        }
#endif /* defined(BCM_TRIUMPH3_SUPPORT) */

#ifdef  BCM_TOMAHAWK_SUPPORT
        if (SOC_WARM_BOOT(unit)) {
            BCM_IF_ERROR_RETURN(
                bcm_esw_scache_ver_get(unit, BCM_MODULE_PORT, &scache_ver));
        }
        /* ASF WB */
        rv = _bcm_esw_asf_wb_memsz_get(unit, &asf_wbmem_sz, scache_ver);
        if (BCM_E_NONE == rv) {
            alloc_sz += asf_wbmem_sz;
        }

        /* Switch Latency Bypass WB */
        rv = bcmi_esw_switch_latency_wb_memsz_get(unit, &latency_wbmem_sz,
                                                  scache_ver);
        if (BCM_E_NONE == rv) {
            alloc_sz += latency_wbmem_sz;
        }
#endif /* BCM_TOMAHAWK_SUPPORT */

        /*IFG WB*/
        if (soc_feature(unit, soc_feature_xmac) ||
                soc_feature(unit, soc_feature_xlmac) ||
                soc_feature(unit, soc_feature_cmac) ||
                soc_feature(unit, soc_feature_clmac)) {
            PBMP_ITER(all_pbmp, port) {
                alloc_sz += sizeof(uint32);
            }
        }
        /* PORT DSCP MAP SETTING */
        if (soc_feature(unit, soc_feature_dscp) &&
            soc_feature(unit, soc_feature_egr_dscp_map_per_port)) {
            /* Allocate size for port dscp map setting status */
            PBMP_ITER(all_pbmp, port) {
                alloc_sz += sizeof(int);
            }
        }

#ifdef  BCM_TOMAHAWK_SUPPORT
        if (SOC_IS_TOMAHAWK(unit)) {
            /* Allocate size for port interface type */
            PBMP_ITER(all_pbmp, port) {
                alloc_sz += sizeof(int);
            }
        }
#endif /* BCM_TOMAHAWK_SUPPORT */

        if (soc_feature(unit, soc_feature_phy_interface_wb)) {
            /* Allocate size for port interface type */
            PBMP_ITER(PBMP_PORT_ALL(unit), port) {
                alloc_sz += sizeof(int);
            }
        }

        SOC_SCACHE_HANDLE_SET(scache_handle, unit, BCM_MODULE_PORT,
                              BCM_PORT_WB_SCACHE_PART_DEFAULT);
        rv = _bcm_esw_scache_ptr_get(unit, scache_handle, FALSE,
                                     alloc_sz, (uint8**)&port_state,
                                     BCM_PORT_WB_DEFAULT_VERSION, &recovered_ver);
        if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
            return rv;
        }
        if (BCM_SUCCESS(rv)) {
            _scache_port_print_ll_init(unit);

            rv = _bcm_esw_port_wb_recover_scache(unit, recovered_ver, port_state,
                    stable_size, asf_wbmem_sz, latency_wbmem_sz, oamp_status,
                    scache_handle, &use_pbmp, &port_bitmap, &dtm_pbmp, &all_pbmp);

            if (BCM_SUCCESS(rv) || rv == BCM_E_UNAVAIL) {
                _scache_port_print_all(unit);
            }
            _scache_port_print_clear_all(unit);

            if (BCM_FAILURE(rv) && rv != BCM_E_UNAVAIL) {
                return rv;
            }
        } else {
            /*
             * No level-2 cache configured. Proceed to Level-1 only recovery
             */
            BCM_PBMP_CLEAR(dtm_pbmp); /* Default is dtag_mode == NONE */
#if defined(BCM_TRIUMPH3_SUPPORT)
            if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
                bcm_port_t egr_port;
                int enabled = 0;

                PBMP_ITER(all_pbmp, port) {
                    SOC_IF_ERROR_RETURN
                        (bcm_esw_port_force_forward_get(unit, port,
                                                &egr_port, &enabled));
                    if (enabled) {
                        _bcm_port_force_forward_add(unit, port,
                                                egr_port);
                    }
                }
            }
#endif /* defined(BCM_TRIUMPH3_SUPPORT) */
        }

#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT) || \
    defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_TOMAHAWK(unit) || SOC_IS_TOMAHAWK2(unit) ||
            SOC_IS_TRIDENT3X(unit) || SOC_IS_KATANA2(unit)) {
            /* Recover port vlan action profile */
            rv = _bcm_th_port_vlan_action_profile_reinit(unit);
            if (BCM_FAILURE(rv)) {
                return rv;
            }
        }
#endif

        /* Recover DT mode */
        rv = _bcm_trx_port_dtag_mode_reinit(unit, dtm_pbmp, use_pbmp);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
#ifdef BCM_TRIUMPH2_SUPPORT
        if (soc_feature(unit, soc_feature_color_prio_map_profile)) {
            /* Recover ING_PRI_CNG_MAP references */
            port_tab_entry_t pent;
            int ptr;
            uint32 ipc_ref_bmp[3];
            /* Required: ING_PRI_CNG_MAP size <= 3 * 32 * 16 = 1536 */

            SHR_BITCLR_RANGE(ipc_ref_bmp, 0, 3*32);

            /* Read port pointer, recover reference count */
            PBMP_ITER(all_pbmp, port) {
#ifdef BCM_TRIDENT3_SUPPORT
                if (SOC_IS_TRIDENT3X(unit)) {
                    rv = _bcm_esw_port_tab_get(unit, port,
                                               TRUST_DOT1P_PTRf, &ptr);
                    if (BCM_FAILURE(rv)) {
                        break;
                    }
                    if (0 != ptr) {
                        rv = _bcm_ing_pri_cng_map_entry_reference(unit,
                                ptr * _BCM_TD3_PRI_CNG_MAP_SIZE,
                                _BCM_TD3_PRI_CNG_MAP_SIZE);
                        if (BCM_FAILURE(rv)) {
                            break;
                        }
                    }

                    /* Recover PROTOCOL_PKT_CONTROL &
                     * IGMP_MLD_PKT_CONTROL references */
                    if (SOC_REG_INFO(unit, PROTOCOL_PKT_CONTROLr).regtype ==
                        soc_portreg) {
                        /* Memory not allocated so no need to proceed */
                        continue;
                    }
                    rv = _bcm_esw_port_tab_get(unit, port,
                                               PROTOCOL_PKT_INDEXf, &ptr);
                    if (BCM_FAILURE(rv)) {
                        break;
                    }
                    if (0 != ptr) {
                        rv = _bcm_prot_pkt_ctrl_reference(unit, ptr);
                        if (BCM_FAILURE(rv)) {
                            break;
                        }
                        /* Remove default reference */
                        rv = _bcm_prot_pkt_ctrl_delete(unit, 0);
                        if (BCM_FAILURE(rv)) {
                            break;
                        }
                    }
                } else
#endif
                {
                rv = soc_mem_read(unit, PORT_TABm, MEM_BLOCK_ANY,
                                  SOC_PORT_MOD_OFFSET(unit, port), &pent);
                if (BCM_FAILURE(rv)) {
                    break;
                }
                if (soc_feature(unit, soc_feature_color)) {
                    ptr = soc_PORT_TABm_field32_get(unit, &pent,
                                                    TRUST_DOT1P_PTRf);
                    if (0 != ptr) {
                        rv = _bcm_ing_pri_cng_map_entry_reference(unit,
                                  ptr * _BCM_TR2_PRI_CNG_MAP_SIZE,
                                        _BCM_TR2_PRI_CNG_MAP_SIZE);
                        if (BCM_FAILURE(rv)) {
                            break;
                        }
                    }
                }

                /* Recover PROTOCOL_PKT_CONTROL &
                 * IGMP_MLD_PKT_CONTROL references */
                if (soc_mem_field_valid(unit, PORT_TABm,
                                        PROTOCOL_PKT_INDEXf)) {
                    if (SOC_REG_INFO(unit, PROTOCOL_PKT_CONTROLr).regtype ==
                        soc_portreg) {
                        /* ========================================== */
                        /* Memory not allocated so no need to proceed */
                        /* if (SOC_IS_HURRICANE(unit))                */
                        /* ========================================== */
                        continue;
                    }
                    ptr = soc_PORT_TABm_field32_get(unit, &pent,
                                                    PROTOCOL_PKT_INDEXf);
                    if (0 != ptr) {
                        rv = _bcm_prot_pkt_ctrl_reference(unit, ptr);
                        if (BCM_FAILURE(rv)) {
                            break;
                        }
                        /* Remove default reference */
                        rv = _bcm_prot_pkt_ctrl_delete(unit, 0);
                        if (BCM_FAILURE(rv)) {
                            break;
                        }
                    }
                }
            }
        }
        }
        if (BCM_FAILURE(rv)) {
            return rv;
        }
#endif /* BCM_TRIUMPH2_SUPPORT */
#ifdef BCM_TRIDENT2PLUS_SUPPORT
        if (soc_feature(unit, soc_feature_misc_i2e_hgclass_combo_profile)) {
            port_tab_entry_t pent;
            int ptr;
            PBMP_ITER(all_pbmp, port) {
                rv = soc_mem_read(unit, PORT_TABm, MEM_BLOCK_ANY,
                                  SOC_PORT_MOD_OFFSET(unit, port), &pent);
                if (BCM_FAILURE(rv)) {
                    break;
                }
                ptr = soc_PORT_TABm_field32_get(unit, &pent,
                                                     MISC_PORT_PROFILE_INDEXf);
                if (0 != ptr) {
                   rv  = _bcm_misc_port_profile_mem_reference(unit, ptr, 1);
                   if (BCM_FAILURE(rv)) {
                      break;
                   }
               }
           }
        }
        if (BCM_FAILURE(rv)) {
            return rv;
        }
#endif

        if (soc_feature(unit, soc_feature_e2ecc)) {
            rv = _bcm_esw_port_e2ecc_reinit(unit);
        }
        if (BCM_FAILURE(rv)) {
            return rv;
        }

#ifdef BCM_TRIUMPH2_SUPPORT
        /* Recover source modid egress blocking profiles */
        if (soc_feature(unit, soc_feature_src_modid_blk_profile)) {
            uint32 regval, srcmod_index;
            int i, modid_count;

            modid_count = SOC_MODID_MAX(unit) + 1;

            PBMP_ITER(all_pbmp, port) {
                BCM_IF_ERROR_RETURN
                    (READ_SRC_MODID_EGRESS_SELr(unit, port, &regval));
                if (soc_reg_field_get(unit,
                            SRC_MODID_EGRESS_SELr, regval, ENABLEf)) {
                    srcmod_index = soc_reg_field_get(unit,
                            SRC_MODID_EGRESS_SELr, regval, SRCMOD_INDEXf);
                    PORT_SRC_MOD_EGR_PROF_PTR(unit, port) = srcmod_index;
                    srcmod_index *= modid_count;
                    for (i = 0; i < modid_count; i++) {
                        SOC_PROFILE_MEM_REFERENCE(unit,
                                        PORT_SRC_MOD_EGR_PROFILE(unit),
                                                  srcmod_index + i, 1);
                        SOC_PROFILE_MEM_ENTRIES_PER_SET(unit,
                                        PORT_SRC_MOD_EGR_PROFILE(unit),
                                                        srcmod_index + i,
                                                        modid_count);
                    }
                }
            }
        }
#endif /* BCM_TRIUMPH2_SUPPORT */

#ifdef BCM_TRIUMPH2_SUPPORT
        if ((SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
             SOC_IS_VALKYRIE2(unit)) &&
            soc_feature(unit, soc_feature_flex_port)) {
            PBMP_ALL_ITER(unit, port) {
                if (_bcm_esw_valid_flex_port_controlling_port(unit, port)) {
                    BCM_IF_ERROR_RETURN(_bcm_tr2_flexport_recover(unit, port));
                }
            }
            /* Call PHY probe for config to take effect */
            if ((rv = bcm_esw_port_probe(unit, PBMP_PORT_ALL(unit),
                   &port_bitmap)) != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_PORT, \
                          (BSL_META_U(unit, \
                                      "Error unit %d:\
                                      Failed port probe: %s\n"),
                           unit, bcm_errmsg(rv)));
                return rv;
            }
        }
#endif /* BCM_TRIUMPH2_SUPPORT */

#if defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_pktpri_as_dot1p)) {
            /*
             * Recover the ref_cnt of enabling treat packet priority as
             * dot1p priority for different packet types or port controls,
             * if available.
             */
            rv = bcmi_esw_port_treat_pktpri_as_dot1p_reinit(unit);
            if (BCM_FAILURE(rv)) {
                return rv;
            }
        }
#endif /* BCM_GREYHOUND_SUPPORT */

        if (SOC_IS_HURRICANEX(unit) || SOC_IS_TRIUMPH2(unit) || \
                SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA(unit) || \
                SOC_IS_ENDURO(unit) || SOC_IS_GREYHOUND(unit) || \
                SOC_IS_VALKYRIE(unit) || SOC_IS_HURRICANE4(unit)) {
            bcm_esw_port_mdix_wb_update(unit);
        }
    }
#endif /* BCM_TRX_SUPPORT */
#if defined(BCM_RAVEN_SUPPORT)
    if (SOC_IS_RAVEN(unit)) {
        bcm_esw_port_mdix_wb_update(unit);
    }
#endif /* BCM_RAVEN_SUPPORT */
#ifdef BCM_PREEMPTION_SUPPORT
    if (soc_feature(unit, soc_feature_preemption)) {
        soc_scache_handle_t scache_handle;

        SOC_SCACHE_HANDLE_SET(scache_handle,
                              unit, BCM_MODULE_PORT,
                              BCM_PORT_WB_SCACHE_PART_PREMMPTION);
        rv = bcmi_esw_preemption_recover(unit, scache_handle);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
    }
#endif /* BCM_PREEMPTION_SUPPORT */

    return rv;
}
#else
#define _bcm_port_vd_pbvl_reinit(u)  (BCM_E_NONE)
#define _bcm_esw_port_wb_recover(u)  (BCM_E_NONE)
#define _bcm_esw_port_wb_alloc(u) (BCM_E_NONE)
#endif /* BCM_WARM_BOOT_SUPPORT */

#ifndef BCM_SW_STATE_DUMP_DISABLE
/*
 * Function:
 *     _bcm_esw_flexport_sw_dump
 * Purpose:
 *     Displays port information after flexport.
 * Parameters:
 *     unit - Device unit number
 * Returns:
 *     None
 * Note:
 */
void
_bcm_esw_flexport_sw_dump(int unit)
{
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        soc_flexport_sw_dump(unit);
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

#if defined(BCM_TOMAHAWK3_SUPPORT)
    if (SOC_IS_TOMAHAWK3(unit)) {
        soc_th3_flexport_sw_dump(unit);
    }
#endif /* BCM_TOMAHAWK3_SUPPORT */

#if defined(BCM_TOMAHAWK2_SUPPORT)
    if (SOC_IS_TOMAHAWK2(unit)) {
        soc_th2_flexport_sw_dump(unit);
    }
#endif /* BCM_TOMAHAWK2_SUPPORT */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (SOC_IS_TOMAHAWK(unit)) {
        soc_th_flexport_sw_dump(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

}

void
_bcm_esw_flexport_sw_pipe_speed_group_dump(
        int unit,
        int pipe,
        int speed_id)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (SOC_IS_TOMAHAWK(unit)) {
        soc_th_flexport_sw_pipe_speed_group_dump(
                unit, pipe, speed_id);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
}

#endif /* BCM_SW_STATE_DUMP_DISABLE */

static int
_bcm_esw_glp_bits_pos(int unit,
                      uint8 *trunk_pos, uint8 *max_modid,
                      uint8 *modid_pos, uint8 *max_port);

#if defined(BCM_FIREBOLT_SUPPORT)
/*
 * Function:
 *      _bcm_port_vd_pbvl_init
 * Purpose:
 *      Initialization of vd_pbvl bitmap in port
 * Parameters:
 *      unit - StrataSwitch unit number.
 * Returns:
 *      BCM_E_NONE - success (or already initialized)
 *      BCM_E_MEMORY - failed to allocate required memory.
 */

STATIC int
_bcm_port_vd_pbvl_init(int unit)
{
    bcm_port_t port;
    int idxmax;
    int inds_bytes;
    bcm_pbmp_t all_pbmp;

#if defined(BCM_TOMAHAWK3_SUPPORT)
    /* TH3 does not support VLAN Protocol feature. Return doing nothing */
    if (SOC_IS_TOMAHAWK3(unit)) {
        return BCM_E_NONE;
    }
#endif

    idxmax = soc_mem_index_count(unit, VLAN_PROTOCOLm);
    /* Round to the next entry */
    inds_bytes =
        (idxmax + (_BCM_PORT_VD_PBVL_ESIZE -  1)) / _BCM_PORT_VD_PBVL_ESIZE;

    BCM_PBMP_CLEAR(all_pbmp);
    BCM_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
    }
#endif

    PBMP_ITER(all_pbmp, port) {
        PORT(unit, port).p_vd_pbvl = sal_alloc(inds_bytes, "vdv_info");
        if (NULL == PORT(unit, port).p_vd_pbvl) {
            return (BCM_E_MEMORY);
        }

        sal_memset(PORT(unit, port).p_vd_pbvl, 0, inds_bytes);
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_port_vd_pbvl_reinit(unit));
    }
#endif

    return BCM_E_NONE;
}
#endif /* BCM_FIREBOLT_SUPPORT */

/*
 * Function:
 *      _bcm_esw_port_software_detach
 * Purpose:
 *      De-initialization of software for port subsystem.
 * Parameters:
 *      unit - StrataSwitch unit number.
 * Returns:
 *      BCM_E_NONE - success (or already initialized)
 *      BCM_E_INTERNAL- failed to write PTABLE entries
 *      BCM_E_MEMORY - failed to allocate required memory.
 */

int
_bcm_esw_port_software_detach(int unit)
{
    bcm_port_t          port;
    bcm_pbmp_t all_pbmp;

    BCM_PBMP_CLEAR(all_pbmp);
    BCM_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
    }
#endif

    if (bcm_port_info[unit] == NULL) {
         return (BCM_E_NONE);
    }

    PBMP_ITER(all_pbmp, port) {
        if (NULL != PORT(unit, port).p_vd_pbvl) {
            sal_free(PORT(unit, port).p_vd_pbvl);
            PORT(unit, port).p_vd_pbvl = NULL;
        }

        if (NULL != PORT(unit, port).e2ecc_config) {
            sal_free(PORT(unit, port).e2ecc_config);
            PORT(unit, port).e2ecc_config = NULL;
        }
    }

    SOC_IF_ERROR_RETURN(soc_phy_common_detach(unit));

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT) \
 || defined(BCM_RAVEN_SUPPORT)
    if (soc_feature(unit, soc_feature_vlan_ctrl)) {
        BCM_IF_ERROR_RETURN(_bcm_fb2_outer_tpid_detach(unit));
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT \
          || BCM_RAPTOR_SUPPORT */

#ifdef BCM_TRIUMPH2_SUPPORT
    if (NULL != PORT_SRC_MOD_EGR_PROFILE(unit)) {
        BCM_IF_ERROR_RETURN
            (soc_profile_mem_destroy(unit, PORT_SRC_MOD_EGR_PROFILE(unit)));
        sal_free(PORT_SRC_MOD_EGR_PROFILE(unit));
        PORT_SRC_MOD_EGR_PROFILE(unit) = NULL;
    }
#endif /* BCM_TRIUMPH2_SUPPORT */
#if defined(BCM_TRIDENT_SUPPORT)
    if (SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANAX(unit)) {
        BCM_IF_ERROR_RETURN(bcm_td_port_deinit(unit));
    }
#endif /* BCM_TRIDENT_SUPPORT */

    sal_free (bcm_port_info[unit]);
    bcm_port_info[unit] = NULL;

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_software_init
 * Purpose:
 *      Initialization of software for port subsystem.
 * Parameters:
 *      unit - StrataSwitch unit number.
 * Returns:
 *      BCM_E_NONE - success (or already initialized)
 *      BCM_E_INTERNAL- failed to write PTABLE entries
 *      BCM_E_MEMORY - failed to allocate required memory.
 */

STATIC int
_bcm_port_software_init(int unit)
{
    bcm_port_t  port = 0;
    int         max_num_port = 0;
    bcm_pbmp_t  all_pbmp;

    BCM_PBMP_CLEAR(all_pbmp);
    BCM_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));
    max_num_port = SOC_MAX_NUM_PORTS;

#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
        max_num_port = SOC_MAX_NUM_PP_PORTS;
    }
#endif

    if (bcm_port_info[unit] != NULL) {
        PBMP_ITER(all_pbmp, port) {
            if (PORT(unit, port).p_vd_pbvl != NULL) {
                sal_free(PORT(unit, port).p_vd_pbvl);
                PORT(unit, port).p_vd_pbvl = NULL;
            }

            if (PORT(unit, port).e2ecc_config != NULL) {
                sal_free(PORT(unit, port).e2ecc_config);
                PORT(unit, port).e2ecc_config = NULL;
            }

            PORT(unit, port).flags = 0;
#ifdef BCM_TRIDENT2_SUPPORT
            if (SOC_IS_TD2_TT2(unit)) {
                PORT(unit, port).enable = TRUE;
            }
#endif /* BCM_TRIDENT2_SUPPORT */
        }
    }

    if (bcm_port_info[unit] == NULL) {
        bcm_port_info[unit] = sal_alloc(sizeof(_bcm_port_info_t) * max_num_port,
                                        "bcm_port_info");
        if (bcm_port_info[unit] == NULL) {
            return BCM_E_MEMORY;
        }
    }
    sal_memset(bcm_port_info[unit], 0, sizeof(_bcm_port_info_t) * max_num_port);

    SOC_IF_ERROR_RETURN(soc_phy_common_init(unit));
#if defined(BCM_FIREBOLT_SUPPORT)
    if (SOC_IS_FBX(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_port_vd_pbvl_init(unit));
    }
#endif /* BCM_FIREBOLT_SUPPORT */

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT) \
 || defined(BCM_RAVEN_SUPPORT)
    if (SOC_WARM_BOOT(unit)) {
#ifdef BCM_TRIUMPH2_SUPPORT
        /* Moved to here for TD3 since the warm boot function call order changed */
        if (soc_feature(unit, soc_feature_lport_tab_profile)) {
            BCM_IF_ERROR_RETURN(bcm_esw_port_lport_profile_recover(unit));
        }
        if (soc_feature(unit, soc_feature_egr_lport_tab_profile)) {
            BCM_IF_ERROR_RETURN(bcm_esw_port_egr_lport_profile_recover(unit));
        }
#endif
    }

    if (soc_feature(unit, soc_feature_vlan_ctrl)) {
        BCM_IF_ERROR_RETURN(_bcm_fb2_outer_tpid_init(unit));
    }
    if (soc_feature(unit, soc_feature_color_prio_map)) {
        BCM_IF_ERROR_RETURN(_bcm_fb2_priority_map_init(unit));
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT \
          || BCM_RAPTOR_SUPPORT */

#if defined(BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit)) {
        for (port = 0; port < max_num_port; port++) {
            PORT(unit, port).dtag_mode = BCM_PORT_DTAG_MODE_NONE;
        }
    }
#endif

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit) || SOC_FAST_REBOOT(unit)) {
#if defined(BCM_XGS_SWITCH_SUPPORT)
        if (soc_feature(unit, soc_feature_remap_ut_prio)) {
            bcm_port_cfg_t pcfg;
            PBMP_ITER(all_pbmp, port) {
                SOC_IF_ERROR_RETURN
                    (mbcm_driver[unit]->mbcm_port_cfg_get(unit, port,
                                                          &pcfg));
                PORT(unit, port).p_ut_prio = pcfg.pc_new_opri;
            }
        }
#ifdef BCM_TRIDENT2_SUPPORT
        if (SOC_IS_TD2_TT2(unit)) {
            PBMP_ITER(all_pbmp, port) {
                PORT(unit, port).enable = TRUE;
            }
        }
#endif /* BCM_TRIDENT2_SUPPORT */
#endif /* BCM_XGS_SWITCH_SUPPORT */
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit)) {
            PBMP_ITER(all_pbmp, port) {
                /* Recover port's dtag_mode */
                PORT(unit, port).dtag_mode = BCM_PORT_DTAG_MODE_NONE;
            }
        }
#endif /* BCM_TRX_SUPPORT */
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_settings_init
 * Purpose:
 *      Initialize port settings if they are to be different from the
 *      default ones
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      port - port number
 * Returns:
 *      BCM_E_NONE - success (or already initialized)
 *      BCM_E_INTERNAL- failed to write PTABLE entries
 * Notes:
 *      This function initializes port settings based on the folowing config
 *      variables:
 *           port_init_speed
 *           port_init_duplex
 *           port_init_adv
 *           port_init_autoneg
 *      If a variable is not set, then no additional initialization of the
 *      corresponding parameter is done (and the defaults will normally be
 *      advertize everything you can do and use autonegotiation).
 *
 *      A typical use would be to set:
 *          port_init_adv=0
 *          port_init_autoneg=1
 *      to force link down in the beginning.
 *
 *      Another setup that makes sense is something like:
 *          port_init_speed=10
 *          port_init_duplex=0
 *          port_init_autoneg=0
 *      in order to force link into a certain mode. (It is very important to
 *      disable autonegotiation in this case).
 *
 *      PLEASE NOTE:
 *          The standard rc.soc forces autoneg=on on all the ethernet ports
 *          (FE and GE). Thus, to use the second example one has to edit rc.soc
 *          as well.
 *
 *     This function has been declared as global, but not exported. This will
 *     make port initialization easier when using VxWorks shell.
 */
int
bcm_port_settings_init(int unit, bcm_port_t port)
{
    int             val;
    bcm_port_info_t info;

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_settings_init: u=%d p=%d\n"),unit, port));

    bcm_port_info_t_init(&info);

    val = soc_property_port_get(unit, port, spn_PORT_INIT_SPEED, -1);
    if (val != -1) {
        info.speed = val;
        info.action_mask |= BCM_PORT_ATTR_SPEED_MASK;
    }

    val = soc_property_port_get(unit, port, spn_PORT_INIT_DUPLEX, -1);
    if (val != -1) {
        info.duplex = val;
        info.action_mask |= BCM_PORT_ATTR_DUPLEX_MASK;
    }

    val = soc_property_port_get(unit, port, spn_PORT_INIT_ADV, -1);
    if (val != -1) {
        info.local_advert = val;
        info.action_mask |= BCM_PORT_ATTR_LOCAL_ADVERT_MASK;
    }

    val = soc_property_port_get(unit, port, spn_PORT_INIT_AUTONEG, -1);
    if (val != -1) {
        info.autoneg = val;
        info.action_mask |= BCM_PORT_ATTR_AUTONEG_MASK;
    }
    return bcm_esw_port_selective_set(unit, port, &info);
}

#ifdef BCM_TRIUMPH2_SUPPORT
/* Helper function to program logical to physical (and reverse) port mapping */
STATIC int
_bcm_port_remap_set(int unit, bcm_port_t phys, bcm_port_t logical)
{
    port_tab_entry_t ptab;
    sys_portmap_entry_t sys_portmap;
    uint32 regval;

    SOC_IF_ERROR_RETURN(soc_mem_read(unit, PORT_TABm,
                                     MEM_BLOCK_ANY, phys, &ptab));
    soc_PORT_TABm_field32_set(unit, &ptab, SRC_SYS_PORT_IDf, logical);
    SOC_IF_ERROR_RETURN(soc_mem_write(unit, PORT_TABm,
                                      MEM_BLOCK_ALL, phys, &ptab));

    SOC_IF_ERROR_RETURN(soc_mem_read(unit, SYS_PORTMAPm,
                                     MEM_BLOCK_ANY, logical, &sys_portmap));
    soc_SYS_PORTMAPm_field32_set(unit, &sys_portmap, PHYS_PORT_IDf, phys);
    SOC_IF_ERROR_RETURN(soc_mem_write(unit, SYS_PORTMAPm,
                                      MEM_BLOCK_ALL, logical, &sys_portmap));

    /* Configure E2ECC port mapping register */
    SOC_IF_ERROR_RETURN(READ_E2ECC_PORT_MAPPINGr(unit, phys, &regval));
    soc_reg_field_set(unit, E2ECC_PORT_MAPPINGr, &regval, MAPPED_PORT_NUMf, logical);
    SOC_IF_ERROR_RETURN(WRITE_E2ECC_PORT_MAPPINGr(unit, phys, regval));

    return BCM_E_NONE;
}

STATIC int
_bcm_tr2_system_tpid_init(int unit)
{
    int tpid_index, sys_index, rv = BCM_E_NONE;
    bcm_module_t module;
    bcm_port_t port;
    system_config_table_entry_t systab;
    uint32 tpid_enable;
    uint16 tpid;

    tpid = _bcm_fb2_outer_tpid_default_get(unit);
    BCM_IF_ERROR_RETURN(_bcm_fb2_outer_tpid_lkup(unit, tpid, &tpid_index));

    for (module = 0; module <= SOC_MODID_MAX(unit); module++) {
        for (port = 0; port < 64; port++) {
            sys_index = module * 64 + port;
            rv = READ_SYSTEM_CONFIG_TABLEm(unit, MEM_BLOCK_ANY,
                                           sys_index, &systab);
            BCM_IF_ERROR_RETURN(rv);
            tpid_enable = (1 << tpid_index);
            soc_SYSTEM_CONFIG_TABLEm_field32_set(unit, &systab,
                                                 OUTER_TPID_ENABLEf,
                                                 tpid_enable);
            rv = WRITE_SYSTEM_CONFIG_TABLEm(unit, MEM_BLOCK_ALL,
                                            sys_index, &systab);
            BCM_IF_ERROR_RETURN(rv);
        }
    }
    return rv;
}
#endif

/*
 * Function:
 *      _bcm_esw_port_deinit
 * Purpose:
 *      De-initialize the PORT interface layer for the specified SOC device.
 * Parameters:
 *      unit - StrataSwitch unit number.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_esw_port_deinit(int unit)
{
    int  rv;

    if (NULL == bcm_port_info[unit]) {
        return (BCM_E_NONE);
    }

    rv = _bcm_esw_port_software_detach(unit);
    BCM_IF_ERROR_RETURN(rv);

#ifdef BCM_TRX_SUPPORT
    if (soc_feature(unit, soc_feature_vlan_action) ||
        soc_feature(unit,soc_feature_egr_vlan_action)) {
#ifdef BCM_TRIUMPH2_SUPPORT
        if (soc_feature(unit, soc_feature_vpd_profile)) {
            _bcm_tr2_port_vpd_bitmap_free(unit);
        }
#endif /* BCM_TRIUMPH2_SUPPORT */

        /* Initialize the vlan action profile table */
#if defined(BCM_TOMAHAWK3_SUPPORT)
        if (SOC_IS_TOMAHAWK3(unit)) {
            rv = _bcm_th3_vlan_action_profile_detach(unit);
        } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
        {
            rv = _bcm_trx_vlan_action_profile_detach(unit);
        }
        BCM_IF_ERROR_RETURN(rv);
    }
#endif /* BCM_TRX_SUPPORT */

#ifdef BCM_TRIUMPH2_SUPPORT
    if (soc_feature(unit, soc_feature_gport_service_counters)) {
        rv = _bcm_esw_flex_stat_detach(unit, _bcmFlexStatTypeGport);
        BCM_IF_ERROR_RETURN(rv);
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT) || \
    defined(BCM_TIMESYNC_V3_SUPPORT) || defined(BCM_SABER2_SUPPORT)
    if ((soc_feature(unit, soc_feature_timesync_v3) || SOC_IS_TRIUMPH3(unit) ||
         SOC_IS_KATANAX(unit)|| SOC_IS_TD2_TT2(unit) || SOC_IS_SABER2(unit) ||
         SOC_IS_APACHE(unit)) &&
        (soc_feature(unit,soc_feature_timesync_support))) {
        _bcm_esw_port_timesync_profile_delete(unit);
    }
#endif /* defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT) ||
          defined(BCM_TIMESYNC_V3_SUPPORT) || defined(BCM_SABER2_SUPPORT) */

#if defined(BCM_TRIUMPH3_SUPPORT)
    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
        rv = _bcm_port_force_forward_deinit(unit);
        if(BCM_FAILURE(rv)) {
            return rv;
        }
    }
#endif /*defined(BCM_TRIUMPH3_SUPPORT)*/
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_asf_multimode)) {
        /* deinit ASF (cutthrough) subsystem */
        BCM_IF_ERROR_RETURN(_bcm_esw_asf_deinit(unit));
    }
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        _bcm_esw_ibod_sync_recovery_stop(unit);
    }
#endif
#ifdef BCM_PREEMPTION_SUPPORT
    if (soc_feature(unit, soc_feature_preemption)) {
        bcmi_esw_preemption_cleanup(unit);
    }
    if (soc_feature(unit, soc_feature_preemption_cnt)) {
        bcmi_esw_preemption_counter_cleanup(unit);
    }
#endif /* BCM_PREEMPTION_SUPPORT */
#if defined(BCM_GREYHOUND_SUPPORT)
    if (soc_feature(unit, soc_feature_pktpri_as_dot1p)) {
        BCM_IF_ERROR_RETURN(
            bcmi_esw_port_treat_pktpri_as_dot1p_cleanup(unit));
    }
#endif /* BCM_GREYHOUND_SUPPORT */

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_port_portmod_thread_stop
 * Purpose:
 *      Stop the portmod thread.
 * Parameters:
 *      unit - StrataSwitch unit number.
 * Returns:
 *      BCM_E_XXX
 */
int _bcm_esw_port_portmod_thread_stop(int unit)
{
    int  rv = BCM_E_NONE;
    rv =  bcmi_esw_portctrl_portmod_thread_stop(unit);
    return rv;
}

#ifdef BCM_TRIDENT_SUPPORT
#ifdef BCM_WARM_BOOT_SUPPORT
/*
 * Function:
 *      _bcm_td_phymode_reconfigure
 * Purpose:
 *      Reconfigure the mode of the phys during warmboot.
 *      This function has code copied from _soc_trident_misc_init
 *      to keep the phy modes consistent in cold and warmboot modes.
 *      This is required to be called before the phy probe routines
 *      in order for the mode to be configured correctly.
 * Parameters:
 *      unit - StrataSwitch unit number.
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_td_phymode_reconfigure(int unit) {

    soc_info_t *si = &SOC_INFO(unit);
    int port, blk, blk_port, num_lanes, phy_port, bindex;

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        blk_port = SOC_BLOCK_PORT(unit, blk);
        if (blk_port < 0) {
            continue;
        }
        /*
         * Program XLPORT mode and default Warpcore lanes setting
         * core_mode: the number of ports on the system side of XMAC
         * phy_mode: the number of ports on the Warpcore side of XMAC
         * num_lanes: the number of lanes on the line side of Warpcore
         */
        if (si->port_speed_max[blk_port] > 20000) {
            num_lanes = 4;
        } else if (si->port_speed_max[blk_port] > 10000) {
            if (si->port_speed_max[blk_port] == 20000 &&
                si->port_num_lanes[blk_port] == 4) {
                num_lanes = 4;
            } else {
                num_lanes = 2;
            }
        } else {
            num_lanes = 1;
        }

        phy_port = ((si->port_l2p_mapping[blk_port] - 1) & ~0x3) + 1;
        for (bindex = 0; bindex < 4; bindex++) {
            port = si->port_p2l_mapping[phy_port + bindex];
            if (port == -1) {
                continue;
            }
            si->port_num_lanes[port] = num_lanes;
        }
    }
    return BCM_E_NONE;
}
#endif /* BCM_WARM_BOOT_SUPPORT */
#endif /* BCM_TRIDENT_SUPPORT */

#ifdef BCM_WARM_BOOT_SUPPORT
#ifdef BCM_TRIUMPH3_SUPPORT
STATIC int _bcm_tr3_flexport_wb_recover(int unit)
{
    int rv = BCM_E_NONE;
    int alloc_sz = 0;
    uint8 *port_state;
    uint16 recovered_ver;
    bcm_port_t port;
    int stable_size;
    soc_scache_handle_t scache_handle;
    soc_info_t *si = &SOC_INFO(unit);
    int _port_lanes_valid = 0;
    int _port_num_lanes[SOC_MAX_NUM_PORTS] = {0};
    bcm_pbmp_t all_pbmp;

    BCM_PBMP_CLEAR(all_pbmp);
    BCM_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

    /* Calculate the offset of port_num_lanes */
    SOC_IF_ERROR_RETURN(soc_stable_size_get(unit, &stable_size));
    PBMP_ITER(all_pbmp, port) {
        alloc_sz += sizeof(int); /* vp count */
    }
    alloc_sz += sizeof(bcm_pbmp_t); /* Bitmap of dtag_mode == NONE */
    PBMP_ITER(all_pbmp, port) {
        if (!SOC_WARM_BOOT_SCACHE_IS_LIMITED(unit) && (stable_size > 0)) {
            if (SOC_REG_IS_VALID(unit, COSMASKr)) {
                alloc_sz += sizeof(uint32);
            } else {
                alloc_sz += sizeof(_bcm_port_metering_info_t);
            }
            alloc_sz += sizeof(uint8); /* flags */
        }
    }
    alloc_sz += (SOC_MAX_NUM_PORTS * sizeof(int)); /* num lanes of port */

    /* Get port_num_lanes from scahe */
    SOC_SCACHE_HANDLE_SET(scache_handle, unit, BCM_MODULE_PORT,
                          BCM_PORT_WB_SCACHE_PART_DEFAULT);
    rv = _bcm_esw_scache_ptr_get(unit, scache_handle, FALSE,
                                 alloc_sz, (uint8**)&port_state,
                                 BCM_PORT_WB_DEFAULT_VERSION, &recovered_ver);
    if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
        return rv;
    }

    port_state += (alloc_sz - (SOC_MAX_NUM_PORTS * sizeof(int)));
    if (recovered_ver >= BCM_PORT_WB_VERSION_1_1) {
        PBMP_ALL_ITER(unit, port) {
            sal_memcpy(&_port_num_lanes[port], port_state,
                       sizeof(int));
            port_state += sizeof(int);
            _port_lanes_valid++;
        }
    }

    /* Recover port_num_lanes */
    if (_port_lanes_valid) {
         PBMP_ALL_ITER(unit, port) {
             if (soc_tr3_port_is_flex_port(unit, port) &&
                 (si->port_num_lanes[port] != _port_num_lanes[port])) {
                 LOG_VERBOSE(BSL_LS_BCM_PORT,
                             (BSL_META_U(unit,
                                         "Port %d needs flex transform !!\n"),
                              port));
                 if ((rv = _bcm_tr3_port_lanes_set(unit, port,
                               _port_num_lanes[port])) != BCM_E_NONE) {
                     LOG_ERROR(BSL_LS_BCM_PORT, \
                               (BSL_META_U(unit, \
                                           "Error unit %d: "\
                                           "Failed port lanes set: %s\n"),
                                unit, bcm_errmsg(rv)));
                     return rv;
                 }
             }
         }
         (void)soc_port_type_verify(unit);
    }

    return rv;
}

STATIC void
_bcm_tr3_port_info_reconfig(int unit)
{
    soc_port_t port;

    PBMP_ALL_ITER(unit, port) {
        if (IS_AXP_PORT(unit, port)) {
            /* Physical port table index doesn't exist for AXP ports */
            continue;
        }
        /* cache num of port lanes */
        (void)soc_tr3_port_lanes_gen(unit, port, &SOC_INFO(unit).port_num_lanes[port], NULL);
    }

    if (soc_feature(unit, soc_feature_flex_port)) {
        _bcm_tr3_flexport_wb_recover(unit);
    }
}
#endif /* BCM_TRIUMPH3_SUPPORT */
#endif /* BCM_WARM_BOOT_SUPPORT */

#ifdef BCM_HIGIG2_SUPPORT
/*
 * Function:
 *      _bcm_esw_port_higig2_mode_set
 * Purpose:
 *      Set port Higig2 mode
 * Parameters:
 *      unit - StrataSwitch unit #
 *      port - StrataSwitch port #
 *      higig2_mode - Higig2 mode
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_esw_port_higig2_mode_set(int unit, bcm_port_t port, int higig2_mode)
{
    soc_reg_t egr_port_reg;
    soc_mem_t egr_port_mem;

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_higig2_mode_set(unit, port, higig2_mode);
    }

    if (!SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_tab_set(unit, port,
                            _BCM_CPU_TABS_NONE, HIGIG2f, higig2_mode));
    }
    egr_port_reg = (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
            SOC_IS_VALKYRIE2(unit) || SOC_IS_GREYHOUND(unit) ||
            SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) ?
            EGR_PORT_64r : EGR_PORTr;
    if (SOC_REG_FIELD_VALID(unit, egr_port_reg, HIGIG2f)) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit, egr_port_reg, port,
                    HIGIG2f, higig2_mode));
    } else if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, HIGIG2f)) {
        BCM_IF_ERROR_RETURN(soc_mem_field32_modify(unit, EGR_PORTm, port,
                    HIGIG2f, higig2_mode));
    }

#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        /* For Saber2, configure IECELL along with XLPORT */
        if (SOC_REG_PORT_VALID(unit, IECELL_CONFIGr, port)) {
            BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                        IECELL_CONFIGr, port, HIGIG2_MODEf, higig2_mode));

        }
    }
#endif

    if (IS_CL_PORT(unit, port) &&
            SOC_REG_FIELD_VALID(unit, CLPORT_CONFIGr, HIGIG2_MODEf)) {
        uint32 clp_hg2_mode = higig2_mode;

#ifdef BCM_GREYHOUND2_SUPPORT
        if (SOC_IS_GREYHOUND2(unit)) {
            /* GH2 for CL port has PGW interface config for HG2/HG2-Lite */
#ifdef BCM_FIRELIGHT_SUPPORT
            if (soc_feature(unit, soc_feature_fl)) {
                BCM_IF_ERROR_RETURN(soc_firelight_pgw_encap_field_modify(
                    unit, port, HIGIG2_MODEf, higig2_mode));
            } else
#endif /* BCM_FIRELIGHT_SUPPORT */
            {
                BCM_IF_ERROR_RETURN(soc_greyhound2_pgw_encap_field_modify(
                    unit, port, HIGIG2_MODEf, higig2_mode));
            }

            /* GH2 sepcial design to set CLPORT_CONFIGr as IEEE encap mode for
             * HG2-Lite. Thus the CLPORT_CONFIGr.HIGIG2_MODEf must be 0 here.
             */
            if (IS_HL_PORT(unit, port)) {
                clp_hg2_mode = 0;
            }
        }
#endif  /* GREYHOUND2 */

        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit, CLPORT_CONFIGr, port,
                            HIGIG2_MODEf, clp_hg2_mode));
    } else if (IS_C_PORT(unit, port) &&
        SOC_REG_FIELD_VALID(unit, CPORT_CONFIGr, HIGIG2_MODEf)) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit, CPORT_CONFIGr, port,
                HIGIG2_MODEf, higig2_mode));
    } else if (SOC_REG_FIELD_VALID(unit, XLPORT_CONFIGr, HIGIG2_MODEf)) {
        uint32 xlp_hg2_mode = higig2_mode;

#ifdef BCM_GREYHOUND_SUPPORT
        if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
            SOC_IS_GREYHOUND2(unit)){
            BCM_IF_ERROR_RETURN(soc_greyhound_pgw_encap_field_modify(unit,
                port, HIGIG2_MODEf, higig2_mode));

            /* GH sepcial design to set XLPORT_CONFIGr as IEEE encap mode for
             * HG2-Lite. Thus the XLPORT_CONFIGr.HIGIG2_MODEf must be 0 here.
             */
            if (IS_HL_PORT(unit, port)) {
                xlp_hg2_mode = 0;
            }
        }
#endif /* BCM_GREYHOUND_SUPPORT */

        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit, XLPORT_CONFIGr, port,
                HIGIG2_MODEf, xlp_hg2_mode));
    } else if (SOC_REG_FIELD_VALID(unit, XPORT_CONFIGr, HIGIG2_MODEf)) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit, XPORT_CONFIGr, port,
                HIGIG2_MODEf, higig2_mode));
    } else if (SOC_REG_FIELD_VALID(unit, PORT_CONFIGr, HIGIG2_MODEf)) {
        BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit, PORT_CONFIGr, port,
                HIGIG2_MODEf, higig2_mode));
    }
    if (soc_feature(unit, soc_feature_wh2)) {
        SOC_IF_ERROR_RETURN(
            soc_reg_field32_modify(unit, PGW_GE_CONFIGr, port,
                                   HIGIG2_MODEf, higig2_mode));
    }

    egr_port_mem = SOC_IS_KATANA2(unit) ? EGR_PHYSICAL_PORTm : EGR_ING_PORTm;
    if (SOC_MEM_FIELD_VALID(unit, egr_port_mem, HIGIG2f)) {
        if (IS_CPU_PORT(unit, port)) {
            BCM_IF_ERROR_RETURN(soc_mem_field32_modify(unit, egr_port_mem,
                        SOC_INFO(unit).cpu_hg_index, HIGIG2f, higig2_mode));
        } else {
            BCM_IF_ERROR_RETURN(soc_mem_field32_modify(unit, egr_port_mem,
                        port, HIGIG2f, higig2_mode));
        }
    }

    return BCM_E_NONE;
}
#endif /* BCM_HIGIG2_SUPPORT */

#ifdef BCM_TRIUMPH3_SUPPORT
/*
 * Function:
 *      _bcm_esw_tr3_port_lanes_init
 * Purpose:
 *      Initialize port lanes settings for 40g port of
 *      Triumph3(56541,56542, 56545 and 56546)
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      port - port number
 * Returns:
 *      BCM_E_NONE - success (or already initialized)
 *      BCM_E_INTERNAL- failed to set lane mode
 * Notes:
 *      This function initializes port lanes settings based on the following config
 *      variables:
 *           port_max_speed
 *      If a variable is not set, then no additional initialization of the
 *      parameter is done.
 *
 *      If user want to use 100Mbps on WC ports(xe4,xe5), configuration
 *      must be setted as below:
 *          port_max_speed=100
 */
int
_bcm_esw_tr3_port_lanes_init(int unit)
{
    int rv;
    int max_speed;
    int old_lanes = 0, new_lanes = -1;
    int enable;
    bcm_port_t port;
    PBMP_PORT_ITER(unit, port) {
        if (port != 54 && port != 55) {
            continue;
        }
        if (soc_property_port_get(unit, port, spn_PORT_MAX_SPEED, 0)) {
            max_speed = soc_property_port_get(unit, port, spn_PORT_MAX_SPEED, 0);
            if ((max_speed == 100) || (max_speed == 1000)) {
                new_lanes = 1;
            } else if ((max_speed != 100) && (max_speed != 1000)) {
                new_lanes = 4;
            }
            BCM_IF_ERROR_RETURN(_bcm_tr3_port_lanes_get(unit, port, &old_lanes));
            if (new_lanes > 0 && old_lanes != new_lanes) {
                /* Cache original configurations */
                BCM_IF_ERROR_RETURN(bcm_esw_port_enable_get(unit, port, &enable));
                COUNTER_LOCK(unit);
                rv = _bcm_tr3_port_lanes_set(unit, port, new_lanes);
                COUNTER_UNLOCK(unit);
                BCM_IF_ERROR_RETURN(rv);
                bcm_port_settings_init(unit, port);
                BCM_IF_ERROR_RETURN(bcm_esw_port_enable_set(unit, port, enable));
            }
        }
    }
    return BCM_E_NONE;
}
#endif

#if defined(BCM_TRIDENT3_SUPPORT) && defined(CANCUN_SUPPORT)
/*
 * Function:
 *      _bcm_esw_td3_port_cmh_ctrl_set
 * Description:
 *      Configure CANCUN redefined port control.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      type - Enum value of the feature
 *      value - value to be set
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_UNAVAIL - Functionality not available
 */
int
_bcm_esw_td3_port_cmh_ctrl_set(int unit, bcm_port_t port,
                         bcm_port_control_t type, int value)
{
    int rv = BCM_E_NONE;
    uint32 entry[SOC_MAX_MEM_WORDS];
    bcm_module_t my_modid = 0, modid_out;
    bcm_port_t port_out;
    bcm_trunk_t trunk_out;
    int    src_trk_idx = 0, id_out;
    soc_mem_t mem = SOURCE_TRUNK_MAP_TABLEm;

    if (BCM_GPORT_IS_SET(port)) {
        BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                                 &modid_out, &port_out, &trunk_out, &id_out));
    } else {
        port_out = port;
    }

    if (!soc_cancun_cmh_check(unit, LPORT_TABm, VXLAN_SVP_ASSIGNMENT_KEY_TYPEf)) {
        return rv;
    }

    BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, &my_modid));
    BCM_IF_ERROR_RETURN(_bcm_esw_src_mod_port_table_index_get(unit, my_modid,
                            port_out, &src_trk_idx));

    mem = SOURCE_TRUNK_MAP_TABLEm;
    sal_memset(entry, 0, sizeof(entry));
    soc_mem_lock(unit, mem);
    rv = soc_mem_read(unit, mem, MEM_BLOCK_ANY, src_trk_idx, entry);
    if (SOC_SUCCESS(rv)) {
        soc_mem_field32_set(unit, mem, entry, CTRL_PROFILE_IDX_0f,
                             value? 0x1: 0x0);
        rv = soc_mem_write(unit, mem, MEM_BLOCK_ANY, src_trk_idx, entry);
    }
    soc_mem_unlock(unit, mem);

    return rv;
}

#endif

/*
 * Function:
 *      bcm_port_init
 * Purpose:
 *      Initialize the PORT interface layer for the specified SOC device.
 * Parameters:
 *      unit - StrataSwitch unit number.
 * Returns:
 *      BCM_E_NONE - success (or already initialized)
 *      BCM_E_INTERNAL- failed to write PTABLE entries
 *      BCM_E_MEMORY - failed to allocate required memory.
 * Notes:
 *      By default ports come up enabled. They can be made to come up disabled
 *      at startup by a compile-time application policy flag in your Make.local
 *      PTABLE initialized.
 */
int
bcm_esw_port_init(int unit)
{
    int                 rv, port_enable, length_check;
    bcm_port_t          p;
    int                 p_speed;
    pbmp_t              okay_ports;
    bcm_vlan_data_t     vd;
    char                pfmtok[SOC_PBMP_FMT_LEN],
                        pfmtall[SOC_PBMP_FMT_LEN];
    bcm_pbmp_t          all_pbmp;
#ifdef BCM_TRX_SUPPORT
    bcm_pbmp_t          hg_pbmp;
#endif /* BCM_TRX_SUPPORT */
#if defined(BCM_KATANA2_SUPPORT)
    uint32 entry[SOC_MAX_MEM_WORDS];
#endif /* BCM_KATANA_SUPPORT */
    uint32              rx_los;
#ifdef BCM_TRIDENT2_SUPPORT
    int                 enable;
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    int index;
    mmu_intfi_st_trans_tbl_entry_t st_trans_entry;
#endif
#if defined(BCM_FIREBOLT6_SUPPORT)
    egr_port_min_pkt_size_entry_t egr_port_mem_pkt_size_ent;
#endif

    int port_iter;
#ifdef BCM_METROLITE_SUPPORT
    uint16 dev_id=0;
    uint8  rev_id=0;
    bcm_pbmp_t          non_sat_port_pbmp;
    soc_cm_get_id(unit, &dev_id, &rev_id);
#endif

    LOG_VERBOSE(BSL_LS_BCM_PORT,
                (BSL_META_U(unit,
                            "bcm_port_init: unit %d\n"), unit));
    assert(unit < BCM_MAX_NUM_UNITS);
    if ((rv = _bcm_port_software_init(unit)) != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit,
                              "Error unit %d:  Failed software port init: %s\n"),
                   unit, bcm_errmsg(rv)));
        return rv;
    }
    if (SAL_BOOT_SIMULATION &&
        soc_property_get(unit, "skip_port_hw_init", 0)) {
        return BCM_E_NONE;
    }

    /* Initialize Port Function driver */
    BCM_ESW_PORT_DRV(unit) = NULL;

#ifdef BCM_XGS5_SWITCH_PORT_SUPPORT
#if defined(BCM_KATANA2_SUPPORT)
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN(bcmi_katana2_port_fn_drv_init(unit));
    } else
#endif
#if defined(BCM_MONTEREY_SUPPORT)
    if (SOC_IS_MONTEREY(unit)) {
        BCM_IF_ERROR_RETURN(bcmi_monterey_port_fn_drv_init(unit));
    } else
#endif
#if defined(BCM_APACHE_SUPPORT)
    if (SOC_IS_APACHE(unit)) {
        BCM_IF_ERROR_RETURN(bcmi_apache_port_fn_drv_init(unit));
    } else
#endif
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (SOC_IS_TD2P_TT2P(unit)) {
        BCM_IF_ERROR_RETURN(bcmi_td2p_port_fn_drv_init(unit));
    } else
#endif
#ifdef BCM_TRIDENT3_SUPPORT
    if (SOC_IS_TRIDENT3(unit)) {
        BCM_IF_ERROR_RETURN(bcmi_td3_port_fn_drv_init(unit));
    } else
#endif
#ifdef BCM_HURRICANE4_SUPPORT
    if (SOC_IS_HURRICANE4(unit)) {
        BCM_IF_ERROR_RETURN(bcmi_hr4_port_fn_drv_init(unit));
    } else
#endif
#ifdef BCM_HELIX5_SUPPORT
    if (SOC_IS_HELIX5(unit)) {
        BCM_IF_ERROR_RETURN(bcmi_hx5_port_fn_drv_init(unit));
    } else
#endif
#ifdef BCM_MAVERICK2_SUPPORT
    if (SOC_IS_MAVERICK2(unit)) {
        BCM_IF_ERROR_RETURN(bcmi_mv2_port_fn_drv_init(unit));
    } else
#endif
#ifdef BCM_TOMAHAWK2_SUPPORT
    if (SOC_IS_TOMAHAWK2(unit)) {
        BCM_IF_ERROR_RETURN(bcmi_th2_port_fn_drv_init(unit));
    } else
#endif
#ifdef BCM_TOMAHAWK3_SUPPORT
    if (SOC_IS_TOMAHAWK3(unit)) {
        BCM_IF_ERROR_RETURN(bcmi_th3_port_fn_drv_init(unit));
    } else
#endif
#ifdef BCM_HURRICANE4_SUPPORT
    if (SOC_IS_HURRICANE4(unit)) {
        BCM_IF_ERROR_RETURN(bcmi_hr4_port_fn_drv_init(unit));
    } else
#endif
#ifdef BCM_FIREBOLT6_SUPPORT
    if (SOC_IS_FIREBOLT6(unit)) {
        BCM_IF_ERROR_RETURN(bcmi_fb6_port_fn_drv_init(unit));
    } else
#endif
    {
    }
#endif /* BCM_XGS5_SWITCH_PORT_SUPPORT */

    SOC_PBMP_CLEAR(all_pbmp);

#ifdef BCM_TRX_SUPPORT
    SOC_PBMP_CLEAR(hg_pbmp);

    if (soc_feature(unit, soc_feature_vlan_action) ||
        soc_feature(unit, soc_feature_egr_vlan_action)) {
        bcm_vlan_action_set_t action;

        bcm_vlan_action_set_t_init(&action);

#ifdef BCM_TRIUMPH2_SUPPORT
        if (soc_feature(unit, soc_feature_vpd_profile)) {
            BCM_IF_ERROR_RETURN(_bcm_tr2_port_vpd_bitmap_alloc(unit));
        }
#endif

        BCM_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

#ifdef BCM_KATANA2_SUPPORT
        if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
            /* The HW defaults for EGR_VLAN_CONTROL_1.VT_MISS_UNTAG == 1, which
             * causes the outer tag to be removed from packets that don't have
             * a hit in the egress vlan tranlation table. Set to 0 to disable this.
             */
            uint32 rval = 0;
            soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, VT_MISS_UNTAGf, 0);
            soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, REMARK_OUTER_DOT1Pf,1);

            BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
            PBMP_ITER(all_pbmp, p) {
               BCM_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, p, rval));
            }
        }

		if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);


        }
#endif

#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
        if ((SOC_IS_KATANA2(unit) || SOC_IS_TOMAHAWKX(unit)
             || SOC_IS_TRIDENT3X(unit)) &&
                (SOC_MEM_IS_VALID(unit, VLAN_PROTOCOL_DATAm) &&
                 soc_mem_index_max(unit, VLAN_PROTOCOL_DATAm) > 0)) {
            vlan_protocol_data_entry_t vlan_protocol_data_entries[16];
            uint32 vlan_protocol_data_index =0;
            void *entries_buf[1];
            int i, count = 0;
                vlan_protocol_data_entry_t vde;

            /* Create the default VLAN_PROTOCOL_DATA profile */
            sal_memset(vlan_protocol_data_entries, 0,
                sizeof(vlan_protocol_data_entries));

                entries_buf[0] = &vlan_protocol_data_entries;
                BCM_IF_ERROR_RETURN(
                    _bcm_port_vlan_protocol_data_entry_add(unit, entries_buf,
                         16, (uint32 *)&vlan_protocol_data_index));

            /* First 16 entries of VLAN_PROTOCOL_DATA table are used for
             * default profile for Katana2 */
            for (i = 0; i < soc_mem_index_count(unit, VLAN_PROTOCOLm); i++) {
                    sal_memset(&vde, 0, sizeof(vlan_protocol_data_entry_t));
                    soc_VLAN_PROTOCOL_DATAm_field32_set(unit, &vde,
                    OVIDf, BCM_VLAN_DEFAULT);
                    soc_VLAN_PROTOCOL_DATAm_field32_set(unit, &vde,
                     TAG_ACTION_PROFILE_PTRf, 0);
                    BCM_IF_ERROR_RETURN(WRITE_VLAN_PROTOCOL_DATAm(unit,
                        MEM_BLOCK_ALL, i, &vde));
            }

            count = 0;
            PBMP_ITER(all_pbmp, p) {
                PORT(unit, p).vp_count = 0;
                if (!IS_LB_PORT(unit, p) && !SOC_WARM_BOOT(unit)) {

                    /* Set vlan_protocol_data_ptr profile index in port table. */
                    BCM_IF_ERROR_RETURN(
                    _bcm_esw_port_tab_set(unit, p,
                                         _BCM_CPU_TABS_ETHER,
                                          VLAN_PROTOCOL_DATA_INDEXf,
                                          vlan_protocol_data_index / 16));
                    PORT(unit, p).vlan_prot_ptr = vlan_protocol_data_index;
                    count++;
                }
            }

            /* Keep one extra reference to the default profile */
            for (i = 1; i < count + 1; i++) {
                BCM_IF_ERROR_RETURN(
                _bcm_port_vlan_protocol_data_entry_reference (unit,
                    vlan_protocol_data_index, 16));
            }
        } else

#endif
        {
            PBMP_ITER(all_pbmp, p) {
                PORT(unit, p).vp_count = 0;
                if (!IS_LB_PORT(unit, p)) {
                    if (!SOC_IS_TOMAHAWKX(unit) &&
                        !SOC_IS_TOMAHAWK3(unit) && !SOC_IS_TRIDENT3(unit)) {
                        /* there are more ports the profile */
#ifdef BCM_TRIUMPH2_SUPPORT
                        if (soc_feature(unit, soc_feature_vpd_profile)) {
                            BCM_IF_ERROR_RETURN
                                (_bcm_port_vlan_prot_index_alloc
                                    (unit, &(PORT(unit, p).vlan_prot_ptr)));
                        } else
#endif
                        {
                            PORT(unit, p).vlan_prot_ptr = p * soc_mem_index_count
                                                          (unit, VLAN_PROTOCOLm);
                        }
                    }
                }
            }
        }

        if (!SOC_WARM_BOOT(unit)) {
            /* Clear the profile ptr of source table */
            PBMP_ALL_ITER(unit, p) {
                BCM_IF_ERROR_RETURN
                    (_bcm_trx_vlan_port_egress_action_profile_clear(unit, p));
            }
        }

#ifdef BCM_FIREBOLT6_SUPPORT
        if (SOC_IS_FIREBOLT6(unit)) {
            PBMP_ALL_ITER(unit, p) {
                SOC_IF_ERROR_RETURN(
                    soc_mem_field32_modify(unit, SOURCE_TRUNK_MAP_TABLEm, p,
                   SRC_SUBPORT_NUMf, p));
                SOC_IF_ERROR_RETURN(
                    soc_mem_field32_modify(unit, SOURCE_TRUNK_MAP_TABLEm, p,
                  PP_PORT_NUMf, p));
            }

            /* Set egr min pkt size to default value of 0x40 */
            for (index = 0; index < soc_mem_index_count(unit,
                        EGR_PORT_MIN_PKT_SIZEm); index++) {
                SOC_IF_ERROR_RETURN(READ_EGR_PORT_MIN_PKT_SIZEm(
                            unit, MEM_BLOCK_ALL, index,
                            &egr_port_mem_pkt_size_ent));
                soc_mem_field32_set(unit, EGR_PORT_MIN_PKT_SIZEm,
                        &egr_port_mem_pkt_size_ent, MIN_PKT_SIZEf, 0x40);
                SOC_IF_ERROR_RETURN(WRITE_EGR_PORT_MIN_PKT_SIZEm(
                            unit, MEM_BLOCK_ALL, index,
                            &egr_port_mem_pkt_size_ent));
            }
        }
#endif

        /* Initialize the vlan action profile table */
#if defined(BCM_TOMAHAWK3_SUPPORT)
        if (SOC_IS_TOMAHAWK3(unit)) {
            BCM_IF_ERROR_RETURN (_bcm_th3_vlan_action_profile_init(unit));
        } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
        {
            BCM_IF_ERROR_RETURN (_bcm_trx_vlan_action_profile_init(unit));
        }

        if (SOC_IS_KATANA2(unit)) {
            SOC_PBMP_ASSIGN(hg_pbmp,PBMP_ST_ALL(unit));
        } else {
            SOC_PBMP_ASSIGN(hg_pbmp,PBMP_HG_ALL(unit));
        }

        if (!SOC_IS_TRIDENT3X(unit)) {
            PBMP_ITER(hg_pbmp, p) {
                BCM_IF_ERROR_RETURN
                    (_bcm_trx_vlan_port_egress_default_action_get(unit,
                                                                 p, &action));
                /* Backward compatible defaults */
                action.ot_outer = bcmVlanActionDelete;
                action.dt_outer = bcmVlanActionDelete;
                BCM_IF_ERROR_RETURN
                    (_bcm_trx_vlan_port_egress_default_action_set(unit,
                                                                 p, &action));
            }
        }
    }
#endif  /* BCM_TRX_SUPPORT*/

#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_higig_over_ethernet)) {
#ifdef BCM_WARM_BOOT_SUPPORT
        if (SOC_WARM_BOOT(unit)) {
            uint32 port_type, hg_type, update = 0;
            bcm_pbmp_t e_pbm;
            soc_info_t *si;
            egr_port_entry_t egr_port;

            if (SOC_IS_TRIDENT2PLUS(unit) || SOC_IS_APACHE(unit)) {
                si = &SOC_INFO(unit);
                SOC_PBMP_ASSIGN(e_pbm, PBMP_E_ALL(unit));
                PBMP_ITER(e_pbm, p) {
                    BCM_IF_ERROR_RETURN
                        (READ_EGR_PORTm(unit, MEM_BLOCK_ANY, p, &egr_port));
                    port_type =
                        soc_mem_field32_get(unit, EGR_PORTm, &egr_port, PORT_TYPEf);
                    hg_type =
                        soc_mem_field32_get(unit, EGR_PORTm, &egr_port, HG_TYPEf);
                    if ((port_type == 1) &&
                        (hg_type == BCM_PORT_HG_TYPE_HGOE_TRANSPORT)) {
                        SOC_PBMP_PORT_ADD(si->st.bitmap, p);
                        SOC_PBMP_PORT_REMOVE(si->ether.bitmap, p);
                        SOC_PBMP_PORT_REMOVE(si->hg2_pbm, p);
                        update = 1;
                    }
                }
#define RECONFIGURE_PORT_TYPE_INFO(ptype) \
                si->ptype.num = 0; \
                si->ptype.min = si->ptype.max = -1; \
                PBMP_ITER(si->ptype.bitmap, p) { \
                    si->ptype.port[si->ptype.num++] = p; \
                    if (si->ptype.min < 0) { \
                        si->ptype.min = p; \
                    } \
                    if (p > si->ptype.max) { \
                        si->ptype.max = p; \
                    } \
                }

                if (update) {
                    /* Recalculate port type data */
                    RECONFIGURE_PORT_TYPE_INFO(ether);
                    RECONFIGURE_PORT_TYPE_INFO(st);
                }
#undef  RECONFIGURE_PORT_TYPE_INFO
            }
        }
#endif /* BCM_WARM_BOOT_SUPPORT */
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

#ifdef BCM_TRIUMPH2_SUPPORT
    if (soc_feature(unit, soc_feature_gport_service_counters)) {
#ifdef BCM_WARM_BOOT_SUPPORT
        if (SOC_WARM_BOOT(unit)) {
            port_tab_entry_t ptab;
            int fs_idx;
            bcm_gport_t gport;

#ifdef BCM_TRIDENT_SUPPORT
            if (SOC_IS_TD_TT(unit)) {
                BCM_IF_ERROR_RETURN(_bcm_td_phymode_reconfigure(unit));
            }
#endif /* BCM_TRIDENT_SUPPORT */
            PBMP_ITER(all_pbmp, p) {
                BCM_IF_ERROR_RETURN(soc_mem_read(unit, PORT_TABm,
                                                 MEM_BLOCK_ANY, p, &ptab));
                fs_idx =
                    soc_mem_field32_get(unit, PORT_TABm, &ptab,
                                        VINTF_CTR_IDXf);
                if (fs_idx) {
                    BCM_IF_ERROR_RETURN
                        (bcm_esw_port_gport_get(unit, p, &gport));
                    _bcm_esw_flex_stat_reinit_add(unit,
                             _bcmFlexStatTypeGport, fs_idx, gport);
                }
            }
        }
#endif /* BCM_WARM_BOOT_SUPPORT */
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

#ifdef BCM_WARM_BOOT_SUPPORT
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        if (SOC_WARM_BOOT(unit)) {
            _bcm_tr3_port_info_reconfig(unit);
        }
    }
#endif /* BCM_TRIUMPH3_SUPPORT */
#endif /* BCM_WARM_BOOT_SUPPORT */
    if (!SOC_WARM_BOOT(unit)) {
        /*
         * Write port configuration tables to contain the Initial System
         * Configuration (see init.c).
         */

        SOC_PBMP_CLEAR(all_pbmp);
        BCM_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

#ifdef BCM_KATANA2_SUPPORT
        if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
            BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
        }
#endif

				SOC_PBMP_REMOVE(all_pbmp, PBMP_TDM(unit));

#ifdef BCM_KATANA2_SUPPORT
        if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
        }
#endif

        vd.vlan_tag = BCM_VLAN_DEFAULT;
        BCM_PBMP_ASSIGN(vd.port_bitmap, all_pbmp);
        BCM_PBMP_ASSIGN(vd.ut_port_bitmap, all_pbmp);
        BCM_PBMP_REMOVE(vd.ut_port_bitmap, PBMP_CMIC(unit));
        PBMP_ITER(all_pbmp, p) {
            BCM_IF_ERROR_RETURN
                (mbcm_driver[unit]->mbcm_port_cfg_init(unit, p, &vd));
        }

        if (SOC_IS_TRIDENT3X(unit)) {
            /* Initialize inner TPID
             * (WAR)Set to 0x9100 then change back to take effort
             */
            BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit, VLAN_CTRLr,
                                REG_PORT_ANY, INNER_TPIDf, 0x9100));
            BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit, VLAN_CTRLr,
                                REG_PORT_ANY, INNER_TPIDf, 0x8100));

            if (SOC_REG_FIELD_VALID(unit, EGR_CONFIG_1_64r, INNER_TPIDf)) {
                BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit, EGR_CONFIG_1_64r,
                                    REG_PORT_ANY, INNER_TPIDf, 0x9100));
                BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit, EGR_CONFIG_1_64r,
                                REG_PORT_ANY, INNER_TPIDf, 0x8100));
        }
        }

        /*
         * Clear egress port blocking table
         */
        if (SOC_IS_XGS_SWITCH(unit)) {
#ifdef BCM_SHADOW_SUPPORT
            if (!SOC_IS_SHADOW(unit)) {
#endif
                if (!SAL_BOOT_SIMULATION || SAL_BOOT_QUICKTURN) {
                    SOC_IF_ERROR_RETURN
                        (soc_mem_clear(unit, MAC_BLOCKm, COPYNO_ALL, TRUE));
                }
#ifdef BCM_SHADOW_SUPPORT
            }
#endif
        }
    }

#ifdef BCM_SHADOW_SUPPORT
    if (SOC_IS_SHADOW(unit)) {
        PBMP_ITER(PBMP_PORT_ALL(unit), p) {
            if (BCM_PBMP_MEMBER(SOC_INFO(unit).all.disabled_bitmap, p)) {
                SOC_PBMP_PORT_REMOVE(PBMP_PORT_ALL(unit), p);
            }
        }
    }
#endif
#ifdef BCM_PREEMPTION_SUPPORT
    if (soc_feature(unit, soc_feature_preemption)) {
        BCM_IF_ERROR_RETURN(bcmi_esw_preemption_init(unit));
    }
#endif

    /* Probe for ports */
    SOC_PBMP_CLEAR(okay_ports);

    /* Fast reboot will NOT cold boot portmod and the serdes because we
     * want to keep the link up
     */
    if (SOC_FAST_REBOOT(unit)) {
        SOC_WARM_BOOT_START(unit);
    }
#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit) &&
        (dev_id == BCM56272_DEVICE_ID)) {
        BCM_PBMP_CLEAR(non_sat_port_pbmp);
        BCM_PBMP_ASSIGN(non_sat_port_pbmp, PBMP_PORT_ALL(unit));
        if(SOC_PBMP_MEMBER(non_sat_port_pbmp, _BCM_SB2_SAT_OAMP_PHY_PORT_NUMBER)) {
            /* TSC0 is OFF */
            SOC_PBMP_PORT_REMOVE(non_sat_port_pbmp,
                    _BCM_SB2_SAT_OAMP_PHY_PORT_NUMBER);
        }
        rv = bcm_esw_port_probe(unit, non_sat_port_pbmp, &okay_ports);
    } else
#endif
    {
        rv = bcm_esw_port_probe(unit, PBMP_PORT_ALL(unit), &okay_ports);
    }
    if (rv != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit,
                              "Error unit %d:  Failed port probe: %s\n"),
                   unit, bcm_errmsg(rv)));
        return rv;
    }

    LOG_VERBOSE(BSL_LS_BCM_PORT,
                (BSL_META_U(unit,
                            "Probed ports okay: %s of %s\n"),
                 SOC_PBMP_FMT(okay_ports, pfmtok),
                 SOC_PBMP_FMT(PBMP_PORT_ALL(unit), pfmtall)));

    if (SOC_FAST_REBOOT(unit)) {
        SOC_WARM_BOOT_DONE(unit);

        /* Add all ports that would have been added during portmod init to
         * the pbmp because the rest of the cold boot sequence is going
         * to need it
         */
        PBMP_PORT_ITER(unit, port_iter) {
            if (IS_CPU_PORT(unit, port_iter) || IS_LB_PORT(unit, port_iter)) {
                continue;
            }
            SOC_PBMP_PORT_ADD(okay_ports, port_iter);
        }

    }

    /*
     * A compile-time application policy may prefer to disable ports
     * when switch boots up
     */
#ifdef BCM_PORT_DEFAULT_DISABLE
            port_enable = FALSE;
#else
            port_enable = TRUE;
#endif  /* BCM_PORT_DEFAULT_DISABLE */

    if(SOC_IS_SABER2(unit) && (!SOC_WARM_BOOT(unit))) {
        PBMP_ITER(okay_ports, p) {
            if ((rv = bcm_esw_port_enable_set(unit, p, port_enable)) < 0) {
                LOG_WARN(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                                     "Warning: Unit %d Port %s: "
                                     "Failed to %s port: %s\n"),
                          unit, SOC_PORT_NAME(unit, p),(port_enable) ? \
                          "enable" : "disable" ,bcm_errmsg(rv)));
            }
        }
    }



    length_check = soc_property_get(unit, spn_MAC_LENGTH_CHECK_ENABLE, 0);

    /* Probe and initialize MAC and PHY drivers for ports that were OK */
    PBMP_ITER(okay_ports, p) {
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "bcm_port_init: unit %d port %s\n"),
                                unit, SOC_PORT_NAME(unit, p)));

        PORT_LOCK(unit);

        
        if (SOC_PORT_USE_PORTCTRL(unit, p)) {
        } else {
            if ((rv = _bcm_port_mode_setup(unit, p, TRUE)) < 0) {
                LOG_WARN(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                                     "Warning: Port %s: "
                                     "Failed to set initial mode: %s\n"),
                          SOC_PORT_NAME(unit, p), bcm_errmsg(rv)));
            }
        }
        PORT_UNLOCK(unit);

#ifdef BCM_RCPU_SUPPORT
        if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, p)) {
            if (SOC_PORT_USE_PORTCTRL(unit, p)) {
                bcmi_esw_portctrl_phy_enable_set(unit, p, TRUE);
            } else {
                soc_phyctrl_enable_set(unit, p, TRUE);
            }
            continue;
        }
#endif /* BCM_RCPU_SUPPORT */

#ifdef BCM_WARM_BOOT_SUPPORT
        if (SOC_WARM_BOOT(unit) || SOC_FAST_REBOOT(unit)) {
            continue;
        }
#endif /* BCM_WARM_BOOT_SUPPORT */
        if ((rv = bcm_port_settings_init(unit, p)) < 0) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "Warning: Port %s: "
                                 "Failed to configure initial settings: %s\n"),
                      SOC_PORT_NAME(unit, p), bcm_errmsg(rv)));
        }

#ifdef BCM_TRIDENT2_SUPPORT
        if (soc_feature(unit, soc_feature_pgw_mac_rsv_mask_remap)) {
            uint32 addr;
            int block;
            uint8 acc_type;
            uint32 rval;

            addr = soc_reg_addr_get(unit, PGW_MAC_RSV_MASKr, p, 0,
                                    SOC_REG_ADDR_OPTION_NONE, &block,
                                    &acc_type);
            addr &= 0xffffff00;
            /* coverity[overrun-local : FALSE] */
            addr |= (SOC_INFO(unit).port_l2p_mapping[p] - 1) & 0xf;
            SOC_IF_ERROR_RETURN(_soc_reg32_get(unit, block, acc_type, addr,
                                               &rval));
            if (length_check) {
                rval |= 0x20;  /* set bit 5 to enable frame length check */
            } else {
                rval &= ~0x20; /* clear bit 5 to disable frame length check */
            }
            rval |= 1 << 18; /* set PFC frame detected indicator */
            SOC_IF_ERROR_RETURN(_soc_reg32_set(unit, block, acc_type, addr,
                                               rval));
        } else
#endif /* BCM_TRIDENT2_SUPPORT */
        /* Control 802.3 frame length field check in MAC for
         * XL, XLB0, XT, CL, CLG2, XW (helix4) or MXQ blocks */
        if (IS_XL_PORT(unit, p) || IS_XLB0_PORT(unit, p) || IS_XT_PORT(unit, p) ||
            IS_CL_PORT(unit, p) || IS_CLG2_PORT(unit, p) || IS_MXQ_PORT(unit,p) ||
            IS_XW_PORT(unit,p) || IS_CD_PORT(unit, p)) {
            uint32 rval;
            soc_reg_t reg = INVALIDr;

            if ((IS_CL_PORT(unit, p) || IS_CLG2_PORT(unit, p)) &&
                SOC_REG_IS_VALID(unit, CLPORT_MAC_RSV_MASKr)) {
                reg = CLPORT_MAC_RSV_MASKr;
            } else if (IS_CD_PORT(unit, p)) {
                reg = CDMAC_RSV_MASKr;
            } else if (SOC_REG_IS_VALID(unit, PGW_MAC_RSV_MASKr)) {
                reg = PGW_MAC_RSV_MASKr;
            } else if (SOC_IS_SABER2(unit) && SOC_REG_PORT_VALID(unit, XLPORT_MAC_RSV_MASKr, p)) {
                reg = XLPORT_MAC_RSV_MASKr;
            } else if (SOC_REG_IS_VALID(unit, MAC_RSV_MASKr)) {
                reg = MAC_RSV_MASKr;
            } else if (SOC_REG_IS_VALID(unit, XLPORT_MAC_RSV_MASKr)) {
                reg = XLPORT_MAC_RSV_MASKr;
            }

            if (reg != INVALIDr) {
                SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, p, 0, &rval));
                if (length_check) {
                    rval |= 0x20;  /* set bit 5 to enable frame length check */
                } else {
                    rval &= ~0x20; /* clear bit 5 to disable frame length check */
                }
                if (SOC_IS_TD2_TT2(unit)|| SOC_IS_HELIX4(unit)) {
                    rval |= 1 << 18; /* set PFC frame detected indicator */
                }
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, p, 0, rval));
            }
        }

        /*
         * A compile-time application policy may prefer to disable ports
         * when switch boots up
         */

#ifdef BCM_PORT_DEFAULT_DISABLE
            port_enable = FALSE;
#else
            port_enable = TRUE;
#endif  /* BCM_PORT_DEFAULT_DISABLE */

        if(!SOC_IS_SABER2(unit)) {
            if ((rv = bcm_esw_port_enable_set(unit, p, port_enable)) < 0) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "Warning: Port %s: "
                                 "Failed to %s port: %s\n"),
                      SOC_PORT_NAME(unit, p),(port_enable) ? \
                      "enable" : "disable" ,bcm_errmsg(rv)));
            }
        }

        /*
         *  JAM should be enabled by default
         */
        if (IS_E_PORT(unit, p)) {
            if (soc_mem_field_valid(unit, PORT_TABm, JAM_ENf) ||
                soc_reg_field_valid(unit, GE_PORT_CONFIGr, JAM_ENf) ||
                soc_feature(unit, soc_feature_unimac)) {

#if defined(BCM_HURRICANE_SUPPORT)
                if (SOC_IS_HURRICANEX(unit) || SOC_IS_GREYHOUND(unit) ||
                    SOC_IS_GREYHOUND2(unit)) {
                    rv = bcm_esw_port_jam_set(unit, p, 0);
                } else
#endif
                {
                    rv = bcm_esw_port_jam_set(unit, p, 1);
                }
                if (BCM_FAILURE(rv) && (rv != BCM_E_UNAVAIL)) {
                    LOG_WARN(BSL_LS_BCM_PORT,
                             (BSL_META_U(unit,
                                         "Warning: Port %s: "
                                         "Failed to enable JAM %s\n"),
                              SOC_PORT_NAME(unit, p), bcm_errmsg(rv)));
                }
            }
        }
#ifdef BCM_TRIUMPH2_SUPPORT
        if (soc_feature(unit, soc_feature_unimac_tx_crs) && IS_XQ_PORT(unit, p)
            && IS_GE_PORT(unit, p)) {
            BCM_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, XPORT_CONFIGr, p,
                                        UNIMAC_HD_ECO_ENABLEf, 1));
        }
#endif
#ifdef BCM_RCPU_SUPPORT
        if ((uint32)p == soc_property_get(unit, spn_RCPU_PORT, -1)) {
            BCM_IF_ERROR_RETURN
                (bcm_esw_port_frame_max_set(unit, p, BCM_PORT_JUMBO_MAXSZ));
        }
#endif /* BCM_RCPU_SUPPORT */
    }

#if defined(BCM_GREYHOUND_SUPPORT)
    if (SOC_IS_GREYHOUND(unit)) {
        BCM_IF_ERROR_RETURN(bcm_gh_port_init(unit));
    }
#endif

#if defined(BCM_HURRICANE3_SUPPORT)
    if (SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
        BCM_IF_ERROR_RETURN(bcm_hr3_port_init(unit));
    }
#endif

#if defined(BCM_TRIDENT_SUPPORT)
    if (SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANAX(unit)) {
        BCM_IF_ERROR_RETURN(bcm_td_port_init(unit));
    }
#endif /* BCM_TRIDENT_SUPPORT */

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAVEN_SUPPORT) || \
    defined(BCM_TRX_SUPPORT)
    if (!SOC_WARM_BOOT(unit) && !SOC_IS_RELOADING(unit)) {
        /* Enable the default outer TPID. */
        if (soc_feature(unit, soc_feature_vlan_ctrl)) {
        /* if (soc_feature(unit, soc_feature_vlan_ctrl) && * SOC_IS_SHADOW(unit)) { */

        SOC_PBMP_CLEAR(all_pbmp);
        SOC_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

#ifdef BCM_KATANA2_SUPPORT
        if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
            BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
        }
#endif

        SOC_PBMP_REMOVE(all_pbmp, PBMP_TDM(unit));

#ifdef BCM_KATANA2_SUPPORT
        if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
        }
#endif

#if defined(BCM_SABER2_SUPPORT)
        /* If OAMP is enabled by default, skip the port init for oamp port */
        if(SOC_IS_SABER2(unit)) {
            int oamp_enable;
            (void)bcm_sb2_sat_oamp_enable_get(unit, &oamp_enable);

            if (soc_feature(unit, soc_feature_sat) &&
                ((!SOC_WARM_BOOT(unit) &&
                    soc_property_get(unit, spn_SAT_ENABLE, 0)) ||
                 (SOC_WARM_BOOT(unit) && (oamp_enable == TRUE)))) {
                SOC_PBMP_PORT_REMOVE(all_pbmp,
                        _BCM_SB2_SAT_OAMP_PHY_PORT_NUMBER);
            }
        }
#endif
            PBMP_ITER(all_pbmp, p) {
                rv = bcm_esw_port_tpid_set(unit, p,
                                _bcm_fb2_outer_tpid_default_get(unit));
                if (BCM_FAILURE(rv)) {
                 LOG_WARN(BSL_LS_BCM_PORT,
                          (BSL_META_U(unit,
                                      "Warning: "
                                      "Failed to set %s port default TPID: %s\n"),
                           SOC_PORT_NAME(unit, p), bcm_errmsg(rv)));
                }
                if (soc_feature(unit, soc_feature_inner_tpid_enable)) {
                    /* Enable the default inner TPID. */
                    rv = bcm_esw_port_inner_tpid_set(unit, p,
                                    _bcm_fb2_outer_tpid_default_get(unit));
                    if (BCM_FAILURE(rv)) {
                     LOG_WARN(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                                          "Warning: "
                                          "Failed to set %s port default inner TPID: %s\n"),
                               SOC_PORT_NAME(unit, p), bcm_errmsg(rv)));
                    }
                }
            }
        }
    }
#endif

#ifdef BCM_XGS3_FABRIC_SUPPORT
    if (SOC_IS_XGS3_FABRIC(unit)) {
        PBMP_ALL_ITER(unit, p) {
            bcm_esw_port_learn_set(unit, p, BCM_PORT_LEARN_FWD);
        }
    }
#endif
    if (SAL_BOOT_SIMULATION &&
        soc_property_get(unit, "skip_partial_port_hw_init", 0)) {
        return BCM_E_NONE;
    }
#ifdef BCM_TRIUMPH2_SUPPORT
    if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
        SOC_IS_VALKYRIE2(unit) || SOC_IS_ENDURO(unit) ||
        SOC_IS_TD_TT(unit) || SOC_IS_HURRICANEX(unit) ||
        SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANAX(unit) ||
        SOC_IS_GREYHOUND(unit) || SOC_IS_GREYHOUND2(unit)) {
        uint32 regval, profile_index;
        bcm_pbmp_t port_pbmp;

        /* Set the chip-wide E2ECC port mapping enable bit */
        if (soc_feature(unit, soc_feature_sysport_remap)) {
            SOC_IF_ERROR_RETURN(READ_E2ECC_PORT_MAPPING_CONFIGr(unit, &regval));
            soc_reg_field_set(unit, E2ECC_PORT_MAPPING_CONFIGr, &regval, PORT_MAPPING_ENf, 1);
            SOC_IF_ERROR_RETURN(WRITE_E2ECC_PORT_MAPPING_CONFIGr(unit, regval));
        }

        SOC_PBMP_CLEAR(all_pbmp);
        SOC_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));
        SOC_PBMP_CLEAR(port_pbmp);
        SOC_PBMP_ASSIGN(port_pbmp, PBMP_PORT_ALL(unit));

#ifdef BCM_KATANA2_SUPPORT
        if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
            _bcm_kt2_subport_pbmp_update(unit, &port_pbmp);
        }
        if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
            BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &all_pbmp));
            BCM_IF_ERROR_RETURN(_bcm_kt2_flexio_pbmp_update(unit, &port_pbmp));
        }
#endif

        PBMP_ITER(all_pbmp, p) {
            /* Initialize the logical to physical port mapping */
            if (!SOC_IS_ENDURO(unit) && !SOC_IS_HURRICANEX(unit) &&
                !SOC_IS_TD_TT(unit) && !SOC_IS_TRIUMPH3(unit) &&
                !SOC_IS_KATANAX(unit) && !SOC_IS_GREYHOUND(unit) &&
                !SOC_IS_GREYHOUND2(unit)) {
                bcm_port_t sp = p;
                if (soc_feature(unit, soc_feature_sysport_remap)) {
                    BCM_XLATE_SYSPORT_P2S(unit, &sp);
                }
                _bcm_port_remap_set(unit, p, sp);
            }

            /* Initialize egress block profile pointer to invalid value */
            PORT_SRC_MOD_EGR_PROF_PTR(unit, p) = -1;

            /* Program the VLAN_PROTOCOL_DATA / FP_PORT_FIELD_SEL_INDEX
               / PROTOCOL_PKT_INDEX pointers */
            if (!IS_LB_PORT(unit, p) && !IS_TDM_PORT(unit, p)) {
                int value = 0;
                if (SOC_MEM_IS_VALID(unit, VLAN_PROTOCOLm)) {
                    value = PORT(unit, p).vlan_prot_ptr /
                            soc_mem_index_count(unit, VLAN_PROTOCOLm);
                }
                if ((0 != value) &&
                    (soc_mem_index_max(unit, VLAN_PROTOCOL_DATAm) > 0)) {
                    BCM_IF_ERROR_RETURN(
                        _bcm_esw_port_tab_set(unit, p,
                                       _BCM_CPU_TABS_ETHER,
                                       VLAN_PROTOCOL_DATA_INDEXf,
                                       BCM_PBMP_MEMBER(port_pbmp, p) ? value : 0));
                }

                if (soc_mem_field_valid(unit, PORT_TABm,
                    FP_PORT_FIELD_SEL_INDEXf)) {
                    BCM_IF_ERROR_RETURN(
                        _bcm_esw_port_tab_set(unit, p,
                                   _BCM_CPU_TABS_ETHER,
                                    FP_PORT_FIELD_SEL_INDEXf, p));
                }
                if (soc_mem_field_valid(unit, PORT_TABm, PROTOCOL_PKT_INDEXf) ||
                    soc_mem_field_valid(unit, LPORT_TABm,
                                        PROTOCOL_PKT_INDEXf)) {
                    if (SOC_REG_INFO(unit, PROTOCOL_PKT_CONTROLr).regtype ==
                        soc_portreg) {
                            BCM_IF_ERROR_RETURN(
                                _bcm_esw_port_tab_set(unit, p,
                                                   _BCM_CPU_TABS_ETHER,
                                                   PROTOCOL_PKT_INDEXf,
                                                   p));
                    } else {
                        BCM_IF_ERROR_RETURN
                            (_bcm_prot_pkt_ctrl_add(unit, 0, 0,
                                                    &profile_index));
                        BCM_IF_ERROR_RETURN(
                            _bcm_esw_port_tab_set(unit, p,
                                                   _BCM_CPU_TABS_ETHER,
                                                   PROTOCOL_PKT_INDEXf,
                                                   profile_index));
                    }
                }

                if (soc_feature(unit, soc_feature_embedded_higig)
                    && IS_E_PORT(unit, p)) {
                    uint32 buffer[_BCM_PORT_EHG_IP_GRE_HEADER_BUFFER_SZ];
                    uint32      mask[SOC_MAX_MEM_FIELD_WORDS];

                    sal_memset(buffer, 0,
                           WORDS2BYTES(_BCM_PORT_EHG_IP_GRE_HEADER_BUFFER_SZ));
                    sal_memset(mask, 0xFF, sizeof(mask));
                    /* coverity[overrun-call : FALSE] */
                    BCM_IF_ERROR_RETURN(
                        _bcm_port_ehg_header_write(unit, p, buffer, buffer, mask,
                                        _BCM_PORT_EHG_IP_GRE_HEADER_BUFFER_SZ));
                }
            }
        }

        if (!SOC_MEM_IS_VALID(unit, SYSTEM_CONFIG_TABLE_MODBASEm) &&
            !SOC_MEM_IS_VALID(unit, SOURCE_TRUNK_MAP_MODBASEm) &&
            SOC_MEM_IS_VALID(unit, SYSTEM_CONFIG_TABLEm)) {
            BCM_IF_ERROR_RETURN(_bcm_tr2_system_tpid_init(unit));
        }
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT) || \
    defined(BCM_TIMESYNC_V3_SUPPORT) || defined(BCM_SABER2_SUPPORT)
    if ((soc_feature(unit, soc_feature_timesync_v3) || SOC_IS_TRIUMPH3(unit) ||
         SOC_IS_KATANAX(unit)|| SOC_IS_TD2_TT2(unit) || SOC_IS_SABER2(unit) ||
         SOC_IS_APACHE(unit)) &&
        (soc_feature(unit,soc_feature_timesync_support))) {
        _bcm_esw_port_timesync_profile_init(unit);
    }
#endif /* defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT) ||
          defined(BCM_TIMESYNC_V3_SUPPORT) || defined(BCM_SABER2_SUPPORT) */

#ifdef BCM_SHADOW_SUPPORT
        /* Static port load balancing configuration for shadow */
    if (SOC_IS_SHADOW(unit))  {
        port_tab_entry_t ptab;

        for (p = 0; p <= 16; p++) {
            /* Enable IPV4 and IPV6 */
            BCM_IF_ERROR_RETURN(
                _bcm_esw_port_tab_set(unit, p,
                                     _BCM_CPU_TABS_ETHER,
                                      IPV4_ENABLEf, 1));

            BCM_IF_ERROR_RETURN(
                _bcm_esw_port_tab_set(unit, p,
                                     _BCM_CPU_TABS_ETHER,
                                      IPV6_ENABLEf, 1));
        }

        /* For shadow-petrab mode, configure uflow_A(xe0) and uflow_b(xe1)*/
        if(soc_property_get(unit, spn_BCM88732_DEVICE_MODE, 0) &&
                ((soc_property_get(unit, spn_BCM88732_2X40_1X40, 0)) ||
                 (soc_property_get(unit, spn_BCM88732_2X40_2X40, 0)))) {
            BCM_IF_ERROR_RETURN(
                _bcm_esw_port_tab_set(unit, 1,
                                     _BCM_CPU_TABS_ETHER,
                                      AGGREGATION_GROUP_SELECTf, 0));

            /* port 5 (xe1) configure uflow_b for static load balancing */
            BCM_IF_ERROR_RETURN(
                _bcm_esw_port_tab_set(unit, 5,
                                     _BCM_CPU_TABS_ETHER,
                                      AGGREGATION_GROUP_SELECTf, 1));

            /* Enable SAND interop header for Interlaken ports */
            for (p = 9; p <= 16; p++) {
                BCM_IF_ERROR_RETURN(_bcm_esw_port_tab_set(unit, p,
                                           _BCM_CPU_TABS_ETHER,
                                            SAND_COS_ENABLEf, 1));
            }
        }
        if(soc_property_get(unit, spn_BCM88732_2X40_8X10, 0))  {
            sal_memset(&ptab, 0, sizeof(ptab));
            /* port 1 (xe0) configure uflow_a for static load balancing */
            SOC_IF_ERROR_RETURN(
                    READ_PORT_TABm(unit, MEM_BLOCK_ANY, 1, &ptab));
            soc_PORT_TABm_field32_set(unit, &ptab, AGGREGATION_GROUP_SELECTf, 0);
            SOC_IF_ERROR_RETURN(
                    WRITE_PORT_TABm(unit,MEM_BLOCK_ALL, 1, &ptab));

            /* port 5 (xe1) configure uflow_b for static load balancing */
            SOC_IF_ERROR_RETURN(
                    READ_PORT_TABm(unit, MEM_BLOCK_ANY, 5, &ptab));
            soc_PORT_TABm_field32_set(unit, &ptab, AGGREGATION_GROUP_SELECTf, 1);
            SOC_IF_ERROR_RETURN(
                    WRITE_PORT_TABm(unit,MEM_BLOCK_ALL, 5, &ptab));

        }

        /* By default Disable VLAN checks and enable TPID in port table */
        for (p = 0; p <= 16; p++) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_tab_set(unit, p,
                                _BCM_CPU_TABS_ETHER,
                                 DISABLE_VLAN_CHECKSf, 1));

            BCM_IF_ERROR_RETURN(_bcm_esw_port_tab_set(unit, p,
                                _BCM_CPU_TABS_ETHER,
                                 OUTER_TPID_ENABLEf, 1));
        }
    }
#endif /* BCM_SHADOW_SUPPORT */

#ifdef BCM_TRIDENT_SUPPORT
    if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit)) {
        uint32 regval;
        int blk;
        int blk_num = -1;
        int bindex = 0;
        int tx_pbm = 0;
        bcm_pbmp_t all_pbmp;

        if (SOC_IS_TRIUMPH3(unit)) {
            /* Clear all bits for flex port considerations */
            for (blk_num = 0; blk_num < 7; blk_num++) {
                SOC_IF_ERROR_RETURN
                    (WRITE_E2ECC_TX_ENABLE_BMPr(unit, blk_num, 0));
            }
        }

        SOC_PBMP_CLEAR(all_pbmp);
        SOC_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

#ifdef BCM_KATANA2_SUPPORT
        if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
        }
#endif

        PBMP_ITER(all_pbmp, p) {
            if (!IS_LB_PORT(unit, p) && !IS_TDM_PORT(unit, p)) {
                 if (soc_mem_field_valid(unit, PORT_TABm,
                    FP_PORT_FIELD_SEL_INDEXf)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_port_tab_set(unit, p,
                                    _BCM_CPU_TABS_ETHER,
                                    FP_PORT_FIELD_SEL_INDEXf, p));
                }
            }
        }

        PBMP_ITER(PBMP_PORT_ALL(unit), p) {
            /* In Trident all ports are enabled to send E2ECC messages by
             * default. Disable E2ECC message TX here until congestion config
             * set enables the port.
             */

            if (soc_feature(unit, soc_feature_logical_port_num)) {
                /* coverity[overrun-local : FALSE] */
                blk = SOC_PORT_BLOCK(unit, SOC_INFO(unit).port_l2p_mapping[p]);
                bindex = SOC_PORT_BINDEX(unit, SOC_INFO(unit).port_l2p_mapping[p]);
            } else{
                blk = SOC_PORT_BLOCK(unit, p);
                bindex = SOC_PORT_BINDEX(unit, p);
            }
#if defined(BCM_APACHE_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)
           if (SOC_IS_TRIDENT2X(unit)) {
               blk_num = SOC_INFO(unit).port_serdes[p];
           } else
#endif
           {
              blk_num = SOC_BLOCK_INFO(unit, blk).number;
           }
            if (SOC_IS_KATANA2(unit)) {
                if (!IS_HG_PORT(unit, p)) {
                    continue;
                }
                /* In KT2 E2ECC is implemented only in blocks 6..9 */
                if (blk_num >= 6) {
                    blk_num -= 6;
                } else {
                    continue;
                }
            }
            if (!SOC_IS_TRIUMPH3(unit) &&
                SOC_REG_IS_VALID(unit, E2ECC_TX_ENABLE_BMPr)) {
                SOC_IF_ERROR_RETURN(READ_E2ECC_TX_ENABLE_BMPr(unit, blk_num,
                                                              &regval));
                tx_pbm = soc_reg_field_get(unit, E2ECC_TX_ENABLE_BMPr, regval,
                                           TX_ENABLE_BMPf);
                tx_pbm &= ~(1 << bindex);
                soc_reg_field_set(unit, E2ECC_TX_ENABLE_BMPr, &regval,
                                  TX_ENABLE_BMPf, tx_pbm);
                SOC_IF_ERROR_RETURN(WRITE_E2ECC_TX_ENABLE_BMPr(unit,
                                                               blk_num, regval));
            }
        }
        /* Set the chip-wide E2ECC port mapping enable bit */
        if (soc_feature(unit, soc_feature_sysport_remap)) {
            SOC_IF_ERROR_RETURN(READ_E2ECC_PORT_MAPPING_CONFIGr(unit, &regval));
            soc_reg_field_set(unit, E2ECC_PORT_MAPPING_CONFIGr, &regval,
                              PORT_MAPPING_ENf, 1);
            SOC_IF_ERROR_RETURN(WRITE_E2ECC_PORT_MAPPING_CONFIGr(unit, regval));
        }
    }
#endif

#if defined (BCM_HURRICANE_SUPPORT) || defined(BCM_TRIDENT_SUPPORT) \
    || defined (BCM_HAWKEYE_SUPPORT) || defined(BCM_SHADOW_SUPPORT) \
    || defined (BCM_HURRICANE2_SUPPORT)
    if (SOC_IS_HURRICANE (unit) || SOC_IS_TD_TT (unit) ||
        SOC_IS_HAWKEYE (unit) || SOC_IS_SHADOW(unit) ||
        SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit) ||
        SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit) ||
        SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
        if (soc_feature (unit, soc_feature_eee)) {
            int mac_val = 0;
            _bcm_port_info_t *port_info;
            PBMP_ALL_ITER(unit, p) {
                if (!IS_LB_PORT(unit, p) && !IS_CPU_PORT (unit, p) && !IS_FAE_PORT (unit, p) &&
                    !IS_TDM_PORT(unit, p) && !IS_RDB_PORT(unit,p) && !IS_MACSEC_PORT(unit,p)) {
                    /* EEE standard compliance Work Around:
                     * Initialize the software state of native eee in MAC
                     */
                    eee_cfg[unit][p] = 0;
                    /* Check if MAC supports Native EEE and set the value of
                     * eee_cfg by reading the EEE status from MAC*/
                    if (SOC_PORT_USE_PORTCTRL(unit, p)) {
                        rv = bcmi_esw_portctrl_eee_enable_get(unit, p,
                                                              &mac_val);

                    } else {
                        _bcm_port_info_access(unit, p, &port_info);
                        rv = MAC_CONTROL_GET(port_info->p_mac, unit, p,
                                             SOC_MAC_CONTROL_EEE_ENABLE,
                                             &mac_val);
                    }
                    if (rv != BCM_E_UNAVAIL) {
                        eee_cfg[unit][p] = mac_val;
                    }
                }
            }
        }
    }
#endif /* (BCM_HURRICANE_SUPPORT) || (BCM_TRIDENT_SUPPORT) || (BCM_HAWKEYE_SUPPORT)*/

    /*
     * CES TDM Port initialization
     */
    /* Set Higig/Higig2 mode */
    if (!SOC_WARM_BOOT(unit)) {
        if (SOC_USE_PORTCTRL(unit)) {
            int hg_port;
            PBMP_HG_ITER(unit, hg_port) {
                BCM_IF_ERROR_RETURN
                    (bcmi_esw_portctrl_higig_mode_set(unit, hg_port, TRUE));
            }
        }
#ifdef BCM_HIGIG2_SUPPORT
        if (soc_feature(unit, soc_feature_higig2)) {
            int hg_port;
#if defined(BCM_KATANA_SUPPORT)
            int hl_port;

            if (SOC_IS_KATANA(unit)) {
                PBMP_HL_ITER(unit, hl_port) {
                    BCM_IF_ERROR_RETURN
                        (_bcm_esw_port_higig2_mode_set(unit, hl_port, TRUE));
                    SOC_HG2_ENABLED_PORT_ADD(unit, hl_port);
                }
            }
#endif
            PBMP_HG_ITER(unit, hg_port) {
                /*
                 * Make all HG ports default to HiGig2, when
                 * 1. spn_HIGIG2_HDR_MODE = 1. Or
                 * 2. portmod is enabled
                 */
                if (soc_property_port_get(unit, hg_port, spn_HIGIG2_HDR_MODE,
                        soc_feature(unit, soc_feature_no_higig_plus) ? 1 : 0) ||
                    SOC_USE_PORTCTRL(unit)) {
                    BCM_IF_ERROR_RETURN
                        (_bcm_esw_port_higig2_mode_set(unit, hg_port, TRUE));
                    SOC_HG2_ENABLED_PORT_ADD(unit, hg_port);
                }
            }
        }
#endif /* BCM_HIGIG2_SUPPORT */
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_mon_start(unit));
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_esw_ibod_sync_recovery_start(unit,
             soc_property_get(unit, spn_PORTMON_INTERVAL, IBOD_SYNC_INTERVAL_MIN)));
    }
#endif /* BCM_TRIUMPH3_SUPPORT */
    /* Port translation call-back function for PHY drivers */
    soc_phy_cb_xlate_port_func = _bcm_phy_cb_xlate_port;

#ifdef BCM_TRIUMPH2_SUPPORT
    if (soc_feature(unit, soc_feature_src_modid_blk_profile)) {
        soc_mem_t mem = SRC_MODID_EGRESSm;
        int mem_words;
        int rv;

        if (SOC_MEM_IS_VALID(unit, mem)) {
            if (NULL == PORT_SRC_MOD_EGR_PROFILE(unit)) {
                PORT_SRC_MOD_EGR_PROFILE(unit) =
                    sal_alloc(sizeof(soc_profile_mem_t),
                              "SRC_MODID_EGRESS Profile Mem");
                if (NULL == PORT_SRC_MOD_EGR_PROFILE(unit)) {
                    return BCM_E_MEMORY;
                }
                soc_profile_mem_t_init(PORT_SRC_MOD_EGR_PROFILE(unit));

                mem_words = sizeof(src_modid_egress_entry_t) /
                    sizeof(uint32);

                rv = soc_profile_mem_create(unit, &mem, &mem_words, 1,
                                            PORT_SRC_MOD_EGR_PROFILE(unit));
                if (rv < 0) {
                    sal_free(PORT_SRC_MOD_EGR_PROFILE(unit));
                    PORT_SRC_MOD_EGR_PROFILE(unit) = NULL;
                    return rv;
                }
            }
        }
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT)
    if (SOC_IS_KATANA2(unit)) {
        /* Enable EGR_ENABLEm:PRT_ENABLEf for cpu port */
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "\nEnable EGR_ENABLEm:PRT_ENABLEf for cpu port \n")));
        sal_memset(entry, 0, sizeof(egr_enable_entry_t));
        soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 1);
        SOC_IF_ERROR_RETURN(
            WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, CMIC_PORT(unit), entry));
        SOC_IF_ERROR_RETURN(
            WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, LB_PORT(unit), entry));
    }
#endif /* BCM_KATANA_SUPPORT */

    if (!soc_feature(unit, soc_feature_no_sw_rx_los)){
    /* Get Initial SW RX LOS configuration from PHY driver */
    PBMP_ITER(all_pbmp, p) {
        if (IS_E_PORT(unit, p)) {
            rv = bcm_esw_port_phy_control_get(unit, p,
                                 BCM_PORT_PHY_CONTROL_SOFTWARE_RX_LOS,
                                 &rx_los);
            if (BCM_SUCCESS(rv)) {
                PORT(unit, p).rx_los = rx_los;
            }
        }
    }
    }

    /* set link delay offset */
    PBMP_ITER(all_pbmp, p) {
        PORT(unit, p).link_delay_offset = 0;
        if (SOC_WARM_BOOT(unit)) {
            rv = bcm_esw_port_speed_get(unit, p, &p_speed);
            if (BCM_FAILURE(rv)) {
                continue;
            }
            BCM_IF_ERROR_RETURN(_bcm_esw_port_link_delay_recover(unit, p, p_speed));
        }
    }

    /* set port dscp map set to zero */
    PBMP_ITER(all_pbmp, p) {
        PORT(unit, p).port_dscp_map_set = 0;
    }

#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        /* Get Initial SW port enable status from HW */
        PBMP_ITER(all_pbmp, p) {
            if (IS_E_PORT(unit, p)) {
                rv = bcm_esw_port_enable_get(unit, p, &enable);
                if (BCM_SUCCESS(rv)) {
                    PORT(unit, p).enable = enable;
                }
            }
        }
    }
#endif /* BCM_TRIDENT2_SUPPORT */

    PBMP_PORT_ITER(unit, p) {
        rv = bcm_esw_port_speed_get(unit, p, &p_speed);
        if (BCM_FAILURE(rv)) {
            continue;
        }
        _bcm_esw_port_link_delay_update(unit, p, p_speed);
    }

#if defined(BCM_TRIUMPH3_SUPPORT)
    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
        rv = _bcm_port_force_forward_init(unit);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
    }
#endif /*defined(BCM_TRIUMPH3_SUPPORT)*/

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* TH ASF */
    if (soc_feature(unit, soc_feature_asf_multimode)
#ifdef BCM_WARM_BOOT_SUPPORT
        && !SOC_WARM_BOOT(unit)
        /* WB recovery happens in _bcm_esw_port_wb_recover context */
#endif /* BCM_WARM_BOOT_SUPPORT */
       ) {
#ifdef BCM_MAVERICK2_SUPPORT
        if (SOC_IS_MAVERICK2(unit)) {
            BCM_IF_ERROR_RETURN(
                _bcm_esw_mv2_asf_init(unit, _SOC_MV2_ASF_MODE_INIT));
        } else
#endif
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            BCM_IF_ERROR_RETURN(
                _bcm_esw_td3_asf_init(unit, _SOC_TD3_ASF_MODE_INIT));
        } else
#endif
        {
            BCM_IF_ERROR_RETURN(
                _bcm_esw_asf_init(unit, _SOC_TH_ASF_MODE_INIT));
        }
    }
#endif

#if defined (BCM_EP_REDIRECT_VERSION_2)
    /* Mark the RDB port as loopback mode */
    if (soc_feature(unit, soc_feature_ep_redirect_v2)) {
        SOC_IF_ERROR_RETURN(soc_mem_field32_modify(unit, PORT_TABm,
                                       BCMI_EP_REDIRECT_PORT, PORT_TYPEf, 2));
    }
#endif

#ifdef BCM_PREEMPTION_SUPPORT
    if (soc_feature(unit, soc_feature_preemption_cnt)) {
        BCM_IF_ERROR_RETURN(bcmi_esw_preemption_counter_init(unit));
    }
#endif

#if defined(BCM_GREYHOUND_SUPPORT)
    if (soc_feature(unit, soc_feature_pktpri_as_dot1p)) {
        /*
         * The ref_cnt of system-wise treat packet priority as dot1p priority
         * for different packet types or port controls.
         */
        BCM_IF_ERROR_RETURN(
            bcmi_esw_port_treat_pktpri_as_dot1p_init(unit));
    }
#endif /* BCM_GREYHOUND_SUPPORT */

    if (SOC_WARM_BOOT(unit)) {
        return (_bcm_esw_port_wb_recover(unit));
    }
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_KATANA2_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT)
    else {
        if(SOC_IS_KATANA2(unit) || SOC_IS_TRIDENT2(unit) || SOC_IS_APACHE(unit)) {
            /*
             * Hardcoding the MMU_INTFI_ST_TRANS_TBL so the
             * congestion data is written as it is
             * in FC_ST_TABLE, This we are doing so that
             * congestion data is updated as it is how
             * it recevied
             */
            for (index=0 ; index < soc_mem_index_count(unit,
                        MMU_INTFI_ST_TRANS_TBLm); index++) {
                SOC_IF_ERROR_RETURN(READ_MMU_INTFI_ST_TRANS_TBLm(
                            unit, MEM_BLOCK_ALL,index,
                            &st_trans_entry));
                soc_mem_field32_set(unit, MMU_INTFI_ST_TRANS_TBLm,
                        &st_trans_entry, FC_ST_XLATEf,
                        index % (SOC_IS_KATANA2(unit) ? 256 : 16));
                SOC_IF_ERROR_RETURN(WRITE_MMU_INTFI_ST_TRANS_TBLm(
                            unit, MEM_BLOCK_ALL, index,
                            &st_trans_entry));
            }
        }
    }
#endif
#if defined(BCM_GREYHOUND2_SUPPORT)
    if (SOC_IS_GREYHOUND2(unit)) {
        if (soc_feature(unit, soc_feature_e2efc)) {
            bcmi_gh2_port_e2efc_remote_port_init(unit);
        }
    }
#endif /* BCM_GHREYHOUND2 */
    return (_bcm_esw_port_wb_alloc(unit));
}

/*
 * Function:
 *      bcm_port_clear
 * Purpose:
 *      Initialize the PORT interface layer for the specified SOC device
 *      without resetting stacking ports.
 * Parameters:
 *      unit - StrataSwitch unit number.
 * Returns:
 *      BCM_E_NONE - success (or already initialized)
 *      BCM_E_INTERNAL- failed to write PTABLE entries
 *      BCM_E_MEMORY - failed to allocate required memory.
 * Notes:
 *      By default ports come up enabled. They can be made to come up disabled
 *      at startup by a compile-time application policy flag in your Make.local
 *      A call to bcm_port_clear should exhibit similar behavior for
 *      non-stacking ethernet ports
 *      PTABLE initialized.
 */

int
bcm_esw_port_clear(int unit)
{
    bcm_port_config_t port_config;
    bcm_pbmp_t reset_ports;
    bcm_port_t port;
    int rv, port_enable;

    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(bcm_esw_port_config_get(unit, &port_config));

    /* Clear all non-stacking ethernet ports */
    BCM_PBMP_ASSIGN(reset_ports, port_config.e);
    BCM_PBMP_REMOVE(reset_ports, SOC_PBMP_STACK_CURRENT(unit));

    PBMP_ITER(reset_ports, port) {
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "bcm_port_clear: unit %d port %s\n"),
                     unit, SOC_PORT_NAME(unit, port)));

        PORT_LOCK(unit);
        if ((rv = _bcm_port_mode_setup(unit, port, TRUE)) < 0) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "Warning: Port %s: "
                                 "Failed to set initial mode: %s\n"),
                      SOC_PORT_NAME(unit, port), bcm_errmsg(rv)));
        }
        PORT_UNLOCK(unit);

#ifdef BCM_RCPU_SUPPORT
        if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, port)) {
            /* Do not enable/disable rcpu port. */
            continue;
        }
#endif /* BCM_RCPU_SUPPORT */

        /*
         * A compile-time application policy may prefer to disable
         * ports at startup. The same behavior should be observed
         * when bcm_port_clear gets called.
         */

#ifdef BCM_PORT_DEFAULT_DISABLE
            port_enable = FALSE;
#else
            port_enable = TRUE;
#endif  /* BCM_PORT_DEFAULT_DISABLE */


        if ((rv = bcm_esw_port_enable_set(unit, port, port_enable)) < 0) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "Warning: Port %s: "
                                 "Failed to %s port: %s\n"),
                      SOC_PORT_NAME(unit, port),(port_enable) ?\
                      "enable" : "disable" ,bcm_errmsg(rv)));
        }

    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_phy_probe
 * Purpose:
 *      Probe the phy and set up the phy of the indicated port
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      port - Port to probe
 *      okay - Output parameter indicates port can be enabled.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL - internal error.
 * Notes:
 *      If error is returned, the port should not be enabled.
 */
int
_bcm_port_phy_probe(int unit, bcm_port_t port, int *okay)
{
    int                 rv;
    bcm_pbmp_t pbmp;
    bcm_pbmp_t okay_pbmp;

    /* Check for PortMod */
    if(SOC_PORT_USE_PORTCTRL(unit, port)) {
        return BCM_E_UNAVAIL;
    }

    *okay = FALSE;

    LOG_VERBOSE(BSL_LS_BCM_PORT,
                (BSL_META_U(unit,
                            "Init port %d PHY...\n"), port));

    BCM_PBMP_CLEAR(okay_pbmp);
    BCM_PBMP_CLEAR(pbmp);
    BCM_PBMP_PORT_SET(pbmp, port);

    rv = soc_phyctrl_pbm_probe_init(unit,pbmp,&okay_pbmp);
    if (rv  != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_PORT, \
                  (BSL_META_U(unit, \
                              "Error unit %d:\
                              Failed port init probe: %s\n"),
                   unit, bcm_errmsg(rv)));
        return rv;
    }

    if (!SOC_WARM_BOOT(unit)) {
        /* Probe function should leave port disabled */
        if ((rv = soc_phyctrl_enable_set(unit, port, 0)) < 0) {
            return rv;
        }
    }

    *okay = TRUE;

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_mac_init
 * Purpose:
 *      Set up the mac of the indicated port
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      port - Port to setup
 *      okay - Output parameter indicates port can be enabled.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL - internal error.
 * Notes:
 *      If error is returned, the port should not be enabled.
 */
int
_bcm_port_mac_init(int unit, bcm_port_t port, int *okay)
{
    int                 rv;
    mac_driver_t        *macd;

    /* Check for PortMod */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return BCM_E_UNAVAIL;
    }

    *okay = FALSE;

    LOG_VERBOSE(BSL_LS_BCM_PORT,
                (BSL_META_U(unit,
                            "Init port %d MAC...\n"), port));

    if ((rv = soc_mac_probe(unit, port, &macd)) < 0) {
        LOG_WARN(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit,
                             "Port %s: Failed to probe MAC: %s\n"),
                  SOC_PORT_NAME(unit, port), soc_errmsg(rv)));
        return rv;
    }

    PORT(unit, port).p_mac = macd;

    if (!SOC_WARM_BOOT(unit) && !SOC_IS_RELOADING(unit)) {

#ifdef BCM_RCPU_SUPPORT
        if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, port)) {
            *okay = TRUE;
            return BCM_E_NONE;
        }
#endif /* BCM_RCPU_SUPPORT */

        if ((rv = MAC_INIT(PORT(unit, port).p_mac, unit, port)) < 0) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "Port %s: Failed to initialize MAC: %s\n"),
                      SOC_PORT_NAME(unit, port), soc_errmsg(rv)));
            return rv;
        }

        /* Probe function should leave port disabled */
        if ((rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, 0)) < 0) {
            return rv;
        }
    }

    *okay = TRUE;

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_probe
 * Purpose:
 *      Probe the phy and set up the phy and mac of the indicated port
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      port - Port to probe
 *      okay - Output parameter indicates port can be enabled.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL - internal error.
 * Notes:
 *      If error is returned, the port should not be enabled.
 */

int
_bcm_port_probe(int unit, bcm_port_t port, int *okay)
{
    /* Check for PortMod */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_probe(unit, port, 0, NULL, okay);
    }

    BCM_IF_ERROR_RETURN(_bcm_port_phy_probe(unit, port, okay));

    /*
     * Currently initializing MAC after PHY is required because of
     * phy_5690_notify_init().
     */
    BCM_IF_ERROR_RETURN(_bcm_port_mac_init(unit, port, okay));

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_probe
 * Purpose:
 *      Probe the PHY and set up the PHY and MAC for the specified ports.
 *      This is purely a discovery routine and does no configuration.
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      pbmp - Bitmap of ports to probe.
 *      okay_pbmp (OUT) - Ports which were successfully probed.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL - internal error.
 * Notes:
 *      If error is returned, the port should not be enabled.
 *      Assumes port_init done.
 *      Note that if a PHY is not present, the port will still probe
 *      successfully.  The default driver will be installed.
 */
int
bcm_esw_port_probe(int unit, pbmp_t pbmp, pbmp_t *okay_pbmp)
{
    int rv = BCM_E_NONE;
    bcm_port_t port;
    int okay;
    int skip_mac_reset = 0;
    soc_persist_t      *sop;
#ifdef BCM_TRIDENT_SUPPORT
    int port_speed;
    soc_port_ability_t mac_ability;
#endif
    pbmp_t pbmp_portmod;
    pbmp_t pbmp_legacy;
    pbmp_t okay_pbmp_portmod;
    pbmp_t okay_pbmp_legacy;

    SOC_PBMP_CLEAR(*okay_pbmp);

    PORT_INIT(unit);
    PORT_LOCK(unit);

    SOC_PBMP_CLEAR(pbmp_portmod);
    SOC_PBMP_CLEAR(pbmp_legacy);
    SOC_PBMP_CLEAR(okay_pbmp_portmod);
    SOC_PBMP_CLEAR(okay_pbmp_legacy);
    if (SOC_USE_PORTCTRL(unit)) {
#ifdef BCM_HURRICANE4_SUPPORT
        if (SOC_IS_HURRICANE4(unit)) {
            PBMP_ITER(pbmp, port) {
                if (SOC_PORT_USE_PORTCTRL(unit, port)) {
                    SOC_PBMP_PORT_ADD(pbmp_portmod, port);
                } else {
                    SOC_PBMP_PORT_ADD(pbmp_legacy, port);
                }
            }
        } else
#endif
        {
            SOC_PBMP_ASSIGN(pbmp_portmod, pbmp);
        }
    } else {
        SOC_PBMP_ASSIGN(pbmp_legacy, pbmp);
    }

#ifdef BCM_TOMAHAWK2_SUPPORT
    if (SOC_IS_TOMAHAWK2(unit)) {
        rv = bcmi_th2_tsc_xgxs_reset(unit, pbmp);
        if (SOC_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
    } else
#endif /* BCM_TOMAHAWK2_SUPPORT */
    {
#ifdef BCM_TRIDENT2_SUPPORT
        if (SOC_IS_TD2_TT2(unit)) {
            soc_info_t *si;
            uint32 tsc_map, reset_tsc_map;
            int tsc, ports[32];

            si = &SOC_INFO(unit);
            /* Construct tsc_map covered by the specified pbmp */
            tsc_map = 0;
            PBMP_ITER(pbmp, port) {
                tsc = si->port_serdes[port];
                if (tsc != -1) {
                    tsc_map |= 1 << tsc;
                }
            }

            reset_tsc_map = 0;
            PBMP_PORT_ITER(unit, port) {
                tsc = si->port_serdes[port];
#ifdef BCM_HURRICANE4_SUPPORT
                /* No TSC for EGPHY */
                if (SOC_IS_HURRICANE4(unit) && IS_EGPHY_PORT(unit, port)) {
                    continue;
                }
#endif
                if (tsc_map & (1 << tsc)) {
                    if (PORT(unit, port).flags & _PORT_INFO_PROBE_RESET_SERDES) {
                        PORT(unit, port).flags &= ~_PORT_INFO_PROBE_RESET_SERDES;
                        reset_tsc_map |= 1 << tsc;
                        ports[tsc] = port;
                    }
                }
            }
        for (tsc = 0; tsc < 32; tsc++) {
            if (reset_tsc_map & (1 << tsc)) {
                rv = soc_tsc_xgxs_reset(unit, ports[tsc], 0);
                if (SOC_FAILURE(rv)) {
                    PORT_UNLOCK(unit);
                    return (rv);
                }
            }
        }
    }
#endif /* BCM_TRIDENT2_SUPPORT */
    }
#if defined(BCM_SABER2_SUPPORT)
    /* If OAMP is enabled by default, skip the port init for oamp port */
    if(SOC_IS_SABER2(unit)) {
        int oamp_enable;
        (void)bcm_sb2_sat_oamp_enable_get(unit, &oamp_enable);

        if (soc_feature(unit, soc_feature_sat) &&
            ((!SOC_WARM_BOOT(unit) &&
                soc_property_get(unit, spn_SAT_ENABLE, 0)) ||
             (SOC_WARM_BOOT(unit) && (oamp_enable == TRUE)))) {
            SOC_PBMP_PORT_REMOVE(pbmp, _BCM_SB2_SAT_OAMP_PHY_PORT_NUMBER);
            SOC_PBMP_PORT_REMOVE(*okay_pbmp,
                    _BCM_SB2_SAT_OAMP_PHY_PORT_NUMBER);
        }
    }
#endif
    /* Check for PortMod */
    if (SOC_USE_PORTCTRL(unit) && SOC_PBMP_NOT_NULL(pbmp_portmod)) {
        rv = bcmi_esw_portctrl_probe_pbmp(unit, pbmp_portmod, &okay_pbmp_portmod);
        SOC_PBMP_OR((*okay_pbmp), okay_pbmp_portmod);
        if (SOC_FAILURE(rv) || SOC_PBMP_IS_NULL(pbmp_legacy)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
    }

    rv = soc_phyctrl_pbm_probe_init(unit,pbmp_legacy,&okay_pbmp_legacy);
    if (!SOC_WARM_BOOT(unit)) {
        PBMP_ITER(okay_pbmp_legacy, port) {
            /* Probe function should leave port disabled */
            if ((rv = soc_phyctrl_enable_set(unit, port, 0)) < 0) {
                break;
            }
        }
    }
    if (soc_property_get(unit, spn_SAME_SPEED_INTF_DO_NOT_OVERWRITE,
                         (SAL_BOOT_BCMSIM || SAL_BOOT_XGSSIM))) {
        PBMP_ITER(okay_pbmp_legacy, port) {
            if ((rv = bcm_esw_port_interface_get(unit, port, &(PORT(unit, port).intf))) < 0) {
                PORT(unit, port).intf = 0;
                continue;
            }
        }
    }

    if (SOC_IS_GREYHOUND(unit) || SOC_IS_SABER2(unit) ||
        SOC_IS_TOMAHAWKX(unit) || SOC_IS_APACHE(unit) ||
        SOC_IS_HURRICANE4(unit)) {
        /* XLPORT_MAC_CONTROLr.XMAC0_RESETf has been toggled duirng soc_reset */
        skip_mac_reset = 1;
    }

    if (SOC_REG_IS_VALID(unit, GPORT_UMAC_CONTROLr)) {
        int blk;
        uint32 rval;
        pbmp_t block_pbmp;
        int port_blk_index;
        int i;

        SOC_BLOCK_ITER(unit, blk, SOC_BLK_GPORT) {
            rval = 0;
            BCM_PBMP_ASSIGN(block_pbmp, SOC_BLOCK_BITMAP(unit, blk));
            BCM_PBMP_AND(block_pbmp, pbmp);
            if (BCM_PBMP_IS_NULL(block_pbmp)) {
                continue;
            }

            /* get the port number */
            SOC_PBMP_ITER(block_pbmp, i)
            {
               /* get the index of the port in blk*/
               port_blk_index = SOC_PORT_BLOCK_INDEX(unit, i);
               rval |= 1 << port_blk_index;
            }

            port = SOC_BLOCK_PORT(unit, blk);
            /* just Write.. No need for RMW as no other field is there.. */
            /* (void)READ_GPORT_UMAC_CONTROLr(unit, port, &rval); */
            /* Set UMAC0_RESETf..UMAC7_RESETf */
#ifdef BCM_RCPU_SUPPORT
            if (SOC_IS_RCPU_ONLY(unit) &&
                SOC_PORT_VALID(unit, RCPU_PORT(unit)) &&
                BCM_PBMP_MEMBER(block_pbmp, RCPU_PORT(unit))) {
                rval &= ~ (1 << SOC_PORT_BLOCK_INDEX(unit, RCPU_PORT(unit)));
            }
#endif /* BCM_RCPU_SUPPORT */
            (void)WRITE_GPORT_UMAC_CONTROLr(unit, port, rval);
            sal_udelay(10);
            rval = 0; /* Reset UMAC0_RESETf..UMAC7_RESETf */
            (void)WRITE_GPORT_UMAC_CONTROLr(unit, port, rval);
        }
    }

    if (SOC_REG_IS_VALID(unit, XLPORT_MAC_CONTROLr) && !skip_mac_reset) {
        int blk, port;

        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
            port = SOC_BLOCK_PORT(unit, blk);
            if (port == -1) {
                continue;
            }

            if (SOC_INFO(unit).port_speed_max[port] >= 100000) {
                continue;
            }

            /* Reset the entire block only if it is called from port init */
            if (PORT(unit, port).p_mac != NULL) {
                continue;
            }

#ifdef BCM_RCPU_SUPPORT
            if (SOC_IS_RCPU_ONLY(unit) &&
                SOC_PORT_VALID(unit, RCPU_PORT(unit)) &&
                BCM_PBMP_MEMBER(SOC_BLOCK_BITMAP(unit, blk), RCPU_PORT(unit))) {
                continue;
            }
#endif /* BCM_RCPU_SUPPORT */

            _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                (soc_reg_field32_modify(unit, XLPORT_MAC_CONTROLr, port,
                                        XMAC0_RESETf, 1));
            sal_udelay(10);
            _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                (soc_reg_field32_modify(unit, XLPORT_MAC_CONTROLr, port,
                                        XMAC0_RESETf, 0));
            if (soc_feature (unit, soc_feature_xlmac_timestamp_disable)) {
                if (soc_reg_field_valid(unit, XLPORT_MAC_CONTROLr, XLMAC_TS_DISABLEf)) {
                    /* Disable MAC timestamp by default */
                    _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                        (soc_reg_field32_modify(unit, XLPORT_MAC_CONTROLr, port,
                                                XLMAC_TS_DISABLEf, 1));
                }
            }
        }
    }

    if (SOC_REG_IS_VALID(unit, GPORT_UMAC_CONTROLr)) {
        int blk, port;

        SOC_BLOCK_ITER(unit, blk, SOC_BLK_CPORT) {
            port = SOC_BLOCK_PORT(unit, blk);
            if (port == -1) {
                continue;
            }

            if (SOC_INFO(unit).port_speed_max[port] < 100000) {
                continue;
            }

            /* Reset the entire block only if it is called from port init */
            if (PORT(unit, port).p_mac != NULL) {
                continue;
            }

#ifdef BCM_RCPU_SUPPORT
            if (SOC_IS_RCPU_ONLY(unit) &&
                SOC_PORT_VALID(unit, RCPU_PORT(unit)) &&
                BCM_PBMP_MEMBER(SOC_BLOCK_BITMAP(unit, blk), RCPU_PORT(unit))) {
                continue;
            }
#endif /* BCM_RCPU_SUPPORT */

            _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                (soc_reg_field32_modify(unit, CPORT_MAC_CONTROLr, port,
                                        CMAC_RESETf, 1));
            if (SOC_REG_IS_VALID(unit, CPORT_SOFT_RESETr)) {
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                 (soc_reg_field32_modify(unit, CPORT_SOFT_RESETr, port,
                                        CPORT_COREf, 1));
            }
            sal_udelay(10);
            if (SOC_REG_IS_VALID(unit, CPORT_SOFT_RESETr)) {
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                 (soc_reg_field32_modify(unit, CPORT_SOFT_RESETr, port,
                                        CPORT_COREf, 0));
            }
            _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                (soc_reg_field32_modify(unit, CPORT_MAC_CONTROLr, port,
                                        CMAC_RESETf, 0));
        }
    }

    if (SOC_REG_IS_VALID(unit, XLPORT_XMAC_CONTROLr)) {
        int blk;
        uint32 rval;
        pbmp_t block_pbmp;

        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
            BCM_PBMP_ASSIGN(block_pbmp, SOC_BLOCK_BITMAP(unit, blk));
            BCM_PBMP_AND(block_pbmp, pbmp);
            if (BCM_PBMP_IS_NULL(block_pbmp)) {
                continue;
            }

            port = SOC_BLOCK_PORT(unit, blk);

            /* Reset the entire block only if it is called from port init */
            if (PORT(unit, port).p_mac != NULL) {
                continue;
            }

#ifdef BCM_RCPU_SUPPORT
            if (SOC_IS_RCPU_ONLY(unit) &&
                SOC_PORT_VALID(unit, RCPU_PORT(unit)) &&
                BCM_PBMP_MEMBER(block_pbmp, RCPU_PORT(unit))) {
                continue;
            }
#endif /* BCM_RCPU_SUPPORT */

            (void)READ_XLPORT_XMAC_CONTROLr(unit, port, &rval);
            soc_reg_field_set(unit, XLPORT_XMAC_CONTROLr, &rval, XMAC_RESETf,
                              1);
            (void)WRITE_XLPORT_XMAC_CONTROLr(unit, port, rval);
            sal_udelay(10);

            soc_reg_field_set(unit, XLPORT_XMAC_CONTROLr, &rval, XMAC_RESETf,
                              0);
            (void)WRITE_XLPORT_XMAC_CONTROLr(unit, port, rval);
        }
    }
#ifdef BCM_SHADOW_SUPPORT
    /* Interlaken need to be taken out of reset after PHY is initialized */
    if (SOC_IS_SHADOW(unit)) {
        int active_il = 0;
        uint32 rval;

        if (soc_property_get(unit, spn_BCM88732_2X40_1X40, 0) ||
            soc_property_get(unit, spn_BCM88732_8X10_1X40, 0)) {
            active_il = 1;
        } else {
            if (soc_property_get(unit, spn_BCM88732_1X40_4X10, 0) ||
                soc_property_get(unit, spn_BCM88732_4X10_4X10, 0) ||
                soc_property_get(unit, spn_BCM88732_2X40_2X40, 0) ||
                soc_property_get(unit, spn_BCM88732_2X40_8X12, 0) ||
                soc_property_get(unit, spn_BCM88732_8X10_8X12, 0) ||
                soc_property_get(unit, spn_BCM88732_2X40_8X10, 0) ||
                soc_property_get(unit, spn_BCM88732_8X10_8X10, 0) ||
                soc_property_get(unit, spn_BCM88732_8X10_4X12, 0) ||
                soc_property_get(unit, spn_BCM88732_8X10_2X12, 0) ||
                soc_property_get(unit, spn_BCM88732_1X40_4X10_8X12, 0) ||
                soc_property_get(unit, spn_BCM88732_4X10_1X40_8X12, 0) ||
                soc_property_get(unit, spn_BCM88732_6X10_2X12, 0)) {
                active_il = 0;
            } else {
                active_il = 2;
            }
        }
        if (active_il) {
            _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                (READ_IL_GLOBAL_CONTROLr(unit, 9, &rval));
            soc_reg_field_set(unit, IL_GLOBAL_CONTROLr, &rval, SOFT_RESETf, 0);
            _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                (WRITE_IL_GLOBAL_CONTROLr(unit, 9, rval));
        }
        if (active_il == 2) {
            _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                (READ_IL_GLOBAL_CONTROLr(unit, 13, &rval));
            soc_reg_field_set(unit, IL_GLOBAL_CONTROLr, &rval, SOFT_RESETf, 0);
            _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                (WRITE_IL_GLOBAL_CONTROLr(unit, 13, rval));
        }
    }
#endif /* BCM_SHADOW_SUPPORT */

    if (SOC_REG_IS_VALID(unit, XPORT_XMAC_CONTROLr)) {
        int blk;
        uint32 rval;
        pbmp_t block_pbmp;

        SOC_BLOCK_ITER(unit, blk, SOC_BLK_MXQPORT) {
            BCM_PBMP_ASSIGN(block_pbmp, SOC_BLOCK_BITMAP(unit, blk));
            BCM_PBMP_AND(block_pbmp, pbmp);
            if (BCM_PBMP_IS_NULL(block_pbmp)) {
                continue;
            }

            port = SOC_BLOCK_PORT(unit, blk);

            /* Reset the entire block only if it is called from port init */
            if (PORT(unit, port).p_mac != NULL) {
                continue;
            }

#ifdef BCM_RCPU_SUPPORT
            if (SOC_IS_RCPU_ONLY(unit) &&
                SOC_PORT_VALID(unit, RCPU_PORT(unit)) &&
                BCM_PBMP_MEMBER(block_pbmp, RCPU_PORT(unit))) {
                continue;
            }
#endif /* BCM_RCPU_SUPPORT */

            (void)READ_XPORT_XMAC_CONTROLr(unit, port, &rval);
            soc_reg_field_set(unit, XPORT_XMAC_CONTROLr, &rval, XMAC_RESETf,
                              1);
            (void)WRITE_XPORT_XMAC_CONTROLr(unit, port, rval);
            sal_udelay(10);

            soc_reg_field_set(unit, XPORT_XMAC_CONTROLr, &rval, XMAC_RESETf,
                              0);
            (void)WRITE_XPORT_XMAC_CONTROLr(unit, port, rval);
        }
    }

#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        uint8 rev_id;
        uint16 dev_id;
        soc_info_t *si;
        soc_port_t port;
        int phy, lane, blk, block_has_ports, high_speed_port;
        uint32 rval;

        si = &SOC_INFO(unit);
        soc_cm_get_id(unit, &dev_id, &rev_id);
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_CLPORT) {
            block_has_ports = FALSE;
            high_speed_port = -1;
            for (phy = 0; phy < _SOC_TR3_PHY_PER_PORT_BLOCK; phy++) {
                for (lane = 0; lane < _SOC_TR3_LANES_PER_PHY; lane++) {
                    port = si->port_p2l_mapping[si->blk_fpp[blk] +
                               ((phy * _SOC_TR3_LANES_PER_PHY) + lane)];
                    /* coverity[overrun-local : FALSE] */
                    if (SOC_PORT_VALID(unit, port) &&
                        si->port_speed_max[port] >= 100000) {
                        /* Save the 100G+ speed port becuase we must
                         * init the other two PHYs, even though they don't
                         * match a valid port. */
                        high_speed_port = port;
                    } else if (high_speed_port >= 0) {
                        port = high_speed_port;
                    }
                    if (SOC_PORT_VALID(unit, port)) {
                        block_has_ports |= 1 << phy;
                        break; /* Only need to reset PHY once */
                    }
                }
            }
            if (!block_has_ports) {
                continue; /* All ports disabled */
            }
            port = SOC_BLOCK_PORT(unit, blk);

            /* Reset only when called from port init */
            if (PORT(unit, port).p_mac != NULL) {
                continue;
            }

            rv = READ_PORT_MAC_CONTROLr(unit, port, &rval);
            if (SOC_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
            if ((soc_feature(unit, soc_feature_cmac)) && (high_speed_port >= 0)) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  CMAC_RESETf, 1);
            }
            if (block_has_ports & 1) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  XMAC0_RESETf, 1);
            }
            if (block_has_ports & 2) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  XMAC1_RESETf, 1);
            }
            if (block_has_ports & 4) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  XMAC2_RESETf, 1);
            }
            rv = WRITE_PORT_MAC_CONTROLr(unit, port, rval);
            if (SOC_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }

            sal_udelay(10);
            if ((soc_feature(unit, soc_feature_cmac)) && (high_speed_port >= 0)) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  CMAC_RESETf, 0);
            }
            if (block_has_ports & 1) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  XMAC0_RESETf, 0);
            }
            if (block_has_ports & 2) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  XMAC1_RESETf, 0);
            }
            if (block_has_ports & 4) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  XMAC2_RESETf, 0);
            }
            rv = WRITE_PORT_MAC_CONTROLr(unit, port, rval);
            if (SOC_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
        }
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XTPORT) {
            block_has_ports = FALSE;
            for (phy = 0; phy < _SOC_TR3_PHY_PER_PORT_BLOCK; phy++) {
                for (lane = 0; lane < _SOC_TR3_LANES_PER_PHY; lane++) {
                    port = si->port_p2l_mapping[si->blk_fpp[blk] +
                               ((phy * _SOC_TR3_LANES_PER_PHY) + lane)];
                    if (SOC_PORT_VALID(unit, port)) {
                        block_has_ports |= 1 << phy;
                        break; /* Only need to reset PHY once */
                    }
                }
            }
            if (!block_has_ports) {
                continue; /* All ports disabled */
            }
            port = SOC_BLOCK_PORT(unit, blk);

            /* Reset only when called from port init */
            if (PORT(unit, port).p_mac != NULL) {
                continue;
            }

            rv = READ_PORT_MAC_CONTROLr(unit, port, &rval);
            if (SOC_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
            if (block_has_ports & 1) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  XMAC0_RESETf, 1);
            }
            if (block_has_ports & 2) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  XMAC1_RESETf, 1);
            }
            if (block_has_ports & 4) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  XMAC2_RESETf, 1);
            }
            rv = WRITE_PORT_MAC_CONTROLr(unit, port, rval);
            if (SOC_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
            sal_udelay(10);
            if (block_has_ports & 1) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  XMAC0_RESETf, 0);
            }
            if (block_has_ports & 2) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  XMAC1_RESETf, 0);
            }
            if (block_has_ports & 4) {
                soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                                  XMAC2_RESETf, 0);
            }
            rv = WRITE_PORT_MAC_CONTROLr(unit, port, rval);
            if (SOC_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
        }
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
            block_has_ports = FALSE;
            /* Only one PHY per XLPORT */
            for (lane = 0; lane < _SOC_TR3_LANES_PER_PHY; lane++) {
                port = si->port_p2l_mapping[si->blk_fpp[blk] + lane];
                if (SOC_PORT_VALID(unit, port)) {
                    block_has_ports = TRUE;
                    break;
                }
            }
            if (!block_has_ports) {
                continue; /* All ports disabled */
            }
            port = SOC_BLOCK_PORT(unit, blk);

            /* Reset only when called from port init */
            if (PORT(unit, port).p_mac != NULL) {
                continue;
            }

            rv = READ_PORT_MAC_CONTROLr(unit, port, &rval);
            if (SOC_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
            soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                              XMAC0_RESETf, 1);
            rv = WRITE_PORT_MAC_CONTROLr(unit, port, rval);
            if (SOC_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
            sal_udelay(10);
            soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                              XMAC0_RESETf, 0);
            rv = WRITE_PORT_MAC_CONTROLr(unit, port, rval);
            if (SOC_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
        }
#ifdef BCM_HELIX4_SUPPORT
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XWPORT) {
            block_has_ports = FALSE;
            /* Only one PHY per XWPORT */
            for (lane = 0; lane < _SOC_TR3_LANES_PER_PHY; lane++) {
                port = si->port_p2l_mapping[si->blk_fpp[blk] + lane];
                if (SOC_PORT_VALID(unit, port)) {
                    block_has_ports = TRUE;
                    break;
                }
            }
            if (!block_has_ports) {
                continue; /* All ports disabled */
            }
            port = SOC_BLOCK_PORT(unit, blk);

            /* Reset only when called from port init */
            if (PORT(unit, port).p_mac != NULL) {
                continue;
            }

            rv = READ_PORT_MAC_CONTROLr(unit, port, &rval);
            if (SOC_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
            soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                              XMAC0_RESETf, 1);
            rv = WRITE_PORT_MAC_CONTROLr(unit, port, rval);
            if (SOC_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
            sal_udelay(10);
            soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                              XMAC0_RESETf, 0);
            rv = WRITE_PORT_MAC_CONTROLr(unit, port, rval);
            if (SOC_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
        }
#endif /* BCM_HELIX4_SUPPORT */
    }
#endif /* BCM_TRIUMPH3_SUPPORT */

    PBMP_ITER(pbmp_legacy, port) {
        if (!(IS_TDM_PORT(unit, port)) &&
            !SOC_PORT_USE_PORTCTRL(unit, port)) {
            rv = _bcm_port_mac_init(unit, port, &okay);

            if (!okay) {
                SOC_PBMP_PORT_REMOVE(okay_pbmp_legacy, port);
#if defined(BCM_ESW_SUPPORT)
                soc_counter_port_pbmp_remove(unit, port);
#endif
            }
            if (rv < 0) {
                LOG_WARN(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "MAC init failed on port %s\n"),
                         SOC_PORT_NAME(unit, port)));
                break;
            }

#ifdef BCM_TRIDENT_SUPPORT
            if (SOC_IS_TD_TT(unit) &&
               (!SOC_PBMP_MEMBER(SOC_INFO(unit).all.disabled_bitmap, port)) &&
               (!(SOC_IS_HURRICANE4(unit) && SOC_WARM_BOOT(unit)))) {
                soc_ipg_t *si;
                int ifg, duplex;

                rv = MAC_DUPLEX_GET(PORT(unit, port).p_mac, unit, port, &duplex);
                if (rv < 0) {
                    LOG_WARN(BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                        "MAC_DUPLEX_GET failed on port %s\n"),
                             SOC_PORT_NAME(unit, port)));
                    break;
                }

                si = &SOC_PERSIST(unit)->ipg[port];
                if (IS_HG_PORT(unit, port)) {
                    ifg = si->fd_hg = SOC_AVERAGE_IPG_HG;
                } else {
                    ifg = si->fd_xe = SOC_AVERAGE_IPG_IEEE;
                }

                if (SOC_IS_TOMAHAWKX(unit) || SOC_IS_HURRICANE4(unit)) {
                    port_speed = (0 != SOC_INFO(unit).port_init_speed[port]) ?
                        SOC_INFO(unit).port_init_speed[port] : SOC_INFO(unit).port_speed_max[port];
                } else if (SOC_IS_TRIDENT2(unit)) {
                    sal_memset(&mac_ability, 0, sizeof(soc_port_ability_t));
                    rv = MAC_ABILITY_LOCAL_GET(PORT(unit, port).p_mac, unit, port,
                            &mac_ability);
                    if (rv < 0) {
                        LOG_WARN(BSL_LS_BCM_PORT,
                                (BSL_META_U(unit,
                                            "MAC_ABILITY_LOCAL_GET failed on port %s\n"),
                                 SOC_PORT_NAME(unit, port)));
                        break;
                    }
                    port_speed = BCM_PORT_ABILITY_SPEED_MAX(mac_ability.speed_full_duplex);
                } else {
                    port_speed = SOC_INFO(unit).port_speed_max[port];
                }

                rv = MAC_IFG_SET(PORT(unit, port).p_mac, unit, port,
                        port_speed, duplex, ifg);
                if (rv < 0) {
                    LOG_WARN(BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                        "MAC_IFG_SET failed on port %s\n"),
                             SOC_PORT_NAME(unit, port)));
                    break;
                }
            }
#endif
#ifdef BCM_HURRICANE4_SUPPORT
            if (SOC_IS_HURRICANE4(unit) && (!SOC_WARM_BOOT(unit))) {
                rv = MAC_FRAME_MAX_SET(PORT(unit, port).p_mac,
                                       unit, port, SOC_INFO(unit).max_mtu);
                if (rv < 0) {
                    LOG_WARN(BSL_LS_BCM_PORT,
                             (BSL_META_U(unit,
                                         "MAC_FRAME_MAX_SET failed on port %s\n"),
                              SOC_PORT_NAME(unit, port)));
                    break;
                }
            }
#endif
        }

        /* This is needed for run-time probing */
        sop = SOC_PERSIST(unit);
        if (soc_property_port_get(unit, port, spn_FCMAP_ENABLE, 0)) {
            SOC_PBMP_PORT_ADD(sop->lc_pbm_fc, port);
        } else {
            SOC_PBMP_PORT_REMOVE(sop->lc_pbm_fc, port);
        }

        /* Check if the external phy is set in EBE/EtherRAM buffer mode */
        if (soc_property_port_get(unit, port, spn_PHY_OPERATIONAL_MODE, 0) == 3) {
            SOC_PBMP_PORT_ADD(sop->lc_pbm_eth_buffer_mode, port);
        } else {
            SOC_PBMP_PORT_REMOVE(sop->lc_pbm_eth_buffer_mode, port);
        }

    }

    SOC_PBMP_OR((*okay_pbmp), okay_pbmp_legacy);

    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      _bcm_port_detach
 * Purpose:
 *      Main part of bcm_port_detach
 */

int
_bcm_port_detach(int unit, pbmp_t pbmp, pbmp_t *detached)
{
    bcm_port_t          port;
    int                 rv;
    soc_persist_t       *sop = SOC_PERSIST(unit);

    SOC_PBMP_CLEAR(*detached);

    PBMP_ITER(pbmp, port) {
        BCM_IF_ERROR_RETURN(bcm_esw_port_stp_set(unit, port, BCM_STG_STP_DISABLE));
        PORT_LOCK(unit);
        rv = _bcm_port_mode_setup(unit, port, FALSE);
        PORT_UNLOCK(unit);
        BCM_IF_ERROR_RETURN(rv);
        SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, port));
        SOC_PBMP_PORT_ADD(*detached, port);

        if (SOC_PBMP_MEMBER(sop->lc_pbm_fc, port)) {
            /* Bring down the internal PHY */
            rv = bcm_esw_port_update(unit, port, FALSE);
            BCM_IF_ERROR_RETURN(rv);
            SOC_PBMP_PORT_REMOVE(sop->lc_pbm_fc, port);
        }
    }
#ifdef BCM_TRIUMPH2_SUPPORT
    if (soc_feature(unit, soc_feature_vpd_profile)) {
        _bcm_tr2_port_vpd_bitmap_free(unit);
    }
#endif
    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_detach
 * Purpose:
 *      Detach a port.  Set phy driver to no connection.
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      pbmp - Bitmap of ports to detach.
 *      detached (OUT) - Bitmap of ports successfully detached.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL - internal error.
 * Notes:
 *      If a port to be detached does not appear in detached, its
 *      state is not defined.
 */

int
bcm_esw_port_detach(int unit, pbmp_t pbmp, pbmp_t *detached)
{
    int         rv;
#ifdef  BROADCOM_DEBUG
    char        pfmtp[SOC_PBMP_FMT_LEN],
                pfmtd[SOC_PBMP_FMT_LEN];
#endif  /* BROADCOM_DEBUG */
    pbmp_t pbmp_portmod;
    pbmp_t pbmp_legacy;
    pbmp_t detached_portmod;
    pbmp_t detached_legacy;

    PORT_INIT(unit);

    if (detached == NULL) {
        return BCM_E_PARAM;
    }

    SOC_PBMP_CLEAR(pbmp_portmod);
    SOC_PBMP_CLEAR(pbmp_legacy);
    SOC_PBMP_CLEAR(detached_portmod);
    SOC_PBMP_CLEAR(detached_legacy);
    SOC_PBMP_CLEAR(*detached);

    if (SOC_USE_PORTCTRL(unit)) {
#ifdef BCM_HURRICANE4_SUPPORT
        if (SOC_IS_HURRICANE4(unit)) {
            bcm_port_t port;
            PBMP_ITER(pbmp, port) {
                if (SOC_PORT_USE_PORTCTRL(unit, port)) {
                    SOC_PBMP_PORT_ADD(pbmp_portmod, port);
                } else {
                    SOC_PBMP_PORT_ADD(pbmp_legacy, port);
                }
            }
        } else
#endif
        {
            SOC_PBMP_ASSIGN(pbmp_portmod, pbmp);
        }
    } else {
        SOC_PBMP_ASSIGN(pbmp_legacy, pbmp);
    }

    if (SOC_USE_PORTCTRL(unit) && SOC_PBMP_NOT_NULL(pbmp_portmod)) {
        rv = bcmi_esw_portctrl_detach(unit, pbmp_portmod, &detached_portmod);
        SOC_PBMP_OR((*detached), detached_portmod);
        if (SOC_FAILURE(rv) || SOC_PBMP_IS_NULL(pbmp_legacy)) {
            return (rv);
        }
    }

    PORT_LOCK(unit);
    rv = _bcm_port_detach(unit, pbmp_legacy, &detached_legacy);
    PORT_UNLOCK(unit);
    SOC_PBMP_OR((*detached), detached_legacy);
#ifdef  BROADCOM_DEBUG
    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_detach: u=%d pbmp=%s det=%s rv=%d\n"),
                         unit,
              SOC_PBMP_FMT(pbmp, pfmtp),
              SOC_PBMP_FMT(*detached, pfmtd),
              rv));
#endif
    return rv;
}

/*
 * Function:
 *      bcm_port_config_get
 * Purpose:
 *      Get port configuration of a device
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      config - (OUT) Structure returning configuration
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_config_get(int unit, bcm_port_config_t *config)
{
    int i;

    PORT_INIT(unit);
    PORT_LOCK(unit);

    config->fe          = PBMP_FE_ALL(unit);
    config->ge          = PBMP_GE_ALL(unit);
    config->xe          = PBMP_XE_ALL(unit);
    config->ce          = PBMP_CE_ALL(unit);
    config->cd          = PBMP_CDE_ALL(unit);
    config->e           = PBMP_E_ALL(unit);
    config->hg          = PBMP_HG_ALL(unit);
    config->tdm         = PBMP_TDM_ALL(unit);
    config->port        = PBMP_PORT_ALL(unit);
    config->cpu         = PBMP_CMIC(unit);
    config->roe         = PBMP_ROE_ALL(unit);
    config->all         = PBMP_ALL(unit);
    /* Remove LB and RDB port from the PBMP_ALL bitmap for backward compatibility */
    SOC_PBMP_REMOVE(config->all, PBMP_LB(unit));
    SOC_PBMP_REMOVE(config->all, PBMP_RDB_ALL(unit));
    SOC_PBMP_REMOVE(config->all, PBMP_FAE_ALL(unit));
#if defined(BCM_MONTEREY_SUPPORT) || defined(BCM_HURRICANE4_SUPPORT)
    if (SOC_IS_MONTEREY(unit) || SOC_IS_HURRICANE4(unit)) {
        SOC_PBMP_REMOVE(config->all, PBMP_MACSEC_ALL(unit));
    }
#endif
    config->stack_ext   = PBMP_ST_ALL(unit);


    BCM_PBMP_CLEAR(config->stack_int);
    BCM_PBMP_CLEAR(config->sci);
    BCM_PBMP_CLEAR(config->sfi);
    BCM_PBMP_CLEAR(config->spi);
    BCM_PBMP_CLEAR(config->spi_subport);

    for (i = 0; i < NUM_PIPE(unit); i++) {
        config->per_pipe[i] = PBMP_PIPE(unit, i);
        SOC_PBMP_REMOVE(config->per_pipe[i], PBMP_LB(unit));
        SOC_PBMP_REMOVE(config->per_pipe[i], PBMP_RDB_ALL(unit));
        SOC_PBMP_REMOVE(config->per_pipe[i], PBMP_FAE_ALL(unit));
#if defined(BCM_MONTEREY_SUPPORT) || defined(BCM_HURRICANE4_SUPPORT)
        if (SOC_IS_MONTEREY(unit) || SOC_IS_HURRICANE4(unit)) {
            SOC_PBMP_REMOVE(config->per_pipe[i], PBMP_MACSEC_ALL(unit));
        }
#endif
    }

#if defined(BCM_SABER2_SUPPORT)
    /* Remove OAMP port from port config list */
    if(SOC_IS_SABER2(unit)) {
        soc_info_t *si = &SOC_INFO(unit);
        bcm_port_t oamp_port = _BCM_SB2_SAT_OAMP_PHY_PORT_NUMBER;

        if(bcm_common_oamp_port_enable_get(unit, oamp_port)) {
            SOC_PBMP_PORT_REMOVE(config->port, oamp_port);
            SOC_PBMP_PORT_REMOVE(config->e, oamp_port);

            if(si->port_speed_max[oamp_port] < 10000) {
                SOC_PBMP_PORT_REMOVE(config->ge, oamp_port);
            } else {
                SOC_PBMP_PORT_REMOVE(config->xe, oamp_port);
            }
        }
    }
#endif

#if defined(BCM_TRIUMPH3_SUPPORT)
    if (SOC_IS_TRIUMPH3(unit)) {
        config->control = soc_tr3_get_control_port_bitmap(unit);
    }
#endif

#if defined(BCM_KATANA2_SUPPORT)
    if (SOC_IS_KATANA2(unit) && (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe))) {
        _bcm_kt2_subport_pbmp_update(unit, &(config->all));
    }
#endif

    PORT_UNLOCK(unit);
    return BCM_E_NONE;
}

STATIC int
_bcm_td_port_mode_update(int unit, bcm_port_t port, int speed)
{
    soc_info_t *si;
    int enable[2], duplex[2], loopback[2], pause_tx[2], pause_rx[2];
    int frame_max[2], encap[2];
    sal_mac_addr_t address[2];
    bcm_port_t port_list[2], phy_port, cur_port;
    uint32 rval;
    int core_mode, phy_mode, old_phy_mode;
    int i;

    /* Get the original phy_mode */
    SOC_IF_ERROR_RETURN(READ_XLPORT_MODE_REGr(unit, port, &rval));
    core_mode = soc_reg_field_get(unit, XLPORT_MODE_REGr, rval,
                                  CORE_PORT_MODEf);
    old_phy_mode = soc_reg_field_get(unit, XLPORT_MODE_REGr, rval,
                                     PHY_PORT_MODEf);

    si = &SOC_INFO(unit);
    /* speed is the only factor to determine phy_mode */
    if ((speed > 20000) && si->port_speed_max[port] > 20000){
        phy_mode = 0;
    } else if (speed > 10000) {
        if ((si->port_num_lanes[port] == 1) && (speed == 11000) &&
            IS_HG_PORT(unit, port)) {
            phy_mode = 2;
        } else {
            phy_mode = 1;
        }
    } else {
        if ((si->port_num_lanes[port] == 2) && (speed == 10000) &&
            IS_HG_PORT(unit, port)) {
            phy_mode = 1; /* Warpcore uses DXGXS 10.5G in HG mode */
        } else if ((si->port_num_lanes[port] == 4) && (speed == 10000)) {
            phy_mode = 2;
            core_mode = 0;
        } else {
            phy_mode = 2;
        }
    }

    if (phy_mode == old_phy_mode) {
        return BCM_E_NONE;
    }

    port_list[0] = port;
    port_list[1] = -1;
    if (core_mode == 1) { /* dual mode */
        si = &SOC_INFO(unit);
        phy_port = si->port_l2p_mapping[port];
        port_list[1] = si->port_p2l_mapping[((phy_port - 1) ^ 2) + 1];
    }
    soc_reg_field_set(unit, XLPORT_MODE_REGr, &rval, PHY_PORT_MODEf, phy_mode);
    soc_reg_field_set(unit, XLPORT_MODE_REGr, &rval, CORE_PORT_MODEf, core_mode);
    SOC_IF_ERROR_RETURN(WRITE_XLPORT_MODE_REGr(unit, port, rval));

    /* Retain MAC setting */
    for (i = 0; i < 2; i++) {
        if (port_list[i] == -1) {
            continue;
        }
        cur_port = port_list[i];

        /* no need to save speed since speed change trigger this, in addition,
         * mac may not be able to tell you exact speed in many cases */
        SOC_IF_ERROR_RETURN
            (MAC_DUPLEX_GET(PORT(unit, cur_port).p_mac, unit, cur_port,
                            &duplex[i]));
        SOC_IF_ERROR_RETURN
            (MAC_PAUSE_GET(PORT(unit, cur_port).p_mac, unit, cur_port,
                           &pause_tx[i], &pause_rx[i]));
        SOC_IF_ERROR_RETURN
            (MAC_PAUSE_ADDR_GET(PORT(unit, cur_port).p_mac, unit, cur_port,
                                address[i]));
        SOC_IF_ERROR_RETURN
            (MAC_FRAME_MAX_GET(PORT(unit, cur_port).p_mac, unit, cur_port,
                               &frame_max[i]));
        /* not saving ifg setting */
        SOC_IF_ERROR_RETURN
            (MAC_ENCAP_GET(PORT(unit, cur_port).p_mac, unit, cur_port,
                           &encap[i]));
        SOC_IF_ERROR_RETURN
            (MAC_LOOPBACK_GET(PORT(unit, cur_port).p_mac, unit, cur_port,
                              &loopback[i]));
        SOC_IF_ERROR_RETURN
            (MAC_ENABLE_GET(PORT(unit, cur_port).p_mac, unit, cur_port,
                            &enable[i]));
    }

    /* Do XMAC hard reset when phy_mode changed */
    (void)READ_XLPORT_XMAC_CONTROLr(unit, port, &rval);
    soc_reg_field_set(unit, XLPORT_XMAC_CONTROLr, &rval, XMAC_RESETf, 1);
    (void)WRITE_XLPORT_XMAC_CONTROLr(unit, port, rval);
    sal_udelay(10);
    soc_reg_field_set(unit, XLPORT_XMAC_CONTROLr, &rval, XMAC_RESETf, 0);
    (void)WRITE_XLPORT_XMAC_CONTROLr(unit, port, rval);

    for (i = 0; i < 2; i++) {
        if (port_list[i] == -1) {
            continue;
        }
        cur_port = port_list[i];

        /* mac init */
        SOC_IF_ERROR_RETURN
            (MAC_INIT(PORT(unit, cur_port).p_mac, unit, cur_port));

        /* Restore MAC setting */
        /* no need to save speed since speed change trigger this, in addition,
         * mac may not be able to tell you exact speed in many cases */
        /* coverity[uninit_use_in_call] : FALSE */
        SOC_IF_ERROR_RETURN
            (MAC_DUPLEX_SET(PORT(unit, cur_port).p_mac, unit, cur_port,
                            duplex[i]));
        /* coverity[uninit_use_in_call] : FALSE */
        SOC_IF_ERROR_RETURN
            (MAC_PAUSE_SET(PORT(unit, cur_port).p_mac, unit, cur_port,
                           pause_tx[i], pause_rx[i]));
        SOC_IF_ERROR_RETURN
            (MAC_PAUSE_ADDR_SET(PORT(unit, cur_port).p_mac, unit, cur_port,
                                address[i]));
        /* coverity[uninit_use_in_call] : FALSE */
        SOC_IF_ERROR_RETURN
            (MAC_FRAME_MAX_SET(PORT(unit, cur_port).p_mac, unit, cur_port,
                               frame_max[i]));
        /* not saving ifg setting */
        /* coverity[uninit_use_in_call] : FALSE */
        SOC_IF_ERROR_RETURN
            (MAC_ENCAP_SET(PORT(unit, cur_port).p_mac, unit, cur_port,
                           encap[i]));
        /* coverity[uninit_use_in_call] : FALSE */
        SOC_IF_ERROR_RETURN
            (MAC_LOOPBACK_SET(PORT(unit, cur_port).p_mac, unit, cur_port,
                              loopback[i]));
        /* coverity[uninit_use_in_call] : FALSE */
        SOC_IF_ERROR_RETURN
            (MAC_ENABLE_SET(PORT(unit, cur_port).p_mac, unit, cur_port,
                            enable[i]));
    }

    return BCM_E_NONE;
}

STATIC int
_bcm_tx_roe_port_update(int unit, bcm_port_t port, int link)
{

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_tx_roe_portctrl_update(unit, port, link);
    }
    return BCM_E_NONE;
}

STATIC int
_bcm_rx_roe_port_update(int unit, bcm_port_t port, int link)
{

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_rx_roe_portctrl_update(unit, port, link);
    }
    return BCM_E_NONE;
}
/*
 * Function:
 *      _bcm_port_update
 * Purpose:
 *      Get port characteristics from PHY and program MAC to match.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      link -  True if link is active, false if link is inactive.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

STATIC int
_bcm_port_update(int unit, bcm_port_t port, int link)
{
    int                 rv;
    int                 duplex, speed, an, an_done;
    soc_port_if_t       pif;
    int                 cur_mac_speed;
    int                 enable;
#ifdef INCLUDE_MACSEC
    int                 policy = 0;
    int                 duplex_old = 0;
#endif
#ifdef INCLUDE_FCMAP
    phy_ctrl_t *pc;
#endif

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_update(unit, port, link);
    }
    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.update.\n"),
                   port));
        return BCM_E_PARAM;
    }

    if (PORT(unit, port).p_mac == NULL) {
        return BCM_E_INIT;
    }

    if (!link) {
        /* PHY is down.  Disable the MAC. */
#ifdef SW_AUTONEG_SUPPORT
        rv = _bcm_esw_port_notify_link_down_evt(unit, port);
        if (BCM_FAILURE(rv)) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "u=%d p=%d NOTIFY LINK DOWN EVT rv=%d\n"),
                      unit, port, rv));
            return rv;
        }
#endif

        rv = (MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, FALSE));
        if (BCM_FAILURE(rv)) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "u=%d p=%d MAC_ENABLE_SET FALSE rv=%d\n"),
                      unit, port, rv));
            return rv;
        }
        /* PHY link down event */
        rv = (soc_phyctrl_linkdn_evt(unit, port));
        if (BCM_FAILURE(rv) && (BCM_E_UNAVAIL != rv)) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "u=%d p=%d soc_phyctrl_linkdn_evt rv=%d\n"),unit, port, rv));
            return rv;
        }
        return BCM_E_NONE;
    }

    /* PHY link up event may not be support by all PHY driver.
     * Just ignore it if not supported */
    rv = (soc_phyctrl_linkup_evt(unit, port));
    if (BCM_FAILURE(rv) && (BCM_E_UNAVAIL != rv)) {
        LOG_WARN(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit,
                             "u=%d p=%d soc_phyctrl_linkup_evt rv=%d\n"),unit, port, rv));
        return rv;
    }

    if (soc_feature(unit, soc_feature_internal_phy_link_check)) {
        int up = 0;

        SOC_IF_ERROR_RETURN
            (soc_phyctrl_link_get(unit, port, &up));

        /* Wait internal PHY link when external PHY is link up */
        if (up) {
            (void)soc_phyctrl_notify(unit, port, phyEventLinkWait, 0);
        }
    }

    /*
     * Set MAC speed first, since for GTH ports, this will switch
     * between the 1000Mb/s or 10/100Mb/s MACs.
     */

    if (!IS_HG_PORT(unit, port) || IS_GX_PORT(unit, port)) {
        rv = (soc_phyctrl_speed_get(unit, port, &speed));
        if (BCM_FAILURE(rv) && (BCM_E_UNAVAIL != rv)) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "u=%d p=%d phyctrl_speed_get rv=%d\n"),unit, port, rv));
            return rv;
        }
        if (IS_HG_PORT(unit, port) && speed < 5000) {
            speed = 0;
        }
        LOG_INFO(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit,
                             "u=%d p=%d phyctrl_speed_get speed=%d\n"),unit, port, speed));

        if (BCM_E_UNAVAIL == rv ) {
            /* If PHY driver doesn't support speed_get, don't change
             * MAC speed. E.g, Null PHY driver
             */
            rv = BCM_E_NONE;
        } else {
            if (SOC_IS_TRIDENT(unit) || SOC_IS_TITAN(unit)) {
                BCM_IF_ERROR_RETURN
                    (_bcm_td_port_mode_update(unit, port, speed));
            }
#ifdef INCLUDE_FCMAP
            /* FOR MONTREAL-1 ONLY
             *
             * In FCMAP mode, the port is operating in FC-Mode. The switch and the
             * system side of the PHY operates in 10G, FullDuplex and Pause enabled
             * mode
             * For MT1, the phy max speed will always be 10G (never 25G which MT2 supports)
             */
            if (soc_property_port_get(unit, port, spn_FCMAP_ENABLE, 0)) {

                pc = EXT_PHY_SW_STATE(unit, port);

                if ((pc != NULL) &&  !PHY_IS_BCM8806X(pc)) {
                     speed = 10000;
                }
                LOG_WARN(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                                     "u=%d p=%d speed_max=%d speed=%d\n"),unit, port,
                                      pc->speed_max, speed));
            }
#endif
            rv =  (MAC_SPEED_GET(PORT(unit, port).p_mac, unit, port, &cur_mac_speed));
            if (BCM_FAILURE(rv)) {
                LOG_WARN(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                                     "u=%d p=%d MAC_SPEED_GET rv=%d\n"),unit, port, rv));
                return rv;
            }

            rv =  (MAC_ENABLE_GET(PORT(unit, port).p_mac, unit, port, &enable));
            if (BCM_FAILURE(rv)) {
                LOG_WARN(BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                      "u=%d p=%d MAC_ENABLE_GET rv=%d\n"),unit, port, rv));
                return rv;
            }

            /* If current MAC speed is the same as PHY speed, no need set it again */
            if (cur_mac_speed != speed || enable != TRUE) {
                 rv =  (MAC_SPEED_SET(PORT(unit, port).p_mac, unit, port, speed));
            }
        }
        if (BCM_FAILURE(rv)) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "u=%d p=%d MAC_SPEED_SET speed=%d rv=%d\n"),
                      unit, port, speed, rv));
            return rv;
        }

        rv =   (soc_phyctrl_duplex_get(unit, port, &duplex));
        if (BCM_FAILURE(rv)) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "u=%d p=%d phyctrl_duplex_get rv=%d\n"),
                                 unit, port, rv));
            return rv;
        }

#ifdef INCLUDE_MACSEC
        /* When macsec is enabled, the switch and system side of the PHY
         * operate in full-duplex mode.
 */
        duplex_old = duplex;
        if ( soc_property_port_get(unit, port, spn_MACSEC_ENABLE, 0) ) {
            duplex = 1;
        }

        policy = soc_property_port_get(unit, port, spn_MACSEC_SWITCH_SIDE_POLICY, 1);
        if ( (policy == 2) && (! duplex_old) ) {
            /* if line-side linked up at half-duplex under Duplex Gateway mode */
            duplex = 1;        /* force to full-duplex */
        }
#endif

#ifdef INCLUDE_FCMAP
            /*
             * In FCMAP mode, the port is operating in FC-Mode. The switch and the
             * system side of the PHY operates in 10G, FullDuplex and Pause enabled
             * mode
             */
            if (soc_property_port_get(unit, port, spn_FCMAP_ENABLE, 0)) {
                duplex = 1;
            }
#endif
        rv = (MAC_DUPLEX_SET(PORT(unit, port).p_mac, unit, port, duplex));
        if (BCM_FAILURE(rv)) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "u=%d p=%d MAC_DUPLEX_SET %s sp=%d rv=%d\n"),
                                 unit, port,
                      duplex ? "FULL" : "HALF", speed, rv));
            return rv;
        }
    } else {

        duplex = 1;
    }

    rv = (soc_phyctrl_interface_get(unit, port, &pif));
    if (BCM_FAILURE(rv)) {
        LOG_WARN(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit,
                             "u=%d p=%d phyctrl_interface_get rv=%d\n"),
                  unit, port, rv));
        return rv;
    }
    rv = (MAC_INTERFACE_SET(PORT(unit, port).p_mac, unit, port, pif));
    if (BCM_FAILURE(rv)) {
        LOG_WARN(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit,
                             "u=%d p=%d MAC_INTERFACE_GET rv=%d\n"),
                  unit, port,rv));
        return rv;
    }

    SOC_IF_ERROR_RETURN
        (soc_phyctrl_auto_negotiate_get(unit, port, &an, &an_done));

    /*
     * If autonegotiating, check the negotiated PAUSE values, and program
     * MACs accordingly. Link can also be achieved thru parallel detect.
     * In this case, it should be treated as in the forced mode.
     */
    if (an && an_done) {
        bcm_port_ability_t      remote_advert, local_advert;
        int                     tx_pause, rx_pause;

    sal_memset(&local_advert,  0, sizeof(bcm_port_ability_t));
    sal_memset(&remote_advert, 0, sizeof(bcm_port_ability_t));

    rv = soc_phyctrl_ability_advert_get(unit, port, &local_advert);
        if (BCM_FAILURE(rv)) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "u=%d p=%d soc_phyctrl_adv_local_get rv=%d\n"),
                      unit, port, rv));
            return rv;
        }
        rv = soc_phyctrl_ability_remote_get(unit, port, &remote_advert);
        if (BCM_FAILURE(rv)) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "u=%d p=%d soc_phyctrl_adv_remote_get rv=%d\n"),
                      unit, port, rv));
            return rv;
        }

        /*
         * IEEE 802.3 Flow Control Resolution.
         * Please see $SDK/doc/pause-resolution.txt for more information.
         */

        if (duplex) {
            tx_pause =
                     ((remote_advert.pause & SOC_PA_PAUSE_RX) &&
                      (local_advert.pause & SOC_PA_PAUSE_RX)) ||
                     ((remote_advert.pause & SOC_PA_PAUSE_RX) &&
                      !(remote_advert.pause & SOC_PA_PAUSE_TX) &&
                      (local_advert.pause & SOC_PA_PAUSE_TX));

            rx_pause =
                     ((remote_advert.pause & SOC_PA_PAUSE_RX) &&
                      (local_advert.pause & SOC_PA_PAUSE_RX)) ||
                     ((local_advert.pause & SOC_PA_PAUSE_RX) &&
                      (remote_advert.pause & SOC_PA_PAUSE_TX) &&
                      !(local_advert.pause & SOC_PA_PAUSE_TX));
        } else {
            rx_pause = tx_pause = 0;
        }
#ifdef INCLUDE_MACSEC
        if ( (policy == 2) && (! duplex_old) ) {
            /* if line-side linked up at half-duplex under Duplex Gateway mode */
            rx_pause = 1;              /* turn on flow control Rx pause frames */
        }
#endif
        rv = (MAC_PAUSE_SET(PORT(unit, port).p_mac,
                           unit, port, tx_pause, rx_pause));
        if (BCM_FAILURE(rv)) {
            LOG_WARN(BSL_LS_BCM_PORT,
                     (BSL_META_U(unit,
                                 "u=%d p=%d MAC_PAUSE_SET rv=%d\n"),
                      unit, port, rv));
            return rv;
        }
    }

#ifdef INCLUDE_MACSEC
    {
    /*
     * In MACSEC based PHYs the switch side could be operating with
     * different speed,duplex and pause compared to line speed, duplex and
     * pause settings. The above setting will be overridden if the switch side
     * of the PHY is set to operate in fixed mode
     */
    uint32 value;
    rv = (soc_phyctrl_control_get(unit, port,
                                  BCM_PORT_PHY_CONTROL_MACSEC_SWITCH_FIXED,
                                  &value));

    if (BCM_E_UNAVAIL != rv) { /* Switch fixed speed is supported */

        if (value == 1) {
            /* Get and Set Speed */
            rv = (soc_phyctrl_control_get(unit, port,
                              BCM_PORT_PHY_CONTROL_MACSEC_SWITCH_FIXED_SPEED,
                              &value));
            if (BCM_FAILURE(rv)) {
                LOG_WARN(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                                     "u=%d p=%d phyctrl_control_get(speed) rv=%d\n"),
                          unit, port, rv));
                return rv;
            }

            rv =  (MAC_SPEED_SET(PORT(unit, port).p_mac, unit, port, value));
            if (BCM_FAILURE(rv)) {
                LOG_WARN(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                                     "u=%d p=%d MAC_SPEED_SET speed=%d rv=%d\n"),
                          unit, port, value, rv));
                return rv;
            }

            /* Get and Set Duplex */
            rv = (soc_phyctrl_control_get(unit, port,
                              BCM_PORT_PHY_CONTROL_MACSEC_SWITCH_FIXED_DUPLEX,
                              &value));
            if (BCM_FAILURE(rv)) {
                LOG_WARN(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                                     "u=%d p=%d phyctrl_control_get(duplex) rv=%d\n"),
                          unit, port, rv));
                return rv;
            }
            rv = (MAC_DUPLEX_SET(PORT(unit, port).p_mac, unit, port, value));
            if (BCM_FAILURE(rv)) {
                LOG_WARN(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                                     "u=%d p=%d MAC_DUPLEX_SET %s sp=%d rv=%d\n"),
                                     unit, port,
                          value ? "FULL" : "HALF", value, rv));
                return rv;
            }

            /* Get and Set PAUSE */
            rv = (soc_phyctrl_control_get(unit, port,
                              BCM_PORT_PHY_CONTROL_MACSEC_SWITCH_FIXED_PAUSE,
                              &value));
            if (BCM_FAILURE(rv)) {
                LOG_WARN(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                                     "u=%d p=%d phyctrl_control_get(Pause) rv=%d\n"),
                          unit, port, rv));
                return rv;
            }
            if (value == 1) {
                /*
                 * Flow control domain is between switch MAC and PHY MAC.
                 * If the flow control domain is not between switch and PHY's
                 * switch MAC, then the flow control domain is extended to that
                 * of GPHY.
                 */
                rv = (MAC_PAUSE_SET(PORT(unit, port).p_mac,
                               unit, port, value, value));
                if (BCM_FAILURE(rv)) {
                    LOG_WARN(BSL_LS_BCM_PORT,
                             (BSL_META_U(unit,
                                         "u=%d p=%d MAC_PAUSE_SET rv=%d\n"),
                              unit, port, rv));
                    return rv;
                }
            }

        }
    }
    }
#endif

    /* Enable the MAC. */
    rv =  (MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, TRUE));
    if (BCM_FAILURE(rv)) {
        LOG_WARN(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit,
                             "u=%d p=%d MAC_ENABLE_SET TRUE rv=%d\n"),
                  unit, port, rv));
        return rv;
    }

#ifdef BCM_BRADLEY_SUPPORT
    /* When a link comes up, hardware will not update the
     * LINK_STATUS register until software has toggled the
     * the LAG_FAILOVER_CONFIG.LINK_STATUS_UP field.
     * When a link goes down, hardware will update the
     * LINK_STATUS register without software intervention.
     */
    if ((SOC_REG_IS_VALID(unit, GXPORT_LAG_FAILOVER_CONFIGr) &&
         IS_GX_PORT(unit, port)) ||
        (SOC_REG_IS_VALID(unit, LAG_FAILOVER_CONFIGr)) ||
        (SOC_REG_IS_VALID(unit, XLPORT_LAG_FAILOVER_CONFIGr) &&
         (IS_XL_PORT(unit, port) || IS_MXQ_PORT(unit, port) )) ||
        (SOC_REG_IS_VALID(unit, CLPORT_LAG_FAILOVER_CONFIGr) &&
          IS_CL_PORT(unit, port))) {
        soc_reg_t reg;
        uint32 rval;

        if (SOC_IS_SABER2(unit) && SOC_REG_PORT_VALID(unit, XLPORT_LAG_FAILOVER_CONFIGr, port)) {
            reg = XLPORT_LAG_FAILOVER_CONFIGr;
        } else if (SOC_REG_IS_VALID(unit, LAG_FAILOVER_CONFIGr)) {
            reg = LAG_FAILOVER_CONFIGr;
        } else if (SOC_REG_IS_VALID(unit, GXPORT_LAG_FAILOVER_CONFIGr)) {
            reg = GXPORT_LAG_FAILOVER_CONFIGr;
        } else if (SOC_REG_PORT_VALID(unit, CLPORT_LAG_FAILOVER_CONFIGr, port) &&
                   (SOC_IS_TOMAHAWKX(unit) || IS_CL_PORT(unit, port))) {
            reg = CLPORT_LAG_FAILOVER_CONFIGr;
        } else {
            reg = XLPORT_LAG_FAILOVER_CONFIGr;
        }

        /* Toggle link bit to notify IPIPE on link up */
        BCM_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));
        soc_reg_field_set(unit, reg, &rval, LINK_STATUS_UPf, 1);
        BCM_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
        soc_reg_field_set(unit, reg, &rval, LINK_STATUS_UPf, 0);
        BCM_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
    }
#endif /* BCM_BRADLEY_SUPPORT */

    return BCM_E_NONE;
}



/*
 * Function:
 *      bcm_port_update
 * Purpose:
 *      Get port characteristics from PHY and program MAC to match.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      link - TRUE - process as link up.
 *             FALSE - process as link down.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_update(int unit, bcm_port_t port, int link)
{
    int         rv = BCM_E_NONE;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#if defined(BCM_RCPU_SUPPORT)
    if (SOC_IS_RCPU_ONLY(unit) && link) {
        /* Can not do this unless real phy driver is used for RCPU device. */
        return BCM_E_NONE;
    }
#endif /* BCM_RCPU_SUPPORT */
    PORT_LOCK(unit);
    rv = _bcm_port_update(unit, port, link);
    if (BCM_FAILURE(rv)) {
        PORT_UNLOCK(unit);
        return (rv);
    }
#if defined(BCM_BRADLEY_SUPPORT)
    if (SOC_IS_HBX(unit) && !SOC_IS_SHADOW(unit)) {
        rv = _bcm_port_mmu_update(unit, port, link);
    }
#endif /* BCM_BRADLEY_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT)
    if (SOC_IS_KATANA2(unit) && !SOC_IS_SABER2(unit)) {
        rv = soc_katana2_mmu_port_enable_set(unit, port, link);
    }
#endif

    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_update: u=%d p=%d link=%d rv=%d\n"),
              unit, port, link, rv));

    return(rv);
}

/*
 * Function:
 *      bcm_esw_roe_tx_port_update
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      link - TRUE - process as link up.
 *             FALSE - process as link down.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_roe_tx_port_update(int unit, bcm_port_t port, int link)
{
    int         rv = BCM_E_NONE;
    PORT_INIT(unit);
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);
    rv = _bcm_tx_roe_port_update(unit, port, link);
    if (BCM_FAILURE(rv)) {
        PORT_UNLOCK(unit);
        return (rv);
    }
    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_tx_roe_port_update: u=%d p=%d link=%d rv=%d\n"),
              unit, port, link, rv));

    return(rv);
}

/*
 * Function:
 *      bcm_esw_roe_rx_port_update
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      link - TRUE - process as link up.
 *             FALSE - process as link down.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_roe_rx_port_update(int unit, bcm_port_t port, int link)
{
    int         rv = BCM_E_NONE;
    PORT_INIT(unit);
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);
    rv = _bcm_rx_roe_port_update(unit, port, link);
    if (BCM_FAILURE(rv)) {
        PORT_UNLOCK(unit);
        return (rv);
    }
    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_rx_roe_port_update: u=%d p=%d link=%d rv=%d\n"),
              unit, port, link, rv));

    return(rv);
}


/*
 * Function:
 *      bcm_port_stp_set
 * Purpose:
 *      Set the spanning tree state for a port.
 *      All STGs containing all VLANs containing the port are updated.
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      port - StrataSwitch port number.
 *      stp_state - State to place port in, one of BCM_PORT_STP_xxx.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL
 * Notes:
 *      BCM_LOCK is taken so that the current list of VLANs
 *      can't change during the operation.
 */

int
bcm_esw_port_stp_set(int unit, bcm_port_t port, int stp_state)
{
    bcm_stg_t           *list = NULL;
    int                 count = 0, i;
    int                 rv = BCM_E_NONE;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef BCM_RCPU_SUPPORT
    if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, port) &&
        !(stp_state == BCM_STG_STP_FORWARD)) {
        return BCM_E_PORT;
    }
#endif /* BCM_RCPU_SUPPORT */

    BCM_LOCK(unit);

    rv = bcm_esw_stg_list(unit, &list, &count);

    if (rv == BCM_E_UNAVAIL) {
        if (stp_state == BCM_STG_STP_FORWARD) {
            rv = BCM_E_NONE;
        } else {
            rv = BCM_E_PARAM;
        }
    } else if (BCM_SUCCESS(rv)) {
        for (i = 0; i < count; i++) {
            if ((rv = bcm_esw_stg_stp_set(unit, list[i],
                                          port, stp_state)) < 0) {
                break;
            }
        }

        bcm_esw_stg_list_destroy(unit, list, count);
    }

    BCM_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_stp_set: u=%d p=%d state=%d rv=%d\n"),
              unit, port, stp_state, rv));

    return rv;
}

/*
 * Function:
 *      bcm_port_stp_get
 * Purpose:
 *      Get the spanning tree state for a port in the default STG.
 * Parameters:
 *      unit - StrataSwitch unit number.
 *      port - StrataSwitch port number.
 *      stp_state - Pointer where state stored.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL
 */

int
bcm_esw_port_stp_get(int unit, bcm_port_t port, int *stp_state)
{
    int                 stg_defl, rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    rv = bcm_esw_stg_default_get(unit, &stg_defl);
    if (rv >= 0) {
        rv = bcm_esw_stg_stp_get(unit, stg_defl, port, stp_state);
    } else if (rv == BCM_E_UNAVAIL) {   /* FABRIC switches, etc */
        *stp_state = BCM_STG_STP_FORWARD;
        rv = BCM_E_NONE;
    }

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_stp_get: u=%d p=%d state=%d rv=%d\n"),
              unit, port, *stp_state, rv));

    return rv;
}

/*
 * Function:
 *      bcm_port_bpdu_enable_set
 * Purpose:
 *      Enable/Disable BPDU reception on the specified port.
 * Parameters:
 *      unit - SOC unit #
 *      port - Port number (0 based)
 *      enable - TRUE to enable, FALSE to disable (reject bpdu).
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL
 */

int
bcm_esw_port_bpdu_enable_set(int unit, bcm_port_t port, int enable)
{
    bcm_port_cfg_t      pcfg;
    int                 rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot enable pbdu on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);

    rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg);

    if (BCM_SUCCESS(rv)) {
        pcfg.pc_bpdu_disable = !enable;
        rv = mbcm_driver[unit]->mbcm_port_cfg_set(unit, port, &pcfg);
    }

    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_port_bpdu_enable_get
 * Purpose:
 *      Return whether BPDU reception is enabled on the specified port.
 * Parameters:
 *      unit - SOC unit #
 *      port - Port number (0 based)
 *      enable - (OUT) TRUE if enabled, FALSE if disabled
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL
 */

int
bcm_esw_port_bpdu_enable_get(int unit, bcm_port_t port, int *enable)
{
    bcm_port_cfg_t      pcfg;
    int                 rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg);

    if (BCM_SUCCESS(rv)) {
        *enable = !pcfg.pc_bpdu_disable;
    }

    return rv;
}

/*
 * Function:
 *      bcm_port_l3_enable_set
 * Purpose:
 *      Enable/Disable L3 switching on the specified port.
 * Parameters:
 *      unit -          device number
 *      port -          port number
 *      enable -        TRUE to enable, FALSE to disable.
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_l3_enable_set(int unit, bcm_port_t port, int enable)
{
    int  rv = BCM_E_UNAVAIL;
#if defined(INCLUDE_L3)
    bcm_port_cfg_t      pcfg;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot enable l3 on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);

    rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg);

    if (BCM_SUCCESS(rv)) {
        if (enable) {
            pcfg.pc_l3_flags |= (BCM_PORT_L3_V4_ENABLE | BCM_PORT_L3_V6_ENABLE);
        } else {
            pcfg.pc_l3_flags &=
                ~(BCM_PORT_L3_V4_ENABLE | BCM_PORT_L3_V6_ENABLE);
        }
        rv = mbcm_driver[unit]->mbcm_port_cfg_set(unit, port, &pcfg);
    }

    PORT_UNLOCK(unit);
#endif /* INCLUDE_L3 */
    return rv;
}

/*
 * Function:
 *      bcm_port_l3_enable_get
 * Purpose:
 *      Return whether L3 switching is enabled on the specified port.
 * Parameters:
 *      unit -          device number
 *      port -          port number
 *      enable -        (OUT) TRUE if enabled, FALSE if disabled
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_l3_enable_get(int unit, bcm_port_t port, int *enable)
{
    int  rv = BCM_E_UNAVAIL;
#if defined(INCLUDE_L3)
    bcm_port_cfg_t      pcfg;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg);

    if (BCM_SUCCESS(rv)) {
        *enable = ((pcfg.pc_l3_flags & BCM_PORT_L3_V4_ENABLE) ||
                   (pcfg.pc_l3_flags & BCM_PORT_L3_V6_ENABLE));
    }
#endif /* INCLUDE_L3 */

    return rv;
}

/*
 * Function:
 *      bcm_port_tgid_get
 * Purpose:
 *      Get the trunk group for a given port.
 * Parameters:
 *      unit - SOC unit #
 *      port - Port number (0 based)
 *      tid - trunk ID
 *      psc - trunk selection criterion
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL
 */

int
bcm_esw_port_tgid_get(int unit, bcm_port_t port, int *tid, int *psc)
{
    bcm_port_cfg_t      pcfg;
    int                 rv;
#if defined(BCM_FIREBOLT_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    soc_field_t tgid_fld = TGIDf;
    if (SOC_MEM_FIELD_VALID(unit, SOURCE_TRUNK_MAP_TABLEm, SRC_TGIDf)) {
        tgid_fld = SRC_TGIDf;
    }
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#if defined(BCM_FIREBOLT_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    if (soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm, tgid_fld)) {
#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            rv = _bcm_kt2_trunk_table_read(unit, port, tid);
        } else
#endif
        {
            rv = _bcm_xgs3_trunk_table_read(unit, port, tid);
        }
        if (BCM_SUCCESS(rv)) {
            *psc = 0;
        }
        return rv;
    }
#endif /* BCM_FIREBOLT_SUPPORT */

    rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg);

    if (BCM_SUCCESS(rv)) {
        *tid = pcfg.pc_tgid;
        *psc = 0;
    }

    return rv;

}

/*
 * Function:
 *      bcm_port_tgid_set
 * Purpose:
 *      Set the trunk group for a given port.
 * Parameters:
 *      unit - SOC unit #
 *      port - Port number (0 based)
 *      tid - trunk ID
 *      psc - trunk selection criterion
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL
 */

int
bcm_esw_port_tgid_set(int unit, bcm_port_t port, int tid, int psc)
{
    bcm_port_cfg_t      pcfg;
    int                 rv;
#if defined(BCM_FIREBOLT_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    soc_field_t tgid_fld = TGIDf;
    if (SOC_MEM_FIELD_VALID(unit, SOURCE_TRUNK_MAP_TABLEm, SRC_TGIDf)) {
        tgid_fld = SRC_TGIDf;
    }
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#if defined(BCM_FIREBOLT_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    if (soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm, tgid_fld)) {
#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            return _bcm_kt2_trunk_table_write(unit, port, tid);
        } else
#endif
        {
            return _bcm_xgs3_trunk_table_write(unit, port, tid);
        }
    }
#endif /* BCM_FIREBOLT_SUPPORT */

    PORT_LOCK(unit);

    rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg);

    if (BCM_SUCCESS(rv)) {
        if (tid != BCM_TRUNK_INVALID) {
            pcfg.pc_tgid = tid;
            pcfg.pc_trunk = 1;
        } else {
            pcfg.pc_tgid = 0;
            pcfg.pc_trunk = 0;
        }
        rv = mbcm_driver[unit]->mbcm_port_cfg_set(unit, port, &pcfg);
    }

    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      _bcm_port_mirror_enable_get (internal)
 * Purpose:
 *       Return whether mirroring is enabled on the specified port.
 * Parameters:
 *      unit   - (IN) BCM device number.
 *      port   - (IN) Port number (0 based).
 *      enable - (OUT) Bitmap of ingress mirror enabled.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL
 */

int
_bcm_port_mirror_enable_get(int unit, bcm_port_t port, int *enable)
{
    bcm_port_cfg_t      pcfg;
    int                 rv;

    /* Input parameters check. */
    if (NULL == enable) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg);

    if (BCM_SUCCESS(rv)) {
        *enable = pcfg.pc_mirror_ing;
    }

    return rv;
}

/*
 * Function:
 *      _bcm_port_mirror_enable_set (internal)
 * Purpose:
 *       Enable/Disable mirroring for a given port.
 * Parameters:
 *      unit -   (IN) BCM unit #
 *      port -   (IN) Port number (0 based)
 *      enable - (IN) Bitmap of ingress mirror enabled.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL
 */

int
_bcm_port_mirror_enable_set(int unit, bcm_port_t port, int enable)
{
    bcm_port_cfg_t      pcfg;
    int                 rv;

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);

    rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg);

    if (BCM_SUCCESS(rv)) {
        pcfg.pc_mirror_ing = enable;
        rv = mbcm_driver[unit]->mbcm_port_cfg_set(unit, port, &pcfg);
    }

    PORT_UNLOCK(unit);

    return rv;
}

#ifdef BCM_TRIUMPH2_SUPPORT
/*
 * Function:
 *      _bcm_port_mirror_egress_true_enable_get (internal)
 * Purpose:
 *       Return whether true egress mirroring is enabled on the
 *       specified port.
 * Parameters:
 *      unit   - (IN) BCM device number.
 *      port   - (IN) Port number (0 based).
 *      enable - (OUT) Bitmap of true egress mirrors enabled.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL
 */

int
_bcm_port_mirror_egress_true_enable_get(int unit, bcm_port_t port,
                                        int *enable)
{
    int     rv;

    /* Input parameters check. */
    if (NULL == enable) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TRIUMPH3_SUPPORT)
    if (soc_feature(unit, soc_feature_ep_redirect) ||
        soc_feature(unit, soc_feature_ep_redirect_v2)) {
        egr_port_entry_t egr_port_entry;
        int              ep_redirect_v2 = FALSE;

        rv = READ_EGR_PORTm(unit, MEM_BLOCK_ANY, port,
                            &egr_port_entry);

        /* Check if this device supports version 2 of redirect,
           based on which we will access different fields below */
        ep_redirect_v2 = soc_feature(unit, soc_feature_ep_redirect_v2);

        if (BCM_SUCCESS(rv)) {
            if (SOC_EPT_REDIRECT_MIRROR ==
                soc_mem_field32_get(unit, EGR_PORTm, &egr_port_entry,
                                    (ep_redirect_v2 ? ER_REDIR_DEST_TYPEf :
                                     REDIRECTION_TYPEf))) {
                *enable = soc_mem_field32_get(unit, EGR_PORTm,
                                             &egr_port_entry,
                                             (ep_redirect_v2 ? ER_REDIR_DESTINATIONf :
                                             REDIRECTION_DESTINATIONf));
            } else {
                *enable = 0;
            }
        }
    } else
#endif /* BCM_TRIUMPH3_SUPPORT */

    {
        uint64 egr_val64;

        rv = READ_EGR_PORT_64r(unit, port, &egr_val64);
        if (BCM_SUCCESS(rv)) {
            *enable = soc_reg64_field32_get(unit, EGR_PORT_64r,
                                            egr_val64, MIRRORf);
        }
    }

    return rv;
}

/*
 * Function:
 *      _bcm_port_mirror_egress_true_enable_set (internal)
 * Purpose:
 *       Enable/Disable true egress mirroring for a given port.
 * Parameters:
 *      unit -   (IN) BCM unit #
 *      port -   (IN) Port number (0 based)
 *      enable - (IN) Bitmap of true egress mirrors enabled.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_INTERNAL
 */

int
_bcm_port_mirror_egress_true_enable_set(int unit, bcm_port_t port,
                                        int enable)
{
    int  rv = BCM_E_NONE;

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);

#if defined(BCM_TRIUMPH3_SUPPORT)
    if (soc_feature(unit, soc_feature_ep_redirect) ||
        soc_feature(unit, soc_feature_ep_redirect_v2)) {

        uint32 egr_port_vals[2];
        soc_field_t egr_port_fields[2];

        /* Based on if the device support version 2 of redirect,
           select the appropriate fields */
        if (soc_feature(unit, soc_feature_ep_redirect_v2)) {
            egr_port_fields[0] = ER_REDIR_DEST_TYPEf;
            egr_port_fields[1] = ER_REDIR_DESTINATIONf;
        } else {
            egr_port_fields[0] = REDIRECTION_TYPEf;
            egr_port_fields[1] = REDIRECTION_DESTINATIONf;
        }

        egr_port_vals[0] =
            (0 != enable) ? SOC_EPT_REDIRECT_MIRROR : SOC_EPT_REDIRECT_NOOP;
        egr_port_vals[1] = enable;

        /* Egress port table */
        rv = soc_mem_fields32_modify(unit, EGR_PORTm, port, 2,
                                     egr_port_fields, egr_port_vals);

        /* If ep-redirect-v2 also set the action, always-redirect vs do-not-redirect */
        if(rv == BCM_E_NONE) {
            if (soc_feature(unit, soc_feature_ep_redirect_v2)) {
                rv = soc_mem_field32_modify(unit, EGR_PORTm,
                       port, ER_REDIR_ACTIONf,
                       (enable ? _BCM_REDIRECT_ALWAYS : _BCM_REDIRECT_NONE));
            }
        }

    } else
#endif /* BCM_TRIUMPH3_SUPPORT */

    {
        rv = soc_reg_field32_modify(unit, EGR_PORT_64r, port,
                                    MIRRORf, enable);
        if (BCM_SUCCESS(rv) && IS_HG_PORT(unit, port)) {
            rv = soc_reg_field32_modify(unit, IEGR_PORT_64r, port,
                                        MIRRORf, enable);
        }
    }

    PORT_UNLOCK(unit);
    return rv;
}
#endif /* BCM_TRIUMPH2_SUPPORT */

/*
 * Function:
 *      bcm_port_linkscan_get
 * Purpose:
 *      Get the link scan state of the port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      linkscan - (OUT) Linkscan value (None, S/W, H/W)
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_linkscan_get(int unit, bcm_port_t port, int *linkscan)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    return bcm_esw_linkscan_mode_get(unit, port, linkscan);
}

/*
 * Function:
 *      bcm_port_linkscan_set
 * Purpose:
 *      Set the linkscan state for a given port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      linkscan - Linkscan value (None, S/W, H/W)
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_linkscan_set(int unit, bcm_port_t port, int linkscan)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot enable linkscan on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    return bcm_esw_linkscan_mode_set(unit, port, linkscan);
}

/*
 * Function:
 *      bcm_port_autoneg_get
 * Purpose:
 *      Get the autonegotiation state of the port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      autoneg - (OUT) Boolean value
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_autoneg_get(int unit, bcm_port_t port, int *autoneg)
{
    int           done=0, rv=BCM_E_NONE;
    int           phy_lane = -1;
    int           phyn = 0, sys_side = 0;
    bcm_port_t    local_port = -1;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_autoneg_get(unit, port, autoneg);
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_phyn_validate(unit, port,
                         &local_port, &phyn, &phy_lane, &sys_side));

    if (local_port == -1) {
       BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    }

    PORT_LOCK(unit);
    if (local_port == -1) {
        rv = soc_phyctrl_auto_negotiate_get(unit, port, autoneg, &done);
    } else {
        rv = soc_phyctrl_redirect_auto_negotiate_get(unit, local_port, phyn,
                                                     phy_lane, sys_side,
                                                     autoneg, &done);
    }
    PORT_UNLOCK(unit);
    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_autoneg_get: u=%d p=%d an=%d done=%d rv=%d\n"),
              unit, port, *autoneg, done, rv));

    return rv;
}

/*
 * Function:
 *      bcm_port_autoneg_set
 * Purpose:
 *      Set the autonegotiation state for a given port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      autoneg - Boolean value
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_autoneg_set(int unit, bcm_port_t port, int autoneg)
{
    int           rv=BCM_E_NONE;
    int           phy_lane = -1;
    int           phyn = 0, sys_side = 0;
    bcm_port_t    local_port = -1;

#if defined(BCM_SABER2_SUPPORT)
    int             phy_status;
#endif
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_autoneg_set(unit, port, autoneg);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot set autoneg on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif
#ifdef BCM_RCPU_SUPPORT
    if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, port)) {
        return BCM_E_PORT;
    }
#endif /* BCM_RCPU_SUPPORT */

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_phyn_validate(unit, port,
                         &local_port, &phyn, &phy_lane, &sys_side));

    if (local_port == -1) {
       BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    }

    PORT_LOCK(unit);

#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit) && IS_XL_PORT(unit, port)) {
        rv = soc_phyctrl_enable_get(unit, port, &phy_status);
        if (BCM_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
        if(phy_status == TRUE) {
            rv = soc_phyctrl_enable_set(unit, port, FALSE);
            if (BCM_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
        }
    }
#endif

#ifdef SW_AUTONEG_SUPPORT
    if (soc_feature(unit, soc_feature_sw_autoneg)) {

        int           an_mode = 0;

        an_mode = soc_property_port_get(unit, port,
                          spn_PHY_AN_C73, an_mode);

        /* phy_an_c73 value of 3 indicated MSA AN mode */
        if ((an_mode == SW_AN_MODE_CL73_MSA) ||
            (an_mode == SW_AN_MODE_MSA_ONLY)) {
            if (autoneg) {
                rv = bcm_sw_an_port_register(unit, port);
                if (rv == BCM_E_NONE) {
                    PORT_UNLOCK(unit);
                    return rv;
                } else if (rv == BCM_E_PORT) {
                    /* when an_set is called during the init
                     * ports wouldn't have been added to SW AN
                     */
                    rv = BCM_E_NONE;
                    PORT_UNLOCK(unit);
                    return rv;
                } else {
                    /* add bsl log */
                    PORT_UNLOCK(unit);
                    return rv;
                }

            } else {
                rv = bcm_sw_an_port_unregister(unit, port);
                if (rv == BCM_E_NONE) {
                    PORT_UNLOCK(unit);
                    return rv;
                } else if (rv == BCM_E_PORT) {
                    /* when an_set is called during the init
                     * ports wouldn't have been added to SW AN
                     */
                    rv = BCM_E_NONE;
                    PORT_UNLOCK(unit);
                    return rv;
                } else {
                    /* add bsl log */
                    PORT_UNLOCK(unit);
                    return rv;
                }
            }
        }
    }
#endif

    if (local_port == -1) {
       rv = soc_phyctrl_auto_negotiate_set(unit, port, autoneg);
    } else {
       rv = soc_phyctrl_redirect_auto_negotiate_set(unit, local_port, phyn,
                                                    phy_lane, sys_side, autoneg);
    }

#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit) &&
            IS_XL_PORT(unit, port) && (phy_status == TRUE)) {
        /* Enable phy in tsc only if already enabled before config change */
        rv = soc_phyctrl_enable_set(unit, port, TRUE);
        if (BCM_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
    }
#endif

#if defined(BCM_XMAC_SUPPORT)
   if(SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit) ||
      SOC_IS_TRIDENT(unit) || SOC_IS_TITAN(unit)) {
      uint32 vco_disturbed = 0;
      phy_ctrl_t *int_pc;
       if (soc_feature(unit, soc_feature_xmac) && (IS_HG_PORT(unit, port) ||
                   IS_XE_PORT(unit, port))) {
           int_pc = INT_PHY_SW_STATE(unit, port);
           rv = PHYCTRL_CONTROL_GET(int_pc, unit, port, SOC_PHY_CONTROL_VCO_DISTURBED, &vco_disturbed);
           if (!((rv == SOC_E_NONE) || (rv == SOC_E_UNAVAIL))) {
               PORT_UNLOCK(unit);
               return rv;
           }
           if (vco_disturbed) {
               rv = _mac_x_reinit(unit, port);
               if (BCM_FAILURE(rv)) {
                   PORT_UNLOCK(unit);
                   return rv;
               }
           }
       }
   }
#endif
    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_autoneg_set: u=%d p=%d an=%d rv=%d\n"),
              unit, port, autoneg, rv));

    return rv;
}

/*
 * Function:
 *      bcm_port_speed_get
 * Purpose:
 *      Getting the speed of the port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      speed - (OUT) Value in megabits/sec (10, 100, etc)
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      If port is in MAC loopback, the speed of the loopback is returned.
 */

int
bcm_esw_port_speed_get(int unit, bcm_port_t port, int *speed)
{
    int         rv = BCM_E_NONE;
    int         mac_lb;
    int         max_speed;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Check for PortMod */
    if (SOC_PORT_USE_PORTCTRL(unit, port) && (port != CMIC_PORT(unit))) {
        return bcmi_esw_portctrl_speed_get(unit, port, speed);
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port) &&
         SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit),port)))) {
          return BCM_E_PORT;
    }
#endif

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);

    rv = MAC_LOOPBACK_GET(PORT(unit, port).p_mac, unit, port, &mac_lb);

    if (BCM_SUCCESS(rv)) {
        if (mac_lb) {
            rv = MAC_SPEED_GET(PORT(unit, port).p_mac, unit, port, speed);
        } else {
            rv = soc_phyctrl_speed_get(unit, port, speed);

            if (BCM_E_UNAVAIL == rv) {
                /* PHY driver doesn't support speed_get. Get the speed from
                 * MAC.
                 */
                rv = MAC_SPEED_GET(PORT(unit, port).p_mac, unit, port, speed);
            }
            if ((IS_HG_PORT(unit, port) && *speed < 5000) && !(IS_HL_PORT(unit,port))) {
                *speed = 0;
            }
            if (soc_feature(unit, soc_feature_port_encap_speed_max_config)) {
                rv = bcm_esw_port_speed_max(unit, port, &max_speed);
                if (BCM_FAILURE(rv)) {
                    PORT_UNLOCK(unit);
                    return (rv);
                }
                if (*speed > max_speed) {
                    *speed = max_speed;
                }
            }
        }
    }

    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_speed_get: u=%d p=%d speed=%d rv=%d\n"),
              unit, port, BCM_SUCCESS(rv) ? *speed : 0, rv));

    return rv;
}

/*
 * Function:
 *      bcm_port_speed_max
 * Purpose:
 *      Getting the maximum speed of the port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      speed - (OUT) Value in megabits/sec (10, 100, etc)
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_speed_max(int unit, bcm_port_t port, int *speed)
{
    bcm_port_ability_t  ability, phy_ability;
    int                 rv;
    int                 phy_speed;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    if (NULL == speed) {
        return (BCM_E_PARAM);
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);


    /* Check for PortMod */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_speed_max(unit, port, speed);
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }


    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    rv = bcm_esw_port_ability_local_get(unit, port, &ability);

    if (BCM_SUCCESS(rv)) {

        *speed = BCM_PORT_ABILITY_SPEED_MAX(ability.speed_full_duplex |
                                            ability.speed_half_duplex);

        if (10000 == *speed) {
            if (IS_HG_PORT(unit, port) && SOC_INFO(unit).port_speed_max[port]) {
                *speed = SOC_INFO(unit).port_speed_max[port];
                /* Retrieving the internal PHY ability */
                rv = soc_phyctrl_ability_local_get(unit, port, &phy_ability);
                if (BCM_SUCCESS(rv)) {
                    /* considering the common supported speed among phy and mac */
                    phy_speed = BCM_PORT_ABILITY_SPEED_MAX(
                                             phy_ability.speed_full_duplex |
                                             phy_ability.speed_half_duplex);
                    *speed = (*speed > phy_speed) ? phy_speed : *speed;
                } else {
                    *speed = 0;
                }
            }
        }
    } else {
        *speed = 0;
    }

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_speed_max: u=%d p=%d speed=%d rv=%d\n"),
              unit, port, *speed, rv));

    return rv;
}

/*
 * Function    : _bcm_port_speed_supported
 * Description : Determine whether port speed is supported based on
 *               number of lanes configured
 * Parameters  : unit  (IN)
 *               port  (IN)
 *               speed (IN)
 * Returns     : BCM_E_XXX
 * Note        : Caller needs to ensure soc_feature_flexport_based_speed_set
 *               is defined
 */
STATIC bcm_error_t
_bcm_port_speed_supported(int unit, bcm_port_t port, int speed)
{
#ifdef BCM_TOMAHAWK_SUPPORT
    if (SOC_IS_TOMAHAWKX(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_th_port_speed_supported(unit, port, speed));
    }
#endif
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_speed_set
 * Purpose:
 *      Main part of bcm_port_speed_set.
 */

STATIC int
_bcm_port_speed_set(int unit, bcm_port_t port, int speed)
{
    int             phy_lb, rv, enable;
    int             mac_lb;
    int             ignore_ability_check = FALSE;
    bcm_port_ability_t mac_ability, phy_ability, requested_ability;
#if defined(BCM_SABER2_SUPPORT)
    int             phy_status;
#endif

#if defined(BCM_TOMAHAWK_SUPPORT)
    int             cur_speed;
#endif
#if defined(BCM_KATANA2_SUPPORT)
    bcmMxqPhyPortMode_t phy_mode = bcmMxqPhyPortModeQuad;
#endif


    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_speed_set(unit, port, speed);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot set speed on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    sal_memset(&mac_ability, 0, sizeof(bcm_port_ability_t));
    sal_memset(&phy_ability, 0, sizeof(bcm_port_ability_t));
    sal_memset(&requested_ability, 0, sizeof(bcm_port_ability_t));

    /*
     * If port is in MAC loopback mode, do not try setting the PHY
     * speed.  This allows MAC loopback at 10/100 even if the PHY is
     * 1000 only.  Loopback diagnostic tests should enable loopback
     * before setting the speed, and vice versa when cleaning up.
     */

    SOC_IF_ERROR_RETURN
        (MAC_LOOPBACK_GET(PORT(unit, port).p_mac, unit, port, &mac_lb));

    if (speed == 0) {
        /* if speed is 0, set the port speed to max */
        SOC_IF_ERROR_RETURN
            (bcm_esw_port_speed_max(unit, port, &speed));
    }

    /* Make sure MAC can handle the requested speed. */
    SOC_IF_ERROR_RETURN
        (MAC_ABILITY_LOCAL_GET(PORT(unit, port).p_mac, unit, port,
                               &mac_ability));
    requested_ability.speed_full_duplex = SOC_PA_SPEED(speed);
    requested_ability.speed_half_duplex = SOC_PA_SPEED(speed);
    LOG_INFO(BSL_LS_BCM_PHY,
             (BSL_META_U(unit,
                         "_bcm_port_speed_set: u=%u p=%d "
                         "MAC FD speed %08X MAC HD speed %08X "
                         "Requested FD Speed %08X Requested HD Speed %08X\n"),
              unit,
              port,
              mac_ability.speed_full_duplex,
              mac_ability.speed_half_duplex,
              requested_ability.speed_full_duplex,
              requested_ability.speed_half_duplex));
    /*
     * On certain devices such as TH speed set is a flexport operation,
     * due to changes needed to the calendar. This is not applicable to
     * mgmt ports on TH as they are guranteed a fixed amount of BW in the
     * calendar.
     */
    if ((soc_feature(unit, soc_feature_flexport_based_speed_set)) &&
        !SOC_PBMP_MEMBER(PBMP_MANAGEMENT(unit), port)) {
            rv = _bcm_port_speed_supported(unit, port, speed);
            if (BCM_SUCCESS(rv)) {
                ignore_ability_check = TRUE;
            }
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (SOC_IS_TOMAHAWK(unit)) {
        int encap;
        BCM_IF_ERROR_RETURN(bcm_esw_port_encap_get(unit, port, &encap));

        if (IS_HG2_SPEED(speed) && (encap == BCM_PORT_ENCAP_IEEE)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit,
                              "Speed and encapsulation configuration unmatch "
                              "for port=%d, speed=%d, encap=%d\n"),
                   port, speed, encap));
            return BCM_E_CONFIG;
        }
    }
#endif

    if (((mac_ability.speed_full_duplex &
          requested_ability.speed_full_duplex) == 0) &&
        ((mac_ability.speed_half_duplex &
          requested_ability.speed_half_duplex) == 0) &&
        !ignore_ability_check) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "u=%d p=%d MAC doesn't support %d Mbps speed.\n"),
                     unit, port, speed));
        return SOC_E_CONFIG;
    }
    SOC_IF_ERROR_RETURN
        (soc_phyctrl_ability_local_get(unit, port, &phy_ability));

    if (((phy_ability.speed_full_duplex &
          requested_ability.speed_full_duplex) == 0) &&
        ((phy_ability.speed_half_duplex &
          requested_ability.speed_half_duplex) == 0) &&
        !ignore_ability_check) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "u=%d p=%d PHY doesn't support %d Mbps speed.\n"),
                         unit, port, speed));
            return SOC_E_CONFIG;
    } else {

#if defined(BCM_SABER2_SUPPORT)
        if(SOC_IS_SABER2(unit) && IS_XL_PORT(unit, port)) {
            BCM_IF_ERROR_RETURN(soc_phyctrl_enable_get(unit, port, &phy_status));
            if(phy_status == TRUE) {
                BCM_IF_ERROR_RETURN(soc_phyctrl_enable_set(unit, port, FALSE));
            }
        }
#endif

#if defined(BCM_TOMAHAWK_SUPPORT)
        if (SOC_IS_TOMAHAWKX(unit)) {
            SOC_IF_ERROR_RETURN
                (soc_phyctrl_speed_get(unit, port, &cur_speed));
        }
#endif
#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit) && !SOC_IS_SABER2(unit)) {
            SOC_IF_ERROR_RETURN
                (soc_katana2_get_phy_port_mode(unit, port, speed, &phy_mode));
        }
#endif
        SOC_IF_ERROR_RETURN
            (soc_phyctrl_auto_negotiate_set(unit, port, FALSE));
        SOC_IF_ERROR_RETURN
            (soc_phyctrl_speed_set(unit, port, speed));

#if defined(BCM_SABER2_SUPPORT)
        if(SOC_IS_SABER2(unit) &&
                IS_XL_PORT(unit, port) && (phy_status == TRUE)) {
            /* Enable phy in tsc only if already enabled before config change */
            BCM_IF_ERROR_RETURN(soc_phyctrl_enable_set(unit, port, TRUE));
        }
#endif

#if defined(BCM_XMAC_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit) ||
            SOC_IS_TRIDENT(unit) || SOC_IS_TITAN(unit)) {
            uint32 vco_disturbed = 0;
            phy_ctrl_t *int_pc;
            if (soc_feature(unit, soc_feature_xmac) && (IS_HG_PORT(unit, port) ||
                        IS_XE_PORT(unit, port))) {

                int_pc = INT_PHY_SW_STATE(unit, port);
                rv = PHYCTRL_CONTROL_GET(int_pc, unit, port, SOC_PHY_CONTROL_VCO_DISTURBED, &vco_disturbed);
                if (!((rv == SOC_E_NONE) || (rv == SOC_E_UNAVAIL))) {
                    return rv;
                }
                if (vco_disturbed) {
                    BCM_IF_ERROR_RETURN(_mac_x_reinit(unit, port));
                }
            }
        }
#endif
    }

    /* TSC needs no legacy war */
    if (!SOC_IS_TD2_TT2(unit)) {
       /* Prevent PHY register access while resetting BigMAC and Fusion core */
       if (IS_HG_PORT(unit, port)) {
          soc_phyctrl_enable_get(unit, port, &enable);
          soc_phyctrl_enable_set(unit, port, 0);
          soc_phyctrl_loopback_get(unit, port, &phy_lb);
       }
    }
    if (SOC_IS_TRIDENT(unit) || SOC_IS_TITAN(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_td_port_mode_update(unit, port, speed));
    }

#if defined(BCM_TOMAHAWK2_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
    /* Reconfigure chip(PGW/TDM/IP/EP/MMU) for speed set change */
    if (BCM_ESW_PORT_DRV(unit)!= NULL &&
        !(SOC_IS_HURRICANE4(unit) && IS_EGPHY_PORT(unit, port))) {
        if (BCM_ESW_PORT_DRV(unit)->resource_speed_set != NULL) {
            rv = BCM_ESW_PORT_DRV(unit)->resource_speed_set(unit, port, speed);
            if (BCM_FAILURE(rv)) {
                LOG_VERBOSE(BSL_LS_BCM_PORT,
                            (BSL_META_UP(unit, port,
                                         "resource_speed_set failed: %s\n"),
                                         bcm_errmsg(rv)));
                return rv;
            }
        }
    }
#endif /* BCM_TOMAHAWK2_SUPPORT || BCM_TRIDENT3_SUPPORT*/

    rv = MAC_SPEED_SET(PORT(unit, port).p_mac, unit, port, speed);
    if (BCM_FAILURE(rv)) {
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (SOC_IS_TOMAHAWKX(unit)) {
            /* Restore phy's speed state based on what was read periously */
            SOC_IF_ERROR_RETURN
                (soc_phyctrl_speed_set(unit, port, cur_speed));
        }
#endif

        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "MAC_SPEED_SET failed: %s\n"), bcm_errmsg(rv)));
    }

if (!SOC_IS_MONTEREY(unit)) {
    /* TSC needs no legacy war */
    if (!SOC_IS_TD2_TT2(unit)) {
       /* Restore PHY register access */
       if (IS_HG_PORT(unit, port)) {
          soc_phyctrl_enable_set(unit, port, enable);
          soc_phyctrl_loopback_set(unit, port, phy_lb, TRUE);
       }
    }
}

    return rv;
}

/*
 * Function:
 *      bcm_port_speed_set
 * Purpose:
 *      Setting the speed for a given port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      speed - Value in megabits/sec (10, 100, etc)
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      Turns off autonegotiation.  Caller must make sure other forced
 *      parameters (such as duplex) are set.
 */

int
bcm_esw_port_speed_set(int unit, bcm_port_t port, int speed)
{
    int    rv=BCM_E_NONE, max_speed, enable, rv1 = BCM_E_NONE;
    pbmp_t pbm;
    int    curr_speed = 0;
    bcm_port_if_t curr_intf = 0;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

#if defined(BCM_PORT_SPEED_CHANGE_BENCHMARK)
    sal_usecs_t time_start = 0;
    sal_usecs_t time_end = 0;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined(BCM_TOMAHAWK3_SUPPORT)
    /* Don't allow PM8x50 to do bcm_port_speed_set */
    if (SOC_IS_TOMAHAWK3(unit) && IS_CD_PORT(unit, port)) {
        return BCM_E_UNAVAIL;
    }
#endif

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot set speed on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_PORT_SPEED_CHANGE_BENCHMARK)
    time_start = sal_time_usecs();
#endif

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#if defined(BCM_FIREBOLT6_SUPPORT)
    if (SOC_IS_FIREBOLT6(unit)) {
        if (!(SAL_BOOT_SIMULATION)) {
            /* Validate speeds based on OTP. */
            if (_soc_fb6_port_speed_validate(unit, port, -1, -1, -1, speed)) {
                return BCM_E_CONFIG;
            }
        }
    }
#endif

    if (soc_property_get(unit, spn_SAME_SPEED_INTF_DO_NOT_OVERWRITE,
                         (SAL_BOOT_BCMSIM || SAL_BOOT_XGSSIM))) {
        BCM_IF_ERROR_RETURN(bcm_esw_port_speed_get(unit, port, &curr_speed));
        BCM_IF_ERROR_RETURN(bcm_esw_port_interface_get(unit, port, &curr_intf));
        if((speed == curr_speed) && (PORT(unit, port).intf == curr_intf)) {
#if defined(BCM_PORT_SPEED_CHANGE_BENCHMARK)
            time_end = SAL_USECS_SUB(sal_time_usecs(), time_start);
            LOG_INFO(BSL_LS_BCM_BENCHMARK,
                    (BSL_META_U(unit,
                                "\nPort %d speed change to %d processing took %d usecs\n"),
                                port,
                                speed,
                                time_end));
#endif
            return BCM_E_NONE;
        }
    }

#ifdef BCM_RCPU_SUPPORT
    if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, port)) {
        return BCM_E_PORT;
    }
#endif /* BCM_RCPU_SUPPORT */

    /*    coverity[uninit_use_in_call : FALSE]    */
    BCM_IF_ERROR_RETURN
        (bcm_esw_port_speed_max(unit,port, &max_speed));

    if (IS_XL_PORT(unit,port) && (speed == 12700)) {
        speed = 13000;
    }

    if ((speed < 0) || (speed > max_speed)) {
        if ((speed > max_speed) &&
            !soc_feature(unit, soc_feature_flexport_based_speed_set))
        return BCM_E_CONFIG; 
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (SOC_IS_TOMAHAWKX(unit) || SOC_IS_TRIDENT3(unit)) {
        int cur_speed;

        BCM_IF_ERROR_RETURN
            (bcm_esw_port_speed_get(unit, port, &cur_speed));
        if ((speed == 0) && (max_speed == cur_speed)) {
            /* no speed set is required */
            return BCM_E_NONE;
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /*
     * When performing flexport based speed changes, disable port
     * first prior to affecting speed change
     */
    if (soc_feature(unit, soc_feature_flexport_based_speed_set) &&
        !SOC_PBMP_MEMBER(PBMP_MANAGEMENT(unit), port) &&
        !SOC_PORT_USE_PORTCTRL(unit, port)) {
        BCM_IF_ERROR_RETURN(bcm_esw_port_enable_get(unit, port, &enable));
        if (TRUE == enable) {
            BCM_IF_ERROR_RETURN(bcm_esw_port_enable_set(unit, port, FALSE));
        }
    }

    PORT_LOCK(unit);                    /* multiple operations operation */

    rv = _bcm_port_speed_set(unit, port, speed);
    PORT_UNLOCK(unit);                  /* Unlock before link call */
    /*
     * Restore port's enable state based on what was read prior
     * to setting speed
     */
    if (soc_feature(unit, soc_feature_flexport_based_speed_set) &&
        !SOC_PBMP_MEMBER(PBMP_MANAGEMENT(unit), port) &&
        !SOC_PORT_USE_PORTCTRL(unit, port)) {
        if (TRUE == enable) {
            BCM_IF_ERROR_RETURN(bcm_esw_port_enable_set(unit, port, TRUE));
        }
    }

    if (BCM_SUCCESS(rv) && !SAL_BOOT_SIMULATION) {
        SOC_PBMP_CLEAR(pbm);
        SOC_PBMP_PORT_ADD(pbm, port);
        (void)bcm_esw_link_change(unit, pbm);
    }
    PORT_LOCK(unit);                    /* multiple operations operation */
    rv1 = _bcm_esw_port_link_delay_update(unit, port, speed);
    PORT_UNLOCK(unit);                  /* Unlock before link call */
    if (BCM_FAILURE(rv1)) {
        if (BCM_SUCCESS(rv)) {
            rv = rv1;
        }
    }

#if defined(BCM_PORT_SPEED_CHANGE_BENCHMARK)
    time_end = SAL_USECS_SUB(sal_time_usecs(), time_start);
    LOG_INFO(BSL_LS_BCM_BENCHMARK,
            (BSL_META_U(unit,
                        "\nPort %d speed change to %d processing took %d usecs\n"),
                        port,
                        speed,
                        time_end));
#endif

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_speed_set: u=%d p=%d speed=%d rv=%d\n"),
              unit, port, speed, rv));

   return rv;
}

/*
 * Function:
 *      bcm_port_master_get
 * Purpose:
 *      Getting the master status of the port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      ms - (OUT) BCM_PORT_MS_*
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      WARNING: assumes BCM_PORT_MS_* matches SOC_PORT_MS_*
 */

int
bcm_esw_port_master_get(int unit, bcm_port_t port, int *ms)
{
    int         rv=BCM_E_NONE;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_master_get(unit, port, ms);
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    PORT_LOCK(unit);
    rv = soc_phyctrl_master_get(unit, port, ms);
    PORT_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_port_master_set
 * Purpose:
 *      Setting the master status for a given port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      ms - BCM_PORT_MS_*
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      Ignored if not supported on port.
 *      WARNING: assumes BCM_PORT_MS_* matches SOC_PORT_MS_*
 */

int
bcm_esw_port_master_set(int unit, bcm_port_t port, int ms)
{
    int         rv;
    pbmp_t      pbm;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_master_set(unit, port, ms);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot configure OAMP Port %d to be master.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef BCM_RCPU_SUPPORT
    if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, port)) {
        return BCM_E_PORT;
    }
#endif /* BCM_RCPU_SUPPORT */

    PORT_LOCK(unit);                    /* multiple operations operation */

    rv = soc_phyctrl_master_set(unit, port, ms);
    if (BCM_FAILURE(rv)) {
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "PHY_MASTER_SETfailed:%s\n"), bcm_errmsg(rv)));
    }

#if defined(BCM_XMAC_SUPPORT)
    if(SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit) ||
       SOC_IS_TRIDENT(unit) || SOC_IS_TITAN(unit)) {
       uint32 vco_disturbed = 0;
       phy_ctrl_t *int_pc;
        if (soc_feature(unit, soc_feature_xmac) && (IS_HG_PORT(unit, port) ||
                    IS_XE_PORT(unit, port))) {

            int_pc = INT_PHY_SW_STATE(unit, port);
            rv = PHYCTRL_CONTROL_GET(int_pc, unit, port, SOC_PHY_CONTROL_VCO_DISTURBED, &vco_disturbed);
            if (!((rv == SOC_E_NONE) || (rv == SOC_E_UNAVAIL))) {
                PORT_UNLOCK(unit);
                return rv;
            }
            if (vco_disturbed) {
                rv = _mac_x_reinit(unit, port);
                if (BCM_FAILURE(rv)) {
                    PORT_UNLOCK(unit);
                    return rv;
                }
            }
        }
    }
#endif
    PORT_UNLOCK(unit);                  /* Unlock before link call */

    if (BCM_SUCCESS(rv)) {
        SOC_PBMP_CLEAR(pbm);
        SOC_PBMP_PORT_ADD(pbm, port);
        (void)bcm_esw_link_change(unit, pbm);
    }

    return rv;
}

/*
 * Function:
 *      bcm_port_interface_get
 * Purpose:
 *      Getting the interface type of a port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      intf - (OUT) BCM_PORT_IF_*
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      WARNING: assumes BCM_PORT_IF_* matches SOC_PORT_IF_*
 */

int
bcm_esw_port_interface_get(int unit, bcm_port_t port, bcm_port_if_t *intf)
{
    int         rv=BCM_E_NONE;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_interface_get(unit, port, intf);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit), port)) {
        return BCM_E_PORT;
    }
    PORT_LOCK(unit);
    rv = soc_phyctrl_interface_get(unit, port, intf);
    PORT_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_port_interface_set
 * Purpose:
 *      Setting the interface type for a given port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      if - BCM_PORT_IF_*
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      WARNING: assumes BCM_PORT_IF_* matches SOC_PORT_IF_*
 */

int
bcm_esw_port_interface_set(int unit, bcm_port_t port, bcm_port_if_t intf)
{
    int         rv;
    pbmp_t      pbm;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_interface_set(unit, port, intf);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META(
				   		"Error: Cannot set interface type on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit), port)) {
        return BCM_E_PORT;
    }

#ifdef BCM_RCPU_SUPPORT
    if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, port)) {
        return BCM_E_PORT;
    }
#endif /* BCM_RCPU_SUPPORT */

    PORT_LOCK(unit);                    /* multiple operations operation */

    rv = soc_phyctrl_interface_set(unit, port, intf);
    if (BCM_FAILURE(rv)) {
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "PHY_INTERFACE_SETfailed:%s\n"), bcm_errmsg(rv)));
    }
#if defined(BCM_XMAC_SUPPORT)
    if(SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit) ||
       SOC_IS_TRIDENT(unit) || SOC_IS_TITAN(unit)) {
       uint32 vco_disturbed = 0;
       phy_ctrl_t *int_pc;
        if (soc_feature(unit, soc_feature_xmac) && (IS_HG_PORT(unit, port) ||
                    IS_XE_PORT(unit, port))) {

            int_pc = INT_PHY_SW_STATE(unit, port);
            rv = PHYCTRL_CONTROL_GET(int_pc, unit, port, SOC_PHY_CONTROL_VCO_DISTURBED, &vco_disturbed);
            if (!((rv == SOC_E_NONE) || (rv == SOC_E_UNAVAIL))) {
                PORT_UNLOCK(unit);
                return rv;
            }
            if (vco_disturbed) {
                rv = _mac_x_reinit(unit, port);
                if (BCM_FAILURE(rv)) {
                    PORT_UNLOCK(unit);
                    return rv;
                }
            }
        }
    }
#endif

    PORT_UNLOCK(unit);                  /* Unlock before link call */

    if (BCM_SUCCESS(rv)) {
        SOC_PBMP_CLEAR(pbm);
        SOC_PBMP_PORT_ADD(pbm, port);
        (void)bcm_esw_link_change(unit, pbm);
        PORT(unit, port).intf = intf;
    }

    return rv;
}

/*
 * Function:
 *      bcm_port_loopback_set
 * Purpose:
 *      Setting the speed for a given port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      loopback - one of:
 *              BCM_PORT_LOOPBACK_NONE
 *              BCM_PORT_LOOPBACK_MAC
 *              BCM_PORT_LOOPBACK_PHY
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_loopback_set(int unit, bcm_port_t port, int loopback)
{
    int             rv, link = TRUE;
    int             phy_lane = -1;
    int             phyn = 0, sys_side = 0;
    bcm_port_t      local_port = -1;
#if defined(BCM_TOMAHAWK_SUPPORT)
    uint32          link_st = 0;
    soc_timeout_t   to;
    int             phy_port;
#endif
    soc_persist_t   *sop = SOC_PERSIST(unit);

#ifdef BCM_TRIDENT2_SUPPORT
    int             enable;
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        /* Check if port have to force-loopback */
        if (BCM_ESW_PORT_DRV(unit)!= NULL) {
            if (BCM_ESW_PORT_DRV(unit)->force_lb_check != NULL) {
                rv = BCM_ESW_PORT_DRV(unit)->force_lb_check(unit, port,
                                                            loopback);
                if (rv != BCM_E_NONE) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META("Error: Port %d allow PHY internal "
                                        "loopback only.\n"),
                               port));
                    return BCM_E_PARAM;
                }
            }
        }

        return bcmi_esw_portctrl_loopback_set(unit, port, loopback);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot set loopback on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_phyn_validate(unit, port,
                                                        &local_port, &phyn,
                                                        &phy_lane, &sys_side));

    if (local_port == -1) {
       BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    } else {
       port = local_port;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (SOC_IS_TOMAHAWKX(unit)) {
        BCM_IF_ERROR_RETURN(bcm_th_phy_lb_check(unit, port, loopback));
    }
#endif

#ifdef BCM_RCPU_SUPPORT
    if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, port)) {
        return BCM_E_PORT;
    }
#endif /* BCM_RCPU_SUPPORT */

    PORT_LOCK(unit);
    soc_phyctrl_enable_get(unit, port, &link);
    PORT_UNLOCK(unit);
    if (TRUE == link) {
        if (SOC_PBMP_MEMBER(sop->lc_pbm_override_ports, port)) {
            if(!SOC_PBMP_MEMBER(sop->lc_pbm_override_link, port)) {
                link = FALSE;
            }
        }
    }

    rv = BCM_E_NONE;
    /*
     * Always force link before changing hardware to avoid
     * race with the linkscan thread.
     */
    if (!(loopback == BCM_PORT_LOOPBACK_NONE)) {
        rv = _bcm_esw_link_force(unit, 0 /*flags*/, port, TRUE, FALSE);

        if(rv == BCM_E_NONE) {
            /* Force the update function to be called so the state is
               updated */
            if (_soc_linkscan_phy_flags_test(unit, port, PHY_FLAGS_EXTERNAL_PHY)) {
                rv = bcm_esw_port_update(unit, port, TRUE);
            }
        }
    }

    PORT_LOCK(unit);

    if (BCM_SUCCESS(rv)) {
        rv = MAC_LOOPBACK_SET(PORT(unit, port).p_mac, unit, port,
                              (loopback == BCM_PORT_LOOPBACK_MAC));
    }
    if (BCM_SUCCESS(rv)) {
        if (local_port == -1) {
            if (loopback == BCM_PORT_LOOPBACK_PHY_REMOTE) {
                rv = soc_phyctrl_control_set(unit, port,
                                             SOC_PHY_CONTROL_LOOPBACK_REMOTE, 1);
            } else {
                if (loopback == BCM_PORT_LOOPBACK_NONE) {
                    rv = soc_phyctrl_control_set(unit, port,
                                             SOC_PHY_CONTROL_LOOPBACK_REMOTE, 0);
                }

                if (rv == SOC_E_NONE || rv == SOC_E_UNAVAIL) {
                    rv = soc_phyctrl_loopback_set(unit, port,
                                                  (loopback == BCM_PORT_LOOPBACK_PHY),
                                                  TRUE);
                }
            }

        } else {
            rv = soc_phyctrl_redirect_loopback_set
                                          (unit, port, phyn,
                                           phy_lane, sys_side,
                                           (loopback == BCM_PORT_LOOPBACK_PHY),
                                           TRUE);
        }
    }
    /* some mac loopback implementations require the phy to also be in loopback */
    if (soc_feature(unit, soc_feature_phy_lb_needed_in_mac_lb) &&
        (loopback == BCM_PORT_LOOPBACK_MAC)) {
        if (local_port == -1) {
            rv = soc_phyctrl_loopback_set(unit, port, 1, TRUE);
        } else {
            rv = soc_phyctrl_redirect_loopback_set(unit, port, phyn,
                                                   phy_lane, sys_side,
                                                   1, TRUE);
        }
     }

    PORT_UNLOCK(unit);                  /* unlock before link call */

    if ((loopback == BCM_PORT_LOOPBACK_NONE) || !BCM_SUCCESS(rv)) {
        _bcm_esw_link_force(unit, 0 /*flags*/, port, FALSE, DONT_CARE);
        PORT_LOCK(unit);
#ifdef BCM_TRIDENT2_SUPPORT
        /* When the PHY is TSC, need to unsquelch TX LANE. */
        if (SOC_IS_TD2_TT2(unit) && !SOC_IS_TOMAHAWKX(unit)
            && !(SOC_IS_HURRICANE4(unit) && IS_EGPHY_PORT(unit, port))){
            enable = PORT(unit, port).enable;
            if ((FALSE == enable) && (loopback == BCM_PORT_LOOPBACK_NONE)) {
                (void)soc_phyctrl_notify(unit, port, phyEventTxSquelch, FALSE);
                rv = soc_phyctrl_enable_set(unit, port, FALSE);
                if (SOC_FAILURE(rv)) {
                    PORT_UNLOCK(unit);
                    return (rv);
                }
                rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, FALSE);
            }
        } else
#endif /* BCM_TRIDENT2_SUPPORT */
        {
            if ((FALSE == link) && (loopback == BCM_PORT_LOOPBACK_NONE)) {
                /* Disable MAC RX to prevent traffic going into this port */
                MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                SOC_MAC_CONTROL_RX_SET, FALSE);
                sal_udelay(100); /* Wait for 1 jumbo packet transmission time */

                rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, FALSE);
            }
        }
        PORT_UNLOCK(unit);
    } else {
        /* Enable only MAC instead of calling bcm_port_enable_set so
         * that this API doesn't silently enable the port if the
         * port is disabled by application.
         */
        rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, TRUE);

#ifdef BCM_TRIDENT2_SUPPORT
        /* When the PHY is TSC, need to enable the PHY to support MAC loopback
         * on a disabled port. In order to avoid link flap of link partner,
         * need to squelch TX LANE before enabling PHY.
         */
        if (BCM_FAILURE(rv)) {
            return (rv);
        }
        if ((SOC_IS_TD2_TT2(unit) && !SOC_IS_TOMAHAWKX(unit))
            && !(SOC_IS_HURRICANE4(unit) && IS_EGPHY_PORT(unit, port))
            && (FALSE == link)
            && (loopback == BCM_PORT_LOOPBACK_MAC)) {
            PORT_LOCK(unit);
            (void)soc_phyctrl_notify(unit, port, phyEventTxSquelch, TRUE);
            rv = soc_phyctrl_enable_set(unit, port, TRUE);
            PORT_UNLOCK(unit);
            if (SOC_FAILURE(rv)) {
                return (rv);
            }
        }
#endif /* BCM_TRIDENT2_SUPPORT */

        if (BCM_SUCCESS(rv)) {
            /* Make sure that the link status is updated only after the
             * MAC is enabled so that link_mask2 is set before the
             * calling thread synchronizes with linkscan thread in
             * _bcm_link_force call.
             * If the link is forced before MAC is enabled, there could
             * be a race condition in _soc_link_update where linkscan
             * may use an old view of link_mask2 and override the
             * EPC_LINK_BMAP after the mac_enable_set updates
             * link_mask2 and EPC_LINK_BMAP.
             */
            if (loopback == BCM_PORT_LOOPBACK_MAC) {
                rv = _bcm_esw_link_force(unit, 0 /*flags*/, port, TRUE, TRUE);
            } else {
                rv = _bcm_esw_link_force(unit, 0 /*flags*/, port, TRUE, link);
            }
        }
        if (BCM_FAILURE(rv)) {
            return (rv);
        }

#if defined(BCM_BRADLEY_SUPPORT)
        /*
         * Call _bcm_port_mmu_update explicitly because linkscan
         * will not call bcm_port_update when the link is forced.
         */
        if (SOC_IS_HBX(unit) && !SOC_IS_SHADOW(unit)) {
            rv = _bcm_port_mmu_update(unit, port, 1);
        }

        /* When a link comes up, hardware will not update the
         * LINK_STATUS register until software has toggled the
         * the LAG_FAILOVER_CONFIG.LINK_STATUS_UP field.
         * Normally, this is done by bcm_port_update. But since
         * linkscan will not call bcm_port_update when a link is
         * forced up, the toggling of LAG_FAILOVER_CONFIG.LINK_STATUS_UP
         * is done here.
         */
        if ((SOC_REG_IS_VALID(unit, GXPORT_LAG_FAILOVER_CONFIGr) &&
             IS_GX_PORT(unit, port)) ||
            (SOC_REG_IS_VALID(unit, LAG_FAILOVER_CONFIGr)) ||
            (SOC_REG_IS_VALID(unit, XLPORT_LAG_FAILOVER_CONFIGr) &&
              (IS_XL_PORT(unit, port) || IS_MXQ_PORT(unit, port))) ||
            (SOC_REG_IS_VALID(unit, CLPORT_LAG_FAILOVER_CONFIGr) &&
              IS_CL_PORT(unit, port))) {
            soc_reg_t reg;
            uint32 rval;

            if (SOC_IS_SABER2(unit) && SOC_REG_PORT_VALID(unit, XLPORT_LAG_FAILOVER_CONFIGr, port)) {
                reg = XLPORT_LAG_FAILOVER_CONFIGr;
            } else if (SOC_REG_IS_VALID(unit, LAG_FAILOVER_CONFIGr)) {
                reg = LAG_FAILOVER_CONFIGr;
            } else if (SOC_REG_IS_VALID(unit, GXPORT_LAG_FAILOVER_CONFIGr)) {
                reg = GXPORT_LAG_FAILOVER_CONFIGr;
            } else if (SOC_REG_PORT_VALID(unit, CLPORT_LAG_FAILOVER_CONFIGr, port) &&
                       (SOC_IS_TOMAHAWKX(unit) || IS_CL_PORT(unit, port))) {
                reg = CLPORT_LAG_FAILOVER_CONFIGr;
            } else {
                reg = XLPORT_LAG_FAILOVER_CONFIGr;
            }

#if defined(BCM_TOMAHAWK_SUPPORT)
           if (SOC_IS_TOMAHAWK(unit)) {
               phy_port = SOC_INFO(unit).port_l2p_mapping[port];
               if((phy_port == TH_MGMT_PORT0_NUM) ||
                  (phy_port == TH_MGMT_PORT1_NUM)) {
                   reg = XLPORT_LAG_FAILOVER_CONFIGr;
               }
               /* Link status to IPIPE is updated by H/W and driven based on both the
               * rising edge of XLPORT_LAG_FAILOVER_CONFIG.LINK_STATUS_UP and
               * actual link up status from Serdes.
               * In some loopback scenarios it may take longer time to see Serdes link up status.
               */
               soc_timeout_init(&to, 10000, 0);
               do {
                      if (((phy_port != TH_MGMT_PORT0_NUM) &&
                           (phy_port != TH_MGMT_PORT1_NUM)) ||
                           (loopback == BCM_PORT_LOOPBACK_NONE)) {
                          break;
                      }

                      switch(phy_port) {
                          case TH_MGMT_PORT0_NUM:
                              BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XLPORT_XGXS0_LN0_STATUS0_REGr, port, 0, &rval));
                              link_st = soc_reg_field_get(unit, XLPORT_XGXS0_LN0_STATUS0_REGr, rval, LINK_STATUSf);
                              break;
                          case TH_MGMT_PORT1_NUM:
                              BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XLPORT_XGXS0_LN2_STATUS0_REGr, port, 0, &rval));
                              link_st = soc_reg_field_get(unit, XLPORT_XGXS0_LN2_STATUS0_REGr, rval, LINK_STATUSf);
                              break;
                      }
                      if(link_st) {
                          break;
                      }
               } while (!soc_timeout_check(&to));
           }
#endif
           /* Toggle link bit to notify IPIPE on link up */
           BCM_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));
           soc_reg_field_set(unit, reg, &rval, LINK_STATUS_UPf, 1);
           BCM_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
           soc_reg_field_set(unit, reg, &rval, LINK_STATUS_UPf, 0);
           BCM_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
        }
#endif /* BCM_BRADLEY_SUPPORT */
    }

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_loopback_set: u=%d p=%d lb=%d rv=%d\n"),
              unit, port, loopback, rv));

    return rv;
}

/*
 * Function:
 *      bcm_port_loopback_get
 * Purpose:
 *      Recover the current loopback operation for the specified port.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      loopback - (OUT) one of:
 *              BCM_PORT_LOOPBACK_NONE
 *              BCM_PORT_LOOPBACK_MAC
 *              BCM_PORT_LOOPBACK_PHY
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_loopback_get(int unit, bcm_port_t port, int *loopback)
{
    int         rv = BCM_E_NONE;
    int         phy_lb = 0;
    uint32      phy_rlb = 0;
    int         mac_lb = 0;
    int         phy_lane = -1;
    int         phyn = 0, sys_side = 0;
    bcm_port_t  local_port = -1;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_loopback_get(unit, port, loopback);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_phyn_validate(unit, port,
                                                        &local_port, &phyn,
                                                        &phy_lane, &sys_side));

    if (local_port == -1) {
       BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    } else {
       port = local_port;
    }
    PORT_LOCK(unit);                    /* multiple operations operation */

    if (local_port == -1) {
        /* Most ext-phys don't support remote loopback and return SOC_E_UNAVAIL.
         * When the return value is SOC_E_UNAVAIL, continue to get phy or mac
         * loopback mode
         */
        rv = soc_phyctrl_control_get(unit, port,
                                     SOC_PHY_CONTROL_LOOPBACK_REMOTE,
                                     &phy_rlb);
        if (rv >= 0 || rv == SOC_E_UNAVAIL) {
            rv = soc_phyctrl_loopback_get(unit, port, &phy_lb);
        }
    } else {
        rv = soc_phyctrl_redirect_loopback_get(unit, port, phyn,
                                               phy_lane, sys_side,
                                               &phy_lb);
    }

        rv = MAC_LOOPBACK_GET(PORT(unit, port).p_mac, unit, port, &mac_lb);

    PORT_UNLOCK(unit);
    if (rv >= 0) {
        if (mac_lb) {
            *loopback = BCM_PORT_LOOPBACK_MAC;
        } else if (phy_lb) {
            *loopback = BCM_PORT_LOOPBACK_PHY;
        } else if (phy_rlb) {
            *loopback = BCM_PORT_LOOPBACK_PHY_REMOTE;
        } else {
            *loopback = BCM_PORT_LOOPBACK_NONE;
        }
    } else {
        *loopback = BCM_PORT_LOOPBACK_NONE;
    }

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_loopback_get: u=%d p=%d lb=%d rv=%d\n"),
              unit, port, *loopback, rv));

    return rv;
}

/*
 * Function:
 *      bcm_port_duplex_get
 * Purpose:
 *      Get the port duplex settings
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      duplex - (OUT) Duplex setting, one of SOC_PORT_DUPLEX_xxx
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_duplex_get(int unit, bcm_port_t port, int *duplex)
{
    int         phy_duplex;
    int         rv=BCM_E_NONE;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_duplex_get(unit, port, duplex);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    PORT_LOCK(unit);
    rv = soc_phyctrl_duplex_get(unit, port, &phy_duplex);
    PORT_UNLOCK(unit);

    if (BCM_SUCCESS(rv)) {
        *duplex = phy_duplex ? SOC_PORT_DUPLEX_FULL : SOC_PORT_DUPLEX_HALF;
    } else {
        *duplex = SOC_PORT_DUPLEX_FULL;
    }

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_duplex_get: u=%d p=%d dup=%d rv=%d\n"),
              unit, port, *duplex, rv));

    return rv;
}

/*
 * Function:
 *      _bcm_port_duplex_ability_check
 * Purpose:
 *      Check the port duplex ability.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      duplex - Duplex setting, one of SOC_PORT_DUPLEX_xxx
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */
STATIC int
_bcm_esw_port_duplex_ability_check(int unit, bcm_port_t port, int duplex)
{
    bcm_port_ability_t ability_mask;
    int         rv;
    int         mac_lb;
    int         speed = 0, full_duplex_speed, half_duplex_speed;
    uint32      pa_speed = 0;
    sal_memset(&ability_mask, 0, sizeof(bcm_port_ability_t));
    rv = MAC_LOOPBACK_GET(PORT(unit, port).p_mac, unit, port, &mac_lb);
    if (BCM_SUCCESS(rv)) {
        /* If the port is in mac loopback, we get mac_ability rather than port_ability. */
        if(mac_lb) {
           rv = MAC_ABILITY_LOCAL_GET(PORT(unit, port).p_mac, unit,port, &ability_mask);
        } else {
           rv = bcm_esw_port_ability_local_get(unit, port, &ability_mask);
        }
        if (rv < 0) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META("Error: Could not get port %d ability: %s\n"),
                         port, bcm_errmsg(rv)));
            return rv;
        }
        if ((rv = bcm_esw_port_speed_get(unit, port, &speed)) < 0) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META("Error: Could not get port %d speed: %s\n"),
                         port, bcm_errmsg(rv)));
            return rv;
        }
        pa_speed = SOC_PA_SPEED(speed);
        full_duplex_speed = ability_mask.speed_full_duplex & pa_speed;
        half_duplex_speed = ability_mask.speed_half_duplex & pa_speed;
        if (!soc_feature(unit, soc_feature_flexport_based_speed_set) && (speed != 0)) {
            if (duplex) {
                if (!full_duplex_speed) {
                    LOG_WARN(BSL_LS_BCM_PORT,
                             (BSL_META_U(unit, "Warning: port %d does not support %d mbps full duplex\n"),
                              port, speed));
                    return BCM_E_UNAVAIL;
                }
            } else {
                if (!half_duplex_speed) {
                    LOG_WARN(BSL_LS_BCM_PORT,
                             (BSL_META_U(unit, "Warning: port %d does not support %d mbps half duplex\n"),
                              port, speed));
                    return BCM_E_UNAVAIL;
                }
            }
        }
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_duplex_set
 * Purpose:
 *      Set the port duplex settings.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      duplex - Duplex setting, one of SOC_PORT_DUPLEX_xxx
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      Turns off autonegotiation.  Caller must make sure other forced
 *      parameters (such as speed) are set.
 */

int
bcm_esw_port_duplex_set(int unit, bcm_port_t port, int duplex)
{
    int         rv;
    pbmp_t      pbm;
    int         an = 0 ;
    int         an_done=0;
#if defined(BCM_SABER2_SUPPORT)
    int             phy_status;
#endif
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_duplex_set(unit, port, duplex);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot set duplex mode on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    } else
#endif
     if((!BCM_GPORT_IS_SET(port)) && (!(SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit), port)))) {
        return BCM_E_PORT;
     }
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef BCM_RCPU_SUPPORT
    if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, port)) {
        return BCM_E_PORT;
    }
#endif /* BCM_RCPU_SUPPORT */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (SOC_IS_TOMAHAWK(unit)) {
        /*half-duplex is not supported at any speed Eagle & Falcon */
        if (duplex == 0) {
            return BCM_E_UNAVAIL;
        }
    }
#endif

    /* in SIMULATION, port's alility_mask may not be correct due to NULL phy */
    if (!SAL_BOOT_SIMULATION) {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_duplex_ability_check(unit, port, duplex));
    }

    PORT_LOCK(unit);

#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit) && IS_XL_PORT(unit, port)) {
        rv = soc_phyctrl_enable_get(unit, port, &phy_status);
        if (BCM_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
        if(phy_status == TRUE) {
            rv = soc_phyctrl_enable_set(unit, port, FALSE);
            if (BCM_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
        }
    }
#endif
    rv = soc_phyctrl_auto_negotiate_get(unit, port, &an, &an_done);
    if (BCM_FAILURE(rv)) {
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "PHY_AUTONEG_GETfailed:%s\n"), bcm_errmsg(rv)));
    }
    if(an != FALSE)
    {
        rv = soc_phyctrl_auto_negotiate_set(unit, port, FALSE);
        if (BCM_FAILURE(rv)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "PHY_AUTONEG_SETfailed:%s\n"), bcm_errmsg(rv)));
        }
    }

#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit) &&
            IS_XL_PORT(unit, port) && (phy_status == TRUE)) {
        /* Enable phy in tsc only if already enabled before config change */
        rv = soc_phyctrl_enable_set(unit, port, TRUE);
        if (BCM_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
    }
#endif

    if (BCM_SUCCESS(rv)) {
        rv = soc_phyctrl_duplex_set(unit, port, duplex);
        if (BCM_FAILURE(rv)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "PHY_DUPLEX_SETfailed:%s\n"), bcm_errmsg(rv)));
        }
    }

    if (BCM_SUCCESS(rv)) {
        rv = MAC_DUPLEX_SET(PORT(unit, port).p_mac, unit, port, duplex);
        if (BCM_FAILURE(rv)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "MAC_DUPLEX_SETfailed:%s\n"), bcm_errmsg(rv)));
        }
    }
#if defined(BCM_XMAC_SUPPORT)
    if(SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit) ||
       SOC_IS_TRIDENT(unit) || SOC_IS_TITAN(unit)) {
       uint32 vco_disturbed = 0;
       phy_ctrl_t *int_pc;
        if (soc_feature(unit, soc_feature_xmac) && (IS_HG_PORT(unit, port) ||
                    IS_XE_PORT(unit, port))) {

            int_pc = INT_PHY_SW_STATE(unit, port);
            rv = PHYCTRL_CONTROL_GET(int_pc, unit, port, SOC_PHY_CONTROL_VCO_DISTURBED, &vco_disturbed);
            if (!((rv == SOC_E_NONE) || (rv == SOC_E_UNAVAIL))) {
                PORT_UNLOCK(unit);
                return rv;
            }
            if (vco_disturbed) {
                rv = _mac_x_reinit(unit, port);
                if (BCM_FAILURE(rv)) {
                    PORT_UNLOCK(unit);
                    return rv;
                }
            }
        }
    }
#endif

    PORT_UNLOCK(unit);                  /* Unlock before link call */

    if (BCM_SUCCESS(rv) && !SAL_BOOT_SIMULATION) {
        SOC_PBMP_CLEAR(pbm);
        SOC_PBMP_PORT_ADD(pbm, port);
        (void)bcm_esw_link_change(unit, pbm);
    }

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_duplex_set: u=%d p=%d dup=%d rv=%d\n"),
              unit, port, duplex, rv));

    return rv;
}

/*
 * Function:
 *      bcm_port_pause_get
 * Purpose:
 *      Get the source address for transmitted PAUSE frames.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      pause_tx - (OUT) Boolean value
 *      pause_rx - (OUT) Boolean value
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_pause_get(int unit, bcm_port_t port, int *pause_tx, int *pause_rx)
{
    int         rv;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_pause_get(unit, port, pause_tx, pause_rx);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);
    rv = MAC_PAUSE_GET(PORT(unit, port).p_mac, unit, port, pause_tx, pause_rx);
    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_port_pause_set
 * Purpose:
 *      Set the pause state for a given port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      pause_tx - Boolean value, or -1 (don't change)
 *      pause_rx - Boolean value, or -1 (don't change)
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      Symmetric pause requires the two "pause" values to be the same.
 */

int
bcm_esw_port_pause_set(int unit, bcm_port_t port, int pause_tx, int pause_rx)
{
    int         rv;
#ifdef BCM_MONTEREY_SUPPORT
    uint32      enable = 0;
#endif
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
#ifdef BCM_MONTEREY_SUPPORT
        if (SOC_IS_MONTEREY(unit)) {
            BCM_IF_ERROR_RETURN(
                bcmi_esw_portctrl_preemption_mac_config_get(
                unit, port, bcmPortPreemptControlEnableTx, &enable));
            if (enable && (pause_tx || pause_rx)) {
                return BCM_E_PARAM;
            }
        }
#endif
        return bcmi_esw_portctrl_pause_set(unit, port, pause_tx, pause_rx);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot set pause state on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);
    rv = MAC_PAUSE_SET(PORT(unit, port).p_mac, unit, port, pause_tx, pause_rx);
    if (BCM_FAILURE(rv)) {
        PORT_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_BRADLEY_SUPPORT)
    if (SOC_IS_HBX(unit)) {
#ifdef BCM_SHADOW_SUPPORT
    if (!SOC_IS_SHADOW(unit)) {
#endif
        rv = _bcm_port_mmu_update(unit, port, -1);
#ifdef BCM_SHADOW_SUPPORT
    }
#endif
    }
#endif /* BCM_BRADLEY_SUPPORT */

    PORT_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_port_pause_sym_get
 * Purpose:
 *      Get the current pause setting for pause
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      pause - (OUT) returns a bcm_port_pause_e enum value
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_pause_sym_get(int unit, bcm_port_t port, int *pause)
{
    int         pause_rx, pause_tx;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN
        (bcm_esw_port_pause_get(unit, port, &pause_tx, &pause_rx));
    if (pause_tx) {
        if (pause_rx) {
            *pause = BCM_PORT_PAUSE_SYM;
        } else {
            *pause = BCM_PORT_PAUSE_ASYM_TX;
        }
    } else if (pause_rx) {
        *pause = BCM_PORT_PAUSE_ASYM_RX;
    } else {
        *pause = BCM_PORT_PAUSE_NONE;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_pause_sym_set
 * Purpose:
 *      Set the pause values for the port using single integer
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      pause - a bcm_port_pause_e enum value
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_pause_sym_set(int unit, bcm_port_t port, int pause)
{
    int         pause_rx, pause_tx;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot set pause values on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    pause_tx = pause_rx = 0;

    switch (pause) {
    case BCM_PORT_PAUSE_SYM:
        pause_tx = pause_rx = 1;
        break;
    case BCM_PORT_PAUSE_ASYM_RX:
        pause_rx = 1;
        break;
    case BCM_PORT_PAUSE_ASYM_TX:
        pause_tx = 1;
        break;
    case BCM_PORT_PAUSE_NONE:
        break;
    default:
        return BCM_E_PARAM;
    }

    return bcm_esw_port_pause_set(unit, port, pause_tx, pause_rx);
}

/*
 * Function:
 *      bcm_port_pause_addr_get
 * Purpose:
 *      Get the source address for transmitted PAUSE frames.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      mac - (OUT) MAC address sent with pause frames.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_pause_addr_get(int unit, bcm_port_t port, bcm_mac_t mac)
{
    int         rv;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_pause_addr_get(unit, port, mac);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);
    rv = MAC_PAUSE_ADDR_GET(PORT(unit, port).p_mac, unit, port, mac);
    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_port_pause_addr_set
 * Purpose:
 *      Set the source address for transmitted PAUSE frames.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      mac - station address used for pause frames.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      Symmetric pause requires the two "pause" values to be the same.
 */

int
bcm_esw_port_pause_addr_set(int unit, bcm_port_t port, bcm_mac_t mac)
{
    int         rv;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_pause_addr_set(unit, port, mac);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot set pause addr on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);
    rv = MAC_PAUSE_ADDR_SET(PORT(unit, port).p_mac, unit, port, mac);
    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_port_advert_get
 * Purpose:
 *      Retrieve the local port advertisement for autonegotiation.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      ability_mask - (OUT) Local advertisement.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_advert_get(int unit, bcm_port_t port, bcm_port_abil_t *ability_mask)
{
    int                 rv;
    bcm_port_ability_t  ability;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_ability_advert_get(unit, port,
                                                    &ability, ability_mask);
    }
    sal_memset(&ability, 0, sizeof(bcm_port_ability_t));

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);
    rv = soc_phyctrl_ability_advert_get(unit, port, &ability);
    if (BCM_SUCCESS(rv)) {
        rv = soc_port_ability_to_mode(&ability, ability_mask);
    }
    PORT_UNLOCK(unit);



    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_advert_get: u=%d p=%d abil=0x%x rv=%d\n"),
              unit, port, *ability_mask, rv));

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_ability_advert_get
 * Purpose:
 *      Retrieve the local port advertisement for autonegotiation.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      ability_mask - (OUT) Local advertisement.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_ability_advert_get(int unit, bcm_port_t port,
                                bcm_port_ability_t *ability_mask)
{
    int         rv=BCM_E_NONE;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_ability_advert_get(unit, port,
                                                    ability_mask, NULL);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit), port)) {
        return BCM_E_PORT;
    }

    sal_memset(ability_mask, 0, sizeof(bcm_port_ability_t));
    PORT_LOCK(unit);
    rv = soc_phyctrl_ability_advert_get(unit, port, ability_mask);
    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_esw_port_ability_advert_get: u=%d p=%d rv=%d\n"),
              unit, port, rv));

    return rv;
}
/*
 * Function:
 *      bcm_port_autoneg_ability_advert_get
 * Purpose:
 *      Retrieve the local port abilities.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      max_num_ability  -- the max num of autoneg ability this port can advertise
 *      ability - (OUT) values indicating the ability this port advertise
 *      actual_num_ability - (OUT) the actual num of ability that this port advertise
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */
int
bcm_esw_port_autoneg_ability_advert_get(int unit,
                                     bcm_port_t port,
                                     int max_num_ability,
                                     bcm_port_speed_ability_t *abilities,
                                     int *actual_num_ability)
{
    int rv = BCM_E_UNAVAIL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        rv = bcmi_esw_portctrl_autoneg_ability_advert_get(unit, port, max_num_ability,
                                                          abilities, actual_num_ability);
    }

    return rv;
}


/*
 * Function:
 *      bcm_port_advert_set
 * Purpose:
 *      Set the local port advertisement for autonegotiation.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      ability_mask - Local advertisement.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      This call MAY NOT restart autonegotiation (depending on the phy).
 *      To do that, follow this call with bcm_port_autoneg_set(TRUE).
 */

int
bcm_esw_port_advert_set(int unit, bcm_port_t port, bcm_port_abil_t ability_mask)
{
    int                 rv;
    bcm_port_ability_t  given_ability, port_ability, temp_ability;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_ability_advert_set(unit, port,
                                                    NULL, ability_mask);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot set port advert on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    BCM_IF_ERROR_RETURN
        (bcm_esw_port_ability_local_get(unit, port, &port_ability));

    BCM_IF_ERROR_RETURN
        (bcm_esw_port_ability_advert_get(unit, port, &given_ability));

    BCM_IF_ERROR_RETURN(
        soc_port_mode_to_ability(ability_mask, &given_ability));

    /* temporary store ability of half duplex */
    temp_ability.speed_half_duplex = given_ability.speed_half_duplex;
    /* make sure that the ability advertising in PHY is supported by MAC */
    soc_port_ability_mask(&given_ability, &port_ability);
    /* restore half duplex ability */
    given_ability.speed_half_duplex = temp_ability.speed_half_duplex;

    if (IS_HG_PORT(unit, port) && SOC_INFO(unit).port_speed_max[port]) {
        if (SOC_INFO(unit).port_speed_max[port] < 16000) {
            given_ability.speed_full_duplex &= ~(BCM_PORT_ABILITY_16GB);
            given_ability.speed_half_duplex &= ~(BCM_PORT_ABILITY_16GB);
        }

        if (SOC_INFO(unit).port_speed_max[port] < 13000) {
            given_ability.speed_full_duplex &= ~(BCM_PORT_ABILITY_13GB);
            given_ability.speed_half_duplex &= ~(BCM_PORT_ABILITY_13GB);
        }

        if (SOC_INFO(unit).port_speed_max[port] < 12000) {
            given_ability.speed_full_duplex &= ~(BCM_PORT_ABILITY_12GB);
            given_ability.speed_half_duplex &= ~(BCM_PORT_ABILITY_12GB);
        }

        if (IS_HL_PORT(unit, port)) {
            if (!(given_ability.speed_full_duplex & BCM_PORT_ABILITY_2500MB)) {
                return BCM_E_CONFIG;
            }
        } else if (!(given_ability.speed_full_duplex & (BCM_PORT_ABILITY_16GB |
              BCM_PORT_ABILITY_13GB | BCM_PORT_ABILITY_12GB |
              BCM_PORT_ABILITY_10GB))) {
            return BCM_E_CONFIG;
        }
    }

    PORT_LOCK(unit);
    rv = soc_phyctrl_ability_advert_set(unit, port, &given_ability);
    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_advert_set: u=%d p=%d abil=0x%x rv=%d\n"),
              unit, port, ability_mask, rv));

    return rv;
}

/*
 * Function:
 *      bcm_port_ability_advert_set
 * Purpose:
 *      Set the local port advertisement for autonegotiation.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      ability_mask - Local advertisement.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      This call MAY NOT restart autonegotiation (depending on the phy).
 *      To do that, follow this call with bcm_port_autoneg_set(TRUE).
 */

int
bcm_esw_port_ability_advert_set(int unit, bcm_port_t port,
                                bcm_port_ability_t *ability_mask)
{
    int             rv=BCM_E_NONE;
    bcm_port_ability_t port_ability, temp_ability;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_ability_advert_set(unit, port,
                                                    ability_mask, 0);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META(
						"Error: Cannot set port ability on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit), port)) {
        return BCM_E_PORT;
    }

    BCM_IF_ERROR_RETURN
        (bcm_esw_port_ability_local_get(unit, port, &port_ability));

    /* temporary store speed_half_duplex ability */
    temp_ability.speed_half_duplex = ability_mask->speed_half_duplex;
    /* Make sure to advertise only abilities supported by the port */
    soc_port_ability_mask(&port_ability, ability_mask);
    /* restore speed_half_duplex ability even some mac don't support it */
    port_ability.speed_half_duplex = temp_ability.speed_half_duplex;
    PORT_LOCK(unit);
    rv = soc_phyctrl_ability_advert_set(unit, port, &port_ability);
    PORT_UNLOCK(unit);
    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_ability_advert_set: u=%d p=%d rv=%d\n"),
              unit, port, rv));
    LOG_VERBOSE(BSL_LS_BCM_PORT,
                (BSL_META_U(unit,
                            "Speed(HD=0x%08x, FD=0x%08x) Pause=0x%08x advert_set\n"
                            "Interface=0x%08x Medium=0x%08x Loopback=0x%08x Flags=0x%08x\n"),
                 port_ability.speed_half_duplex,
                 port_ability.speed_full_duplex,
                 port_ability.pause, port_ability.interface,
                 port_ability.medium, port_ability.loopback,
                 port_ability.flags));

    return rv;
}

/*
 * Function:
 *      bcm_port_autoneg_ability_advert_set
 * Purpose:
 *      Set the local port advertisement for autonegotiation.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      num_ability - number of ability the port will advertise
 *      ability - Local advertisement for each ability.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      This call WILL NOT restart autonegotiation (depending on the phy).
 *      To do that, follow this call with bcm_port_autoneg_set(TRUE).
 */

int bcm_esw_port_autoneg_ability_advert_set(int unit,
                                            bcm_port_t port,
                                            int num_ability,
                                            bcm_port_speed_ability_t *abilities)
{
    int             rv = BCM_E_UNAVAIL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        rv = bcmi_esw_portctrl_autoneg_ability_advert_set(unit, port,
                                                          num_ability, abilities);
    }

    return rv;
}


/*
 * Function:
 *      bcm_port_advert_remote_get
 * Purpose:
 *      Retrieve the local port advertisement for autonegotiation.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      ability_mask - (OUT) Remote advertisement.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_advert_remote_get(int unit, bcm_port_t port,
                               bcm_port_abil_t *ability_mask)
{
    int                 rv;
    bcm_port_ability_t  port_ability;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_ability_remote_get(unit, port,
                                                    &port_ability,
                                                    ability_mask);
    }

    sal_memset(&port_ability, 0, sizeof(bcm_port_ability_t));

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);
    rv = _bcm_port_autoneg_advert_remote_get(unit, port, &port_ability);
    if (BCM_SUCCESS(rv)) {
        rv = soc_port_ability_to_mode(&port_ability, ability_mask);
    }
    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_advert_remote_get: u=%d p=%d abil=0x%x rv=%d\n"),
              unit, port, *ability_mask, rv));

    return rv;
}


/*
 * Function:
 *      bcm_port_ability_remote_get
 * Purpose:
 *      Retrieve the local port advertisement for autonegotiation.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      ability_mask - (OUT) Remote advertisement.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */
int
bcm_esw_port_ability_remote_get(int unit, bcm_port_t port,
                           bcm_port_ability_t *ability_mask)
{
    int         rv;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_ability_remote_get(unit, port,
                                                    ability_mask, NULL);
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    sal_memset(ability_mask, 0, sizeof(bcm_port_ability_t));
    PORT_LOCK(unit);
    rv = _bcm_port_autoneg_advert_remote_get(unit, port, ability_mask);
    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_ability_remote_get: u=%d p=%d rv=%d\n"),
              unit, port, rv));
    LOG_VERBOSE(BSL_LS_BCM_PORT,
                (BSL_META_U(unit,
                            "Speed(HD=0x%08x, FD=0x%08x) Pause=0x%08x remote_get\n"
                            "Interface=0x%08x Medium=0x%08x Loopback=0x%08x Flags=0x%08x\n"),
                 ability_mask->speed_half_duplex,
                 ability_mask->speed_full_duplex,
                 ability_mask->pause, ability_mask->interface,
                 ability_mask->medium, ability_mask->loopback,
                 ability_mask->flags));

    return rv;
}
/*
 * Function:
 *      bcm_port_autoneg_ability_remote_get
 * Purpose:
 *      Retrieve the local port abilities.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      max_num_ability  -- the max num of speed ability remote partner can advertise
 *      ability - (OUT) values indicating the ability of the MAC/PHY
 *      actual_num_ability - (OUT) the actual num of ability that remote partner advertise
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */
int
bcm_esw_port_autoneg_ability_remote_get(int unit,
                                     bcm_port_t port,
                                     int max_num_ability,
                                     bcm_port_speed_ability_t *abilities,
                                     int *actual_num_ability)
{
    int rv = BCM_E_UNAVAIL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        rv = bcmi_esw_portctrl_autoneg_ability_remote_get(unit, port, max_num_ability,
                                                          abilities, actual_num_ability);
    }
    return rv;
}


/*
 * Function:
 *      bcm_port_ability_get
 * Purpose:
 *      Retrieve the local port abilities.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      ability_mask - (OUT) Mask of BCM_PORT_ABIL_ values indicating the
 *              ability of the MAC/PHY.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_ability_get(int unit, bcm_port_t port, bcm_port_abil_t *ability_mask)
{
    int                 rv;
    bcm_port_ability_t  port_ability;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_ability_get(unit, port,
                                             &port_ability, ability_mask);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if(!(SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit), port))) {
       return BCM_E_PORT;
    }

    PORT_LOCK(unit);
    rv = _bcm_port_ability_local_get(unit, port, &port_ability);
    if (BCM_SUCCESS(rv)) {
        rv = soc_port_ability_to_mode(&port_ability, ability_mask);
    }
    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_ability_get: u=%d p=%d abil=0x%x rv=%d\n"),
              unit, port, *ability_mask, rv));

    return rv;
}

/*
 * Function:
 *      bcm_port_ability_local_get
 * Purpose:
 *      Retrieve the local port abilities.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      ability_mask - (OUT) Mask of BCM_PORT_ABIL_ values indicating the
 *              ability of the MAC/PHY.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_ability_local_get(int unit, bcm_port_t port,
                               bcm_port_ability_t *ability_mask)
{
    int         rv;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);


    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_ability_get(unit, port,
                                             ability_mask, NULL);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    sal_memset(ability_mask, 0, sizeof(bcm_port_ability_t));
    PORT_LOCK(unit);
    rv = _bcm_port_ability_local_get(unit, port, ability_mask);
    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_ability_local_get: u=%d p=%d rv=%d\n"),
              unit, port, rv));
    LOG_VERBOSE(BSL_LS_BCM_PORT,
                (BSL_META_U(unit,
                            "Speed(HD=0x%08x, FD=0x%08x) Pause=0x%08x local_get\n"
                            "Interface=0x%08x Medium=0x%08x EEE=0x%08x Loopback=0x%08x Flags=0x%08x\n"),
                 ability_mask->speed_half_duplex,
                 ability_mask->speed_full_duplex,
                 ability_mask->pause, ability_mask->interface,
                 ability_mask->medium, ability_mask->eee,
                 ability_mask->loopback, ability_mask->flags));

    return rv;
}
/*
 * Function:
 *      bcm_port_speed_ability_local_get
 * Purpose:
 *      Retrieve the local port abilities.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      max_num_ability  -- the max num of speed ability this port support
 *      ability - (OUT) values indicating the ability of the MAC/PHY
 *      actual_num_ability - (OUT) the actual num of ability that this port can support
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */
int
bcm_esw_port_speed_ability_local_get(int unit,
                                     bcm_port_t port,
                                     int max_num_ability,
                                     bcm_port_speed_ability_t *abilities,
                                     int *actual_num_ability)
{
    int rv = BCM_E_UNAVAIL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        rv = bcmi_esw_portctrl_speed_ability_local_get(unit, port, max_num_ability,
                                                          abilities, actual_num_ability);
    }
    return rv;
}

/*
 * Function:
 *      bcm_port_discard_get
 * Purpose:
 *      Get port discard attributes for the specified port
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      mode - (OUT) Port discard mode, one of BCM_PORT_DISCARD_xxx
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_discard_get(int unit, bcm_port_t port, int *mode)
{
    bcm_port_cfg_t pcfg;
    int                 rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if ((rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg)) ==
        BCM_E_NONE) {
        *mode = pcfg.pc_disc;
    }

    return(rv);
}

/*
 * Function:
 *      bcm_port_discard_set
 * Purpose:
 *      Set port discard attributes for the specified port.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      mode - Port discard mode, one of BCM_PORT_DISCARD_xxx
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_discard_set(int unit, bcm_port_t port, int mode)
{
    bcm_port_cfg_t      pcfg;
    int                 rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Cannot set discard attr on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    switch (mode) {
    case BCM_PORT_DISCARD_TAG:
    case BCM_PORT_DISCARD_NONE:
    case BCM_PORT_DISCARD_ALL:
    case BCM_PORT_DISCARD_UNTAG:
        break;
    default:
        return BCM_E_PARAM;
    }

    PORT_LOCK(unit);

    rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg);

    if (BCM_SUCCESS(rv)) {
        pcfg.pc_disc = mode;
        rv = mbcm_driver[unit]->mbcm_port_cfg_set(unit, port, &pcfg);
    }

    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      _bcm_port_learn_modify
 * Purpose:
 *      Main part of bcm_port_learn_modify.
 */

STATIC int
_bcm_port_learn_modify(int unit, bcm_port_t port, uint32 add, uint32 remove)
{
    uint32      flags;

    SOC_IF_ERROR_RETURN(bcm_esw_port_learn_get(unit, port, &flags));

    flags |= add;
    flags &= ~remove;

    SOC_IF_ERROR_RETURN(bcm_esw_port_learn_set(unit, port, flags));

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_learn_modify
 * Purpose:
 *      Modify the port learn flags, adding add and removing remove flags.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      add  - Flags to set.
 *      remove - Flags to clear.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_learn_modify(int unit, bcm_port_t port, uint32 add, uint32 remove)
{
    int         rv;
    bcm_port_t  port_out;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port_out));

    PORT_LOCK(unit);
    rv = _bcm_port_learn_modify(unit, port, add, remove);
    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_port_learn_get
 * Purpose:
 *      Get the ARL hardware learning options for this port.
 *      This defines what the hardware will do when a packet
 *      is seen with an unknown address.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      flags - (OUT) Logical OR of BCM_PORT_LEARN_xxx flags
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_learn_get(int unit, bcm_port_t port, uint32 *flags)
{
    bcm_port_cfg_t      pcfg;
    int                 rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    if (flags == NULL) {
        return BCM_E_PARAM;
    }

#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_SUBPORT_GROUP(port)) {
         if (SOC_IS_SCORPION(unit)) {
             return BCM_E_UNAVAIL;
         } else {
             return bcm_tr_subport_learn_get(unit, (bcm_gport_t) port, flags);
         }
    }
#endif /* BCM_TRX_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIUMPH_SUPPORT) && defined(BCM_MPLS_SUPPORT) && \
    defined(INCLUDE_L3)
    if (BCM_GPORT_IS_MPLS_PORT(port)) {
        return bcm_tr_mpls_port_learn_get(unit, (bcm_gport_t) port, flags);
    }
#endif
#if ((defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)) \
     && defined(INCLUDE_L3))
    if (BCM_GPORT_IS_MIM_PORT(port)) {
        return bcm_tr2_mim_port_learn_get(unit, (bcm_gport_t) port, flags);
    }
    if (BCM_GPORT_IS_WLAN_PORT(port)) {
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return bcm_tr3_wlan_port_learn_get(unit, (bcm_gport_t) port, flags);
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
            return bcm_tr2_wlan_port_learn_get(unit, (bcm_gport_t) port, flags);
        }
    }
#endif /* BCM_TRIUMPH2_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIDENT_SUPPORT)&& defined(INCLUDE_L3)
    if (BCM_GPORT_IS_NIV_PORT(port)) {
        return bcm_trident_niv_port_learn_get(unit, (bcm_gport_t) port, flags);
    }
#endif /* BCM_TRIDENT_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
    if (SOC_IS_TD2_TT2(unit)) {
        if (BCM_GPORT_IS_VXLAN_PORT(port)) {
            return bcm_td2_vxlan_port_learn_get(unit, (bcm_gport_t) port, flags);
        }
    }
#endif /* BCM_TRIDENT2_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIUMPH3_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_L2GRE_PORT(port)){
        return bcm_tr3_l2gre_port_learn_get(unit, (bcm_gport_t) port, flags);
    }
#endif /* BCM_TRIUMPH3_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIUMPH3_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_EXTENDER_PORT(port)){
        if (soc_feature(unit, soc_feature_port_extension)) {
            return bcm_tr3_extender_port_learn_get(unit, port, flags);
        }
    }
#endif /* BCM_TRIUMPH3_SUPPORT && INCLUDE_L3 */
#if defined(BCM_HGPROXY_COE_SUPPORT) && defined(INCLUDE_L3)
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        (soc_feature(unit, soc_feature_channelized_switching))) &&
        BCM_GPORT_IS_SUBPORT_PORT(port)) {
            return bcmi_xgs5_subport_port_learn_get(unit, (bcm_gport_t) port, flags);
    }
#endif /* BCM_HGPROXY_COE_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_TRUNK(port)){
        if (soc_feature(unit, soc_feature_vp_lag)) {
            return bcm_td2_vp_lag_port_learn_get(unit,
                       BCM_GPORT_TRUNK_GET(port), flags);
        }
    }
#endif /* BCM_TRIDENT2_SUPPORT && INCLUDE_L3 */

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);

    rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg);

    PORT_UNLOCK(unit);

    BCM_IF_ERROR_RETURN(rv);

#ifdef BCM_TRX_SUPPORT
    if (SOC_IS_TRX(unit)) {
        *flags = 0;
        BCM_IF_ERROR_RETURN(
            _bcm_trx_port_cml_hw2flags(unit, pcfg.pc_cml, flags));
    } else
#endif
    {
        switch (pcfg.pc_cml) {
        case PVP_CML_SWITCH:
            *flags = (BCM_PORT_LEARN_ARL |
                      BCM_PORT_LEARN_FWD |
                      (pcfg.pc_cpu ? BCM_PORT_LEARN_CPU : 0));
            break;
        case PVP_CML_CPU:
            *flags = BCM_PORT_LEARN_CPU;
            break;
        case PVP_CML_FORWARD:
            *flags = BCM_PORT_LEARN_FWD;
            break;
        case PVP_CML_DROP:
            *flags = 0;
            break;
        case PVP_CML_CPU_SWITCH:
            *flags = (BCM_PORT_LEARN_ARL |
                      BCM_PORT_LEARN_CPU |
                      BCM_PORT_LEARN_FWD);
            break;
        case PVP_CML_CPU_FORWARD:
            *flags = BCM_PORT_LEARN_CPU | BCM_PORT_LEARN_FWD;
            break;
        default:
            return BCM_E_INTERNAL;
        }
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_learn_set
 * Purpose:
 *      Set the ARL hardware learning options for this port.
 *      This defines what the hardware will do when a packet
 *      is seen with an unknown address.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      flags - Logical OR of BCM_PORT_LEARN_xxx flags
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

#define Arl     BCM_PORT_LEARN_ARL
#define Cpu     BCM_PORT_LEARN_CPU
#define Fwd     BCM_PORT_LEARN_FWD

int
bcm_esw_port_learn_set(int unit, bcm_port_t port, uint32 flags)
{
    bcm_port_cfg_t      pcfg;
    int                 rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_TRX_SUPPORT)  && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_SUBPORT_GROUP(port)) {
        if (SOC_IS_SCORPION(unit)) {
             return BCM_E_UNAVAIL;
        } else {
            return bcm_tr_subport_learn_set(unit, (bcm_gport_t) port, flags);
        }
    }
#endif /* BCM_TRX_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIUMPH_SUPPORT) && defined(BCM_MPLS_SUPPORT) && \
    defined(INCLUDE_L3)
    if (BCM_GPORT_IS_MPLS_PORT(port)) {
        return bcm_tr_mpls_port_learn_set(unit, (bcm_gport_t) port, flags);
    }
#endif
#if ((defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)) \
     && defined(INCLUDE_L3))
    if (BCM_GPORT_IS_MIM_PORT(port)) {
        return bcm_tr2_mim_port_learn_set(unit, (bcm_gport_t) port, flags);
    }
    if (BCM_GPORT_IS_VLAN_PORT(port)) {
        if (soc_feature(unit, soc_feature_vlan_vp)) {
            return bcm_tr2_vlan_port_learn_set(unit, (bcm_gport_t) port, flags);
        }
    }
    if (BCM_GPORT_IS_WLAN_PORT(port)) {
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return bcm_tr3_wlan_port_learn_set(unit, (bcm_gport_t) port, flags);
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
            return bcm_tr2_wlan_port_learn_set(unit, (bcm_gport_t) port, flags);
        }
    }
#endif /* BCM_TRIUMPH2_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIDENT_SUPPORT)&& defined(INCLUDE_L3)
    if (BCM_GPORT_IS_NIV_PORT(port)) {
        return bcm_trident_niv_port_learn_set(unit, (bcm_gport_t) port, flags);
    }
#endif /* BCM_TRIDENT_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
    if (SOC_IS_TD2_TT2(unit)) {
        if (BCM_GPORT_IS_VXLAN_PORT(port)){
            return bcm_td2_vxlan_port_learn_set(unit, (bcm_gport_t) port, flags);
        }
    }
#endif /* BCM_TRIDENT2_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIUMPH3_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_L2GRE_PORT(port)){
        return bcm_tr3_l2gre_port_learn_set(unit, (bcm_gport_t) port, flags);
    }
#endif /* BCM_TRIUMPH3_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIUMPH3_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_EXTENDER_PORT(port)){
        if (soc_feature(unit, soc_feature_port_extension)) {
            return bcm_tr3_extender_port_learn_set(unit, port, flags);
        }
    }
#endif /* BCM_TRIUMPH3_SUPPORT && INCLUDE_L3 */
#if defined(BCM_HGPROXY_COE_SUPPORT) && defined(INCLUDE_L3)
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        (soc_feature(unit, soc_feature_channelized_switching))) &&
        BCM_GPORT_IS_SUBPORT_PORT(port)) {
            return bcmi_xgs5_subport_port_learn_set(unit, (bcm_gport_t) port, flags);
    }
#endif /* BCM_HGPROXY_COE_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
        if (BCM_GPORT_IS_TRUNK(port)){
            if (soc_feature(unit, soc_feature_vp_lag)) {
                return bcm_td2_vp_lag_port_learn_set(unit,
                           BCM_GPORT_TRUNK_GET(port), flags);
            }
        }
#endif /* BCM_TRIDENT2_SUPPORT && INCLUDE_L3 */

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (flags & BCM_PORT_LEARN_PENDING) {
        if (!soc_feature(unit, soc_feature_l2_pending)) {
            return BCM_E_UNAVAIL;
        } else if (!IS_CPU_PORT(unit, port) & (!(flags & BCM_PORT_LEARN_ARL))) {
            /* When the PENDING flag is set, the ARL must also be set */
            return BCM_E_PARAM;
        }
    }

    PORT_LOCK(unit);

    rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg);

    pcfg.pc_cpu = ((flags & BCM_PORT_LEARN_CPU) != 0);

    /* Use shortened names to handle each flag combination individually */

#ifdef BCM_TRX_SUPPORT
    if (SOC_IS_TRX(unit)) {
        pcfg.pc_cml = 0;
        rv = _bcm_trx_port_cml_flags2hw(unit, flags, (uint32 *)&pcfg.pc_cml);
        if (BCM_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
    } else
#endif
    {
        switch (flags) {
        case ((!Arl) | (!Cpu) | (!Fwd)):
            pcfg.pc_cml = PVP_CML_DROP;
            break;
        case ((!Arl) | (!Cpu) | ( Fwd)):
            pcfg.pc_cml = PVP_CML_FORWARD;
            break;
        case ((!Arl) | ( Cpu) | (!Fwd)):
            pcfg.pc_cml = PVP_CML_CPU;
            break;
        case ((!Arl) | ( Cpu) | ( Fwd)):
            if (SOC_IS_XGS_SWITCH(unit)) {
                pcfg.pc_cml = PVP_CML_CPU_FORWARD;
            } else {
                rv = BCM_E_UNAVAIL;
            }
            break;
        case (( Arl) | (!Cpu) | (!Fwd)):
            rv = BCM_E_UNAVAIL;
            break;
        case (( Arl) | (!Cpu) | ( Fwd)):
            pcfg.pc_cml = PVP_CML_SWITCH;
            break;
        case (( Arl) | ( Cpu) | (!Fwd)):
            rv = BCM_E_UNAVAIL;
            break;
        case (( Arl) | ( Cpu) | ( Fwd)):
            if (SOC_IS_XGS_SWITCH(unit)) {
                pcfg.pc_cml = PVP_CML_CPU_SWITCH;
            } else {
                pcfg.pc_cml = PVP_CML_SWITCH;       /* pc_cpu also being set */
            }
            break;
        }
    }

    if (BCM_SUCCESS(rv)) {
        rv = mbcm_driver[unit]->mbcm_port_cfg_set(unit, port, &pcfg);
    }

    PORT_UNLOCK(unit);

    return rv;
}

#undef Arl
#undef Cpu
#undef Fwd

/*
 * Function:
 *      bcm_port_ifilter_get
 * Description:
 *      Return input filter mode for a port.
 * Parameters:
 *      unit - StrataSwitch PCI device unit number (driver internal).
 *      port - Port number to operate on
 *      mode - (OUT) Filter mode, 1 is enable; 0 is disable.
 * Returns:
 *      BCM_E_NONE              Success.
 *      BCM_E_INTERNAL          Chip access failure.
 * Notes:
 *      This API is superseded by bcm_port_vlan_member_get.
 */

int
bcm_esw_port_ifilter_get(int unit, bcm_port_t port, int *mode)
{
    int rv;
    uint32 flags;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    rv = bcm_esw_port_vlan_member_get(unit, port, &flags);

    if (BCM_SUCCESS(rv)) {
        *mode = (flags & BCM_PORT_VLAN_MEMBER_INGRESS) ? 1 : 0;
    }

    return rv;
}

/*
 * Function:
 *      bcm_port_ifilter_set
 * Description:
 *      Set input filter mode for a port.
 * Parameters:
 *      unit - StrataSwitch PCI device unit number (driver internal).
 *      port - Port number to operate on
 *      mode - 1 to enable, 0 to disable.
 * Returns:
 *      BCM_E_NONE              Success.
 *      BCM_E_INTERNAL          Chip access failure.
 * Notes:
 *      This API is superseded by bcm_port_vlan_member_set.
 *
 *      When input filtering is turned on for a port, packets received
 *      on the port that do not match the port's VLAN classifications
 *      are discarded.
 */

int
bcm_esw_port_ifilter_set(int unit, bcm_port_t port, int mode)
{
    uint32 flags;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(bcm_esw_port_vlan_member_get(unit, port, &flags));

    if (mode) {
        flags |= BCM_PORT_VLAN_MEMBER_INGRESS;
    }  else {
        flags &= (~BCM_PORT_VLAN_MEMBER_INGRESS);
    }

    return bcm_esw_port_vlan_member_set(unit, port, flags);
}

/*
 * Function:
 *      bcm_esw_port_vlan_member_get
 * Description:
 *      Return filter mode for a port.
 * Parameters:
 *      unit - StrataSwitch PCI device unit number (driver internal).
 *      port - Port number to operate on
 *      flags - (OUT) Filter mode, one of BCM_PORT_VLAN_MEMBER_xxx.
 * Returns:
 *      BCM_E_NONE              Success.
 *      BCM_E_INTERNAL          Chip access failure.
 */

int
bcm_esw_port_vlan_member_get(int unit, bcm_port_t port, uint32 *flags)
{
    int  rv = BCM_E_UNAVAIL;

    *flags = 0;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined(BCM_TRIDENT_SUPPORT) && defined(INCLUDE_L3)
    if (BCMI_GPORT_TYPE_VALID(port)) {
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (soc_feature(unit, soc_feature_vlan_vfi_membership)) {
            return bcm_td2p_vp_vlan_member_get(unit, port, -1, flags);
        } else
#endif
        {
            return bcm_td_vp_vlan_member_get(unit, port, flags);
        }
    } else
#endif /* BCM_TRIDENT_SUPPORT && INCLUDE_L3 */
    if (BCM_GPORT_IS_WLAN_PORT(port)) {
        rv = BCM_E_NONE;
    } else {
        rv = _bcm_esw_port_gport_validate(unit, port, &port);
    }
    BCM_IF_ERROR_RETURN(rv);
    rv = BCM_E_UNAVAIL;

    switch (BCM_CHIP_FAMILY(unit)) {

    case BCM_FAMILY_HERCULES:
        rv = BCM_E_NONE;
        break;

    case BCM_FAMILY_FIREBOLT:
    case BCM_FAMILY_BRADLEY:
    case BCM_FAMILY_HUMV:
    case BCM_FAMILY_TRIUMPH:
    case BCM_FAMILY_SCORPION:
    case BCM_FAMILY_CONQUEROR:
    case BCM_FAMILY_TRIUMPH2:
    case BCM_FAMILY_TRIDENT:
    case BCM_FAMILY_TITAN:
    case BCM_FAMILY_KATANA:
        if (SOC_IS_XGS12_SWITCH(unit) && IS_HG_PORT(unit, port)) {
            rv = BCM_E_NONE;
        } else {
            uint32 ent[SOC_MAX_MEM_FIELD_WORDS];
            soc_mem_t mem;
            soc_field_t field = EN_EFILTERf;

#if ((defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)) \
     && defined(INCLUDE_L3))
            if (BCM_GPORT_IS_WLAN_PORT(port)) {
                int value;
                if (!soc_feature(unit, soc_feature_wlan)) {
                    return BCM_E_PORT;
                }
#if defined(BCM_TRIUMPH3_SUPPORT)
                if (SOC_IS_TRIUMPH3(unit)) {
                    rv = bcm_tr3_wlan_lport_field_get(unit, port,
                                                      EN_IFILTERf, &value);
                } else
#endif /* BCM_TRIUMPH3_SUPPORT */
                {
                    rv = bcm_tr2_wlan_lport_field_get(unit, port,
                                                      EN_IFILTERf, &value);
                }
                if (value) {
                    *flags |= BCM_PORT_VLAN_MEMBER_INGRESS;
                }
                return rv;
            }
#endif

            mem = SOC_PORT_MEM_TAB(unit, port);
            if (SOC_MEM_IS_VALID(unit, ING_DEVICE_PORTm)) {
#ifdef BCM_TRIDENT3_SUPPORT
                int value;
                rv = _bcm_esw_port_tab_get(unit, port, EN_IFILTERf, &value);
                if (rv == BCM_E_NONE) {
                    if(value) {
                        *flags |= BCM_PORT_VLAN_MEMBER_INGRESS;
                        if (value == 2) {
                            *flags |= BCM_PORT_VLAN_MEMBER_VP_VLAN_MEMBERSHIP;
                        }
                    }
                }
#endif
            } else {
                uint32 value = 0;
                rv = soc_mem_read(unit, mem, MEM_BLOCK_ANY,
                                  SOC_PORT_MOD_OFFSET(unit, port), &ent);

                if (BCM_SUCCESS(rv)) {
                    value = soc_PORT_TABm_field32_get(unit, &ent, EN_IFILTERf);
                    if (value) {
                        *flags |= BCM_PORT_VLAN_MEMBER_INGRESS;
                        if (value == 2) {
                            *flags |= BCM_PORT_VLAN_MEMBER_VP_VLAN_MEMBERSHIP;
                        }
                    }
                }
            }

#ifdef BCM_TRIDENT_SUPPORT
            mem = EGR_PORTm;
            field = EN_EFILTERf;
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                int val = 0;
                rv = _bcm_esw_egr_port_tab_get(unit, port, field, &val);
                if (BCM_SUCCESS(rv) && val != 0) {
                    *flags |= BCM_PORT_VLAN_MEMBER_EGRESS;
                    if(val == 2) {
                        *flags |= BCM_PORT_VLAN_MEMBER_VP_VLAN_MEMBERSHIP;
                    }
                }
            } else
#endif
            if (SOC_MEM_IS_VALID(unit, mem)) {
                int val = 0;
                rv = soc_mem_read(unit, mem, MEM_BLOCK_ANY, port, &ent);
                val = soc_mem_field32_get(unit, mem, &ent, field);
                if (BCM_SUCCESS(rv) && val) {
                    *flags |= BCM_PORT_VLAN_MEMBER_EGRESS;
                    if(val == 2) {
                        *flags |= BCM_PORT_VLAN_MEMBER_VP_VLAN_MEMBERSHIP;
                    }
                }
            } else
#endif /* BCM_TRIDENT_SUPPORT */
            if (SOC_IS_XGS3_SWITCH(unit)) {
                uint32 egr_val;
                uint64 egr_val64;
                if (SOC_REG_IS_VALID(unit, EGR_PORTr)) {
                    rv = READ_EGR_PORTr(unit, port, &egr_val);
                } else {
                    rv = READ_EGR_PORT_64r(unit, port, &egr_val64);
                }
                if (BCM_SUCCESS(rv)) {
                    if (SOC_REG_IS_VALID(unit, EGR_PORTr)) {
                        if (soc_reg_field_valid(unit, EGR_PORTr, field)) {
                            if (soc_reg_field_get(unit, EGR_PORTr,
                                                  egr_val, field)) {
                                *flags |= BCM_PORT_VLAN_MEMBER_EGRESS;
                            }
                        }
                    } else if (soc_reg64_field32_get(unit,
                                   EGR_PORT_64r, egr_val64, field)) {
                            *flags |= BCM_PORT_VLAN_MEMBER_EGRESS;
                    }
                }
            }
        }
        break;

    default:
        break;
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_vlan_member_set
 * Description:
 *      Set ingress and egress filter mode for a port.
 * Parameters:
 *      unit - StrataSwitch PCI device unit number (driver internal).
 *      port - Port number to operate on
 *      flags - BCM_PORT_VLAN_MEMBER_xxx.
 * Returns:
 *      BCM_E_NONE              Success.
 *      BCM_E_INTERNAL          Chip access failure.
 */

int
bcm_esw_port_vlan_member_set(int unit, bcm_port_t port, uint32 flags)
{
    int       rv = BCM_E_UNAVAIL;
    int fieldLen = 0;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP Port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

    if (BCMI_GPORT_TYPE_VALID(port)) {
#if defined(BCM_TRIDENT_SUPPORT) && defined(INCLUDE_L3)
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (soc_feature(unit, soc_feature_vlan_vfi_membership)) {
            rv = bcm_td2p_vp_vlan_member_set(unit, port, flags);
        } else
#endif
        {
            rv = bcm_td_vp_vlan_member_set(unit, port, flags);
        }
#endif /* BCM_TRIDENT_SUPPORT && INCLUDE_L3 */
        return rv;
    } else if (BCM_GPORT_IS_WLAN_PORT(port)) {
        rv = BCM_E_NONE;
    } else {
        rv = _bcm_esw_port_gport_validate(unit, port, &port);
    }
    BCM_IF_ERROR_RETURN(rv);
    rv = BCM_E_UNAVAIL;

    PORT_LOCK(unit);

    switch (BCM_CHIP_FAMILY(unit)) {

    case BCM_FAMILY_HERCULES:
        rv = (flags & BCM_PORT_VLAN_MEMBER_INGRESS) ? BCM_E_UNAVAIL :
              ((flags & BCM_PORT_VLAN_MEMBER_EGRESS) ? BCM_E_UNAVAIL : BCM_E_NONE);
        break;

    case BCM_FAMILY_FIREBOLT:
    case BCM_FAMILY_BRADLEY:
    case BCM_FAMILY_HUMV:
    case BCM_FAMILY_TRIUMPH:
    case BCM_FAMILY_SCORPION:
    case BCM_FAMILY_CONQUEROR:
    case BCM_FAMILY_TRIUMPH2:
    case BCM_FAMILY_TRIDENT:
    case BCM_FAMILY_TITAN:
    case BCM_FAMILY_KATANA:
        if (SOC_IS_XGS12_SWITCH(unit) && IS_HG_PORT(unit, port)) {
            rv = (flags & BCM_PORT_VLAN_MEMBER_INGRESS) ? BCM_E_UNAVAIL :
                  ((flags & BCM_PORT_VLAN_MEMBER_EGRESS) ? BCM_E_UNAVAIL :
                  BCM_E_NONE);
        } else {
#if ((defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)) \
     && defined(INCLUDE_L3))

            if (BCM_GPORT_IS_WLAN_PORT(port)) {
                if (!soc_feature(unit, soc_feature_wlan)) {
                    PORT_UNLOCK(unit);
                    return BCM_E_PORT;
                }
                if (flags & BCM_PORT_VLAN_MEMBER_INGRESS) {
#if defined(BCM_TRIUMPH3_SUPPORT)
                    if (SOC_IS_TRIUMPH3(unit)) {
                        rv = _bcm_tr3_wlan_port_set(unit, port, EN_IFILTERf, 1);
                    } else
#endif /* BCM_TRIUMPH3_SUPPORT */
                    {
                        rv = _bcm_tr2_wlan_port_set(unit, port, EN_IFILTERf, 1);
                    }
                } else {
#if defined(BCM_TRIUMPH3_SUPPORT)
                    if (SOC_IS_TRIUMPH3(unit)) {
                        rv = _bcm_tr3_wlan_port_set(unit, port, EN_IFILTERf, 0);
                    } else
#endif /* BCM_TRIUMPH3_SUPPORT */
                    {
                        rv = _bcm_tr2_wlan_port_set(unit, port, EN_IFILTERf, 0);
                    }
                }
                PORT_UNLOCK(unit);
                return rv;
            }
#endif
            if (SOC_MEM_IS_VALID(unit, PORT_TABm) &&
                SOC_MEM_FIELD_VALID(unit, PORT_TABm, EN_IFILTERf)) {
                fieldLen = soc_mem_field_length(unit, PORT_TABm, EN_IFILTERf);
            } else if (SOC_MEM_IS_VALID(unit, LPORT_TABm) &&
                SOC_MEM_FIELD_VALID(unit, LPORT_TABm, EN_IFILTERf)) {
                fieldLen = soc_mem_field_length(unit, LPORT_TABm, EN_IFILTERf);
            }
            if (fieldLen > 0) {
                /* value = 2 requires EN_IFILTERf to have 2 bits. In some
                 * chips the field only has 1 bit */
                if ((flags & BCM_PORT_VLAN_MEMBER_VP_VLAN_MEMBERSHIP) &&
                        fieldLen == 1) {
                    PORT_UNLOCK(unit);
                    return BCM_E_PARAM;
                }
            }

            if (SOC_MEM_IS_VALID(unit, ING_DEVICE_PORTm)) {
                int value = (flags & BCM_PORT_VLAN_MEMBER_INGRESS) ? 1 : 0;
                if (soc_feature(unit, soc_feature_vlan_vfi_membership) &&
                    (flags & BCM_PORT_VLAN_MEMBER_VP_VLAN_MEMBERSHIP)) {
                    if (value == 1) {
                        value = 2;
                    }
                }
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           EN_IFILTERf, value);
            } else {
                int value = (flags & BCM_PORT_VLAN_MEMBER_INGRESS) ? 1 : 0;
                if (soc_feature(unit, soc_feature_vlan_vfi_membership) &&
                    (flags & BCM_PORT_VLAN_MEMBER_VP_VLAN_MEMBERSHIP)) {
                    if (value == 1) {
                        value = 2;
                    }
                }
                rv = _bcm_esw_port_tab_set(unit, port, 0, EN_IFILTERf, value);
            }

#ifdef BCM_TRIDENT_SUPPORT
            if (SOC_MEM_IS_VALID(unit, ING_EN_EFILTER_BITMAPm)) {
                uint32 efilter;
                ing_en_efilter_bitmap_entry_t entry;
                pbmp_t pbmp;

                if (SOC_MEM_IS_VALID(unit, EGR_PORTm) &&
                    SOC_MEM_FIELD_VALID(unit, EGR_PORTm, EN_EFILTERf)) {
                    fieldLen = soc_mem_field_length(unit, EGR_PORTm, EN_EFILTERf);
                } else if (SOC_MEM_IS_VALID(unit, EGR_LPORT_PROFILEm) &&
                    SOC_MEM_FIELD_VALID(unit, EGR_LPORT_PROFILEm, EN_EFILTERf)) {
                    fieldLen = soc_mem_field_length(unit, EGR_LPORT_PROFILEm, EN_EFILTERf);
                }
                if (fieldLen > 0) {
                    /* value = 2 requires EN_EFILTERf to have 2 bits. In some
                     * chips the field only has 1 bit */
                    if ((flags & BCM_PORT_VLAN_MEMBER_VP_VLAN_MEMBERSHIP) &&
                            fieldLen == 1) {
                        PORT_UNLOCK(unit);
                        return BCM_E_PARAM;
                    }
                }

                efilter = flags & BCM_PORT_VLAN_MEMBER_EGRESS ? 1 : 0;
                if((efilter == 1) && (flags & BCM_PORT_VLAN_MEMBER_VP_VLAN_MEMBERSHIP)) {
                    efilter = 2;
                }
                if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, EGR_LPORT_PROFILE_IDXf)) {
                    rv = _bcm_esw_egr_port_tab_set(unit, port, EN_EFILTERf,
                                                   efilter);
                } else {
                    rv = soc_mem_field32_modify(unit, EGR_PORTm, port, EN_EFILTERf,
                                                efilter);
                }
                if (BCM_SUCCESS(rv)) {
                    rv = soc_mem_read(unit, ING_EN_EFILTER_BITMAPm,
                                      MEM_BLOCK_ANY, 0, &entry);
                }
                if (BCM_SUCCESS(rv)) {
                    soc_mem_pbmp_field_get(unit, ING_EN_EFILTER_BITMAPm,
                                           &entry, BITMAPf, &pbmp);
                    if (efilter && PORT(unit, port).vp_count == 0) {
                        SOC_PBMP_PORT_ADD(pbmp, port);
                    } else {
                        SOC_PBMP_PORT_REMOVE(pbmp, port);
                    }
                    soc_mem_pbmp_field_set(unit, ING_EN_EFILTER_BITMAPm,
                                           &entry, BITMAPf, &pbmp);
                    rv = soc_mem_write(unit, ING_EN_EFILTER_BITMAPm,
                                       MEM_BLOCK_ANY, 0, &entry);
                }
            } else
#endif /* BCM_TRIDENT_SUPPORT */
            if (SOC_IS_XGS3_SWITCH(unit)) {
                soc_reg_t egr_port_reg;
                egr_port_reg = (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
                                SOC_IS_VALKYRIE2(unit) || SOC_IS_GREYHOUND(unit) ||
                                SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) ?
                                EGR_PORT_64r : EGR_PORTr;
                rv = soc_reg_field32_modify(unit, egr_port_reg, port, EN_EFILTERf,
                                          (flags & BCM_PORT_VLAN_MEMBER_EGRESS) ? 1 : 0);
                if (BCM_SUCCESS(rv)) {
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAVEN_SUPPORT) || \
        defined(BCM_SCORPION_SUPPORT)
                    if (SOC_IS_FIREBOLT2(unit) || SOC_IS_RAVEN(unit) ||
                        SOC_IS_SC_CQ(unit) || SOC_IS_HAWKEYE(unit)) {
                        uint32 egr_val;
                        pbmp_t pbmp;
                        uint32 bitmap, pbmp32;

                        rv = READ_ING_EN_EFILTER_BITMAPr(unit, &egr_val);
                        if (BCM_SUCCESS(rv)) {
                            SOC_PBMP_PORT_SET(pbmp, port);
                            pbmp32 = SOC_PBMP_WORD_GET(pbmp, 0);
                            bitmap =
                                soc_reg_field_get(unit,
                                                  ING_EN_EFILTER_BITMAPr,
                                                  egr_val, BITMAPf);
                            if (flags & BCM_PORT_VLAN_MEMBER_EGRESS) {
                                bitmap |= pbmp32;
                            } else {
                                bitmap &= ~pbmp32;
                            }
                            soc_reg_field_set(unit, ING_EN_EFILTER_BITMAPr,
                                              &egr_val, BITMAPf, bitmap);
                            rv = WRITE_ING_EN_EFILTER_BITMAPr(unit, egr_val);
                        }
                    }
#endif /* BCM_FIREBOLT_SUPPORT || BCM_RAVEN_SUPPORT || BCM_SCORPION_SUPPORT */
#if defined(BCM_TRIUMPH_SUPPORT)
                    /* Do this only if there is no VP on this port */
                    if (soc_feature (unit, soc_feature_high_portcount_register)) {
                        /*
                        *  pbmp reg split to multiple reg due to high port count
                        *  Note :
                        *   - ING_EN_EFILTER_BITMAP_64r here is split to
                        *      {ING_EN_EFILTER_BITMAP_LOr + ING_EN_EFILTER_BITMAP_HIr}
                        */
                        uint64      fval64, rval64;
                        uint32      t_port;
                        soc_reg_t   reg;
                        pbmp_t      curr_pbmp;

                        BCM_PBMP_CLEAR(curr_pbmp);
                        COMPILER_64_ZERO(fval64);
                        COMPILER_64_ZERO(rval64);

                        if (port < 64) {
                            reg = ING_EN_EFILTER_BITMAP_LOr;
                            t_port = port;
                        } else {
                            reg = ING_EN_EFILTER_BITMAP_HIr;
                            t_port = port - 64;
                        }
                        rv = soc_reg_get(unit, reg, REG_PORT_ANY, 0, &rval64);
                        if (BCM_SUCCESS(rv)) {
                            fval64 = soc_reg64_field_get(unit, reg,
                                                         rval64, BITMAPf);
                            SOC_PBMP_WORD_SET(curr_pbmp, 0,
                                              COMPILER_64_LO(fval64));
                            SOC_PBMP_WORD_SET(curr_pbmp, 1,
                                              COMPILER_64_HI(fval64));

                            if ((flags & BCM_PORT_VLAN_MEMBER_EGRESS)){
                                SOC_PBMP_PORT_ADD(curr_pbmp, t_port);
                            } else {
                                SOC_PBMP_PORT_REMOVE(curr_pbmp, t_port);
                            }

                            COMPILER_64_SET(fval64,
                                            SOC_PBMP_WORD_GET(curr_pbmp, 1),
                                            SOC_PBMP_WORD_GET(curr_pbmp, 0));
                            soc_reg64_field_set(unit, reg, &rval64,
                                                BITMAPf, fval64);
                            rv = soc_reg_set(unit, reg,
                                             REG_PORT_ANY, 0, rval64);
                        }
                    } else if (SOC_IS_TR_VL(unit)) {
                        uint64 egr_val_64;
                        pbmp_t pbmp;
                        uint32 bitmap, pbmp32;

                        rv = READ_ING_EN_EFILTER_BITMAP_64r(unit, &egr_val_64);
                        if (BCM_SUCCESS(rv)) {
                            SOC_PBMP_PORT_SET(pbmp, port);
                            /* Low bitmap */
                            bitmap =
                                soc_reg64_field32_get(unit,
                                                      ING_EN_EFILTER_BITMAP_64r,
                                                      egr_val_64, BITMAP_LOf);
                            pbmp32 = SOC_PBMP_WORD_GET(pbmp, 0);
                            if ((flags & BCM_PORT_VLAN_MEMBER_EGRESS)  &&
                                (PORT(unit, port).vp_count == 0)) {
                                bitmap |= pbmp32;
                            } else {
                                bitmap &= ~pbmp32;
                            }
                            soc_reg64_field32_set(unit, ING_EN_EFILTER_BITMAP_64r,
                                                  &egr_val_64, BITMAP_LOf, bitmap);

                            if(!SOC_IS_ENDURO(unit) && !SOC_IS_HURRICANEX(unit) &&
                                    !SOC_IS_GREYHOUND(unit)) {
                                /* High bitmap */
                                bitmap =
                                    soc_reg64_field32_get(unit,
                                                          ING_EN_EFILTER_BITMAP_64r,
                                                          egr_val_64, BITMAP_HIf);
                                pbmp32 = SOC_PBMP_WORD_GET(pbmp, 1);
                                if ((flags & BCM_PORT_VLAN_MEMBER_EGRESS)  &&
                                    (PORT(unit, port).vp_count == 0)) {
                                    bitmap |= pbmp32;
                                } else {
                                    bitmap &= ~pbmp32;
                                }
                                soc_reg64_field32_set(unit, ING_EN_EFILTER_BITMAP_64r,
                                                      &egr_val_64, BITMAP_HIf, bitmap);
                            }

                            rv = WRITE_ING_EN_EFILTER_BITMAP_64r(unit, egr_val_64);
                        }
                    }
#endif
                }
            }
        }
        break;

    default:
        break;
    }

    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      _bcm_port_link_get
 * Purpose:
 *      Return current PHY up/down status
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      hw - If TRUE, assume hardware linkscan is active and use it
 *              to reduce PHY reads.
 *           If FALSE, do not use information from hardware linkscan.
 *      up - (OUT) TRUE for link up, FALSE for link down.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
_bcm_port_link_get(int unit, bcm_port_t port, int hw, int *up)
{
    int     rv = 0;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_link_get(unit, port, hw, up);
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);

    if (hw) {
        pbmp_t hw_linkstat;

        rv = soc_linkscan_hw_link_get(unit, &hw_linkstat);

        *up = PBMP_MEMBER(hw_linkstat, port);

        /*
         * We need to confirm link down because we may receive false link
         * change interrupts when hardware and software linkscan are mixed.
         * Processing a false link down event is known to cause packet
         * loss, which is obviously unacceptable.
         */
        if(!(*up)) {
            rv = soc_phyctrl_link_get(unit, port, up);
        }
    } else {
        if (SOC_IS_RCPU_ONLY(unit)) {
            rv = MAC_ENABLE_GET(PORT(unit, port).p_mac, unit, port, up);
        } else {
            rv = soc_phyctrl_link_get(unit, port, up);
        }
    }

    if (BCM_SUCCESS(rv)) {
        if (PHY_FLAGS_TST(unit, port, PHY_FLAGS_MEDIUM_CHANGE)) {
            soc_port_medium_t  medium;
            soc_phyctrl_medium_get(unit, port, &medium);
            soc_phy_medium_status_notify(unit, port, medium);
        }
    }
    PORT_UNLOCK(unit);

    LOG_VERBOSE(BSL_LS_BCM_PORT,
                (BSL_META_U(unit,
                            "_bcm_port_link_get: u=%d p=%d hw=%d up=%d rv=%d\n"),
                 unit, port, hw, *up, rv));

    return rv;
}

/*
 * Function:
 *      bcm_port_link_status_get
 * Purpose:
 *      Return current Link up/down status, queries linkscan, if unable to
 *      retrieve status queries the PHY.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      up - (OUT) Boolean value, FALSE for link down and TRUE for link up
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_link_status_get(int unit, bcm_port_t port, int *up)
{
    int                 rv;
#if defined(BCM_KATANA2_SUPPORT)
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.\n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    rv = _bcm_esw_link_get(unit, port, up);

    if (rv == BCM_E_DISABLED) {
        int mode;
        mode = BCM_LINKSCAN_MODE_NONE;

        rv = bcm_esw_linkscan_mode_get(unit, port, &mode);

#if defined(BCM_KATANA2_SUPPORT)
        /*
         * Check added for invalid ports where the port number
         * lies between the maximum and minimum port values.
         */
        if (SOC_IS_KATANA2(unit) && rv == BCM_E_PORT) {
            return rv;
        }
#endif
        if (mode == BCM_LINKSCAN_MODE_HW) {
            rv = _bcm_port_link_get(unit, port, 1, up);
        } else {
            rv = _bcm_port_link_get(unit, port, 0, up);
        }
    }


    return rv;
}

/*
 * Function:
 *      bcm_esw_port_link_failed_clear
 * Purpose:
 *      Clear failed link status from a port which has undergone
 *      LAG failover.
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 * Notes:
 *      The port is moved to down status.  The application is responsible
 *      for removing the port from all trunk memberships before calling this
 *      function.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_link_failed_clear(int unit, bcm_port_t port)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    return _bcm_esw_link_failed_clear(unit, port);
}

/*
 * Function:
 *      _bcm_port_pfm_set
 * Purpose:
 *      Main part of function bcm_port_pfm_set
 */

STATIC int
_bcm_port_pfm_set(int unit, bcm_port_t port, int mode)
{
    int                 rv = BCM_E_NONE;

    /*
     * The filter mode for the first 16 ports is in one register
     * and for the rest in another
     */
    switch (BCM_CHIP_FAMILY(unit)) {

#ifdef BCM_XGS12_FABRIC_SUPPORT
    case BCM_FAMILY_HERCULES:
        /* See remarks under bcm_port_pfm_get below */
        break;
#endif

#ifdef BCM_XGS3_SWITCH_SUPPORT
    case BCM_FAMILY_FIREBOLT:
    case BCM_FAMILY_BRADLEY:
    case BCM_FAMILY_HUMV:
    case BCM_FAMILY_TRIUMPH:
    case BCM_FAMILY_SCORPION:
    case BCM_FAMILY_CONQUEROR:
    case BCM_FAMILY_TRIUMPH2:
    case BCM_FAMILY_TRIDENT:
    case BCM_FAMILY_TITAN:
    case BCM_FAMILY_KATANA:
        /*
         * PFM is a per VLAN attribute. It is not a per port attribute
         * on XGS3
         */
        return BCM_E_UNAVAIL;
#endif

    default:
        return BCM_E_UNAVAIL;
        break;
    }

    return rv;
}

/*
 * Function:
 *      bcm_port_pfm_set
 * Purpose:
 *      Set current port filtering mode (see port.h)
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      mode - mode for PFM bits (see port.h)
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_pfm_set(int unit, bcm_port_t port, int mode)
{
    int                 rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    if (!IS_PORT(unit, port)) {
        return BCM_E_PORT;
    }

    PORT_LOCK(unit);
    rv = _bcm_port_pfm_set(unit, port, mode);
    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_port_pfm_get
 * Purpose:
 *      Return current port filtering mode (see port.h)
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      mode - (OUT) mode read from StrataSwitch for PFM bits (see port.h)
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      This function not supported on 5670.
 */

int
bcm_esw_port_pfm_get(int unit, bcm_port_t port, int *mode)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    if (!IS_PORT(unit, port)) {
        return BCM_E_PORT;
    }

    switch (BCM_CHIP_FAMILY(unit)) {

#ifdef BCM_HERCULES_SUPPORT
    case BCM_FAMILY_HERCULES:
        /*
         * Packets marked as multicast prompt a lookup in the
         * MC table in 567x.  There is no notion of missing a multicast
         * address.
         *
         * Alternatively, we can mess with the MC/IPMC table
         * entries to support the different modes.  This is
         * probably not worth the trouble when we look at how
         * 567x is meant to fit into the system.
         */
        *mode = BCM_PORT_PFM_MODEC;
        break;
#endif

#ifdef BCM_XGS3_SWITCH_SUPPORT
    case BCM_FAMILY_FIREBOLT:
    case BCM_FAMILY_BRADLEY:
    case BCM_FAMILY_HUMV:
    case BCM_FAMILY_TRIUMPH:
    case BCM_FAMILY_SCORPION:
    case BCM_FAMILY_CONQUEROR:
    case BCM_FAMILY_TRIUMPH2:
    case BCM_FAMILY_TRIDENT:
    case BCM_FAMILY_TITAN:
    case BCM_FAMILY_KATANA:
        /*
         * PFM is a per VLAN attribute. It is not a per port attribute
         * on XGS3
         */
        *mode = BCM_PORT_PFM_MODEC;
        return BCM_E_UNAVAIL;
#endif

    default:
        return BCM_E_UNAVAIL;
        break;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_untagged_priority_set
 * Purpose:
 *      Main part of bcm_port_untagged_priority_set.
 */

STATIC int
_bcm_port_untagged_priority_set(int unit, bcm_port_t port, int priority)
{
    if (priority > 7) {
        return BCM_E_PARAM;
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_XGS_SWITCH_SUPPORT)
    if (soc_feature(unit, soc_feature_remap_ut_prio) && (priority >= 0)) {
        bcm_port_cfg_t pcfg;
        SOC_IF_ERROR_RETURN(
            mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg));
        pcfg.pc_remap_pri_en = 1;
            pcfg.pc_new_opri = priority;
        SOC_IF_ERROR_RETURN(
            mbcm_driver[unit]->mbcm_port_cfg_set(unit, port, &pcfg));
        PORT(unit, port).p_ut_prio = pcfg.pc_new_opri;
        return SOC_E_NONE;
    }
#endif /* BCM_XGS_SWITCH_SUPPORT */

    if (priority < 0) {
        return BCM_E_PARAM;
    }

    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_port_untagged_priority_set
 * Purpose:
 *      Set the 802.1P priority for untagged packets coming in on a
 *      port.  This value will be written into the priority field of the
 *      tag that is added at the ingress.
 * Parameters:
 *      unit      - StrataSwitch Unit #.
 *      port      - StrataSwitch port #.
 *      priority  - Priority to be set in 802.1p priority tag, from 0 to 7.
 *                  A negative priority leaves the ingress port priority as
 *                  is, but disables it from overriding ARL-based priorities.
 *                  (on those devices that support ARL-based priority).
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_untagged_priority_set(int unit, bcm_port_t port, int priority)
{
    int         rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

#if ((defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)) \
     && defined(INCLUDE_L3))
    if (BCM_GPORT_IS_WLAN_PORT(port)) {
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return bcm_tr3_wlan_port_untagged_prio_set(unit, port, priority);
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
            return bcm_tr2_wlan_port_untagged_prio_set(unit, port, priority);
        }
    }
#endif
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);
    rv = _bcm_port_untagged_priority_set(unit, port, priority);
    PORT_UNLOCK(unit);

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_ut_priority_set: u=%d p=%d pri=%d rv=%d\n"),
              unit, port, priority, rv));

    return rv;
}

/*
 * Function:
 *      bcm_port_untagged_priority_get
 * Purpose:
 *      Returns priority being assigned to untagged receive packets
 * Parameters:
 *      unit      - StrataSwitch Unit #.
 *      port      - StrataSwitch port #.
 *      priority  - Pointer to an int in which priority value is returned.
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */

int
bcm_esw_port_untagged_priority_get(int unit, bcm_port_t port, int *priority)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

#if ((defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)) \
     && defined(INCLUDE_L3))
    if (BCM_GPORT_IS_WLAN_PORT(port)) {
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return bcm_tr3_wlan_port_untagged_prio_get(unit, port, priority);
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
            return bcm_tr2_wlan_port_untagged_prio_get(unit, port, priority);
        }
    }
#endif
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (priority != NULL) {
        *priority = PORT(unit, port).p_ut_prio;
        LOG_INFO(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit,
                             "bcm_port_ut_priority_get: u=%d p=%d pri=%d\n"),
                  unit, port, *priority));
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_selective_get
 * Purpose:
 *      Get requested port parameters
 * Parameters:
 *      unit - switch Unit
 *      port - switch port
 *      info - (IN/OUT) port information structure
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      The action_mask field of the info argument is used as an input
 */

int
bcm_esw_port_selective_get(int unit, bcm_port_t port, bcm_port_info_t *info)
{
    int                 r;
    uint32              mask;
    bcm_port_if_t       intf;
    int                 speed;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    if (!BCM_GPORT_IS_SET(port)) {
        if (!SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit),port)) {
            return BCM_E_PORT;
        }
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    mask = info->action_mask;

    /* PM8x50 does not support these things, so do not try to fetch them */
    if (IS_CD_PORT(unit, port)) {
        mask &= ~BCM_PORT_ATTR_ABILITY_MASK;
        mask &= ~BCM_PORT_ATTR_LOCAL_ADVERT_MASK;
        mask &= ~BCM_PORT_ATTR_INTERFACE_MASK;
    }

    if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port) ||
        IS_CE_PORT(unit, port)) {
        if (!(IS_CD_PORT(unit, port))) {
            BCM_IF_ERROR_RETURN(bcm_esw_port_speed_get(unit, port, &speed));
            BCM_IF_ERROR_RETURN(bcm_esw_port_interface_get(unit, port, &intf));

            /* check if the port has no fault status to retrieve */
            if (speed < 5000) {
                mask &= ~BCM_PORT_ATTR_FAULT_MASK;
            } else if (speed == 5000) {
                if (intf != BCM_PORT_IF_KR) {
                    mask &= ~BCM_PORT_ATTR_FAULT_MASK;
                }
            } else if (speed < 10000) {
                mask &= ~BCM_PORT_ATTR_FAULT_MASK;
            }
        }
    }

    if (IS_QSGMII_PORT(unit, port)) {
        mask &= ~BCM_PORT_ATTR_FAULT_MASK;
    }

    if (mask & BCM_PORT_ATTR_ENCAP_MASK) {
        r = bcm_esw_port_encap_get(unit, port, &info->encap_mode);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_encap_getfailed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_ENABLE_MASK) {
        r = bcm_esw_port_enable_get(unit, port, &info->enable);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_enable_getfailed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_LINKSTAT_MASK) {
        r = bcm_esw_port_link_status_get(unit, port, &info->linkstatus);
        if (BCM_FAILURE(r)) {
            /* LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_link_status_getfailed:%s\n"), bcm_errmsg(r))); */
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_AUTONEG_MASK) {
        r = bcm_esw_port_autoneg_get(unit, port, &info->autoneg);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_autoneg_getfailed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_LOCAL_ADVERT_MASK) {
        r = bcm_esw_port_ability_advert_get(unit, port,
                                            &info->local_ability);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_ability_advert_getfailed:%s\n"),
                         bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
        r = soc_port_ability_to_mode(&info->local_ability,
                                     &info->local_advert);
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_REMOTE_ADVERT_MASK) {

        if ((r = bcm_esw_port_ability_remote_get(unit, port,
                                                 &info->remote_ability)) < 0) {
            info->remote_advert = 0;
            info->remote_advert_valid = FALSE;
        } else {
            r = soc_port_ability_to_mode(&info->remote_ability,
                                         &info->remote_advert);
            BCM_IF_ERROR_RETURN(r);
            info->remote_advert_valid = TRUE;
        }
    }

    if (mask & BCM_PORT_ATTR_SPEED_MASK) {
        if ((r = bcm_esw_port_speed_get(unit, port, &info->speed)) < 0) {
            if (r != BCM_E_BUSY) {
                LOG_VERBOSE(BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                        "bcm_port_speed_get failed: %s\n"), bcm_errmsg(r)));
                return(r);
            } else {
                info->speed = 0;
            }
        }
    }

    if (mask & BCM_PORT_ATTR_DUPLEX_MASK) {
        if ((r = bcm_esw_port_duplex_get(unit, port, &info->duplex)) < 0) {
            if (r != BCM_E_BUSY) {
                LOG_VERBOSE(BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                        "bcm_port_duplex_get failed: %s\n"), bcm_errmsg(r)));
                return r;
            } else {
                info->duplex = 0;
            }
        }
    }

    /* get both if either mask bit set */
    if (mask & (BCM_PORT_ATTR_PAUSE_TX_MASK |
                BCM_PORT_ATTR_PAUSE_RX_MASK)) {
        r = bcm_esw_port_pause_get(unit, port,
                                   &info->pause_tx, &info->pause_rx);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_pause_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_PAUSE_MAC_MASK) {
        r = bcm_esw_port_pause_addr_get(unit, port, info->pause_mac);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_pause_addr_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_LINKSCAN_MASK) {
        r = bcm_esw_port_linkscan_get(unit, port, &info->linkscan);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_linkscan_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_LEARN_MASK) {
        r = bcm_esw_port_learn_get(unit, port, &info->learn);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_learn_getfailed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_DISCARD_MASK) {
        r = bcm_esw_port_discard_get(unit, port, &info->discard);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_discard_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_VLANFILTER_MASK) {
        r = bcm_esw_port_vlan_member_get(unit, port, &info->vlanfilter);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_esw_port_vlan_member_get failed:%s\n"),
                         bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_UNTAG_PRI_MASK) {
        r = bcm_esw_port_untagged_priority_get(unit, port,
                                               &info->untagged_priority);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_untagged_priority_get failed:%s\n"),
                         bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_UNTAG_VLAN_MASK) {
        r = bcm_esw_port_untagged_vlan_get(unit, port,
                                           &info->untagged_vlan);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_untagged_vlan_get failed:%s\n"),
                         bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_STP_STATE_MASK) {
        r = bcm_esw_port_stp_get(unit, port, &info->stp_state);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_stp_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_PFM_MASK) {
        r = bcm_esw_port_pfm_get(unit, port, &info->pfm);
        if (r != BCM_E_UNAVAIL) {
            if (BCM_FAILURE(r)) {
                LOG_VERBOSE(BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                        "bcm_port_pfm_get failed:%s\n"), bcm_errmsg(r)));
            }
        }
        BCM_IF_ERROR_NOT_UNAVAIL_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_LOOPBACK_MASK) {
        r = bcm_esw_port_loopback_get(unit, port, &info->loopback);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_loopback_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_PHY_MASTER_MASK) {
        r = bcm_esw_port_master_get(unit, port, &info->phy_master);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_master_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_INTERFACE_MASK) {
        r = bcm_esw_port_interface_get(unit, port, &info->interface);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_interface_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_RATE_MCAST_MASK) {
        r = bcm_esw_rate_mcast_get(unit, &info->mcast_limit,
                                   &info->mcast_limit_enable, port);
        if (r == BCM_E_UNAVAIL) {
            r = BCM_E_NONE;     /* Ignore if not supported on chip */
        }
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_rate_mcast_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_RATE_BCAST_MASK) {
        r = bcm_esw_rate_bcast_get(unit, &info->bcast_limit,
                                   &info->bcast_limit_enable, port);
        if (r == BCM_E_UNAVAIL) {
            r = BCM_E_NONE;     /* Ignore if not supported on chip */
        }
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_rate_bcast_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_RATE_DLFBC_MASK) {
        r = bcm_esw_rate_dlfbc_get(unit, &info->dlfbc_limit,
                                   &info->dlfbc_limit_enable, port);
        if (r == BCM_E_UNAVAIL) {
            r = BCM_E_NONE;     /* Ignore if not supported on chip */
        }
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_rate_dlfbc_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_SPEED_MAX_MASK) {
        r = bcm_esw_port_speed_max(unit, port, &info->speed_max);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_speed_max failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_ABILITY_MASK) {
        r = bcm_esw_port_ability_local_get(unit, port, &info->port_ability);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_ability_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
        r = soc_port_ability_to_mode(&info->port_ability,
                                     &info->ability);
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_FRAME_MAX_MASK) {
        r = bcm_esw_port_frame_max_get(unit, port, &info->frame_max);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_frame_max_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_MDIX_MASK) {
        r = bcm_esw_port_mdix_get(unit, port, &info->mdix);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_mdix_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_MDIX_STATUS_MASK) {
        r = bcm_esw_port_mdix_status_get(unit, port, &info->mdix_status);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_mdix_status_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_MEDIUM_MASK) {
        r = bcm_esw_port_medium_get(unit, port, &info->medium);
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_medium_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_FAULT_MASK) {
        r = bcm_esw_port_fault_get(unit, port, &info->fault);
        if (r == BCM_E_PORT) {
            r = BCM_E_NONE;     /* Ignore if not supported on chip/port */
        }
        if (BCM_FAILURE(r)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_fault_get failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_selective_set
 * Purpose:
 *      Set requested port parameters
 * Parameters:
 *      unit - switch unit
 *      port - switch port
 *      info - port information structure
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 *      Does not set spanning tree state.
 */

int
bcm_esw_port_selective_set(int unit, bcm_port_t port, bcm_port_info_t *info)
{
    int                 r;
    uint32              mask;
    int                 flags = 0;
    soc_info_t          *si;

    if (!(si = &SOC_INFO(unit))) {
        return SOC_E_INTERNAL;
    }

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_selective_set: u=%d p=%d\n"), unit, port));

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    if (!BCM_GPORT_IS_SET(port)) {
        if (!SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit),port)) {
            return BCM_E_PORT;
        }
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    mask = info->action_mask;

    /* PM8x50 does not support these things, so do not try to fetch them */
    if (IS_CD_PORT(unit, port)) {
        mask &= ~BCM_PORT_ATTR_ABILITY_MASK;
        mask &= ~BCM_PORT_ATTR_LOCAL_ADVERT_MASK;
        mask &= ~BCM_PORT_ATTR_INTERFACE_MASK;
    }

    if (mask & BCM_PORT_ATTR_ENCAP_MASK) {
        if (info->encap_mode == BCM_PORT_ENCAP_HIGIG_OVER_ETHERNET) {
            /* HGOE mode valid only for TD3 fabric */
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit) &&
                 soc_feature(unit, soc_feature_higig_over_ethernet)) {
                bcm_port_encap_config_t config;
                config.encap = info->encap_mode;
                BCM_IF_ERROR_RETURN(
                    bcm_esw_port_encap_config_set(unit, port, &config));
            } else
#endif
            {
                return BCM_E_PARAM;
            }
        } else {

            BCM_IF_ERROR_RETURN
                (bcmi_esw_port_encap_validate(unit, port, info->encap_mode,
                            ((mask & BCM_PORT_ATTR_SPEED_MASK) ? info->speed : 0)));
            r = _bcm_esw_port_encap_set(unit, port, info->encap_mode);
            if (BCM_FAILURE(r)) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                        "bcm_port_encap_set failed:%s\n"), bcm_errmsg(r)));
            }
            BCM_IF_ERROR_RETURN(r);
        }
    }

    if (mask & BCM_PORT_ATTR_ENABLE_MASK) {
        r = bcm_esw_port_enable_set(unit, port, info->enable);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_enable_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_PAUSE_MAC_MASK) {
        r = bcm_esw_port_pause_addr_set(unit, port, info->pause_mac);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_pause_addr_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_INTERFACE_MASK) {
        r = bcm_esw_port_interface_set(unit, port, info->interface);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_interface_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_PHY_MASTER_MASK) {
        r = bcm_esw_port_master_set(unit, port, info->phy_master);
        if (r != BCM_E_UNAVAIL) {
            if (BCM_FAILURE(r)) {
                LOG_VERBOSE(BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                        "bcm_port_master_set failed:%s\n"), bcm_errmsg(r)));
            }
        }
        BCM_IF_ERROR_NOT_UNAVAIL_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_LINKSCAN_MASK) {
        r = bcm_esw_port_linkscan_set(unit, port, info->linkscan);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_linkscan_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_LEARN_MASK) {
        r = bcm_esw_port_learn_set(unit, port, info->learn);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_learn_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_DISCARD_MASK) {
        r = bcm_esw_port_discard_set(unit, port, info->discard);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_discard_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_VLANFILTER_MASK) {
        r = bcm_esw_port_vlan_member_set(unit, port, info->vlanfilter);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_esw_port_vlan_member_set failed:%s\n"),
                         bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_UNTAG_PRI_MASK) {
        r = bcm_esw_port_untagged_priority_set(unit, port,
                                               info->untagged_priority);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_untagged_priority_set failed:%s\n"),
                         bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_UNTAG_VLAN_MASK) {
        r = bcm_esw_port_untagged_vlan_set(unit, port, info->untagged_vlan);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_untagged_vlan_set (%d) failed: %s\n"),
                         info->untagged_vlan, bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_PFM_MASK) {
        r = bcm_esw_port_pfm_set(unit, port, info->pfm);
        if (r != BCM_E_UNAVAIL) {
            if (BCM_FAILURE(r)) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                        "bcm_port_pfm_set failed:%s\n"), bcm_errmsg(r)));
            }
        }
        BCM_IF_ERROR_NOT_UNAVAIL_RETURN(r);
    }

    /*
     * Set loopback mode before setting the speed/duplex, since it may
     * affect the allowable values for speed/duplex.
     */

    if (mask & BCM_PORT_ATTR_LOOPBACK_MASK) {
        r = bcm_esw_port_loopback_set(unit, port, info->loopback);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_loopback_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_LOCAL_ADVERT_MASK) {
        if (info->action_mask2 & BCM_PORT_ATTR2_PORT_ABILITY) {
            r = bcm_esw_port_ability_advert_set(unit, port,
                                                &(info->local_ability));
            if (BCM_FAILURE(r)) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                        "bcm_port_ability_advert_set failed: %s\n"),
                             bcm_errmsg(r)));
            }
            BCM_IF_ERROR_RETURN(r);
        } else {
            r = bcm_esw_port_advert_set(unit, port, info->local_advert);
            if (BCM_FAILURE(r)) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                        "bcm_port_advert_set failed: (0x%x): %s\n"),
                             info->local_advert, bcm_errmsg(r)));
            }
            BCM_IF_ERROR_RETURN(r);
        }
    }

    if (mask & BCM_PORT_ATTR_AUTONEG_MASK) {
#if defined(BCM_TOMAHAWK_SUPPORT)
        if ((SOC_IS_TOMAHAWKX(unit) || SOC_IS_TRIDENT3(unit)) && IS_CL_PORT(unit, port)) {
            int speed = si->port_init_speed[port];
            if (1000 == speed) {    /* 1G ports do not support autoneg, force off */
                info->autoneg = 0;
            }
        }
#endif
        r = bcm_esw_port_autoneg_set(unit, port, info->autoneg);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_autoneg_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_SPEED_MASK) {
        /*When AN=on, speed will be auto-detected. Hence don't set*/
        if ((mask & BCM_PORT_ATTR_AUTONEG_MASK) && info->autoneg) {
            r = BCM_E_PARAM;
            if (BCM_FAILURE(r)) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                          "Autoneg:On. SPEED will be "
                           "auto-detected :%s\n"), bcm_errmsg(r)));
            }
            BCM_IF_ERROR_RETURN(r);
        }
#ifdef BCM_TOMAHAWK3_SUPPORT
        if (SOC_IS_TOMAHAWK3(unit) && IS_CD_PORT(unit, port)) {
            bcm_port_resource_t pr;
            r = bcm_esw_port_resource_get(unit, port, &pr);
            BCM_IF_ERROR_RETURN(r);
            if (pr.speed != info->speed) {
                LOG_INFO(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                          "Warning: bcm_port_info speed (%d) does NOT match "
                          " current speed (%d). May have fec/link training/"
                          "phy lane config mismatches!\n"),
                          pr.speed, info->speed));
            }
            pr.speed = info->speed;
            r = bcm_esw_port_resource_speed_set(unit, port, &pr);
            BCM_IF_ERROR_RETURN(r);
        } else
#endif
        {
        r = bcm_esw_port_speed_set(unit, port, info->speed);
        }
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_speed_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_DUPLEX_MASK) {
        /*When AN=on, then duplex method will be auto-detected, hence don't set*/
        if ((mask & BCM_PORT_ATTR_AUTONEG_MASK) && info->autoneg) {
            r = BCM_E_PARAM;
            if (BCM_FAILURE(r)) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                          "Autoneg:On. DUPLEX should be "
                           "auto-detected :%s\n"), bcm_errmsg(r)));
            }
            BCM_IF_ERROR_RETURN(r);
        }
        r = bcm_esw_port_duplex_set(unit, port, info->duplex);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_duplex_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & (BCM_PORT_ATTR_PAUSE_TX_MASK |
                BCM_PORT_ATTR_PAUSE_RX_MASK)) {
        int     tpause, rpause;

        tpause = rpause = -1;
        if (mask & BCM_PORT_ATTR_PAUSE_TX_MASK) {
            tpause = info->pause_tx;
        }
        if (mask & BCM_PORT_ATTR_PAUSE_RX_MASK) {
            rpause = info->pause_rx;
        }
        r = bcm_esw_port_pause_set(unit, port, tpause, rpause);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_pause_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_RATE_MCAST_MASK) {
        flags = (info->mcast_limit_enable) ? BCM_RATE_MCAST : 0;
        r = bcm_esw_rate_mcast_set(unit, info->mcast_limit, flags, port);
        if (r == BCM_E_UNAVAIL) {
            r = BCM_E_NONE;     /* Ignore if not supported on chip */
        }
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_rate_mcast_port_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_RATE_BCAST_MASK) {
        flags = (info->bcast_limit_enable) ? BCM_RATE_BCAST : 0;
        r = bcm_esw_rate_bcast_set(unit, info->bcast_limit, flags, port);
        if (r == BCM_E_UNAVAIL) {
            r = BCM_E_NONE;     /* Ignore if not supported on chip */
        }
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_rate_bcast_port_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_RATE_DLFBC_MASK) {
        flags = (info->dlfbc_limit_enable) ? BCM_RATE_DLF : 0;
        r = bcm_esw_rate_dlfbc_set(unit, info->dlfbc_limit, flags, port);
        if (r == BCM_E_UNAVAIL) {
            r = BCM_E_NONE;     /* Ignore if not supported on chip */
        }
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_rate_dlfbcast_port_set failed:%s\n"),
                         bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_STP_STATE_MASK) {
        r = bcm_esw_port_stp_set(unit, port, info->stp_state);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_stp_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_FRAME_MAX_MASK) {
        r = bcm_esw_port_frame_max_set(unit, port, info->frame_max);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_frame_max_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    if (mask & BCM_PORT_ATTR_MDIX_MASK) {
        r = bcm_esw_port_mdix_set(unit, port, info->mdix);
        if (BCM_FAILURE(r)) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "bcm_port_mdix_set failed:%s\n"), bcm_errmsg(r)));
        }
        BCM_IF_ERROR_RETURN(r);
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_info_get
 * Purpose:
 *      Get all information on the port
 * Parameters:
 *      unit - StrataSwitch unit #
 *      port - StrataSwitch port #
 *      info - Pointer to structure in which to save values
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_info_get(int unit, bcm_port_t port, bcm_port_info_t *info)
{
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    bcm_port_info_t_init(info);

    if (IS_ST_PORT(unit, port)) {
        info->action_mask = BCM_PORT_HERC_ATTRS;
        if (SOC_IS_XGS_SWITCH(unit)) {
            info->action_mask |= BCM_PORT_ATTR_STP_STATE_MASK |
                                 BCM_PORT_ATTR_DISCARD_MASK |
                                 BCM_PORT_ATTR_LEARN_MASK;
        }
    } else {
        info->action_mask = BCM_PORT_ATTR_ALL_MASK;
    }

    return bcm_esw_port_selective_get(unit, port, info);
}

/*
 * Function:
 *      bcm_port_info_set
 * Purpose:
 *      Set all information on the port
 * Parameters:
 *      unit - StrataSwitch unit #
 *      port - StrataSwitch port #
 *      info - Pointer to structure in which to save values
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      Checks if AN is on, and if so, clears the
 *      proper bits in the action mask.
 */

int
bcm_esw_port_info_set(int unit, bcm_port_t port, bcm_port_info_t *info)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (IS_ST_PORT(unit, port)) {
        info->action_mask = BCM_PORT_HERC_ATTRS;
        if (SOC_IS_XGS_SWITCH(unit)) {
            info->action_mask |= BCM_PORT_ATTR_STP_STATE_MASK |
                                 BCM_PORT_ATTR_DISCARD_MASK |
                                 BCM_PORT_ATTR_LEARN_MASK;
        }
    } else {
        info->action_mask = BCM_PORT_ATTR_ALL_MASK;
    }

    /* If autoneg is set, remove those attributes controlled by it */
    if (info->autoneg) {
        info->action_mask &= ~BCM_PORT_AN_ATTRS;
    }

    return bcm_esw_port_selective_set(unit, port, info);
}

/*
 * Function:
 *      bcm_port_info_save
 * Purpose:
 *      Save the current settings of a port
 * Parameters:
 *      unit - StrataSwitch unit #
 *      port - StrataSwitch port #
 *      info - Pointer to structure in which to save values
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      The action_mask will be adjusted so that the
 *      proper values will be set when a restore is made.
 *      This mask should not be altered between these calls.
 */

int
bcm_esw_port_info_save(int unit, bcm_port_t port, bcm_port_info_t *info)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (IS_ST_PORT(unit, port)) {
        info->action_mask = BCM_PORT_HERC_ATTRS;
        if (SOC_IS_XGS_SWITCH(unit)) {
            info->action_mask |= BCM_PORT_ATTR_STP_STATE_MASK;
        }
#ifdef BCM_GXPORT_SUPPORT
        if (IS_GX_PORT(unit, port)) {
            info->action_mask |= BCM_PORT_ATTR_AUTONEG_MASK;
        }
#endif
    } else {
        info->action_mask = BCM_PORT_ATTR_ALL_MASK;
    }
    info->action_mask2 = BCM_PORT_ATTR2_PORT_ABILITY;

    BCM_IF_ERROR_RETURN(bcm_esw_port_selective_get(unit, port, info));

    if (info->autoneg) {
        info->action_mask &= ~BCM_PORT_AN_ATTRS;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_info_restore
 * Purpose:
 *      Restore port settings saved by info_save
 * Parameters:
 *      unit - StrataSwitch unit #
 *      port - StrataSwitch port #
 *      info - Pointer to structure with info from port_info_save
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      bcm_port_info_save has done all the work.
 *      We just call port_selective_set.
 */

int
bcm_esw_port_info_restore(int unit, bcm_port_t port, bcm_port_info_t *info)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    return bcm_esw_port_selective_set(unit, port, info);
}

/*
 * Function:
 *      bcm_port_phy_drv_name_get
 * Purpose:
 *      Return the name of the PHY driver being used on a port.
 * Parameters:
 *      unit - StrataSwitch unit #
 *      port - StrataSwitch port #
 * Returns:
 *      Pointer to static string
 */
int
bcm_esw_port_phy_drv_name_get(int unit, bcm_port_t port, char *name, int len)
{
    int str_len;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_phy_drv_name_get(unit, port, name, len);
    }

    if (bcm_port_info[unit] == NULL) {
        str_len = sal_strlen("driver not initialized");
        if (str_len <= len) {
            sal_strlcpy(name, "driver not initialized", len);
        }
        return BCM_E_INIT;
    }
    if (!SOC_PORT_VALID(unit, port)) {
        str_len = sal_strlen("invalid port");
        if (str_len <= len) {
            sal_strlcpy(name, "invalid port", len);
        }
        return BCM_E_PORT;
    }
    return (soc_phyctrl_drv_name_get(unit, port, name, len));
}

/*
 * Function:
 *      _bcm_port_encap_xport_set
 * Purpose:
 *      Convert 10G Ether port to Higig port, or reverse
 * Notes;
 *      Must be called with PORT_LOCK held.
 */

int
_bcm_port_encap_xport_set(int unit, bcm_port_t port, int mode,
                          int update_port_mode)
{
#ifdef BCM_FIREBOLT_SUPPORT
    bcm_stg_t        stg;
    int              to_higig;
    soc_field_t      port_type_field;
    soc_reg_t        egr_port_reg;
    soc_port_ability_t ability;
    soc_port_mode_t  non_ieee_speed;
    int              an, an_done, force_speed, port_type;
    uint32           entry[SOC_MAX_MEM_WORDS];
#ifdef BCM_TRIDENT2_SUPPORT
    int              config_speed = 0;
#endif
#if defined(BCM_KATANA2_SUPPORT)
    int speed = 0;
    bcmMxqPhyPortMode_t phy_mode;
#endif
int              enable = 0;
#if defined(BCM_XGS3_SWITCH_SUPPORT)
    uint32 rval = 0;
    uint32 mtu = 0;
    soc_info_t       *si = &SOC_INFO(unit);
#endif /* BCM_XGS3_SWITCH_SUPPORT */

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_encap_xport_set(unit, port, mode);
    }

    to_higig = (mode != BCM_PORT_ENCAP_IEEE);
    port_type_field = (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
                       SOC_IS_VALKYRIE2(unit) || SOC_IS_ENDURO(unit) ||
                       SOC_IS_HURRICANEX(unit) || SOC_IS_TD_TT(unit) ||
                       SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANAX(unit)||
                       SOC_IS_GREYHOUND(unit) || SOC_IS_GREYHOUND2(unit)) ?
                       PORT_TYPEf : HIGIG_PACKETf;
    egr_port_reg = (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
                    SOC_IS_VALKYRIE2(unit) || SOC_IS_GREYHOUND(unit) ||
                    SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) ?
                    EGR_PORT_64r : EGR_PORTr;

#if defined(BCM_KATANA2_SUPPORT)
    if (to_higig && SOC_IS_KATANA2(unit) && !SOC_IS_SABER2(unit) &&
            update_port_mode) {
        /*
         * Updating the phy_mode according to the port encap type.
         * Using 13G as default speed for higig since the underlying routine
         * do not differentiate on higig speeds.
         */
        SOC_IF_ERROR_RETURN
            (soc_katana2_get_phy_port_mode(unit, port, 13000, &phy_mode));
    }
#endif
    SOC_IF_ERROR_RETURN
        (MAC_ENCAP_SET(PORT(unit, port).p_mac, unit, port, mode));

    if ((SOC_IS_SABER2(unit) || SOC_IS_HURRICANE2(unit)) && IS_XL_PORT(unit, port)) {
        if (mode == BCM_PORT_ENCAP_HIGIG2_LITE) {
            SOC_PBMP_PORT_ADD(SOC_INFO(unit).hl.bitmap, port);
        } else {
            SOC_PBMP_PORT_REMOVE(SOC_INFO(unit).hl.bitmap, port);
        }
    }
    if (SOC_IS_KATANA2(unit) && !SOC_IS_SABER2(unit)) {
        if ((mode == BCM_PORT_ENCAP_HIGIG2_LITE) && IS_ST_PORT(unit, port)) {
            /*KT2: HL port is treated as GE port too*/
            SOC_PBMP_PORT_ADD(SOC_INFO(unit).hl.bitmap, port);
            SOC_PBMP_PORT_ADD(SOC_INFO(unit).ge.bitmap, port);
        } else if ((mode == BCM_PORT_ENCAP_IEEE) && IS_XE_PORT(unit,port)) {
            SOC_PBMP_PORT_REMOVE(SOC_INFO(unit).hl.bitmap, port);
            SOC_PBMP_PORT_REMOVE(SOC_INFO(unit).ge.bitmap, port);
        }
        soc_dport_map_update(unit);
    }
    /*
     * MAC_ENCAP_SET() would change the ING_MTU to defalut value.
     * So also change EGR_MTU to default value manually.
     */
#ifdef BCM_SHADOW_SUPPORT
    if (SOC_IS_SHADOW(unit)) {
        mtu = (1 << soc_reg_field_length(unit, EGR_L2_MTUr, VALUEf)) - 1;
        soc_reg_field_set(unit, EGR_L2_MTUr, &rval,
                          VALUEf, mtu);
        SOC_IF_ERROR_RETURN(WRITE_EGR_L2_MTUr(unit, port, rval));
    } else
#endif /* BCM_SHADOW_SUPPORT */

#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (SOC_IS_XGS3_SWITCH(unit)) {
        soc_reg_t reg;
        soc_mem_t mem;
        uint32 field_val_clear = 0;

        if (SOC_MEM_IS_VALID(unit, EGR_MTUm)) {
            mem = EGR_MTUm;
            mtu = si->max_mtu;
            if (soc_feature(unit, soc_feature_egr_all_profile)) {
                BCM_IF_ERROR_RETURN(
                    bcm_esw_port_egr_lport_field_set(unit, port, mem,
                    MTU_SIZEf, mtu));
            } else {
                SOC_IF_ERROR_RETURN(
                    soc_mem_read(unit, mem, MEM_BLOCK_ANY, port, entry));
                soc_mem_field_set(unit, mem, entry, MTU_SIZEf, &mtu);
                if (soc_mem_field_valid(unit, mem, MTU_ENABLEf)) {
                soc_mem_field_set(unit, mem, entry, MTU_ENABLEf,
                                  &field_val_clear);
                }
                SOC_IF_ERROR_RETURN(
                    soc_mem_write(unit, mem, MEM_BLOCK_ANY, port, entry));
            }
        } else {
            reg = SOC_REG_IS_VALID(unit, EGR_MTUr) ? EGR_MTUr : EGR_MTU_SIZEr;
            mtu = si->max_mtu;
            soc_reg_field_set(unit, reg, &rval, MTU_SIZEf, mtu);
            if (soc_reg_field_valid(unit, reg, MTU_ENABLEf)) {
                soc_reg_field_set(unit, reg, &rval, MTU_ENABLEf, 0);
            }
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
        }
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT */

    if (!to_higig) {
        SOC_IF_ERROR_RETURN
            (MAC_INTERFACE_SET(PORT(unit, port).p_mac,
                               unit, port, SOC_PORT_IF_XGMII));
    }

    /* Sepcific for GH on avoiding port speed change */
    if (!soc_feature(unit, soc_feature_hg_no_speed_change)) {
        BCM_IF_ERROR_RETURN
                (bcm_esw_port_ability_local_get(unit, port, &ability));

        non_ieee_speed = ability.speed_full_duplex &
                ~(SOC_PA_SPEED_100GB | SOC_PA_SPEED_40GB | SOC_PA_SPEED_10GB |
                  SOC_PA_SPEED_2500MB | SOC_PA_SPEED_1000MB | SOC_PA_SPEED_100MB |
                  SOC_PA_SPEED_10MB);

        BCM_IF_ERROR_RETURN
                (bcm_esw_port_ability_advert_get(unit, port, &ability));
        if (to_higig) {
            ability.speed_full_duplex |= non_ieee_speed;
            ability.pause &= ~(SOC_PA_PAUSE | SOC_PA_PAUSE_ASYMM);
            /* Retrieving the max speed */
            BCM_IF_ERROR_RETURN(bcm_esw_port_speed_max(unit, port, &force_speed));
            force_speed = force_speed == 0 ?
                    SOC_CONTROL(unit)->info.port_speed_max[port] : force_speed;

#ifdef BCM_TRIDENT2_SUPPORT
            if (SOC_IS_TRIDENT2(unit) &&
                soc_property_port_get(unit, port, spn_PORT_MAX_SPEED, 0) &&
                (si->port_num_lanes[port] != 4)) {
                config_speed = soc_property_port_get(unit, port, spn_PORT_MAX_SPEED, force_speed);
                force_speed = (force_speed > config_speed) ? config_speed : force_speed;
            }
#endif

            ability.speed_full_duplex |= SOC_PA_SPEED(force_speed);
        } else {
            ability.speed_full_duplex &= ~non_ieee_speed;
            force_speed = IS_GE_PORT(unit , port) ? 1000 : IS_CE_PORT(unit , port) ?
                100000 : SOC_CONTROL(unit)->info.port_speed_max[port] >= 40000 ?
                40000 :  SOC_CONTROL(unit)->info.port_speed_max[port] >= 10000 ?
                10000 : 1000;
#if defined(BCM_KATANA2_SUPPORT)
            /* For Katana2 Warpcore the xlport_mode_reg. The phy_port_mode value
            * differs when speed is 1000 vs 2500.
            * GE port does not necessarily have 1000 speed always.
            * The VCO frequency can change ased on phy_port_mode,
            * core_port_mode and number of lanes on Warpcore.
            * The lower layer Warpcore driver relies on these values.
            * So we need to set the correct forced speed for the port */
            if ((SOC_IS_KATANA2(unit) && !SOC_IS_SABER2(unit)) && force_speed == 1000) {
                BCM_IF_ERROR_RETURN(bcm_esw_port_speed_get(unit, port, &speed));
                force_speed = (speed == 2500) ? speed : force_speed;
            }
#endif
        }

    BCM_IF_ERROR_RETURN
        (bcm_esw_port_ability_advert_set(unit, port, &ability));

#ifdef BCM_KATANA2_SUPPORT
#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
       BCM_IF_ERROR_RETURN
              (_bcm_ml_update_port_mode(unit, port, force_speed));

        if (IS_XL_PORT(unit,port) &&
            ((mode == BCM_PORT_ENCAP_HIGIG2) || (mode == BCM_PORT_ENCAP_HIGIG))) {
            SOC_IF_ERROR_RETURN(soc_phyctrl_speed_set(unit, port, force_speed));
            SOC_IF_ERROR_RETURN(MAC_SPEED_SET(PORT(unit, port).p_mac,
                                  unit, port, force_speed));
        }
    } else
#endif

#ifdef BCM_SABER2_SUPPORT
    if (SOC_IS_SABER2(unit)) {
       BCM_IF_ERROR_RETURN
              (_bcm_sb2_update_port_mode(unit, port, force_speed));

        if (IS_XL_PORT(unit,port) &&
            ((mode == BCM_PORT_ENCAP_HIGIG2) || (mode == BCM_PORT_ENCAP_HIGIG))) {
            SOC_IF_ERROR_RETURN(soc_phyctrl_speed_set(unit, port, force_speed));
            SOC_IF_ERROR_RETURN(MAC_SPEED_SET(PORT(unit, port).p_mac,
                                  unit, port, force_speed));
        }
    } else
#endif
        if(SOC_IS_KATANA2(unit) && update_port_mode) {
            BCM_IF_ERROR_RETURN
                (_bcm_kt2_update_port_mode(unit, port, force_speed));
        }
#endif
        SOC_IF_ERROR_RETURN
                (soc_phyctrl_auto_negotiate_get(unit, port, &an, &an_done));
        /* some phy driver will enable the port no matter previous port
         * state while executing speed_set or autoneg_set. So we need to
         * get the port state before speed_set or autoneg_set, and set it
         * back after speed_set or autoneg_set. So that it can keep the
         * same port state before after speed_set or autoneg_set*/
        BCM_IF_ERROR_RETURN(bcm_esw_port_enable_get(unit, port, &enable));

        /* Some mac driver re-init phy while executing MAC_ENCAP_SET, in that case
         * autoneg is probably always true here */
        if (an) {
            SOC_IF_ERROR_RETURN(bcm_esw_port_autoneg_set(unit, port, TRUE));
        } else {
            SOC_IF_ERROR_RETURN(soc_phyctrl_speed_set(unit, port, force_speed));
        }
        BCM_IF_ERROR_RETURN(bcm_esw_port_enable_set(unit, port, enable));
    }

    /* Now we propagate the changes */
    port_type = to_higig ? 1 : 0;
    if (soc_mem_field_valid(unit, PORT_TABm, port_type_field)) {
        SOC_IF_ERROR_RETURN(soc_mem_field32_modify(
                            unit, PORT_TABm, port, port_type_field, port_type));
    }
    if (SOC_MEM_IS_VALID(unit, EGR_PORTm)) {
        if (soc_mem_field_valid(unit, EGR_PORTm, port_type_field)) {
            SOC_IF_ERROR_RETURN
                (soc_mem_field32_modify(unit, EGR_PORTm, port, port_type_field,
                                        port_type));
        }
    } else {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, egr_port_reg, port, port_type_field,
                                    port_type));
    }

    if (SOC_MEM_IS_VALID(unit, EGR_ING_PORTm)) {
        if (!IS_CPU_PORT(unit, port) && !IS_LB_PORT(unit, port)) {
            SOC_IF_ERROR_RETURN
                (soc_mem_field32_modify(unit, EGR_ING_PORTm, port, PORT_TYPEf,
                                        mode == BCM_PORT_ENCAP_IEEE ? 0 : 1));
        }
    }

    
    if (SOC_MEM_IS_VALID(unit, ICONTROL_OPCODE_BITMAPm)) {
        icontrol_opcode_bitmap_entry_t entry;
        soc_pbmp_t pbmp;

        SOC_IF_ERROR_RETURN
            (READ_ICONTROL_OPCODE_BITMAPm(unit, MEM_BLOCK_ANY, port, &entry));
        SOC_PBMP_CLEAR(pbmp);
        if (to_higig) {
            SOC_PBMP_PORT_SET(pbmp, CMIC_PORT(unit));
        }
        soc_mem_pbmp_field_set(unit, ICONTROL_OPCODE_BITMAPm, &entry,
                               BITMAPf, &pbmp);
        SOC_IF_ERROR_RETURN
            (WRITE_ICONTROL_OPCODE_BITMAPm(unit, MEM_BLOCK_ANY, port, &entry));
    } else if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
        SOC_IS_VALKYRIE2(unit)) {
        uint64 cpu_pbm64;
        uint64 rval64;      /* Current 64 bit register data.  */
        COMPILER_64_ZERO(cpu_pbm64);
        COMPILER_64_SET(cpu_pbm64, 0, to_higig ? 1 : 0);
        SOC_IF_ERROR_RETURN(READ_ICONTROL_OPCODE_BITMAP_64r(unit, port,
                                                            &rval64));
        soc_reg64_field_set(unit, ICONTROL_OPCODE_BITMAP_64r, &rval64,
                            BITMAPf, cpu_pbm64);
        SOC_IF_ERROR_RETURN(WRITE_ICONTROL_OPCODE_BITMAP_64r(unit, port,
                                                             rval64));
    } else if (SOC_REG_IS_VALID(unit,ICONTROL_OPCODE_BITMAP_LOr) &&
               SOC_REG_IS_VALID(unit,ICONTROL_OPCODE_BITMAP_HIr)) {
        uint64      fval64, rval64;
        uint32      t_port;
        pbmp_t      curr_pbmp;
        soc_reg_t   reg;

        BCM_PBMP_CLEAR(curr_pbmp);
        COMPILER_64_ZERO(fval64);

        /* Set HG ingress CPU Opcode map to the CPU */
        if (CMIC_PORT(unit) < 64) {
            reg = ICONTROL_OPCODE_BITMAP_LOr;
            t_port = CMIC_PORT(unit);
        } else {
            reg = ICONTROL_OPCODE_BITMAP_HIr;
            t_port = CMIC_PORT(unit) - 64;
        }


        if (to_higig) {
            SOC_PBMP_PORT_ADD(curr_pbmp, t_port);
        }

        BCM_IF_ERROR_RETURN(soc_reg_get(unit,
                            reg, port, 0, &rval64));
        COMPILER_64_SET(fval64,
                        SOC_PBMP_WORD_GET(curr_pbmp, 1),
                        SOC_PBMP_WORD_GET(curr_pbmp, 0));

        soc_reg64_field_set(unit,
                reg, &rval64, BITMAPf, fval64);
        BCM_IF_ERROR_RETURN(soc_reg_set(unit,
                reg, port, 0, rval64));

    } else if (SOC_REG_IS_VALID(unit,ICONTROL_OPCODE_BITMAPr)) {

        /* Set HG ingress CPU Opcode map to the CPU */
        int pbm_len;
        uint32 cpu_pbm = 0;

        if (to_higig) {
            if (SOC_IS_TR_VL(unit)) {
                soc_xgs3_port_to_higig_bitmap(unit, CMIC_PORT(unit),
                                              &cpu_pbm);
            } else if (CMIC_PORT(unit)) {
                pbm_len = soc_reg_field_length(unit, ICONTROL_OPCODE_BITMAPr,
                                               BITMAPf);
                cpu_pbm = 1 << (pbm_len - 1);
            } else {
                cpu_pbm = 1;
            }
        } /* else, cpu_pbm = 0 */

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, ICONTROL_OPCODE_BITMAPr,
                                    port, BITMAPf, cpu_pbm));
    }

    if (to_higig) {
        /* HG ports to forwarding */
        BCM_IF_ERROR_RETURN(bcm_esw_port_stp_set(unit, port,
                                                 BCM_STG_STP_FORWARD));
    }  

#if defined(BCM_XGS3_SWITCH_SUPPORT)
    /*
     * Higig ports need the MIRROR_CONTROL.M_ENABLE=1 in order to respond to
     * the mirror bit in the Higig headers.
     */
    if (to_higig) {
        BCM_IF_ERROR_RETURN(_bcm_esw_mirror_enable_set(unit, port, TRUE));
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT */

    /* Clear mirror enable settings */
    /* coverity[stack_use_callee] */
    /* coverity[stack_use_overflow] */
    BCM_IF_ERROR_RETURN(bcm_esw_mirror_port_set(unit, port, -1, -1, 0));

    /* Set untagged state in default VLAN properly */
    BCM_IF_ERROR_RETURN(_bcm_esw_vlan_untag_update(unit, port, to_higig));

    /* Resolve STG 0 */
    BCM_IF_ERROR_RETURN(bcm_esw_stg_default_get(unit, &stg));
    BCM_IF_ERROR_RETURN
        (bcm_esw_stg_stp_set(unit, 0, port,
                             to_higig ? BCM_STG_STP_FORWARD : BCM_STG_STP_DISABLE));

#ifdef BCM_TRX_SUPPORT
    /* Reset the vlan default action */
    if (SOC_IS_TRX(unit) &&
        (soc_feature(unit, soc_feature_vlan_action) ||
         soc_feature(unit, soc_feature_egr_vlan_action))) {
        bcm_vlan_action_set_t action;

        BCM_IF_ERROR_RETURN
            (_bcm_trx_vlan_port_egress_default_action_get(unit,
                                                         port, &action));
        /* Backward compatible defaults */
        if (to_higig && (!SOC_IS_TRIDENT3X(unit))) {
            action.ot_outer = bcmVlanActionDelete;
            action.dt_outer = bcmVlanActionDelete;
        } else {
            action.ot_outer = bcmVlanActionNone;
            action.dt_outer = bcmVlanActionNone;
        }
        BCM_IF_ERROR_RETURN
            (_bcm_trx_vlan_port_egress_default_action_set(unit,
                                                         port, &action));
    }
#endif

#ifdef INCLUDE_L3
    if (soc_feature(unit, soc_feature_ip_mcast)) {
        BCM_IF_ERROR_RETURN(bcm_esw_ipmc_egress_port_set(unit, port,
                to_higig ? _soc_mac_all_ones :_soc_mac_all_zeroes,
                0, 0, 0));
    }
#endif /* INCLUDE_L3 */

    return BCM_E_NONE;
#else
    return BCM_E_PARAM;
#endif
}

/*
 * Function:
 *      _bcm_port_encap_stport_set
 * Purpose:
 *      Convert 2.5G Higig 2 port to Ether port, or reverse
 */
int
_bcm_port_encap_stport_set(int unit, bcm_port_t port, int mode)
{
#if defined(BCM_RAVEN_SUPPORT) || defined (BCM_TRIUMPH2_SUPPORT) || \
    defined(BCM_KATANA_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    uint32           rval;
    bcm_stg_t        stg;
    int              to_higig = 0, max_mtu = 0;
    uint32           tab_higig_type;
    soc_info_t       *si = &SOC_INFO(unit);
    soc_field_t      hg_en[6] = {-1, HGIG2_EN_S0f, HGIG2_EN_S1f, -1,
                                 HGIG2_EN_S3f, HGIG2_EN_S4f};
    soc_field_t      port_type;
    soc_reg_t        egr_port;

    if (mode == BCM_PORT_ENCAP_HIGIG2 || mode == BCM_PORT_ENCAP_HIGIG2_LITE
        || mode == BCM_PORT_ENCAP_HIGIG || mode == BCM_PORT_ENCAP_HIGIG_OVER_ETHERNET) {
        to_higig = TRUE;
    }

#ifdef BCM_FIRELIGHT_SUPPORT
    if (SOC_IS_FIRELIGHT(unit)) {
        /* FL goes through */
    } else
#endif
    if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
        SOC_IS_GREYHOUND2(unit)) {
        if (!soc_feature(unit, soc_feature_wh2)) {
        return BCM_E_INTERNAL;
    }
    }

    /* This check is not correct for devices supporting embedded higig */
    if (!soc_feature(unit, soc_feature_embedded_higig) &&
        !soc_feature(unit, soc_feature_higig_over_ethernet)) {
        if (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANE(unit)) {
            if ((port != 26) && (port != 27) && (port != 28) && (port != 29)) {
                return BCM_E_PORT;
            }
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, EHG_RX_CONTROLr, port, MODEf,
                                        to_higig ? 2 : 0));
        } else if (SOC_IS_HURRICANE2(unit)) {
            if ((port < 26) || (port > 29)) {
                return BCM_E_PORT;
            }
        } else if (SOC_IS_KATANA(unit)) {
            /* Only ports 25..34 are HGL capable */
            if ((port < 25) || (port > 34)) {
                return BCM_E_PORT;
            }
        } else if (SOC_IS_KATANA2(unit) && !SOC_IS_SABER2(unit)) {
            /* Only ports 25..40 are HGL capable */
            if ((port < 25) || (port > 40)) {
                return BCM_E_PORT;
            }
        } else if (SOC_IS_TRIDENT2PLUS(unit) || SOC_IS_TOMAHAWKX(unit) ||
                   SOC_IS_TRIDENT3X(unit)) {
            /* Need to check what is the right condition for Embedded Higig */
        } else if (soc_feature(unit, soc_feature_wh2)) {
            /* All ports are HGL capable */
#ifdef BCM_FIRELIGHT_SUPPORT
        } else if (SOC_IS_FIRELIGHT(unit)) {
            /* All ports are HGL capable */
#endif
        } else {
            if ((port != 1) && (port != 2) && (port != 4) && (port != 5)) {
                return BCM_E_PORT;
            }
        }
    }

#if defined(BCM_KATANA2_SUPPORT)
    if (SOC_IS_KATANA2(unit) && !SOC_IS_SABER2(unit)) {
        SOC_IF_ERROR_RETURN(MAC_ENCAP_SET(PORT(unit, port).p_mac,
                                               unit, port, mode));
    } else
#endif
    {
        port_type = SOC_MEM_FIELD_VALID(unit,
                             SOC_PORT_MEM_TAB(unit, port),
                             HIGIG_PACKETf) ?
                             HIGIG_PACKETf : PORT_TYPEf;

        BCM_IF_ERROR_RETURN
             (_bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_NONE,
                                    port_type, to_higig));

        if (to_higig == 1) {
            if (mode == BCM_PORT_ENCAP_HIGIG_OVER_ETHERNET) {
                tab_higig_type = BCM_PORT_HG_TYPE_HGOE_TRANSPORT;
            } else if (mode == BCM_PORT_ENCAP_HIGIG) {
                tab_higig_type = BCM_PORT_HG_TYPE_HIGIGPLUS;
            } else {
                tab_higig_type = BCM_PORT_HG_TYPE_HIGIG2_NORMAL;
            }
        } else {
            tab_higig_type = 0;
        }

        if (SOC_MEM_FIELD_VALID(unit, EGR_ING_PORTm, HG_TYPEf)) {
            SOC_IF_ERROR_RETURN
                (soc_mem_field32_modify(unit, EGR_ING_PORTm, port,
                 HG_TYPEf, tab_higig_type));
        }

        if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, HG_TYPEf)) {
            SOC_IF_ERROR_RETURN
                (soc_mem_field32_modify(unit, EGR_PORTm, port,
                 HG_TYPEf, tab_higig_type));
        }

        if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, PORT_TYPEf)) {
            SOC_IF_ERROR_RETURN
                (soc_mem_field32_modify(unit, EGR_PORTm, port,
                             PORT_TYPEf, to_higig));
        } else {
            if (SOC_REG_IS_VALID(unit, EGR_PORT_64r)) {
                egr_port = EGR_PORT_64r;
            } else {
                egr_port = EGR_PORTr;
            }
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, egr_port, port,
                                        port_type, to_higig));
       }

       /* The port number check is for Coverity.  No port > 6 will
        * reach this logic on Raven. */
        if (SOC_IS_RAVEN(unit) && (port < 6)) {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, GPORT_CONFIGr, port,
                                        hg_en[port], to_higig));
        }
    }

    if (to_higig) {
        BCM_IF_ERROR_RETURN(bcm_esw_port_pause_set(unit, port, 0, 0));
        /* For encap to hg/st port, SOC_PORT_MIN need to update or
           cannot do SOC_PBMP_PORT_ADD if the port is lower than
           SOC_PORT_MIN
        */
        if ((port < SOC_PORT_MIN(unit,st)) || (SOC_PORT_MIN(unit,st) == -1)) {
            SOC_PORT_MIN(unit,st) = port;
        }
        if (port > SOC_PORT_MAX(unit,st)) {
            SOC_PORT_MAX(unit,st) = port;
        }

        SOC_PBMP_PORT_ADD(si->st.bitmap, port);
        SOC_PBMP_PORT_ADD(si->hl.bitmap, port);
        SOC_PBMP_PORT_REMOVE(si->xe.bitmap, port);
        SOC_PBMP_PORT_REMOVE(si->ether.bitmap, port);

        SOC_PBMP_PORT_INFO_UPDATE(si->xe);

        max_mtu = SOC_INFO(unit).max_mtu;
        BCM_IF_ERROR_RETURN(bcm_esw_port_frame_max_set(unit, port, max_mtu));
    } else {
        SOC_PBMP_PORT_REMOVE(si->st.bitmap, port);
        SOC_PBMP_PORT_REMOVE(si->hl.bitmap, port);
        SOC_PBMP_PORT_ADD(si->ether.bitmap, port);

        /* Set pause and frame - other abilities depend on the board and
         * the application needs to call other APIs appropriately */
        BCM_IF_ERROR_RETURN(bcm_esw_port_pause_set(unit, port, 1, 1));
        max_mtu = SOC_INFO(unit).max_mtu - 4;
        BCM_IF_ERROR_RETURN(bcm_esw_port_frame_max_set(unit, port, max_mtu));
    }
    SOC_PBMP_PORT_INFO_UPDATE(si->ether);
    SOC_PBMP_PORT_INFO_UPDATE(si->st);
    SOC_PBMP_PORT_INFO_UPDATE(si->hl);

    /* Set HG ingress CPU Opcode map to the CPU */
    if (SOC_MEM_IS_VALID(unit, ICONTROL_OPCODE_BITMAPm)) {
        icontrol_opcode_bitmap_entry_t entry;
        soc_pbmp_t pbmp;

        SOC_IF_ERROR_RETURN
            (READ_ICONTROL_OPCODE_BITMAPm(unit, MEM_BLOCK_ANY, port, &entry));
        SOC_PBMP_CLEAR(pbmp);
        if (to_higig) {
            SOC_PBMP_PORT_SET(pbmp, CMIC_PORT(unit));
        }
        soc_mem_pbmp_field_set(unit, ICONTROL_OPCODE_BITMAPm, &entry,
                               BITMAPf, &pbmp);
        SOC_IF_ERROR_RETURN
            (WRITE_ICONTROL_OPCODE_BITMAPm(unit, MEM_BLOCK_ANY, port, &entry));
    } else if (SOC_REG_IS_VALID(unit, ICONTROL_OPCODE_BITMAP_64r)) {
        uint64 cpu_pbm64;
        uint64 rval64;      /* Current 64 bit register data.  */
        COMPILER_64_ZERO(cpu_pbm64);
        COMPILER_64_SET(cpu_pbm64, 0, to_higig ? 1 : 0);
        SOC_IF_ERROR_RETURN(
            READ_ICONTROL_OPCODE_BITMAP_64r(unit, port,&rval64));

        soc_reg64_field_set(unit, ICONTROL_OPCODE_BITMAP_64r, &rval64,
                            BITMAPf, cpu_pbm64);

        SOC_IF_ERROR_RETURN(
            WRITE_ICONTROL_OPCODE_BITMAP_64r(unit, port, rval64));
    } else {
        uint32 cpu_pbm;

        if(SOC_IS_ENDURO(unit) || SOC_IS_HURRICANEX(unit)) {
            if(to_higig) {
                SOC_IF_ERROR_RETURN
                        (soc_xgs3_port_to_higig_bitmap(unit, CMIC_PORT(unit),
                                           &cpu_pbm));
            } else {
                cpu_pbm = 0;
            }
        } else {
            cpu_pbm = to_higig ? 1 : 0;
        }
#ifdef BCM_FIRELIGHT_SUPPORT
        if (SOC_IS_FIRELIGHT(unit)) {
            uint64      fval64, rval64;
            uint32      t_port;
            pbmp_t      curr_pbmp;
            soc_reg_t   reg;

            BCM_PBMP_CLEAR(curr_pbmp);
            COMPILER_64_ZERO(fval64);

            /* Set HG ingress CPU Opcode map to the CPU */
            if (CMIC_PORT(unit) < 64) {
                reg = ICONTROL_OPCODE_BITMAP_LOr;
                t_port = CMIC_PORT(unit);
            } else {
                reg = ICONTROL_OPCODE_BITMAP_HIr;
                t_port = CMIC_PORT(unit) - 64;
            }

            if (to_higig) {
                SOC_PBMP_PORT_ADD(curr_pbmp, t_port);
            }

            BCM_IF_ERROR_RETURN(soc_reg_get(unit,
                                reg, port, 0, &rval64));
            COMPILER_64_SET(fval64,
                            SOC_PBMP_WORD_GET(curr_pbmp, 1),
                            SOC_PBMP_WORD_GET(curr_pbmp, 0));

            soc_reg64_field_set(unit,
                    reg, &rval64, BITMAPf, fval64);
            BCM_IF_ERROR_RETURN(soc_reg_set(unit,
                    reg, port, 0, rval64));
        } else
#endif
        {
            SOC_IF_ERROR_RETURN(
                READ_ICONTROL_OPCODE_BITMAPr(unit, port,&rval));

            soc_reg_field_set(unit, ICONTROL_OPCODE_BITMAPr,
                              &rval, BITMAPf, cpu_pbm);

            SOC_IF_ERROR_RETURN(
                WRITE_ICONTROL_OPCODE_BITMAPr(unit, port, rval));
        }
    }

    /* HG ports to forwarding */
    BCM_IF_ERROR_RETURN(
        bcm_esw_port_stp_set(unit, port, BCM_STG_STP_FORWARD));

    /* Set untagged state in default VLAN properly */
    BCM_IF_ERROR_RETURN(_bcm_esw_vlan_untag_update(unit, port, to_higig));

    /* Resolve STG 0 */
    BCM_IF_ERROR_RETURN(bcm_esw_stg_default_get(unit, &stg));
    BCM_IF_ERROR_RETURN(
        bcm_esw_stg_stp_set(unit, stg, port, BCM_STG_STP_FORWARD));

#if defined(BCM_ENDURO_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    /* Reset the vlan default action */
    if ((SOC_IS_ENDURO(unit) || SOC_IS_HURRICANEX(unit) ||
         SOC_IS_KATANA2(unit)) &&
            soc_feature(unit, soc_feature_vlan_action)) {
        bcm_vlan_action_set_t action;

        BCM_IF_ERROR_RETURN
            (_bcm_trx_vlan_port_egress_default_action_get(unit,
                                                         port, &action));
        if (to_higig) {
            action.ot_outer = bcmVlanActionDelete;
            action.dt_outer = bcmVlanActionDelete;
        } else {
            action.ot_outer = bcmVlanActionNone;
            action.dt_outer = bcmVlanActionNone;
        }
        BCM_IF_ERROR_RETURN
            (_bcm_trx_vlan_port_egress_default_action_set(unit,
                                                         port, &action));
    }
#endif /* BCM_ENDURO_SUPPORT */

    return BCM_E_NONE;
#else
    return BCM_E_PARAM;
#endif
}

/*
 * Function:
 *      _bcm_port_ehg_header_mem_get
 * Purpose:
 *      Calculates the correct memories for a given port
 * Parameters:
 *      unit            - (IN) device id
 *      port            - (IN) Physical port
 *      tx_mem          - (OUT) tx memory for EHG heade
 *      rx_mem          - (OUT) rx memory for EHG heade
 *      rx_mask_mem     - (OUT) rx mask memory for EHG heade
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_port_ehg_header_mem_get(int unit, bcm_port_t port, soc_mem_t *tx_mem,
                             soc_mem_t *rx_mem, soc_mem_t *rx_mask_mem)
{
    int phy_port;

    if (NULL == tx_mem || NULL == rx_mem || NULL == rx_mask_mem) {
        return BCM_E_PARAM;
    }

    if (soc_feature(unit, soc_feature_logical_port_num)) {
        /* coverity[overrun-local : FALSE] */
        phy_port = SOC_INFO(unit).port_l2p_mapping[port];
    } else {
        phy_port = port;
    }
    switch (SOC_PORT_BLOCK_TYPE(unit, phy_port)) {
        case SOC_BLK_GXPORT:
            *tx_mem = XPORT_EHG_TX_TUNNEL_DATAm;
            *rx_mem = XPORT_EHG_RX_TUNNEL_DATAm;
            *rx_mask_mem = XPORT_EHG_RX_TUNNEL_MASKm;
            break;
        case SOC_BLK_GPORT:
            *tx_mem = GPORT_EHG_TX_TUNNEL_DATAm;
            *rx_mem = GPORT_EHG_RX_TUNNEL_DATAm;
            *rx_mask_mem = GPORT_EHG_RX_TUNNEL_MASKm;
            break;
        case SOC_BLK_SPORT:
            *tx_mem = SPORT_EHG_TX_TUNNEL_DATAm;
            *rx_mem = SPORT_EHG_RX_TUNNEL_DATAm;
            *rx_mask_mem = SPORT_EHG_RX_TUNNEL_MASKm;
            break;
        case SOC_BLK_XQPORT:
            *tx_mem = XQPORT_EHG_TX_TUNNEL_DATAm;
            *rx_mem = XQPORT_EHG_RX_TUNNEL_DATAm;
            *rx_mask_mem = XQPORT_EHG_RX_TUNNEL_MASKm;
            break;
        case SOC_BLK_CLPORT:
        case SOC_BLK_XLPORT:
        case SOC_BLK_XTPORT:
        case SOC_BLK_XWPORT:
            *tx_mem = PORT_EHG_TX_TUNNEL_DATAm;
            *rx_mem = PORT_EHG_RX_TUNNEL_DATAm;
            *rx_mask_mem = PORT_EHG_RX_TUNNEL_MASKm;
            break;
        default:
            *tx_mem = *rx_mem = *rx_mask_mem = INVALIDm;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_ehg_header_read
 * Purpose:
 *      Reads EHG header from the HW tables
 * Parameters:
 *      unit            - (IN) device id
 *      port            - (IN) Physical port
 *      buffer          - (OUT) Pointer to the buffer to contain header
 * Returns:
 *      BCM_E_XXX
 */

STATIC int
_bcm_port_ehg_header_read(int unit, bcm_port_t port, uint32 *buffer)
{
    soc_mem_t   tx_mem, rx_mem, rx_mask_mem;
    int         tbl_idx_start, tbl_idx_end, idx;
    xqport_ehg_rx_tunnel_data_entry_t      entry;
    int         phy_port;

    BCM_IF_ERROR_RETURN
        (_bcm_port_ehg_header_mem_get(unit, port, &tx_mem, &rx_mem,
                                      &rx_mask_mem));

    if (INVALIDm == tx_mem) {
        return (BCM_E_PORT);
    }

    if (soc_feature(unit, soc_feature_logical_port_num)) {
        phy_port = SOC_INFO(unit).port_l2p_mapping[port];
    } else {
        phy_port = port;
    }

    tbl_idx_start = SOC_PORT_BINDEX(unit, phy_port) * 4;
    tbl_idx_end = tbl_idx_start + 3;

    for (idx = 0 ; idx <= (tbl_idx_end - tbl_idx_start); idx ++) {
        BCM_IF_ERROR_RETURN
            (soc_mem_read(unit, tx_mem, SOC_PORT_BLOCK(unit, phy_port),
                          (idx + tbl_idx_start), (void *)&entry));
        soc_mem_field_get(unit, tx_mem, (void *)&entry, TUNNEL_DATAf,
                          (buffer + ((tbl_idx_end - tbl_idx_start - idx) * 4)));
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_port_ehg_header_write
 * Purpose:
 *      Writes EHG header into the HW tables
 * Parameters:
 *      unit            - (IN) device id
 *      port            - (IN) Physical port
 *      tx_buff         - (IN) Pointer to the tx header
 *      rx_buff         - (IN) Pointer to the rx header
 *      mask            - (IN) Pointer to the mask header
 *      len             - (IN) Header length
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_port_ehg_header_write(int unit, bcm_port_t port, uint32 *tx_buf,
                           uint32 *rx_buf, uint32 *mask, int len)
{
    soc_mem_t   tx_mem, rx_mem, rx_mask_mem;
    int         tbl_idx_start, tbl_idx_end, idx;
    xqport_ehg_rx_tunnel_data_entry_t data_entry;
    xqport_ehg_rx_tunnel_mask_entry_t mask_entry;
    int         phy_port;

    BCM_IF_ERROR_RETURN
        (_bcm_port_ehg_header_mem_get(unit, port, &tx_mem, &rx_mem,
                                      &rx_mask_mem));

    if (INVALIDm == tx_mem) {
        return (BCM_E_PORT);
    }

    if (soc_feature(unit, soc_feature_logical_port_num)) {
        phy_port = SOC_INFO(unit).port_l2p_mapping[port];
    } else {
        phy_port = port;
    }

    tbl_idx_start = SOC_PORT_BINDEX(unit, phy_port) * 4;
    tbl_idx_end = tbl_idx_start + (len / 4) - 1;

    for (idx = 0; idx <= (tbl_idx_end - tbl_idx_start); idx ++) {
        /* Reset hw buffer. */
        sal_memset(&data_entry, 0, sizeof(xqport_ehg_rx_tunnel_data_entry_t));
        soc_mem_field_set(unit, tx_mem, (uint32 *)&data_entry, TUNNEL_DATAf,
                          (tx_buf + ((tbl_idx_end - tbl_idx_start - idx) * 4)));
        BCM_IF_ERROR_RETURN
            (soc_mem_write(unit, tx_mem, SOC_PORT_BLOCK(unit, phy_port),
                           (idx + tbl_idx_start), &data_entry));

        /* Reset hw buffer. */
        sal_memset(&data_entry, 0, sizeof(xqport_ehg_rx_tunnel_data_entry_t));
        soc_mem_field_set(unit, rx_mem, (uint32 *)&data_entry, TUNNEL_DATAf,
                          (rx_buf + ((tbl_idx_end - tbl_idx_start - idx) * 4)));
        BCM_IF_ERROR_RETURN
            (soc_mem_write(unit, rx_mem, SOC_PORT_BLOCK(unit, phy_port),
                           (idx + tbl_idx_start), &data_entry));

        /* Reset hw buffer. */
        sal_memset(&mask_entry, 0, sizeof(xqport_ehg_rx_tunnel_mask_entry_t));
        soc_mem_field_set(unit, rx_mask_mem, (uint32 *)&mask_entry, TUNNEL_MASKf,
                          (mask + ((tbl_idx_end - tbl_idx_start - idx)* 4)));
        BCM_IF_ERROR_RETURN
            (soc_mem_write(unit, rx_mask_mem, SOC_PORT_BLOCK(unit, phy_port),
                           (idx + tbl_idx_start), &mask_entry));
    }

    return (BCM_E_NONE);
}


/*
 * Function:
 *      _bcm_port_ehg_setup_txrx_ethernet_hdr
 * Purpose:
 *      Prepares SRC and DEST MAC addresses into rx and tx buffers on a given index
 * Parameters:
 *      tx_buffer       -(IN/OUT) - tx buffer to fill
 *      rx_buffer       -(IN/OUT) - rx buffer to fill
 *      index           -(IN/OUT) - index to the right location in buffer
 *      encap_config    - (IN) structure describes port encapsulation configuration
 * Returns:
 *      BCM_E_XXX
 */

STATIC void
_bcm_port_ehg_setup_txrx_ethernet_hdr(uint32 *tx_buffer, uint32 *rx_buffer,
                                      int *index,
                                      bcm_port_encap_config_t *encap_config)
{
    int idx = *index;

    /* Destination mac address. */
    tx_buffer[idx] = (((uint32)(encap_config->dst_mac)[0]) << 24 | \
                      ((uint32)(encap_config->dst_mac)[1]) << 16 | \
                      ((uint32)(encap_config->dst_mac)[2]) << 8  | \
                      ((uint32)(encap_config->dst_mac)[3]));
    /* TX dest MAC is RX src MAC */
    rx_buffer[idx] = (((uint32)(encap_config->src_mac)[0]) << 24 | \
                      ((uint32)(encap_config->src_mac)[1]) << 16 | \
                      ((uint32)(encap_config->src_mac)[2]) << 8  | \
                      ((uint32)(encap_config->src_mac)[3]));
    idx--;

    tx_buffer[idx] = (((uint32)(encap_config->dst_mac)[4]) << 24 | \
                      ((uint32)(encap_config->dst_mac)[5]) << 16 | \
                      ((uint32)(encap_config->src_mac)[0]) << 8  | \
                      ((uint32)(encap_config->src_mac)[1]));
    /* TX dest MAC is RX src MAC */
    rx_buffer[idx] = (((uint32)(encap_config->src_mac)[4]) << 24 | \
                      ((uint32)(encap_config->src_mac)[5]) << 16 | \
                      ((uint32)(encap_config->dst_mac)[0]) << 8  | \
                      ((uint32)(encap_config->dst_mac)[1]));
    idx--;
    /* Source mac address. */
    tx_buffer[idx] = (((uint32)(encap_config->src_mac)[2]) << 24 | \
                      ((uint32)(encap_config->src_mac)[3]) << 16 | \
                      ((uint32)(encap_config->src_mac)[4]) << 8  | \
                      ((uint32)(encap_config->src_mac)[5]));
    /* TX src MAC is RX dest MAC */
    rx_buffer[idx] = (((uint32)(encap_config->dst_mac)[2]) << 24 | \
                      ((uint32)(encap_config->dst_mac)[3]) << 16 | \
                      ((uint32)(encap_config->dst_mac)[4]) << 8  | \
                      ((uint32)(encap_config->dst_mac)[5]));
    idx--;

    *index = idx;
    return;
}

/* Embedded Higig register access macros */
#define EHG_TX_REG(unit) \
        (SOC_IS_TRIUMPH3(unit) ? PORT_EHG_TX_CONTROLr : EHG_TX_CONTROLr)
#define EHG_RX_REG(unit) \
        (SOC_IS_TRIUMPH3(unit) ? PORT_EHG_RX_CONTROLr : EHG_RX_CONTROLr)
#define EHG_TPID_REG(unit) \
        (SOC_IS_TRIUMPH3(unit) ? PORT_EHG_TPIDr : EHG_TPIDr)

/*
 * Function:
 *      _bcm_port_ehg_ethernet_header_parse
 * Purpose:
 *      Parses Ethernet header from EHG header
 * Parameters:
 *      unit            - (IN) device id
 *      port            - (IN) Physical port
 *      header          - (IN) pointer to the EHG header buffer
 *      encap_config    - (IN/OUT) structure describes port encapsulation configuration
 *      index           - (IN/OUT) index to the right location in buffer
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_port_ehg_ethernet_header_parse(int unit, bcm_port_t port, uint32 *header,
                                    bcm_port_encap_config_t *encap_config, int *index)
{
    uint32  val;
    int     idx = *index;
    soc_reg_t ehg_tx_reg = EHG_TX_REG(unit);

    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, ehg_tx_reg, port, 0, &val));
    encap_config->dst_mac[0] = (uint8)(header[idx] >> 24);
    encap_config->dst_mac[1] = (uint8)(header[idx] >> 16);
    encap_config->dst_mac[2] = (uint8)(header[idx] >> 8);
    encap_config->dst_mac[3] = (uint8)(header[idx]);
    idx--;
    encap_config->dst_mac[4] = (uint8)(header[idx] >> 24);
    encap_config->dst_mac[5] = (uint8)(header[idx] >> 16);
    encap_config->src_mac[0] = (uint8)(header[idx] >> 8);
    encap_config->src_mac[1] = (uint8)(header[idx]);
    idx--;
    encap_config->src_mac[2] = (uint8)(header[idx] >> 24);
    encap_config->src_mac[3] = (uint8)(header[idx] >> 16);
    encap_config->src_mac[4] = (uint8)(header[idx] >> 8);
    encap_config->src_mac[5] = (uint8)(header[idx]);
    idx--;

    if (soc_reg_field_get(unit, ehg_tx_reg, val, VLAN_TAG_CONTROLf)) {
        encap_config->tpid = (uint16)(header[idx] >> 16);
        encap_config->vlan = (uint16)(header[idx]);
        idx--;
    } else {
        encap_config->vlan = BCM_VLAN_NONE;
        encap_config->tpid = BCM_VLAN_NONE;
    }

    *index = idx;
    return BCM_E_NONE;
}
/*
 * Function:
 *      _bcm_port_ip4_tunnel_header_set
 * Purpose:
 *      Prepares and sets IP GRE tunnel header for Embedded higig
 * Parameters:
 *      unit            - (IN) device id
 *      port            - (IN) Physical port
 *      encap_config    - (IN) structure describes port encapsulation configuration
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_port_ip4_tunnel_header_set(int unit, bcm_port_t port,
                               bcm_port_encap_config_t *encap_config)
{
    /*SW tunnel tx encap buffer.*/
    uint32 tx_buffer[_BCM_PORT_EHG_IP_GRE_HEADER_BUFFER_SZ];
    /*SW tunnel rx encap buffer.*/
    uint32 rx_buffer[_BCM_PORT_EHG_IP_GRE_HEADER_BUFFER_SZ];
    uint32      mask[_BCM_PORT_EHG_IP_GRE_HEADER_BUFFER_SZ];
    int    idx;  /* Headers offset iterator.*/
    int    adjust_rx_offset = 0;

    sal_memset(tx_buffer, 0, WORDS2BYTES(_BCM_PORT_EHG_IP_GRE_HEADER_BUFFER_SZ));
    sal_memset(rx_buffer, 0, WORDS2BYTES(_BCM_PORT_EHG_IP_GRE_HEADER_BUFFER_SZ));
    sal_memset(mask, 0, WORDS2BYTES(_BCM_PORT_EHG_IP_GRE_HEADER_BUFFER_SZ));

    idx = _BCM_PORT_EHG_IP_GRE_HEADER_BUFFER_SZ - 1;

    _bcm_port_ehg_setup_txrx_ethernet_hdr(tx_buffer, rx_buffer, &idx,
                                          encap_config);

    /* Set tpid & vlan id. */
    if (BCM_VLAN_VALID(encap_config->vlan)) {
        /* Tpid. Priority,  Cfi, Vlan id. */
        tx_buffer[idx] |= (((uint32)(encap_config->tpid)) << 16 | \
                           ((uint32)(encap_config->vlan)));
        /*rx_buffer should not have the VLAN and TPID included*/
        idx--;
        adjust_rx_offset = 1;
    }

    /*
     *   IPv4 header.
     */
    /* Set ether type to ip. 0x800  */
    /* Version + 5 word no options length.  + Tos */
    /* Length, Id, Flags, Fragmentation offset. */
    tx_buffer[idx] |= (((uint32)(0x0800) << 16) | \
                       ((uint32)(0x45) << 8) | \
                       ((uint32)(encap_config->tos)));
    rx_buffer[idx + adjust_rx_offset] = tx_buffer[idx];
    idx--;
    idx--;

    /* Ttl */
    /* Protocol (GRE 0x2f) */
    tx_buffer[idx] = (((uint32)(encap_config->ttl) << 8) | \
                      ((uint32)(0x2f)));
    rx_buffer[idx + adjust_rx_offset] = tx_buffer[idx];
    idx--;

    /* TX Src Ip. */
    tx_buffer[idx] |= ((uint32)(encap_config->src_addr) >> 16);

    /* RX Dst Ip. */
    rx_buffer[idx + adjust_rx_offset] |= ((uint32)(encap_config->dst_addr) >> 16);
    idx--;

    /* TX Src Ip. */
    tx_buffer[idx] |= ((uint32)(encap_config->src_addr) << 16);

    /* RX Dst Ip. */
    rx_buffer[idx + adjust_rx_offset] |= ((uint32)(encap_config->dst_addr) << 16);

    /* TX Dst Ip. */
    tx_buffer[idx] |= ((uint32)(encap_config->dst_addr) >> 16);

    /* RX Src Ip */
    rx_buffer[idx + adjust_rx_offset] |= ((uint32)(encap_config->src_addr) >> 16);
    idx--;


    /* TX Dst Ip. */
    tx_buffer[idx] |= ((uint32)(encap_config->dst_addr) << 16);

    /* RX Src Ip */
    rx_buffer[idx + adjust_rx_offset] |= ((uint32)(encap_config->src_addr) << 16);
    idx--;

    /* Gre header */
    /* Set protocol type in GRE header to ether type specified by user */
    tx_buffer[idx] |= (((uint32)(encap_config->higig_ethertype) << 16) | \
                       ((uint32)(encap_config->oui)[0]) << 8 | \
                       ((uint32)(encap_config->oui)[1]));
    rx_buffer[idx + adjust_rx_offset] = tx_buffer[idx];
    mask[idx + adjust_rx_offset]=0x0000FFFF;/*TUNNEL_TYPE=1:The first 38 bytes will be compared against the rx table data*/
    sal_memset(mask, 0xFF, WORDS2BYTES(idx + adjust_rx_offset));
    idx--;

    /* Set TX OUI and OUI Ethertype*/
    tx_buffer[idx] |= (((uint32)(encap_config->oui)[2]) << 24 | \
                       ((uint32)(encap_config->oui_ethertype)) << 8);
    rx_buffer[idx + adjust_rx_offset] = tx_buffer[idx];

    return _bcm_port_ehg_header_write(unit, port, tx_buffer, rx_buffer, mask,
                                      _BCM_PORT_EHG_IP_GRE_HEADER_BUFFER_SZ);
}

/*
 * Function:
 *      _bcm_port_ipv4_tunnel_header_parse
 * Purpose:
 *      Parse IPv4 GRE tunnel header for Embedded higig and updates encap_config
 *      structure accordingly
 * Parameters:
 *      unit            - (IN) device id
 *      port            - (IN) Physical port
 *      header          - (IN) Buffer contains EHG header to parse
 *      encap_config    - (OUT) structure describes port encapsulation configuration
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_port_ipv4_tunnel_header_parse(int unit, bcm_port_t port, uint32 *header,
                                   bcm_port_encap_config_t *encap_config)
{
    /* Headers offset iterator, begins at end of header */
    int  idx = 4 * BYTES2WORDS(sizeof(xport_ehg_tx_tunnel_data_entry_t)) - 1;

    BCM_IF_ERROR_RETURN(
    _bcm_port_ehg_ethernet_header_parse(unit, port, header, encap_config,
                                            &idx));

    encap_config->tos = (uint8)(header[idx]);
    idx--;
    idx--;
    encap_config->ttl = (uint8)(header[idx] >> 8);
    idx--;
    encap_config->src_addr = ((uint16)(header[idx])) << 16;
    idx--;
    encap_config->src_addr |=(uint16)(header[idx] >> 16);
    encap_config->dst_addr = ((uint16)(header[idx])) << 16;
    idx--;
    encap_config->dst_addr |=(uint16)(header[idx] >> 16);
    idx--;
    encap_config->higig_ethertype = (uint16)(header[idx] >> 16);
    encap_config->oui[0] = (uint8)(header[idx] >> 8);
    encap_config->oui[1] = (uint8)(header[idx]);
    idx--;
    encap_config->oui[2] = (uint8)(header[idx] >> 24);
    encap_config->oui_ethertype = (uint16)(header[idx] >> 8);

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_l2_tunnel_header_set
 * Purpose:
 *      Prepares and sets L2 tunnel header for Embedded higig
 * Parameters:
 *      unit            - (IN) device id
 *      port            - (IN) Physical port
 *      encap_config    - (IN) structure describes port encapsulation configuration
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_port_l2_tunnel_header_set(int unit, bcm_port_t port,
                               bcm_port_encap_config_t *encap_config)
{
    /*SW tunnel tx encap buffer.*/
    uint32 tx_buffer[_BCM_PORT_EHG_L2_HEADER_BUFFER_SZ];
    /*SW tunnel rx encap buffer.*/
    uint32 rx_buffer[_BCM_PORT_EHG_L2_HEADER_BUFFER_SZ];
    uint32      mask[_BCM_PORT_EHG_L2_HEADER_BUFFER_SZ];
    int     idx;  /* Headers offset iterator.*/
    int     adjust_rx_offset = 0;

    sal_memset(tx_buffer, 0, WORDS2BYTES(_BCM_PORT_EHG_L2_HEADER_BUFFER_SZ));
    sal_memset(rx_buffer, 0, WORDS2BYTES(_BCM_PORT_EHG_L2_HEADER_BUFFER_SZ));
    sal_memset(mask, 0, WORDS2BYTES(_BCM_PORT_EHG_L2_HEADER_BUFFER_SZ));

    idx = _BCM_PORT_EHG_L2_HEADER_BUFFER_SZ - 1;

    _bcm_port_ehg_setup_txrx_ethernet_hdr(tx_buffer, rx_buffer, &idx,
                                          encap_config);

    /* Set tpid & vlan id. */
    if (BCM_VLAN_VALID(encap_config->vlan)) {
        /* Tpid. Priority,  Cfi, Vlan id. */
        tx_buffer[idx] |= (((uint32)(encap_config->tpid)) << 16 | \
                           ((uint32)(encap_config->vlan)));
        /*rx_buffer should not have the VLAN and TPID included*/
        idx--;
        adjust_rx_offset = 1;
    }

    /* Set ether type to OUI and TX OUI */
    tx_buffer[idx] |= (((uint32)(encap_config->higig_ethertype)) << 16 | \
                       ((uint32)(encap_config->oui)[0]) << 8 | \
                       ((uint32)(encap_config->oui)[1]));
    rx_buffer[idx + adjust_rx_offset] = tx_buffer[idx];
    mask[idx + adjust_rx_offset] = 0x0000FFFF; /*TUNNEL_TYPE=0:The first 14 bytes will be compared against the rx table data*/
    sal_memset(mask, 0xFF, WORDS2BYTES(idx + adjust_rx_offset));
    idx--;
    /* Set TX OUI and HG ether type */
    tx_buffer[idx] |= (((uint32)(encap_config->oui)[2]) << 24 | \
                       ((uint32)(encap_config->oui_ethertype)) << 8);
    rx_buffer[idx + adjust_rx_offset] = tx_buffer[idx];

    return _bcm_port_ehg_header_write(unit, port, tx_buffer, rx_buffer, mask,
                                       _BCM_PORT_EHG_L2_HEADER_BUFFER_SZ);
}


/*
 * Function:
 *      _bcm_port_l2_tunnel_header_parse
 * Purpose:
 *      Parse L2 tunnel header for Embedded higig and updates encap_config
 *      structure accordingly
 * Parameters:
 *      unit            - (IN) device id
 *      port            - (IN) Physical port
 *      header          - (IN) Buffer contains EHG header to parse
 *      encap_config    - (OUT) structure describes port encapsulation configuration
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_port_l2_tunnel_header_parse(int unit, bcm_port_t port, uint32 *header,
                                 bcm_port_encap_config_t *encap_config)
{
    /* Headers offset iterator, begins at end of header */
    int  idx = 4 * BYTES2WORDS(sizeof(xport_ehg_tx_tunnel_data_entry_t)) - 1;

    BCM_IF_ERROR_RETURN
        (_bcm_port_ehg_ethernet_header_parse(unit, port, header,
                                             encap_config, &idx));

    encap_config->higig_ethertype = (uint16)(header[idx] >> 16);
    encap_config->oui[0] = (uint8)(header[idx] >> 8);
    encap_config->oui[1] = (uint8)(header[idx]);
    idx--;
    encap_config->oui[2] = (uint8)(header[idx] >> 24);
    encap_config->oui_ethertype = (uint16)(header[idx] >> 8);

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_encap_ehg_xport_update
 * Purpose:
 *      Updates XPORT higig config for EHG
 * Parameters:
 *      unit            - (IN) device id
 *      port            - (IN) Physical port
 * Returns:
 */
STATIC int
_bcm_port_encap_ehg_xport_update(int unit, bcm_port_t port)
{
#if defined(BCM_TRIUMPH3_SUPPORT)
    if (SOC_IS_TRIUMPH3(unit)) {
        
        soc_field_t ept_fields[2] = { HIGIG2f, PORT_TYPEf };
        uint32 ept_vals[2] = { BCM_EGR_PORT_HIGIG2, BCM_EGR_PORT_TYPE_EHG };

        /* Ingress port table */
        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_NONE,
                                   HIGIG2f, 1));
        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_NONE,
                                   PORT_TYPEf, BCM_EGR_PORT_TYPE_EHG));

        /* Egress port table */
        BCM_IF_ERROR_RETURN
            (soc_mem_fields32_modify(unit, EGR_PORTm, port, 2,
                                     ept_fields, ept_vals));

        /* Egress ingress port table */
        BCM_IF_ERROR_RETURN
            (soc_mem_fields32_modify(unit, EGR_ING_PORTm, port, 2,
                                     ept_fields, ept_vals));

        BCM_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, PORT_CONFIGr, port,
                                    HIGIG2_MODEf, 1));

        if (SOC_MEM_IS_VALID(unit, ICONTROL_OPCODE_BITMAPm)) {
            icontrol_opcode_bitmap_entry_t entry;
            soc_pbmp_t pbmp;

            BCM_IF_ERROR_RETURN
                (READ_ICONTROL_OPCODE_BITMAPm(unit, MEM_BLOCK_ANY, port, &entry));

            SOC_PBMP_CLEAR(pbmp);

            SOC_PBMP_PORT_SET(pbmp, CMIC_PORT(unit));

            soc_mem_pbmp_field_set(unit, ICONTROL_OPCODE_BITMAPm, &entry,
                    BITMAPf, &pbmp);

            BCM_IF_ERROR_RETURN
                (WRITE_ICONTROL_OPCODE_BITMAPm(unit, MEM_BLOCK_ANY, port, &entry));
        }

        return (BCM_E_NONE);
    }
#endif /* BCM_TRIUMPH3_SUPPORT  */

#ifdef BCM_GXPORT_SUPPORT
    {
        soc_reg_t   egr_port_reg;

        if (IS_GX_PORT(unit, port) || IS_XQ_PORT(unit,port)) {

            egr_port_reg =
                (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
                 SOC_IS_VALKYRIE2(unit)|| SOC_IS_GREYHOUND(unit) ||
                 SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) ?
                 EGR_PORT_64r : EGR_PORTr;

            BCM_IF_ERROR_RETURN
                (_bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_NONE,
                                       HIGIG2f, 1));

            BCM_IF_ERROR_RETURN
                (_bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_NONE,
                                       PORT_TYPEf, BCM_EGR_PORT_TYPE_EHG));
            BCM_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, egr_port_reg, port, HIGIG2f,
                                        BCM_EGR_PORT_HIGIG2));
            BCM_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, egr_port_reg, port,
                                        PORT_TYPEf, BCM_EGR_PORT_TYPE_EHG));

            if(SOC_REG_IS_VALID(unit, XPORT_CONFIGr)) {
                BCM_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, XPORT_CONFIGr, port,
                                            HIGIG2_MODEf, 1));
            }
        }
    }
#endif /* BCM_GXPORT_SUPPORT */
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_port_ehg_transport_mode_set
 * Purpose:
 *      Set the port into embedded higig transport mode
 * Parameters:
 *      unit            - (IN) device id
 *      port            - (IN) Physical port
 *      encap_config    - (IN) structure describes port encapsulation configuration
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_port_ehg_transport_mode_set(int unit, bcm_port_t port,
                                 bcm_port_encap_config_t *encap_config)
{
    int         vlan_valid;
    uint32      val;
    soc_reg_t   ehg_tx_reg = EHG_TX_REG(unit);
    soc_reg_t   ehg_rx_reg = EHG_RX_REG(unit);
    soc_reg_t   ehg_tpid_reg = EHG_TPID_REG(unit);

    if (IS_HG_PORT(unit, port)) {
        return BCM_E_CONFIG;
    }

    BCM_IF_ERROR_RETURN
        (_bcm_port_encap_ehg_xport_update(unit, port));

    vlan_valid = BCM_VLAN_VALID(encap_config->vlan);

    /* Configure TX control */
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, ehg_tx_reg, port, 0, &val));
    soc_reg_field_set(unit, ehg_tx_reg, &val, ENABLEf, 1);
    soc_reg_field_set(unit, ehg_tx_reg, &val, TUNNEL_TYPEf, 0);
    soc_reg_field_set(unit, ehg_tx_reg, &val, VLAN_TAG_CONTROLf,
                      vlan_valid);
    soc_reg_field_set(unit, ehg_tx_reg, &val, UPDATE_VLAN_PRI_CFIf,
                      vlan_valid);
    soc_reg_field_set(unit, ehg_tx_reg, &val, PAYLOAD_LENGTH_ADJUSTMENTf,
                      0);
    soc_reg_field_set(unit, ehg_tx_reg, &val, UPDATE_DSCPf, 0);
    soc_reg_field_set(unit, ehg_tx_reg, &val, UPDATE_IPf, 0);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, ehg_tx_reg, port, 0, val));

    /* Configure RX control */
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, ehg_rx_reg, port, 0, &val));
    soc_reg_field_set(unit, ehg_rx_reg, &val, TUNNEL_TYPEf, 0);
    soc_reg_field_set(unit, ehg_rx_reg, &val, MODEf, 1);
    soc_reg_field_set(unit, ehg_rx_reg, &val, VLAN_TAG_CONTROLf,
                      vlan_valid);
    soc_reg_field_set(unit, ehg_rx_reg, &val, COMPARE_VLANf,
                      vlan_valid);
    soc_reg_field_set(unit, ehg_rx_reg, &val, VLANf,
                      (vlan_valid) ? encap_config->vlan : 0);
    soc_reg_field_set(unit, ehg_rx_reg, &val, IPV4_CHKSUM_ENABLEf, 0);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, ehg_rx_reg, port, 0, val));

    /* Configure EHG-tpid */
    if (vlan_valid) {
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, ehg_tpid_reg, port, 0, &val));
        soc_reg_field_set(unit, ehg_tpid_reg, &val, TPIDf,
                          encap_config->tpid);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, ehg_tpid_reg, port, 0, val));
    }

    return _bcm_port_l2_tunnel_header_set(unit, port, encap_config);
}

/*
 * Function:
 *      _bcm_port_ehg_tunnel_mode_set
 * Purpose:
 *      Set the port into embedded higig tunnel mode
 * Parameters:
 *      unit            - (IN) device id
 *      port            - (IN) Physical port
 *      encap_config    - (IN) structure describes port encapsulation configuration
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_port_ehg_tunnel_mode_set(int unit, bcm_port_t port,
                                 bcm_port_encap_config_t *encap_config)
{
    int         vlan_valid;
    uint32      val;
    soc_reg_t   ehg_tx_reg = EHG_TX_REG(unit);
    soc_reg_t   ehg_rx_reg = EHG_RX_REG(unit);
    soc_reg_t   ehg_tpid_reg = EHG_TPID_REG(unit);

    if (IS_HG_PORT(unit, port)) {
        return BCM_E_CONFIG;
    }

    BCM_IF_ERROR_RETURN
        (_bcm_port_encap_ehg_xport_update(unit, port));

    vlan_valid = BCM_VLAN_VALID(encap_config->vlan);

    /* Configure TX control */
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, ehg_tx_reg, port, 0, &val));
    soc_reg_field_set(unit, ehg_tx_reg, &val, ENABLEf, 1);
    soc_reg_field_set(unit, ehg_tx_reg, &val, TUNNEL_TYPEf, 1);
    soc_reg_field_set(unit, ehg_tx_reg, &val, VLAN_TAG_CONTROLf,
                      vlan_valid);
    soc_reg_field_set(unit, ehg_tx_reg, &val, UPDATE_VLAN_PRI_CFIf,
                      vlan_valid);
    soc_reg_field_set(unit, ehg_tx_reg, &val, PAYLOAD_LENGTH_ADJUSTMENTf,
         vlan_valid ? (WORDS2BYTES(_BCM_PORT_EHG_IP_GRE_HEADER_BUFFER_SZ) - 1):
                 (WORDS2BYTES(_BCM_PORT_EHG_IP_GRE_HEADER_BUFFER_SZ - 1) - 1));
    soc_reg_field_set(unit, ehg_tx_reg, &val, UPDATE_DSCPf, 1);
    soc_reg_field_set(unit, ehg_tx_reg, &val, UPDATE_IPf, 1);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, ehg_tx_reg, port, 0, val));

    /* Configure RX control */
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, ehg_rx_reg, port, 0, &val));
    soc_reg_field_set(unit, ehg_rx_reg, &val, MODEf, 1);
    soc_reg_field_set(unit, ehg_rx_reg, &val, TUNNEL_TYPEf, 1);
    soc_reg_field_set(unit, ehg_rx_reg, &val, VLAN_TAG_CONTROLf,
                      vlan_valid);
    soc_reg_field_set(unit, ehg_rx_reg, &val, COMPARE_VLANf,
                      vlan_valid);
    soc_reg_field_set(unit, ehg_rx_reg, &val, VLANf,
                      (vlan_valid) ? encap_config->vlan : 0);
    soc_reg_field_set(unit, ehg_rx_reg, &val, IPV4_CHKSUM_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, ehg_rx_reg, port, 0, val));

    /* Configure EHG-tpid */
    if (vlan_valid) {
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, ehg_tpid_reg, port, 0, &val));
        soc_reg_field_set(unit, ehg_tpid_reg, &val, TPIDf,
                          encap_config->tpid);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, ehg_tpid_reg, port, 0, val));
    }

    return _bcm_port_ip4_tunnel_header_set(unit, port, encap_config);
}

/*
 * Function:
 *      _bcm_port_hgoe_transport_mode_set
 * Purpose:
 *      Set the port into Higig over Ethernet transport mode
 * Parameters:
 *      unit            - (IN) device id
 *      port            - (IN) Physical port
 *      encap_config    - (IN) structure describes port encapsulation configuration
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_port_hgoe_transport_mode_set(int unit, bcm_port_t port,
                                 bcm_port_encap_config_t *encap_config)
{
    uint64 val64;
    uint32 val;


    if (IS_HG_PORT(unit, port)) {
        return BCM_E_CONFIG;
    }
#if defined(BCM_TRIDENT3_SUPPORT)
    if (SOC_IS_TRIDENT3X(unit)) {
        if (BCM_PORT_ENCAP_HIGIG_OVER_ETHERNET == encap_config->encap) {
            return bcm_td3_port_hgoe_mode_set(unit, port);
        } else {
            return BCM_E_UNAVAIL;
        }
    }
#endif
    /* Configure HGoE TX control */
    if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, HG_TYPEf)) {
        BCM_IF_ERROR_RETURN
            (soc_mem_field32_modify(unit, EGR_PORTm, port, PORT_TYPEf,
                                    encap_config->encap ==
                                    BCM_PORT_ENCAP_HIGIG_OVER_ETHERNET?
                                    1 : 0));
        BCM_IF_ERROR_RETURN
            (soc_mem_field32_modify(unit, EGR_PORTm, port, HG_TYPEf,
                                    BCM_PORT_HG_TYPE_HGOE_TRANSPORT));
    }

    if (SOC_REG_IS_VALID(unit, EGR_EHG_ETHERTYPEr)) {
        BCM_IF_ERROR_RETURN
            (soc_reg32_get(unit, EGR_EHG_ETHERTYPEr, port, 0, &val));
        soc_reg_field_set(unit, EGR_EHG_ETHERTYPEr,
                          &val, ETHERTYPEf, encap_config->higig_ethertype);
        BCM_IF_ERROR_RETURN
            (soc_reg32_set(unit, EGR_EHG_ETHERTYPEr, port, 0, val));
    }

    if (SOC_REG_IS_VALID(unit, EGR_EHG_HEADER_CONTROLr)) {
        BCM_IF_ERROR_RETURN
            (soc_reg32_get(unit, EGR_EHG_HEADER_CONTROLr, port, 0, &val));
        soc_reg_field_set(unit, EGR_EHG_HEADER_CONTROLr,
                          &val, EHG_RESERVEDf, encap_config->hgoe_reserved);
        BCM_IF_ERROR_RETURN
            (soc_reg32_set(unit, EGR_EHG_HEADER_CONTROLr, port, 0, val));
    }

    /* Configure HGoE RX control */
    if (SOC_MEM_FIELD_VALID(unit, PORT_TABm, HG_TYPEf)) {
        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_tab_set(unit, port,
                                   _BCM_CPU_TABS_NONE, PORT_TYPEf,
                                   encap_config->encap ==
                                   BCM_PORT_ENCAP_HIGIG_OVER_ETHERNET?
                                   1 : 0));

        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_tab_set(unit, port,
                                   _BCM_CPU_TABS_NONE, HG_TYPEf,
                                   BCM_PORT_HG_TYPE_HGOE_TRANSPORT));
    }

    if (SOC_MEM_FIELD_VALID(unit, EGR_ING_PORTm, HG_TYPEf)) {
        BCM_IF_ERROR_RETURN
            (soc_mem_field32_modify(unit, EGR_ING_PORTm, port, PORT_TYPEf,
                                    encap_config->encap ==
                                    BCM_PORT_ENCAP_HIGIG_OVER_ETHERNET?
                                    1 : 0));
        BCM_IF_ERROR_RETURN
            (soc_mem_field32_modify(unit, EGR_ING_PORTm, port, HG_TYPEf,
                                    BCM_PORT_HG_TYPE_HGOE_TRANSPORT));
    }

    if (SOC_REG_IS_VALID(unit, PGW_CELL_ASM_EMBEDDED_HG_ETHERTYPEr)) {
        uint64 v64;
        COMPILER_64_SET(v64, 0, encap_config->higig_ethertype);
        BCM_IF_ERROR_RETURN
            (soc_reg_get(unit, PGW_CELL_ASM_EMBEDDED_HG_ETHERTYPEr, port, 0,
                         &val64));
        soc_reg64_field_set(unit, PGW_CELL_ASM_EMBEDDED_HG_ETHERTYPEr,
                            &val64, ETHERTYPEf, v64);
        BCM_IF_ERROR_RETURN
            (soc_reg_set(unit, PGW_CELL_ASM_EMBEDDED_HG_ETHERTYPEr, port, 0,
                         val64));
    }

    /* Enable HGoE */
    if (SOC_REG_IS_VALID(unit, PGW_CELL_ASM_EMBEDDED_HG_CONTROL0r)) {
        uint64 one = COMPILER_64_INIT(0, 1);
        BCM_IF_ERROR_RETURN
            (soc_reg_get(unit, PGW_CELL_ASM_EMBEDDED_HG_CONTROL0r, port, 0,
                         &val64));
        soc_reg64_field_set(unit, PGW_CELL_ASM_EMBEDDED_HG_CONTROL0r,
                            &val64, TRANSPORT_ENf, one);
        BCM_IF_ERROR_RETURN
            (soc_reg_set(unit, PGW_CELL_ASM_EMBEDDED_HG_CONTROL0r, port, 0,
                         val64));
    }
#ifdef BCM_TRX_SUPPORT
    /* Set the vlan default action */
    if (soc_feature(unit, soc_feature_vlan_action) &&
        (!SOC_IS_TRIDENT3X(unit))) {
        bcm_vlan_action_set_t action;

        BCM_IF_ERROR_RETURN
            (_bcm_trx_vlan_port_egress_default_action_get(unit,
                                                        port, &action));
        /* Backward compatible defaults */
        action.ot_outer = bcmVlanActionDelete;
        action.dt_outer = bcmVlanActionDelete;
        BCM_IF_ERROR_RETURN
            (_bcm_trx_vlan_port_egress_default_action_set(unit,
                                                        port, &action));
    }
#endif
#if defined(BCM_TRIDENT2PLUS_SUPPORT) && defined(BCM_TX_HGOE_LIMITED_SOLUTION)
    if (SOC_IS_TRIDENT2PLUS(unit)
        && SOC_MEM_IS_VALID(unit, ICONTROL_OPCODE_BITMAPm)) {
        icontrol_opcode_bitmap_entry_t entry;
        soc_pbmp_t pbmp;

        SOC_IF_ERROR_RETURN
            (READ_ICONTROL_OPCODE_BITMAPm(unit, MEM_BLOCK_ANY, port, &entry));
        SOC_PBMP_CLEAR(pbmp);
        SOC_PBMP_PORT_SET(pbmp, CMIC_PORT(unit));
        soc_mem_pbmp_field_set(unit,
                            ICONTROL_OPCODE_BITMAPm, &entry, BITMAPf, &pbmp);
        SOC_IF_ERROR_RETURN
            (WRITE_ICONTROL_OPCODE_BITMAPm(unit, MEM_BLOCK_ANY, port, &entry));
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT && BCM_TX_HGOE_LIMITED_SOLUTION */

    return BCM_E_NONE;
}


/*
 * Function:
 *      _bcm_esw_port_encap_higig_lite_set
 * Purpose:
 *      Helper function to force a port into HIGIG2_LITE mode
 * Parameters:
 *      unit            - (IN) device id
 *      port            - (IN) port number
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_esw_port_encap_higig_lite_set(int unit, bcm_port_t port)
{
    soc_port_ability_t  ability;
    int                 an, an_done;
    int rv = BCM_E_CONFIG;

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_encap_higig_lite_set(unit, port);
    }

    sal_memset(&ability, 0, sizeof(soc_port_ability_t));

    if (soc_feature(unit, soc_feature_hg_no_speed_change)) {
        /* HG-Lite process without 2.5G speed setting can calls to
            * _bcm_port_encap_xport_set() directly.
            */
        return _bcm_port_encap_xport_set(unit, port,
                                         BCM_PORT_ENCAP_HIGIG2_LITE, TRUE);
    } else {
        if (IS_XE_PORT(unit, port) || IS_HG_PORT(unit, port) ||
                (SOC_IS_METROLITE(unit) && IS_XL_PORT(unit, port))) {
            /* Restrict the speed to <= 2.5G and set the encap to HG2 */
            if ((SOC_IS_SABER2(unit) || SOC_IS_HURRICANE2(unit)) && IS_XL_PORT(unit, port)) {
                rv = _bcm_port_encap_xport_set(unit, port,
                                               BCM_PORT_ENCAP_HIGIG2_LITE,
                                               TRUE);
                if (rv != BCM_E_NONE) {
                    return rv;
                }
                SOC_IF_ERROR_RETURN
                         (MAC_SPEED_SET(PORT(unit, port).p_mac, unit, port, 2500));
            }
            if((SOC_IS_KATANA2(unit) && !SOC_IS_SABER2(unit)) && IS_XE_PORT(unit, port)) {
               /*Restrict the speed to <= 2.5G and set the encap to HG_LITE*/
                rv = _bcm_port_encap_xport_set(unit, port,
                                               BCM_PORT_ENCAP_HIGIG2_LITE,
                                               TRUE);
                if (rv != BCM_E_NONE) {
                    return rv;
                }
                SOC_IF_ERROR_RETURN
                         (MAC_SPEED_SET(PORT(unit, port).p_mac, unit, port, 2500));
            }
            BCM_IF_ERROR_RETURN(
                soc_phyctrl_ability_local_get(unit, port, &ability));

            ability.speed_full_duplex &= ~(SOC_PA_SPEED_10GB |
                    SOC_PA_SPEED_12GB | SOC_PA_SPEED_13GB | SOC_PA_SPEED_15GB |
                    SOC_PA_SPEED_16GB | SOC_PA_SPEED_20GB | SOC_PA_SPEED_21GB |
                    SOC_PA_SPEED_25GB | SOC_PA_SPEED_30GB | SOC_PA_SPEED_40GB);

            BCM_IF_ERROR_RETURN(
                soc_phyctrl_ability_advert_set(unit, port, &ability));
            BCM_IF_ERROR_RETURN(
                soc_phyctrl_auto_negotiate_get(unit, port, &an, &an_done));
            if (!an) {
                BCM_IF_ERROR_RETURN(
                    soc_phyctrl_speed_set(unit, port, 2500));
            }
            if (!SOC_IS_SABER2(unit) && !SOC_IS_KATANA2(unit) && !SOC_IS_HURRICANE2(unit)) {
                return _bcm_port_encap_xport_set(unit, port,
                                                 BCM_PORT_ENCAP_HIGIG2, TRUE);
            }
        } else if (IS_ST_PORT(unit, port) || IS_E_PORT(unit, port)) {
            return _bcm_port_encap_stport_set(unit, port, BCM_PORT_ENCAP_HIGIG2);
        }
    } /* if soc_feature(soc_feature_hg_no_speed_change) */

    return rv;
}


/*
 * Function:
 *      bcm_esw_port_encap_config_set
 * Purpose:
 *      Set the port encapsulation
 * Parameters:
 *      unit            - (IN) device id
 *      gport           - (IN) Generic port
 *      encap_config    - (IN) structure describes port encapsulation configuration
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_encap_config_set(int unit, bcm_gport_t gport,
                                  bcm_port_encap_config_t *encap_config)
{
    bcm_port_t  port;
    int         rv = BCM_E_UNAVAIL, curr_mode=0;
    soc_info_t  *si = &SOC_INFO(unit);
    bcm_stg_t        stg = 0;

    if (NULL == encap_config) {
        return BCM_E_PARAM;
    }
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, gport, &port));
    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }


    if (encap_config->encap != BCM_PORT_ENCAP_HIGIG2_L2 &&
        encap_config->encap != BCM_PORT_ENCAP_HIGIG2_LITE &&
        encap_config->encap != BCM_PORT_ENCAP_HIGIG2_IP_GRE &&
        encap_config->encap != BCM_PORT_ENCAP_HIGIG_OVER_ETHERNET) {
        return bcm_esw_port_encap_set(unit, port, encap_config->encap);
    }

    if (encap_config->encap == BCM_PORT_ENCAP_HIGIG2_LITE &&
        (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANEX(unit) || SOC_IS_RAVEN(unit)
        || SOC_IS_GREYHOUND(unit) || SOC_IS_GREYHOUND2(unit))) {
        return bcm_esw_port_encap_set(unit, port, encap_config->encap);
    }

    if (!soc_feature(unit, soc_feature_embedded_higig) &&
        !soc_feature(unit, soc_feature_higig_over_ethernet)) {
        return (BCM_E_UNAVAIL);
    }

#if defined(BCM_SABER2_SUPPORT)
    if (SOC_IS_SABER2(unit) && (!BCM_GPORT_IS_SET(port))) {
        if(!IS_XL_PORT(unit, port)) {
            /* On saber2 non XL port, shouldn't have reached till here */
            return BCM_E_UNAVAIL;
        }
    }
#endif
#if defined(BCM_TRIDENT3_SUPPORT)
    if (SOC_IS_TRIDENT3X(unit)
        && encap_config->encap == BCM_PORT_ENCAP_HIGIG_OVER_ETHERNET) {

        if (!soc_feature(unit, soc_feature_higig_over_ethernet)) {
            return BCM_E_UNAVAIL;
        }
    }
#endif
    PORT_LOCK(unit);

    if (encap_config->encap == BCM_PORT_ENCAP_HIGIG2_LITE) {
        rv = _bcm_esw_port_encap_higig_lite_set(unit, port);
    } else {
        if ((IS_XE_PORT(unit, port) || IS_HG_PORT(unit, port))) {
            if (BCM_PORT_ENCAP_HIGIG2_L2 == encap_config->encap) {
                rv = BCM_E_NONE;
                rv = bcm_esw_port_encap_get(unit, port, &curr_mode);
                if ((BCM_SUCCESS(rv)) && (curr_mode != BCM_PORT_ENCAP_IEEE)) {
                    rv = _bcm_port_encap_xport_set(unit, port,
                                                   BCM_PORT_ENCAP_IEEE, TRUE);
                }
            } else {
                rv = _bcm_port_encap_xport_set(unit, port,
                                               BCM_PORT_ENCAP_IEEE, TRUE);
            }
            /* Update soc_info_t after changing port to ethernet */
            soc_xport_type_update(unit, port, 0);
        } else if (IS_ST_PORT(unit, port) || IS_E_PORT(unit, port)) {
            rv = _bcm_port_encap_stport_set(unit, port, BCM_PORT_ENCAP_IEEE);
        }
    }

    if (BCM_SUCCESS(rv)) {
        if (BCM_PORT_ENCAP_HIGIG2_L2 == encap_config->encap) {
            rv = _bcm_port_ehg_transport_mode_set(unit, port, encap_config);
        } else if (BCM_PORT_ENCAP_HIGIG2_IP_GRE == encap_config->encap){
            rv = _bcm_port_ehg_tunnel_mode_set(unit, port, encap_config);
        } else if (BCM_PORT_ENCAP_HIGIG2_LITE == encap_config->encap){
            rv = soc_reg_field32_modify(unit, EHG_RX_REG(unit),
                                        port, MODEf, 2);
        } else if (BCM_PORT_ENCAP_HIGIG_OVER_ETHERNET == encap_config->encap){
            rv = _bcm_port_hgoe_transport_mode_set(unit, port, encap_config);
        }
    }

    /* Embedded Higig ports should be configured and marked as ST ports */
    if (BCM_SUCCESS(rv)) {
        rv = bcm_esw_port_pause_set(unit, port, 0, 0);
    }
    if (BCM_SUCCESS(rv)) {
        /* Stack ports to forwarding */
        rv = bcm_esw_port_stp_set(unit, port, BCM_STG_STP_FORWARD);
    }
    if (BCM_SUCCESS(rv)) {
        /* Set untagged state in default VLAN properly */
        rv = _bcm_esw_vlan_untag_update(unit, port, TRUE);
    }
    if (BCM_SUCCESS(rv)) {
        /* Resolve STG 0 */
        rv = bcm_esw_stg_default_get(unit, &stg);
    }
    if (BCM_SUCCESS(rv)) {
        rv = bcm_esw_stg_stp_set(unit, stg, port, BCM_STG_STP_FORWARD);
    }
    if (BCM_SUCCESS(rv)) {
        SOC_PBMP_PORT_ADD(si->st.bitmap, port);
        SOC_PBMP_PORT_REMOVE(si->ether.bitmap, port);
        SOC_PBMP_PORT_REMOVE(si->hg2_pbm, port);
    }

    PORT_UNLOCK(unit);

    return (rv);
}

/*
 * Function:
 *      bcm_esw_port_encap_config_get
 * Purpose:
 *      Get the port encapsulation
 * Parameters:
 *      unit            - (IN) device id
 *      gport           - (IN) Generic port
 *      encap_config    - (OUT) structure describes port encapsulation configuration
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_encap_config_get(int unit, bcm_gport_t gport,
                                  bcm_port_encap_config_t *encap_config)
{
    bcm_port_t      port;
    uint32          val, buffer[16];   /* 64 bytes max EHG header size */
    uint64          val64;
    int             rv = BCM_E_NONE, mode = 0;
    soc_reg_t       ehg_tx_reg = EHG_TX_REG(unit);
    soc_reg_t       ehg_rx_reg = EHG_RX_REG(unit);

    if (NULL == encap_config) {
        return (BCM_E_PARAM);
    }
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    sal_memset(encap_config, 0, sizeof(bcm_port_encap_config_t));

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, gport, &port));
    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    if (!soc_feature(unit, soc_feature_embedded_higig) &&
        !soc_feature(unit, soc_feature_higig_over_ethernet)) {

        rv = bcm_esw_port_encap_get(unit, port, &mode);
        if (BCM_SUCCESS(rv)) {
            encap_config->encap = (bcm_port_encap_t)mode;
        }
        return rv;
    }

    if (soc_feature(unit, soc_feature_embedded_higig)) {
        /* Check for Raptor-style stacking */
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, ehg_rx_reg, port, 0, &val));
        if (soc_reg_field_get(unit, ehg_rx_reg, val, MODEf) == 2) {
            encap_config->encap = BCM_PORT_ENCAP_HIGIG2_LITE;
            return rv;
        }

        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, ehg_tx_reg, port, 0, &val));
        /* If no EHG was programmed the just read port encapsulation */
        if (!soc_reg_field_get(unit, ehg_tx_reg, val, ENABLEf)) {
            rv = bcm_esw_port_encap_get(unit, port, &mode);
            if (BCM_SUCCESS(rv)) {
                encap_config->encap = (bcm_port_encap_t)mode;
            }
            return rv;
        }

        /* EHG is enabled. */
        if (!IS_ST_PORT(unit, port)) {
            return (BCM_E_CONFIG);
        }

        BCM_IF_ERROR_RETURN(_bcm_port_ehg_header_read(unit, port, buffer));

        if (!soc_reg_field_get(unit, ehg_tx_reg, val, TUNNEL_TYPEf)) {
            encap_config->encap = BCM_PORT_ENCAP_HIGIG2_L2;
            rv = _bcm_port_l2_tunnel_header_parse(unit, port, buffer,
                                                  encap_config);
        } else {
            encap_config->encap = BCM_PORT_ENCAP_HIGIG2_IP_GRE;
            rv = _bcm_port_ipv4_tunnel_header_parse(unit, port, buffer,
                                                    encap_config);
        }
    } else if(soc_feature(unit, soc_feature_higig_over_ethernet)) {
        uint64 v64 = COMPILER_64_INIT(0, 0);
        uint32 v32=0;

        /* If HGoE disabled and then just read port encapsulation */
        if (SOC_REG_IS_VALID(unit, PGW_CELL_ASM_EMBEDDED_HG_CONTROL0r)) {
            BCM_IF_ERROR_RETURN
             (soc_reg_get(unit, PGW_CELL_ASM_EMBEDDED_HG_CONTROL0r, port, 0,
                    &val64));
            v64 = soc_reg64_field_get(unit, PGW_CELL_ASM_EMBEDDED_HG_CONTROL0r,
                                    val64, TRANSPORT_ENf);
        }
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            uint8 is_hgoe = 0;
            BCM_IF_ERROR_RETURN(bcm_td3_port_hgoe_mode_get(
                        unit, port, &is_hgoe));
            if (is_hgoe) {
                encap_config->encap = BCM_PORT_ENCAP_HIGIG_OVER_ETHERNET;
                encap_config->higig_ethertype = BCM_TD3_HGOE_HDR_TYPE;
                return BCM_E_NONE;
            } else {
                rv = bcm_esw_port_encap_get(unit, port, &mode);
                if (BCM_SUCCESS(rv)) {
                    encap_config->encap = (bcm_port_encap_t)mode;
                }
                return rv;
            }
        } else
#endif
        if (COMPILER_64_IS_ZERO(v64)) {
            rv = bcm_esw_port_encap_get(unit, port, &mode);
            if (BCM_SUCCESS(rv)) {
                encap_config->encap = (bcm_port_encap_t)mode;
            }
            return rv;
        }

        if (!IS_ST_PORT(unit, port)) {
            return (BCM_E_CONFIG);
        }

        sal_memset(encap_config, 0, sizeof(bcm_port_encap_config_t));
        encap_config->encap = BCM_PORT_ENCAP_HIGIG_OVER_ETHERNET;

        if (SOC_REG_IS_VALID(unit, PGW_CELL_ASM_EMBEDDED_HG_ETHERTYPEr)) {
            BCM_IF_ERROR_RETURN
                (soc_reg_get(unit, PGW_CELL_ASM_EMBEDDED_HG_ETHERTYPEr, port,
                    0, &val64));
            v64 = soc_reg64_field_get(unit,
                   PGW_CELL_ASM_EMBEDDED_HG_ETHERTYPEr, val64, ETHERTYPEf);
            encap_config->higig_ethertype = (uint16) COMPILER_64_LO(v64);
        }

        if (SOC_REG_IS_VALID(unit, EGR_EHG_HEADER_CONTROLr)) {
            BCM_IF_ERROR_RETURN
                (soc_reg_get(unit, EGR_EHG_HEADER_CONTROLr, port, 0, &val64));
            v32 = COMPILER_64_LO(val64);
            encap_config->hgoe_reserved = soc_reg_field_get(unit,
                                EGR_EHG_HEADER_CONTROLr, v32, EHG_RESERVEDf);
        }
    }

    return (rv);
}

/*
 * Function:
 *      _bcm_esw_port_mirror_lock
 * Purpose:
 *      Take the mirror and port mutexes
 * Parameters:
 *      unit - unit #
 * Returns:
 *      None
 */
void
_bcm_esw_port_mirror_lock(int unit) {
    bcm_esw_mirror_lock(unit);
    PORT_LOCK(unit);
}

/*
 * Function:
 *      _bcm_esw_port_mirror_unlock
 * Purpose:
 *      Give up the mirror and port mutexes
 * Parameters:
 *      unit - unit #
 * Returns:
 *      None
 */
void
_bcm_esw_port_mirror_unlock(int unit) {
    PORT_UNLOCK(unit);
    bcm_esw_mirror_unlock(unit);
}

/*
 * Function:
 *      bcmi_esw_port_encap_set
 * Purpose:
 *      Set the port encapsulation mode
 * Parameters:
 *      unit - StrataSwitch unit #
 *      port - StrataSwitch port #
 *      mode - One of BCM_PORT_ENCAP_xxx (see port.h)
 * Returns:
 *      BCM_E_XXX
 */
int
bcmi_esw_port_encap_set(int unit, bcm_port_t port, int mode)
{
    int         rv=BCM_E_NONE, xport_swap = FALSE;
    int         stport_swap = FALSE;
#if defined(BCM_KATANA2_SUPPORT)
    uint64      rval64;
    ing_physical_port_table_entry_t ing_entry={{0}};
    ing_physical_port_table_entry_t ing_entry_dup={{0}};
    egr_physical_port_entry_t       egr_entry={{0}};
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif
#ifdef BCM_HELIX4_SUPPORT
    uint16 dev_id = 0;
    uint8 rev_id = 0;
#endif
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

#ifdef BCM_HELIX4_SUPPORT
    soc_cm_get_id(unit, &dev_id, &rev_id);
    if ((BCM56548H_DEVICE_ID == dev_id) &&
        (mode == BCM_PORT_ENCAP_IEEE) && ((port >= 46) && (port <= 53))) {
        /* IEEE encap mode shouldn't be supported on WC1 and WC2 for BCM56548H*/
        return BCM_E_UNAVAIL;
    }
#endif

#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_esw_port_encap_set: u=%d p=%d mode=%d\n"),
              unit, port, mode));
#if defined(BCM_METROLITE_SUPPORT)
    if (SOC_IS_METROLITE(unit)){
    if (!BCM_GPORT_IS_SET(port)) {
        if(!IS_XL_PORT(unit, port) && (mode != BCM_PORT_ENCAP_IEEE)) {
            return BCM_E_UNAVAIL;
	}
        if((0 == SOC_PORT_BLOCK_NUMBER(unit, port)) &&
            (mode != BCM_PORT_ENCAP_IEEE)) {
            return BCM_E_UNAVAIL;
        }
    }
}else
#endif
#if defined(BCM_SABER2_SUPPORT)
    if (SOC_IS_SABER2(unit) && (!BCM_GPORT_IS_SET(port))) {
        if(!IS_XL_PORT(unit, port) && (mode != BCM_PORT_ENCAP_IEEE)) {
            return BCM_E_UNAVAIL;
        }
    }
#endif
#if defined(BCM_GREYHOUND_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT) ||\
    defined (BCM_SABER2_SUPPORT)
    if (SOC_IS_GREYHOUND(unit) || SOC_IS_TOMAHAWKX(unit) ||
        SOC_IS_HURRICANE3(unit) || SOC_IS_SABER2(unit) ||
        SOC_IS_TRIDENT3X(unit) || SOC_IS_GREYHOUND2(unit)) {
        int encap_mode;
        BCM_IF_ERROR_RETURN(bcm_esw_port_encap_get(unit, port, &encap_mode));
        if (encap_mode == mode) {
            /* no encap set is required */
            return BCM_E_NONE;
        }
    }
#endif /* BCM_GREYHOUND_SUPPORT || BCM_TOMAHAWK_SUPPORT || BCM_SABER2_SUPPORT */

#if defined(BCM_HURRICANE3_SUPPORT)
    if (soc_feature(unit, soc_feature_wh2)){
        return bcmi_wh2_port_encap_set(unit, port, mode);
    }
#endif /* BCM_HURRICANE3_SUPPORT */
    _bcm_esw_port_mirror_lock(unit);

    if ((IS_HG_PORT(unit,port) && (mode == BCM_PORT_ENCAP_IEEE)) ||
        ((IS_XE_PORT(unit,port) || IS_CE_PORT(unit,port)) &&
         (mode != BCM_PORT_ENCAP_IEEE))) {
        if (soc_feature(unit, soc_feature_xport_convertible)) {
            xport_swap =  TRUE;
        } else {
            /* Ether <=> Higig not allowed on all systems */
            _bcm_esw_port_mirror_unlock(unit);
            return BCM_E_UNAVAIL;
        }
    }
#if defined(BCM_GREYHOUND_SUPPORT)
    if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
        SOC_IS_GREYHOUND2(unit)) {
        if ((IS_HG_PORT(unit, port) && (mode != BCM_PORT_ENCAP_IEEE)) ||
                (IS_HL_PORT(unit, port) && (mode == BCM_PORT_ENCAP_IEEE))) {
            /* HG port encap swap between HG/HG2/HG-Lite and
             * HG-Lite encap swap to IEEE.
             */
            xport_swap = TRUE;
        } else if (IS_GE_PORT(unit, port)) {
            if ((IS_XL_PORT(unit, port) || IS_CL_PORT(unit, port)) &&
                    (mode == BCM_PORT_ENCAP_IEEE ||
                    mode == BCM_PORT_ENCAP_HIGIG2_LITE)){
                /* GE+XL/CL port encap set between IEEE/HG-Lite */
                xport_swap = TRUE;
            } else {
                /* unavail encap configuration :
                 *  1. QSGMII port for HG/HG2/HG2-Lite related encap
                 *  2. GE(+XL) port for HG/HG2
                 */
                _bcm_esw_port_mirror_unlock(unit);
                return BCM_E_UNAVAIL;
            }
        }
    }
#endif  /* BCM_GREYHOUND_SUPPORT */
#if defined(BCM_KATANA_SUPPORT)
    if (SOC_IS_KATANA(unit) && IS_MXQ_PORT(unit,port) &&
                                IS_GE_PORT(unit,port)) {
        if ((IS_ST_PORT(unit,port) && (mode == BCM_PORT_ENCAP_IEEE)) ||
            (IS_E_PORT(unit,port) && (mode == BCM_PORT_ENCAP_HIGIG2 ||
                                      mode == BCM_PORT_ENCAP_HIGIG2_LITE))) {
            stport_swap =  TRUE;
        }
    }
#endif
#if defined(BCM_KATANA2_SUPPORT)
    if ((SOC_IS_KATANA2(unit) && !SOC_IS_SABER2(unit)) &&
                                 (port >= 25 && port <= 40)) {
        if ((IS_ST_PORT(unit,port) && (mode == BCM_PORT_ENCAP_IEEE)) ||
            (IS_E_PORT(unit,port) && (mode == BCM_PORT_ENCAP_HIGIG2 ||
                                      mode == BCM_PORT_ENCAP_HIGIG2_LITE))) {
             stport_swap =  TRUE;
        }
    }
#endif
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_HURRICANE2_SUPPORT)
    /* There could be hg to hg (hg2 -> hg2 lite) which require special processing */
    if ((SOC_IS_SABER2(unit) || SOC_IS_HURRICANE2(unit)) && IS_XL_PORT(unit, port)) {
        xport_swap = TRUE;
    }
#endif
    if (SOC_IS_RAVEN(unit) || SOC_IS_ENDURO(unit) || SOC_IS_HURRICANEX(unit)) {
        if ((IS_ST_PORT(unit,port) && (mode == BCM_PORT_ENCAP_IEEE)) ||
            (IS_E_PORT(unit,port) && (mode == BCM_PORT_ENCAP_HIGIG2 ||
                                      mode == BCM_PORT_ENCAP_HIGIG2_LITE))) {
                stport_swap =  TRUE;
        }
    }
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit) && IS_XT_PORT(unit,port) &&
        !((mode == BCM_PORT_ENCAP_IEEE) || (mode == BCM_PORT_ENCAP_HIGIG2_L2))) {
        /* Ether => Higig not allowed on XT ports */
            _bcm_esw_port_mirror_unlock(unit);
            return BCM_E_UNAVAIL;
    }
    if (SOC_IS_TRIUMPH3(unit) && (mode != BCM_PORT_ENCAP_IEEE) &&
        !IS_HG_PORT(unit, port)) {
        int hp, hgc = 0;

        PBMP_HG_ITER(unit, hp) {
            if (!SOC_PBMP_MEMBER(SOC_PORT_DISABLED_BITMAP(unit, port), hp)) {
                hgc++;
            }
        }
        if (hgc+1 > _SOC_TR3_MAX_HG_PORT_COUNT) {
            LOG_ERROR(BSL_LS_BCM_PORT, \
                      (BSL_META_U(unit, \
                                  "Error: Port %d config error "\
                                  "(Higig port count(%d) exceeded) !!\n"),
                       port, hgc));
            _bcm_esw_port_mirror_unlock(unit);
            return BCM_E_RESOURCE;
        }
    }
#endif /* BCM_TRIUMPH3_SUPPORT */

    if (xport_swap) {
        COUNTER_LOCK(unit);
        if ((BCM_PORT_ENCAP_HIGIG2_LITE == mode)) {
            rv = _bcm_esw_port_encap_higig_lite_set(unit, port);
        } else {
            rv = _bcm_port_encap_xport_set(unit, port, mode, TRUE);
        }

        COUNTER_UNLOCK(unit);
    } else if (stport_swap) {
        rv = _bcm_port_encap_stport_set(unit, port, mode);
    } else if (IS_HG_PORT(unit, port)) {
        rv = MAC_ENCAP_SET(PORT(unit, port).p_mac, unit, port, mode);
    } else if (IS_GE_PORT(unit, port) && IS_ST_PORT(unit, port)) {
        if (mode == BCM_PORT_ENCAP_IEEE) {
            bcm_port_encap_config_t encap_config;

            rv = bcm_esw_port_encap_config_get(unit, port,
                                               &encap_config);
            if (BCM_SUCCESS(rv)) {
                if ((BCM_PORT_ENCAP_HIGIG2_L2 == encap_config.encap) ||
                    (BCM_PORT_ENCAP_HIGIG2_IP_GRE == encap_config.encap) ||
                    (BCM_PORT_ENCAP_HIGIG2_LITE == encap_config.encap) ||
                    (BCM_PORT_ENCAP_HIGIG_OVER_ETHERNET == encap_config.encap)) {
                    rv = _bcm_port_encap_stport_set(unit, port,
                                                    BCM_PORT_ENCAP_IEEE);
                } else {
                    rv = BCM_E_UNAVAIL;
                }
            }
        } else {
            if ((mode == BCM_PORT_ENCAP_HIGIG2) ||
                (mode == BCM_PORT_ENCAP_HIGIG2_LITE &&
                 (SOC_IS_RAVEN(unit) || SOC_IS_ENDURO(unit) ||
                  SOC_IS_HURRICANEX( unit) || SOC_IS_GREYHOUND(unit) ||
                  SOC_IS_GREYHOUND2(unit)))) {
                rv = BCM_E_NONE;
            } else {
                rv = BCM_E_UNAVAIL;
            }
        }
#if defined(BCM_TRIUMPH3_SUPPORT)
     } else if (IS_CE_PORT(unit, port))  {
         if ((mode == BCM_PORT_ENCAP_HIGIG2) || (mode == BCM_PORT_ENCAP_HIGIG)
               || (mode == BCM_PORT_ENCAP_IEEE)) {
                    rv = _bcm_port_encap_stport_set(unit, port, mode);
         } else {
             rv = BCM_E_UNAVAIL;
         }
#endif
    } else if (mode == BCM_PORT_ENCAP_IEEE) {
        rv = BCM_E_NONE;
    } else {
        rv = BCM_E_UNAVAIL;
    }

#ifdef BCM_GXPORT_SUPPORT
    if ( IS_GX_PORT(unit, port)
      || IS_XG_PORT(unit,port)
      || (IS_XQ_PORT(unit, port) &&
         (SOC_IS_ENDURO(unit) || SOC_IS_HURRICANE(unit)))
      || (IS_XL_PORT(unit, port) &&
         (SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit) ||
          (SOC_IS_SABER2(unit) || SOC_IS_HURRICANE3(unit)) ||
           SOC_IS_GREYHOUND2(unit)))
      || (IS_CL_PORT(unit, port) && (SOC_IS_GREYHOUND2(unit)))
      || (IS_MXQ_PORT(unit, port) && (SOC_IS_KATANAX(unit) && !SOC_IS_SABER2(unit)))
      || ((IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port) ||
           IS_CE_PORT(unit, port)) &&
          (SOC_IS_TRIUMPH3(unit)
           || (SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit)) ||
           SOC_IS_TOMAHAWKX(unit))) ) {
        int hg2 = FALSE;
        soc_reg_t port_config_reg;
        uint32 regval, new_hg_pbm;
        int blk, blk_num, bindex;

        if (mode == BCM_PORT_ENCAP_HIGIG2 || mode == BCM_PORT_ENCAP_HIGIG2_LITE) {
            hg2 = TRUE;
        }
        if (BCM_SUCCESS(rv)) {
            rv = _bcm_esw_port_higig2_mode_set(unit, port, hg2);
        }

        if (IS_CL_PORT(unit, port) &&
            SOC_REG_IS_VALID(unit, CLPORT_CONFIGr)) {
            port_config_reg = CLPORT_CONFIGr;
        } else if (IS_C_PORT(unit, port) &&
            SOC_REG_IS_VALID(unit, CPORT_CONFIGr)) {
            port_config_reg = CPORT_CONFIGr;
        } else if (SOC_REG_IS_VALID(unit, XLPORT_CONFIGr)) {
            port_config_reg = XLPORT_CONFIGr;
        } else if (SOC_REG_IS_VALID(unit, PORT_CONFIGr)) {
            port_config_reg = PORT_CONFIGr;
        } else {
            port_config_reg = XPORT_CONFIGr;
        }
        if (BCM_SUCCESS(rv)) {
#if defined(BCM_GREYHOUND_SUPPORT)||defined(BCM_GREYHOUND2_SUPPORT)
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)){
                uint32  port_hg_mode;

                /* XLPORT/CLPORT and PGW register for HIGIG_MODEf is confirmed
                    *  will be '1' for HG/HG+ setting only and '0' for other
                    *  encap mode{IEEE/HG2/HG2-LITE}
                    */
                port_hg_mode = (mode == BCM_PORT_ENCAP_HIGIG) ? 1 : 0;
                rv = soc_reg_field32_modify(unit, port_config_reg, port,
                        HIGIG_MODEf, port_hg_mode);
                if (BCM_FAILURE(rv)) {
                    _bcm_esw_port_mirror_unlock(unit);
                    return rv;
                }

                /* only port available for HG2 configuration allows PGW encap
                * setting below
                */
#if defined(BCM_GREYHOUND2_SUPPORT)
                if (SOC_IS_GREYHOUND2(unit)) {
#ifdef BCM_FIRELIGHT_SUPPORT
                    if (soc_feature(unit, soc_feature_fl)) {
                        rv = soc_firelight_pgw_encap_field_modify(unit,
                                port, HIGIG_MODEf, port_hg_mode);
                    } else
#endif /* BCM_FIRELIGHT_SUPPORT */
                    {
                        rv = soc_greyhound2_pgw_encap_field_modify(unit,
                                port, HIGIG_MODEf, port_hg_mode);
                    }
                } else
#endif /* BCM_GREYHOUND2_SUPPORT */
                {
                    rv = soc_greyhound_pgw_encap_field_modify(unit,
                            port, HIGIG_MODEf, port_hg_mode);
                }
                if (BCM_FAILURE(rv)) {
                    _bcm_esw_port_mirror_unlock(unit);
                    return rv;
                }
            } else
#endif /* BCM_GREYHOUND_SUPPORT||BCM_GREYHOUND2_SUPPORT */
            {
#if defined(BCM_SABER2_SUPPORT)
                if(SOC_IS_SABER2(unit)) {
                    /* For Saber2, configure IECELL along with XLPORT */
                    if (SOC_REG_PORT_VALID(unit, IECELL_CONFIGr, port)) {
                        if ((mode == BCM_PORT_ENCAP_HIGIG2) ||
                                (mode == BCM_PORT_ENCAP_HIGIG2_LITE) ||
                                (mode == BCM_PORT_ENCAP_HIGIG)) {
                            rv = soc_reg_field32_modify(unit, IECELL_CONFIGr, port,
                                    HIGIG_MODEf, mode == BCM_PORT_ENCAP_HIGIG ?
                                    1 : 0);
                            rv = soc_reg_field32_modify(unit, IECELL_CONFIGr, port,
                                    HIGIG2_MODEf, mode == BCM_PORT_ENCAP_HIGIG ?
                                    0 : 1);
                        } else {
                            rv = soc_reg_field32_modify(unit, IECELL_CONFIGr, port,
                                    HIGIG2_MODEf, 0);
                            rv = soc_reg_field32_modify(unit, IECELL_CONFIGr, port,
                                    HIGIG_MODEf, 0);
                        }
                    }
                }
#endif
#ifdef BCM_KATANA2_SUPPORT
                if (SOC_IS_KATANA2(unit)) {
                    if (SOC_REG_FIELD_VALID(unit, port_config_reg, HIGIG_MODEf)) {
                        if ((mode == BCM_PORT_ENCAP_HIGIG2) ||
                                (mode == BCM_PORT_ENCAP_HIGIG2_LITE) ||
                                (mode == BCM_PORT_ENCAP_HIGIG)) {

                            rv = soc_reg_field32_modify(unit, port_config_reg, port,
                                    HIGIG_MODEf, mode == BCM_PORT_ENCAP_HIGIG ?
                                    1 : 0);
                            rv = soc_reg_field32_modify(unit, port_config_reg, port,
                                    HIGIG2_MODEf, mode == BCM_PORT_ENCAP_HIGIG ?
                                    0 : 1);
                        } else {
                            rv = soc_reg_field32_modify(unit, port_config_reg, port,
                                    HIGIG2_MODEf, 0);
                            rv = soc_reg_field32_modify(unit, port_config_reg, port,
                                    HIGIG_MODEf, 0);
                        }
                    }
                } else
#endif
                {
                    if (SOC_REG_FIELD_VALID(unit, port_config_reg, HIGIG_MODEf)) {
                        rv = soc_reg_field32_modify(unit, port_config_reg, port,
                                        HIGIG_MODEf, mode == BCM_PORT_ENCAP_IEEE ?
                                        0 : 1);
                    }
                    if (SOC_IS_TOMAHAWKX(unit)) {
                        if (IS_CL_PORT(unit, port) &&
                            (mode == BCM_PORT_ENCAP_HIGIG)) {
                            if (SOC_REG_FIELD_VALID(unit, port_config_reg,
                                HIGIG2_MODEf)) {
                                rv = soc_reg_field32_modify(unit,
                                        port_config_reg, port, HIGIG2_MODEf, 1);
                            }
                        }
                    }
                }
            }
        }
        if (BCM_SUCCESS(rv)) {
            if (SOC_MEM_IS_VALID(unit, EGR_PORTm) &&
                    soc_mem_field_valid(unit, EGR_PORTm, PORT_TYPEf)) {
                rv = soc_mem_field32_modify(unit, EGR_PORTm, port,
                                            PORT_TYPEf, mode == BCM_PORT_ENCAP_IEEE ?
                                            0 : 1);
            }
        }
        if (SOC_IS_TRIUMPH3(unit) && (mode == BCM_PORT_ENCAP_IEEE)) {
            /* Disable E2ECC */
            if (soc_feature(unit, soc_feature_logical_port_num)) {
                blk = SOC_PORT_BLOCK(unit, SOC_INFO(unit).port_l2p_mapping[port]);
                bindex = SOC_PORT_BINDEX(unit, SOC_INFO(unit).port_l2p_mapping[port]);
            } else{
                blk = SOC_PORT_BLOCK(unit, port);
                bindex = SOC_PORT_BINDEX(unit, port);
            }
            blk_num = SOC_BLOCK_INFO(unit, blk).number;
            /* In TR3 E2ECC is implemented only in blocks CL, XL1 */
            if (IS_CL_PORT(unit, port) || (blk == 13)) {
                if (IS_CL_PORT(unit, port)) {
                    blk_num = (blk_num ?  4 + bindex/4 : bindex/4);
                    bindex = bindex%4;
                } else {
                    blk_num = 3;
                }
#if defined(BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit)) {
                    /* In KT2 E2ECC is implemented only in blocks 6..9 */
                    blk_num = (blk_num >= 6) ? (blk_num - 6) : blk_num ;
                }
#endif
                rv = READ_E2ECC_TX_ENABLE_BMPr(unit, blk_num, &regval);
                if (BCM_FAILURE(rv)) {
                    _bcm_esw_port_mirror_unlock(unit);
                    return rv;
                }
                if (regval & (1 << bindex)) {
                    new_hg_pbm = soc_reg_field_get(unit, E2ECC_TX_ENABLE_BMPr, regval,
                                                   TX_ENABLE_BMPf);
                    new_hg_pbm &= ~(1 << bindex);
                    soc_reg_field_set(unit, E2ECC_TX_ENABLE_BMPr, &regval,
                                      TX_ENABLE_BMPf, new_hg_pbm);
                    rv = WRITE_E2ECC_TX_ENABLE_BMPr(unit, blk_num, regval);
                }
            }
        }
    }
#endif /* BCM_GXPORT_SUPPORT */

    if (soc_feature(unit, soc_feature_embedded_higig)) {
        /* Clear embedded Higig regs, if present */
        soc_reg_t   ehg_tx_reg = EHG_TX_REG(unit);
        soc_reg_t   ehg_rx_reg = EHG_RX_REG(unit);

        if (BCM_SUCCESS(rv) && SOC_REG_IS_VALID(unit, ehg_tx_reg)) {
            rv = soc_reg32_set(unit, ehg_tx_reg, port, 0, 0);
        }
        if (BCM_SUCCESS(rv) && SOC_REG_IS_VALID(unit, ehg_rx_reg)) {
            rv = soc_reg32_set(unit, ehg_rx_reg, port, 0, 0);
        }
    }

#ifdef BCM_HIGIG2_SUPPORT
    /* Update cached version of HiGig2 encapsulation */
    if (BCM_SUCCESS(rv)) {
        if (mode == BCM_PORT_ENCAP_HIGIG2 || mode == BCM_PORT_ENCAP_HIGIG2_LITE) {
            SOC_HG2_ENABLED_PORT_ADD(unit, port);

            if(SOC_IS_SABER2(unit)){
                if(mode == BCM_PORT_ENCAP_HIGIG2_LITE) {
                    SOC_PBMP_PORT_ADD(SOC_INFO(unit).hl.bitmap, port);
                } else {
                    SOC_PBMP_PORT_REMOVE(SOC_INFO(unit).hl.bitmap, port);
                }
            }
        } else {
            SOC_HG2_ENABLED_PORT_REMOVE(unit, port);
            if(SOC_IS_SABER2(unit) && IS_XL_PORT(unit, port)) {
                SOC_PBMP_PORT_REMOVE(SOC_INFO(unit).hl.bitmap, port);
            }
        }
    }
#endif /* BCM_HIGIG2_SUPPORT */

#ifdef BCM_KATANA2_SUPPORT
    if (BCM_SUCCESS(rv)) {
        if (SOC_IS_KATANA2(unit)) {
            int hdr_mode = 0;

            do {
                rv = soc_mem_read(unit, ING_PHYSICAL_PORT_TABLEm,
                                  MEM_BLOCK_ANY, port, &ing_entry);
                sal_memcpy(&ing_entry_dup,&ing_entry,
                           sizeof(ing_physical_port_table_entry_t));
                if (BCM_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                                          "Error: Encap Set: "
                                          "ING_PHYSICAL_PORT_TABLEm read failure")));
                    break;
                }
                rv = soc_mem_read(unit, EGR_PHYSICAL_PORTm,
                                  MEM_BLOCK_ANY, port, &egr_entry);
                if (BCM_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                                          "Error: Encap Set: "
                                          "EGR_PHYSICAL_PORTm read failure")));
                    break;
                }
                /* Initialize */
                soc_mem_field32_set(unit, ING_PHYSICAL_PORT_TABLEm,
                                    &ing_entry, PORT_TYPEf, 0);
                soc_mem_field32_set(unit, ING_PHYSICAL_PORT_TABLEm,
                                    &ing_entry, HIGIG2f, 0);
                soc_mem_field32_set(unit, EGR_PHYSICAL_PORTm,
                                    &egr_entry, PORT_TYPEf, 0);
                soc_mem_field32_set(unit, EGR_PHYSICAL_PORTm,
                                    &egr_entry, HIGIG2f, 0);
                if ((mode == BCM_PORT_ENCAP_HIGIG) ||
                    (mode == BCM_PORT_ENCAP_HIGIG2) ||
                    (mode == BCM_PORT_ENCAP_HIGIG2_LITE)) {
                     if (((mode == BCM_PORT_ENCAP_HIGIG2) ||
                          (mode == BCM_PORT_ENCAP_HIGIG2_LITE)) &&
                           soc_feature(unit, soc_feature_higig2)) {
                         if (mode == BCM_PORT_ENCAP_HIGIG2_LITE) {
                             hdr_mode = 0; /* Ieee mode */
                         } else {
                             hdr_mode = 2; /* Higig2 */
                         }
                         soc_mem_field32_set(unit,
                                             ING_PHYSICAL_PORT_TABLEm,
                                             &ing_entry, HIGIG2f, 1);
                         soc_mem_field32_set(unit, EGR_PHYSICAL_PORTm,
                                             &egr_entry, HIGIG2f, 1);
                    } else {
                        hdr_mode = 1; /* HG, hg+ */
                    }
                    soc_mem_field32_set(unit, ING_PHYSICAL_PORT_TABLEm,
                            &ing_entry, PORT_TYPEf, 1);
                    soc_mem_field32_set(unit, EGR_PHYSICAL_PORTm,
                            &egr_entry, PORT_TYPEf, 1);
                } else {
                    hdr_mode = 0; /* Ieee mode */
                }
                if (SOC_REG_IS_VALID(unit, XMAC_MODEr)) {
                    rv = READ_XMAC_MODEr(unit,port, &rval64);
                    if (BCM_FAILURE(rv)) {
                        _bcm_esw_port_mirror_unlock(unit);
                        return rv;
                    }
                    soc_reg64_field32_set(unit, XMAC_MODEr, &rval64,HDR_MODEf, hdr_mode);
                    rv = WRITE_XMAC_MODEr(unit, port, rval64);
                    if (BCM_FAILURE(rv)) {
                        _bcm_esw_port_mirror_unlock(unit);
                        return rv;
                    }
                }
                if (SOC_REG_IS_VALID(unit, XLMAC_MODEr)) {
                    rv = READ_XLMAC_MODEr(unit,port, &rval64);
                    if (BCM_FAILURE(rv)) {
                        _bcm_esw_port_mirror_unlock(unit);
                        return rv;
                    }
                    soc_reg64_field32_set(unit, XLMAC_MODEr, &rval64,HDR_MODEf, hdr_mode);
                    rv = WRITE_XLMAC_MODEr(unit, port, rval64);
                    if (BCM_FAILURE(rv)) {
                        _bcm_esw_port_mirror_unlock(unit);
                        return rv;
                    }
                }

                if (sal_memcmp(&ing_entry_dup,&ing_entry,
                               sizeof(ing_physical_port_table_entry_t)) == 0) {
                    LOG_VERBOSE(BSL_LS_BCM_PORT,
                                (BSL_META_U(unit,
                                            "##No Change in  entry so skipping write##\n")));
                    rv = BCM_E_NONE;
                } else {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                                          "##Change in  entry so Need to update##\n")));
                    rv = soc_mem_write(unit, ING_PHYSICAL_PORT_TABLEm,
                                       MEM_BLOCK_ALL, port, &ing_entry);
                }
                if (BCM_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                                          "Error: Encap Set: "
                                          "ING_PHYSICAL_PORT_TABLEm write failure")));
                    break;
                }
                rv = soc_mem_write(unit, EGR_PHYSICAL_PORTm,
                                   MEM_BLOCK_ALL, port, &egr_entry);
                if (BCM_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                                          "Error: Encap Set: "
                                          "EGR_PHYSICAL_PORTm write failure")));
                    break;
                }

#ifdef BCM_KATANA2_SUPPORT
                if (SOC_IS_KATANA2(unit )) {
                    rv =  _bcm_kt2_cosq_dynamic_port_encap_change(unit,port);
                    if (BCM_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                                 "Error: Encap Set: "
                                 "MMU config failure")));
                        break;
                    }
                }
#endif

            }while (0);
        }
    }
#endif

#if defined(BCM_XMAC_SUPPORT)
   if(SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA2(unit) ||
      SOC_IS_TRIDENT(unit) || SOC_IS_TITAN(unit)) {
       uint32          vco_disturbed = 0;
       phy_ctrl_t      *int_pc;
       if (soc_feature(unit, soc_feature_xmac) && (IS_HG_PORT(unit, port) ||
                   IS_XE_PORT(unit, port))) {

           int_pc = INT_PHY_SW_STATE(unit, port);
           rv = PHYCTRL_CONTROL_GET(int_pc, unit, port, SOC_PHY_CONTROL_VCO_DISTURBED, &vco_disturbed);
           if (!((rv == SOC_E_NONE) || (rv == SOC_E_UNAVAIL))) {
               _bcm_esw_port_mirror_unlock(unit);
               return rv;
           }
           if (vco_disturbed) {
               rv = _mac_x_reinit(unit, port);
               if (BCM_FAILURE(rv)) {
                   _bcm_esw_port_mirror_unlock(unit);
                   return rv;
               }
           }
       }
   }
#endif
    _bcm_esw_port_mirror_unlock(unit);

    return rv;
}


/*
 * Function:
 *      bcmi_esw_port_encap_validate
 * Purpose:
 *      Check if the encap change for this port can be acceptable or not.
 * Parameters:
 *      unit     - (IN) Unit number
 *      port     - (IN) Logical port number
 *      encap    - (IN) encap mode
 *      speed    - (IN) speed
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 * Notes:
 */
STATIC int
bcmi_esw_port_encap_validate(int unit, bcm_port_t port, int mode, int speed)
{
#ifdef BCM_XGS5_SWITCH_PORT_SUPPORT
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (BCM_ESW_PORT_DRV(unit)!= NULL) {
        if (BCM_ESW_PORT_DRV(unit)->encap_speed_check != NULL) {
            BCM_IF_ERROR_RETURN
                (BCM_ESW_PORT_DRV(unit)->encap_speed_check(unit, port,
                                                           mode, speed));
        }
    }
    return BCM_E_NONE;
#else
    return BCM_E_NONE;
#endif
}

STATIC int
_bcm_esw_port_encap_set(int unit, bcm_port_t port, int mode)
{
    int rv;
#if defined(BCM_TOMAHAWK2_SUPPORT)
    int asf_mode;
#endif /* BCM_TOMAHAWK2_SUPPORT */


#if defined(BCM_TOMAHAWK3_SUPPORT)
    if (SOC_IS_TOMAHAWK3(unit)) {
        return BCM_E_NONE;
    }
#endif /* BCM_TOMAHAWK3_SUPPORT */

#if defined(BCM_TOMAHAWK2_SUPPORT)
    if (SOC_IS_TOMAHAWK2(unit)) {
        BCM_IF_ERROR_RETURN(bcm_esw_port_asf_mode_get(unit, port, &asf_mode));
        if (asf_mode != _SOC_TH_ASF_MODE_SAF) {
            BCM_IF_ERROR_RETURN
                (bcm_esw_port_asf_mode_set(unit, port, _SOC_TH_ASF_MODE_SAF));
        }
    }
#endif /* BCM_TOMAHAWK2_SUPPORT */

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        rv = bcmi_esw_portctrl_encap_set(unit, port, mode, FALSE);
    } else {
        rv = bcmi_esw_port_encap_set(unit, port, mode);
    }

#if defined(BCM_TOMAHAWK2_SUPPORT)
    if (SOC_IS_TOMAHAWK2(unit)) {
        if (asf_mode != _SOC_TH_ASF_MODE_SAF) {
            BCM_IF_ERROR_RETURN
                (bcm_esw_port_asf_mode_set(unit, port, asf_mode));
        }
    }
#endif /* BCM_TOMAHAWK2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_port_encap_set
 * Purpose:
 *      Set the port encapsulation mode
 * Parameters:
 *      unit - StrataSwitch unit #
 *      port - StrataSwitch port #
 *      mode - One of BCM_PORT_ENCAP_xxx (see port.h)
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_encap_set(int unit, bcm_port_t port, int mode)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(bcmi_esw_port_encap_validate(unit, port, mode, 0));
    BCM_IF_ERROR_RETURN(_bcm_esw_port_encap_set(unit, port, mode));

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_encap_get
 * Purpose:
 *      Get the port encapsulation mode
 * Parameters:
 *      unit - StrataSwitch unit #
 *      port - StrataSwitch port #
 *      mode (OUT) - One of BCM_PORT_ENCAP_xxx (see port.h)
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_encap_get(int unit, bcm_port_t port, int *mode)
{

#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_KATANA_SUPPORT)
   int speed_mode = 0;
   uint64 rval64;
#endif

#if defined(BCM_KATANA2_SUPPORT)
   int max_phy_port = KT2_MAX_PHYSICAL_PORTS;
#endif

    *mode = -1;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return (bcmi_esw_portctrl_encap_get(unit, port, mode));
    }
    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }


#if defined(BCM_KATANA2_SUPPORT)
#if defined(BCM_SABER2_SUPPORT)
   if(SOC_IS_SABER2(unit)) {
       max_phy_port = SB2_MAX_PHYSICAL_PORTS;
   }
#endif
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(port)) &&
        (!((port >= 1) && (port <= max_phy_port)))) {
         return BCM_E_PORT;
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#if defined(BCM_ENDURO_SUPPORT) || defined(BCM_KATANA_SUPPORT)
    if (SOC_IS_ENDURO(unit) || SOC_IS_KATANAX(unit) ||
        SOC_IS_HURRICANE(unit) || SOC_IS_HURRICANE2(unit)) {
        if (IS_HL_PORT(unit, port)) {
            *mode = BCM_PORT_ENCAP_HIGIG2;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANAX(unit)) {
                if (SOC_REG_PORT_VALID(unit, XMAC_MODEr, port)) {
                    SOC_IF_ERROR_RETURN(READ_XMAC_MODEr(unit, port, &rval64));
                    speed_mode = soc_reg64_field32_get(unit, XMAC_MODEr, rval64,
                                                       SPEED_MODEf);

                } else if (SOC_REG_PORT_VALID(unit, XLMAC_MODEr, port)) {

                    SOC_IF_ERROR_RETURN(READ_XLMAC_MODEr(unit, port, &rval64));
                    speed_mode = soc_reg64_field32_get(unit, XLMAC_MODEr, rval64,
                                                       SPEED_MODEf);
                }
#if defined(BCM_METROLITE_SUPPORT)
                if (SOC_IS_METROLITE(unit)) {
                    /* 2.5G and 1G speed in HIGIG2_LITE */
                    if ((speed_mode == 3)||(speed_mode == 2)) {
                        *mode = BCM_PORT_ENCAP_HIGIG2_LITE;
                    }
                } else
#endif
                if (speed_mode == 3) {
                    *mode = BCM_PORT_ENCAP_HIGIG2_LITE;
                 }
             }
#endif
        } else {
            SOC_IF_ERROR_RETURN
                (MAC_ENCAP_GET(PORT(unit, port).p_mac, unit, port, mode));
        }
    } else
#endif  /* BCM_ENDURO_SUPPORT */
#ifdef BCM_GREYHOUND_SUPPORT
    if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
        SOC_IS_GREYHOUND2(unit)) {
        int     rv;
        uint32  hg2_mode = 0;

#if defined(BCM_HURRICANE3_SUPPORT)
        if (soc_feature(unit, soc_feature_wh2)) {
            return bcmi_wh2_port_encap_get(unit, port, mode);
        }
#endif /* BCM_HURRICANE3_SUPPORT */
        /* MAC encap can report the proper encap type but special setting
        * in port marcro for HG2-Lite case.
        *
        * For HG2-Lite condition :
        *   - in Port Macro(MAC is included in PM), the encap will be IEEE.
        *   - Out of Port Macro, the encap will be HG2
        */
        BCM_IF_ERROR_RETURN
                (MAC_ENCAP_GET(PORT(unit, port).p_mac, unit, port, mode));
        if (*mode == BCM_PORT_ENCAP_IEEE) {
#ifdef  BCM_GREYHOUND2_SUPPORT
            if (SOC_IS_GREYHOUND2(unit)) {
#ifdef BCM_FIRELIGHT_SUPPORT
                if (soc_feature(unit, soc_feature_fl)) {
                    rv = soc_firelight_pgw_encap_field_get(unit,
                            port, HIGIG2_MODEf, &hg2_mode);
                } else
#endif /* BCM_FIRELIGHT_SUPPORT */
                {
                    rv = soc_greyhound2_pgw_encap_field_get(unit,
                            port, HIGIG2_MODEf, &hg2_mode);
                }
            } else
#endif  /* GREYHOUDN2 */
            {
                /* only port in XLMAC allows PGW encap setting below */
                rv = soc_greyhound_pgw_encap_field_get(unit,
                        port, HIGIG2_MODEf, &hg2_mode);
             }

            if (BCM_SUCCESS(rv)){
                *mode = (hg2_mode) ? BCM_PORT_ENCAP_HIGIG2_LITE : *mode;
            } else if (rv != BCM_E_UNAVAIL) {
                /* BCM_E_UNAVAIL can be occurred on the port at QSGMII */
                return rv;
            }
        }
    } else
#endif  /* BCM_GREYHOUND_SUPPORT */
    if (IS_GE_PORT(unit, port) && IS_ST_PORT(unit, port)) {
        if (soc_feature(unit, soc_feature_embedded_higig)) {
            *mode = BCM_PORT_ENCAP_IEEE;
        } else {
            uint32 rval;
            soc_field_t hg_en[6] = {-1, HGIG2_EN_S0f, HGIG2_EN_S1f, -1,
                                    HGIG2_EN_S3f, HGIG2_EN_S4f};
           /* The port number check is for Coverity.  No port > 6 will
            * reach this logic on Raven. */
            if (SOC_IS_RAVEN(unit) && (port < 6)) {
                BCM_IF_ERROR_RETURN(READ_GPORT_CONFIGr(unit, port, &rval));

                if (SOC_REG_FIELD_VALID(unit, GPORT_CONFIGr, hg_en[port])) {
                    *mode = soc_reg_field_get(unit, GPORT_CONFIGr, rval,
                                              hg_en[port]) ?
                        BCM_PORT_ENCAP_HIGIG2 : BCM_PORT_ENCAP_IEEE;
                } else {
                    return (BCM_E_CONFIG);
                }
            }
        }
#if defined(BCM_TRIUMPH3_SUPPORT)
    } else if (SOC_IS_TRIUMPH3(unit) && IS_CE_PORT(unit, port)) {
        uint32 regval;
        BCM_IF_ERROR_RETURN(READ_PORT_CONFIGr(unit, port, &regval));
        if (soc_reg_field_get(unit, PORT_CONFIGr, regval, HIGIG2_MODEf)) {
          *mode = BCM_PORT_ENCAP_HIGIG2;
        } else if (soc_reg_field_get(unit, PORT_CONFIGr, regval, HIGIG_MODEf)) {
          *mode = BCM_PORT_ENCAP_HIGIG;
        } else {
           SOC_IF_ERROR_RETURN
                (MAC_ENCAP_GET(PORT(unit, port).p_mac, unit, port, mode));
        }
#endif
    } else {
        SOC_IF_ERROR_RETURN
            (MAC_ENCAP_GET(PORT(unit, port).p_mac, unit, port, mode));
    }

    if(*mode == -1) {
        /* Default : Return MAC encap mode */
        SOC_IF_ERROR_RETURN
            (MAC_ENCAP_GET(PORT(unit, port).p_mac, unit, port, mode));
    }

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_esw_port_encap_get: u=%d p=%d mode=%d\n"),
              unit, port, *mode));
    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_queued_count_get
 * Purpose:
 *      Returns the count of packets (or cells) currently buffered
 *      for a port.  Useful to know when a port has drained all
 *      data and can then be re-configured.
 * Parameters:
 *      unit - StrataSwitch unit #
 *      port - StrataSwitch port #
 *      count (OUT) - count of packets currently buffered
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      "packets" may actually be cells on most chips,
 *      If no packets are buffered, the cell count is 0,
 *      If some packets are buffered the cell count will be
 *      greater than or equal to the packet count.
 */

int
bcm_esw_port_queued_count_get(int unit, bcm_port_t port, uint32 *count)
{
    uint32      regval;
    int         cos;

    *count = 0;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (SOC_IS_FB_FX_HX(unit) || SOC_IS_HURRICANE2(unit) ||
        SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
        SOC_IS_GREYHOUND2(unit)) {
        for (cos = 0; cos < NUM_COS(unit); cos++) {
            regval = 0;
            SOC_IF_ERROR_RETURN(READ_COSLCCOUNTr(unit, port, cos, &regval));
            *count += soc_reg_field_get(unit, COSLCCOUNTr, regval, LCCOUNTf);
        }
        return BCM_E_NONE;
    }

#if defined(BCM_XGS12_FABRIC_SUPPORT)
    if (SOC_IS_XGS12_FABRIC(unit)) {
        regval = 0;
        SOC_IF_ERROR_RETURN(READ_MMU_CELLCNTTOTALr(unit, port, &regval));
        *count += soc_reg_field_get(unit, MMU_CELLCNTTOTALr, regval, COUNTf);
        return BCM_E_NONE;
    }
#endif /* BCM_XGS12_FABRIC_SUPPORT */

#if defined(BCM_BRADLEY_SUPPORT)
    if (SOC_IS_HBX(unit)) {
        regval = 0;
        SOC_IF_ERROR_RETURN(READ_OP_PORT_TOTAL_COUNTr(unit, port, &regval));
        *count += soc_reg_field_get(unit, OP_PORT_TOTAL_COUNTr,
                                    regval, OP_PORT_TOTAL_COUNTf);
        return BCM_E_NONE;
    }
#endif /* BCM_BRADLEY_SUPPORT  */

#if defined(BCM_TRIDENT_SUPPORT)
    if (SOC_IS_TD_TT(unit)) {
        return soc_egress_cell_count(unit, port, count);
    }
#endif /* BCM_TRIDENT_SUPPORT */

#if defined(BCM_TRIUMPH3_SUPPORT)
    if (SOC_IS_TRIUMPH3(unit)) {
        regval = 0;
        SOC_IF_ERROR_RETURN(READ_OP_PORT_TOTAL_COUNT_CELLr(unit, port, &regval));
        *count += soc_reg_field_get(unit, OP_PORT_TOTAL_COUNT_CELLr,
                                    regval, TOTAL_COUNTf);
        return BCM_E_NONE;
    }
#endif /* BCM_TRIUMPH3_SUPPORT  */

    return BCM_E_UNAVAIL;
}

    /*
 * Function:
 *      bcm_port_protocol_vlan_add
 * Purpose:
 *      Adds a protocol based vlan to a port.  The protocol
 *      is matched by frame type and ether type.  Returns an
 *      error if hardware does not support protocol vlans
 *      (Strata and Hercules).
 * Parameters:
 *      unit - StrataSwitch unit #
 *      port - StrataSwitch port #
 *      frame - one of BCM_PORT_FRAMETYPE_{ETHER2,8023,LLC}
 *      ether - 16 bit Ethernet type field
 *      vid - VLAN ID
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_protocol_vlan_add(int unit,
                           bcm_port_t port,
                           bcm_port_frametype_t frame,
                           bcm_port_ethertype_t ether,
                           bcm_vlan_t vid)
{
    int rv = BCM_E_UNAVAIL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
#ifdef  BCM_XGS_SWITCH_SUPPORT

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    PORT_SWITCHED_CHECK(unit, port);

    PORT_LOCK(unit);
#ifdef BCM_TRX_SUPPORT
    if (SOC_IS_TRX(unit)) {
        bcm_vlan_action_set_t action;

        if (!soc_feature(unit, soc_feature_vlan_action)) {
            PORT_UNLOCK(unit);
            return BCM_E_UNAVAIL;
        }

        bcm_vlan_action_set_t_init(&action);
        action.new_outer_vlan = vid;
        action.new_inner_vlan = 0;
        action.priority = PORT(unit, port).p_ut_prio;
        action.ut_outer = bcmVlanActionAdd;
        action.it_outer = bcmVlanActionAdd;
        action.it_inner = bcmVlanActionDelete;
        action.it_inner_prio = bcmVlanActionNone;
        action.ot_outer_prio = bcmVlanActionReplace;
        action.dt_outer_prio = bcmVlanActionReplace;

        rv = _bcm_trx_vlan_port_protocol_action_add(unit, port, frame,
                                                     ether, &action);
        PORT_UNLOCK(unit);
        return rv;
    }
#endif /* BCM_TRX_SUPPORT */

#if defined(BCM_FIREBOLT_SUPPORT)
    if (SOC_IS_FBX(unit)) {
        rv = _bcm_fb_port_protocol_vlan_add(unit, port, frame, ether, vid);
        PORT_UNLOCK(unit);
        return rv;
    }
#endif /* BCM_FIREBOLT_SUPPORT */
    PORT_UNLOCK(unit);
#endif /* BCM_XGS_SWITCH_SUPPORT */
    /* not supported on STRATA and HERCULES */
    return rv;
}

/*
 * Function:
 *      bcm_port_protocol_vlan_delete
 * Purpose:
 *      Remove an already created proto protocol based vlan
 *      on a port.
 * Parameters:
 *      unit - StrataSwitch unit #
 *      port - StrataSwitch port #
 *      frame - one of BCM_PORT_FRAMETYPE_{ETHER2,8023,LLC}
 *      ether - 16 bit Ethernet type field
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_protocol_vlan_delete(int unit,
                              bcm_port_t port,
                              bcm_port_frametype_t frame,
                              bcm_port_ethertype_t ether)
{
    int rv = BCM_E_UNAVAIL;
    /* Make sure port module is initialized. */
    PORT_INIT(unit);
#ifdef  BCM_XGS_SWITCH_SUPPORT
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    PORT_SWITCHED_CHECK(unit, port);

    PORT_LOCK(unit);

#ifdef BCM_TRX_SUPPORT
    if (SOC_IS_TRX(unit)) {
        if (!soc_feature(unit, soc_feature_vlan_action)) {
            PORT_UNLOCK(unit);
            return BCM_E_UNAVAIL;
        }
        rv = _bcm_trx_vlan_port_protocol_delete(unit, port, frame, ether);
        PORT_UNLOCK(unit);
        return rv;
    }
#endif /* BCM_TRX_SUPPORT */

#if defined(BCM_FIREBOLT_SUPPORT)
    if (SOC_IS_FBX(unit)) {
        rv = _bcm_fb_port_protocol_vlan_delete(unit, port, frame, ether);
        PORT_UNLOCK(unit);
        return rv;

    }
#endif /* BCM_FIREBOLT_SUPPORT */

    PORT_UNLOCK(unit);
#endif /* BCM_XGS_SWITCH_SUPPORT */
    /* not supported on STRATA and HERCULES */
    return rv;
}

/*
 * Function:
 *      bcm_port_protocol_vlan_delete_all
 * Purpose:
 *      Remove all protocol based vlans on a port.
 * Parameters:
 *      unit - StrataSwitch unit #
 *      port - StrataSwitch port #
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_protocol_vlan_delete_all(int unit, bcm_port_t port)
{
#ifdef  BCM_XGS_SWITCH_SUPPORT
    int         i;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    PORT_SWITCHED_CHECK(unit, port);

#ifdef BCM_TRX_SUPPORT
    if (SOC_IS_TRX(unit)) {
        int rv;
        if (!soc_feature(unit, soc_feature_vlan_action)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = _bcm_trx_vlan_port_protocol_delete_all(unit, port);
        PORT_UNLOCK(unit);
        return rv;
    }
#endif /* BCM_TRX_SUPPORT */

#if defined(BCM_FIREBOLT_SUPPORT)
    if (SOC_IS_FBX(unit)) {
        vlan_protocol_entry_t        vpe;
        vlan_protocol_data_entry_t   vde;
        bcm_vlan_t                   cvid, defvid;
        int                          idxmin, idxmax;
        int                          vlan_prot_entries;
        int                          vdentry, p, valid;
        _bcm_port_info_t             *pinfo;
        bcm_pbmp_t                   switched_pbm;

        idxmin = soc_mem_index_min(unit, VLAN_PROTOCOLm);
        idxmax = soc_mem_index_max(unit, VLAN_PROTOCOLm);
        vlan_prot_entries = idxmax + 1;

        for (i = idxmin; i <= idxmax; i++) {
            vdentry = (port * vlan_prot_entries) + i;
            SOC_IF_ERROR_RETURN
                (READ_VLAN_PROTOCOL_DATAm(unit, MEM_BLOCK_ANY,
                                          vdentry, &vde));
            cvid = soc_VLAN_PROTOCOL_DATAm_field32_get(unit, &vde, VLAN_IDf);
            BCM_IF_ERROR_RETURN
                (bcm_esw_port_untagged_vlan_get(unit, port, &defvid));
            BCM_IF_ERROR_RETURN(_bcm_port_info_get(unit, port, &pinfo));
            if (cvid == 0 ||
                (cvid == defvid && (!_BCM_PORT_VD_PBVL_IS_SET(pinfo, i)))) {
                continue;
            }
            sal_memset(&vde, 0, sizeof(vde));
            soc_VLAN_PROTOCOL_DATAm_field32_set(unit, &vde, VLAN_IDf, defvid);
            SOC_IF_ERROR_RETURN
                (WRITE_VLAN_PROTOCOL_DATAm(unit, MEM_BLOCK_ALL, vdentry, &vde));
            _BCM_PORT_VD_PBVL_CLEAR(pinfo, i);
            /*
             * see if any vlan_protocol_data entries are still valid
             * for the current protocol.
             */
            valid = 0;
            switched_pbm = PBMP_E_ALL(unit);
            if (soc_feature(unit, soc_feature_cpuport_switched)) {
                BCM_PBMP_OR(switched_pbm, PBMP_CMIC(unit));
            }

            BCM_PBMP_ITER(switched_pbm, p) {
                if (p == port) {    /* skip the entry we just "defaulted" */
                    continue;
                }
                BCM_IF_ERROR_RETURN(_bcm_port_info_get(unit, p, &pinfo));
                /* entry valid if programmed VLAN ID for port */
                if (_BCM_PORT_VD_PBVL_IS_SET(pinfo, i)) {
                    valid = 1;
                    break;
                }
            }
            if (!valid) {
                /*
                 * Clear all VLAN_PROTOCOL_DATA entries associated
                 * with this protocol.
                 */
                BCM_PBMP_ITER(switched_pbm, p) {
                    vdentry = (p * vlan_prot_entries) + i;
                    sal_memset(&vde, 0, sizeof(vde));
                    SOC_IF_ERROR_RETURN
                        (WRITE_VLAN_PROTOCOL_DATAm(unit, MEM_BLOCK_ALL,
                                                   vdentry, &vde));
                    BCM_IF_ERROR_RETURN(_bcm_port_info_get(unit, p, &pinfo));
                    _BCM_PORT_VD_PBVL_CLEAR(pinfo, i);
                }
                /* clear VLAN_PROTOCOL entry */
                sal_memset(&vpe, 0, sizeof(vpe));
                SOC_IF_ERROR_RETURN
                    (WRITE_VLAN_PROTOCOLm(unit, MEM_BLOCK_ALL, i, &vpe));
            }
        }
        return BCM_E_NONE;
    }
#endif /* BCM_FIREBOLT_SUPPORT */

#endif /* BCM_XGS_SWITCH_SUPPORT */

    /* not supported on STRATA and HERCULES */

    return BCM_E_UNAVAIL;
}

/*
 * Differentiated Services Code Point Mapping
 */

/*
 * Function:
 *      bcm_esw_port_dscp_map_mode_set
 * Purpose:
 *      Set DSCP mapping for the port.
 * Parameters:
 *      unit - switch device
 *      port - switch port      or -1 to apply on all the ports.
 *      mode - BCM_PORT_DSCP_MAP_NONE
 *           - BCM_PORT_DSCP_MAP_ZERO Map if incomming DSCP = 0
 *           - BCM_PORT_DSCP_MAP_ALL DSCP -> DSCP mapping.
 * Returns:
 *      BCM_E_XXX
 */
static int
_bcm_esw_port_dscp_map_mode_set(int unit, bcm_port_t port, int mode)
{
    bcm_port_cfg_t      pcfg;

    BCM_IF_ERROR_RETURN
        (mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg));
    if (pcfg.pc_dse_mode == -1) {       /* STRATA1 for example */
        return BCM_E_UNAVAIL;
    }
    switch (mode) {
        case BCM_PORT_DSCP_MAP_NONE:
            pcfg.pc_dse_mode = 0;
            pcfg.pc_dse_mode_ipv6 = 0;
#if defined(BCM_XGS_SWITCH_SUPPORT)
            pcfg.pc_dscp_prio = 0;
#endif /* BCM_XGS_SWITCH_SUPPORT */
            break;
        case BCM_PORT_DSCP_MAP_ZERO:
            if (soc_feature(unit, soc_feature_dscp_map_mode_all)) {
                return BCM_E_UNAVAIL;
            }
            pcfg.pc_dse_mode = 1;
#if defined(BCM_XGS_SWITCH_SUPPORT)
            pcfg.pc_dscp_prio = 1;
#endif /* BCM_XGS_SWITCH_SUPPORT */
            break;
        case BCM_PORT_DSCP_MAP_ALL:
            if (soc_feature(unit, soc_feature_dscp_map_mode_all)) {
                pcfg.pc_dse_mode = 1;
                pcfg.pc_dse_mode_ipv6 = 1;
            } else {
                pcfg.pc_dse_mode = 2;
            }
#if defined(BCM_XGS_SWITCH_SUPPORT)
            pcfg.pc_dscp_prio = 1;
#endif /* BCM_XGS_SWITCH_SUPPORT */
            break;
        case BCM_PORT_DSCP_MAP_IPV4_ONLY:
            if (!soc_feature(unit, soc_feature_dscp_map_mode_all)) {
                return BCM_E_UNAVAIL;
            }
            pcfg.pc_dse_mode = 1;
#if defined(BCM_XGS_SWITCH_SUPPORT)
            pcfg.pc_dscp_prio = 1;
#endif /* BCM_XGS_SWITCH_SUPPORT */
            break;
        case BCM_PORT_DSCP_MAP_IPV6_ONLY:
            if (!soc_feature(unit, soc_feature_dscp_map_mode_all)) {
                return BCM_E_UNAVAIL;
            }
            pcfg.pc_dse_mode_ipv6 = 1;
#if defined(BCM_XGS_SWITCH_SUPPORT)
            pcfg.pc_dscp_prio = 1;
#endif /* BCM_XGS_SWITCH_SUPPORT */
            break;
        case BCM_PORT_DSCP_MAP_IPV4_NONE:
            if (!soc_feature(unit, soc_feature_dscp_map_mode_all)) {
                return BCM_E_UNAVAIL;
            }
            pcfg.pc_dse_mode = 0;
#if defined(BCM_XGS_SWITCH_SUPPORT)
            if (!pcfg.pc_dse_mode_ipv6) {
                pcfg.pc_dscp_prio = 0;
            }
#endif /* BCM_XGS_SWITCH_SUPPORT */
            break;
        case BCM_PORT_DSCP_MAP_IPV6_NONE:
            if (!soc_feature(unit, soc_feature_dscp_map_mode_all)) {
                return BCM_E_UNAVAIL;
            }
            pcfg.pc_dse_mode_ipv6 = 0;
#if defined(BCM_XGS_SWITCH_SUPPORT)
            if (!pcfg.pc_dse_mode) {
                pcfg.pc_dscp_prio = 0;
            }
#endif /* BCM_XGS_SWITCH_SUPPORT */
            break;
        default:
            return BCM_E_PARAM;
    }
    BCM_IF_ERROR_RETURN
        (mbcm_driver[unit]->mbcm_port_cfg_set(unit, port, &pcfg));

    return BCM_E_NONE;
}

#if defined(BCM_TRIUMPH2_SUPPORT) && defined(INCLUDE_L3)
static int
_bcm_esw_vp_dscp_map_mode_set(int unit, bcm_gport_t port, int mode) {
    if (SOC_IS_KATANAX(unit) ||
        SOC_IS_TD_TT(unit)||
        soc_feature(unit, soc_feature_vp_dscp_map)) {
        return _bcm_tr2_vp_dscp_map_mode_set(unit, port, mode);
    }
    return BCM_E_UNAVAIL;
}

STATIC int
_bcm_esw_vp_dscp_map_set(int unit, bcm_gport_t port, int srccp, int mapcp,
                         int prio)
{
    if (SOC_IS_TD_TT(unit) || soc_feature(unit, soc_feature_vp_dscp_map)) {
        return _bcm_tr2_vp_dscp_map_set(unit, port, srccp, mapcp, prio);
    }
    return BCM_E_UNAVAIL;
}
#endif

int
bcm_esw_port_dscp_map_mode_set(int unit, bcm_port_t port, int mode)
{
    int rv;
    bcm_port_config_t port_conf;
    bcm_pbmp_t pbmp;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (!soc_feature(unit, soc_feature_dscp)) {
        return BCM_E_UNAVAIL;
    }

#if defined(BCM_TRIUMPH2_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_SET(port) && !BCM_GPORT_IS_MODPORT(port) &&
        !BCM_GPORT_IS_LOCAL(port) && !BCM_GPORT_IS_SUBPORT_PORT(port)) {
        return _bcm_esw_vp_dscp_map_mode_set(unit, port, mode);
    }
#endif

    if (port != -1) {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    }

    PORT_LOCK(unit);

    /* Get device port configuration. */
    rv = bcm_esw_port_config_get(unit, &port_conf);
    if (BCM_FAILURE(rv)) {
        PORT_UNLOCK(unit);
        return rv;
    }
    BCM_PBMP_ASSIGN(pbmp, port_conf.e);
    if (SOC_IS_XGS3_SWITCH(unit) || SOC_IS_XGS3_FABRIC(unit)) {
        BCM_PBMP_OR(pbmp, port_conf.cpu);
    }
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        rv = _bcm_kt2_flexio_pbmp_update(unit, &pbmp);
        if (BCM_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &pbmp);
    }
#endif

    if (port == -1) {
        PBMP_ITER(pbmp, port) {
            rv = _bcm_esw_port_dscp_map_mode_set(unit, port, mode);
            if (BCM_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return rv;
            }
        }
    } else {
        if (BCM_PBMP_MEMBER(pbmp, port)) {
            rv = _bcm_esw_port_dscp_map_mode_set(unit, port, mode);
        } else {
            rv = BCM_E_PORT;
        }
    }
    PORT_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_esw_port_dscp_map_mode_get
 * Purpose:
 *      DSCP mapping status for the port.
 * Parameters:
 *      unit - switch device
 *      port - switch port or -1 to get mode from first available port
 *      mode - (OUT)
 *           - BCM_PORT_DSCP_MAP_NONE
 *           - BCM_PORT_DSCP_MAP_ZERO Map if incomming DSCP = 0
 *           - BCM_PORT_DSCP_MAP_ALL DSCP -> DSCP mapping.
 * Returns:
 *      BCM_E_XXX
 */

static int
_bcm_esw_port_dscp_map_mode_get(int unit, bcm_port_t port, int *mode)
{
    bcm_port_cfg_t      pcfg;

    BCM_IF_ERROR_RETURN
        (mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg));
    if (pcfg.pc_dse_mode == -1) {       /* STRATA1 for example */
        return BCM_E_UNAVAIL;
    }
    switch (pcfg.pc_dse_mode) {
        case 1:
            if (soc_feature(unit, soc_feature_dscp_map_mode_all)) {
                if (pcfg.pc_dse_mode_ipv6) {
                    *mode = BCM_PORT_DSCP_MAP_ALL;
                } else {
                    *mode = BCM_PORT_DSCP_MAP_IPV4_ONLY;
                }
            } else {
                *mode = BCM_PORT_DSCP_MAP_ZERO;
            }
            break;
        case 2:
            if (soc_feature(unit, soc_feature_dscp_map_mode_all)) {
                if (pcfg.pc_dse_mode_ipv6) {
                    *mode = BCM_PORT_DSCP_MAP_ALL;
                } else {
                    *mode = BCM_PORT_DSCP_MAP_IPV4_ONLY;
                }
            } else {
                *mode = BCM_PORT_DSCP_MAP_ALL;
            }
            break;
        case 0:
            if (pcfg.pc_dse_mode_ipv6) {
                *mode = BCM_PORT_DSCP_MAP_IPV6_ONLY;
            } else {
                *mode = BCM_PORT_DSCP_MAP_NONE;
            }
            break;

        default:
            *mode = BCM_PORT_DSCP_MAP_NONE;
            break;
    }

    return BCM_E_NONE;
}

#if defined(BCM_TRIUMPH2_SUPPORT) && defined(INCLUDE_L3)
static int
_bcm_esw_vp_dscp_map_mode_get(int unit, bcm_gport_t port, int *mode) {
    if (SOC_IS_KATANAX(unit) ||
        SOC_IS_TD_TT(unit) ||
        soc_feature(unit, soc_feature_vp_dscp_map)) {
        return _bcm_tr2_vp_dscp_map_mode_get(unit, port, mode);
    }
    return BCM_E_UNAVAIL;
}

STATIC int
_bcm_esw_vp_dscp_map_get(int unit, bcm_gport_t port, int srccp, int *mapcp,
                         int *prio)
{
    if (SOC_IS_TD_TT(unit) || soc_feature(unit, soc_feature_vp_dscp_map)) {
        return _bcm_tr2_vp_dscp_map_get(unit, port, srccp, mapcp, prio);
    }
    return BCM_E_UNAVAIL;
}
#endif

int
bcm_esw_port_dscp_map_mode_get(int unit, bcm_port_t port, int *mode)
{
    int rv;
    bcm_port_config_t port_conf;
    bcm_pbmp_t pbmp;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (!soc_feature(unit, soc_feature_dscp)) {
        return BCM_E_UNAVAIL;
    }

#if defined(BCM_TRIUMPH2_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_SET(port) && !BCM_GPORT_IS_MODPORT(port) &&
        !BCM_GPORT_IS_LOCAL(port) && !BCM_GPORT_IS_SUBPORT_PORT(port)) {
        return _bcm_esw_vp_dscp_map_mode_get(unit, port, mode);
    }
#endif

    if (port != -1) {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    }

    PORT_LOCK(unit);

    /* Get device port configuration. */
    rv = bcm_esw_port_config_get(unit, &port_conf);
    if (BCM_FAILURE(rv)) {
        PORT_UNLOCK(unit);
        return rv;
    }
    BCM_PBMP_ASSIGN(pbmp, port_conf.e);
    if (SOC_IS_XGS3_SWITCH(unit) || SOC_IS_XGS3_FABRIC(unit)) {
        BCM_PBMP_OR(pbmp, port_conf.cpu);
    }
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        rv = _bcm_kt2_flexio_pbmp_update(unit, &pbmp);
        if (BCM_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &pbmp);
    }
#endif

    if (port == -1) {
        PBMP_ITER(pbmp, port) {
            break;
        }
    }

    /* coverity[overrun-local : FALSE] */
    if (BCM_PBMP_MEMBER(pbmp, port)) {
        rv = _bcm_esw_port_dscp_map_mode_get(unit, port, mode);
    } else {
        rv = BCM_E_PORT;
    }
    PORT_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      _bcm_port_dscp_map_set
 * Purpose:
 *      Internal implementation for bcm_port_dscp_map_set
 * Parameters:
 *      unit - switch device
 *      port - switch port or -1 for global table
 *      srccp - src code point or -1
 *      mapcp - mapped code point or -1
 *      prio - priority value for mapped code point
 *              -1 to use port default untagged priority
 *              BCM_PRIO_RED    can be or'ed into the priority
 *              BCM_PRIO_YELLOW can be or'ed into the priority
 * Returns:
 *      BCM_E_XXX
 */

STATIC int
_bcm_port_dscp_map_set(int unit, bcm_port_t port,
                       int srccp, int mapcp, int prio)
{
#define DSCP_CODE_POINT_CNT 64
#define DSCP_CODE_POINT_MAX (DSCP_CODE_POINT_CNT - 1)
    bcm_port_cfg_t      pcfg;

    if (mapcp < -1 || mapcp > DSCP_CODE_POINT_MAX) {
        return BCM_E_PARAM;
    }

#if defined(BCM_XGS3_SWITCH_SUPPORT)
    if (SOC_IS_XGS3_SWITCH(unit)) {
        int                  i, cng;
        dscp_table_entry_t   de;
        phb_mapping_tbl_2_entry_t  phb_tbl_2;
        int                  max_index;
        int                  min_index;
        int                  field_len;

        if (SOC_IS_TRIDENT3X(unit)) {
            field_len = soc_mem_field_length(unit, PHB_MAPPING_TBL_2m, INT_PRIf);
        } else {
            field_len = soc_mem_field_length(unit, DSCP_TABLEm, PRIf);
        }

        if (srccp < -1 || srccp > DSCP_CODE_POINT_MAX) {
            return BCM_E_PARAM;
        }
        /* Extract cng bits and check for valid priority. */
        
        cng = 0; /* Green */
        if (prio < BCM_PRIO_MIN) {
            return BCM_E_PARAM;
        }
        if (prio & BCM_PRIO_RED) {
            cng = 0x01;  /* Red */
            prio &= ~BCM_PRIO_RED;
        } else if (prio & BCM_PRIO_YELLOW) {
            cng = 0x03;  /* Yellow  */
            prio &= ~BCM_PRIO_YELLOW;
        }
        if ((prio & ~BCM_PRIO_MASK) != 0) {
            return BCM_E_PARAM;
        }
        if (prio >= (1 << field_len)) {
            return BCM_E_PARAM;
        }
        if (srccp < 0 && mapcp < 0) {
            /* No mapping */
            return BCM_E_NONE;
        } else if (srccp < 0) {
            /* Map all DSCPs to a new DSCP */
            /* fill all entries in DSCP_TABLEm with mapcp */

#ifdef BCM_TRIDENT2_SUPPORT
            if (SOC_IS_TD2_TT2(unit)) {
                return (bcm_td2_port_dscp_map_set(unit,
                    port, srccp, mapcp, prio, cng));
            }
#endif
#ifdef BCM_KATANA2_SUPPORT
            if (SOC_IS_KATANA2(unit)) {
                return (bcm_kt2_port_dscp_map_set(unit, port,
                    srccp, mapcp, prio, cng));
            }
#endif

            if (SOC_IS_TRIDENT3X(unit)) {
                sal_memset(&phb_tbl_2, 0, sizeof(phb_tbl_2));
                soc_PHB_MAPPING_TBL_2m_field32_set(unit, &phb_tbl_2, DSCPf, mapcp);
                soc_PHB_MAPPING_TBL_2m_field32_set(unit, &phb_tbl_2, INT_PRIf, prio);
                soc_PHB_MAPPING_TBL_2m_field32_set(unit, &phb_tbl_2, CNGf, cng);
            } else {
                sal_memset(&de, 0, sizeof(de));
                soc_DSCP_TABLEm_field32_set(unit, &de, DSCPf, mapcp);
                soc_DSCP_TABLEm_field32_set(unit, &de, PRIf, prio);
                soc_DSCP_TABLEm_field32_set(unit, &de, CNGf, cng);
            }
            if (soc_feature(unit, soc_feature_dscp_map_per_port)) {
                min_index = port * DSCP_CODE_POINT_CNT;
                max_index = min_index + DSCP_CODE_POINT_MAX;
            } else {
                if (SOC_IS_TRIDENT3X(unit)) {
                    max_index = soc_mem_index_max(unit, PHB_MAPPING_TBL_2m);
                } else {
                    max_index = soc_mem_index_max(unit, DSCP_TABLEm);
                }
                min_index = 0;
            }

            for (i = min_index; i <= max_index; i++) {
                if (SOC_IS_TRIDENT3X(unit)) {
                    SOC_IF_ERROR_RETURN
                    (WRITE_PHB_MAPPING_TBL_2m(unit, MEM_BLOCK_ALL, i, &phb_tbl_2));
                } else {
                    SOC_IF_ERROR_RETURN
                    (WRITE_DSCP_TABLEm(unit, MEM_BLOCK_ALL, i, &de));
                }
            }
        } else {
            int num_cosq;

#ifdef BCM_TRIDENT2_SUPPORT
            if (SOC_IS_TD2_TT2(unit)) {
                return (bcm_td2_port_dscp_map_set(unit, port,
                    srccp, mapcp, prio, cng));
            }
#endif
#ifdef BCM_KATANA2_SUPPORT
            if (SOC_IS_KATANA2(unit)) {
                return (bcm_kt2_port_dscp_map_set(unit, port,
                    srccp, mapcp, prio, cng));
            }
#endif

            num_cosq = 1; /* For all cosqs */
            /* Map a specific DSCP to a new DSCP */
            sal_memset(&de, 0, sizeof(de));
            /* fill specific srccp entry/entries in DSCP_TABLEm with mapcp */
            if (SOC_IS_TRIDENT3X(unit)) {
                soc_PHB_MAPPING_TBL_2m_field32_set(unit, &phb_tbl_2, DSCPf, mapcp);
                soc_PHB_MAPPING_TBL_2m_field32_set(unit, &phb_tbl_2, INT_PRIf, prio);
                soc_PHB_MAPPING_TBL_2m_field32_set(unit, &phb_tbl_2, CNGf, cng);
            } else {
                soc_DSCP_TABLEm_field32_set(unit, &de, DSCPf, mapcp);
                soc_DSCP_TABLEm_field32_set(unit, &de, PRIf, prio);
                soc_DSCP_TABLEm_field32_set(unit, &de, CNGf, cng);
            }

            if (soc_feature(unit, soc_feature_dscp_map_per_port)) {
                if (SOC_IS_TRIDENT3X(unit)) {
                    SOC_IF_ERROR_RETURN
                      (WRITE_PHB_MAPPING_TBL_2m(unit, MEM_BLOCK_ALL,
                                         (port * DSCP_CODE_POINT_CNT) + srccp, &phb_tbl_2));
                } else {
                    SOC_IF_ERROR_RETURN
                      (WRITE_DSCP_TABLEm(unit, MEM_BLOCK_ALL,
                                         (port * DSCP_CODE_POINT_CNT) + srccp, &de));
                }

            } else {
                for (i = 0; i < num_cosq ; i++) {
                    if (SOC_IS_TRIDENT3X(unit)) {
                        SOC_IF_ERROR_RETURN
                          (WRITE_PHB_MAPPING_TBL_2m(unit, MEM_BLOCK_ALL,
                                         (i * DSCP_CODE_POINT_CNT) + srccp, &phb_tbl_2));
                    } else {
                        SOC_IF_ERROR_RETURN
                          (WRITE_DSCP_TABLEm(unit, MEM_BLOCK_ALL,
                                         (i * DSCP_CODE_POINT_CNT) + srccp, &de));
                    }
                }
            }
        }
        return BCM_E_NONE;
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT */

    /* all other switches */
    if (srccp < -1 || srccp > 0) {
        return BCM_E_PARAM;
    }

    pcfg.pc_dse_mode = -1;
    BCM_IF_ERROR_RETURN
        (mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg));
    if (pcfg.pc_dse_mode == -1) {       /* STRATA1 for example */
        return BCM_E_UNAVAIL;
    }

    if (mapcp >= 0) {
        pcfg.pc_dscp = mapcp;

        BCM_IF_ERROR_RETURN
            (mbcm_driver[unit]->mbcm_port_cfg_set(unit, port, &pcfg));
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_dscp_map_set
 * Purpose:
 *      Define a mapping for diffserv code points
 *      The mapping enable/disable is controlled by a seperate API
 *      bcm_port_dscp_map_enable_set/get
 *      Also Enable/Disable control for DSCP mapping for tunnels
 *      are available in the respective tunnel create APIs.
 * Parameters:
 *      unit - switch device
 *      port - switch port      or -1 to setup global mapping table.
 *      srccp - src code point or -1
 *      mapcp - mapped code point or -1
 *      prio - priority value for mapped code point
 *              -1 to use port default untagged priority
 *              BCM_PRIO_DROP_FIRST can be or'ed into the priority
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      On most xgs switches there are a limited set
 *      of mappings that are possible:
 *              srccp -1, mapcp -1:     no mapping
 *              srccp -1, mapcp 0..63:  map all packets
 *              srccp 0, mapcp 0..63:   map packets with cp 0
 *      On Firebolt/Helix/Felix, there is no per port mapping table.
 *      Only a global mapping table is available.
 */

int
bcm_esw_port_dscp_map_set(int unit, bcm_port_t port, int srccp, int mapcp,
                      int prio)
{
    int rv;
    bcm_port_config_t port_conf;
    bcm_pbmp_t pbmp;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (!soc_feature(unit, soc_feature_dscp)) {
        return BCM_E_UNAVAIL;
    }

#if defined(BCM_TRIUMPH2_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_SET(port) && !BCM_GPORT_IS_MODPORT(port) &&
        !BCM_GPORT_IS_LOCAL(port) && !BCM_GPORT_IS_SUBPORT_PORT(port)) {
        return _bcm_esw_vp_dscp_map_set(unit, port, srccp, mapcp, prio);
    }
#endif

    if (port != -1) {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
        if (!soc_feature(unit, soc_feature_dscp_map_per_port)) {
            return BCM_E_PORT;
        }
    }

    PORT_LOCK(unit);

    /* Get device port configuration. */
    rv = bcm_esw_port_config_get(unit, &port_conf);
    if (BCM_FAILURE(rv)) {
        PORT_UNLOCK(unit);
        return rv;
    }
    BCM_PBMP_ASSIGN(pbmp, port_conf.e);
    if (SOC_IS_XGS3_SWITCH(unit) || SOC_IS_XGS3_FABRIC(unit)) {
        BCM_PBMP_OR(pbmp, port_conf.cpu);
    }
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        rv = _bcm_kt2_flexio_pbmp_update(unit, &pbmp);
        if (BCM_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &pbmp);
    }
#endif

    if ((port == -1) && (soc_feature(unit, soc_feature_dscp_map_per_port))) {
        PBMP_ITER(pbmp, port) {
            /* coverity[stack_use_callee] */
            /* coverity[stack_use_overflow] */
            rv = _bcm_port_dscp_map_set(unit, port, srccp, mapcp, prio);
            if (BCM_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return rv;
            }
        }
    } else {
        if (BCM_PBMP_MEMBER(pbmp, port) || (port == -1)) {
            rv = _bcm_port_dscp_map_set(unit, port, srccp, mapcp, prio);
        } else {
            rv = BCM_E_PORT;
        }
    }
    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      _bcm_port_dscp_map_get
 * Purpose:
 *      Get a mapping for diffserv code points
 * Parameters:
 *      unit - switch device
 *      port - switch port
 *      srccp - src code point or -1
 *      mapcp - (OUT) pointer to returned mapped code point
 *      prio - (OUT) Priority value for mapped code point or -1
 *                      May have BCM_PRIO_DROP_FIRST or'ed into it
 * Returns:
 *      BCM_E_XXX
 */

STATIC int
_bcm_esw_port_dscp_map_get(int unit, bcm_port_t port, int srccp, int *mapcp,
                      int *prio)
{
    bcm_port_cfg_t      pcfg;
    port_tab_entry_t    pent;
#if defined(BCM_XGS3_SWITCH_SUPPORT)
    int                      index = 0;
#endif /* BCM_XGS3_SWITCH_SUPPORT */
    int                      rv = BCM_E_NONE;

    if (SOC_IS_TRIDENT3X(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_tab_get(unit, port,
                            TRUST_DSCP_PTRf, &index));
    } else if (SOC_IS_TD2_TT2(unit) || SOC_IS_KATANA2(unit)) {
        /* Get profile index from port table. */
        rv = soc_mem_read(unit, PORT_TABm, MEM_BLOCK_ANY,
                          port, &pent);
        if (BCM_FAILURE(rv)) {
            return rv;
        }

#if defined(BCM_XGS3_SWITCH_SUPPORT)
        index = soc_mem_field32_get(unit, PORT_TABm, &pent, TRUST_DSCP_PTRf);
#endif /* BCM_XGS3_SWITCH_SUPPORT */
    }

    if (srccp < -1 || srccp > DSCP_CODE_POINT_MAX ||
        mapcp == NULL || prio == NULL) {
        return BCM_E_PARAM;
    }

#if defined(BCM_XGS3_SWITCH_SUPPORT)
    if (SOC_IS_XGS3_SWITCH(unit)) {
        int                     base;
        int                     cng;
        dscp_table_entry_t      de;
        phb_mapping_tbl_2_entry_t phb_tbl_2;

        /* look up in DSCP_TABLEm */
        if (srccp < 0) {
            srccp = 0;
        }
        if (soc_feature(unit, soc_feature_dscp_map_per_port)) {
            base = (port * DSCP_CODE_POINT_CNT);

            if (SOC_IS_TD2_TT2(unit) || SOC_IS_KATANA2(unit)) {
                base = (index * DSCP_CODE_POINT_CNT);
            }
        } else {
            base = 0;
        }

        if (SOC_IS_TRIDENT3X(unit)) {
            SOC_IF_ERROR_RETURN
                (READ_PHB_MAPPING_TBL_2m(unit, MEM_BLOCK_ANY, base + srccp, &phb_tbl_2));
            *mapcp = soc_PHB_MAPPING_TBL_2m_field32_get(unit, &phb_tbl_2, DSCPf);
            *prio = soc_PHB_MAPPING_TBL_2m_field32_get(unit, &phb_tbl_2, INT_PRIf);

             cng   = soc_PHB_MAPPING_TBL_2m_field32_get(unit, &phb_tbl_2, CNGf);
        } else {
            SOC_IF_ERROR_RETURN
                (READ_DSCP_TABLEm(unit, MEM_BLOCK_ANY, base + srccp, &de));
            *mapcp = soc_DSCP_TABLEm_field32_get(unit, &de, DSCPf);
            *prio = soc_DSCP_TABLEm_field32_get(unit, &de, PRIf);

            cng   = soc_DSCP_TABLEm_field32_get(unit, &de, CNGf);
        }
        if (cng == 1) {
            *prio |= BCM_PRIO_RED;
        } else if (cng == 3) {
            *prio |= BCM_PRIO_YELLOW;
        } else if (cng != 0) {
            *prio |= BCM_PRIO_DROP_FIRST;
        }

        return BCM_E_NONE;
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT */

    /* all other switches */

    pcfg.pc_dse_mode = -1;
    BCM_IF_ERROR_RETURN
        (mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &pcfg));
    if (pcfg.pc_dse_mode == -1) {       /* STRATA1 for example */
        return BCM_E_UNAVAIL;
    }

    /*
     * The mapping table is set independently of the mapping mode.
     * So the _get API will return the mapping table setup and not
     * necessarily the actual mapping that will be applied to the packet.
     * The mapping applied to the packet is determined by mapping mode
     * set using bcm_port_dscp_map_mode_set
     */
    *mapcp = pcfg.pc_dscp;

    *prio = -1;

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_dscp_map_get
 * Purpose:
 *      Get a mapping for diffserv code points
 * Parameters:
 *      unit - switch device
 *      port - switch port
 *      srccp - src code point or -1
 *      mapcp - (OUT) pointer to returned mapped code point
 *      prio - (OUT) Priority value for mapped code point or -1
 *                      May have BCM_PRIO_DROP_FIRST or'ed into it
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_dscp_map_get(int unit, bcm_port_t port, int srccp, int *mapcp,
                      int *prio)
{
    int rv;
    bcm_port_config_t port_conf;
    bcm_pbmp_t pbmp;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (!soc_feature(unit, soc_feature_dscp)) {
        return BCM_E_UNAVAIL;
    }

#if defined(BCM_TRIUMPH2_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_SET(port) && !BCM_GPORT_IS_MODPORT(port) &&
        !BCM_GPORT_IS_LOCAL(port) && !BCM_GPORT_IS_SUBPORT_PORT(port)) {
        return _bcm_esw_vp_dscp_map_get(unit, port, srccp, mapcp, prio);
    }
#endif

    if (port != -1) {
        if (0 == soc_feature(unit, soc_feature_dscp_map_per_port)) {
            return BCM_E_PORT;
        }
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    }

    PORT_LOCK(unit);

    /* Get device port configuration. */
    rv = bcm_esw_port_config_get(unit, &port_conf);
    if (BCM_FAILURE(rv)) {
        PORT_UNLOCK(unit);
        return rv;
    }
    BCM_PBMP_ASSIGN(pbmp, port_conf.e);
    if (SOC_IS_XGS3_SWITCH(unit) || SOC_IS_XGS3_FABRIC(unit)) {
        BCM_PBMP_OR(pbmp, port_conf.cpu);
    }
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        rv = _bcm_kt2_flexio_pbmp_update(unit, &pbmp);
        if (BCM_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &pbmp);
    }
#endif

    if (port == -1) {
        PBMP_ITER(pbmp, port) {
            break;
        }
    }

    if (SOC_PORT_VALID(unit, port) && BCM_PBMP_MEMBER(pbmp, port)) {
        rv = _bcm_esw_port_dscp_map_get(unit, port, srccp, mapcp, prio);
    } else {
        rv = BCM_E_PORT;
    }

    PORT_UNLOCK(unit);
    return rv;
}

#ifdef BCM_TRIDENT_SUPPORT
STATIC int
_bcm_td_egr_l3_intf_dscp_map_update(int unit, uint32 dscp_map_id, uint32 new_dscp_map_id)
{
    char *egr_intf_tbl_ptr = NULL;   /* EGR_L3_INTF dma table pointer.  */
    int rv;
    uint32 *egr_intf_entry_ptr;        /* EGR_L3_INTF entry pointer. */
    int ifindex;
    uint32 dscp_map_ptr;
    int tbl_size;
    int alloc_size;

    if (dscp_map_id == new_dscp_map_id) {
        return BCM_E_NONE;
    }

    /* Calculate table size. */
    tbl_size =  soc_mem_index_count(unit, EGR_L3_INTFm);
    if (!tbl_size) {
        return (BCM_E_NOT_FOUND);
    }
    alloc_size = sizeof(egr_l3_intf_entry_t) * tbl_size;

    /* Allocate memory buffer. */
    egr_intf_tbl_ptr = soc_cm_salloc(unit, alloc_size, "egr_l3_intf_tbl");
    if (egr_intf_tbl_ptr == NULL) {
        return (BCM_E_MEMORY);
    }

    /* Reset allocated buffer. */
    sal_memset(egr_intf_tbl_ptr, 0, alloc_size);

    /* Read table to the buffer. */
    rv = soc_mem_read_range(unit, EGR_L3_INTFm, MEM_BLOCK_ANY,
                            soc_mem_index_min(unit, EGR_L3_INTFm),
                            soc_mem_index_max(unit, EGR_L3_INTFm), egr_intf_tbl_ptr);
    if (BCM_FAILURE(rv)) {
        goto cleanup;
    }
    for (ifindex = 0; ifindex < tbl_size; ifindex++) {
        egr_intf_entry_ptr =
        soc_mem_table_idx_to_pointer(unit, EGR_L3_INTFm,
                                     uint32 *, egr_intf_tbl_ptr,
                                     ifindex);
        dscp_map_ptr = soc_mem_field32_get(unit, EGR_L3_INTFm,
                                           egr_intf_entry_ptr, DSCP_MAPPING_PTRf);
        if (dscp_map_ptr == dscp_map_id) {

            soc_mem_field32_set(unit, EGR_L3_INTFm,
                                egr_intf_entry_ptr, DSCP_MAPPING_PTRf,
                                new_dscp_map_id);
        }
    }
    rv = soc_mem_write_range(unit, EGR_L3_INTFm, MEM_BLOCK_ALL,
                             soc_mem_index_min(unit, EGR_L3_INTFm),
                             soc_mem_index_max(unit, EGR_L3_INTFm),
                             egr_intf_tbl_ptr);
    if (SOC_FAILURE(rv)) {
        goto cleanup;
    }

    _bcm_tr2_qos_id_update(unit, dscp_map_id, new_dscp_map_id);

cleanup:

    if (egr_intf_tbl_ptr) {
        soc_cm_sfree(unit, egr_intf_tbl_ptr);
    }
    return rv;

}
#endif

/*
 * Function:
 *      _bcm_port_dscp_unmap_set
 * Purpose:
 *      Internal implementation for bcm_port_dscp_unmap_set
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_port_dscp_unmap_set(int unit, bcm_port_t port, int internal_pri,
                         bcm_color_t color, int pkt_dscp)
{
    int index, port_shift = 6;
    egr_dscp_table_entry_t  dscp_unmap;
    egr_zone_4_qos_mapping_table_entry_t z4_qos_unmap;
#if defined(BCM_TRIDENT_SUPPORT)
    egr_dscp_table_entry_t egr_dscp_map_entries[64];
    void *entries[1];
    uint32 dscp_index = 0;
    uint32 new_dscp_index;
    int ref_count;
    void *entry;
    int port_dscp_map_set;
    int old_pkt_dscp;
#endif
    if (pkt_dscp < 0 || pkt_dscp > DSCP_CODE_POINT_MAX) {
        return BCM_E_PARAM;
    }
    if ((internal_pri < 0) || (internal_pri > 15) ||
        ((color != bcmColorGreen) && (color != bcmColorYellow) &&
         (color != bcmColorRed))) {
        return BCM_E_PARAM;
    }

    /* EGR_DSCP_TABLE table is indexed with
     * port[5:0] priority[3:0] CNG [1:0]
     */

    index = (port << port_shift) | (internal_pri << 2) |
         _BCM_COLOR_ENCODING(unit, color);

    if (SOC_IS_TRIDENT3X(unit)) {
        /* This function is obselete - put in the right register for readability*/
        sal_memset(&z4_qos_unmap, 0, sizeof(z4_qos_unmap));
        soc_mem_field32_set(unit, EGR_ZONE_4_QOS_MAPPING_TABLEm, &z4_qos_unmap, QOSf, pkt_dscp);
        SOC_IF_ERROR_RETURN
        (WRITE_EGR_ZONE_4_QOS_MAPPING_TABLEm(unit, MEM_BLOCK_ALL, index, &z4_qos_unmap));

        soc_mem_field32_set(unit, EGR_ZONE_2_QOS_MAPPING_TABLEm, &z4_qos_unmap, QOSf, pkt_dscp);
        SOC_IF_ERROR_RETURN
        (WRITE_EGR_ZONE_2_QOS_MAPPING_TABLEm(unit, MEM_BLOCK_ALL, index, &z4_qos_unmap));
    } else
#ifdef BCM_TRIDENT_SUPPORT
    if (SOC_MEM_FIELD_VALID(unit, EGR_L3_INTFm, OPRI_OCFI_SELf)) {
        dscp_index = port << port_shift;
        index = (internal_pri << 2) | _BCM_COLOR_ENCODING(unit, color);

        sal_memset(egr_dscp_map_entries, 0, sizeof(egr_dscp_map_entries));
        entries[0] = &egr_dscp_map_entries;

        entry = &egr_dscp_map_entries[index];
        BCM_IF_ERROR_RETURN(
            _bcm_egr_dscp_table_entry_ref_count_get(unit, dscp_index, &ref_count));
        port_dscp_map_set = PORT(unit, port).port_dscp_map_set;
        if (ref_count > 0) {
            BCM_IF_ERROR_RETURN(
                _bcm_egr_dscp_table_entry_get(unit, dscp_index,
                                              _BCM_QOS_MAP_CHUNK_EGR_DSCP, entries));
            old_pkt_dscp = soc_mem_field32_get(unit, EGR_DSCP_TABLEm, entry, DSCPf);
            if (pkt_dscp != old_pkt_dscp) {
                int i;
                int port_dscp_map_count = port_dscp_map_set;
                /* If this profile is only used by port */
                if ((ref_count == 1) && (port_dscp_map_set == 1)) {
                    soc_mem_field32_set(unit, EGR_DSCP_TABLEm, entry, DSCPf, pkt_dscp);
                    BCM_IF_ERROR_RETURN(
                        _bcm_egr_dscp_table_entry_set(unit, entries, dscp_index));
                    BCM_IF_ERROR_RETURN(
                        _bcm_egr_dscp_table_entry_delete(unit, dscp_index));
                } else { /* If this profile is used not only by port */
                    soc_mem_field32_set(unit, EGR_DSCP_TABLEm, entry, DSCPf,
                                        old_pkt_dscp);
                    BCM_IF_ERROR_RETURN(
                        _bcm_egr_dscp_table_entry_add(unit, entries,
                                                      _BCM_QOS_MAP_CHUNK_EGR_DSCP,
                                                      &new_dscp_index,
                                                      SOC_PROFILE_MEM_F_NO_SHARE));
                    for (i = 0; i < (ref_count - port_dscp_map_count - 1); i++) {
                        BCM_IF_ERROR_RETURN(
                            _bcm_egr_dscp_table_entry_reference(unit, new_dscp_index,
                                                                _BCM_QOS_MAP_CHUNK_EGR_DSCP));
                    }
                    BCM_IF_ERROR_RETURN(
                        _bcm_td_egr_l3_intf_dscp_map_update(unit, port,
                                                            (new_dscp_index >> port_shift)));
                    soc_mem_field32_set(unit, EGR_DSCP_TABLEm, entry, DSCPf, pkt_dscp);
                    BCM_IF_ERROR_RETURN(
                        _bcm_egr_dscp_table_entry_set(unit, entries, dscp_index));
                    for (i = 0; i < ref_count; i++) {
                        BCM_IF_ERROR_RETURN(
                            _bcm_egr_dscp_table_entry_delete(unit, dscp_index));
                    }
                }
            }
        } else {
            soc_mem_field32_set(unit, EGR_DSCP_TABLEm, entry, DSCPf, pkt_dscp);
            _bcm_common_profile_mem_ref_cnt_update(unit, EGR_DSCP_TABLEm, port, 1);
            BCM_IF_ERROR_RETURN(
                _bcm_egr_dscp_table_entry_set(unit, entries, dscp_index));
            BCM_IF_ERROR_RETURN(
                _bcm_egr_dscp_table_entry_delete(unit, dscp_index));
        }
        PORT(unit, port).port_dscp_map_set = 1;

    } else
#endif
    {
        sal_memset(&dscp_unmap, 0, sizeof(dscp_unmap));
        soc_mem_field32_set(unit, EGR_DSCP_TABLEm, &dscp_unmap, DSCPf, pkt_dscp);
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_DSCP_TABLEm(unit, MEM_BLOCK_ALL, index, &dscp_unmap));
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_dscp_unmap_set
 * Purpose:
 *      Define a mapping for diffserv code points
 *      The mapping enable/disable is controlled by a seperate API
 *      bcm_port_dscp_map_enable_set/get
 *      Also Enable/Disable control for DSCP mapping for tunnels
 *      are available in the respective tunnel create APIs.
 * Parameters:
 *      unit - switch device
 *      port - switch port      or -1 to setup global mapping table.
 *      internal_pri - internal priority
 *      color - Red/Yellow/Green
 *      pkt_dscp - DSCP marking on outgoing packet
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_dscp_unmap_set(int unit, bcm_port_t port, int internal_pri,
                            bcm_color_t color, int pkt_dscp)
{
    int rv;
    bcm_port_config_t port_conf;
    bcm_pbmp_t pbmp;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    if (!soc_feature(unit, soc_feature_dscp) ||
        !soc_feature(unit, soc_feature_egr_dscp_map_per_port)) {
        return BCM_E_UNAVAIL;
    }

    if (port != -1) {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
        if (IS_HG_PORT(unit, port) || IS_ST_PORT(unit, port)) {
            return BCM_E_PORT;
        }
    }

    PORT_LOCK(unit);

    /* Get device port configuration. */
    rv = bcm_esw_port_config_get(unit, &port_conf);
    if (BCM_FAILURE(rv)) {
        PORT_UNLOCK(unit);
        return rv;
    }
    BCM_PBMP_ASSIGN(pbmp, port_conf.e);
    BCM_PBMP_OR(pbmp, port_conf.cpu);
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        rv = _bcm_kt2_flexio_pbmp_update(unit, &pbmp);
        if (BCM_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &pbmp);
    }
#endif

    if (port == -1) {
        PBMP_ITER(pbmp, port) {
            rv = _bcm_port_dscp_unmap_set(unit, port, internal_pri, color,
                                          pkt_dscp);
            if (BCM_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return rv;
            }
        }
    } else if (SOC_PORT_VALID(unit, port) && BCM_PBMP_MEMBER(pbmp, port)) {
        rv = _bcm_port_dscp_unmap_set(unit, port, internal_pri, color,
                                      pkt_dscp);
    } else {
        rv = BCM_E_PORT;
    }
    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      _bcm_port_dscp_unmap_get
 * Purpose:
 *      Internal implementation for bcm_port_dscp_unmap_get
 * Returns:
 *      BCM_E_XXX
 */
STATIC int
_bcm_port_dscp_unmap_get(int unit, bcm_port_t port, int internal_pri,
                         bcm_color_t color, int *pkt_dscp)
{
    int index, port_shift = 6;
    egr_dscp_table_entry_t  dscp_unmap;
#if defined(BCM_TRIDENT_SUPPORT)
    egr_dscp_table_entry_t egr_dscp_map_entries[64];
    void *entries[1];
    uint32 dscp_index = 0;
    void *entry;
#endif
    if ((internal_pri < 0) || (internal_pri > 15) ||
        ((color != bcmColorGreen) && (color != bcmColorYellow) &&
         (color != bcmColorRed))) {
        return BCM_E_PARAM;
    }

    /* EGR_DSCP_TABLE table is indexed with
     * port[5:0] priority[3:0] CNG [1:0]
     */
    index = (port << port_shift) | (internal_pri << 2) |
                 _BCM_COLOR_ENCODING(unit, color);

    if (SOC_IS_TRIDENT3X(unit)) {
        SOC_IF_ERROR_RETURN
        (READ_EGR_ZONE_4_QOS_MAPPING_TABLEm(unit, MEM_BLOCK_ANY, index, &dscp_unmap));
        *pkt_dscp = soc_mem_field32_get(unit, EGR_ZONE_4_QOS_MAPPING_TABLEm,
                                        &dscp_unmap, QOSf);

        SOC_IF_ERROR_RETURN
        (READ_EGR_ZONE_2_QOS_MAPPING_TABLEm(unit, MEM_BLOCK_ANY, index, &dscp_unmap));
        *pkt_dscp = soc_mem_field32_get(unit, EGR_ZONE_2_QOS_MAPPING_TABLEm,
                                        &dscp_unmap, QOSf);
    } else
#if defined(BCM_TRIDENT_SUPPORT)
    if (SOC_MEM_FIELD_VALID(unit, EGR_L3_INTFm, OPRI_OCFI_SELf)) {
        dscp_index = port << port_shift;
        index = (internal_pri << 2) | _BCM_COLOR_ENCODING(unit, color);

        sal_memset(egr_dscp_map_entries, 0, sizeof(egr_dscp_map_entries));
        entries[0] = &egr_dscp_map_entries;

        BCM_IF_ERROR_RETURN(
            _bcm_egr_dscp_table_entry_get(unit, dscp_index,
                                          _BCM_QOS_MAP_CHUNK_EGR_DSCP, entries));
        entry = &egr_dscp_map_entries[index];
        *pkt_dscp = soc_mem_field32_get(unit, EGR_DSCP_TABLEm,
                                        entry, DSCPf);
    } else
#endif
    {
        SOC_IF_ERROR_RETURN
            (READ_EGR_DSCP_TABLEm(unit, MEM_BLOCK_ANY, index, &dscp_unmap));
        *pkt_dscp = soc_mem_field32_get(unit, EGR_DSCP_TABLEm,
                                        &dscp_unmap, DSCPf);
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_dscp_unmap_get
 * Purpose:
 *      Retrieve a mapping for diffserv code points
 *      The mapping enable/disable is controlled by a seperate API
 *      bcm_port_dscp_map_enable_set/get
 *      Also Enable/Disable control for DSCP mapping for tunnels
 *      are available in the respective tunnel create APIs.
 * Parameters:
 *      unit - switch device
 *      port - switch port.
 *      internal_pri - internal priority
 *      color - Red/Yellow/Green
 *      pkt_dscp - DSCP marking on outgoing packet
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_dscp_unmap_get(int unit, bcm_port_t port, int internal_pri,
                            bcm_color_t color, int *pkt_dscp)
{
    int rv;
    bcm_port_config_t port_conf;
    bcm_pbmp_t pbmp;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    if (!soc_feature(unit, soc_feature_dscp) ||
        !soc_feature(unit, soc_feature_egr_dscp_map_per_port)) {
        return BCM_E_UNAVAIL;
    }

    if (port != -1) {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
        if (IS_HG_PORT(unit, port) || IS_ST_PORT(unit, port)) {
            return BCM_E_PORT;
        }
    }

    PORT_LOCK(unit);

    /* Get device port configuration. */
    rv = bcm_esw_port_config_get(unit, &port_conf);
    if (BCM_FAILURE(rv)) {
        PORT_UNLOCK(unit);
        return rv;
    }
    BCM_PBMP_ASSIGN(pbmp, port_conf.e);
    BCM_PBMP_OR(pbmp, port_conf.cpu);
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_flex_port)) {
        rv = _bcm_kt2_flexio_pbmp_update(unit, &pbmp);
        if (BCM_FAILURE(rv)) {
            PORT_UNLOCK(unit);
            return (rv);
        }
    }
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update(unit, &pbmp);
    }
#endif

    if (port == -1) {
        PBMP_ITER(pbmp, port) {
            break;
        }
    }

    if (SOC_PORT_VALID(unit, port) && BCM_PBMP_MEMBER(pbmp, port)) {
        rv = _bcm_port_dscp_unmap_get(unit, port, internal_pri, color,
                                      pkt_dscp);
    } else {
        rv = BCM_E_PORT;
    }

    PORT_UNLOCK(unit);
    return rv;
}

#undef DSCP_CODE_POINT_MAX
#undef DSCP_CODE_POINT_CNT

STATIC int
_bcm_esw_port_modid_egress_resolve(int unit, _bcm_port_egr_dest_t *egr_dst)
{
    int             port_adjst = 0, mod_adjust = 0;
    int             isLocal = 0;
    bcm_module_t    my_mod, modid;

    if (BCM_GPORT_IS_SET(egr_dst->in_port)) {
        bcm_trunk_t     tid;
        int             id;
        bcm_port_t      port;

        BCM_IF_ERROR_RETURN(
            _bcm_esw_gport_resolve(unit, egr_dst->in_port, &modid, &port,
                                   &tid, &id));
        if ((-1 != id) || (-1 != tid)) {
            return BCM_E_PORT;
        }
        BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, &my_mod));
        BCM_IF_ERROR_RETURN(
            _bcm_esw_modid_is_local(unit, modid, &isLocal));

        if ((TRUE == isLocal) && (modid != my_mod)){
            port_adjst = 32;
            mod_adjust = 1;
        }
        egr_dst->out_min_port = egr_dst->out_max_port = port + port_adjst;
        egr_dst->out_min_modid = egr_dst->out_max_modid = modid - mod_adjust;
    } else {
        if (egr_dst->in_modid < 0) {
            egr_dst->out_min_modid = 0;
            egr_dst->out_max_modid = SOC_MODID_MAX(unit);
        } else if (!SOC_MODID_ADDRESSABLE(unit, egr_dst->in_modid)) {
            return BCM_E_PARAM;
        } else {
            egr_dst->out_min_modid = egr_dst->out_max_modid = egr_dst->in_modid;
        }

        if (egr_dst->in_port < 0) {
            egr_dst->out_min_port = 0;
            egr_dst->out_max_port = SOC_PORT_MAX(unit, all);
        } else if (!SOC_PORT_ADDRESSABLE(unit, egr_dst->in_port)) {
            return BCM_E_PORT;
        } else {
            egr_dst->out_min_port = egr_dst->out_max_port = egr_dst->in_port;
        }
    }

    return BCM_E_NONE;
}


/*
 * Function:
 *      bcm_port_egress_set
 * Description:
 *      Set switching only to indicated ports from given (modid, port).
 * Parameters:
 *      unit - StrataSwitch PCI device unit number (driver internal).
 *      port  - ingress port number.
 *      modid - source module ID index (in HiGig mod header).
 *      pbmp - bitmap of ports to allow egress.
 * Returns:
 *      BCM_E_xxxx
 * Note:
 *      if port < 0, means all/any port
 *      if modid < 0, means all/any modid
 */
int
bcm_esw_port_egress_set(int unit, bcm_port_t port, int modid, bcm_pbmp_t pbmp)
{
    egr_mask_entry_t        em_entry;
    int                     em_index;
    bcm_module_t            cur_mod, hw_mod;
    bcm_pbmp_t              em_pbmp;
    bcm_port_t              cur_port, hw_port;
    int                     rv = BCM_E_NONE;
    _bcm_port_egr_dest_t    egr_dst;
    int                     mod_is_local = 0;
    int                     mod_port_map_done = 0;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

#ifdef BCM_TRIDENT_SUPPORT
    if (SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANAX(unit)) {
        return bcm_td_port_egress_set(unit, port, modid, pbmp);
    }
#endif /* BCM_TRIDENT_SUPPORT */

#ifdef BCM_HURRICANE3_SUPPORT
    if (SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
        return bcm_hr3_port_egress_set(unit, port, modid, pbmp);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    if (!SOC_IS_XGS_SWITCH(unit)) {
        if (BCM_PBMP_EQ(pbmp, PBMP_ALL(unit))) {
            return BCM_E_NONE;
        } else {
            return BCM_E_UNAVAIL;
        }
    }

    sal_memset(&em_entry, 0, sizeof(egr_mask_entry_t));

    BCM_PBMP_NEGATE(em_pbmp, pbmp);
    BCM_PBMP_AND(em_pbmp, PBMP_ALL(unit));
    BCM_PBMP_REMOVE(em_pbmp, PBMP_LB(unit));
    soc_mem_pbmp_field_set(unit, EGR_MASKm, &em_entry, EGRESS_MASKf,
                           &em_pbmp);

    egr_dst.in_modid = modid;
    egr_dst.in_port = port;
    BCM_IF_ERROR_RETURN(_bcm_esw_port_modid_egress_resolve(unit, &egr_dst));
    /* If the given port is a gport, _bcm_esw_port_modid_egress_resolve had
     * already performed module and port mapping for devices with
     * multiple module IDs.
     */
    mod_port_map_done = BCM_GPORT_IS_SET(port) ? 1 : 0;

    soc_mem_lock(unit, EGR_MASKm);
    for (cur_mod = egr_dst.out_min_modid; cur_mod <= egr_dst.out_max_modid; cur_mod++) {
        rv = _bcm_esw_modid_is_local(unit, cur_mod, &mod_is_local);
        if (BCM_FAILURE(rv)) {
            break;
        }
        for (cur_port = egr_dst.out_min_port; cur_port <= egr_dst.out_max_port; cur_port++) {
            if (mod_is_local && (NUM_MODID(unit) > 1) && !mod_port_map_done) {
                if (cur_port <= SOC_MODPORT_MAX(unit)) {
                    rv = _bcm_esw_stk_modmap_map(unit, BCM_STK_MODMAP_SET,
                            cur_mod, cur_port, &hw_mod, &hw_port);
                    if (BCM_FAILURE(rv)) {
                        break;
                    }
                } else {
                    break;
                }
            } else {
                hw_mod = cur_mod;
                hw_port = cur_port;
            }

            em_index = (hw_mod & SOC_MODID_MAX(unit)) *
                    (SOC_PORT_ADDR_MAX(unit) + 1) |
                    (hw_port & SOC_PORT_ADDR_MAX(unit));
            rv = soc_mem_write(unit, EGR_MASKm, MEM_BLOCK_ALL,
                    em_index, &em_entry);
            if (!BCM_SUCCESS(rv)) {
                break;
            }
        }
        if (!BCM_SUCCESS(rv)) {
            break;
        }
    }
    soc_mem_unlock(unit, EGR_MASKm);

    return rv;
}

/*
 * Function:
 *      bcm_port_egress_get
 * Description:
 *      Retrieve bitmap of ports for which switching is enabled
 *      for (modid, port).
 * Parameters:
 *      unit - StrataSwitch PCI device unit number (driver internal).
 *      port  - ingress port number.
 *      modid - source module ID index (in HiGig mod header).
 *      pbmp - (OUT) bitmap of ports where egress allowed.
 * Returns:
 *      BCM_E_xxxx
 */
int
bcm_esw_port_egress_get(int unit, bcm_port_t port, int modid, bcm_pbmp_t *pbmp)
{
    egr_mask_entry_t    em_entry;
    int                 em_index;
    bcm_pbmp_t          em_pbmp, temp_pbmp;
    _bcm_port_egr_dest_t    egr_dst;
    int                 mod_port_map_done = 0;
    bcm_module_t        hw_mod;
    bcm_port_t          hw_port;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

#ifdef BCM_TRIDENT_SUPPORT
    if (SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANAX(unit)) {
        return bcm_td_port_egress_get(unit, port, modid, pbmp);
    }
#endif /* BCM_TRIDENT_SUPPORT */

#ifdef BCM_HURRICANE3_SUPPORT
    if (SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
        return bcm_hr3_port_egress_get(unit, port, modid, pbmp);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    if (!SOC_IS_XGS_SWITCH(unit)) {
        BCM_PBMP_ASSIGN(*pbmp, PBMP_ALL(unit));
        return BCM_E_NONE;
    }

    if ((modid < 0) || (port < 0) ){
            return BCM_E_PARAM;
    }

    egr_dst.in_modid = modid;
    egr_dst.in_port = port;
    BCM_IF_ERROR_RETURN(_bcm_esw_port_modid_egress_resolve(unit, &egr_dst));
    /* If the given port is a gport, _bcm_esw_port_modid_egress_resolve had
     * already performed module and port mapping for devices with
     * multiple module IDs.
     */
    mod_port_map_done = BCM_GPORT_IS_SET(port) ? 1 : 0;

    if (!mod_port_map_done) {
        PORT_DUALMODID_VALID(unit, egr_dst.out_min_port);
        BCM_IF_ERROR_RETURN(_bcm_esw_stk_modmap_map(unit, BCM_STK_MODMAP_SET,
                    egr_dst.out_min_modid, egr_dst.out_min_port,
                    &hw_mod, &hw_port));
    } else {
        hw_mod = egr_dst.out_min_modid;
        hw_port = egr_dst.out_min_port;
    }
    em_index = (hw_mod & SOC_MODID_MAX(unit)) *
        (SOC_PORT_ADDR_MAX(unit) + 1) | (hw_port & SOC_PORT_ADDR_MAX(unit));

    BCM_IF_ERROR_RETURN
        (READ_EGR_MASKm(unit, MEM_BLOCK_ALL, em_index, &em_entry));

    BCM_PBMP_CLEAR(em_pbmp);
    soc_mem_pbmp_field_get(unit, EGR_MASKm, &em_entry, EGRESS_MASKf,
                           &em_pbmp);
    BCM_PBMP_NEGATE(temp_pbmp, em_pbmp);
    BCM_PBMP_AND(temp_pbmp, PBMP_ALL(unit));
    BCM_PBMP_REMOVE(temp_pbmp, PBMP_LB(unit));
    BCM_PBMP_ASSIGN(*pbmp, temp_pbmp);

    return BCM_E_NONE;
}

#ifdef BCM_TRIUMPH2_SUPPORT
STATIC int
_bcm_port_src_mod_egress_profile_add(int unit, bcm_port_t port,
                                     int min_mod, int max_mod, pbmp_t pbmp)
{
    int i, region, modid_cnt, new_region, empty_profile, alloc_size;
    int rv = BCM_E_NONE;
    uint32 val, add_index;
    src_modid_egress_entry_t *srcmodegr_p, *sme_buf;
    pbmp_t test_pbmp;
    void   *entries[1];     /* for profile memories      */

    modid_cnt = SOC_MODID_MAX(unit) + 1;
    region = PORT_SRC_MOD_EGR_PROF_PTR(unit, port);
    empty_profile = TRUE;
    new_region = -1;

    alloc_size = modid_cnt * sizeof(*srcmodegr_p);
    sme_buf = sal_alloc(alloc_size, "SRC_MODID_EGRESS update buffer");
    if (NULL == sme_buf) {
        return BCM_E_MEMORY;
    }
    sal_memset(sme_buf, 0, alloc_size);
    entries[0] = sme_buf;

    if (0 <= region) {
        rv = soc_profile_mem_get(unit, PORT_SRC_MOD_EGR_PROFILE(unit),
                                 region * modid_cnt, modid_cnt, entries);
    } /* Else cleared by memset above.  Null entry is all 0's */

    if (BCM_SUCCESS(rv)) {
        for (i = min_mod; i <= max_mod; i++) {
            /* Profile memory is an array of entries, not a DMA buffer */
            srcmodegr_p = sme_buf + i; /* Both same pointer type */
            soc_mem_pbmp_field_set(unit, SRC_MODID_EGRESSm, srcmodegr_p,
                                   PORT_BLOCK_MASK_BITMAPf, &pbmp);
        }

        if (BCM_PBMP_IS_NULL(pbmp)) {
            /* Check for empty bitmap */
            for (i = 0; i < modid_cnt; i++) {
                srcmodegr_p = sme_buf + i; /* Both same pointer type */
                soc_mem_pbmp_field_get(unit, SRC_MODID_EGRESSm, srcmodegr_p,
                                       PORT_BLOCK_MASK_BITMAPf, &test_pbmp);
                if (BCM_PBMP_NOT_NULL(test_pbmp)) {
                    empty_profile = FALSE;
                    break;
                }
            }
        } else {
            empty_profile = FALSE;
        }

        if (!empty_profile) {
            rv = soc_profile_mem_add(unit, PORT_SRC_MOD_EGR_PROFILE(unit),
                                     entries, modid_cnt, &add_index);
            if (BCM_SUCCESS(rv)) {
                new_region = add_index / modid_cnt;
            }
        }
    }

    sal_free(sme_buf);
    BCM_IF_ERROR_RETURN(rv);

    BCM_IF_ERROR_RETURN(READ_SRC_MODID_EGRESS_SELr(unit, port, &val));
    if (empty_profile) {
        soc_reg_field_set(unit, SRC_MODID_EGRESS_SELr, &val, ENABLEf, 0);
        soc_reg_field_set(unit, SRC_MODID_EGRESS_SELr, &val,
                          SRCMOD_INDEXf, 0);
    } else {
        soc_reg_field_set(unit, SRC_MODID_EGRESS_SELr, &val, ENABLEf, 1);
        soc_reg_field_set(unit, SRC_MODID_EGRESS_SELr, &val,
                          SRCMOD_INDEXf, new_region);
    }
    BCM_IF_ERROR_RETURN(WRITE_SRC_MODID_EGRESS_SELr(unit, port, val));

    if (-1 != region) {
        BCM_IF_ERROR_RETURN
            (soc_profile_mem_delete(unit, PORT_SRC_MOD_EGR_PROFILE(unit),
                                    region * modid_cnt));
    }

    PORT_SRC_MOD_EGR_PROF_PTR(unit, port) = new_region;
    return BCM_E_NONE;
}
#endif

/*
 * Function:
 *      bcm_port_modid_egress_set
 * Description:
 *      Set port bitmap of egress ports on which the incoming packets
 *      will be forwarded.
 * Parameters:
 *      unit - StrataSwitch PCI device unit number (driver internal).
 *      port  - ingress port number.
 *      modid - source module ID index (in HiGig mod header).
 *      pbmp - bitmap of ports to allow egress.
 * Returns:
 *      BCM_E_xxxx
 * Note:
 *      if port < 0, means all/any port
 *      if modid < 0, means all/any modid
 */
int
bcm_esw_port_modid_egress_set(int unit, bcm_port_t port,
                              bcm_module_t modid, bcm_pbmp_t pbmp)
{
#if defined(BCM_HERCULES15_SUPPORT) || defined(BCM_FIREBOLT_SUPPORT)
    int rv=BCM_E_UNAVAIL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#ifdef  BCM_HERCULES15_SUPPORT
    if (SOC_IS_HERCULES15(unit)) {
        mem_ing_srcmodblk_entry_t srcmod;
        uint32 smf;
        bcm_module_t mod_idx, min_mod, max_mod;
        bcm_pbmp_t mod_pbmp;
        int bk=-1, blk;

        if (port >= 0) {
            if (!SOC_PORT_VALID(unit, port) || !IS_HG_PORT(unit, port)) {
                return BCM_E_PORT;
            }
            bk = SOC_PORT_BLOCK(unit, port);
        }

        if (modid < 0) {
            min_mod = soc_mem_index_min(unit, MEM_ING_SRCMODBLKm);
            max_mod = soc_mem_index_max(unit, MEM_ING_SRCMODBLKm);
        } else if (modid > soc_mem_index_max(unit, MEM_ING_SRCMODBLKm)) {
            return BCM_E_PARAM;
        } else {
            min_mod = max_mod = modid;
        }

        BCM_PBMP_ASSIGN(mod_pbmp, pbmp);
        BCM_PBMP_AND(mod_pbmp, PBMP_ALL(unit));
        if (BCM_PBMP_NEQ(pbmp, mod_pbmp)) {
            return BCM_E_PARAM;
        }

        soc_mem_lock(unit, MEM_ING_SRCMODBLKm);
        SOC_MEM_BLOCK_ITER(unit, MEM_ING_SRCMODBLKm, blk) {
            if ((port >= 0) && (bk !=blk)) {
                continue;
            }
            for (mod_idx = min_mod; mod_idx <= max_mod; mod_idx++) {
                 sal_memset(&srcmod, 0, sizeof(srcmod));
                 rv = READ_MEM_ING_SRCMODBLKm(unit, blk, mod_idx, &srcmod);
                 if (rv >= 0) {
                     SOC_PBMP_WORD_SET(mod_pbmp, 0,
                         soc_MEM_ING_SRCMODBLKm_field32_get(unit, &srcmod, BITMAPf));
                     if (BCM_PBMP_NEQ(pbmp, mod_pbmp)) {
                         smf = SOC_PBMP_WORD_GET(pbmp, 0);
                         soc_MEM_ING_SRCMODBLKm_field_set(unit, &srcmod, BITMAPf, &smf);
                         rv = WRITE_MEM_ING_SRCMODBLKm(unit, blk, mod_idx, &srcmod);
                     }
                 }
            }
        }
        soc_mem_unlock(unit, MEM_ING_SRCMODBLKm);
    }
#endif /* BCM_HERCULES15_SUPPORT */

#ifdef BCM_TRIUMPH2_SUPPORT
    if (soc_feature(unit, soc_feature_src_modid_blk_profile)) {
        src_modid_ingress_block_entry_t srcmoding;
        _bcm_port_egr_dest_t egr_dst;
        int all_st_ports;
        int i;
        bcm_port_t p;
        pbmp_t mod_pbmp, all_pbmp;

        if ((port != -1) && (!SOC_PORT_VALID(unit, port))) {
            return BCM_E_PORT;
        }
        egr_dst.in_port = port;
        egr_dst.in_modid = modid;
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_modid_egress_resolve(unit, &egr_dst));

        if (egr_dst.out_min_port == egr_dst.out_max_port) {
            all_st_ports = 0;
        } else {
            all_st_ports = 1;
        }

        SOC_PBMP_CLEAR(all_pbmp);
        SOC_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

#ifdef BCM_KATANA2_SUPPORT
        if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
        }
#endif
        /* First program the ingress blocking */
        soc_mem_lock(unit, SRC_MODID_INGRESS_BLOCKm);
        for (i = egr_dst.out_min_modid; i <= egr_dst.out_max_modid; i++) {
            rv = READ_SRC_MODID_INGRESS_BLOCKm(unit, MEM_BLOCK_ANY, i,
                                               &srcmoding);
            if (BCM_FAILURE(rv)) {
                soc_mem_unlock(unit, SRC_MODID_INGRESS_BLOCKm);
                return rv;
            }
            if (!all_st_ports) {
                soc_mem_pbmp_field_get(unit, SRC_MODID_INGRESS_BLOCKm,
                                       &srcmoding, PORT_BITMAPf, &mod_pbmp);
                BCM_PBMP_PORT_REMOVE(mod_pbmp, egr_dst.out_min_port);
            } else {
                BCM_PBMP_ASSIGN(mod_pbmp, all_pbmp);
                BCM_PBMP_OR(mod_pbmp, PBMP_LB(unit));
                PBMP_ST_ITER(unit, p) {
                    BCM_PBMP_PORT_REMOVE(mod_pbmp, p);
                }
            }
            soc_mem_pbmp_field_set(unit, SRC_MODID_INGRESS_BLOCKm,
                                   &srcmoding, PORT_BITMAPf, &mod_pbmp);
            rv = WRITE_SRC_MODID_INGRESS_BLOCKm(unit, MEM_BLOCK_ALL, i,
                                                &srcmoding);
            if (BCM_FAILURE(rv)) {
                soc_mem_unlock(unit, SRC_MODID_INGRESS_BLOCKm);
                return rv;
            }
        }
        soc_mem_unlock(unit, SRC_MODID_INGRESS_BLOCKm);

        /* Deal with the egress blocking - use one of 8 profiles */
        BCM_PBMP_ASSIGN(mod_pbmp, pbmp);
        BCM_PBMP_AND(mod_pbmp, all_pbmp);
        BCM_PBMP_REMOVE(mod_pbmp, PBMP_LB(unit));
        if (BCM_PBMP_NEQ(pbmp, mod_pbmp)) {
            return BCM_E_PARAM;
        }

        BCM_PBMP_NEGATE(mod_pbmp, pbmp);
        BCM_PBMP_AND(mod_pbmp, all_pbmp);
        BCM_PBMP_REMOVE(mod_pbmp, PBMP_LB(unit));

        soc_mem_lock(unit, SRC_MODID_EGRESSm);
        if (!all_st_ports) {
            /* Deal with a single stack port and its profile */
            /* coverity[overrun-call : FALSE] */
            rv = _bcm_port_src_mod_egress_profile_add(unit,
                                                      egr_dst.out_min_port,
                                                      egr_dst.out_min_modid,
                                                      egr_dst.out_max_modid,
                                                      mod_pbmp);
            if (BCM_FAILURE(rv)) {
                soc_mem_unlock(unit, SRC_MODID_EGRESSm);
                return rv;
            }
        } else {
            /* Deal with all stack ports and their profiles */
            PBMP_ST_ITER(unit, p) {
                /* coverity[overrun-local : FALSE] */
                rv = _bcm_port_src_mod_egress_profile_add(unit, p,
                                                     egr_dst.out_min_modid,
                                                     egr_dst.out_max_modid,
                                                          mod_pbmp);
                if (BCM_FAILURE(rv)) {
                    soc_mem_unlock(unit, SRC_MODID_EGRESSm);
                    return rv;
                }
            }
        }
        soc_mem_unlock(unit, SRC_MODID_EGRESSm);

        return rv;
    }
#endif

#ifdef BCM_TRX_SUPPORT
    if (SOC_IS_TRX(unit)) {
        src_modid_block_entry_t srcmod;
        int modid_cnt, idx, i, j;
        bcm_pbmp_t mod_pbmp;
        _bcm_port_egr_dest_t    egr_dst;

        /* Number of supported MODIDs for this unit */
        modid_cnt = SOC_MODID_MAX(unit) + 1;

        egr_dst.in_port = port;
        egr_dst.in_modid = modid;
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_modid_egress_resolve(unit, &egr_dst));

        if (egr_dst.out_min_port == egr_dst.out_max_port) {
            /* process to retrieve hg_port index from port */
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
                egr_dst.out_min_port = egr_dst.out_max_port;
            } else {
                SOC_IF_ERROR_RETURN(
                    soc_xgs3_port_num_to_higig_port_num(unit,
                                egr_dst.out_max_port, &egr_dst.out_min_port));
            }

            egr_dst.out_max_port = egr_dst.out_min_port;
        } else {
            egr_dst.out_min_port = soc_mem_index_min(unit, SRC_MODID_BLOCKm) / modid_cnt;
            egr_dst.out_max_port = soc_mem_index_max(unit, SRC_MODID_BLOCKm) / modid_cnt;
        }

        BCM_PBMP_ASSIGN(mod_pbmp, pbmp);
        BCM_PBMP_AND(mod_pbmp, PBMP_ALL(unit));
        if (BCM_PBMP_NEQ(pbmp, mod_pbmp)) {
            return BCM_E_PARAM;
        }

        BCM_PBMP_NEGATE(mod_pbmp, pbmp);
        BCM_PBMP_AND(mod_pbmp, PBMP_ALL(unit));

        soc_mem_lock(unit, SRC_MODID_BLOCKm);
        for (i = egr_dst.out_min_port; i <= egr_dst.out_max_port; i++) {
            for (j = egr_dst.out_min_modid; j <= egr_dst.out_max_modid; j++) {
                idx = i * modid_cnt + j;
                rv = READ_SRC_MODID_BLOCKm(unit, MEM_BLOCK_ANY, idx, &srcmod);
                if (rv >= 0) {
                    soc_SRC_MODID_BLOCKm_field_set(unit, &srcmod,
                                                   PORT_BLOCK_MASK_BITMAPf,
                                                   (uint32 *)&mod_pbmp);
                    rv = WRITE_SRC_MODID_BLOCKm(unit, MEM_BLOCK_ALL, idx,
                                                &srcmod);
                }
                if (rv < 0) {
                    soc_mem_unlock(unit, SRC_MODID_BLOCKm);
                    return rv;
                }
            }
        }
        soc_mem_unlock(unit, SRC_MODID_BLOCKm);
        return rv;
    }
#endif /* BCM_TRX_SUPPORT */

#ifdef BCM_FIREBOLT_SUPPORT
    if (soc_feature(unit, soc_feature_src_modid_blk)) {
        src_modid_block_entry_t srcmod;
        bcm_module_t mod_idx;
        int p_idx, min_p, max_p;
        int tbl_size, modid_cnt, idx;
        bcm_pbmp_t mod_pbmp, tst_pbmp, hg_pbmp;
        int cpu=0, ether=0;
        uint32 xge_val;
        _bcm_port_egr_dest_t    egr_dst;
#if defined(BCM_RAPTOR_SUPPORT)
        uint32  rp_val;
#endif /* BCM_RAPTOR_SUPPORT */
        /* Number of supported MODIDs for this unit */
        modid_cnt = SOC_MODID_MAX(unit) + 1;


        egr_dst.in_port = port;
        egr_dst.in_modid = modid;
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_modid_egress_resolve(unit, &egr_dst));

        if (egr_dst.out_min_port == egr_dst.out_max_port) {
            min_p = max_p = egr_dst.out_min_port - SOC_HG_OFFSET(unit);
        } else {
            min_p = 0;
            tbl_size = soc_mem_index_count(unit, SRC_MODID_BLOCKm);
            max_p = (tbl_size / modid_cnt) - 1;
            assert(max_p >= 0);
        }

        BCM_PBMP_ASSIGN(mod_pbmp, pbmp);
        BCM_PBMP_AND(mod_pbmp, PBMP_ALL(unit));
        if (BCM_PBMP_NEQ(pbmp, mod_pbmp)) {
            return BCM_E_PARAM;
        }

        BCM_PBMP_NEGATE(mod_pbmp, pbmp);
        BCM_PBMP_AND(mod_pbmp, PBMP_ALL(unit));

        BCM_PBMP_ASSIGN(tst_pbmp, mod_pbmp);
        BCM_PBMP_AND(tst_pbmp, PBMP_CMIC(unit));
        if (BCM_PBMP_NOT_NULL(tst_pbmp)) {
            cpu = 1;
        }

        BCM_PBMP_ASSIGN(tst_pbmp, mod_pbmp);
        BCM_PBMP_AND(tst_pbmp, PBMP_E_ALL(unit));
        if (BCM_PBMP_NOT_NULL(tst_pbmp)) {
            ether = 1;
            BCM_PBMP_ASSIGN(tst_pbmp, PBMP_XE_ALL(unit));
        }

        BCM_PBMP_ASSIGN(hg_pbmp, mod_pbmp);
        BCM_PBMP_AND(hg_pbmp, PBMP_ST_ALL(unit));

        if (ether && BCM_PBMP_NOT_NULL(tst_pbmp)) {
            BCM_PBMP_OR(hg_pbmp, tst_pbmp);
        }
        xge_val = SOC_PBMP_WORD_GET(hg_pbmp, 0) >> SOC_HG_OFFSET(unit);

        /* In Raven, port #3 is the GMII port and it introduces a hole in the ST pbmp */
        soc_mem_lock(unit, SRC_MODID_BLOCKm);
        for (p_idx = min_p; p_idx <= max_p; p_idx++) {
            if (SOC_IS_RAVEN(unit) && p_idx == 3) {
                continue;
            }
            for (mod_idx = egr_dst.out_min_modid; mod_idx <= egr_dst.out_max_modid; mod_idx++) {
                 sal_memset(&srcmod, 0, sizeof(srcmod));
                 /* Table is 2-dimensional array */
                 if (SOC_IS_RAVEN(unit) && p_idx >= 4) {
                     idx = (p_idx - 1) * modid_cnt + mod_idx;
                 } else {
                     idx = (p_idx * modid_cnt) + mod_idx;
                 }
                 rv = READ_SRC_MODID_BLOCKm(unit, MEM_BLOCK_ANY, idx, &srcmod);
                 if (rv >= 0) {
                     soc_SRC_MODID_BLOCKm_field32_set(unit, &srcmod,
                                                      CPU_PORT_BLOCK_MASKf,
                                                      (cpu) ? 1 : 0);
                     if (SOC_IS_FB_FX_HX(unit)) {
                         soc_SRC_MODID_BLOCKm_field32_set(unit, &srcmod,
                                                          GE_PORT_BLOCK_MASKf,
                                                          (ether) ? 1 : 0);
                     }
                     soc_SRC_MODID_BLOCKm_field32_set(unit, &srcmod,
                                                      HIGIG_XGE_PORT_BLOCK_MASKf,
                                                      xge_val);
#if defined(BCM_RAPTOR_SUPPORT)
                     if (soc_mem_field_valid(unit, SRC_MODID_BLOCKm,
                                             PORT_0_5_BLOCK_MASKf)) {
                          rp_val = (SOC_PBMP_WORD_GET(mod_pbmp, 0)) &
                              ((1 << soc_reg_field_length(unit, SRC_MODID_BLOCKm,
                                                   PORT_0_5_BLOCK_MASKf )) - 1);
                          soc_SRC_MODID_BLOCKm_field32_set(unit, &srcmod,
                                                           PORT_0_5_BLOCK_MASKf,
                                                           rp_val);
                     }
#endif /* BCM_RAPTOR_SUPPORT */
                     rv = WRITE_SRC_MODID_BLOCKm(unit, MEM_BLOCK_ALL,
                                                 idx, &srcmod);
                 }
            }
        }
        soc_mem_unlock(unit, SRC_MODID_BLOCKm);
    }
#endif /* BCM_FIREBOLT_SUPPORT */

    return rv;
#else
    return BCM_E_UNAVAIL;
#endif  /* BCM_HERCULES15_SUPPORT || BCM_FIREBOLT_SUPPORT */
}

/*
 * Function:
 *      bcm_port_modid_egress_get
 * Description:
 *      Retrieve port bitmap of egress ports on which the incoming packets
 *      will be forwarded.
 * Parameters:
 *      unit - StrataSwitch PCI device unit number (driver internal).
 *      port  - ingress port number.
 *      modid - source module ID index (in HiGig mod header).
 *      pbmp - (OUT) bitmap of ports where egress allowed.
 * Returns:
 *      BCM_E_xxxx
 */
int
bcm_esw_port_modid_egress_get(int unit, bcm_port_t port,
                              bcm_module_t modid, bcm_pbmp_t *pbmp)
{
#if defined(BCM_HERCULES15_SUPPORT) || defined(BCM_FIREBOLT_SUPPORT)
    int rv=BCM_E_UNAVAIL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#ifdef  BCM_HERCULES15_SUPPORT
    if (SOC_IS_HERCULES15(unit)) {
        mem_ing_srcmodblk_entry_t srcmod;
        bcm_module_t min_mod, max_mod;
        int blk, rv=BCM_E_NONE;

        if (!SOC_PORT_VALID(unit, port) || !IS_HG_PORT(unit, port)) {
            return BCM_E_PORT;
        }

        min_mod = soc_mem_index_min(unit, MEM_ING_SRCMODBLKm);
        max_mod = soc_mem_index_max(unit, MEM_ING_SRCMODBLKm);
        if ((modid < min_mod) || (modid > max_mod))  {
            return BCM_E_PARAM;
        }

        blk = SOC_PORT_BLOCK(unit, port);
        SOC_PBMP_CLEAR(*pbmp);
        rv = READ_MEM_ING_SRCMODBLKm(unit, blk, modid, &srcmod);
        if (rv >= 0) {
            SOC_PBMP_WORD_SET(*pbmp, 0,
                soc_MEM_ING_SRCMODBLKm_field32_get(unit, &srcmod, BITMAPf));
        }
    }
#endif /* BCM_HERCULES15_SUPPORT */

#ifdef BCM_TRIUMPH2_SUPPORT
    if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
        SOC_IS_VALKYRIE2(unit) || SOC_IS_TD_TT(unit) ||
        SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANAX(unit)) {
        src_modid_egress_entry_t srcmodegr;
        int idx;
        _bcm_port_egr_dest_t    egr_dst;
        bcm_pbmp_t all_pbmp;

        SOC_PBMP_CLEAR(all_pbmp);
        SOC_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

#ifdef BCM_KATANA2_SUPPORT
        if (soc_feature(unit, soc_feature_linkphy_coe) ||
            soc_feature(unit, soc_feature_subtag_coe)) {
            _bcm_kt2_subport_pbmp_update(unit, &all_pbmp);
        }
#endif

        egr_dst.in_port = port;
        egr_dst.in_modid = modid;
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_modid_egress_resolve(unit, &egr_dst));

        if (egr_dst.out_min_modid != egr_dst.out_max_modid) {
            return BCM_E_PARAM;
        }
        if (egr_dst.out_max_port != egr_dst.out_min_port) {
            return BCM_E_PORT;
        }

        idx = PORT_SRC_MOD_EGR_PROF_PTR(unit, egr_dst.out_min_port) *
              (SOC_MODID_MAX(unit) + 1) + egr_dst.out_min_modid;
        SOC_IF_ERROR_RETURN(READ_SRC_MODID_EGRESSm(unit, MEM_BLOCK_ANY, idx,
                                                   &srcmodegr));
        soc_mem_pbmp_field_get(unit, SRC_MODID_EGRESSm, &srcmodegr,
                               PORT_BLOCK_MASK_BITMAPf, pbmp);
        BCM_PBMP_NEGATE(*pbmp, *pbmp);
        BCM_PBMP_AND(*pbmp, all_pbmp);
        BCM_PBMP_REMOVE(*pbmp, PBMP_LB(unit));
        return SOC_E_NONE;
    }
#endif

#ifdef BCM_TRX_SUPPORT
    if (SOC_IS_TRX(unit)) {
        src_modid_block_entry_t srcmod;
        int hg_port, idx;
        _bcm_port_egr_dest_t    egr_dst;

        egr_dst.in_port = port;
        egr_dst.in_modid = modid;
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_modid_egress_resolve(unit, &egr_dst));

        if (egr_dst.out_min_modid != egr_dst.out_max_modid) {
            return BCM_E_PARAM;
        }
        if (egr_dst.out_max_port != egr_dst.out_min_port) {
            return BCM_E_PORT;
        }

        /* process to retrieve hg_port index from port */
        if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
            SOC_IS_GREYHOUND2(unit)) {
            hg_port = egr_dst.out_min_port;
        } else {
            SOC_IF_ERROR_RETURN(
                soc_xgs3_port_num_to_higig_port_num(unit,
                                        egr_dst.out_min_port, &hg_port));
        }

        idx = hg_port * (SOC_MODID_MAX(unit) + 1) + egr_dst.out_min_modid;
        SOC_IF_ERROR_RETURN(READ_SRC_MODID_BLOCKm(unit, MEM_BLOCK_ANY, idx,
                                                  &srcmod));
        soc_SRC_MODID_BLOCKm_field_get(unit, &srcmod, PORT_BLOCK_MASK_BITMAPf,
                                       (uint32 *)pbmp);
        BCM_PBMP_NEGATE(*pbmp, *pbmp);
        BCM_PBMP_AND(*pbmp, PBMP_ALL(unit));

        return SOC_E_NONE;
    }
#endif

#ifdef BCM_FIREBOLT_SUPPORT
    if (soc_feature(unit, soc_feature_src_modid_blk)) {
        src_modid_block_entry_t srcmod;
        int modid_cnt, p_idx, idx;
        _bcm_port_egr_dest_t    egr_dst;

        egr_dst.in_port = port;
        egr_dst.in_modid = modid;
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_modid_egress_resolve(unit, &egr_dst));

        if (egr_dst.out_min_modid != egr_dst.out_max_modid) {
            return BCM_E_PARAM;
        }
        if (egr_dst.out_max_port != egr_dst.out_min_port) {
            return BCM_E_PORT;
        }

        modid_cnt = SOC_MODID_MAX(unit) + 1;
        p_idx = egr_dst.out_min_port - SOC_HG_OFFSET(unit);
        if (SOC_IS_RAVEN(unit) && p_idx >= 4) {
            idx = (p_idx - 1) * modid_cnt + egr_dst.out_min_modid;
        } else {
            idx = (p_idx * modid_cnt) + egr_dst.out_min_modid;
        }

        rv = READ_SRC_MODID_BLOCKm(unit, MEM_BLOCK_ANY, idx, &srcmod);
        BCM_PBMP_CLEAR(*pbmp);
        if (rv >= 0) {
            int cpu, ether;
            pbmp_t hg_pbmp;
            uint32 xge_val;
#if defined(BCM_RAPTOR_SUPPORT)
            uint32 rp_val;
#endif /* BCM_RAPTOR_SUPPORT */
            cpu = soc_SRC_MODID_BLOCKm_field32_get(unit, &srcmod,
                                                   CPU_PORT_BLOCK_MASKf);
            if (SOC_IS_FB_FX_HX(unit)) {
                ether = soc_SRC_MODID_BLOCKm_field32_get(unit, &srcmod,
                                                         GE_PORT_BLOCK_MASKf);
            } else {
                ether = 0;
            }
            xge_val = soc_SRC_MODID_BLOCKm_field32_get(unit, &srcmod,
                                                       HIGIG_XGE_PORT_BLOCK_MASKf);
            SOC_PBMP_CLEAR(hg_pbmp);
            SOC_PBMP_WORD_SET(hg_pbmp, 0, xge_val << SOC_HG_OFFSET(unit));

#if defined(BCM_RAPTOR_SUPPORT)
            if (soc_mem_field_valid(unit, SRC_MODID_BLOCKm,
                                    PORT_0_5_BLOCK_MASKf)) {
                rp_val = soc_SRC_MODID_BLOCKm_field32_get(unit, &srcmod,
                                                         PORT_0_5_BLOCK_MASKf);
                SOC_PBMP_WORD_SET(hg_pbmp, 0, rp_val);
            }
#endif /* BCM_RAPTOR_SUPPORT */
            BCM_PBMP_ASSIGN(*pbmp, PBMP_ALL(unit));
            if (cpu) {
                BCM_PBMP_REMOVE(*pbmp, PBMP_CMIC(unit));
            }
            if (ether) {
                BCM_PBMP_REMOVE(*pbmp, PBMP_E_ALL(unit));
            }
            if (BCM_PBMP_NOT_NULL(hg_pbmp)) {
                BCM_PBMP_REMOVE(*pbmp, hg_pbmp);
            }
        }
    }
#endif /* BCM_FIREBOLT_SUPPORT */

    return rv;
#else
    return BCM_E_UNAVAIL;
#endif  /* BCM_HERCULES15_SUPPORT  || BCM_FIREBOLT_SUPPORT */
}

/*
 * Function:
 *    bcm_port_modid_enable_set
 * Purpose:
 *    Enable/block packets from a specific module on a port.
 * Parameters:
 *    unit - StrataSwitch PCI device unit number (driver internal).
 *    port - StrataSwitch port number.
 *    modid - Which source module id to enable/disable
 *    enable - TRUE/FALSE Enable/disable forwarding packets from
 *             source module arriving on port.
 * Returns:
 *    BCM_E_XXX
 */
int
bcm_esw_port_modid_enable_set(int unit, bcm_port_t port, int modid, int enable)
{
    int max_mod;
#ifdef BCM_HERCULES_SUPPORT
    uint32 smf, osmf;
#endif /* BCM_HERCULES_SUPPORT */
#ifdef BCM_HERCULES1_SUPPORT
    uint32 mask;
#endif /* BCM_HERCULES1_SUPPORT */
#ifdef BCM_HERCULES15_SUPPORT
    mem_ing_srcmodblk_entry_t srcmod;
    int blk;
#endif /* BCM_HERCULES15_SUPPORT */
#if defined(BCM_HERCULES15_SUPPORT) || defined(BCM_FIREBOLT_SUPPORT)
    int rv=BCM_E_NONE;
#endif /* BCM_HERCULES15_SUPPORT || BCM_FIREBOLT_SUPPORT */

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef BCM_TRX_SUPPORT
    if (SOC_IS_TRX(unit)) {
        src_modid_ingress_block_entry_t srcmoding;
        src_modid_block_entry_t srcmod;
        int modid_cnt, hg_port, idx, i;
        bcm_pbmp_t pbmp;
        _bcm_port_egr_dest_t    egr_dst;

        egr_dst.in_port = port;
        egr_dst.in_modid = modid;
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_modid_egress_resolve(unit, &egr_dst));

        if (egr_dst.out_max_port != egr_dst.out_min_port) {
            return BCM_E_PORT;
        }

        if (!IS_E_PORT(unit, egr_dst.out_max_port) &&
            !IS_ST_PORT(unit, egr_dst.out_max_port)) {
            return BCM_E_PORT;
        }


        if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
            SOC_IS_VALKYRIE2(unit) || SOC_IS_TD_TT(unit) ||
            SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANAX(unit)) {
            soc_mem_lock(unit, SRC_MODID_INGRESS_BLOCKm);
            for (i = egr_dst.out_min_modid; i <= egr_dst.out_max_modid; i++) {
                rv = READ_SRC_MODID_INGRESS_BLOCKm(unit, MEM_BLOCK_ANY, i,
                                                   &srcmoding);
                if (rv >= 0) {
                    soc_mem_pbmp_field_get(unit, SRC_MODID_INGRESS_BLOCKm,
                                           &srcmoding, PORT_BITMAPf, &pbmp);
                    if (enable) {
                        BCM_PBMP_PORT_REMOVE(pbmp, egr_dst.out_max_port);
                    } else {
                        BCM_PBMP_PORT_ADD(pbmp, egr_dst.out_max_port);
                    }
                    soc_mem_pbmp_field_set(unit, SRC_MODID_INGRESS_BLOCKm,
                                           &srcmoding, PORT_BITMAPf, &pbmp);
                    rv = WRITE_SRC_MODID_INGRESS_BLOCKm(unit, MEM_BLOCK_ALL, i,
                                                        &srcmoding);
                }
                if (rv < 0) {
                    soc_mem_unlock(unit, SRC_MODID_INGRESS_BLOCKm);
                    return rv;
                }
            }
            soc_mem_unlock(unit, SRC_MODID_INGRESS_BLOCKm);
        } else {
            modid_cnt = SOC_MODID_MAX(unit) + 1;

            /* process to retrieve hg_port index from port */
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
                hg_port = port;
            } else {
                SOC_IF_ERROR_RETURN(
                    soc_xgs3_port_num_to_higig_port_num(unit, port, &hg_port));
            }

            soc_mem_lock(unit, SRC_MODID_BLOCKm);
            for (i = egr_dst.out_min_modid; i <= egr_dst.out_max_modid; i++) {
                idx = hg_port * modid_cnt + i;
                rv = READ_SRC_MODID_BLOCKm(unit, MEM_BLOCK_ANY, idx, &srcmod);
                if (rv >= 0) {
                    if (!enable) {
                        SOC_PBMP_ASSIGN(pbmp, PBMP_ALL(unit));
                    } else {
                        SOC_PBMP_CLEAR(pbmp);
                    }
                    soc_mem_pbmp_field_set(unit, SRC_MODID_BLOCKm, &srcmod,
                                           PORT_BLOCK_MASK_BITMAPf,&pbmp);
                    rv = WRITE_SRC_MODID_BLOCKm(unit, MEM_BLOCK_ALL, idx, &srcmod);
                }
                if (rv < 0) {
                    soc_mem_unlock(unit, SRC_MODID_BLOCKm);
                    return rv;
                }
            }
            soc_mem_unlock(unit, SRC_MODID_BLOCKm);
        }
        return rv;
    }
#endif  /* BCM_TRX_SUPPORT */

#ifdef BCM_FIREBOLT_SUPPORT
    if (soc_feature(unit, soc_feature_src_modid_blk)) {
        src_modid_block_entry_t src_mod;
        int modid_cnt, mod_idx, p_idx, idx, val;
        _bcm_port_egr_dest_t    egr_dst;

        egr_dst.in_port = port;
        egr_dst.in_modid = modid;
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_modid_egress_resolve(unit, &egr_dst));

        if (egr_dst.out_max_port != egr_dst.out_min_port) {
            return BCM_E_PORT;
        }

        modid_cnt = SOC_MODID_MAX(unit) + 1;
        p_idx = egr_dst.out_min_port - SOC_HG_OFFSET(unit);
        soc_mem_lock(unit, SRC_MODID_BLOCKm);
        for (mod_idx = egr_dst.out_min_modid; mod_idx <= egr_dst.out_max_modid; mod_idx++) {
             sal_memset(&src_mod, 0, sizeof(src_mod));
             if (SOC_IS_RAVEN(unit) && p_idx >= 4) {
                 idx = (p_idx - 1) * modid_cnt + mod_idx;
             } else {
                 idx = (p_idx * modid_cnt) + mod_idx;
             }
             rv = READ_SRC_MODID_BLOCKm(unit, MEM_BLOCK_ANY, idx, &src_mod);
             if (rv >= 0) {
                 soc_SRC_MODID_BLOCKm_field32_set(unit, &src_mod,
                                                  CPU_PORT_BLOCK_MASKf,
                                                  (enable) ? 0 : 1);
                 if (SOC_IS_FB_FX_HX(unit)) {
                     soc_SRC_MODID_BLOCKm_field32_set(unit, &src_mod,
                                                      GE_PORT_BLOCK_MASKf,
                                                      (enable) ? 0 : 1);
                 }

                 val = (1 << soc_mem_field_length(unit, SRC_MODID_BLOCKm,
                                             HIGIG_XGE_PORT_BLOCK_MASKf)) - 1;

                 soc_SRC_MODID_BLOCKm_field32_set(unit, &src_mod,
                                                  HIGIG_XGE_PORT_BLOCK_MASKf,
                                                  (enable) ? 0 : val);
#if defined(BCM_RAPTOR_SUPPORT)
                 if (soc_mem_field_valid(unit, SRC_MODID_BLOCKm,
                                         PORT_0_5_BLOCK_MASKf)) {

                     val = (1 << soc_mem_field_length(unit, SRC_MODID_BLOCKm,
                                                 PORT_0_5_BLOCK_MASKf)) - 1;

                     soc_SRC_MODID_BLOCKm_field32_set(unit, &src_mod,
                                                      PORT_0_5_BLOCK_MASKf,
                                                      (enable) ? 0 : val);

                 }
#endif /* BCM_RAPTOR_SUPPORT */
                 rv = WRITE_SRC_MODID_BLOCKm(unit, MEM_BLOCK_ALL,
                                             idx, &src_mod);
             }
        }
        soc_mem_unlock(unit, SRC_MODID_BLOCKm);

        return rv;
    }
#endif /* BCM_FIREBOLT_SUPPORT */

    if (!IS_PORT(unit, port)) {
        return BCM_E_PORT;
    }

    if (!soc_feature(unit, soc_feature_srcmod_filter)) {
        if (enable) {
            return BCM_E_NONE;
        } else {
            return BCM_E_UNAVAIL;
        }
    }

    max_mod = 128;
    if (modid >= max_mod) {
        return BCM_E_PARAM;
    }

#ifdef BCM_HERCULES15_SUPPORT
    if (SOC_IS_HERCULES15(unit)) {
        blk = SOC_PORT_BLOCK(unit, port);
        soc_mem_lock(unit, MEM_ING_SRCMODBLKm);
        if (modid < 0) {
            for (modid = 0; modid < max_mod; modid++) {
                rv = READ_MEM_ING_SRCMODBLKm(unit, blk, modid, &srcmod);
                if (rv < 0) {
                    break;
                }
                soc_MEM_ING_SRCMODBLKm_field_get(unit, &srcmod, BITMAPf,
                                                 &osmf);
                smf = (enable) ? SOC_PBMP_WORD_GET(PBMP_ALL(unit), 0) : 0;
                if (osmf != smf) {
                    soc_MEM_ING_SRCMODBLKm_field_set(unit, &srcmod, BITMAPf,
                                                     &smf);
                    rv = WRITE_MEM_ING_SRCMODBLKm(unit, blk, modid, &srcmod);
                    if (rv < 0) {
                        break;
                    }
                }
            }
        } else {
            rv = READ_MEM_ING_SRCMODBLKm(unit, blk, modid, &srcmod);
            if (rv >= 0) {
                soc_MEM_ING_SRCMODBLKm_field_get(unit, &srcmod, BITMAPf,
                                                 &osmf);
                smf = (enable) ? SOC_PBMP_WORD_GET(PBMP_ALL(unit), 0) : 0;
                if (osmf != smf) {
                    soc_MEM_ING_SRCMODBLKm_field_set(unit, &srcmod, BITMAPf,
                                                     &smf);
                    rv = WRITE_MEM_ING_SRCMODBLKm(unit, blk, modid, &srcmod);
                }
            }
        }
        soc_mem_unlock(unit, MEM_ING_SRCMODBLKm);
    }
#endif /* BCM_HERCULES15_SUPPORT */

    return BCM_E_NONE;
}

/*
 * Function:
 *    bcm_port_modid_enable_get
 * Purpose:
 *    Return enable/block state for a specific module on a port.
 * Parameters:
 *    unit - StrataSwitch PCI device unit number (driver internal).
 *    port - StrataSwitch port number.
 *    modid - Which source module id to enable/disable
 *    enable - (OUT) TRUE/FALSE Enable/disable forwarding packets from
 *             source module arriving on port.
 * Returns:
 *    BCM_E_XXX
 */
int
bcm_esw_port_modid_enable_get(int unit, bcm_port_t port, int modid, int *enable)
{
    int max_mod;
#ifdef BCM_HERCULES_SUPPORT
    uint32 smf;
#endif /* BCM_HERCULES_SUPPORT */
#ifdef BCM_HERCULES1_SUPPORT
    uint32 mask;
#endif /* BCM_HERCULES1_SUPPORT */
#ifdef BCM_HERCULES15_SUPPORT
    mem_ing_srcmodblk_entry_t srcmod;
    int blk, rv;
#endif /* BCM_HERCULES15_SUPPORT */

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef BCM_TRX_SUPPORT
    if (SOC_IS_TRX(unit)) {
        src_modid_ingress_block_entry_t srcmoding;
        src_modid_block_entry_t srcmod;
        int hg_port, idx;
        bcm_pbmp_t pbmp;
        _bcm_port_egr_dest_t    egr_dst;

        egr_dst.in_port = port;
        egr_dst.in_modid = modid;
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_modid_egress_resolve(unit, &egr_dst));

        if (egr_dst.out_max_port != egr_dst.out_min_port) {
            return BCM_E_PORT;
        }
        if (egr_dst.out_max_modid != egr_dst.out_min_modid) {
            return BCM_E_PARAM;
        }

        if (!IS_E_PORT(unit, egr_dst.out_max_port) &&
            !IS_ST_PORT(unit, egr_dst.out_max_port)) {
            return BCM_E_PORT;
        }

        SOC_PBMP_CLEAR(pbmp);
        if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
            SOC_IS_VALKYRIE2(unit) || SOC_IS_TD_TT(unit) ||
            SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANAX(unit)) {
            SOC_IF_ERROR_RETURN(
                READ_SRC_MODID_INGRESS_BLOCKm(unit, MEM_BLOCK_ANY,
                                              egr_dst.out_min_modid, &srcmoding));
            soc_mem_pbmp_field_get(unit, SRC_MODID_INGRESS_BLOCKm,
                                   &srcmoding, PORT_BITMAPf, &pbmp);
        } else {
            /* process to retrieve hg_port index from port */
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
                hg_port = egr_dst.out_min_port;
            } else {
                SOC_IF_ERROR_RETURN(soc_xgs3_port_num_to_higig_port_num(unit,
                        egr_dst.out_min_port, &hg_port));
            }

            idx = hg_port * (SOC_MODID_MAX(unit) + 1) + egr_dst.out_min_modid;
            SOC_IF_ERROR_RETURN(READ_SRC_MODID_BLOCKm(unit, MEM_BLOCK_ANY, idx,
                                                      &srcmod));
            soc_mem_pbmp_field_get(unit, SRC_MODID_BLOCKm, &srcmod,
                                   PORT_BLOCK_MASK_BITMAPf, &pbmp);
        }

        *enable = !SOC_PBMP_MEMBER(pbmp, egr_dst.out_max_port);

        return BCM_E_NONE;
    }
#endif /* BCM_TRIUMPH_SUPPORT */

#ifdef BCM_FIREBOLT_SUPPORT
    if (soc_feature(unit, soc_feature_src_modid_blk)) {
        uint32 config;
        src_modid_block_entry_t src_mod;
        int gable, modid_cnt, p_idx, idx;
        _bcm_port_egr_dest_t    egr_dst;

        egr_dst.in_port = port;
        egr_dst.in_modid = modid;
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_modid_egress_resolve(unit, &egr_dst));

        if (egr_dst.out_max_port != egr_dst.out_min_port) {
            return BCM_E_PORT;
        }
        if (egr_dst.out_max_modid != egr_dst.out_min_modid) {
            return BCM_E_PARAM;
        }

        SOC_IF_ERROR_RETURN(READ_ING_CONFIGr(unit, &config));
        gable = !soc_reg_field_get(unit, ING_CONFIGr, config,
                                   FB_A0_COMPATIBLEf);
        if (gable) {
            modid_cnt = SOC_MODID_MAX(unit) + 1;
            p_idx = egr_dst.out_min_port - SOC_HG_OFFSET(unit);
            if (SOC_IS_RAVEN(unit) && p_idx >= 4) {
                idx = (p_idx - 1) * modid_cnt + egr_dst.out_min_modid;
            } else {
                idx = (p_idx * modid_cnt) + egr_dst.out_min_modid;
            }
            SOC_IF_ERROR_RETURN
                (READ_SRC_MODID_BLOCKm(unit, MEM_BLOCK_ANY,
                                       idx, &src_mod));
            *enable = (soc_SRC_MODID_BLOCKm_field32_get(unit, &src_mod,
                                                        CPU_PORT_BLOCK_MASKf) |
                       soc_SRC_MODID_BLOCKm_field32_get(unit, &src_mod,
                                                        HIGIG_XGE_PORT_BLOCK_MASKf)
                                                        ) ? 0 : 1;
            if (SOC_IS_FB_FX_HX(unit)) {
                *enable = (soc_SRC_MODID_BLOCKm_field32_get(unit, &src_mod,
                                                            GE_PORT_BLOCK_MASKf)
                                                            ) ? 0 : 1;
            }

#if defined(BCM_RAPTOR_SUPPORT)
            if (soc_mem_field_valid(unit, SRC_MODID_BLOCKm,
                                    PORT_0_5_BLOCK_MASKf)) {
                *enable = (soc_SRC_MODID_BLOCKm_field32_get(unit, &src_mod,
                                                 PORT_0_5_BLOCK_MASKf)
                                                 ) ? 0 : 1;
            }
#endif /* BCM_RAPTOR_SUPPORT */

        } else {
            *enable = gable;
        }

        return BCM_E_NONE;
    }
#endif /* BCM_FIREBOLT_SUPPORT */

    if (!IS_PORT(unit, port)) {
        return BCM_E_PORT;
    }

    if (!soc_feature(unit, soc_feature_srcmod_filter)) {
        *enable = TRUE;
        return BCM_E_NONE;
    }

    max_mod = 128;
    if (!((modid >= 0) && (modid < max_mod))) {
        return BCM_E_PARAM;
    }

#ifdef BCM_HERCULES15_SUPPORT
    if (SOC_IS_HERCULES15(unit)) {
        blk = SOC_PORT_BLOCK(unit, port);
        rv = READ_MEM_ING_SRCMODBLKm(unit, blk, modid, &srcmod);
        if (rv >= 0) {
            soc_MEM_ING_SRCMODBLKm_field_get(unit, &srcmod, BITMAPf, &smf);
            *enable = (smf & SOC_PBMP_WORD_GET(PBMP_ALL(unit),0)) ? 1 : 0;
        }
    }
#endif /* BCM_HERCULES15_SUPPORT */

    return BCM_E_NONE;
}


/*
 * Function:
 *      _bcm_port_flood_block_op
 * Purpose:
 *      Set or get port membership in one of the egress block registers
 * Parameters:
 *      unit
 *      set_op          - TRUE for set, FALSE for get
 *      ingress_port    - ingress port on which the egress blocking
 *                        will be enabled
 *      egress_port     - port for which egress will be blocked
 *      mode            - BCM_PORT_FLOOD_BLOCK_XXX
 *      enable          - Whether blocking should be enabled or disabled
 *                        This is also BCM_PORT_FLOOD_BLOCK_XXX
 * Returns:
 *      BCM_E_UNAVAIL   - This chip does not support this feature
 *      BCM_E_NONE
 */
STATIC int
_bcm_port_flood_block_op(int unit, int set_op,
                         bcm_port_t ingress_port, bcm_port_t egress_port,
                         uint32 mode, uint32 *enable)
{
    soc_reg_t reg, mask_reg[2], mask_hi_reg[2];
    soc_mem_t mem;
    soc_field_t field;
    uint64 rval;
    uint32 fval;
    uint32 entry[SOC_MAX_MEM_WORDS];
    pbmp_t pbmp;
    int index;
    int cpu_hg_index = 0;

    mask_reg[0] = mask_reg[1] = INVALIDr;
    mask_hi_reg[0] = mask_hi_reg[1] = INVALIDr;
    mem = INVALIDm;
    field = INVALIDf;

    switch (mode) {
    case BCM_PORT_FLOOD_BLOCK_BCAST:
        if (SOC_MEM_IS_VALID(unit, BCAST_BLOCK_MASKm)) {
            mem = BCAST_BLOCK_MASKm;
            field = BLK_BITMAPf;
        /* coverity[result_independent_of_operands] */
        } else if (SOC_REG_IS_VALID(unit, BCAST_BLOCK_MASK_64r)) {
            mask_reg[0] = BCAST_BLOCK_MASK_64r;
            mask_reg[1] = IBCAST_BLOCK_MASK_64r;
        } else if (SOC_REG_IS_VALID(unit, BCAST_BLOCK_MASK_LO_64r)) {
            mask_reg[0] = BCAST_BLOCK_MASK_LO_64r;
            mask_reg[1] = IBCAST_BLOCK_MASK_LO_64r;
            mask_hi_reg[0] = BCAST_BLOCK_MASK_HI_64r;
            mask_hi_reg[1] = IBCAST_BLOCK_MASK_HI_64r;
        } else if (SOC_REG_IS_VALID(unit, BCAST_BLOCK_MASKr)) {
            mask_reg[0] = BCAST_BLOCK_MASKr;
            mask_reg[1] = IBCAST_BLOCK_MASKr;
        } else {
            return BCM_E_UNAVAIL;
        }
        break;
    case BCM_PORT_FLOOD_BLOCK_UNKNOWN_UCAST:
        if (SOC_MEM_IS_VALID(unit, UNKNOWN_UCAST_BLOCK_MASKm)) {
            mem = UNKNOWN_UCAST_BLOCK_MASKm;
            field = BLK_BITMAPf;
        } else if (SOC_REG_IS_VALID(unit, UNKNOWN_UCAST_BLOCK_MASK_64r)) {
            mask_reg[0] = UNKNOWN_UCAST_BLOCK_MASK_64r;
            mask_reg[1] = IUNKNOWN_UCAST_BLOCK_MASK_64r;
        } else if (SOC_REG_IS_VALID(unit, UNKNOWN_UCAST_BLOCK_MASK_LO_64r)) {
            mask_reg[0] = UNKNOWN_UCAST_BLOCK_MASK_LO_64r;
            mask_reg[1] = IUNKNOWN_UCAST_BLOCK_MASK_LO_64r;
            mask_hi_reg[0] = UNKNOWN_UCAST_BLOCK_MASK_HI_64r;
            mask_hi_reg[1] = IUNKNOWN_UCAST_BLOCK_MASK_HI_64r;
        } else if (SOC_REG_IS_VALID(unit, UNKNOWN_UCAST_BLOCK_MASKr)) {
            mask_reg[0] = UNKNOWN_UCAST_BLOCK_MASKr;
            mask_reg[1] = IUNKNOWN_UCAST_BLOCK_MASKr;
        } else {
            return BCM_E_UNAVAIL;
        }
        break;
    case BCM_PORT_FLOOD_BLOCK_UNKNOWN_MCAST:
        if (SOC_MEM_IS_VALID(unit, UNKNOWN_MCAST_BLOCK_MASKm)) {
            mem = UNKNOWN_MCAST_BLOCK_MASKm;
            field = BLK_BITMAPf;
        } else if (SOC_REG_IS_VALID(unit, UNKNOWN_MCAST_BLOCK_MASK_64r)) {
            mask_reg[0] = UNKNOWN_MCAST_BLOCK_MASK_64r;
            mask_reg[1] = IUNKNOWN_MCAST_BLOCK_MASK_64r;
        } else if (SOC_REG_IS_VALID(unit, UNKNOWN_MCAST_BLOCK_MASK_LO_64r)) {
            mask_reg[0] = UNKNOWN_MCAST_BLOCK_MASK_LO_64r;
            mask_reg[1] = IUNKNOWN_MCAST_BLOCK_MASK_LO_64r;
            mask_hi_reg[0] = UNKNOWN_MCAST_BLOCK_MASK_HI_64r;
            mask_hi_reg[1] = IUNKNOWN_MCAST_BLOCK_MASK_HI_64r;
        } else if (SOC_REG_IS_VALID(unit, UNKNOWN_MCAST_BLOCK_MASKr)) {
            mask_reg[0] = UNKNOWN_MCAST_BLOCK_MASKr;
            mask_reg[1] = IUNKNOWN_MCAST_BLOCK_MASKr;
        } else {
            return BCM_E_UNAVAIL;
        }
        break;
    case BCM_PORT_FLOOD_BLOCK_KNOWN_MCAST:
        if (SOC_MEM_IS_VALID(unit, KNOWN_MCAST_BLOCK_MASKm)) {
            mem = KNOWN_MCAST_BLOCK_MASKm;
            field = BLK_BITMAPf;
        } else if (SOC_REG_IS_VALID(unit, KNOWN_MCAST_BLOCK_MASK_64r)) {
            mask_reg[0] = KNOWN_MCAST_BLOCK_MASK_64r;
            mask_reg[1] = IKNOWN_MCAST_BLOCK_MASK_64r;
        } else if (SOC_REG_IS_VALID(unit, KNOWN_MCAST_BLOCK_MASK_LOr)) {
            mask_reg[0] = KNOWN_MCAST_BLOCK_MASK_LOr;
            mask_reg[1] = IKNOWN_MCAST_BLOCK_MASK_LOr;
            mask_hi_reg[0] = KNOWN_MCAST_BLOCK_MASK_HIr;
            mask_hi_reg[1] = IKNOWN_MCAST_BLOCK_MASK_HIr;
        } else if (SOC_REG_IS_VALID(unit, KNOWN_MCAST_BLOCK_MASKr)) {
            mask_reg[0] = KNOWN_MCAST_BLOCK_MASKr;
            mask_reg[1] = IKNOWN_MCAST_BLOCK_MASKr;
        } else {
            return BCM_E_UNAVAIL;
        }
        break;
    case BCM_PORT_FLOOD_BLOCK_ALL:
        if (SOC_MEM_IS_VALID(unit, ING_EGRMSKBMAPm)) {
            mem = ING_EGRMSKBMAPm;
            field = BITMAPf;
        } else if (SOC_REG_IS_VALID(unit, ING_EGRMSKBMAP_64r)) {
            mask_reg[0] = ING_EGRMSKBMAP_64r;
            mask_reg[1] = IING_EGRMSKBMAP_64r;
        } else if (SOC_REG_IS_VALID(unit, ING_EGRMSKBMAP_LOr)) {
            mask_reg[0] = ING_EGRMSKBMAP_LOr;
            mask_reg[1] = IING_EGRMSKBMAP_LOr;
            mask_hi_reg[0] = ING_EGRMSKBMAP_HIr;
            mask_hi_reg[1] = IING_EGRMSKBMAP_HIr;
        } else if (SOC_REG_IS_VALID(unit, ING_EGRMSKBMAPr)) {
            mask_reg[0] = ING_EGRMSKBMAPr;
            mask_reg[1] = IING_EGRMSKBMAPr;
        } else {
            return BCM_E_UNAVAIL;
        }
        break;
    default:
        return BCM_E_INTERNAL;
    }

    if (mem != INVALIDm) {
        BCM_IF_ERROR_RETURN
            (soc_mem_read(unit, mem, MEM_BLOCK_ANY, ingress_port, entry));
        soc_mem_pbmp_field_get(unit, mem, entry, field, &pbmp);
        if (!set_op) {
            *enable = SOC_PBMP_WORD_GET(pbmp, egress_port / 32) &
                (1 << (egress_port & 0x1f)) ? mode : 0;
            return BCM_E_NONE;
        }
        if (*enable & mode) {
            SOC_PBMP_PORT_ADD(pbmp, egress_port);
        } else {
            SOC_PBMP_PORT_REMOVE(pbmp, egress_port);
        }
        soc_mem_pbmp_field_set(unit, mem, entry, field, &pbmp);
        BCM_IF_ERROR_RETURN
            (soc_mem_write(unit, mem, MEM_BLOCK_ANY, ingress_port, entry));

        cpu_hg_index = SOC_IS_KATANA2(unit) ?
                       SOC_INFO(unit).cpu_hg_pp_port_index :
                       SOC_INFO(unit).cpu_hg_index;
        if (IS_CPU_PORT(unit, ingress_port) && cpu_hg_index != -1) {
            BCM_IF_ERROR_RETURN
                (soc_mem_read(unit, mem, MEM_BLOCK_ANY, cpu_hg_index, entry));
            soc_mem_pbmp_field_get(unit, mem, entry, field, &pbmp);
            if (*enable & mode) {
                SOC_PBMP_PORT_ADD(pbmp, egress_port);
            } else {
                SOC_PBMP_PORT_REMOVE(pbmp, egress_port);
            }
            soc_mem_pbmp_field_set(unit, mem, entry, field, &pbmp);
            BCM_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ANY, cpu_hg_index, entry));
        }
    } else {
        if (!IS_CPU_PORT(unit, ingress_port)) {
            if (IS_ST_PORT(unit, ingress_port)) {
                mask_reg[0] = INVALIDr;
                mask_hi_reg[0] = INVALIDr;
            } else {
                mask_reg[1] = INVALIDr;
                mask_hi_reg[1] = INVALIDr;
            }
        }

        for (index = 0; index < 2; index++) {
            if (soc_feature (unit, soc_feature_high_portcount_register)) {
                uint64      fval64, rval64;
                uint32      t_port;
                pbmp_t      curr_pbmp;

                /*
                *  pbmp reg split to multiple reg due to high port count
                *  example :
                *   - BCAST_BLOCK_MASK_64r was split to
                *      {BCAST_BLOCK_MASK_LO_64r + BCAST_BLOCK_MASK_HI_64r}
                *   - ING_EGRMSKBMAP_64r was split to
                *      {ING_EGRMSKBMAP_LOr + ING_EGRMSKBMAP_HIr}
                */
                BCM_PBMP_CLEAR(curr_pbmp);
                COMPILER_64_ZERO(fval64);
                COMPILER_64_ZERO(rval64);

                if (egress_port < 64) {
                    reg = mask_reg[index];
                    t_port = egress_port;
                } else {
                    reg = mask_hi_reg[index];
                    t_port = egress_port - 64;
                }
                field = BLK_BITMAPf;

                if (SOC_REG_IS_VALID(unit, reg)) {
                    BCM_IF_ERROR_RETURN(soc_reg_get(unit,
                            reg, ingress_port, 0, &rval64));

                    fval64 = soc_reg64_field_get(unit, reg, rval64, field);
                    SOC_PBMP_WORD_SET(curr_pbmp, 0, COMPILER_64_LO(fval64));
                    SOC_PBMP_WORD_SET(curr_pbmp, 1, COMPILER_64_HI(fval64));

                    if (!set_op) {
                        /* for GET */
                        *enable = SOC_PBMP_MEMBER(curr_pbmp, t_port) ? mode : 0;
                    } else {
                        /* for SET */
                        if (*enable & mode) {
                            SOC_PBMP_PORT_ADD(curr_pbmp, t_port);
                        } else {
                            SOC_PBMP_PORT_REMOVE(curr_pbmp, t_port);
                        }
                        COMPILER_64_SET(fval64,
                                SOC_PBMP_WORD_GET(curr_pbmp, 1),
                                SOC_PBMP_WORD_GET(curr_pbmp, 0));
                        soc_reg64_field_set(unit, reg,
                                &rval64, field, fval64);
                        BCM_IF_ERROR_RETURN(soc_reg_set(unit,
                                reg, ingress_port, 0, rval64));
                    }
                }
            } else {
                reg = mask_reg[index];
                if (reg == INVALIDr) {
                    continue;
                }
                BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg, ingress_port, 0, &rval));
                if (SOC_REG_IS_64(unit, reg)) {
                    if (egress_port < 32) {
                        if (soc_reg_field_valid(unit, reg, BLK_BITMAP_LOf)) {
                            field = BLK_BITMAP_LOf;
                        } else {
                            field = BLK_BITMAP_0f;
                        }
                    } else {
                        if (soc_reg_field_valid(unit, reg, BLK_BITMAP_HIf)) {
                            field = BLK_BITMAP_HIf;
                        } else {
                            field = BLK_BITMAP_1f;
                        }
                    }
                } else {
                    field = BLK_BITMAPf;
                }
                fval = soc_reg64_field32_get(unit, reg, rval, field);
                if (!set_op) {
                    *enable = fval & (1 << (egress_port & 0x1f)) ? mode : 0;
                    return BCM_E_NONE;
                }
                if (*enable & mode) {
                    fval |= 1 << (egress_port & 0x1f);
                } else {
                    fval &= ~(1 << (egress_port & 0x1f));
                }
                soc_reg64_field32_set(unit, reg, &rval, field, fval);
                BCM_IF_ERROR_RETURN(soc_reg_set(unit, reg, ingress_port, 0, rval));
            }
        }
    }

    return BCM_E_NONE;
}

#if defined(BCM_RAPTOR_SUPPORT)
/*
 * Function:
 *      _bcm_port_flood_block_hi_set
 * Purpose:
 *      Enable/disable port membership in one of the egress block registers
 * Parameters:
 *      unit
 *      ingress_port    - ingress port on which the egress blocking
 *                        will be enabled
 *      egress_port     - port for which egress will be blocked
 *      reg             - egress block register.
 *      enable          - Whether blocking should be enabled or disabled
 * Returns:
 *      BCM_E_UNAVAIL   - This chip does not support this feature
 *      BCM_E_NONE
 * Notes:
 *      'reg' must be one of BCAST_BLOCK_MASKr,
 *      UNKNOWN_UCAST_BLOCK_MASKr, UNKNOWN_MCAST_BLOCK_MASKr, or
 *      their Stack port variants.
 *
 *      This function is a helper for bcm_port_flood_block_set()
 */

STATIC int
_bcm_port_flood_block_hi_set(int unit,
                              bcm_port_t ingress_port, bcm_port_t egress_port,
                              soc_reg_t reg, uint32 enable)
{
    uint32 rval;
    pbmp_t pbmp;
    uint32 pbmp32;
    uint32 bitmap32, obitmap32;

    if (!soc_feature(unit, soc_feature_register_hi)) {
        return BCM_E_UNAVAIL;
    }

    SOC_PBMP_PORT_SET(pbmp, egress_port);
    pbmp32 = SOC_PBMP_WORD_GET(pbmp, 1);

    if (!pbmp32) {
        return BCM_E_NONE;
    }

    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, ingress_port, 0, &rval));

    obitmap32 = bitmap32 = soc_reg_field_get(unit, reg, rval, BLK_BITMAPf);
    if (enable) {
        bitmap32 |= pbmp32;
    } else {
        bitmap32 &= ~pbmp32;
    }

    if (obitmap32 != bitmap32) {
        soc_reg_field_set(unit, reg, &rval, BLK_BITMAPf, bitmap32);
        return soc_reg32_set(unit, reg, ingress_port, 0, rval);
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_flood_block_hi_get
 * Purpose:
 *      Retrieve the current state egress block state on a port
 * Parameters:
 *      unit
 *      ingress_port    - ingress_port for which the state will be retreived
 *      egress_port     - port for which the egress blocking state
 *                        on ingress_port is requested
 *      reg             - block mask register
 *      enable          - (OUT) receives the block state
 * Returns:
 *      BCM_E_UNAVAIL   - Feature unavailable on this chip
 *      BCM_E_NONE
 * Notes:
 *      See _bcm_port_flood_block_hi_set()
 *      This is a helper function for bcm_port_flood_block_get()
 */

STATIC int
_bcm_port_flood_block_hi_get(int unit,
                          bcm_port_t ingress_port, bcm_port_t egress_port,
                          soc_reg_t reg, uint32 *enable)
{
    uint32 rval;
    pbmp_t pbmp;
    uint32 pbmp32;
    uint32 bitmap32;

    if (!soc_feature(unit, soc_feature_register_hi)) {
        return BCM_E_UNAVAIL;
    }

    SOC_PBMP_PORT_SET(pbmp, egress_port);
    pbmp32 = SOC_PBMP_WORD_GET(pbmp, 1);
    if (!pbmp32) {
        *enable = 0;
        return BCM_E_NONE;
    }

    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, reg, ingress_port, 0, &rval));

    bitmap32 = soc_reg_field_get(unit, reg, rval, BLK_BITMAPf);
    *enable = (pbmp32 & bitmap32) ? 1 : 0;

    return BCM_E_NONE;
}
#endif /* BCM_RAPTOR_SUPPORT */

/*
 * Function:
 *      bcm_port_flood_block_set
 * Purpose:
 *      Set selective per-port blocking of flooded VLAN traffic
 * Parameters:
 *      unit            - unit number
 *      ingress_port    - Port traffic is ingressing
 *      egress_port     - Port for which the traffic should be blocked.
 *      flags           - Specifies the type of traffic to block
 * Returns:
 *      BCM_E_UNAVAIL   - Functionality not available
 *      BCM_E_NONE
 *
 * NOTE:  For fabrics, this changes egrmskbmap; as a result, all traffic
 * will be blocked (or enabled) to the given egress port, including
 * unicast traffic.
 */

int
bcm_esw_port_flood_block_set(int unit,
                         bcm_port_t ingress_port, bcm_port_t egress_port,
                         uint32 flags)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, ingress_port,
                                                     &ingress_port));
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, egress_port,
                                                     &egress_port));

#if defined(BCM_XGS12_FABRIC_SUPPORT)
    /* See note above */
    if (SOC_IS_XGS12_FABRIC(unit)) {
        uint32  ports, oports;
        pbmp_t  pbmp;

        if (!IS_HG_PORT(unit, ingress_port)) {
            return BCM_E_PORT;
        }

        SOC_IF_ERROR_RETURN
            (READ_ING_EGRMSKBMAPr(unit, ingress_port, &ports));
        oports = ports;
        SOC_PBMP_CLEAR(pbmp);
        SOC_PBMP_WORD_SET(pbmp, 0, ports);
        if (flags) {
            SOC_PBMP_PORT_REMOVE(pbmp, egress_port);
        } else {
            SOC_PBMP_PORT_ADD(pbmp, egress_port);
        }
        ports = SOC_PBMP_WORD_GET(pbmp, 0);
        if (ports != oports) {
            SOC_IF_ERROR_RETURN
                (WRITE_ING_EGRMSKBMAPr(unit, ingress_port, ports));
        }
        return BCM_E_NONE;
    }
#endif /* BCM_XGS12_FABRIC_SUPPORT */

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAVEN_SUPPORT) \
        || defined(BCM_BRADLEY_SUPPORT)
    if (SOC_IS_FIREBOLT2(unit) || SOC_IS_RAVEN(unit)||
        SOC_IS_HBX(unit) || SOC_IS_TRX(unit) || SOC_IS_HAWKEYE(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_port_flood_block_op(unit, TRUE, ingress_port, egress_port,
                                      BCM_PORT_FLOOD_BLOCK_ALL, &flags));
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_RAVEN_SUPPORT || \
          BCM_BRADLEY_SUPPORT */

    BCM_IF_ERROR_RETURN
        (_bcm_port_flood_block_op(unit, TRUE, ingress_port, egress_port,
                                  BCM_PORT_FLOOD_BLOCK_BCAST, &flags));

    BCM_IF_ERROR_RETURN
        (_bcm_port_flood_block_op(unit, TRUE, ingress_port, egress_port,
                                  BCM_PORT_FLOOD_BLOCK_UNKNOWN_MCAST, &flags));

    /*
     * For some devices like RAVEN , which do not have support for
     * blocking KNOWN_MCAST , continue processing.
     */
    BCM_IF_ERROR_NOT_UNAVAIL_RETURN
        (_bcm_port_flood_block_op(unit, TRUE, ingress_port, egress_port,
                                  BCM_PORT_FLOOD_BLOCK_KNOWN_MCAST, &flags));

    BCM_IF_ERROR_RETURN
        (_bcm_port_flood_block_op(unit, TRUE, ingress_port, egress_port,
                                  BCM_PORT_FLOOD_BLOCK_UNKNOWN_UCAST, &flags));

    /*
     * Handle the devices with > 32 ports that use _HI convention
     */
#if defined(BCM_RAPTOR_SUPPORT)
       if (soc_feature(unit, soc_feature_register_hi)){
           soc_reg_t reg;
           uint32 enable;
            reg = IS_ST_PORT(unit, ingress_port) ?
                IUNKNOWN_UCAST_BLOCK_MASK_HIr : UNKNOWN_UCAST_BLOCK_MASK_HIr;
            enable = flags & BCM_PORT_FLOOD_BLOCK_UNKNOWN_UCAST;
            BCM_IF_ERROR_RETURN
                (_bcm_port_flood_block_hi_set(unit, ingress_port, egress_port,
                                              reg, enable));

            reg = IS_ST_PORT(unit, ingress_port) ?
                IUNKNOWN_MCAST_BLOCK_MASK_HIr : UNKNOWN_MCAST_BLOCK_MASK_HIr;
            enable = flags & BCM_PORT_FLOOD_BLOCK_UNKNOWN_MCAST;
            BCM_IF_ERROR_RETURN
                (_bcm_port_flood_block_hi_set(unit, ingress_port, egress_port,
                                              reg, enable));

            reg = IS_ST_PORT(unit, ingress_port) ?
                IBCAST_BLOCK_MASK_HIr : BCAST_BLOCK_MASK_HIr;
            enable = flags & BCM_PORT_FLOOD_BLOCK_BCAST;
            BCM_IF_ERROR_RETURN
                (_bcm_port_flood_block_hi_set(unit, ingress_port, egress_port,
                                              reg, enable));
       }
#endif /* BCM_RAPTOR_SUPPORT */

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_flood_block_get
 * Purpose:
 *      Get the current per-port flood block settings
 * Parameters:
 *      unit            - unit number
 *      ingress_port    - Port traffic is ingressing
 *      egress_port     - Port for which the traffic would be blocked
 *      flags           - (OUT) Returns the current settings
 * Returns:
 *      BCM_E_UNAVAIL   - Functionality not available
 *      BCM_E_NONE
 */

int
bcm_esw_port_flood_block_get(int unit,
                         bcm_port_t ingress_port, bcm_port_t egress_port,
                         uint32 *flags)
{
    uint32 enable;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, ingress_port,
                                                     &ingress_port));
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, egress_port,
                                                     &egress_port));

    *flags = 0;

#if defined(BCM_XGS12_FABRIC_SUPPORT)
    if (SOC_IS_XGS12_FABRIC(unit)) {
        uint32  ports;
        pbmp_t  pbmp;

        if (!IS_HG_PORT(unit, ingress_port)) {
            return BCM_E_PORT;
        }

        SOC_IF_ERROR_RETURN
            (READ_ING_EGRMSKBMAPr(unit, ingress_port, &ports));
        SOC_PBMP_CLEAR(pbmp);
        SOC_PBMP_WORD_SET(pbmp, 0, ports);
        if (!SOC_PBMP_MEMBER(pbmp, egress_port)) {
            *flags = -1;        
        }
        return BCM_E_NONE;
    }
#endif

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAVEN_SUPPORT) \
        || defined(BCM_BRADLEY_SUPPORT)
    if (SOC_IS_FIREBOLT2(unit) || SOC_IS_RAVEN(unit)||
        SOC_IS_HBX(unit) || SOC_IS_TRX(unit) || SOC_IS_HAWKEYE(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_port_flood_block_op(unit, FALSE, ingress_port, egress_port,
                                      BCM_PORT_FLOOD_BLOCK_ALL, &enable));
        *flags |= enable;
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_RAVEN_SUPPORT || BCM_BRADLEY_SUPPORT */

    BCM_IF_ERROR_RETURN
        (_bcm_port_flood_block_op(unit, FALSE, ingress_port, egress_port,
                                  BCM_PORT_FLOOD_BLOCK_BCAST, &enable));
    *flags |= enable;

    BCM_IF_ERROR_RETURN
        (_bcm_port_flood_block_op(unit, FALSE, ingress_port, egress_port,
                                  BCM_PORT_FLOOD_BLOCK_UNKNOWN_MCAST,
                                  &enable));
    *flags |= enable;

    /*
     * For some devices like RAVEN , which do not have support for
     * blocking KNOWN_MCAST , continue processing.
     */
    BCM_IF_ERROR_NOT_UNAVAIL_RETURN
        (_bcm_port_flood_block_op(unit, FALSE, ingress_port, egress_port,
                                  BCM_PORT_FLOOD_BLOCK_KNOWN_MCAST,
                                  &enable));
    *flags |= enable;

    BCM_IF_ERROR_RETURN
        (_bcm_port_flood_block_op(unit, FALSE, ingress_port, egress_port,
                                  BCM_PORT_FLOOD_BLOCK_UNKNOWN_UCAST,
                                  &enable));
    *flags |= enable;

#if defined(BCM_RAPTOR_SUPPORT)
    if (soc_feature(unit, soc_feature_register_hi)){
        soc_reg_t reg;
        reg = IS_ST_PORT(unit, ingress_port) ?
            IBCAST_BLOCK_MASK_HIr : BCAST_BLOCK_MASK_HIr;
        BCM_IF_ERROR_RETURN
            (_bcm_port_flood_block_hi_get(unit, ingress_port, egress_port,
                                       reg, &enable));
        *flags |= (enable) ? BCM_PORT_FLOOD_BLOCK_BCAST : 0;

        reg = IS_ST_PORT(unit, ingress_port) ?
            IUNKNOWN_MCAST_BLOCK_MASK_HIr : UNKNOWN_MCAST_BLOCK_MASK_HIr;
        BCM_IF_ERROR_RETURN
            (_bcm_port_flood_block_hi_get(unit, ingress_port, egress_port,
                                       reg, &enable));
        *flags |= (enable) ? BCM_PORT_FLOOD_BLOCK_UNKNOWN_MCAST : 0;

        reg = IS_ST_PORT(unit, ingress_port) ?
            IUNKNOWN_UCAST_BLOCK_MASK_HIr : UNKNOWN_UCAST_BLOCK_MASK_HIr;
        BCM_IF_ERROR_RETURN
            (_bcm_port_flood_block_hi_get(unit, ingress_port, egress_port,
                                       reg, &enable));
        *flags |= (enable) ? BCM_PORT_FLOOD_BLOCK_UNKNOWN_UCAST : 0;
    }
#endif /* BCM_RAPTOR_SUPPORT */

    return BCM_E_NONE;
}

/*
 * Per-port leaky bucket ingress and egress rate limiting
 *
 * Granularity is in kbits/sec and a rate of 0 disables rate limiting.
 * The max burst size is set in kbits.
 */

/*
 * Function:
 *      bcm_port_rate_egress_set
 * Purpose:
 *      Set egress rate limiting parameters
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      kbits_sec - Rate in kilobits (1000 bits) per second.
 *                      Rate of 0 disables rate limiting.
 *      kbits_burst - Maximum burst size in kilobits (1000 bits).
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_rate_egress_set(int unit,
                             bcm_port_t port,
                             uint32 kbits_sec,
                             uint32 kbits_burst)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!soc_feature(unit, soc_feature_egress_metering)) {
        return BCM_E_UNAVAIL;
    } else {
        return mbcm_driver[unit]->mbcm_port_rate_egress_set(unit, port,
                                                            kbits_sec,
                                                            kbits_burst,
                                                            _BCM_PORT_RATE_BYTE_MODE);
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_rate_egress_pps_set
 * Purpose:
 *      Set egress rate limiting parameter in packet mode.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      pps -  Rate in pps
 *             Rate of 0 disables rate limiting.
 *      burst - Maximum burst size
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_rate_egress_pps_set(int unit,
                             bcm_port_t port,
                             uint32 pps,
                             uint32 burst)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!soc_feature(unit, soc_feature_egress_metering)) {
        return BCM_E_UNAVAIL;
    } else {
        return mbcm_driver[unit]->mbcm_port_rate_egress_set(unit, port,
                                                            pps,
                                                            burst,
                                                            _BCM_PORT_RATE_PPS_MODE);
    }

    return BCM_E_NONE;
}


/*
 * Function:
 *      bcm_port_rate_egress_get
 * Purpose:
 *      Get egress rate limiting parameters
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      kbits_sec - (OUT) Rate in kilobits (1000 bits) per second, or
 *                        zero if rate limiting is disabled.
 *      kbits_burst - (OUT) Maximum burst size in kilobits (1000 bits).
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_rate_egress_get(int unit,
                             bcm_port_t port,
                             uint32 *kbits_sec,
                             uint32 *kbits_burst)
{
    uint32 flags = 0;
    int    rv = BCM_E_NONE;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!soc_feature(unit, soc_feature_egress_metering)) {
        return BCM_E_UNAVAIL;
    } else {
        rv = mbcm_driver[unit]->mbcm_port_rate_egress_get(unit, port,
                                                            kbits_sec,
                                                            kbits_burst,
                                                            &flags);
    }

    if (BCM_SUCCESS(rv)) {
        if (flags == _BCM_PORT_RATE_BYTE_MODE) {
            return BCM_E_NONE;
        } else {
            /* Set as pps; kbits cannot be returned */
            return BCM_E_CONFIG;
        }
    }

    return rv;
}

/*
 * Function:
 *      bcm_port_rate_egress_pps_get
 * Purpose:
 *      Get egress rate limiting parameter in packet mode.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      pps -  (OUT) Rate in pps
 *                   0 if rate limiting is disabled
 *      burst -(OUT) burst size
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_rate_egress_pps_get(int unit,
                             bcm_port_t port,
                             uint32 *pps,
                             uint32 *burst)
{
    uint32 flags = 0;
    int    rv = BCM_E_NONE;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!soc_feature(unit, soc_feature_egress_metering)) {
        return BCM_E_UNAVAIL;
    } else {
        rv = mbcm_driver[unit]->mbcm_port_rate_egress_get(unit, port,
                                                            pps,
                                                            burst,
                                                            &flags);
    }

    if (BCM_SUCCESS(rv)) {
        if (flags == _BCM_PORT_RATE_PPS_MODE) {
            return BCM_E_NONE;
        } else {
            /* Set as kbits; pps cannot be returned */
            return BCM_E_CONFIG;
        }
    }
    return rv;
}

/*
 * Function:
 *      bcm_port_rate_ingress_set
 * Purpose:
 *      Set ingress rate limiting parameters
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      kbits_sec - Rate in kilobits (1000 bits) per second.
 *                  Rate of 0 disables rate limiting.
 *      kbits_burst - Maximum burst size in kilobits (1000 bits).
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_rate_ingress_set(int unit,
                              bcm_port_t port,
                              uint32 kbits_sec,
                              uint32 kbits_burst)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (SOC_IS_XGS3_SWITCH(unit)) {
        /*
         * Use port-based ingress metering function.
         * Enabling rate-based ingress metering on the Firebolt
         * will also enable rate-based pause frames on this port.
         */
        return bcm_xgs3_port_rate_ingress_set(unit, port, kbits_sec,
                                              kbits_burst);
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT */

    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_port_rate_ingress_get
 * Purpose:
 *      Get ingress rate limiting parameters
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      kbits_sec - (OUT) Rate in kilobits (1000 bits) per second, or
 *                        zero if rate limiting is disabled.
 *      kbits_burst - (OUT) Maximum burst size in kilobits (1000 bits).
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_rate_ingress_get(int unit,
                              bcm_port_t port,
                              uint32 *kbits_sec,
                              uint32 *kbits_burst)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!kbits_sec || !kbits_burst) {
        return BCM_E_PARAM;
    }

#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (SOC_IS_XGS3_SWITCH(unit)) {
       /* Use port-based ingress metering function */
        return bcm_xgs3_port_rate_ingress_get(unit, port, kbits_sec,
                                            kbits_burst);
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT */

    *kbits_sec = 0;
    *kbits_burst = 0;

    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_port_rate_pause_set
 * Purpose:
 *      Set ingress rate limiting pause frame control parameters
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      kbits_pause - Pause threshold in kbits (1000 bits).
 *              A value of zero disables the pause/resume mechanism.
 *      kbits_resume - Resume threshold in kbits (1000 bits).
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      This interface applies only when port ingress rate limiting
 *      is active.  Currently, only the 566x supports this feature.
 *
 *      If the maximum of bits that could be received before dropping a
 *      frame falls below the kbits_pause, a pause frame is sent.
 *      A resume frame will be sent once it becomes possible to receive
 *      kbits_resume bits of data without dropping.
 */

int
bcm_esw_port_rate_pause_set(int unit,
                            bcm_port_t port,
                            uint32 kbits_pause,
                            uint32 kbits_resume)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef BCM_FIREBOLT_SUPPORT
    /*
     * For Firebolt, rate-based pause frames are generated as
     * a result of rate-based metering. As such, their behavior
     * is not directly controllable, but may be read.
     * see bcm_port_rate_pause_get().
     */
#endif /* BCM_FIREBOLT_SUPPORT */
    /* Otherwise, not supported  */
    return (kbits_pause == 0) ? BCM_E_NONE : BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_port_rate_pause_get
 * Purpose:
 *      Get ingress rate limiting pause frame control parameters
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      kbits_pause - (OUT) Pause threshold in kbits (1000 bits).
 *              Zero indicates the pause/resume mechanism is disabled.
 *      kbits_resume - (OUT) Resume threshold in kbits (1000 bits).
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_port_rate_pause_get(int unit,
                            bcm_port_t port,
                            uint32 *kbits_pause,
                            uint32 *kbits_resume)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined(BCM_HGPROXY_COE_SUPPORT)
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        (soc_feature(unit, soc_feature_channelized_switching))) &&
        BCM_GPORT_IS_SET(port) &&
        _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
        return BCM_E_PORT;
    } else
#endif /* BCM_HGPROXY_COE_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT)
    if (BCM_GPORT_IS_SET(port) &&
        _BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit, port)) {
        return BCM_E_PORT;
    }
#endif
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef BCM_MONTEREY_SUPPORT
    if (SOC_IS_MONTEREY(unit)) {
        *kbits_pause = 0;
        *kbits_resume = 0;
        return BCM_E_UNAVAIL;
    } else
#endif
#ifdef BCM_TOMAHAWK_SUPPORT
    if (SOC_IS_TOMAHAWKX(unit) || SOC_IS_TRIDENT3X(unit)) {
        *kbits_pause = 0;
        *kbits_resume = 0;
        return BCM_E_UNAVAIL;
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        return bcm_td2_port_rate_pause_get(unit, port, kbits_pause,
                                           kbits_resume);
    } else
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIUMPH_SUPPORT
    if (SOC_IS_TR_VL(unit) && !SOC_IS_HURRICANEX(unit) &&
        !SOC_IS_GREYHOUND(unit) && !SOC_IS_GREYHOUND2(unit)) {
        return bcm_tr_port_rate_pause_get(unit, port, kbits_pause,
                                          kbits_resume);
    }
#endif /* BCM_TRIUMPH_SUPPORT */
#ifdef BCM_FIREBOLT_SUPPORT
    if (SOC_IS_FBX(unit)) {
        return bcm_fb_port_rate_pause_get(unit, port, kbits_pause,
                                          kbits_resume);
    }
#endif /* BCM_FIREBOLT_SUPPORT */
    /* Otherwise, not supported */
    *kbits_pause = 0;
    *kbits_resume = 0;
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_port_sample_rate_set
 * Purpose:
 *      Control the sampling of packets ingressing or egressing a port
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      ingress_rate - Every 1/ingress_rate packets will be sampled
 *              0 indicates no sampling
 *              1 indicates sampling all packets
 *      egress_rate - Every 1/egress_rate packets will be sampled
 *              0 indicates no sampling
 *              1 indicates sampling all packets
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      This API is a building block for supporting sFlow (RFC 3176)
 */

int
bcm_esw_port_sample_rate_set(int unit, bcm_port_t port,
                         int ingress_rate, int egress_rate)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /*
     * IMPLEMENTATION NOTES
     *
     * ingress_rate maps into the per port SFLOW_ING_THRESHOLD reg:
     *  if (ingress_rate <= 0) {
     *          SFLOW_ING_THRESHOLD.ENABLE=0
     *          SFLOW_ING_THRESHOLD.THRESHOLD=0
     *  } else {
     *          SFLOW_ING_THRESHOLD.ENABLE=1
     *          SFLOW_ING_THRESHOLD.THRESHOLD=0xffff/ingress_rate
     *  }
     * egress_rate maps into the per port SFLOW_EGR_THRESHOLD reg:
     *  if (egress_rate <= 0) {
     *          SFLOW_EGR_THRESHOLD.ENABLE=0
     *          SFLOW_EGR_THRESHOLD.THRESHOLD=0
     *  } else {
     *          SFLOW_EGR_THRESHOLD.ENABLE=1
     *          SFLOW_EGR_THRESHOLD.THRESHOLD=0xffff/egress_rate
     *  }
     *
     * bcmSwitchCpuSamplePrio maps to CPU_CONTROL_2.CPU_SFLOW_PRIORITY
     * bcmSwitchSampleIngressRandomSeed maps to SFLOW_ING_RAND_SEED.SEED
     * bcmSwitchSampleEgressRandomSeed maps to SFLOW_EGR_RAND_SEED.SEED
     *
     * There are two related RX reason codes defined in <bcm/rx.h>
     *  BCM_RX_PR_SAMPLE_SRC
     *  BCM_RX_PR_SAMPLE_DST
     */

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    if (ingress_rate < 0 || egress_rate < 0) {
        return BCM_E_PARAM;
    }

#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (SOC_IS_XGS3_SWITCH(unit)) {
        return bcm_xgs3_port_sample_rate_set(unit, port,
                                             ingress_rate, egress_rate);
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT */

    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_port_sample_rate_get
 * Purpose:
 *      Get the sampling of packets ingressing or egressing a port
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      ingress_rate - Every 1/ingress_rate packets will be sampled
 *              0 indicates no sampling
 *              1 indicates sampling all packets
 *      egress_rate - Every 1/egress_rate packets will be sampled
 *              0 indicates no sampling
 *              1 indicates sampling all packets
 * Returns:
 *      BCM_E_UNIT
 *      BCM_E_PARAM
 *      BCM_E_UNAVAIL
 *      BCM_E_XXX
 * Notes:
 *      This API is a building block for supporting sFlow (RFC 3176)
 */

int
bcm_esw_port_sample_rate_get(int unit, bcm_port_t port,
                         int *ingress_rate, int *egress_rate)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (ingress_rate == NULL  || egress_rate == NULL) {
        return BCM_E_PARAM;
    }

#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (SOC_IS_XGS3_SWITCH(unit)) {
        return bcm_xgs3_port_sample_rate_get(unit, port,
                                           ingress_rate, egress_rate);
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT */


    return BCM_E_UNAVAIL;
}

#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
#ifdef BCM_WARM_BOOT_SUPPORT
STATIC int
_bcm_esw_sflow_counter_wb_recover(int unit, soc_mem_t mem)
{
    int idx_min, idx_max, i, id, rv = 0;
    soc_counter_non_dma_t *non_dma = NULL;
    soc_control_t *soc;
    uint32 count = 0, subset_ct = 0, sflow_enable = 0;
    uint8 *sflow_tbl_chunk = NULL;
    void *sflow_entry;

    soc = SOC_CONTROL(unit);

    idx_min = soc_mem_index_min(unit, mem);
    idx_max = soc_mem_index_max(unit, mem);
    sflow_tbl_chunk = soc_cm_salloc(unit, SOC_MEM_TABLE_BYTES(unit, mem),
                        "sFlow Ingress Data Source table buffer");
    if (sflow_tbl_chunk == NULL) {
        return BCM_E_MEMORY;
    }

    /* Read Ingress rate data table entries */
    sal_memset(sflow_tbl_chunk, 0, SOC_MEM_TABLE_BYTES(unit, mem));
    rv = soc_mem_read_range(unit, mem, MEM_BLOCK_ANY, idx_min, idx_max,
                            sflow_tbl_chunk);
    if (SOC_FAILURE(rv)) {
        soc_cm_sfree(unit, sflow_tbl_chunk);
        return rv;
    }

    if (mem == SFLOW_ING_DATA_SOURCEm) {
        id = SOC_COUNTER_NON_DMA_SFLOW_ING_PKT;
    } else {
        id = SOC_COUNTER_NON_DMA_SFLOW_FLEX_PKT;
    }

    for(i = idx_min; i < idx_max; i++) {
        sflow_entry = soc_mem_table_idx_to_pointer(unit, mem, void *,
                                                   sflow_tbl_chunk, i);
        sflow_enable = soc_mem_field32_get(unit, mem, sflow_entry, ENABLEf);

        if (sflow_enable) {
            non_dma = &soc->counter_non_dma[id - SOC_COUNTER_NON_DMA_START];
            /* Do PACKET_CTRf and BYTE_CTRf sequentially. Hence 2x loop */
            subset_ct = non_dma->extra_ctr_ct << 1;
            non_dma->flags |= _SOC_COUNTER_NON_DMA_VALID;
            non_dma = non_dma->extra_ctrs;

            do {
                non_dma->flags |= _SOC_COUNTER_NON_DMA_VALID;
                /* BYTE_CTRf not currently supported */
                count += 2;
                non_dma += 2;
            } while ((count < subset_ct));
            break;
        }
    }

    soc_cm_sfree(unit, sflow_tbl_chunk);
    return BCM_E_NONE;
}

/**
 * Function:
 *      _bcm_esw_sflow_wb_recover
 * Purpose:
 *      sFlow Warmboot Recovery
 * Parameters:
 *      unit - (IN) Unit number
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_sflow_wb_recover(int unit) {
    int rv = 0;

    if (soc_feature(unit, soc_feature_sflow_ing_mem)) {
        rv = _bcm_esw_sflow_counter_wb_recover(unit, SFLOW_ING_DATA_SOURCEm);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
    }

    if (soc_feature(unit, soc_feature_sflow_flex)) {
        rv = _bcm_esw_sflow_counter_wb_recover(unit,
                SFLOW_ING_FLEX_DATA_SOURCEm);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
    }

    return BCM_E_NONE;
}
#endif /* BCM_WARM_BOOT_SUPPORT */
#endif /* BCM_TOMAHAWK_SUPPORT */

/*
 * Double Tagging
 */

/*
 * Function:
 *      bcm_port_dtag_mode_set
 * Description:
 *      Set the double-tagging mode of a port.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      mode - Double-tagging mode, one of:
 *              BCM_PORT_DTAG_MODE_NONE            No double tagging
 *              BCM_PORT_DTAG_MODE_INTERNAL        Service Provider port
 *              BCM_PORT_DTAG_MODE_EXTERNAL        Customer port
 *              BCM_PORT_DTAG_REMOVE_EXTERNAL_TAG  Remove customer tag
 *              BCM_PORT_DTAG_ADD_EXTERNAL_TAG     Add customer tag
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      BCM_PORT_DTAG_MODE_INTERNAL is for service provider ports.
 *              A tag will be added if the packet does not already
 *              have the internal TPID (see bcm_port_tpid_set below).
 *              Internally this sets DT_MODE and clears IGNORE_TAG.
 *      BCM_PORT_DTAG_MODE_EXTERNAL is for customer ports.
 *              The service provider TPID will always be added
 *              (see bcm_port_tpid_set below).
 *              Internally this sets DT_MODE and sets IGNORE_TAG.
 *      On some chips, such as BCM5665, double-tag enable is a system-wide
 *              setting rather than a port setting, so enabling double-
 *              tagging on one port may enable it on all ports.
 */

int
bcm_esw_port_dtag_mode_set(int unit, bcm_port_t port, int mode)
{
#ifdef BCM_FIREBOLT_SUPPORT
    int         dt_mode, ignore_tag;
#endif
    int         dt_mode_mask;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    /* Skip PORT_SWITCHED_CHECK for Higig lookup (for q-in-q proxy) */
    if (!(IS_ST_PORT(unit, port) &&
          soc_feature(unit, soc_feature_higig_lookup))) {
        PORT_SWITCHED_CHECK(unit, port);
    }

    dt_mode_mask = BCM_PORT_DTAG_MODE_INTERNAL |
        BCM_PORT_DTAG_MODE_EXTERNAL;

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAVEN_SUPPORT) || defined(BCM_TRX_SUPPORT)
    if (SOC_IS_FIREBOLT2(unit) || SOC_IS_RAVEN(unit) || \
        SOC_IS_HAWKEYE(unit) || SOC_IS_TRX(unit)) {
        if (mode & ~(BCM_PORT_DTAG_MODE_INTERNAL |
                     BCM_PORT_DTAG_MODE_EXTERNAL |
                     BCM_PORT_DTAG_REMOVE_EXTERNAL_TAG |
                     BCM_PORT_DTAG_ADD_EXTERNAL_TAG)) {
            return BCM_E_UNAVAIL;
        }

        if (IS_ST_PORT(unit, port)) {
            /* Addition or removal of two tags is not supported on
             * Higig / Higig Lite ports.
             */
            if (mode & BCM_PORT_DTAG_ADD_EXTERNAL_TAG ||
                mode & BCM_PORT_DTAG_REMOVE_EXTERNAL_TAG) {
                return BCM_E_PARAM;
            }
        }

        /* Removal of two tags should be enable only for UNI egress ports. */
        if (mode == (BCM_PORT_DTAG_MODE_INTERNAL |
                     BCM_PORT_DTAG_REMOVE_EXTERNAL_TAG)) {
            return BCM_E_PARAM;
        }

#ifdef BCM_TRX_SUPPORT
        if (SOC_IS_TRX(unit)) {
            if (!soc_feature(unit, soc_feature_vlan_action)) {
                return BCM_E_UNAVAIL;
            }
            return  _bcm_trx_port_dtag_mode_set(unit, port, mode);
        }
#endif
    } else
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_RAVEN_SUPPORT || BCM_TRX_SUPPORT */
    if (0 != (mode & ~dt_mode_mask)) {
        /* Some devices do not support the add/remove tag options */
        return BCM_E_UNAVAIL;
    }

#ifdef BCM_FIREBOLT_SUPPORT
    switch (mode & dt_mode_mask) {
      case BCM_PORT_DTAG_MODE_NONE:
          dt_mode = 0;
          ignore_tag = 0;
          break;
      case BCM_PORT_DTAG_MODE_INTERNAL:
          dt_mode = 1;
          ignore_tag = 0;
          break;
      case BCM_PORT_DTAG_MODE_EXTERNAL:
          dt_mode = 1;
          ignore_tag = 1;
          break;
      default:
          return BCM_E_PARAM;
    }

    if (SOC_IS_FBX(unit)) {
        return _bcm_fb_port_dtag_mode_set(unit, port, mode,
                                          dt_mode, ignore_tag);
    }
#endif
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_port_dtag_mode_get
 * Description:
 *      Return the current double-tagging mode of a port.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      mode - (OUT) Double-tagging mode
 * Return Value:
 *      BCM_E_XXX
 */

int
bcm_esw_port_dtag_mode_get(int unit, bcm_port_t port, int *mode)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    /* Skip PORT_SWITCHED_CHECK for Higig lookup (for q-in-q proxy) */
    if (!(IS_ST_PORT(unit, port) &&
          soc_feature(unit, soc_feature_higig_lookup))) {
        PORT_SWITCHED_CHECK(unit, port);
    }

    if (mode == NULL) {
        return BCM_E_PARAM;
    }

#ifdef BCM_TRX_SUPPORT
    if (SOC_IS_TRX(unit)) {
        *mode = PORT(unit, port).dtag_mode;
        return BCM_E_NONE;
    }
#endif

#ifdef BCM_FIREBOLT_SUPPORT
    if (SOC_IS_FBX(unit)) {
        return _bcm_fb_port_dtag_mode_get(unit, port, mode);
    }
#endif

    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      _bcm_esw_mod_port_tpid_set
 * Description:
 *      Set the Tag Protocol ID for a (module, port).
 * Parameters:
 *      unit - Device number
 *      mod  - Module ID
 *      port - Port number
 *      tpid - Tag Protocol ID
 * Return Value:
 *      BCM_E_XXX
 */
STATIC int
_bcm_esw_mod_port_tpid_set(int unit, bcm_module_t mod, bcm_port_t port,
        uint16 tpid)
{
#ifdef BCM_HURRICANE3_SUPPORT
    if (SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
        return _bcm_hr3_mod_port_tpid_set(unit, mod, port, tpid);
    } else
#endif /* BCM_HURRICANE3_SUPPORT */
#ifdef BCM_TRIDENT_SUPPORT
    {
        return _bcm_td_mod_port_tpid_set(unit, mod, port, tpid);
    }
#endif /* BCM_TRIDENT_SUPPORT */
    return BCM_E_UNAVAIL;
}

#if defined(BCM_MONTEREY_SUPPORT)
STATIC
void bcm_port_inner_tpid_obm_set(int unit, bcm_port_t port, uint16 tpid)
{
   uint32 rval32 = 0;
   int obm, pgw, pgw_inst;
   soc_info_t  *si;
   soc_reg_t reg;
   static const soc_reg_t obm_inner_tpid_regs[] = {
        IDB_OBM0_INNER_TPIDr, IDB_OBM1_INNER_TPIDr,
        IDB_OBM2_INNER_TPIDr, IDB_OBM3_INNER_TPIDr,
        IDB_OBM4_INNER_TPIDr, IDB_OBM5_INNER_TPIDr,
        IDB_OBM6_INNER_TPIDr, IDB_OBM7_INNER_TPIDr
    };
    if ((port < 1) || (port > 64)) {
        return;
    }
    si = &SOC_INFO(unit);
    obm = si->port_serdes[port];
    obm %= MONTEREY_TSCS_PER_PGW;

    pgw = si->port_group[port];
    pgw_inst = (pgw | SOC_REG_ADDR_INSTANCE_MASK);

    reg =  obm_inner_tpid_regs[obm];

    soc_reg32_get(unit, reg, pgw_inst, 0, &rval32);
    soc_reg_field_set(unit, reg, &rval32, TPIDf, tpid);
    soc_reg_field_set(unit, reg, &rval32, ENABLEf, tpid ? 1 : 0);
    soc_reg32_set(unit, reg, pgw_inst, 0, rval32);
    return;
}
STATIC
void bcm_inner_tpid_obm_set(int unit, uint16 tpid)
{
   int port;
   BCM_PBMP_ITER(PBMP_PORT_ALL(unit), port) {
        bcm_port_inner_tpid_obm_set(unit, port, tpid);
   }
   return;
}
STATIC
void bcm_port_outer_tpid_obm_set(int unit, bcm_port_t port,
                                 uint16 tpid, int tpid_index)
{
   uint32 rval32 = 0;
   int obm, pgw, pgw_inst;
   soc_info_t  *si;
   soc_reg_t reg;
   static const soc_reg_t obm_inner_tpid_regs[][4] = {
        {IDB_OBM0_OUTER_TPID_0r, IDB_OBM0_OUTER_TPID_1r,
         IDB_OBM0_OUTER_TPID_2r, IDB_OBM0_OUTER_TPID_3r},
        {IDB_OBM1_OUTER_TPID_0r, IDB_OBM1_OUTER_TPID_1r,
         IDB_OBM1_OUTER_TPID_2r, IDB_OBM1_OUTER_TPID_3r},
        {IDB_OBM2_OUTER_TPID_0r, IDB_OBM2_OUTER_TPID_1r,
         IDB_OBM2_OUTER_TPID_2r, IDB_OBM2_OUTER_TPID_3r},
        {IDB_OBM3_OUTER_TPID_0r, IDB_OBM3_OUTER_TPID_1r,
         IDB_OBM3_OUTER_TPID_2r, IDB_OBM3_OUTER_TPID_3r},
        {IDB_OBM4_OUTER_TPID_0r, IDB_OBM4_OUTER_TPID_1r,
         IDB_OBM4_OUTER_TPID_2r, IDB_OBM4_OUTER_TPID_3r},
        {IDB_OBM5_OUTER_TPID_0r, IDB_OBM5_OUTER_TPID_1r,
         IDB_OBM5_OUTER_TPID_2r, IDB_OBM5_OUTER_TPID_3r},
        {IDB_OBM6_OUTER_TPID_0r, IDB_OBM6_OUTER_TPID_1r,
         IDB_OBM6_OUTER_TPID_2r, IDB_OBM6_OUTER_TPID_3r},
        {IDB_OBM7_OUTER_TPID_0r, IDB_OBM7_OUTER_TPID_1r,
         IDB_OBM7_OUTER_TPID_2r, IDB_OBM7_OUTER_TPID_3r}
    };
    if ((port < 1) || (port > 64) ||
        (tpid_index < 0) || (tpid_index > 3)) {
        return;
    }
    si = &SOC_INFO(unit);
    obm = si->port_serdes[port];
    obm %= MONTEREY_TSCS_PER_PGW;

    pgw = si->port_group[port];
    pgw_inst = (pgw | SOC_REG_ADDR_INSTANCE_MASK);

    reg =  obm_inner_tpid_regs[obm][tpid_index];

    soc_reg32_get(unit, reg, pgw_inst, 0, &rval32);
    soc_reg_field_set(unit, reg, &rval32, TPIDf, tpid);
    soc_reg_field_set(unit, reg, &rval32, ENABLEf, tpid ? 1 : 0);
    soc_reg32_set(unit, reg, pgw_inst, 0, rval32);
    return;
}
#endif
/*
 * Function:
 *      bcm_port_tpid_set
 * Description:
 *      Set the default Tag Protocol ID for a port.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      tpid - Tag Protocol ID
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      This API is not specifically double-tagging-related, but
 *      the port TPID becomes the service provider TPID when double-tagging
 *      is enabled on a port.  The default TPID is 0x8100.
 *      On BCM5665, only 0x8100 is allowed for the inner (customer) tag.
 */

int
bcm_esw_port_tpid_set(int unit, bcm_port_t port, uint16 tpid)
{
    int rv = BCM_E_UNAVAIL;
    bcm_module_t mod_out;
    bcm_port_t port_out;
    bcm_trunk_t tgid_out;
    int id_out;
    int is_local = 0, tpid_index = 0;
#ifdef BCM_FIREBOLT_SUPPORT
    bcm_port_t orig_port = -1;
#endif
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
    int vp = -1;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    if (BCM_GPORT_IS_SET(port)) {
        /* Handle virtual ports separetly */
        if (BCM_GPORT_IS_MPLS_PORT(port) ||
            BCM_GPORT_IS_MIM_PORT(port) ||
            BCM_GPORT_IS_VXLAN_PORT(port) ||
            BCM_GPORT_IS_FLOW_PORT(port) ||
            BCM_GPORT_IS_VLAN_PORT(port)) {
            if (soc_feature(unit, soc_feature_vlan_ctrl)) {
#if defined(BCM_TRX_SUPPORT)
                PORT_LOCK(unit);
                rv = _bcm_trx_vp_tpid_set(unit, port, tpid);
                PORT_UNLOCK(unit);
#endif
            }
            return rv;
        } else if (BCM_GPORT_IS_SUBPORT_GROUP(port)) {
            if (soc_feature(unit, soc_feature_subtag_coe)) {
#if defined(BCM_KATANA2_SUPPORT)
                PORT_LOCK(unit);
                rv = bcm_kt2_subport_subtag_port_tpid_set(unit, port, tpid);
                PORT_UNLOCK(unit);
#endif
            }
            return rv;
        } else if (BCM_GPORT_IS_SUBPORT_PORT(port)) {

            if (soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
                (soc_feature(unit, soc_feature_channelized_switching))) {
#ifdef BCM_HGPROXY_COE_SUPPORT
                if (_BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
                    orig_port = port;
                    BCM_IF_ERROR_RETURN(
                        _bcmi_coe_subport_physical_port_get(unit,
                                    port, &port));
                    } else {
                        return BCM_E_PORT;
                }
#endif
        } else if (soc_feature(unit, soc_feature_subtag_coe) ||
                soc_feature(unit, soc_feature_linkphy_coe)) {
#ifdef BCM_KATANA2_SUPPORT
                if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit,
                    port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
                    BCM_IF_ERROR_RETURN(_bcm_kt2_modport_to_pp_port_get(unit,
                        mod_out, port_out, &port));
                } else {
                    return BCM_E_PORT;
                }
#endif
            } else {
                return BCM_E_PORT;
            }
        } else if (BCM_GPORT_IS_TRUNK(port)) {
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
            if (soc_feature(unit, soc_feature_vp_lag)) {
                BCM_IF_ERROR_RETURN(
                    _bcm_esw_trunk_tid_to_vp_lag_vp(
                        unit, BCM_GPORT_TRUNK_GET(port), &vp));
                if (_bcm_vp_used_get(unit, vp, _bcmVpTypeVpLag)) {
                    if (soc_feature(unit, soc_feature_vlan_ctrl)) {
                        PORT_LOCK(unit);
                        rv = _bcm_trx_vp_tpid_set(unit, port, tpid);
                        PORT_UNLOCK(unit);
                        return rv;
                    }
                } else {
                    return BCM_E_PARAM;
                }
            }
#endif
            return BCM_E_PARAM;
        } else {
            BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
            if ((-1 != tgid_out) || (-1 != id_out)) {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN
                (_bcm_esw_modid_is_local(unit, mod_out, &is_local));
#if defined(BCM_HURRICANE3_SUPPORT)
            /* Here only take care non-local port, the local port will
             * be handled later (by _bcm_fb2_port_tpid_set) */
            if (SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
                if (!is_local) {
                    if (soc_mem_is_valid(unit, SYSTEM_CONFIG_TABLE_MODBASEm)) {
                        return _bcm_esw_mod_port_tpid_set(unit, mod_out,
                                                          port_out, tpid);
                    } else {
                        return BCM_E_PARAM;
                    }
                } else {
                    BCM_IF_ERROR_RETURN(
                        bcm_esw_port_local_get(unit, port, &port));
                }
            } else
#endif
            {
                if (!is_local) {
                        if (soc_mem_is_valid(unit, SYSTEM_CONFIG_TABLE_MODBASEm) ||
                            soc_feature(unit,soc_feature_stm_tpid_support)) {
                            return _bcm_esw_mod_port_tpid_set(unit, mod_out,
                                                              port_out, tpid);
                        } else {
                            return BCM_E_PARAM;
                        }
                } else {
                    if (soc_mem_is_valid(unit, SYSTEM_CONFIG_TABLE_MODBASEm)) {
                        BCM_IF_ERROR_RETURN
                            (_bcm_esw_mod_port_tpid_set(unit, mod_out,
                                                        port_out, tpid));
                    }
                    BCM_IF_ERROR_RETURN(
                        bcm_esw_port_local_get(unit, port, &port));
                }
            }
        }
    } else if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }

#if defined (BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit) &&
        (PORT(unit, port).dtag_mode == BCM_PORT_DTAG_MODE_EXTERNAL)) {
        /* For DT mode external ports, don't enable any outer TPIDs */
        return BCM_E_NONE;
    }
#endif

#ifdef BCM_FIREBOLT_SUPPORT
    if (SOC_IS_FBX(unit)) {
        PORT_LOCK(unit);
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT) || \
        defined(BCM_RAVEN_SUPPORT)
        if (soc_feature(unit, soc_feature_vlan_ctrl)) {
            if (orig_port != -1) {
                rv = _bcm_fb2_port_tpid_set(unit, orig_port, tpid, &tpid_index);
            } else {
                rv = _bcm_fb2_port_tpid_set(unit, port, tpid, &tpid_index);
            }
#if defined(BCM_TOMAHAWK_SUPPORT)
    /* For Tomahawk low latency mode, use outer_tpid field  */
    /* of EGR_VLAN_TAG_ACTION_FOR_BYPASSr on egress side    */
            if (soc_feature(unit, soc_feature_fast_egr_vlan_action)) {
                uint32 rval;
                bcm_port_t local_port;

                if (orig_port != -1)
                    local_port = orig_port;
                else {
                    local_port = port;
                }

                rv = READ_EGR_VLAN_TAG_ACTION_FOR_BYPASSr(unit, local_port,
                                                          &rval);
                if (SOC_FAILURE(rv)) {
                    PORT_UNLOCK(unit);
                    return (rv);
                }

                soc_reg_field_set(unit, EGR_VLAN_TAG_ACTION_FOR_BYPASSr, &rval,
                                  OUTER_TPIDf, tpid);

                rv = WRITE_EGR_VLAN_TAG_ACTION_FOR_BYPASSr(unit, local_port,
                                                           rval);
                if (SOC_FAILURE(rv)) {
                    PORT_UNLOCK(unit);
                    return (rv);
                }
            }
#endif
#if defined(BCM_MONTEREY_SUPPORT)
    if (soc_feature(unit, soc_feature_obm_tpid_sync)) {
        bcm_port_outer_tpid_obm_set(unit, port, tpid, tpid_index);
    }
#endif
        } else
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT || BCM_RAVEN_SUPPORT */
        {
            rv = _bcm_fb_port_tpid_set(unit, port, tpid);
        }
        /* coverity[negative_shift] */
        if (BCM_SUCCESS(rv) && SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit), port)) {

            
            if(!SOC_IS_TOMAHAWK3(unit)) {
                /*
                 * At now, this mac drvier is only supported by XMAC & XLMAC
                 * If function return BCM_E_UNAVAIL, it should be correct.
                 */
                if (SOC_PORT_USE_PORTCTRL(unit, port)) {
                    rv = bcmi_esw_portctrl_vlan_tpid_set(unit, port, tpid);
                } else {
                    rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                     SOC_MAC_CONTROL_RX_VLAN_TAG_OUTER_TPID, tpid);
                    if (rv == BCM_E_UNAVAIL) {
                        rv = BCM_E_NONE;
                    }
                }
            }
        }
        PORT_UNLOCK(unit);
        return rv;
    }
#endif

    if (tpid == 0x8100) {
        return BCM_E_NONE;
    }
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      _bcm_esw_mod_port_tpid_get
 * Description:
 *      Retrieve the Tag Protocol ID for a (module, port).
 * Parameters:
 *      unit - Device number
 *      mod  - Module ID
 *      port - Port number
 *      tpid - (OUT) Tag Protocol ID
 * Return Value:
 *      BCM_E_XXX
 */
STATIC int
_bcm_esw_mod_port_tpid_get(int unit, bcm_module_t mod, bcm_port_t port,
        uint16 *tpid)
{
#ifdef BCM_HURRICANE3_SUPPORT
    if (SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
        return _bcm_hr3_mod_port_tpid_get(unit, mod, port, tpid);
    } else
#endif /* BCM_HURRICANE3_SUPPORT */
#ifdef BCM_TRIDENT_SUPPORT
    {
        return _bcm_td_mod_port_tpid_get(unit, mod, port, tpid);
    }
#endif /* BCM_TRIDENT_SUPPORT */
    return BCM_E_UNAVAIL;
}


/*
 * Function:
 *      bcm_port_tpid_get
 * Description:
 *      Retrieve the default Tag Protocol ID for a port.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      tpid - (OUT) Tag Protocol ID
 * Return Value:
 *      BCM_E_XXX
 */

int
bcm_esw_port_tpid_get(int unit, bcm_port_t port, uint16 *tpid)
{
    int rv = BCM_E_UNAVAIL;
    bcm_module_t mod_out;
    bcm_port_t port_out;
    bcm_trunk_t tgid_out;
    int id_out;
    int is_local = 0;
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
    int vp = -1;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    if (BCM_GPORT_IS_SET(port)) {
        /* Handle virtual ports separetly */
        if (BCM_GPORT_IS_MPLS_PORT(port) ||
            BCM_GPORT_IS_MIM_PORT(port) ||
            BCM_GPORT_IS_VXLAN_PORT(port) ||
            BCM_GPORT_IS_FLOW_PORT(port) ||
            BCM_GPORT_IS_VLAN_PORT(port)) {

            if (soc_feature(unit, soc_feature_vlan_ctrl)) {
#if defined(BCM_TRX_SUPPORT)
                PORT_LOCK(unit);
                rv = _bcm_trx_vp_tpid_get(unit, port, tpid);
                PORT_UNLOCK(unit);
#endif
            }
            return rv;
        } else if (BCM_GPORT_IS_SUBPORT_GROUP(port)) {
            if (soc_feature(unit, soc_feature_subtag_coe)) {
#if defined(BCM_KATANA2_SUPPORT)
                PORT_LOCK(unit);
                rv = bcm_kt2_subport_subtag_port_tpid_get(unit, port, tpid);
                PORT_UNLOCK(unit);
#endif
            }
            return rv;
        } else if (BCM_GPORT_IS_SUBPORT_PORT(port)) {

            if (soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
                (soc_feature(unit, soc_feature_channelized_switching))) {
#ifdef BCM_HGPROXY_COE_SUPPORT
                if (_BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
                    } else {
                        return BCM_E_PORT;
                }
#endif
            } else if (soc_feature(unit, soc_feature_subtag_coe) ||
                       soc_feature(unit, soc_feature_linkphy_coe)) {
#ifdef BCM_KATANA2_SUPPORT
                if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit,
                    port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
                    BCM_IF_ERROR_RETURN(_bcm_kt2_modport_to_pp_port_get(unit,
                        mod_out, port_out, &port));
                } else {
                    return BCM_E_PORT;
                }
#endif
            } else {
                return BCM_E_PORT;
            }
        } else if (BCM_GPORT_IS_TRUNK(port)) {
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
            if (soc_feature(unit, soc_feature_vp_lag)) {
                BCM_IF_ERROR_RETURN(
                    _bcm_esw_trunk_tid_to_vp_lag_vp(
                        unit, BCM_GPORT_TRUNK_GET(port), &vp));
                if (_bcm_vp_used_get(unit, vp, _bcmVpTypeVpLag)) {
                    if (soc_feature(unit, soc_feature_vlan_ctrl)) {
                        PORT_LOCK(unit);
                        rv = _bcm_trx_vp_tpid_get(unit, port, tpid);
                        PORT_UNLOCK(unit);
                        return rv;
                    }
                } else {
                    return BCM_E_PARAM;
                }
            }
#endif
            return BCM_E_PARAM;
        } else {
            BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
            if ((-1 != tgid_out) || (-1 != id_out)) {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN
                (_bcm_esw_modid_is_local(unit, mod_out, &is_local));
            if (!is_local) {
                if (soc_mem_is_valid(unit, SYSTEM_CONFIG_TABLE_MODBASEm)) {
                    return _bcm_esw_mod_port_tpid_get(unit, mod_out, port_out,
                            tpid);
                } else {
                    return BCM_E_PARAM;
                }
            } else {
                BCM_IF_ERROR_RETURN(
                        bcm_esw_port_local_get(unit, port, &port));
            }
        }

    } else if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }

    if (tpid == NULL) {
        return BCM_E_PARAM;
    }

#ifdef BCM_FIREBOLT_SUPPORT
    if (SOC_IS_FBX(unit)) {
         PORT_LOCK(unit);
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT) \
        || defined(BCM_RAVEN_SUPPORT)
        if (soc_feature(unit, soc_feature_vlan_ctrl)) {
            rv = _bcm_fb2_port_tpid_get(unit, port, tpid);
        } else
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT || BCM_RAVEN_SUPPORT */
        {
            rv = _bcm_fb_port_tpid_get(unit, port, tpid);
        }
        PORT_UNLOCK(unit);
        return rv;
    }
#endif /* BCM_FIREBOLT_SUPPORT */
    *tpid = 0x8100;
    return (BCM_E_NONE);
}

/*
 * Function:
 *      _bcm_esw_mod_port_tpid_add
 * Description:
 *      Add TPID for a (module, port).
 * Parameters:
 *      unit - (IN) Device number
 *      mod  - (IN) Module ID
 *      port - (IN) Port number
 *      tpid - (IN) Tag Protocol ID
 * Return Value:
 *      BCM_E_XXX
 */
STATIC int
_bcm_esw_mod_port_tpid_add(int unit, bcm_module_t mod, bcm_port_t port,
                      uint16 tpid)
{
#ifdef BCM_HURRICANE3_SUPPORT
    if (SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
        return _bcm_hr3_mod_port_tpid_add(unit, mod, port, tpid);
    } else
#endif /* BCM_HURRICANE3_SUPPORT */
#ifdef BCM_TRIDENT_SUPPORT
    {
        return _bcm_td_mod_port_tpid_add(unit, mod, port, tpid);
    }
#endif /* BCM_TRIDENT_SUPPORT */
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_port_tpid_add
 * Description:
 *      Add allowed TPID for a port.
 * Parameters:
 *      unit         - (IN) Device number
 *      port         - (IN) Port number
 *      tpid         - (IN) Tag Protocol ID
 *      color_select - (IN) Color mode for TPID
 * Return Value:
 *      BCM_E_XXX
 */
int
bcm_esw_port_tpid_add(int unit, bcm_port_t port,
                      uint16 tpid, int color_select)
{
    int rv = BCM_E_UNAVAIL;
    bcm_module_t mod_out;
    bcm_port_t port_out;
    bcm_trunk_t tgid_out;
    int id_out;
    int is_local = 0;
#ifdef BCM_FIREBOLT_SUPPORT
    bcm_port_t orig_port = -1;
#endif
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
    int vp = -1;
#endif

    if (color_select != BCM_COLOR_PRIORITY &&
        color_select != BCM_COLOR_OUTER_CFI &&
        color_select != BCM_COLOR_INNER_CFI) {
        return BCM_E_PARAM;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    if (BCM_GPORT_IS_SET(port)) {
        /* Handle virtual ports separetly */
        if (BCM_GPORT_IS_MPLS_PORT(port) ||
            BCM_GPORT_IS_MIM_PORT(port) ||
            BCM_GPORT_IS_TRILL_PORT(port) ||
            BCM_GPORT_IS_VXLAN_PORT(port) ||
            BCM_GPORT_IS_FLOW_PORT(port) ||
            BCM_GPORT_IS_VLAN_PORT(port)) {

            if (soc_feature(unit, soc_feature_vlan_ctrl)) {
#if defined(BCM_TRX_SUPPORT)
                PORT_LOCK(unit);
                rv = _bcm_trx_vp_tpid_add(unit, port, tpid, color_select);
                PORT_UNLOCK(unit);
#endif
            }
            return rv;
        } else if (BCM_GPORT_IS_SUBPORT_PORT(port)) {

            if (soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
                (soc_feature(unit, soc_feature_channelized_switching))) {
#ifdef BCM_HGPROXY_COE_SUPPORT
                if (_BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
                    orig_port = port;
                    BCM_IF_ERROR_RETURN(
                        _bcmi_coe_subport_physical_port_get(unit,
                                    port, &port));
                    } else {
                        return BCM_E_PORT;
                    }
#endif
            } else if (soc_feature(unit, soc_feature_subtag_coe) ||
                       soc_feature(unit, soc_feature_linkphy_coe)) {
#ifdef BCM_KATANA2_SUPPORT
                if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit,
                    port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
                    BCM_IF_ERROR_RETURN(_bcm_kt2_modport_to_pp_port_get(unit,
                        mod_out, port_out, &port));
                } else {
                    return BCM_E_PORT;
                }
#endif
            } else {
                return BCM_E_PORT;
            }
        } else if (BCM_GPORT_IS_TRUNK(port)) {
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
            if (soc_feature(unit, soc_feature_vp_lag)) {
                BCM_IF_ERROR_RETURN(
                    _bcm_esw_trunk_tid_to_vp_lag_vp(
                        unit, BCM_GPORT_TRUNK_GET(port), &vp));
                if (_bcm_vp_used_get(unit, vp, _bcmVpTypeVpLag)) {
                    if (soc_feature(unit, soc_feature_vlan_ctrl)) {
                        PORT_LOCK(unit);
                        rv = _bcm_trx_vp_tpid_add(unit, port, tpid,
                                                  color_select);
                        PORT_UNLOCK(unit);
                        return rv;
                    }
                } else {
                    return BCM_E_PARAM;
                }
            }
#endif
            return BCM_E_PARAM;
        } else {
            BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
            if ((-1 != tgid_out) || (-1 != id_out)) {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN
                (_bcm_esw_modid_is_local(unit, mod_out, &is_local));
#if defined(BCM_HURRICANE3_SUPPORT)
            /* Here only take care non-local port, the local port will
             * be handled later (by _bcm_fb2_port_tpid_add) */
            if (SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
                if (!is_local) {
                    if (soc_mem_is_valid(unit, SYSTEM_CONFIG_TABLE_MODBASEm)) {
                        return _bcm_esw_mod_port_tpid_add(unit, mod_out,
                                                          port_out, tpid);
                    } else {
                        return BCM_E_PARAM;
                    }
                } else {
                    BCM_IF_ERROR_RETURN(
                            bcm_esw_port_local_get(unit, port, &port));
                }
            } else
#endif
            {
                if (!is_local) {
                    if (soc_mem_is_valid(unit, SYSTEM_CONFIG_TABLE_MODBASEm)) {
                        return _bcm_esw_mod_port_tpid_add(unit, mod_out,
                                                          port_out, tpid);
                    } else {
                        return BCM_E_PARAM;
                    }
                } else {
                    if (soc_mem_is_valid(unit, SYSTEM_CONFIG_TABLE_MODBASEm)) {
                        BCM_IF_ERROR_RETURN
                            (_bcm_esw_mod_port_tpid_add(unit, mod_out,
                                                        port_out, tpid));
                    }
                    BCM_IF_ERROR_RETURN(
                        bcm_esw_port_local_get(unit, port, &port));
                }
            }
        }

    } else if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }

#if defined (BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit) &&
        (PORT(unit, port).dtag_mode == BCM_PORT_DTAG_MODE_EXTERNAL)) {
        /* For DT mode external ports, don't enable any outer TPIDs */
        return BCM_E_NONE;
    }
#endif

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT) \
    || defined(BCM_RAVEN_SUPPORT)
    if (soc_feature(unit, soc_feature_vlan_ctrl)) {
        PORT_LOCK(unit);
        if (orig_port != -1) {
            rv = _bcm_fb2_port_tpid_add(unit, orig_port, tpid, color_select);
        } else {
            rv = _bcm_fb2_port_tpid_add(unit, port, tpid, color_select);
        }
        PORT_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *      _bcm_esw_mod_port_tpid_delete
 * Description:
 *      Delete TPID for a (module, port).
 * Parameters:
 *      unit - (IN) Device number
 *      mod  - (IN) Module ID
 *      port - (IN) Port number
 *      tpid - (IN) Tag Protocol ID
 * Return Value:
 *      BCM_E_XXX
 */
STATIC int
_bcm_esw_mod_port_tpid_delete(int unit, bcm_module_t mod, bcm_port_t port,
        uint16 tpid)
{
#ifdef BCM_HURRICANE3_SUPPORT
    if (SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
        return _bcm_hr3_mod_port_tpid_delete(unit, mod, port, tpid);
    } else
#endif /* BCM_HURRICANE3_SUPPORT */
#ifdef BCM_TRIDENT_SUPPORT
    {
        return _bcm_td_mod_port_tpid_delete(unit, mod, port, tpid);
    }
#endif /* BCM_TRIDENT_SUPPORT */
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_port_tpid_delete
 * Description:
 *      Delete allowed TPID for a port.
 * Parameters:
 *      unit - (IN) Device number
 *      port - (IN) Port number
 *      tpid - (IN) Tag Protocol ID
 * Return Value:
 *      BCM_E_XXX
 */
int
bcm_esw_port_tpid_delete(int unit, bcm_port_t port, uint16 tpid)
{
    int rv = BCM_E_UNAVAIL;
    bcm_module_t mod_out;
    bcm_port_t port_out;
    bcm_trunk_t tgid_out;
    int id_out;
    int is_local = 0;
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
    int vp = -1;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    if (BCM_GPORT_IS_SET(port)) {
        /* Handle virtual ports separetly */
        if (BCM_GPORT_IS_MPLS_PORT(port) ||
            BCM_GPORT_IS_TRILL_PORT(port) ||
            BCM_GPORT_IS_MIM_PORT(port) ||
            BCM_GPORT_IS_VXLAN_PORT(port) ||
            BCM_GPORT_IS_FLOW_PORT(port) ||
            BCM_GPORT_IS_VLAN_PORT(port)) {

            if (soc_feature(unit, soc_feature_vlan_ctrl)) {
#if defined(BCM_TRX_SUPPORT)
                PORT_LOCK(unit);
                rv = _bcm_trx_vp_tpid_delete(unit, port, tpid);
                PORT_UNLOCK(unit);
#endif
            }
            return rv;
        }  else if (BCM_GPORT_IS_SUBPORT_GROUP(port)) {
            if (soc_feature(unit, soc_feature_subtag_coe)) {
#if defined(BCM_KATANA2_SUPPORT)
                PORT_LOCK(unit);
                rv = bcm_kt2_subport_subtag_port_tpid_delete(unit, port, tpid);
                PORT_UNLOCK(unit);
#endif
            }
            return rv;
        } else if (BCM_GPORT_IS_SUBPORT_PORT(port)) {

            if (soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
                (soc_feature(unit, soc_feature_channelized_switching))) {
#ifdef BCM_HGPROXY_COE_SUPPORT
                if (_BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
                    } else {
                        return BCM_E_PORT;
                    }
#endif
            } else if (soc_feature(unit, soc_feature_subtag_coe) ||
                       soc_feature(unit, soc_feature_linkphy_coe)) {
#ifdef BCM_KATANA2_SUPPORT
                if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit,
                    port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
                    BCM_IF_ERROR_RETURN(_bcm_kt2_modport_to_pp_port_get(unit,
                        mod_out, port_out, &port));
                } else {
                    return BCM_E_PORT;
                }
#endif
            } else {
                return BCM_E_PORT;
            }
        } else if (BCM_GPORT_IS_TRUNK(port)) {
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
            if (soc_feature(unit, soc_feature_vp_lag)) {
                BCM_IF_ERROR_RETURN(
                    _bcm_esw_trunk_tid_to_vp_lag_vp(
                        unit, BCM_GPORT_TRUNK_GET(port), &vp));
                if (_bcm_vp_used_get(unit, vp, _bcmVpTypeVpLag)) {
                    if (soc_feature(unit, soc_feature_vlan_ctrl)) {
                        PORT_LOCK(unit);
                        rv = _bcm_trx_vp_tpid_delete(unit, port, tpid);
                        PORT_UNLOCK(unit);
                        return rv;
                    }
                } else {
                    return BCM_E_PARAM;
                }
            }
#endif
            return BCM_E_PARAM;
        } else {
            BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
            if ((-1 != tgid_out) || (-1 != id_out)) {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN
                (_bcm_esw_modid_is_local(unit, mod_out, &is_local));
#if defined(BCM_HURRICANE3_SUPPORT)
            /* Here only take care non-local port, the local port will
             * be handled later (by _bcm_fb2_port_tpid_delete) */
            if (SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
                if (!is_local) {
                    if (soc_mem_is_valid(unit, SYSTEM_CONFIG_TABLE_MODBASEm)) {
                        return _bcm_esw_mod_port_tpid_delete(unit, mod_out,
                                                             port_out, tpid);
                    } else {
                        return BCM_E_PARAM;
                    }
                } else {
                    BCM_IF_ERROR_RETURN(
                        bcm_esw_port_local_get(unit, port, &port));
                }
            } else
#endif
            {
                if (!is_local) {
                    if (soc_mem_is_valid(unit, SYSTEM_CONFIG_TABLE_MODBASEm)) {
                        return _bcm_esw_mod_port_tpid_delete(unit, mod_out,
                                                             port_out, tpid);
                    } else {
                        return BCM_E_PARAM;
                    }
                } else {
                    if (soc_mem_is_valid(unit, SYSTEM_CONFIG_TABLE_MODBASEm)) {
                        BCM_IF_ERROR_RETURN
                            (_bcm_esw_mod_port_tpid_delete(unit, mod_out,
                                                           port_out, tpid));
                    }
                    BCM_IF_ERROR_RETURN(
                        bcm_esw_port_local_get(unit, port, &port));
                }
            }
        }

    } else if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT) \
    || defined(BCM_RAVEN_SUPPORT)
    if (soc_feature(unit, soc_feature_vlan_ctrl)) {
        PORT_LOCK(unit);
        rv = _bcm_fb2_port_tpid_delete(unit, port, tpid);
        PORT_UNLOCK(unit);
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT || BCM_RAVEN_SUPPORT */
    return rv;
}

/*
 * Function:
 *      _bcm_esw_mod_port_tpid_delete_all
 * Description:
 *      Delete all TPID for a (module, port).
 * Parameters:
 *      unit - (IN) Device number
 *      mod  - (IN) Module ID
 *      port - (IN) Port number
 * Return Value:
 *      BCM_E_XXX
 */
STATIC int
_bcm_esw_mod_port_tpid_delete_all(int unit, bcm_module_t mod, bcm_port_t port)
{
#ifdef BCM_HURRICANE3_SUPPORT
    if (SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
        return _bcm_hr3_mod_port_tpid_delete_all(unit, mod, port);
    } else
#endif /* BCM_HURRICANE3_SUPPORT */
#ifdef BCM_TRIDENT_SUPPORT
    {
        return _bcm_td_mod_port_tpid_delete_all(unit, mod, port);
    }
#endif /* BCM_TRIDENT_SUPPORT */
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_port_tpid_delete_all
 * Description:
 *      Delete all allowed TPID for a port.
 * Parameters:
 *      unit - (IN) Device number
 *      port - (IN) Port number
 * Return Value:
 *      BCM_E_XXX
 */
int
bcm_esw_port_tpid_delete_all(int unit, bcm_port_t port)
{
    int rv = BCM_E_UNAVAIL;
    bcm_module_t mod_out;
    bcm_port_t port_out;
    bcm_trunk_t tgid_out;
    int id_out;
    int is_local = 0;
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
    int vp = -1;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    if (BCM_GPORT_IS_SET(port)) {
        /* Handle virtual ports separetly */
        if (BCM_GPORT_IS_MPLS_PORT(port) ||
            BCM_GPORT_IS_MIM_PORT(port) ||
            BCM_GPORT_IS_VXLAN_PORT(port) ||
            BCM_GPORT_IS_FLOW_PORT(port) ||
            BCM_GPORT_IS_VLAN_PORT(port)) {

            if (soc_feature(unit, soc_feature_vlan_ctrl)) {
#if defined(BCM_TRX_SUPPORT)
                PORT_LOCK(unit);
                rv = _bcm_trx_vp_tpid_delete_all(unit, port);
                PORT_UNLOCK(unit);
#endif
            }
            return rv;
        } else if (BCM_GPORT_IS_SUBPORT_PORT(port)) {

            if (soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
                (soc_feature(unit, soc_feature_channelized_switching))) {
#ifdef BCM_HGPROXY_COE_SUPPORT
                if (_BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
                    } else {
                        return BCM_E_PORT;
                    }
#endif
             } else if (soc_feature(unit, soc_feature_subtag_coe) ||
                      soc_feature(unit, soc_feature_linkphy_coe)) {
#ifdef BCM_KATANA2_SUPPORT
                if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit,
                    port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
                    BCM_IF_ERROR_RETURN(_bcm_kt2_modport_to_pp_port_get(unit,
                        mod_out, port_out, &port));
                } else {
                    return BCM_E_PORT;
                }
#endif
            } else {
                return BCM_E_PORT;
            }
        } else if (BCM_GPORT_IS_TRUNK(port)) {
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
            if (soc_feature(unit, soc_feature_vp_lag)) {
                BCM_IF_ERROR_RETURN(
                    _bcm_esw_trunk_tid_to_vp_lag_vp(
                        unit, BCM_GPORT_TRUNK_GET(port), &vp));
                if (_bcm_vp_used_get(unit, vp, _bcmVpTypeVpLag)) {
                    if (soc_feature(unit, soc_feature_vlan_ctrl)) {
                        PORT_LOCK(unit);
                        rv = _bcm_trx_vp_tpid_delete_all(unit, port);
                        PORT_UNLOCK(unit);
                        return rv;
                    }
                } else {
                    return BCM_E_PARAM;
                }
            }
#endif
            return BCM_E_PARAM;
        } else {
            BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
            if ((-1 != tgid_out) || (-1 != id_out)) {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN
                (_bcm_esw_modid_is_local(unit, mod_out, &is_local));
#if defined(BCM_HURRICANE3_SUPPORT)
            /* Here only take care non-local port, the local port will
             * be handled later (by _bcm_fb2_port_tpid_delete_all) */
            if (SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
                if (!is_local) {
                    if (soc_mem_is_valid(unit, SYSTEM_CONFIG_TABLE_MODBASEm)) {
                        return _bcm_esw_mod_port_tpid_delete_all(unit, mod_out,
                                                                 port_out);
                    } else {
                        return BCM_E_PARAM;
                    }
                } else {
                    BCM_IF_ERROR_RETURN(
                        bcm_esw_port_local_get(unit, port, &port));
                }
            } else
#endif
            {
                if (!is_local) {
                    if (soc_mem_is_valid(unit, SYSTEM_CONFIG_TABLE_MODBASEm)) {
                        return _bcm_esw_mod_port_tpid_delete_all(unit, mod_out,
                                                                 port_out);
                    } else {
                        return BCM_E_PARAM;
                    }
                } else {
                    if (soc_mem_is_valid(unit, SYSTEM_CONFIG_TABLE_MODBASEm)) {
                        BCM_IF_ERROR_RETURN
                            (_bcm_esw_mod_port_tpid_delete_all(unit, mod_out,
                                                               port_out));
                    }
                    BCM_IF_ERROR_RETURN(
                        bcm_esw_port_local_get(unit, port, &port));
                }
            }
        }

    } else if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT) \
 || defined(BCM_RAVEN_SUPPORT)
    if (soc_feature(unit, soc_feature_vlan_ctrl)) {
        PORT_LOCK(unit);
        rv = _bcm_fb2_port_tpid_delete_all(unit, port);
        PORT_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *      _bcm_esw_mod_port_inner_tpid_enable
 * Description:
 *      Enable the Inner Tag Protocol ID for a (module, port).
 * Parameters:
 *      unit - Device number
 *      mod  - Module ID
 *      port - Port number
 * Return Value:
 *      BCM_E_XXX
 */
STATIC int
_bcm_esw_mod_port_inner_tpid_enable(int unit, bcm_module_t mod, bcm_port_t port)
{
    int rv = BCM_E_NONE;
    if (!SOC_MEM_IS_VALID(unit, SYSTEM_CONFIG_TABLE_MODBASEm)) {
        int sys_index = 0;
        uint32 enable = 1;
        system_config_table_entry_t systab;
        sys_index = mod * 64 + port;
        rv = READ_SYSTEM_CONFIG_TABLEm(unit, MEM_BLOCK_ANY, sys_index,
                                       &systab);
        if (BCM_SUCCESS(rv)) {
            soc_SYSTEM_CONFIG_TABLEm_field32_set(unit, &systab,
                                                 INNER_TPID_ENABLEf, enable);
            rv = WRITE_SYSTEM_CONFIG_TABLEm(unit, MEM_BLOCK_ALL,
                                            sys_index, &systab);
        }
    } else {
#ifdef BCM_HURRICANE3_SUPPORT
        if (SOC_IS_HURRICANE3(unit)) {
            rv = _bcm_hr3_mod_port_inner_tpid_enable_write(unit, mod, port, 1);
        }
#endif /* BCM_HURRICANE3_SUPPORT */
    }
    return rv;
}

/*
 * Function:
 *      bcm_port_inner_tpid_set
 * Purpose:
 *      Set the expected TPID for the inner tag in double-tagging mode.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      tpid - Tag Protocol ID
 * Returns:
 *      BCM_E_NONE - Success.
 *      BCM_E_XXX
 */
int
bcm_esw_port_inner_tpid_set(int unit, bcm_port_t port, uint16 tpid)
{
    int rv = BCM_E_UNAVAIL;
    bcm_module_t mod_out = BCM_MODID_INVALID;
    bcm_port_t port_out;
    bcm_trunk_t tgid_out;
    int is_local = TRUE;
    int id_out;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    if (BCM_GPORT_IS_SET(port)) {
        /* Handle virtual ports separetly */
        if (BCM_GPORT_IS_MPLS_PORT(port) ||
            BCM_GPORT_IS_MIM_PORT(port) ||
            BCM_GPORT_IS_VLAN_PORT(port)) {

            if (soc_feature(unit, soc_feature_vlan_ctrl)) {
#if defined(BCM_TRX_SUPPORT)
                PORT_LOCK(unit);
                rv = _bcm_trx_vp_tpid_set(unit, port,tpid);
                PORT_UNLOCK(unit);
#endif
            }
            return rv;
        } else if (BCM_GPORT_IS_SUBPORT_PORT(port)) {
            if (soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
                (soc_feature(unit, soc_feature_channelized_switching))) {
#ifdef BCM_HGPROXY_COE_SUPPORT
                if (_BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
                    BCM_IF_ERROR_RETURN(
                        _bcmi_coe_subport_physical_port_get(unit,
                                    port, &port));
                    } else {
                        return BCM_E_PORT;
                    }
#endif
            } else if (soc_feature(unit, soc_feature_subtag_coe) ||
                soc_feature(unit, soc_feature_linkphy_coe)) {
#ifdef BCM_KATANA2_SUPPORT
                if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit,
                    port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
                    BCM_IF_ERROR_RETURN(_bcm_kt2_modport_to_pp_port_get(unit,
                        mod_out, port_out, &port));
                } else {
                    return BCM_E_PORT;
                }
#endif
            } else {
                return BCM_E_PORT;
            }
        } else {
            BCM_IF_ERROR_RETURN(
                _bcm_esw_gport_resolve(unit, port, &mod_out, &port_out,
                                       &tgid_out, &id_out));
            if ((-1 != tgid_out) || (-1 != id_out)) {
                return BCM_E_PARAM;
            }
            port = port_out;
            BCM_IF_ERROR_RETURN(
                _bcm_esw_modid_is_local(unit, mod_out, &is_local));
        }
    } else if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }

    if (soc_feature(unit, soc_feature_inner_tpid_enable)) {
        if (BCM_MODID_INVALID == mod_out) {
            BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, &mod_out));
        }
        BCM_IF_ERROR_RETURN(
            _bcm_esw_mod_port_inner_tpid_enable(unit, mod_out, port));

        if (TRUE == is_local) {
            uint32 enable = 1;
            BCM_IF_ERROR_RETURN(
                soc_mem_field32_modify(unit, PORT_TABm, port,
                                       INNER_TPID_ENABLEf, enable));
            if (soc_reg_field_valid(unit, EGR_VLAN_CONTROL_1r, INNER_TPID_ENABLEf)) {
                soc_reg_field32_modify(unit, EGR_VLAN_CONTROL_1r, port,
                                       INNER_TPID_ENABLEf, enable);
            }
        }
    } else {
    /*  INNER_TPID_ENABLEf is also in SYSTEM_CONFIG_TABLE which is for Higig.
         *  Hence, bypass the switched port check */

        PORT_SWITCHED_CHECK(unit, port);
    }

#ifdef BCM_FIREBOLT_SUPPORT
    if (SOC_IS_FBX(unit)) {
        uint32 rval;
#if 0
        int tpid_index;

        for (tpid_index = 0; tpid_index < 4; tpid_index++) {
            if (SOC_REG_IS_VALID(unit, PARSER1_ING_INNER_TPIDr)) {
                BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                    PARSER1_ING_INNER_TPIDr, tpid_index, TPIDf, tpid));
                BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                    PARSER2_ING_INNER_TPIDr, tpid_index, TPIDf, tpid));
            }

            if (SOC_REG_IS_VALID(unit, EGR_INNER_TPIDr)) {
                BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                    EGR_INNER_TPIDr, tpid_index, TPIDf, tpid));
            }

            if (SOC_REG_IS_VALID(unit, EGR_PARSER_INNER_TPIDr)) {
                BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit,
                    EGR_PARSER_INNER_TPIDr, tpid_index, TPIDf, tpid));
            }
        }
#endif

        BCM_IF_ERROR_RETURN(READ_VLAN_CTRLr(unit, &rval));
        soc_reg_field_set(unit, VLAN_CTRLr, &rval, INNER_TPIDf, tpid);
        BCM_IF_ERROR_RETURN(WRITE_VLAN_CTRLr(unit, rval));
        if (soc_reg_field_valid(unit, EGR_CONFIGr, INNER_TPIDf)) {
            BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit, EGR_CONFIGr,
                                REG_PORT_ANY, INNER_TPIDf, tpid));
        }
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            if (soc_reg_field_valid(unit, EGR_CONFIG_1_64r, INNER_TPIDf)) {
                BCM_IF_ERROR_RETURN(soc_reg_field32_modify(unit, EGR_CONFIG_1_64r,
                                    REG_PORT_ANY, INNER_TPIDf, tpid));
            }
        }
#endif
        if (SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit), port)) {
            /*
             * At now, this mac drvier is only supported by XMAC & XLMAC
             * If function return BCM_E_UNAVAIL, it should be correct.
             */
            if (SOC_PORT_USE_PORTCTRL(unit, port)) {
                (void)bcmi_esw_portctrl_vlan_inner_tpid_set(unit, port, tpid);
            } else {
                BCM_IF_ERROR_NOT_UNAVAIL_RETURN(
                    MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                SOC_MAC_CONTROL_RX_VLAN_TAG_INNER_TPID, tpid));
            }
        }
        rv = BCM_E_NONE;
    }
#endif
#if defined(BCM_MONTEREY_SUPPORT)
    if (soc_feature(unit, soc_feature_obm_tpid_sync) && (rv == BCM_E_NONE)) {
        bcm_inner_tpid_obm_set(unit, tpid);
    }
#endif
     return rv;
}

/*
 * Function:
 *      bcm_port_inner_tpid_get
 * Purpose:
 *      Get the expected TPID for the inner tag in double-tagging mode.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      tpid - (OUT) Tag Protocol ID
 * Returns:
 *      BCM_E_NONE - Success.
 *      BCM_E_XXX
 */
int
bcm_esw_port_inner_tpid_get(int unit, bcm_port_t port, uint16 *tpid)
{
    int rv = BCM_E_UNAVAIL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    if (BCM_GPORT_IS_SET(port)) {
        /* Handle virtual ports separetly */
        if (BCM_GPORT_IS_MPLS_PORT(port) ||
            BCM_GPORT_IS_MIM_PORT(port) ||
            BCM_GPORT_IS_VLAN_PORT(port)) {

            if (soc_feature(unit, soc_feature_vlan_ctrl)) {
#if defined(BCM_TRX_SUPPORT)
                PORT_LOCK(unit);
                rv = _bcm_trx_vp_tpid_get(unit, port,tpid);
                PORT_UNLOCK(unit);
#endif
            }
            return rv;
        } else {
            BCM_IF_ERROR_RETURN(
                _bcm_esw_port_gport_validate(unit, port, &port));
        }

    } else if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }

    PORT_SWITCHED_CHECK(unit, port);

    if (tpid == NULL) {
        return BCM_E_PARAM;
    }

#ifdef BCM_FIREBOLT_SUPPORT
    if (SOC_IS_FBX(unit)) {
        uint32 rval;
        BCM_IF_ERROR_RETURN(READ_VLAN_CTRLr(unit, &rval));
        *tpid = soc_reg_field_get(unit, VLAN_CTRLr, rval, INNER_TPIDf);
        return BCM_E_NONE;
    }
#endif

    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_port_frame_max_set
 * Description:
 *      Set the maximum receive frame size for the port
 * Parameters:
 *      unit - Device number
 *      in_port - Port number
 *      size - Maximum frame size in bytes
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      Depending on chip or port type the actual maximum receive frame size
 *      might be slightly higher.
 *
 *      It looks like this operation is performed the same way on all the chips
 *      and the only depends on the port type.
 */
int
bcm_esw_port_frame_max_set(int unit, bcm_port_t in_port, int size)
{
    bcm_port_t port;
    int max_size = BCM_PORT_JUMBO_MAXSZ;
#if defined(BCM_XGS3_SWITCH_SUPPORT)
    uint32 rval;
#endif /* BCM_XGS3_SWITCH_SUPPORT */
#if defined(BCM_KATANA2_SUPPORT)
    int         min_pp_port = SOC_INFO(unit).pp_port_index_min;
#endif /* BCM_KATANA2_SUPPORT */

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, in_port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   in_port));
        return BCM_E_PARAM;
    }

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, in_port)) {
        return bcmi_esw_portctrl_frame_max_set(unit, in_port, size);
    }

    /* Set jumbo max size to 12k for Katana2 as per Arch team recommendation */
    max_size = SOC_INFO(unit).max_mtu;
#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TRIDENT2(unit) || SOC_IS_TOMAHAWKX(unit) ||
        SOC_IS_HURRICANE4(unit)) {
        if (IS_XE_PORT(unit, in_port) || IS_GE_PORT(unit, in_port)
            || IS_CE_PORT(unit, in_port)
            || (IS_C_PORT(unit, in_port) && IS_E_PORT(unit, in_port))) {
            max_size -= 4;
        }
    }
#endif
    if (size < 0 || size > max_size) {
        return BCM_E_PARAM;
    }

    if (!BCM_GPORT_IS_SET(in_port)) {
        if (!SOC_PBMP_MEMBER((PBMP_PORT_ALL(unit)), in_port)) {
            return BCM_E_PORT;
        }
    }
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, in_port, &port));

#if defined(BCM_KATANA2_SUPPORT)
    /* LinkPHY/SubportTag CoE subport does not have MAC */
#if defined(BCM_METROLITE_SUPPORT)
    if ((soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) &&
        soc_feature(unit, soc_feature_discontinuous_pp_port) &&
        (_SOC_IS_PP_PORT_LINKPHY_SUBTAG(unit, port) &&
        !_SOC_IS_PORT_LINKPHY_SUBTAG(unit, port))) {
    } else
#endif
    if ((soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) &&
        !soc_feature(unit, soc_feature_discontinuous_pp_port) &&
        (port >= min_pp_port)) {
    } else
#endif
    {
#ifdef BCM_HURRICANE4_SUPPORT
        if (SOC_IS_HURRICANE4(unit) &&
            (IS_XE_PORT(unit, port) || IS_GE_PORT(unit, port)
            || IS_CE_PORT(unit, port)
            || (IS_C_PORT(unit, port) && IS_E_PORT(unit, port)))) {
            SOC_IF_ERROR_RETURN
                (MAC_FRAME_MAX_SET(PORT(unit, port).p_mac, unit, port, (size + 4)));
        } else
#endif
        {
            SOC_IF_ERROR_RETURN
                (MAC_FRAME_MAX_SET(PORT(unit, port).p_mac, unit, port, size));
        }
    }

#ifdef BCM_SHADOW_SUPPORT
    if (SOC_IS_SHADOW(unit)) {
        SOC_IF_ERROR_RETURN(READ_EGR_L2_MTUr(unit, port, &rval));
        soc_reg_field_set(unit, EGR_L2_MTUr, &rval,
                          VALUEf, size + 4);
        SOC_IF_ERROR_RETURN(WRITE_EGR_L2_MTUr(unit, port, rval));
    } else
#endif /* BCM_SHADOW_SUPPORT */

#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (SOC_IS_XGS3_SWITCH(unit)) {
        soc_reg_t reg;
        egr_mtu_entry_t mtu;
        uint32 mtu_size = size;
        uint32 field_val_set = 1;

        if (IS_XE_PORT(unit, port) || IS_GE_PORT(unit, port)
            || IS_CE_PORT(unit, port)
            || (IS_C_PORT(unit, port) && IS_E_PORT(unit, port))) {
            mtu_size += 4;
        }

        if (SOC_MEM_IS_VALID(unit, EGR_MTUm)) {
            soc_mem_t mem = EGR_MTUm;
            if (soc_feature(unit, soc_feature_egr_all_profile)) {
                BCM_IF_ERROR_RETURN(
                    bcm_esw_port_egr_lport_field_set(unit, port, mem,
                    MTU_SIZEf, mtu_size));
                
            } else {
                SOC_IF_ERROR_RETURN(soc_mem_read(unit, mem, MEM_BLOCK_ANY,
                                                 port, &mtu));
                soc_mem_field_set (unit, mem, (uint32 *)&mtu, MTU_SIZEf,
                                   &mtu_size);
                if (soc_mem_field_valid(unit, EGR_MTUm, MTU_ENABLEf)) {
                    soc_mem_field_set(unit, EGR_MTUm, (uint32 *)&mtu,
                                  MTU_ENABLEf, &field_val_set);
                }

                SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem, MEM_BLOCK_ANY,
                                                 port, &mtu));
            }
        } else {
            reg = SOC_REG_IS_VALID(unit, EGR_MTUr) ? EGR_MTUr : EGR_MTU_SIZEr;

            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));
            soc_reg_field_set(unit, reg, &rval, MTU_SIZEf, mtu_size);
            if (soc_reg_field_valid(unit, reg, MTU_ENABLEf)) {
                soc_reg_field_set(unit, reg, &rval, MTU_ENABLEf, 1);
            }
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
        }
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT */

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_port_frame_max_get
 * Description:
 *      Get the maximum receive frame size for the port
 * Parameters:
 *      unit - Device number
 *      in_port - Port number
 *      size - Maximum frame size in bytes
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      Depending on chip or port type the actual maximum receive frame size
 *      might be slightly higher.
 *
 *      For GE ports that use 2 separate MACs (one for GE and another one for
 *      10/100 modes) the function returns the maximum rx frame size set for
 *      the current mode.
 */
int
bcm_esw_port_frame_max_get(int unit, bcm_port_t in_port, int *size)
{
    int rv = BCM_E_UNAVAIL;
    bcm_port_t port;
#if defined(BCM_KATANA2_SUPPORT)
    uint32 rval;
    int min_pp_port = SOC_INFO(unit).pp_port_index_min;
    int max_phy_port = KT2_MAX_PHYSICAL_PORTS;

#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)) {
        max_phy_port = SB2_MAX_PHYSICAL_PORTS;
    }
#endif
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, in_port)) {
        return bcmi_esw_portctrl_frame_max_get(unit, in_port, size);
    }

#if defined(BCM_KATANA2_SUPPORT)
    if (SOC_IS_KATANA2(unit) && (!BCM_GPORT_IS_SET(in_port)) &&
        (!((in_port >= 1) && (in_port <= max_phy_port) &&
         SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit),in_port)))) {
          return BCM_E_PORT;
    }
#endif

    if(bcm_common_oamp_port_enable_get(unit, in_port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   in_port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, in_port, &port));

#if defined(BCM_KATANA2_SUPPORT)
    /* LinkPHY/SubportTag CoE subport does not have MAC */
#if defined(BCM_METROLITE_SUPPORT)
    if ((soc_feature(unit, soc_feature_linkphy_coe) ||
         soc_feature(unit, soc_feature_subtag_coe)) &&
         soc_feature(unit, soc_feature_discontinuous_pp_port) &&
        (_SOC_IS_PP_PORT_LINKPHY_SUBTAG(unit, port) &&
         !_SOC_IS_PORT_LINKPHY_SUBTAG(unit, port))) {
        *size = 0;
        if (SOC_REG_IS_VALID(unit, EGR_MTUr)) {
            SOC_IF_ERROR_RETURN(READ_EGR_MTUr(unit, port, &rval));
            if (soc_reg_field_get(unit, EGR_MTUr, rval, MTU_ENABLEf)) {
                *size = soc_reg_field_get(unit, EGR_MTUr, rval, MTU_SIZEf) - 4;
            }
        }
        rv = BCM_E_NONE;
    } else
#endif
    if ((soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) &&
        !soc_feature(unit, soc_feature_discontinuous_pp_port) &&
        (port >= min_pp_port)) {
        *size = 0;
        if (SOC_REG_IS_VALID(unit, EGR_MTUr)) {
            SOC_IF_ERROR_RETURN(READ_EGR_MTUr(unit, port, &rval));
            if (soc_reg_field_get(unit, EGR_MTUr, rval, MTU_ENABLEf)) {
                *size = soc_reg_field_get(unit, EGR_MTUr, rval, MTU_SIZEf) - 4;
            }
        }
        rv = BCM_E_NONE;
    } else
#endif
    {
        rv = MAC_FRAME_MAX_GET(PORT(unit, port).p_mac, unit, port, size);
#ifdef BCM_HURRICANE4_SUPPORT
        if (SOC_IS_HURRICANE4(unit) &&
            (IS_XE_PORT(unit, port) || IS_GE_PORT(unit, port)
            || IS_CE_PORT(unit, port)
            || (IS_C_PORT(unit, port) && IS_E_PORT(unit, port)))) {
            *size = *size - 4;
        }
#endif
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_l3_mtu_set
 * Description:
 *      Set the maximum L3 frame size for the port
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      size - Maximum frame size in bytes
 * Return Value:
 *      BCM_E_XXX
 */
int
bcm_esw_port_l3_mtu_set(int unit, bcm_port_t port, int size)
{
    int rv = BCM_E_UNAVAIL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    COMPILER_REFERENCE(rv);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_XGS3_SWITCH_SUPPORT) && defined(INCLUDE_L3)
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (SOC_MEM_IS_VALID(unit, EGR_MTUm)) {

        int encap_bytes = 0;
        soc_info_t *si = &SOC_INFO(unit);
        soc_field_t fields[2];
        uint32 values[2];

        if (soc_feature(unit, soc_feature_egr_all_profile) ||
            (((soc_feature(unit, soc_feature_hgproxy_subtag_coe)) ||
             (soc_feature(unit, soc_feature_channelized_switching))) &&
              _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port))) {

#if defined(BCM_CHANNELIZED_SWITCHING_SUPPORT)
            if (soc_feature(unit, soc_feature_channelized_switching)) {

                if (_BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
                    encap_bytes = 4;
                } else {
                    if (BCM_PBMP_MEMBER(si->subtag_allowed_pbm, port)) {
                        encap_bytes = 4;

                    }
                }
            }
#endif

            if ((size + encap_bytes) > si->max_mtu) {

                LOG_ERROR(BSL_LS_BCM_PORT,
                    (BSL_META("MTU (%d) more than max mtu (%d) .\n"),
                    (size + encap_bytes), si->max_mtu));

                if (encap_bytes) {
                    LOG_ERROR(
                        BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                "For CoE port 0x%x, extra 4 bytes are added "
                                "to user provided MTU to account for SVTAG \n"),
                         port));
                }

                return BCM_E_PARAM;
            }

            /* Add extra encap bytes on port. */
            size += encap_bytes;

            /* Setup the fields and their values */
            fields[0] = MTU_SIZEf;  values[0] = size;
            fields[1] = MTU_ENABLEf; values[1] = 1;

            return bcm_esw_port_egr_lport_fields_set(unit, port,
                        EGR_MTUm, 2, fields, values);

        } else {
            egr_mtu_entry_t egr_mtu_entry;

            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            SOC_IF_ERROR_RETURN(soc_mem_read(unit, EGR_MTUm,
                            MEM_BLOCK_ANY, port, &egr_mtu_entry));
            /* Set up the fields */
            soc_mem_field32_set(unit, EGR_MTUm, &egr_mtu_entry, MTU_SIZEf, size);
            soc_mem_field32_set(unit, EGR_MTUm, &egr_mtu_entry, MTU_ENABLEf,
                                1);
            /* Write data to hardware */
            return soc_mem_write(unit, EGR_MTUm, MEM_BLOCK_ANY, port, &egr_mtu_entry);
        }
    } else
#endif
    {
        if (soc_feature(unit, soc_feature_egr_l3_mtu)) {
            soc_reg_t reg;

            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            reg = SOC_REG_IS_VALID(unit, EGR_MTUr) ? EGR_MTUr : EGR_MTU_SIZEr;
            return soc_reg_field32_modify(unit, reg, port,
                    (SOC_REG_FIELD_VALID(unit, reg, L3_MTU_SIZEf) ?
                    L3_MTU_SIZEf : MTU_SIZEf), size);
        }
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT && INCLUDE_L3 */

    return BCM_E_UNAVAIL;

}

/*
 * Function:
 *      bcm_esw_port_l3_mtu_get
 * Description:
 *      Get the maximum L3 frame size for the port
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      size - Maximum frame size in bytes
 * Return Value:
 *      BCM_E_XXX
 */
int
bcm_esw_port_l3_mtu_get(int unit, bcm_port_t port, int *size)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

#if defined(BCM_XGS3_SWITCH_SUPPORT) && defined(INCLUDE_L3)
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (SOC_MEM_IS_VALID(unit, EGR_MTUm)) {
       if (soc_feature(unit, soc_feature_egr_all_profile) ||
           ((soc_feature(unit, soc_feature_hgproxy_subtag_coe)) &&
                _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port))) {

            int rv = BCM_E_NONE;

            rv =  bcm_esw_port_egr_lport_field_get(unit, port,
                    EGR_MTUm, MTU_SIZEf, (uint32*)size);

#if defined(BCM_CHANNELIZED_SWITCHING_SUPPORT)
            if (BCM_SUCCESS(rv)) {
                if (soc_feature(unit, soc_feature_channelized_switching)) {
                    soc_info_t *si = &SOC_INFO(unit);

                    if (_BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
                        *size -= 4;
                    } else {
                        if (BCM_PBMP_MEMBER(si->subtag_allowed_pbm, port)) {
                            *size -= 4;
                        }
                    }
                }
            }
#endif
            return rv;

        } else {
            egr_mtu_entry_t entry;

            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            SOC_IF_ERROR_RETURN(soc_mem_read(unit, EGR_MTUm, MEM_BLOCK_ANY, port, &entry));
            *size = soc_mem_field32_get(unit, EGR_MTUm, &entry, MTU_SIZEf);
            return BCM_E_NONE;
        }
    } else
#endif
    {
        if (soc_feature(unit, soc_feature_egr_l3_mtu)) {
            soc_reg_t reg;
            uint32 rval;

            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

            reg = SOC_REG_IS_VALID(unit, EGR_MTUr) ? EGR_MTUr : EGR_MTU_SIZEr;

            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));
            *size = soc_reg_field_get(unit, reg, rval,
                    (SOC_REG_FIELD_VALID(unit, reg,L3_MTU_SIZEf) ?
                     L3_MTU_SIZEf : MTU_SIZEf));
            return BCM_E_NONE;
        }
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT && INCLUDE_L3 */

    return BCM_E_UNAVAIL;
}

#ifdef BCM_WARM_BOOT_SUPPORT
/*
 * Function:
 *     _bcm_esw_port_ipg_ifg_wb_set
 * Purpose:
 *     Restore the ifg based on the working speed and duplex
 */
STATIC int
_bcm_esw_port_ipg_ifg_wb_set(
    int unit,
    bcm_port_t port,
    soc_ipg_t *ipg,
    uint32 ifg)
{
    int speed, duplex;

    if (IS_XL_PORT(unit, port) || IS_CL_PORT(unit, port)) {
        /* XLMAC or CLMAC */
        ipg->fd_xe = ifg;
    } else {
        /* UNIMAC */
        if (SOC_PORT_USE_PORTCTRL(unit, port)) {
            BCM_IF_ERROR_RETURN
                    (bcm_esw_port_speed_get(unit, port, &speed));
            BCM_IF_ERROR_RETURN
                    (bcm_esw_port_duplex_get(unit, port, &duplex));
        } else {
            BCM_IF_ERROR_RETURN(
                MAC_SPEED_GET(PORT(unit, port).p_mac, unit, port, &speed));
            BCM_IF_ERROR_RETURN(
                MAC_DUPLEX_GET(PORT(unit, port).p_mac, unit, port, &duplex));
        }
        if (duplex == BCM_PORT_DUPLEX_FULL) {
            switch (speed) {
                case 10:
                    ipg->fd_10 = ifg;
                    break;
                case 100:
                    ipg->fd_100 = ifg;
                    break;
                case 1000:
                    ipg->fd_1000 = ifg;
                    break;
                case 2500:
                    ipg->fd_2500 = ifg;
                    break;
                default:
                    return BCM_E_PARAM;
            }
        } else {
            switch (speed) {
                case 10:
                    ipg->hd_10 = ifg;
                    break;
                case 100:
                    ipg->hd_100 = ifg;
                    break;
                default:
                    return BCM_E_PARAM;
            }
        }
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_esw_port_ipg_ifg_wb_get
 * Purpose:
 *     Get the ifg based on the working speed and duplex
 */
STATIC int
_bcm_esw_port_ipg_ifg_wb_get(
    int unit,
    bcm_port_t port,
    soc_ipg_t *ipg,
    uint32 *ifg)
{
    int speed, duplex;

    if (IS_XL_PORT(unit, port) || IS_CL_PORT(unit, port)) {
        /* XLMAC or CLMAC */
        *ifg = ipg->fd_xe;
    } else {
        /* UNIMAC */
        if (SOC_PORT_USE_PORTCTRL(unit, port)) {
            BCM_IF_ERROR_RETURN
                    (bcm_esw_port_speed_get(unit, port, &speed));
            BCM_IF_ERROR_RETURN
                    (bcm_esw_port_duplex_get(unit, port, &duplex));
        } else {
            BCM_IF_ERROR_RETURN(
                MAC_SPEED_GET(PORT(unit, port).p_mac, unit, port, &speed));
            BCM_IF_ERROR_RETURN(
                MAC_DUPLEX_GET(PORT(unit, port).p_mac, unit, port, &duplex));
        }
        if (duplex == BCM_PORT_DUPLEX_FULL) {
            switch (speed) {
                case 10:
                    *ifg = ipg->fd_10;
                    break;
                case 100:
                    *ifg = ipg->fd_100;
                    break;
                case 1000:
                    *ifg = ipg->fd_1000;
                    break;
                case 2500:
                    *ifg = ipg->fd_2500;
                    break;
                default:
                    return BCM_E_PARAM;
            }
        } else {
            switch (speed) {
                case 10:
                    *ifg = ipg->hd_10;
                    break;
                case 100:
                    *ifg = ipg->hd_100;
                    break;
                default:
                    return BCM_E_PARAM;
            }
        }
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_esw_port_ifg_wb_sync
 * Purpose:
 *     Sync port_ifg DB to scache.
 * Parameters:
 *     unit - Device unit number
 *     scache_ptr - Scache pointer.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_bcm_esw_port_ifg_wb_sync(int unit, uint8 **scache_ptr)
{
    bcm_port_t  port;
    soc_ipg_t   *si = NULL;
    uint32      ifg = 0;
    int         mode = 0;
    int         rv = BCM_E_NONE;

    if ((scache_ptr == NULL) || (*scache_ptr == NULL)) {
        return BCM_E_PARAM;
    }

    PBMP_ALL_ITER(unit, port) {
        si = &SOC_PERSIST(unit)->ipg[port];
        if (IS_E_PORT(unit, port)) {
            if (soc_feature(unit, soc_feature_ifg_wb_include_unimac) ||
                                            IS_EGPHY_PORT(unit, port)) {
                BCM_IF_ERROR_RETURN(
                    _bcm_esw_port_ipg_ifg_wb_get(unit, port, si, &ifg));
            } else {
                ifg = si->fd_xe;
            }
        } else {
            if (soc_feature(unit, soc_feature_xmac)) {
                rv = bcm_esw_port_encap_get(unit, port, &mode);
                if (BCM_E_NONE == rv) {
                    if (BCM_PORT_ENCAP_HIGIG2 == mode) {
                        ifg = si->fd_hg2;
                    } else {
                        ifg = si->fd_hg;
                    }
                }
            } else {
                ifg = si->fd_hg;
            }
        }
        sal_memcpy(*scache_ptr, &ifg, sizeof(uint32));
        *scache_ptr += sizeof(uint32);

        rv = _scache_port_print_add(unit, port, SPT_IFG, sizeof(uint32),
                *scache_ptr - sizeof(uint32));
        if (BCM_FAILURE(rv)) {
            return rv;
        }
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_esw_port_ifg_wb_reinit
 * Purpose:
 *     Retrieve port_ifg from scache.
 * Parameters:
 *     unit - Device unit number
 *     scache_ptr - Scache pointer.
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
_bcm_esw_port_ifg_wb_reinit(int unit, uint8 **scache_ptr)
{
    bcm_port_t  port;
    soc_ipg_t   *si = NULL;
    uint32      ifg = 0;
    int         mode = 0;
    int         rv = BCM_E_NONE;

    if ((scache_ptr == NULL) || (*scache_ptr == NULL)) {
        return BCM_E_PARAM;
    }

    PBMP_ALL_ITER(unit, port) {
        si = &SOC_PERSIST(unit)->ipg[port];
        sal_memcpy(&ifg, *scache_ptr, sizeof(uint32));
        if (IS_E_PORT(unit, port)) {
            if (soc_feature(unit, soc_feature_ifg_wb_include_unimac) ||
                                            IS_EGPHY_PORT(unit, port)) {
                BCM_IF_ERROR_RETURN(
                    _bcm_esw_port_ipg_ifg_wb_set(unit, port, si, ifg));
            } else {
                si->fd_xe = ifg;
            }
        } else {
            if (soc_feature(unit, soc_feature_xmac)) {
                rv = bcm_esw_port_encap_get(unit, port, &mode);
                if (BCM_E_NONE == rv) {
                    if (BCM_PORT_ENCAP_HIGIG2 == mode) {
                        si->fd_hg2 = ifg;
                    } else {
                        si->fd_hg = ifg;
                    }
                }
            } else {
                si->fd_hg = ifg;
            }
        }
        *scache_ptr += sizeof(uint32);

        rv = _scache_port_print_add(unit, port, SPT_IFG, sizeof(uint32),
                *scache_ptr - sizeof(uint32));
        if (BCM_FAILURE(rv)) {
            return rv;
        }
    }

    return BCM_E_NONE;
}
#endif

/*
 * Function:
 *      bcm_esw_port_ifg_set
 * Description:
 *      Sets the new ifg (Inter-frame gap) value
 * Parameters:
 *      unit   - Device number
 *      port   - Port number
 *      speed  - the speed for which the IFG is being set
 *      duplex - the duplex for which the IFG is being set
 *      ifg    - Inter-frame gap in bit-times
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      The function makes sure the IFG value makes sense and updates the
 *      IPG register in case the speed/duplex match the current settings
 */
int
bcm_esw_port_ifg_set(int unit, bcm_port_t port,
                 int speed, bcm_port_duplex_t duplex,
                 int ifg)
{

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_ifg_set(unit, port, speed, duplex, ifg);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    return MAC_IFG_SET(PORT(unit, port).p_mac, unit, port,
                       speed, duplex, ifg);
}

/*
 * Function:
 *      bcm_port_ifg_get
 * Description:
 *      Gets the new ifg (Inter-frame gap) value
 * Parameters:
 *      unit   - Device number
 *      port   - Port number
 *      speed  - the speed for which the IFG is being set
 *      duplex - the duplex for which the IFG is being set
 *      ifg    - Inter-frame gap in bit-times
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_ifg_get(int unit, bcm_port_t port,
                 int speed, bcm_port_duplex_t duplex,
                 int *ifg)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_ifg_get(unit, port, speed, duplex, ifg);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    return MAC_IFG_GET(PORT(unit, port).p_mac, unit, port,
                       speed, duplex, ifg);
}

/*
 * Function:
 *      bcm_port_phy_get
 * Description:
 *      General PHY register read
 * Parameters:
 *      unit - Device number
 *      port - Port number or PHY MDIO address (refer BCM_PORT_PHY_NOMAP)
 *      flags - Logical OR of one or more of the following flags:
 *              BCM_PORT_PHY_INTERNAL
 *                      Address internal SERDES PHY for port
 *              BCM_PORT_PHY_NOMAP
 *                      Instead of mapping port to PHY MDIO address,
 *                      treat port parameter as actual PHY MDIO address.
 *              BCM_PORT_PHY_CLAUSE45
 *                      Assume Clause 45 device instead of Clause 22
 *      phy_addr - PHY internal register address
 *      phy_data - (OUT) Data that was read
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_phy_get(int unit, bcm_port_t port, uint32 flags,
                 uint32 phy_reg_addr, uint32 *phy_data)
{
    uint16  phy_id;
    uint8  phy_devad;
    uint16 phy_reg;
    uint16 phy_rd_data;
    uint32 reg_flag;
    int    rv;
    int lane = -1;
    int phyn = -1, sys_side = 0;
    bcm_port_t local_port = -1;

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_phy_get(unit, port, flags, phy_reg_addr,
                                         phy_data);
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    if (!(flags & BCM_PORT_PHY_NOMAP)) {
        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_gport_phyn_validate(unit, port,
                                           &local_port, &phyn,
                                           &lane, &sys_side));
        if (local_port != -1) {
            port = local_port;
        }
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

        if(!(SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit), port))) {
            return BCM_E_PORT;
        }
    }

    if (flags & (SOC_PHY_I2C_DATA8 | SOC_PHY_I2C_DATA16 | SOC_PHY_PVT_DATA)) {
        PORT_LOCK(unit);
        rv = soc_phyctrl_reg_read(unit, port, flags, phy_reg_addr, phy_data);
        PORT_UNLOCK(unit);
        return rv;
    }

    rv       = BCM_E_UNAVAIL;
    reg_flag = BCM_PORT_PHY_REG_FLAGS(phy_reg_addr);
    if ( (reg_flag & SOC_PHY_REG_INDIRECT) ||
         (flags & (BCM_PORT_PHY_REG_RDB | BCM_PORT_PHY_REG_MACSEC)) ) {
        if (flags & BCM_PORT_PHY_NOMAP) {
            /* Indirect register access is performed through PHY driver.
             * Therefore, indirect register access is not supported if
             * BCM_PORT_PHY_NOMAP flag is set.
             */
            return BCM_E_PARAM;
        }
        phy_reg_addr &= ~SOC_PHY_REG_INDIRECT;

        if (lane >= 0) {
#if defined(PHYMOD_SUPPORT)
            SOC_PHY_PHYMOD_FORCE_LANE_SET(phy_reg_addr, lane);
#endif
        }
        if (phyn == 1) {
            flags |= SOC_PHY_INTERNAL;
        }
        PORT_LOCK(unit);
        rv = soc_phyctrl_reg_read(unit, port, flags, phy_reg_addr, phy_data);
        PORT_UNLOCK(unit);
    }

    if (rv == BCM_E_UNAVAIL) {
        if (flags & BCM_PORT_PHY_NOMAP) {
            phy_id = port;
        } else if (flags & BCM_PORT_PHY_INTERNAL) {
            phy_id = PORT_TO_PHY_ADDR_INT(unit, port);
        } else {
            phy_id = PORT_TO_PHY_ADDR(unit, port);
        }

        PORT_LOCK(unit);
        if (flags & BCM_PORT_PHY_CLAUSE45) {
            phy_devad = BCM_PORT_PHY_CLAUSE45_DEVAD(phy_reg_addr);
            phy_reg   = BCM_PORT_PHY_CLAUSE45_REGAD(phy_reg_addr);
            rv = soc_miimc45_read(unit, phy_id, phy_devad,
                                  phy_reg, &phy_rd_data);

        } else {
            phy_reg = phy_reg_addr;
            rv = soc_miim_read(unit, phy_id, phy_reg, &phy_rd_data);
        }
        PORT_UNLOCK(unit);

        if (BCM_SUCCESS(rv)) {
           *phy_data = phy_rd_data;
        }
    }

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_esw_port_phy_get: u=%d p=%d flags=0x%08x "
                         "phy_reg=0x%08x, phy_data=0x%08x, rv=%d\n"),
              unit, port, flags, phy_reg_addr, *phy_data, rv));

    return rv;
}

/*
 * Function:
 *      bcm_port_phy_set
 * Description:
 *      General PHY register write
 * Parameters:
 *      unit - Device number
 *      port - Port number or PHY MDIO address (refer BCM_PORT_PHY_NOMAP)
 *      flags - Logical OR of one or more of the following flags:
 *              BCM_PORT_PHY_INTERNAL
 *                      Address internal SERDES PHY for port
 *              BCM_PORT_PHY_NOMAP
 *                      Instead of mapping port to PHY MDIO address,
 *                      treat port parameter as actual PHY MDIO address.
 *              BCM_PORT_PHY_CLAUSE45
 *                      Assume Clause 45 device instead of Clause 22
 *              BCM_PORT_PHY_BROADCAST_WRITE
 *                      Broadcast write transactions to all MDIO buses
 *                      within one unit. All the ports that have the same
 *                      phy address as the specified port will receive
 *                      the write command.
 *      phy_addr - PHY internal register address
 *      phy_data - Data to write
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_phy_set(int unit, bcm_port_t port, uint32 flags,
                 uint32 phy_reg_addr, uint32 phy_data)
{
    uint16 phy_id;
    uint8  phy_devad;
    uint16 phy_reg;
    uint16 phy_wr_data;
    uint32 reg_flag;
    int    rv;
    int lane = -1;
    int phyn = -1, sys_side = 0;
    bcm_port_t local_port = -1;

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_phy_set(unit, port, flags, phy_reg_addr,
                                         phy_data);
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    if (!(flags & BCM_PORT_PHY_NOMAP)) {
        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_gport_phyn_validate(unit, port,
                                           &local_port, &phyn,
                                           &lane, &sys_side));
        if (local_port != -1) {
            port = local_port;
        }
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

        if(!(SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit), port))) {
            return BCM_E_PORT;
        }
    }

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_esw_port_phy_set: u=%d p=%d flags=0x%08x "
                         "phy_reg=0x%08x phy_data=0x%08x\n"),
              unit, port, flags, phy_reg_addr, phy_data));

    if (flags & (SOC_PHY_I2C_DATA8 | SOC_PHY_I2C_DATA16 | SOC_PHY_PVT_DATA)) {
        PORT_LOCK(unit);
        rv = soc_phyctrl_reg_write(unit, port, flags, phy_reg_addr, phy_data);
        PORT_UNLOCK(unit);
        return rv;
    }

    rv       = BCM_E_UNAVAIL;
    reg_flag = BCM_PORT_PHY_REG_FLAGS(phy_reg_addr);
    if ( (reg_flag & SOC_PHY_REG_INDIRECT) ||
         (flags & (BCM_PORT_PHY_REG_RDB | BCM_PORT_PHY_REG_MACSEC)) ) {
        if (flags & BCM_PORT_PHY_NOMAP) {
            /* Indirect register access is performed through PHY driver.
             * Therefore, indirect register access is not supported if
             * BCM_PORT_PHY_NOMAP flag is set.
             */
            return BCM_E_PARAM;
        }
        phy_reg_addr &= ~SOC_PHY_REG_INDIRECT;
        if (lane >= 0) {
#if defined(PHYMOD_SUPPORT)
            SOC_PHY_PHYMOD_FORCE_LANE_SET(phy_reg_addr, lane);
#endif
        }
        if (phyn == 1) {
            flags |= SOC_PHY_INTERNAL;
        }
        PORT_LOCK(unit);
        rv = soc_phyctrl_reg_write(unit, port, flags, phy_reg_addr, phy_data);
        PORT_UNLOCK(unit);
    }

    if (rv == BCM_E_UNAVAIL) {
        if (flags & BCM_PORT_PHY_NOMAP) {
            phy_id = port;
        } else if (flags & BCM_PORT_PHY_INTERNAL) {
            phy_id = PORT_TO_PHY_ADDR_INT(unit, port);
        } else {
            phy_id = PORT_TO_PHY_ADDR(unit, port);
        }

        if (flags & BCM_PORT_PHY_BROADCAST_WRITE) {
            phy_id |= 0x400;
        }

        phy_wr_data = (uint16) (phy_data & 0xffff);
        PORT_LOCK(unit);
        if (flags & BCM_PORT_PHY_CLAUSE45) {
            phy_devad = BCM_PORT_PHY_CLAUSE45_DEVAD(phy_reg_addr);
            phy_reg   = BCM_PORT_PHY_CLAUSE45_REGAD(phy_reg_addr);
            rv = soc_miimc45_write(unit, phy_id, phy_devad,
                                   phy_reg, phy_wr_data);
        } else {
            phy_reg = phy_reg_addr;
            rv = soc_miim_write(unit, phy_id, phy_reg, phy_wr_data);
        }
        PORT_UNLOCK(unit);
    }
    return rv;
}
/*
 * Function:
 *      bcm_port_phy_multi_get
 * Description:
 *      General PHY register read
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      flags - TBD
 *      dev_addr - Device address on the PHY's bus (ex. I2C addr)
 *      offset - Offset within device
 *      max_size - Requested data size
 *      data - Data buffer
 *      actual_size - Received data size
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_phy_multi_get(int unit, bcm_port_t port, uint32 flags,
                 uint32 dev_addr, uint32 offset, int max_size, uint8 *data, int *actual_size)
{
    int rv;

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_phy_multi_get(unit, port, flags, dev_addr,
                                               offset, max_size, data,
                                               actual_size);
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);
    rv = soc_phyctrl_port_phy_multi_get(unit, port, flags, dev_addr, offset, max_size, data, actual_size);
    PORT_UNLOCK(unit);
    /*
    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_esw_port_phy_multi_get: u=%d p=%d flags=0x%08x "
                         "dev_addr=0x%08x, offset=0x%08x, max_size=%d data=%p actual_size=%d rv=%d\n"),
              unit, port, flags, dev_addr, offset, max_size, data, *actual_size, rv));
    */
    return rv;
}

/*
 * Function:
 *      bcm_port_phy_modify
 * Description:
 *      General PHY register modify
 * Parameters:
 *      unit - Device number
 *      port - Port number  or PHY MDIO address (refer BCM_PORT_PHY_NOMAP)
 *      flags - Logical OR of one or more of the following flags:
 *              BCM_PORT_PHY_INTERNAL
 *                      Address internal SERDES PHY for port
 *              BCM_PORT_PHY_NOMAP
 *                      Instead of mapping port to PHY MDIO address,
 *                      treat port parameter as actual PHY MDIO address.
 *              BCM_PORT_PHY_CLAUSE45
 *                      Assume Clause 45 device instead of Clause 22
 *      phy_addr - PHY internal register address
 *      phy_data - Data to write
 *      phy_mask - Bits to modify using phy_data
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_phy_modify(int unit, bcm_port_t port, uint32 flags,
                        uint32 phy_reg_addr, uint32 phy_data, uint32 phy_mask)
{
    uint16 phy_id;
    uint8  phy_devad;
    uint16 phy_reg;
    uint16 phy_rd_data;
    uint16 phy_wr_data;
    uint32 reg_flag;
    int    rv;
    int lane = -1;
    int phyn = -1, sys_side = 0;
    bcm_port_t local_port = -1;

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_phy_modify(unit, port, flags, phy_reg_addr,
                                            phy_data, phy_mask);
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    if (!(flags & BCM_PORT_PHY_NOMAP)) {
        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_gport_phyn_validate(unit, port,
                                           &local_port, &phyn,
                                           &lane, &sys_side));
        if (local_port != -1) {
            port = local_port;
        }
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

        if(!(SOC_PBMP_MEMBER(PBMP_PORT_ALL(unit), port))) {
            return BCM_E_PORT;
        }
    }

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_esw_port_phy_modify: u=%d p=%d flags=0x%08x "
                         "phy_reg=0x%08x phy_data=0x%08x phy_mask=0x%08x\n"),
              unit, port, flags, phy_reg_addr, phy_data, phy_mask));

    rv       = BCM_E_UNAVAIL;
    reg_flag = BCM_PORT_PHY_REG_FLAGS(phy_reg_addr);
    if (reg_flag & SOC_PHY_REG_INDIRECT) {
        if (flags & BCM_PORT_PHY_NOMAP) {
            /* Indirect register access is performed through PHY driver.
             * Therefore, indirect register access is not supported if
             * BCM_PORT_PHY_NOMAP flag is set.
             */
            return BCM_E_PARAM;
        }
        phy_reg_addr &= ~SOC_PHY_REG_INDIRECT;
        if (lane >= 0) {
#if defined(PHYMOD_SUPPORT)
           SOC_PHY_PHYMOD_FORCE_LANE_SET(phy_reg_addr, lane);
#endif
        }
        if (phyn == 1) {
            flags |= SOC_PHY_INTERNAL;
        }
        PORT_LOCK(unit);
        rv = soc_phyctrl_reg_modify(unit, port, flags, phy_reg_addr,
                                    phy_data, phy_mask);
        PORT_UNLOCK(unit);
    }

    if (rv == BCM_E_UNAVAIL) {
        if (flags & BCM_PORT_PHY_NOMAP) {
            phy_id = port;
        } else if (flags & BCM_PORT_PHY_INTERNAL) {
            phy_id = PORT_TO_PHY_ADDR_INT(unit, port);
        } else {
            phy_id = PORT_TO_PHY_ADDR(unit, port);
        }

        phy_wr_data = (uint16) (phy_data & phy_mask & 0xffff);
        PORT_LOCK(unit);
        if (flags & BCM_PORT_PHY_CLAUSE45) {
            phy_devad = BCM_PORT_PHY_CLAUSE45_DEVAD(phy_reg_addr);
            phy_reg   = BCM_PORT_PHY_CLAUSE45_REGAD(phy_reg_addr);
            rv = soc_miimc45_read(unit, phy_id, phy_devad,
                                  phy_reg, &phy_rd_data);
            phy_wr_data |= (phy_rd_data & ~phy_mask);
            rv = soc_miimc45_write(unit, phy_id, phy_devad,
                                   phy_reg, phy_wr_data);
        } else {
            phy_reg = phy_reg_addr;
            rv = soc_miim_read(unit, phy_id, phy_reg, &phy_rd_data);
            if (BCM_SUCCESS(rv)) {
                phy_wr_data |= (phy_rd_data & ~phy_mask);
                rv = soc_miim_write(unit, phy_id, phy_reg, phy_wr_data);
            }
        }
        PORT_UNLOCK(unit);
    }
    return rv;
}

/*
 * Function:
 *      bcm_port_mdix_set
 * Description:
 *      Set the Auto-MDIX mode of a port/PHY
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      mode - One of:
 *              BCM_PORT_MDIX_AUTO
 *                      Enable auto-MDIX when autonegotiation is enabled
 *              BCM_PORT_MDIX_FORCE_AUTO
 *                      Enable auto-MDIX always
 *              BCM_PORT_MDIX_NORMAL
 *                      Disable auto-MDIX
 *              BCM_PORT_MDIX_XOVER
 *                      Disable auto-MDIX, and swap cable pairs
 * Return Value:
 *      BCM_E_UNAVAIL - feature unsupported by hardware
 *      BCM_E_XXX - other error
 */
int
bcm_esw_port_mdix_set(int unit, bcm_port_t port, bcm_port_mdix_t mode)
{
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_mdix_set(unit, port, mode);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);
    rv = soc_phyctrl_mdix_set(unit, port, mode);
    PORT_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_port_mdix_get
 * Description:
 *      Get the Auto-MDIX mode of a port/PHY
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      mode - (Out) One of:
 *              BCM_PORT_MDIX_AUTO
 *                      Enable auto-MDIX when autonegotiation is enabled
 *              BCM_PORT_MDIX_FORCE_AUTO
 *                      Enable auto-MDIX always
 *              BCM_PORT_MDIX_NORMAL
 *                      Disable auto-MDIX
 *              BCM_PORT_MDIX_XOVER
 *                      Disable auto-MDIX, and swap cable pairs
 * Return Value:
 *      BCM_E_UNAVAIL - feature unsupported by hardware
 *      BCM_E_XXX - other error
 */
int
bcm_esw_port_mdix_get(int unit, bcm_port_t port, bcm_port_mdix_t *mode)
{
    int rv=BCM_E_NONE;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_mdix_get(unit, port, mode);
    }

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    PORT_LOCK(unit);
    rv = soc_phyctrl_mdix_get(unit, port, mode);
    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_port_mdix_status_get
 * Description:
 *      Get the current MDIX status on a port/PHY
 * Parameters:
 *      unit    - Device number
 *      port    - Port number
 *      status  - (OUT) One of:
 *              BCM_PORT_MDIX_STATUS_NORMAL
 *                      Straight connection
 *              BCM_PORT_MDIX_STATUS_XOVER
 *                      Crossover has been performed
 * Return Value:
 *      BCM_E_UNAVAIL - feature unsupported by hardware
 *      BCM_E_XXX - other error
 */
int
bcm_esw_port_mdix_status_get(int unit, bcm_port_t port,
                         bcm_port_mdix_status_t *status)
{
    int rv=BCM_E_NONE;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_mdix_status_get(unit, port, status);
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    PORT_LOCK(unit);
    rv = soc_phyctrl_mdix_status_get(unit, port, status);
    PORT_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_port_medium_config_set
 * Description:
 *      Set the medium-specific configuration for a combo port
 * Parameters:
 *      unit     - Device number
 *      port     - Port number
 *      medium   - The medium (BCM_PORT_MEDIUM_COPPER or BCM_PORT_MEDIUM_FIBER)
 *                 to apply the configuration to
 *      config   - per-medium configuration
 * Return Value:
 *      BCM_E_XXX
 */
int
bcm_esw_port_medium_config_set(int unit, bcm_port_t port,
                           bcm_port_medium_t medium,
                           bcm_phy_config_t  *config)
{
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef PORTMOD_SUPPORT
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        rv = bcmi_esw_portctrl_medium_config_set(unit, port, medium, config);
    } else
#endif /* PORTMOD_SUPPORT */
    {
        PORT_LOCK(unit);
        rv = soc_phyctrl_medium_config_set(unit, port, medium, config);
        PORT_UNLOCK(unit);
    }

    return rv;
}

/*
 * Function:
 *      bcm_port_medium_config_get
 * Description:
 *      Get the medium-specific configuration for a combo port
 * Parameters:
 *      unit     - Device number
 *      port     - Port number
 *      medium   - The medium (BCM_PORT_MEDIUM_COPPER or BCM_PORT_MEDIUM_FIBER)
 *                 to get the config for
 *      config   - per-medium configuration
 * Return Value:
 *      BCM_E_XXX
 */
int
bcm_esw_port_medium_config_get(int unit, bcm_port_t port,
                           bcm_port_medium_t  medium,
                           bcm_phy_config_t  *config)
{
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef PORTMOD_SUPPORT
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        rv = bcmi_esw_portctrl_medium_config_get(unit, port, medium, config);
    } else
#endif /* PORTMOD_SUPPORT */
    {
        PORT_LOCK(unit);
        rv = soc_phyctrl_medium_config_get(unit, port, medium, config);
        PORT_UNLOCK(unit);
    }
    return rv;
}

/*
 * Function:
 *      bcm_port_medium_get
 * Description:
 *      Get the current medium used by a combo port
 * Parameters:
 *      unit     - Device number
 *      port     - Port number
 *      medium   - The medium (BCM_PORT_MEDIUM_COPPER or BCM_PORT_MEDIUM_FIBER)
 *                 which is currently selected
 * Return Value:
 *      BCM_E_XXX
 */
int
bcm_esw_port_medium_get(int unit, bcm_port_t port,
                    bcm_port_medium_t *medium)
{
    int rv=BCM_E_NONE;
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_medium_get(unit, port, medium);
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    PORT_LOCK(unit);
    rv = soc_phyctrl_medium_get(unit, port, medium);
    PORT_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_port_medium_status_register
 * Description:
 *      Register a callback function to be called on medium change event
 * Parameters:
 *      unit      - Device number
 *      port      - port number
 *      callback  - The callback function to call
 *      user_data - An opaque cookie to pass to callback function
 *                  whenever it is called
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_PARAM  -- NULL function pointer or bad {unit, port} combination
 *      BCM_E_FULL   -- Cannot register more than 1 callback per {unit, port}
 */
int
bcm_esw_port_medium_status_register(int                          unit,
                                bcm_port_t                   port,
                                bcm_port_medium_status_cb_t  callback,
                                void                        *user_data)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    return soc_phy_medium_status_register(unit, port, callback, user_data);
}

/*
 * Function:
 *      bcm_port_medium_status_unregister
 * Description:
 *      Unregister a callback function to be called on medium change event
 * Parameters:
 *      unit      - Device number
 *      port      - port number
 *      callback  - The callback function to call
 *      user_data - An opaque cookie to pass to callback function
 *                  whenever it is called
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_PARAM       -- Bad {unit, port} combination
 *      BCM_E_NOT_FOUND   -- The specified {unit, port, callback, user_data}
 *                           combination have not been registered before
 */
int
bcm_esw_port_medium_status_unregister(int                          unit,
                                  bcm_port_t                   port,
                                  bcm_port_medium_status_cb_t  callback,
                                  void                        *user_data)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    return soc_phy_medium_status_unregister(unit, port, callback, user_data);
}

/*
 * Function:
 *      bcm_port_phy_reset
 * Description:
 *      This function performs the low-level PHY reset and is intended to be
 *      called ONLY from callback function registered with
 *      bcm_port_phy_reset_register. Attempting to call it from any other
 *      place will break lots of things.
 * Parameters:
 *      unit    - Device number
 *      port    - Port number
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_phy_reset(int unit, bcm_port_t port)
{
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return (bcmi_esw_portctrl_phy_reset(unit, port));
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!(BCM_PBMP_MEMBER(PBMP_PORT_ALL(unit), port))) {
        return BCM_E_PORT;
    }

    PORT_LOCK(unit);
    rv = soc_phyctrl_reset(unit, port, NULL);
    PORT_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_port_phy_reset_register
 * Description:
 *      Register a callback function to be called whenever a PHY driver
 *      needs to perform a PHY reset
 * Parameters:
 *      unit      - Device number
 *      port      - port number
 *      callback  - The callback function to call
 *      user_data - An opaque cookie to pass to callback function
 *                  whenever it is called
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_PARAM       -- Bad {unit, port} combination
 *      BCM_E_NOT_FOUND   -- The specified {unit, port, callback, user_data}
 *                           combination have not been registered before
 */
int
bcm_esw_port_phy_reset_register(int unit, bcm_port_t port,
                            bcm_port_phy_reset_cb_t callback,
                            void  *user_data)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    return soc_phy_reset_register(unit, port, callback, user_data, FALSE);
}

/*
 * Function:
 *      bcm_port_phy_reset_unregister
 * Description:
 *      Unregister a callback function to be called whenever a PHY driver
 *      needs to perform a PHY reset
 * Parameters:
 *      unit      - Device number
 *      port      - port number
 *      callback  - The callback function to call
 *      user_data - An opaque cookie to pass to callback function
 *                  whenever it is called
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_PARAM       -- Bad {unit, port} combination
 *      BCM_E_NOT_FOUND   -- The specified {unit, port, callback, user_data}
 *                           combination have not been registered before
 */
int
bcm_esw_port_phy_reset_unregister(int unit, bcm_port_t port,
                              bcm_port_phy_reset_cb_t callback,
                              void  *user_data)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    return soc_phy_reset_unregister(unit, port, callback, user_data);
}

/*
 * Function:
 *      bcm_port_jam_set
 * Description:
 *      Enable or disable half duplex jamming on a port
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      enable - non-zero to enable jamming
 * Return Value:
 *      BCM_E_XXX
 */
int
bcm_esw_port_jam_set(int unit, bcm_port_t port, int enable)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!IS_E_PORT(unit, port)) {       /* HG, CPU ports */
        return enable ? BCM_E_CONFIG : BCM_E_NONE;
    }

#ifdef  BCM_XGS3_SWITCH_SUPPORT
    if (SOC_IS_XGS3_SWITCH(unit)) {
        uint32                  rval;
        int                     oenable;

        if (!IS_GE_PORT(unit, port) && !IS_FE_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        } else if (!soc_reg_field_valid(unit, GE_PORT_CONFIGr, JAM_ENf) &&
                   !soc_feature(unit, soc_feature_unimac)) {
            return BCM_E_UNAVAIL;
        }

        if (soc_feature(unit, soc_feature_unimac)) {
#if defined(BCM_GREYHOUND_SUPPORT) || defined(BCM_HURRICANE_SUPPORT)
            if ((SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANEX(unit) ||
                 SOC_IS_GREYHOUND2(unit)) &&
                (IS_XL_PORT(unit,port) || IS_CL_PORT(unit, port))) {
                return BCM_E_UNAVAIL;
            }
#endif
#ifdef BCM_KATANA_SUPPORT
            /* In KATANA, certain GE ports do not use UNIMAC driver */
            if ((SOC_IS_KATANA(unit)) && (IS_MXQ_PORT(unit, port))) {
                return BCM_E_UNAVAIL;
            }
#endif
            SOC_IF_ERROR_RETURN(READ_IPG_HD_BKP_CNTLr(unit, port, &rval));
            oenable = soc_reg_field_get(unit, IPG_HD_BKP_CNTLr, rval,
                                        HD_FC_ENAf);
#ifdef BCM_HAWKEYE_SUPPORT
            if(SOC_IS_HAWKEYE(unit)) {
                /*
                * In HAWKEYE A0, the back-pressure is disabled
                *      when the bit HD_FC_ENA is cleared (binary 0).
                * In other revision of HAWKEYE, the back-pressure is disabled
                *      when the bit HD_FC_ENA is set (binary 1).
                */
                if(soc_feature(unit, soc_feature_hawkeye_a0_war)) {
                    enable = enable ? 1 : 0;
                } else {
                    enable = enable ? 0 : 1;
                }
            } else
#endif /* BCM_HAWKEYE_SUPPORT */
            {
                enable = enable ? 1 : 0;
            }
            if (oenable != enable) {
                soc_reg_field_set(unit, IPG_HD_BKP_CNTLr, &rval, HD_FC_ENAf,
                                  enable);
                SOC_IF_ERROR_RETURN(WRITE_IPG_HD_BKP_CNTLr(unit, port, rval));
            }
        } else {
            SOC_IF_ERROR_RETURN(READ_GE_PORT_CONFIGr(unit, port, &rval));
            oenable = soc_reg_field_get(unit, GE_PORT_CONFIGr, rval, JAM_ENf);
            enable = enable ? 1 : 0;
            if (oenable != enable) {
                soc_reg_field_set(unit, GE_PORT_CONFIGr, &rval, JAM_ENf, enable);
                SOC_IF_ERROR_RETURN(WRITE_GE_PORT_CONFIGr(unit, port, rval));
            }
        }
        return BCM_E_NONE;
    }
#endif

    /* XE ports */
    return enable ? BCM_E_CONFIG : BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_jam_get
 * Description:
 *      Return half duplex jamming state
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      enable - (OUT) non-zero if jamming enabled
 * Return Value:
 *      BCM_E_XXX
 */
int
bcm_esw_port_jam_get(int unit, bcm_port_t port, int *enable)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!IS_E_PORT(unit, port)) {       /* HG, CPU ports */
        *enable = 0;
        return BCM_E_NONE;
    }

#ifdef  BCM_XGS3_SWITCH_SUPPORT
    if (SOC_IS_XGS3_SWITCH(unit)) {
        uint32                  rval;

        if (!IS_GE_PORT(unit, port) && !IS_FE_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        } else if (!soc_reg_field_valid(unit, GE_PORT_CONFIGr, JAM_ENf) &&
                   !soc_feature(unit, soc_feature_unimac)) {
            return BCM_E_UNAVAIL;
        }
#if defined(BCM_GREYHOUND_SUPPORT) || defined(BCM_HURRICANE_SUPPORT)
        else if ((SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANEX(unit) ||
                 SOC_IS_GREYHOUND2(unit)) &&
                (IS_XL_PORT(unit,port) || IS_CL_PORT(unit, port))) {
            return BCM_E_UNAVAIL;
        }
#endif

        if (soc_feature(unit, soc_feature_unimac)) {
#ifdef BCM_KATANA_SUPPORT
        /* In KATANA, certain GE ports do not use UNIMAC driver */
            if ((SOC_IS_KATANA(unit)) && (IS_MXQ_PORT(unit, port))) {
                return BCM_E_UNAVAIL;
            }
#endif
            SOC_IF_ERROR_RETURN(READ_IPG_HD_BKP_CNTLr(unit, port, &rval));
            *enable = soc_reg_field_get(unit, IPG_HD_BKP_CNTLr, rval, HD_FC_ENAf);
        } else {
            SOC_IF_ERROR_RETURN(READ_GE_PORT_CONFIGr(unit, port, &rval));
            *enable = soc_reg_field_get(unit, GE_PORT_CONFIGr, rval, JAM_ENf);
        }
        return BCM_E_NONE;
    }
#endif

    *enable = 0;
    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_cable_diag
 * Description:
 *      Run Cable Diagnostics on port
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      status - (OUT) cable diag status structure
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      Cable diagnostics are only supported by some phy types
 *      (currently 5248 10/100 phy and 546x 10/100/1000 phys)
 */
int
bcm_esw_port_cable_diag(int unit, bcm_port_t port,
                    bcm_port_cable_diag_t *status)
{
    int rv = BCM_E_NONE;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef BCM_RCPU_SUPPORT
    if (SOC_IS_RCPU_ONLY(unit) && IS_RCPU_PORT(unit, port)) {
        return BCM_E_PORT;
    }
#endif /* BCM_RCPU_SUPPORT */

#ifdef PORTMOD_SUPPORT
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_cable_diag(unit, port, status);
    } else
#endif /* PORTMOD_SUPPORT */
    {
        PORT_LOCK(unit);
        rv = soc_phyctrl_cable_diag(unit, port, status);
        PORT_UNLOCK(unit);
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_fault_get
 * Description:
 *      Get link fault type
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      flags - (OUT) flags to indicate fault type
 * Return Value:
 *      BCM_E_XXX
 */

int
bcm_esw_port_fault_get(int unit, bcm_port_t port, uint32 *flags)
{
    int rv, local_fault, remote_fault;
    int faults = FALSE;
    soc_persist_t *sop = SOC_PERSIST(unit);

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    if (SOC_PBMP_MEMBER(sop->lc_pbm_eth_buffer_mode, port)) {
        faults = FALSE;
        SOC_IF_ERROR_RETURN(soc_phyctrl_linkfault_get(unit, port, &faults));
    }

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        rv = bcmi_esw_portctrl_fault_get(unit, port, flags);
        if (SOC_PBMP_MEMBER(sop->lc_pbm_eth_buffer_mode, port)) {
            if (faults) {
                *flags |= faults;
            }
        }
        return (rv);
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                         SOC_MAC_CONTROL_FAULT_LOCAL_STATUS, &local_fault);
    if (rv == SOC_E_UNAVAIL) {
        return BCM_E_PORT;
    }
    SOC_IF_ERROR_RETURN
        (MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                         SOC_MAC_CONTROL_FAULT_REMOTE_STATUS, &remote_fault));

    *flags = 0;
    if (remote_fault) {
        *flags |= BCM_PORT_FAULT_REMOTE;
    }
    if (local_fault) {
        *flags |= BCM_PORT_FAULT_LOCAL;
    }

    if (SOC_PBMP_MEMBER(sop->lc_pbm_eth_buffer_mode, port)) {
        *flags |= faults;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_port_trunk_index_set
 * Description:
 *      Set port index of a trunk for ingress port that is used to select
 *      the egress port in the trunk.
 * Parameters:
 *      unit       - StrataSwitch PCI device unit number (driver internal).
 *      port       - Ingress port.
 *      port_index - Port index of a trunk.
 * Returns:
 *      BCM_E_xxxx
 * Note:
 *      The psc (aka rtag) vlaue needs to be 7 (set in bcm_trunk_set()) for
 *      a trunk in order to utilize this programmable hashing mechanism.
 */

int
bcm_esw_port_trunk_index_set(int unit, bcm_port_t port, int port_index)
{
#if defined(BCM_FIREBOLT_SUPPORT)
    uint32 val, mask = 0x7;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (soc_feature(unit, soc_feature_port_trunk_index)) {
        if (IS_ST_PORT(unit, port)) {
            if (!SOC_REG_IS_VALID(unit, IUSER_TRUNK_HASH_SELECTr)) {
                return BCM_E_UNAVAIL;
            }

            val = 0;
            if (!SOC_IS_RAVEN(unit)) {
                mask = 0x3;
            }
            soc_reg_field_set(unit, IUSER_TRUNK_HASH_SELECTr, &val,
                              TRUNK_CFG_VALf, port_index & mask);
            SOC_IF_ERROR_RETURN
                (WRITE_IUSER_TRUNK_HASH_SELECTr(unit, port, val));
        } else if (IS_E_PORT(unit, port)) {
            if (!SOC_REG_IS_VALID(unit, USER_TRUNK_HASH_SELECTr)) {
                return BCM_E_UNAVAIL;
            }

            val = 0;
            soc_reg_field_set(unit, USER_TRUNK_HASH_SELECTr, &val,
                              TRUNK_CFG_VALf, port_index & mask);
            SOC_IF_ERROR_RETURN
                (WRITE_USER_TRUNK_HASH_SELECTr(unit, port, val));
        }

        return BCM_E_NONE;
    }
#endif  /* BCM_FIREBOLT_SUPPORT */

    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_port_trunk_index_get
 * Description:
 *      Get port index of a trunk for ingress port that is used to select
 *      the egress port in the trunk.
 * Parameters:
 *      unit       - StrataSwitch PCI device unit number (driver internal).
 *      port       - Ingress port.
 *      port_index - (OUT) Port index of a trunk.
 * Returns:
 *      BCM_E_xxxx
 */

int
bcm_esw_port_trunk_index_get(int unit, bcm_port_t port, int *port_index)
{
#if defined(BCM_FIREBOLT_SUPPORT)
    uint32 val;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (soc_feature(unit, soc_feature_port_trunk_index)) {
        if (IS_ST_PORT(unit, port)) {
            if (!SOC_REG_IS_VALID(unit, IUSER_TRUNK_HASH_SELECTr)) {
                return BCM_E_UNAVAIL;
            }

            SOC_IF_ERROR_RETURN
               (READ_IUSER_TRUNK_HASH_SELECTr(unit, port, &val));
            *port_index = soc_reg_field_get(unit, IUSER_TRUNK_HASH_SELECTr,
                                            val, TRUNK_CFG_VALf);
        } else if (IS_E_PORT(unit, port)) {
            if (!SOC_REG_IS_VALID(unit, USER_TRUNK_HASH_SELECTr)) {
                return BCM_E_UNAVAIL;
            }

            SOC_IF_ERROR_RETURN
               (READ_USER_TRUNK_HASH_SELECTr(unit, port, &val));
            *port_index = soc_reg_field_get(unit, USER_TRUNK_HASH_SELECTr,
                                            val, TRUNK_CFG_VALf);
        }

        return BCM_E_NONE;
    }
#endif  /* BCM_FIREBOLT_SUPPORT */

    return BCM_E_UNAVAIL;
}

#ifdef BCM_XGS3_SWITCH_SUPPORT

static soc_field_t _bcm_xgs3_priority_fields[] = {
    PRIORITY0_CNGf,
    PRIORITY1_CNGf,
    PRIORITY2_CNGf,
    PRIORITY3_CNGf,
    PRIORITY4_CNGf,
    PRIORITY5_CNGf,
    PRIORITY6_CNGf,
    PRIORITY7_CNGf,
};

#endif /* BCM_XGS3_SWITCH_SUPPORT */

#ifdef BCM_TRIUMPH2_SUPPORT
STATIC
int _bcm_esw_vp_ing_pri_cng_set(int unit, bcm_gport_t port, int untagged,
                                int pkt_pri, int cfi,
                                int internal_pri, bcm_color_t color)
{
    if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) {
        return _bcm_tr2_vp_ing_pri_cng_set(unit, port, untagged,
                                           pkt_pri, cfi,
                                           internal_pri, color);
    }
    return BCM_E_PORT;
}

STATIC
int _bcm_esw_vp_ing_pri_cng_get(int unit, bcm_gport_t port, int untagged,
                                int pkt_pri, int cfi,
                                int *internal_pri, bcm_color_t *color)
{
    if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) {
        return _bcm_tr2_vp_ing_pri_cng_get(unit, port, untagged,
                                           pkt_pri, cfi,
                                           internal_pri, color);
    }
    return BCM_E_PORT;
}
#endif
/*
 * Function:
 *      bcm_port_priority_color_set
 * Purpose:
 *      Specify the color selection for the given priority.
 * Parameters:
 *      unit -  StrataSwitch PCI device unit number (driver internal).
 *      port -  Port to configure
 *      prio -  priority (aka 802.1p CoS)
 *      color - color assigned to packets with indicated priority.
 * Returns:
 *      BCM_E_NONE - Success.
 *      BCM_E_XXX
 * Notes:
 *      Available on XGS3 only.
 */
int
bcm_esw_port_priority_color_set(int unit, bcm_port_t port,
                                int prio, bcm_color_t color)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (soc_feature(unit, soc_feature_color)) {

        VLAN_CHK_PRIO(unit, prio);

#if defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_color_prio_map_profile)) {
            if (BCM_GPORT_IS_SET(port) &&
                !BCM_GPORT_IS_MODPORT(port) &&
                !BCM_GPORT_IS_LOCAL(port) &&
                !BCM_GPORT_IS_SUBPORT_PORT(port)) {
                return _bcm_esw_vp_ing_pri_cng_set(unit, port, FALSE, prio,
                                                   -1, -1, color);
            }
        }
#endif

        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef BCM_TRIUMPH2_SUPPORT
        if (soc_feature(unit, soc_feature_color_prio_map_profile)) {
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                return bcm_td3_port_ing_pri_cng_set(unit, port, FALSE,
                                                    prio, -1, -1, color);
            } else
#endif
#ifdef BCM_TRIDENT_SUPPORT
            if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
                SOC_IS_TRIUMPH3(unit)) {
                return bcm_td_port_ing_pri_cng_set(unit, port, FALSE,
                                                   prio, -1, -1, color);
            } else
#endif /* BCM_TRIDENT_SUPPORT */
            {
                return _bcm_tr2_port_priority_color_set(unit, port,
                                                        prio, color);
            }
        } else
#endif
        {
            uint32 val, oval;

            SOC_IF_ERROR_RETURN(READ_CNG_MAPr(unit, port, &val));
            oval = val;
            soc_reg_field_set(unit, CNG_MAPr, &val,
                              _bcm_xgs3_priority_fields[prio],
                              _BCM_COLOR_ENCODING(unit, color));
            if (oval != val) {
                SOC_IF_ERROR_RETURN(WRITE_CNG_MAPr(unit, port, val));
            }
            return BCM_E_NONE;
        }
    }
#endif
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_port_priority_color_get
 * Purpose:
 *      Get the color selection for the given priority.
 * Parameters:
 *      unit -  StrataSwitch PCI device unit number (driver internal).
 *      port -  Port to configure
 *      prio -  priority (aka 802.1p CoS)
 *      color - (OUT) color assigned to packets with indicated priority.
 * Returns:
 *      BCM_E_NONE - Success.
 *      BCM_E_XXX
 * Notes:
 *      Available on XGS3 only.
 */
int
bcm_esw_port_priority_color_get(int unit, bcm_port_t port,
                                int prio, bcm_color_t *color)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (soc_feature(unit, soc_feature_color)) {
        uint32 val, hw_color;
        cng_map_entry_t cng_map_entry;
        int ptr;

        /* Input parameters check. */
        if ((NULL == color)) {
            return (BCM_E_PARAM);
        }

        VLAN_CHK_PRIO(unit, prio);

#if defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_color_prio_map_profile)) {
            if (BCM_GPORT_IS_SET(port) &&
                !BCM_GPORT_IS_MODPORT(port) &&
                !BCM_GPORT_IS_LOCAL(port) &&
                !BCM_GPORT_IS_SUBPORT_PORT(port)) {
                return _bcm_esw_vp_ing_pri_cng_get(unit, port, FALSE, prio,
                                                   0, NULL, color);
            }
        }
#endif
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
        ptr = port;

#ifdef BCM_TRIUMPH2_SUPPORT
        if (soc_feature(unit, soc_feature_color_prio_map_profile)) {
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                return bcm_td3_port_ing_pri_cng_get(unit, port, FALSE,
                                                    prio, 0, NULL, color);
            } else
#endif /* BCM_TRIDENT3_SUPPORT */
#ifdef BCM_TRIDENT_SUPPORT
            if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
                SOC_IS_TRIUMPH3(unit)) {
                return bcm_td_port_ing_pri_cng_get(unit, port, FALSE,
                                                   prio, 0, NULL, color);
            } else
#endif /* BCM_TRIDENT_SUPPORT */
            {
                /* Get the pointer from the ING_PRI_CNG_MAP table */
                port_tab_entry_t pent;
                BCM_IF_ERROR_RETURN
                    (soc_mem_read(unit, PORT_TABm, MEM_BLOCK_ANY,
                                  SOC_PORT_MOD_OFFSET(unit, port), &pent));
                ptr = soc_PORT_TABm_field32_get(unit, &pent,
                                                TRUST_DOT1P_PTRf);
            }
        }
#endif
        if (SOC_MEM_IS_VALID(unit, CNG_MAPm)) {
            SOC_IF_ERROR_RETURN(READ_CNG_MAPm(unit, MEM_BLOCK_ANY,
                                              ptr, &cng_map_entry));
            hw_color = soc_CNG_MAPm_field32_get(unit, &cng_map_entry,
                                               _bcm_xgs3_priority_fields[prio]);
        } else {
            SOC_IF_ERROR_RETURN(READ_CNG_MAPr(unit, ptr, &val));
            hw_color = soc_reg_field_get(unit, CNG_MAPr, val,
                                         _bcm_xgs3_priority_fields[prio]);
        }
        *color = _BCM_COLOR_DECODING(unit, hw_color);
        return BCM_E_NONE;
    }
#endif
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_port_cfi_color_set
 * Purpose:
 *      Specify the color selection for the given CFI.
 * Parameters:
 *      unit -  StrataSwitch PCI device unit number (driver internal).
 *      port -  Port to configure
 *      cfi -   Canonical format indicator (TRUE/FALSE)
 *      color - color assigned to packets with indicated CFI.
 * Returns:
 *      BCM_E_NONE - Success.
 *      BCM_E_XXX
 * Notes:
 *      Available on XGS3 only.
 */
int
bcm_esw_port_cfi_color_set(int unit, bcm_port_t port,
                           int cfi, bcm_color_t color)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (soc_feature(unit, soc_feature_color)) {
        if (cfi < 0 || cfi > 1) {
            return BCM_E_PARAM;
        }

#if defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_color_prio_map_profile)) {
            if (BCM_GPORT_IS_SET(port) &&
                !BCM_GPORT_IS_MODPORT(port) &&
                !BCM_GPORT_IS_LOCAL(port) &&
                !BCM_GPORT_IS_SUBPORT_PORT(port)) {
                return _bcm_esw_vp_ing_pri_cng_set(unit, port, FALSE, -1,
                                                   cfi, -1, color);
            }
        }
#endif

        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            return bcm_td3_port_ing_pri_cng_set(unit, port, FALSE,
                                                -1, cfi, -1, color);
        } else
#endif
#ifdef BCM_TRIDENT_SUPPORT
        if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
            SOC_IS_TRIUMPH3(unit)) {
            return bcm_td_port_ing_pri_cng_set(unit, port, FALSE,
                                               -1, cfi, -1, color);
        } else
#endif /* BCM_TRIDENT_SUPPORT */
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAVEN_SUPPORT) \
        || defined (BCM_TRX_SUPPORT)
        if (SOC_IS_FIREBOLT2(unit) || SOC_IS_RAVEN(unit) || SOC_IS_TRX(unit) ||
            SOC_IS_HAWKEYE(unit)) {
            int                     index, pkt_pri;
            uint32 pri_map[SOC_MAX_MEM_FIELD_WORDS];

            sal_memset(pri_map, 0, sizeof(pri_map));

#if defined(BCM_TRIUMPH2_SUPPORT)
            if (soc_feature(unit, soc_feature_color_prio_map_profile)) {
                pkt_pri = -1;
                return _bcm_tr2_port_vlan_priority_map_set(unit, port, pkt_pri,
                        cfi,
                        pkt_pri, color);
            } else
#endif /* BCM_TRIUMPH2_SUPPORT */
            {
                for (pkt_pri = 0; pkt_pri <= 7; pkt_pri++) {
                    /* ING_PRI_CNG_MAP table is indexed with
                     * port[0:4] incoming priority[2:0] incoming CFI[0]
                     */
                    index = (port << 4) | (pkt_pri << 1) | cfi;
                    if (SOC_IS_TRIDENT3X(unit)) {
                        soc_mem_field32_set(unit, PHB_MAPPING_TBL_1m, &pri_map, PRIf,
                                            pkt_pri);
                        soc_mem_field32_set(unit, PHB_MAPPING_TBL_1m, &pri_map, CNGf,
                                            _BCM_COLOR_ENCODING(unit, color));
                        SOC_IF_ERROR_RETURN(WRITE_PHB_MAPPING_TBL_1m(unit,
                                                MEM_BLOCK_ALL, index, &pri_map));
                    } else {
                        soc_mem_field32_set(unit, ING_PRI_CNG_MAPm, &pri_map, PRIf,
                                            pkt_pri);
                        soc_mem_field32_set(unit, ING_PRI_CNG_MAPm, &pri_map, CNGf,
                                            _BCM_COLOR_ENCODING(unit, color));
                        SOC_IF_ERROR_RETURN(WRITE_ING_PRI_CNG_MAPm(unit,
                                                MEM_BLOCK_ALL, index, &pri_map));
                    }
                }
            }
        } else
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_RAVEN_SUPPORT || BCM_TRX_SUPPORT */
        {
            uint32 val, oval;
            SOC_IF_ERROR_RETURN(READ_CNG_MAPr(unit, port, &val));
            oval = val;
            soc_reg_field_set(unit, CNG_MAPr, &val,
                              cfi ? CFI1_CNGf : CFI0_CNGf,
                             _BCM_COLOR_ENCODING(unit, color));
            if (oval != val) {
                SOC_IF_ERROR_RETURN(WRITE_CNG_MAPr(unit, port, val));
            }
        }
        return BCM_E_NONE;
    }
#endif
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_port_cfi_color_get
 * Purpose:
 *      Get the color selection for the given CFI.
 * Parameters:
 *      unit -  StrataSwitch PCI device unit number (driver internal).
 *      port -  Port to configure
 *      cfi -   Canonical format indicator (TRUE/FALSE)
 *      color - (OUT) color assigned to packets with indicated CFI.
 * Returns:
 *      BCM_E_NONE - Success.
 *      BCM_E_XXX
 * Notes:
 *      Available on XGS3 only.
 */
int
bcm_esw_port_cfi_color_get(int unit, bcm_port_t port,
                           int cfi, bcm_color_t *color)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (soc_feature(unit, soc_feature_color)) {
        uint32 hw_color;

        if (cfi < 0 || cfi > 1) {
            return BCM_E_PARAM;
        }

        /* Input parameters check. */
        if ((NULL == color)) {
            return (BCM_E_PARAM);
        }

#if defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_color_prio_map_profile)) {
            if (BCM_GPORT_IS_SET(port) &&
                !BCM_GPORT_IS_MODPORT(port) &&
                !BCM_GPORT_IS_LOCAL(port) &&
                !BCM_GPORT_IS_SUBPORT_PORT(port)) {
                return _bcm_esw_vp_ing_pri_cng_get(unit, port, FALSE, 0,
                                                   cfi, NULL, color);
            }
        }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            return bcm_td3_port_ing_pri_cng_get(unit, port, FALSE, 0, cfi, NULL,
                                                color);
        } else
#endif /* BCM_TRIDENT3_SUPPORT */
#ifdef BCM_TRIDENT_SUPPORT
    if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
        SOC_IS_TRIUMPH3(unit)) {
        return bcm_td_port_ing_pri_cng_get(unit, port, FALSE, 0, cfi, NULL,
                                           color);
    } else
#endif /* BCM_TRIDENT_SUPPORT */
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAVEN_SUPPORT) \
        || defined(BCM_TRX_SUPPORT)
    if (SOC_IS_FIREBOLT2(unit) || SOC_IS_RAVEN(unit)
        || SOC_IS_TRX(unit) || SOC_IS_HAWKEYE(unit)) {
        int index;
        uint32 pri_map[SOC_MAX_MEM_FIELD_WORDS];

        sal_memset(pri_map, 0, sizeof(pri_map));

#if defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_color_prio_map_profile)) {
            int pkt_pri = 0;
            return _bcm_tr2_port_vlan_priority_map_get(unit, port, 0,
                                                       cfi, &pkt_pri, color);
        } else
#endif /* BCM_TRIUMPH2_SUPPORT */
        {
            /* ING_PRI_CNG_MAP table is indexed with
             * port[0:4] incoming priority[2:0] incoming CFI[0]
             */
            index = (port << 4) | cfi;
            if (SOC_IS_TRIDENT3X(unit)) {
                SOC_IF_ERROR_RETURN(READ_PHB_MAPPING_TBL_1m(unit, MEM_BLOCK_ANY,
                                                          index, &pri_map));
                hw_color = soc_mem_field32_get(unit, PHB_MAPPING_TBL_1m,
                                               &pri_map, CNGf);
            } else {
                SOC_IF_ERROR_RETURN(READ_ING_PRI_CNG_MAPm(unit, MEM_BLOCK_ANY,
                                                          index, &pri_map));
                hw_color = soc_mem_field32_get(unit, ING_PRI_CNG_MAPm,
                                               &pri_map, CNGf);
            }
        }
    } else
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_RAVEN_SUPPORT */
        {
            uint32 val;

            SOC_IF_ERROR_RETURN(READ_CNG_MAPr(unit, port, &val));
            hw_color = soc_reg_field_get(unit, CNG_MAPr, val,
                                         cfi ? CFI1_CNGf : CFI0_CNGf);
        }
        *color = _BCM_COLOR_DECODING(unit, hw_color);
        return BCM_E_NONE;
    }
#endif
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_port_vlan_priority_map_set
 * Description:
 *      Define the mapping of incomming port, packet priority, and cfi bit to
 *      switch internal priority and color.
 * Parameters:
 *      unit         - (IN) Device number
 *      port         - (IN) Port number
 *      pkt_pri      - (IN) Packet priority
 *      cfi          - (IN) Packet CFI
 *      internal_pri - (IN) Internal priority
 *      color        - (IN) color
 * Return Value:
 *      BCM_E_XXX
 * Note:
 *      This API programs only the mapping table.
 */
int
bcm_esw_port_vlan_priority_map_set(int unit, bcm_port_t port, int pkt_pri,
                                   int cfi, int internal_pri, bcm_color_t color)
{
#ifdef BCM_TRIUMPH2_SUPPORT
    int untagged = FALSE;
#endif /* BCM_TRIUMPH2_SUPPORT */

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (!soc_feature(unit, soc_feature_color_prio_map) ||
        soc_feature(unit, soc_feature_deprecated_api)) {
        return BCM_E_UNAVAIL;
    }

    if (SOC_MEM_IS_VALID(unit, ING_UNTAGGED_PHBm)) {
        if (pkt_pri == -1 && cfi == -1) {
#ifdef BCM_TRIDENT_SUPPORT
            untagged = TRUE;
#endif /* BCM_TRIDENT_SUPPORT */
            pkt_pri = 0;
            cfi = 0;
        }
    }

    if (pkt_pri < 0 || pkt_pri > 7 || cfi < 0 || cfi > 1 || internal_pri < 0 ) {
        return BCM_E_PARAM;
    }

    if (SOC_IS_TRIDENT3X(unit)) {
       if (internal_pri >= (1 << soc_mem_field_length(unit, PHB_MAPPING_TBL_1m, PRIf))) {
           return BCM_E_PARAM;
       }
    } else {
       if (internal_pri >= (1 << soc_mem_field_length(unit, ING_PRI_CNG_MAPm, PRIf))) {
           return BCM_E_PARAM;
       }
    }

#if defined(BCM_TRIUMPH2_SUPPORT)
    if (soc_feature(unit, soc_feature_color_prio_map_profile)) {
        if (BCM_GPORT_IS_SET(port) && !BCM_GPORT_IS_MODPORT(port) &&
            !BCM_GPORT_IS_LOCAL(port) && !BCM_GPORT_IS_SUBPORT_PORT(port)) {
            return _bcm_esw_vp_ing_pri_cng_set(unit, port, untagged, pkt_pri,
                                               cfi, internal_pri, color);
        }
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAVEN_SUPPORT) \
        || defined(BCM_TRX_SUPPORT)
#if defined(BCM_TRIUMPH2_SUPPORT)
    if (soc_feature(unit, soc_feature_color_prio_map_profile)) {
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            return bcm_td3_port_ing_pri_cng_set(unit, port, untagged,
                                                pkt_pri, cfi,
                                                internal_pri, color);
        } else
#endif
#if defined BCM_TRIDENT_SUPPORT
        if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
            SOC_IS_TRIUMPH3(unit)) {
            return bcm_td_port_ing_pri_cng_set(unit, port, untagged,
                                               pkt_pri, cfi,
                                               internal_pri, color);
        } else
#endif /* BCM_TRIDENT_SUPPORT */
        {
            return _bcm_tr2_port_vlan_priority_map_set(unit, port, pkt_pri,
                                                       cfi,
                                                       internal_pri, color);
        }
    } else
#endif
    if (soc_feature(unit, soc_feature_color_prio_map)) {
        int                      index;
        uint32 pri_map[SOC_MAX_MEM_FIELD_WORDS];

        sal_memset(pri_map, 0, sizeof(pri_map));

        /* ING_PRI_CNG_MAP table is indexed with
         * port[0:4] incoming priority[2:0] incoming CFI[0]
         */
        index = (port << 4) | (pkt_pri << 1) | cfi;

        if (SOC_IS_TRIDENT3X(unit)) {
            soc_mem_field32_set(unit, PHB_MAPPING_TBL_1m, &pri_map, PRIf,
                                internal_pri);
            soc_mem_field32_set(unit, PHB_MAPPING_TBL_1m, &pri_map, CNGf,
                                _BCM_COLOR_ENCODING(unit, color));
            SOC_IF_ERROR_RETURN
                (WRITE_PHB_MAPPING_TBL_1m(unit, MEM_BLOCK_ALL, index, &pri_map));
        } else {
            soc_mem_field32_set(unit, ING_PRI_CNG_MAPm, &pri_map, PRIf,
                                internal_pri);
            soc_mem_field32_set(unit, ING_PRI_CNG_MAPm, &pri_map, CNGf,
                                _BCM_COLOR_ENCODING(unit, color));
            SOC_IF_ERROR_RETURN
                (WRITE_ING_PRI_CNG_MAPm(unit, MEM_BLOCK_ALL, index, &pri_map));
        }

        return BCM_E_NONE;
   }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_RAVEN_SUPPORT || BCM_TRX_SUPPORT */
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_port_vlan_priority_map_get
 * Description:
 *      Get the mapping of incomming port, packet priority, and cfi bit to
 *      switch internal priority and color.
 * Parameters:
 *      unit         - (IN) Device number
 *      port         - (IN) Port number
 *      pkt_pri      - (IN) Packet priority
 *      cfi          - (IN) Packet CFI
 *      internal_pri - (OUT) Internal priority
 *      color        - (OUT) color
 * Return Value:
 *      BCM_E_XXX
 * Note:
 *      This API programs only the mapping table.
 */
int
bcm_esw_port_vlan_priority_map_get(int unit, bcm_port_t port, int pkt_pri,
                                   int cfi, int *internal_pri,
                                   bcm_color_t *color)
{
#if defined BCM_TRIUMPH2_SUPPORT
    int untagged = FALSE;
#endif /* BCM_TRIUMPH2_SUPPORT */

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (!soc_feature(unit, soc_feature_color_prio_map) ||
        soc_feature(unit, soc_feature_deprecated_api)) {
        return BCM_E_UNAVAIL;
    }

    /* Input parameters check. */
    if ((NULL == internal_pri) || (NULL == color)) {
        return (BCM_E_PARAM);
    }

    if (SOC_MEM_IS_VALID(unit, ING_UNTAGGED_PHBm)) {
        if (pkt_pri == -1 && cfi == -1) {
#if defined BCM_TRIDENT_SUPPORT
            untagged = TRUE;
#endif /* BCM_TRIDENT_SUPPORT */
            pkt_pri = 0;
            cfi = 0;
        }
    }

    if (pkt_pri < 0 || pkt_pri > 7 || cfi < 0 || cfi > 1) {
        return BCM_E_PARAM;
    }

#if defined(BCM_TRIUMPH2_SUPPORT)
    if (soc_feature(unit, soc_feature_color_prio_map_profile)) {
        if (BCM_GPORT_IS_SET(port) && !BCM_GPORT_IS_MODPORT(port) &&
            !BCM_GPORT_IS_LOCAL(port) && !BCM_GPORT_IS_SUBPORT_PORT(port)) {
            return _bcm_esw_vp_ing_pri_cng_get(unit, port, untagged, pkt_pri,
                                               cfi, internal_pri, color);
        }
    }
#endif

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAVEN_SUPPORT) \
        || defined(BCM_TRX_SUPPORT)
#if defined(BCM_TRIUMPH2_SUPPORT)
    if (soc_feature(unit, soc_feature_color_prio_map_profile)) {
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            return bcm_td3_port_ing_pri_cng_get(unit, port, untagged,
                                                pkt_pri, cfi,
                                                internal_pri, color);
        } else
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined BCM_TRIDENT_SUPPORT
        if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
            SOC_IS_TRIUMPH3(unit)) {
            return bcm_td_port_ing_pri_cng_get(unit, port, untagged,
                                               pkt_pri, cfi,
                                               internal_pri, color);
        } else
#endif /* BCM_TRIDENT_SUPPORT */
        {
            return _bcm_tr2_port_vlan_priority_map_get(unit, port, pkt_pri,
                                                       cfi, internal_pri,
                                                       color);
        }
    } else
#endif
    if (soc_feature(unit, soc_feature_color_prio_map)) {
        int index, hw_color;
        uint32 pri_map[SOC_MAX_MEM_FIELD_WORDS];

        sal_memset(pri_map, 0, sizeof(pri_map));

        /* ING_PRI_CNG_MAP table is indexed with
         * port[4:0] incoming priority[2:0] incoming CFI[0]
         */
        index = (port << 4) | (pkt_pri << 1) | cfi;

        LOG_INFO(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit,
                             "bcm_esw_port_vlan_priority_map_get: u=%d p=%d index=%d\n"),
                  unit, port, index));

        if (SOC_IS_TRIDENT3X(unit)) {
            SOC_IF_ERROR_RETURN
                (READ_PHB_MAPPING_TBL_1m(unit, MEM_BLOCK_ANY, index, &pri_map));
            *internal_pri = soc_mem_field32_get(unit, PHB_MAPPING_TBL_1m, &pri_map, INT_PRIf);
            hw_color = soc_mem_field32_get(unit, PHB_MAPPING_TBL_1m, &pri_map, CNGf);
        } else {
            SOC_IF_ERROR_RETURN
                (READ_ING_PRI_CNG_MAPm(unit, MEM_BLOCK_ANY, index, &pri_map));
            *internal_pri = soc_mem_field32_get(unit, ING_PRI_CNG_MAPm, &pri_map, PRIf);
            hw_color = soc_mem_field32_get(unit, ING_PRI_CNG_MAPm, &pri_map, CNGf);
        }

        *color = _BCM_COLOR_DECODING(unit, hw_color);
        return BCM_E_NONE;
   }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_RAVEN_SUPPORT || BCM_TRX_SUPPORT */
    return BCM_E_UNAVAIL;

}

/*
 * Function:
 *      bcm_esw_port_vlan_priority_unmap_set
 * Description:
 *      Define the mapping of outgoing port, internal priority, and color to
 *  outgoing packet priority and cfi bit.
 * Parameters:
 *      unit         - (IN) Device number
 *      port         - (IN) Port number
 *      internal_pri - (IN) Internal priority
 *      color        - (IN) Color
 *      pkt_pri      - (IN) Packet priority
 *      cfi          - (IN) Packet CFI
 * Return Value:
 *      BCM_E_XXX
 * Note:
 *      This API programs only the mapping table.
 */
int
bcm_esw_port_vlan_priority_unmap_set(int unit, bcm_port_t port,
                                     int internal_pri, bcm_color_t color,
                                     int pkt_pri, int cfi)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (soc_feature(unit, soc_feature_egr_qos_combo_profile)) {
        return BCM_E_UNAVAIL;
    }
#endif

    if (SOC_IS_TRIDENT3X(unit)) {
        return BCM_E_UNAVAIL;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAVEN_SUPPORT) \
        || defined(BCM_TRX_SUPPORT)
    if (soc_feature(unit, soc_feature_color_prio_map)) {
        int index, int_pri_shift;
        uint32     pri_unmap[SOC_MAX_MEM_FIELD_WORDS];
        soc_mem_t  mem = EGR_PRI_CNG_MAPm;

        int_pri_shift = SOC_IS_TRX(unit) ? 4 : 3;
        if ((internal_pri < 0 || internal_pri >= (1 << int_pri_shift)) ||
            ((color != bcmColorGreen) && (color != bcmColorYellow) &&
             (color != bcmColorRed))) {
            return BCM_E_PARAM;
        }
        if (pkt_pri < 0 || pkt_pri > 7 || cfi < 0 || cfi > 1) {
            return BCM_E_PARAM;
        }

        /* EGR_PRI_CNG_MAP table is indexed with
         * port[4:0] priority[2:0] CNG [1:0]
         * port[5:0] priority[3:0] CNG [1:0] (TRX)
         */
        index = (port << (int_pri_shift + 2)) | (internal_pri << 2) |
            _BCM_COLOR_ENCODING(unit, color);

        sal_memset(pri_unmap, 0, sizeof(pri_unmap));
        soc_mem_field32_set(unit, mem, &pri_unmap, PRIf, pkt_pri);
        soc_mem_field32_set(unit, mem, &pri_unmap, CFIf, cfi);
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem, MEM_BLOCK_ALL, index, &pri_unmap));

        if ((SOC_IS_TD_TT(unit) && !SOC_IS_TOMAHAWK3(unit)) ||
            SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit)) {
            egr_map_mh_entry_t  egr_map;

            sal_memset(&egr_map, 0, sizeof(egr_map));
            index = (port << int_pri_shift) | (internal_pri) ;
            soc_mem_field32_set(unit, EGR_MAP_MHm, &egr_map, HG_TCf, internal_pri);
            SOC_IF_ERROR_RETURN(WRITE_EGR_MAP_MHm(unit, MEM_BLOCK_ALL, index, &egr_map));
        }

        return BCM_E_NONE;
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_RAVEN_SUPPORT || BCM_TRX_SUPPORT */
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_port_vlan_priority_unmap_get
 * Description:
 *      Get the mapping of outgoing port, internal priority, and color to
 *  outgoing packet priority and cfi bit.
 * Parameters:
 *      unit         - (IN) Device number
 *      port         - (IN) Port number
 *      internal_pri - (IN) Internal priority
 *      color        - (IN) Color
 *      pkt_pri      - (OUT) Packet priority
 *      cfi          - (OUT) Packet CFI
 * Return Value:
 *      BCM_E_XXX
 * Note:
 *      This API programs only the mapping table.
 */
int
bcm_esw_port_vlan_priority_unmap_get(int unit, bcm_port_t port,
                                     int internal_pri, bcm_color_t color,
                                     int *pkt_pri, int *cfi)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (soc_feature(unit, soc_feature_egr_qos_combo_profile)) {
        return BCM_E_UNAVAIL;
    }
#endif

    if (SOC_IS_TRIDENT3X(unit)) {
        return BCM_E_UNAVAIL;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAVEN_SUPPORT) \
        || defined(BCM_TRX_SUPPORT)
    if (soc_feature(unit, soc_feature_color_prio_map)) {
        int index, int_pri_shift;
        uint32     pri_unmap[SOC_MAX_MEM_FIELD_WORDS];
        soc_mem_t  mem = EGR_PRI_CNG_MAPm;

        int_pri_shift = SOC_IS_TRX(unit) ? 4 : 3;
        if ((internal_pri < 0 || internal_pri >= (1 << int_pri_shift)) ||
            ((color != bcmColorGreen) && (color != bcmColorYellow) &&
             (color != bcmColorRed))) {
            return BCM_E_PARAM;
        }

        /* EGR_PRI_CNG_MAP table is indexed with
         * port[4:0] priority[2:0] CNG [1:0]
         * port[5:0] priority[3:0] CNG [1:0] (TRX)
         */
        index = (port << (int_pri_shift + 2)) | (internal_pri << 2) |
            _BCM_COLOR_ENCODING(unit, color);

        SOC_IF_ERROR_RETURN
            (soc_mem_read(unit, mem, MEM_BLOCK_ANY, index, pri_unmap));
        *pkt_pri = soc_mem_field32_get(unit, mem, pri_unmap, PRIf);
        *cfi = soc_mem_field32_get(unit, mem, pri_unmap, CFIf);
        return BCM_E_NONE;
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_RAVEN_SUPPORT || BCM_TRX_SUPPORT */
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_port_l3_modify_set
 * Description:
 *      Enable/Disable ingress port based L3 unicast packet operations.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      flags - bitmap of the packet operations to be enabled or disabled.
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      Available on XGS3 only.
 */
int
bcm_esw_port_l3_modify_set(int unit, bcm_port_t port, uint32 flags)
{
#if defined(BCM_XGS3_SWITCH_SUPPORT) && defined(INCLUDE_L3)
    uint64 r;
    soc_reg_t reg;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    if (SOC_IS_XGS3_SWITCH(unit)) {
        reg = IS_ST_PORT(unit, port) ?
            IEGR_PORT_L3UC_MODSr : EGR_PORT_L3UC_MODSr;
    } else {
        return BCM_E_UNAVAIL;
    }

    if (!SOC_REG_IS_VALID(unit, reg)) {
        return BCM_E_UNAVAIL;
    }

    BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg, port, 0, &r));

    soc_reg64_field32_set(unit, reg, &r, L3_UC_SA_DISABLEf,
                          (flags & BCM_PORT_L3_MODIFY_NO_SRCMAC) ? 1 : 0);

    soc_reg64_field32_set(unit, reg, &r, L3_UC_DA_DISABLEf,
                          (flags & BCM_PORT_L3_MODIFY_NO_DSTMAC) ? 1 : 0);

    soc_reg64_field32_set(unit, reg, &r, L3_UC_TTL_DISABLEf,
                          (flags & BCM_PORT_L3_MODIFY_NO_TTL) ? 1 : 0);

    soc_reg64_field32_set(unit, reg, &r, L3_UC_VLAN_DISABLEf,
                          (flags & BCM_PORT_L3_MODIFY_NO_VLAN) ? 1 : 0);

    return soc_reg_set(unit, reg, port, 0, r);
#endif /* BCM_XGS3_SWITCH_SUPPORT && INCLUDE_L3 */
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_port_l3_modify_get
 * Description:
 *      Get ingress port based L3 unicast packet operations status.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      flags - (OUT) pointer to uint32 where bitmap of the current L3 packet
 *              operations is returned.
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_UNAVAIL - Functionality not available
 * Notes:
 *      Available on XGS3 only.
 */
int
bcm_esw_port_l3_modify_get(int unit, bcm_port_t port, uint32 *flags)
{
#if defined(BCM_XGS3_SWITCH_SUPPORT) && defined(INCLUDE_L3)
    uint64 r;
    soc_reg_t reg;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    if (SOC_IS_XGS3_SWITCH(unit)) {
        reg = IS_ST_PORT(unit, port) ?
            IEGR_PORT_L3UC_MODSr : EGR_PORT_L3UC_MODSr;
    } else {
        return BCM_E_UNAVAIL;
    }

    if (!SOC_REG_IS_VALID(unit, reg)) {
        return BCM_E_UNAVAIL;
    }

    BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg, port, 0, &r));

    *flags = 0;

    if (soc_reg64_field32_get(unit, reg, r, L3_UC_SA_DISABLEf)) {
        *flags |= BCM_PORT_L3_MODIFY_NO_SRCMAC;
    }

    if (soc_reg64_field32_get(unit, reg, r, L3_UC_DA_DISABLEf)) {
        *flags |= BCM_PORT_L3_MODIFY_NO_DSTMAC;
    }

    if (soc_reg64_field32_get(unit, reg, r, L3_UC_TTL_DISABLEf)) {
        *flags |= BCM_PORT_L3_MODIFY_NO_TTL;
    }

    if (soc_reg64_field32_get(unit, reg, r, L3_UC_VLAN_DISABLEf)) {
        *flags |= BCM_PORT_L3_MODIFY_NO_VLAN;
    }

    return BCM_E_NONE;
#endif /* BCM_XGS3_SWITCH_SUPPORT && INCLUDE_L3 */
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_port_ipmc_modify_set
 * Description:
 *      Enable/Disable ingress port based L3 multicast packet operations.
 *      If the reg EGR_IPMC_CFG2r does not contain DISABLE_TTL_CHECKf field,
 *         and if flag is set , then return E_PARAM.
 *             if flag is not set, then donot  validate the field.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      flags - bitmap of the packet operations to be enabled or disabled.
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 *      Available on XGS3 only.
 */
int
bcm_esw_port_ipmc_modify_set(int unit, bcm_port_t port, uint32 flags)
{
#if defined(INCLUDE_L3)
    int          field_count;
    soc_field_t  fields[]={DISABLE_SA_REPLACEf, DISABLE_TTL_DECREMENTf,
                           DISABLE_TTL_CHECKf};
    uint32       values[]={0, 0, 0};

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    field_count = COUNTOF(fields);
    if (!soc_feature(unit, soc_feature_ip_mcast)) {
        return BCM_E_UNAVAIL;
    }

    if (soc_feature(unit, soc_feature_no_egr_ipmc_cfg)) {
        return BCM_E_UNAVAIL;
    }

    if (!SOC_REG_IS_VALID(unit, EGR_IPMC_CFG2r) &&
            !soc_feature(unit, soc_feature_egr_ipmc_cfg2_is_memory)) {
        return BCM_E_UNAVAIL;
    }
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#if defined(BCM_RAPTOR1_SUPPORT)
    if (SOC_IS_RAPTOR(unit)) {
        return BCM_E_UNAVAIL;
    }
#endif /* BCM_RAPTOR1_SUPPORT */

    values[0] = (flags & BCM_PORT_IPMC_MODIFY_NO_SRCMAC) ? 1 : 0;
    values[1] = (flags & BCM_PORT_IPMC_MODIFY_NO_TTL)    ? 1 : 0;
    values[2] = (flags & BCM_PORT_IPMC_CHECK_NO_TTL)     ? 1 : 0;

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (soc_feature(unit, soc_feature_egr_ipmc_cfg2_is_memory)) {
        return soc_mem_fields32_modify(unit, EGR_IPMC_CFG2m, port,
                field_count, fields, values);
    } else
#endif
    {
        if (values[2]) {
            if (!SOC_REG_FIELD_VALID(unit, EGR_IPMC_CFG2r, DISABLE_TTL_CHECKf)) {
                return BCM_E_PARAM;
            }
        } else {
            /* Donot include DISABLE_TTL_CHECKf for field validation in reg */
            if (!SOC_REG_FIELD_VALID(unit, EGR_IPMC_CFG2r, DISABLE_TTL_CHECKf)) {
                field_count -= 1;
            }
        }

        return soc_reg_fields32_modify(unit, EGR_IPMC_CFG2r, port,
                field_count, fields, values);
    }
#else /* INCLUDE_L3 */
    return (BCM_E_UNAVAIL);
#endif /* INCLUDE_L3 */
}

/*
 * Function:
 *      bcm_esw_port_ipmc_modify_get
 * Description:
 *      Enable/Disable ingress port based L3 multicast packet operations.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      flags - (OUT) pointer to uint32 where bitmap of the current L3 packet
 *              operations is returned.
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_UNAVAIL - Functionality not available
 * Notes:
 *      Available on XGS3 only.
 */
int
bcm_esw_port_ipmc_modify_get(int unit, bcm_port_t port, uint32 *flags)
{
#if defined(INCLUDE_L3)
    uint32 reg_val;

    if (!soc_feature(unit, soc_feature_ip_mcast)) {
        return BCM_E_UNAVAIL;
    }

    if (soc_feature(unit, soc_feature_no_egr_ipmc_cfg)) {
        return BCM_E_UNAVAIL;
    }

    if (!SOC_REG_IS_VALID(unit, EGR_IPMC_CFG2r) &&
            !soc_feature(unit, soc_feature_egr_ipmc_cfg2_is_memory)) {
        return BCM_E_UNAVAIL;
    }

#if defined(BCM_RAPTOR1_SUPPORT)
    if (SOC_IS_RAPTOR(unit)) {
        return BCM_E_UNAVAIL;
    }
#endif /* BCM_RAPTOR1_SUPPORT */

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    if (NULL == flags) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (soc_feature(unit, soc_feature_egr_ipmc_cfg2_is_memory)) {
        BCM_IF_ERROR_RETURN(READ_EGR_IPMC_CFG2m(unit, MEM_BLOCK_ANY, port, &reg_val));
        *flags = 0;
        if (soc_mem_field32_get(unit, EGR_IPMC_CFG2m, &reg_val, DISABLE_SA_REPLACEf)) {
            *flags |=  BCM_PORT_IPMC_MODIFY_NO_SRCMAC;
        }
        if (soc_mem_field32_get(unit, EGR_IPMC_CFG2m, &reg_val, DISABLE_TTL_DECREMENTf)) {
            *flags |=  BCM_PORT_IPMC_MODIFY_NO_TTL;
        }
        if (soc_mem_field32_get(unit, EGR_IPMC_CFG2m, &reg_val, DISABLE_TTL_CHECKf)) {
            *flags |=  BCM_PORT_IPMC_CHECK_NO_TTL;
        }
    } else
#endif
    {
        BCM_IF_ERROR_RETURN(READ_EGR_IPMC_CFG2r(unit, port, &reg_val));

        *flags = 0;
        if (soc_reg_field_get(unit, EGR_IPMC_CFG2r, reg_val, DISABLE_SA_REPLACEf)) {
            *flags |=  BCM_PORT_IPMC_MODIFY_NO_SRCMAC;
        }
        if (soc_reg_field_get(unit, EGR_IPMC_CFG2r, reg_val, DISABLE_TTL_DECREMENTf)) {
            *flags |=  BCM_PORT_IPMC_MODIFY_NO_TTL;
        }
        if (SOC_REG_FIELD_VALID(unit, EGR_IPMC_CFG2r, DISABLE_TTL_CHECKf)) {
            if (soc_reg_field_get(unit, EGR_IPMC_CFG2r, reg_val,
                        DISABLE_TTL_CHECKf)) {
                *flags |=  BCM_PORT_IPMC_CHECK_NO_TTL;
            }
        }
    }
    return (BCM_E_NONE);
#else /* INCLUDE_L3 */
    return (BCM_E_UNAVAIL);
#endif /* INCLUDE_L3 */
}

/*
 * Function:
 *      _bcm_port_force_forward_linkscan_handler
 * Description:
 *      Called from linkscan handler when port toggles.
 *      Adds/removes entry from LOCAL_SW_DISABLE_DEFAULT_PBM
 * Parameters:
 *      unit - Device number
 *      info - port info
 * Return Value:
 *      BCM_E_XXX
 */
void
_bcm_port_force_forward_linkscan_handler(int unit,
                bcm_port_t port, bcm_port_info_t *info)
{
    bcm_port_t local_port;
    bcm_pbmp_t *sw_disable_pbmp_linkstate =
                            p_linkstate[unit].sw_disable_pbmp_linkstate;
    int rv = BCM_E_NONE;

    if (!info) {
        return;
    }

    if (sw_disable_pbmp_linkstate == NULL) {
        return;
    }
    if (p_linkstate[unit].num_pbmp_entry) {
        PBMP_ALL_ITER(unit, local_port) {
            if (BCM_PBMP_MEMBER(sw_disable_pbmp_linkstate[local_port],
                                        port)) {
                if (info->linkstatus == BCM_PORT_LINK_STATUS_DOWN) {
                    p_linkstate[unit].lock = 1;
                    rv = bcm_esw_port_force_forward_mode_set(unit, local_port,
                                    port, BCM_PORT_FORCE_FORWARD_DISABLE);
                    p_linkstate[unit].lock = 0;
                } else if (info->linkstatus == BCM_PORT_LINK_STATUS_UP) {
                    p_linkstate[unit].lock = 1;
                    rv = bcm_esw_port_force_forward_mode_set(unit, local_port,
                                    port, BCM_PORT_FORCE_FORWARD_ALL);
                    p_linkstate[unit].lock = 0;
                }
                if (BCM_FAILURE(rv)) {
                    LOG_WARN(BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                        "bcm_esw_port_force_forward_mode_set failed for "
                            "port %d, dest_port %d, link_state %d. rv = %d\n"),
                            local_port, port, info->linkstatus, rv));
                }
            }
        }
    }
}

#if defined(BCM_TRIUMPH3_SUPPORT)
/*
 * Function:
 *      _bcm_port_force_forward_init
 * Purpose:
 *      Initialize the port_forward entries
 * Parameters:
 *      unit  - SOC unit #
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_port_force_forward_init(int unit)
{
    p_linkstate[unit].num_pbmp_entry = 0;

    if (p_linkstate[unit].sw_disable_pbmp_linkstate != NULL) {
        sal_free(p_linkstate[unit].sw_disable_pbmp_linkstate);
        p_linkstate[unit].sw_disable_pbmp_linkstate = NULL;
    }

    p_linkstate[unit].sw_disable_pbmp_linkstate = (bcm_pbmp_t*) sal_alloc(
                sizeof(bcm_pbmp_t) * SOC_MAX_NUM_PORTS,
                "SW disable pbmp linkstate");
    if (p_linkstate[unit].sw_disable_pbmp_linkstate == NULL) {
        return BCM_E_MEMORY;
    }
    sal_memset(p_linkstate[unit].sw_disable_pbmp_linkstate, 0,
                sizeof(bcm_pbmp_t) * SOC_MAX_NUM_PORTS);
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_force_forward_deinit
 * Purpose:
 *      Uninitialize the port_forward entries
 * Parameters:
 *      unit  - SOC unit #
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_port_force_forward_deinit(int unit)
{
    if (p_linkstate[unit].sw_disable_pbmp_linkstate != NULL) {
        sal_free(p_linkstate[unit].sw_disable_pbmp_linkstate);
        p_linkstate[unit].sw_disable_pbmp_linkstate = NULL;
        p_linkstate[unit].num_pbmp_entry = 0;
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_port_force_forward_add
 * Purpose:
 *      Add/Deletes an entry into the port_forward DB.
 * Parameters:
 *      unit  - SOC unit #
 *      local_port - Local port/Ingress port
 *      egr_port - destination port. Set 0 to delete it.
 * Returns:
 *      BCM_E_XXX
 */
int
_bcm_port_force_forward_add(int unit, bcm_port_t local_port,
                                        bcm_port_t egr_port)
{
    bcm_pbmp_t *sw_disable_pbmp_linkstate =
                    p_linkstate[unit].sw_disable_pbmp_linkstate;
    if (!sw_disable_pbmp_linkstate) {
        return BCM_E_INTERNAL;
    }
    /* Lock is taken while calling bcm_esw_port_force_forward_mode_set
     * from the linkscan handler. It is not taken when called by user.
     * It is to ensure that only HW tables are written to and the
     * corresponding SW datastructure remains intact.
     */
    if (p_linkstate[unit].lock) {
        return BCM_E_NONE;
    }
    BCM_PBMP_PORT_SET(sw_disable_pbmp_linkstate[local_port], egr_port);
    p_linkstate[unit].num_pbmp_entry++;
    return BCM_E_NONE;
}

#ifdef BCM_WARM_BOOT_SUPPORT
#define _BCM_PORT_WB_MAX_PBMP_V1_5 256

/*
 * Function:
 *     _bcm_port_force_forward_sync
 * Purpose:
 *     Sync port_forward DB to scache.
 * Parameters:
 *     unit - Device unit number
 *     scache_ptr - Scache pointer.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_port_force_forward_sync(int unit, uint8 **scache_ptr)
{
    bcm_port_t local_port, dst_port;
    bcm_pbmp_t *sw_disable_pbmp_linkstate = p_linkstate[unit].sw_disable_pbmp_linkstate;
    int port_count = 0, iter = 0;
    SHR_BITDCLNAME(port_bmp, _BCM_PORT_WB_MAX_PBMP_V1_5);

    if ((scache_ptr == NULL) || (*scache_ptr == NULL)) {
        return BCM_E_INTERNAL;
    }

    PBMP_ALL_ITER(unit, local_port) {
        port_count = 0;
        iter = 0;
        sal_memset(&port_bmp, 0, sizeof(port_bmp));
        BCM_PBMP_COUNT(sw_disable_pbmp_linkstate[local_port], port_count);
        if (BCM_PBMP_NOT_NULL(sw_disable_pbmp_linkstate[local_port])) {
            BCM_PBMP_ITER(sw_disable_pbmp_linkstate[local_port], dst_port) {
                if(_SHR_BITDCLSIZE(_BCM_PORT_WB_MAX_PBMP_V1_5) <
                   _SHR_BITDCLSIZE(dst_port)) {
                    /* coverity[dead_error_line] */
                    continue;
                }
                /* coverity[overrun-local] */
                SHR_BITSET(port_bmp, dst_port);
                iter++;
                if (iter >= port_count) {
                    break;
                }
            }
        }
        sal_memcpy(*scache_ptr, port_bmp, sizeof(port_bmp));
        *scache_ptr += sizeof(port_bmp);
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_port_force_forward_reinit
 * Purpose:
 *     Retrieve port_forward from hardware and scache.
 * Parameters:
 *     unit - Device unit number
 *     scache_ptr - Scache pointer.
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_port_force_forward_reinit(int unit, uint8 **scache_ptr)
{
    bcm_port_t local_port;
    int idx;
    bcm_pbmp_t *sw_disable_pbmp_linkstate =
                            p_linkstate[unit].sw_disable_pbmp_linkstate;
    SHR_BITDCLNAME(port_bmp, _BCM_PORT_WB_MAX_PBMP_V1_5);

    p_linkstate[unit].num_pbmp_entry = 0;
    if ((scache_ptr == NULL) || (*scache_ptr == NULL)) {
        return BCM_E_PARAM;
    }

    sal_memset(&port_bmp, 0, sizeof(port_bmp));
    sal_memset(sw_disable_pbmp_linkstate, 0, sizeof(bcm_pbmp_t));
    PBMP_ALL_ITER(unit, local_port) {
        sal_memcpy(&port_bmp, *scache_ptr, sizeof(port_bmp));
        *scache_ptr += sizeof(port_bmp);
        if (!SHR_BITNULL_RANGE(port_bmp, 0, _BCM_PORT_WB_MAX_PBMP_V1_5)){
            int bitcount = 0;
            SHR_BITCOUNT_RANGE(port_bmp, bitcount, 0, _BCM_PORT_WB_MAX_PBMP_V1_5);
            for(idx = 0; (idx < _BCM_PORT_WB_MAX_PBMP_V1_5) && (bitcount); idx++) {
                if(SHR_BITGET(port_bmp, idx)) {
                    BCM_PBMP_PORT_ADD(sw_disable_pbmp_linkstate[local_port], idx);
                    p_linkstate[unit].num_pbmp_entry++;
                    bitcount--;
                }
            }
        }
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_port_force_forward_scache_size
 * Purpose:
 *     Get the size of the port_forward for scache
 * Parameters:
 *     unit - Device unit number
 *     size - size of scache
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_port_force_forward_scache_size(int unit, int *size)
{
    int port_forward_size;
    int port_count = 0;
    bcm_port_t local_port;

    if (!size) {
        return BCM_E_PARAM;
    }

    /* We prefer to use a predefined size of _BCM_PORT_WB_MAX_PBMP_V1_5
     * for warmboot instead of bcm_pbmp_t. This is because of any future
     * increase in max port count for new devices which may change the
     * size of bcm_bcmp_t.
     */
    PBMP_ALL_ITER(unit, local_port) {
        port_count++;
    }
    port_forward_size = SHR_BITALLOCSIZE(_BCM_PORT_WB_MAX_PBMP_V1_5) * port_count;

    *size = port_forward_size;
    return BCM_E_NONE;
}
#endif /* BCM_WARM_BOOT_SUPPORT */
#endif /*defined(BCM_TRIUMPH3_SUPPORT)*/

/*
 * Function:
 *      bcm_port_force_forward_mode_set
 * Purpose:
 *      Set egress override port mode.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port number
 *      egr_port - (IN) Egress port number
 *      flags - (IN) Force forward flags from PORT_FORCE_FORWARD_*
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_force_forward_mode_set(int unit, bcm_port_t port,
                                    bcm_port_t egr_port, uint32 flags)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_FIREBOLT2_SUPPORT) \
    || defined(BCM_TRX_SUPPORT) || defined(BCM_RAVEN_SUPPORT)
    if (soc_feature(unit, soc_feature_force_forward)) {

        int enable = FALSE;

        if ((0 != (flags & BCM_PORT_FORCE_FORWARD_LOCAL) &&
             !SOC_IS_TRX(unit))) {
            /* We don't support local only mode on pre-TRX devices */
            return BCM_E_PARAM;
        }

        if (0 != (flags & (BCM_PORT_FORCE_FORWARD_ALL |
                           BCM_PORT_FORCE_FORWARD_LOCAL))) {
            enable = TRUE;
        }

        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
        if (enable) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, egr_port,
                                                             &egr_port));
        }

#if defined(BCM_TRIUMPH_SUPPORT)
        if (SOC_IS_TR_VL(unit)) {
            pbmp_t pbmp;
            uint64 val;
            int cpu_hg_index = 0;

            COMPILER_64_SET(val, 0, 0);
            SOC_PBMP_CLEAR(pbmp);
            if (enable) {
                SOC_PBMP_PORT_SET(pbmp, egr_port);
            }
            if (soc_mem_is_valid(unit, LOCAL_SW_DISABLE_DEFAULT_PBMm)) {
                local_sw_disable_default_pbm_entry_t entry;
                sal_memset(&entry, 0, sizeof(entry));
                soc_mem_pbmp_field_set(unit, LOCAL_SW_DISABLE_DEFAULT_PBMm,
                                       &entry, PORT_BITMAPf, &pbmp);
                BCM_IF_ERROR_RETURN
                    (soc_mem_write(unit, LOCAL_SW_DISABLE_DEFAULT_PBMm,
                                   MEM_BLOCK_ANY, port, &entry));

                cpu_hg_index = SOC_IS_KATANA2(unit) ?
                               SOC_INFO(unit).cpu_hg_pp_port_index :
                               SOC_INFO(unit).cpu_hg_index;
                if (IS_CPU_PORT(unit, port)) {
                    BCM_IF_ERROR_RETURN
                        (soc_mem_write(unit, LOCAL_SW_DISABLE_DEFAULT_PBMm,
                                       MEM_BLOCK_ANY, cpu_hg_index, &entry));
                }
            } else {
#if defined(BCM_GREYHOUND2_SUPPORT)
                if (SOC_IS_GREYHOUND2(unit)) {
                    uint64 val_hi, field_val;

                    COMPILER_64_SET(val_hi, 0, 0);
                    COMPILER_64_SET(field_val,
                        SOC_PBMP_WORD_GET(pbmp, 1), SOC_PBMP_WORD_GET(pbmp, 0));
                    soc_reg64_field_set(unit, LOCAL_SW_DISABLE_DEFAULT_PBM_LOr,
                        &val, PORT_BITMAP_LOf, field_val);

                    COMPILER_64_SET(field_val,
                        0, SOC_PBMP_WORD_GET(pbmp, 2));
                    soc_reg64_field_set(unit, LOCAL_SW_DISABLE_DEFAULT_PBM_HIr,
                        &val_hi, PORT_BITMAP_LOf, field_val);

                    
                    if (IS_ST_PORT(unit, port)) {
                        BCM_IF_ERROR_RETURN
                            (WRITE_ILOCAL_SW_DISABLE_DEFAULT_PBM_LOr(unit, port, val));
                        BCM_IF_ERROR_RETURN
                            (WRITE_ILOCAL_SW_DISABLE_DEFAULT_PBM_HIr(unit, port, val_hi));
                    } else {
                        BCM_IF_ERROR_RETURN
                            (WRITE_LOCAL_SW_DISABLE_DEFAULT_PBM_LOr(unit, port, val));
                        BCM_IF_ERROR_RETURN
                            (WRITE_LOCAL_SW_DISABLE_DEFAULT_PBM_HIr(unit, port, val_hi));
                        if (IS_CPU_PORT(unit, port)) {
                            BCM_IF_ERROR_RETURN
                                (WRITE_ILOCAL_SW_DISABLE_DEFAULT_PBM_LOr(unit, port, val));
                            BCM_IF_ERROR_RETURN
                                (WRITE_ILOCAL_SW_DISABLE_DEFAULT_PBM_HIr(unit, port, val_hi));
                        }
                    }
                } else
#endif /* BCM_GREYHOUND2_SUPPORT */
                {
                    soc_reg64_field32_set(unit
                                          , LOCAL_SW_DISABLE_DEFAULT_PBM_64r,
                                          &val, PORT_BITMAP_LOf,
                                          SOC_PBMP_WORD_GET(pbmp, 0));
                    if(!SOC_IS_ENDURO(unit) && !SOC_IS_HURRICANEX(unit) &&
                       !SOC_IS_GREYHOUND(unit)) {
                        soc_reg64_field32_set(unit,
                                              LOCAL_SW_DISABLE_DEFAULT_PBM_64r,
                                              &val, PORT_BITMAP_HIf,
                                              SOC_PBMP_WORD_GET(pbmp, 1));
                    }
                    
                    if (IS_ST_PORT(unit, port)) {
                        BCM_IF_ERROR_RETURN
                            (WRITE_ILOCAL_SW_DISABLE_DEFAULT_PBM_64r(unit, port,
                                                                     val));
                    } else {
                        BCM_IF_ERROR_RETURN
                            (WRITE_LOCAL_SW_DISABLE_DEFAULT_PBM_64r(unit, port,
                                                                    val));
                        if (IS_CPU_PORT(unit, port)) {
                            BCM_IF_ERROR_RETURN
                                (WRITE_ILOCAL_SW_DISABLE_DEFAULT_PBM_64r(unit, port,
                                                                         val));
                        }
                    }
                }
            }
        }  else
#endif /* BCM_TRIUMPH_SUPPORT */
        {
#if defined(BCM_FIREBOLT2_SUPPORT) ||  defined(BCM_RAVEN_SUPPORT)  || \
            defined(BCM_SCORPION_SUPPORT)
            if ((SOC_IS_FIREBOLT2(unit) || SOC_IS_RAVEN(unit) ||
                 SOC_IS_SC_CQ(unit)) && IS_ST_PORT(unit, port)) {
                BCM_IF_ERROR_RETURN
                    (WRITE_ILOCAL_SW_DISABLE_DEFAULT_PBMr(unit, port,
                                         (enable) ? 1 << egr_port : 0));
            } else
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_RAVEN_SUPPORT || BCM_SCORPION_SUPPORT */
            {
                BCM_IF_ERROR_RETURN
                    (WRITE_LOCAL_SW_DISABLE_DEFAULT_PBMr(unit, port,
                                    (enable) ? 1 << egr_port : 0));
            }
        }

#if defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
            int rv;
            rv = _bcm_port_force_forward_add(unit, port,
                            (enable) ? egr_port : 0);
            if (BCM_FAILURE(rv)) {
                return rv;
            }
        }
#endif /*defined(BCM_TRIUMPH3_SUPPORT)*/

#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit)) {
            uint32 mode;

            mode = (flags & BCM_PORT_FORCE_FORWARD_LOCAL) ?
                _BCM_TRX_PORT_FORCE_FORWARD_LOCAL :
                ((flags & BCM_PORT_FORCE_FORWARD_ALL) ?
                 _BCM_TRX_PORT_FORCE_FORWARD_ALL :
                 _BCM_TRX_PORT_FORCE_FORWARD_DISABLE);

            return soc_reg_field32_modify(unit, LOCAL_SW_DISABLE_CTRLr,
                                          port, SW_MODEf, mode);
        } else
#endif
        {
            return _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                         LOCAL_SW_DISABLEf,
                                         (enable) ? 1 : 0);
        }
    }
#endif /* BCM_BRADLEY_SUPPORT || BCM_FIREBOLT2_SUPPORT \
          || BCM_TRX_SUPPORT || BCM_RAVEN_SUPPORT */
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_port_force_forward_mode_get
 * Purpose:
 *      Get egress override port.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port number
 *      egr_port - (OUT) Egress port number
 *      flags - (OUT) Force forward flags from PORT_FORCE_FORWARD_*
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_force_forward_mode_get(int unit, bcm_port_t port,
                                    bcm_port_t *egr_port, uint32 *flags)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_FIREBOLT2_SUPPORT) \
        || defined(BCM_TRX_SUPPORT) || defined(BCM_RAVEN_SUPPORT)
    if (soc_feature(unit, soc_feature_force_forward)) {
        pbmp_t pbmp;
        uint32 egr_pbm;
        int ep, enabled;

        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit)) {
            uint32 val_32, mode;

            BCM_IF_ERROR_RETURN
                (READ_LOCAL_SW_DISABLE_CTRLr(unit, port, &val_32));
            mode = soc_reg_field_get(unit, LOCAL_SW_DISABLE_CTRLr,
                                         val_32, SW_MODEf);

            if (_BCM_TRX_PORT_FORCE_FORWARD_LOCAL == mode) {
                *flags = BCM_PORT_FORCE_FORWARD_LOCAL;
            } else if (_BCM_TRX_PORT_FORCE_FORWARD_ALL == mode) {
                *flags = BCM_PORT_FORCE_FORWARD_ALL;
            } else {
                *flags = BCM_PORT_FORCE_FORWARD_DISABLE;
            }
            enabled = (BCM_PORT_FORCE_FORWARD_DISABLE != mode);
        } else
#endif
        {
            BCM_IF_ERROR_RETURN
                (_bcm_esw_port_tab_get(unit, port, LOCAL_SW_DISABLEf, &enabled));
            *flags = enabled ? BCM_PORT_FORCE_FORWARD_ALL :
                BCM_PORT_FORCE_FORWARD_DISABLE;
        }

        if (enabled) {
            _bcm_gport_dest_t   dest;
            bcm_module_t        modid;
            int                 isGport = 0;

            _bcm_gport_dest_t_init(&dest);
#if defined(BCM_TRIUMPH_SUPPORT)
            if (SOC_IS_TR_VL(unit)) {
                uint64 val;

                if (soc_mem_is_valid(unit, LOCAL_SW_DISABLE_DEFAULT_PBMm)) {
                    local_sw_disable_default_pbm_entry_t entry;
                    BCM_IF_ERROR_RETURN
                        (soc_mem_read(unit, LOCAL_SW_DISABLE_DEFAULT_PBMm,
                                      MEM_BLOCK_ANY, port, &entry));
                    soc_mem_pbmp_field_get(unit, LOCAL_SW_DISABLE_DEFAULT_PBMm,
                                           &entry, PORT_BITMAPf, &pbmp);
                } else {
#if defined(BCM_GREYHOUND2_SUPPORT)
                    if (SOC_IS_GREYHOUND2(unit)) {
                        BCM_IF_ERROR_RETURN
                            (READ_LOCAL_SW_DISABLE_DEFAULT_PBM_LOr(unit, port, &val));

                        egr_pbm = soc_reg64_field32_get(unit,
                                                  LOCAL_SW_DISABLE_DEFAULT_PBM_LOr,
                                                  val, OVER_LOf);
                        SOC_PBMP_CLEAR(pbmp);
                        SOC_PBMP_WORD_SET(pbmp, 0, egr_pbm);

                        egr_pbm = soc_reg64_field32_get(unit,
                                                  LOCAL_SW_DISABLE_DEFAULT_PBM_LOr,
                                                  val, OVER_HIf);
                        SOC_PBMP_WORD_SET(pbmp, 1, egr_pbm);

                        BCM_IF_ERROR_RETURN
                            (READ_LOCAL_SW_DISABLE_DEFAULT_PBM_HIr(unit, port, &val));

                        egr_pbm = soc_reg64_field32_get(unit,
                                                  LOCAL_SW_DISABLE_DEFAULT_PBM_HIr,
                                                  val, OVER_LOf);
                        SOC_PBMP_WORD_SET(pbmp, 2, egr_pbm);
                    } else
#endif /* BCM_GREYHOUND2_SUPPORT */
                    {
                        BCM_IF_ERROR_RETURN
                            (READ_LOCAL_SW_DISABLE_DEFAULT_PBM_64r(unit, port,
                                                                   &val));
                        egr_pbm =
                            soc_reg64_field32_get(unit,
                                                  LOCAL_SW_DISABLE_DEFAULT_PBM_64r,
                                                  val, PORT_BITMAP_LOf);
                        SOC_PBMP_CLEAR(pbmp);
                        SOC_PBMP_WORD_SET(pbmp, 0, egr_pbm);
                        if ((egr_pbm == 0) &&
                            (!SOC_IS_ENDURO(unit)) && (!SOC_IS_HURRICANEX(unit)) &&
                            (!SOC_IS_GREYHOUND(unit))) {
                            egr_pbm = soc_reg64_field32_get
                                (unit,  LOCAL_SW_DISABLE_DEFAULT_PBM_64r,
                                 val, PORT_BITMAP_HIf);
                            SOC_PBMP_WORD_SET(pbmp, 1, egr_pbm);
                        }
                    }
                }
            } else
#endif /* BCM_TRIUMPH_SUPPORT */
            if ((SOC_IS_FIREBOLT2(unit) || SOC_IS_RAVEN(unit) ||
                 SOC_IS_SC_CQ(unit)) && IS_ST_PORT(unit, port)) {
                BCM_IF_ERROR_RETURN
                    (READ_ILOCAL_SW_DISABLE_DEFAULT_PBMr(unit, port, &egr_pbm));
                SOC_PBMP_CLEAR(pbmp);
                SOC_PBMP_WORD_SET(pbmp, 0, egr_pbm);
            } else {
                BCM_IF_ERROR_RETURN
                    (READ_LOCAL_SW_DISABLE_DEFAULT_PBMr(unit, port, &egr_pbm));
                SOC_PBMP_CLEAR(pbmp);
                SOC_PBMP_WORD_SET(pbmp, 0, egr_pbm);
            }
            if (SOC_PBMP_IS_NULL(pbmp)) {
                return BCM_E_INTERNAL;
            }
            /* Convert port bitmap into port number */
            SOC_PBMP_ITER(pbmp, ep) {
                break;
            }
            BCM_IF_ERROR_RETURN
                (bcm_esw_switch_control_get(unit, bcmSwitchUseGport, &isGport));
            if (isGport) {
                /* ignore return code to suport devices w/out modid assigned */
                (void)bcm_esw_stk_my_modid_get(unit, &modid);

                if (BCM_MODID_INVALID == modid) {
                    dest.gport_type = _SHR_GPORT_TYPE_DEVPORT;
                } else {
                    dest.gport_type = _SHR_GPORT_TYPE_MODPORT;
                    dest.modid = modid;
                }
                dest.port = ep;

                BCM_IF_ERROR_RETURN
                    (_bcm_esw_gport_construct(unit, &dest, &ep));
            }
            *egr_port = ep;
        }
        return BCM_E_NONE;
    }
#endif /* BCM_BRADLEY_SUPPORT || BCM_FIREBOLT2_SUPPORT \
          || BCM_TRX_SUPPORT || BCM_RAVEN_SUPPORT */
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_port_force_forward_set
 * Purpose:
 *      This function allows packets to bypass the normal forwarding
 *      logic and be sent out on a specific port instead.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      egr_port - Egress port number
 *      enable - Bypass switching logic and forward to egr_port
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_UNAVAIL - Functionality not available
 * Notes:
 *      All normal ingress processing (table lookups etc.) is still
 *      performed and used for contructing the Higig header if the
 *      forced egress port is a Higig port.
 */
int
bcm_esw_port_force_forward_set(int unit, bcm_port_t port,
                               bcm_port_t egr_port, int enable)
{
    return bcm_esw_port_force_forward_mode_set(unit, port, egr_port,
                         enable ? BCM_PORT_FORCE_FORWARD_ALL :
                                  BCM_PORT_FORCE_FORWARD_DISABLE);
}

/*
 * Function:
 *      bcm_esw_port_force_forward_get
 * Purpose:
 *      Determine forced forwarding setting for a port.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      egr_port - (OUT) Egress port number
 *      enabled - (OUT) Forced forwarding enabled
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_UNAVAIL - Functionality not available
 * Notes:
 *      If the value of enabled is zero, the value of egr_port should
 *      be ignored.
 */
int
bcm_esw_port_force_forward_get(int unit, bcm_port_t port,
                               bcm_port_t *egr_port, int *enabled)
{
    uint32 flags;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN
        (bcm_esw_port_force_forward_mode_get(unit, port, egr_port, &flags));

    *enabled = (0 != (flags & (BCM_PORT_FORCE_FORWARD_ALL |
                              BCM_PORT_FORCE_FORWARD_LOCAL)));
    return BCM_E_NONE;
}

#if defined(INCLUDE_L3)
/*
 * Function:
 *      _bcm_esw_port_ecmp_dlb_link_status_set
 * Purpose:
 *      Set ECMP DLB port link status.
 * Parameters:
 *      unit    - (IN) SOC unit number.
 *      port    - (IN) Port, not Gport.
 *      status  - (IN) ECMP DLB port link status.
 * Returns:
 *      BCM_E_xxx
 */
int
_bcm_esw_port_ecmp_dlb_link_status_set(int unit, bcm_port_t port,
                                       int status)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TOMAHAWK2_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_ecmp_dlb_optimized)) {
        rv = _bcm_th2_l3_egress_ecmp_port_status_set(unit, port, status);
    }
#endif /* BCM_TOMAHAWK2_SUPPORT || BCM_TRIDENT3_SUPPORT */

    return rv;
}
#endif /* INCLUDE_L3 */


#if defined(INCLUDE_L3)
/*
 * Function:
 *      _bcm_esw_port_ecmp_dlb_link_status_get
 * Purpose:
 *      Get ECMP DLB port link status.
 * Parameters:
 *      unit    - (IN) SOC unit number.
 *      port    - (IN) Port, not Gport.
 *      status  - (OUT) ECMP DLB port link status.
 * Returns:
 *      BCM_E_xxx
 */
int
_bcm_esw_port_ecmp_dlb_link_status_get(int unit, bcm_port_t port,
                                       int *status)
{
    int rv = BCM_E_UNAVAIL;

    if (status == NULL) {
        return BCM_E_PARAM;
    }

#if defined(BCM_TOMAHAWK2_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_ecmp_dlb_optimized)) {
       rv = _bcm_th2_l3_egress_ecmp_port_status_get(unit, port, status);
    }
#endif /* BCM_TOMAHAWK2_SUPPORT || BCM_TRIDENT3_SUPPORT */

    return rv;
}
#endif /* INCLUDE_L3 */



/*
 * Function:
 *      _bcm_esw_port_err_sym_detect_set
 * Description:
 *      Enable/Disable XAUI error symbol monitoring feature.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      enable - TRUE, enable |E| monitoring feature on the port.
 *               FALSE, disable |E| monitoring feature on the port.
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_UNAVAIL - Functionality not available
 */
#ifdef BCM_XGS3_SWITCH_SUPPORT
STATIC int
_bcm_esw_port_err_sym_detect_set(int unit, bcm_port_t port, int enable)
{
    int rv;
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "_bcm_esw_port_err_sym_detect_set: u=%d p=%d enable=%d\n"),
              unit, port, enable));

    if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port)
#ifdef BCM_GXPORT_SUPPORT
        || IS_GX_PORT(unit, port)
#endif /* BCM_GXPORT_SUPPORT */
                                 ) {
        PORT_LOCK(unit);
        rv = soc_xaui_err_sym_detect_set(unit, port, enable);
        PORT_UNLOCK(unit);
    } else {
        rv = BCM_E_UNAVAIL;
    }


    return rv;
}
#endif

/*
 * Function:
 *      _bcm_esw_port_err_sym_detect_get
 * Description:
 *      Get the status of XAUI error symbol monitoring feature.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      status - (OUT) TRUE, port is enabled, FALSE port is disabled.
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_UNAVAIL - Functionality not available
 */
#ifdef BCM_XGS3_SWITCH_SUPPORT
STATIC int
_bcm_esw_port_err_sym_detect_get(int unit, bcm_port_t port, int *status)
{
    int rv;
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port)
#ifdef BCM_GXPORT_SUPPORT
        || IS_GX_PORT(unit, port)
#endif /* BCM_GXPORT_SUPPORT */
                                 ) {
        PORT_LOCK(unit);
        rv = soc_xaui_err_sym_detect_get(unit, port, status);
        PORT_UNLOCK(unit);
    } else {
        rv = BCM_E_UNAVAIL;
    }

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "_bcm_esw_port_err_sym_detect_get: u=%d p=%d status=%d\n"),
              unit, port, *status));

    return rv;
}
#endif

/*
 * Function:
 *      _bcm_esw_port_err_sym_count_get
 * Description:
 *      Get the number of |E| symbol in XAUI lanes since last read.
 *      The |E| symbol count is cleared on read.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      count - (OUT) Number of |E| error since last read.
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_UNAVAIL - Functionality not available
 *      BCM_E_INIT    - Error symbol detect feature is not enabled
 */
STATIC int
_bcm_esw_port_err_sym_count_get(int unit, bcm_port_t port, int *count)
{
    int rv;
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    rv = BCM_E_UNAVAIL;

#ifdef BCM_XGS3_SWITCH_SUPPORT

    if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port)
#ifdef BCM_GXPORT_SUPPORT
        || IS_GX_PORT(unit, port)
#endif /* BCM_GXPORT_SUPPORT */
                                 ) {
        PORT_LOCK(unit);
        rv = soc_xaui_err_sym_count(unit, port, count);
        PORT_UNLOCK(unit);
    }
#endif

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "_bcm_esw_port_err_sym_count_get: u=%d p=%d count=%d\n"),
              unit, port, *count));

    return rv;
}

STATIC int
_bcm_esw_port_control_bridge_set(int unit, bcm_port_t port, int value)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TRIUMPH_SUPPORT
    if (SOC_IS_TR_VL(unit)) {
        bcm_pbmp_t  pbmp;            /* Port bitmap to update.*/

        if (IS_E_PORT(unit, port)
            || IS_CPU_PORT(unit, port)
            || IS_HG_PORT(unit, port)) {
            if (SOC_MEM_IS_VALID(unit, PORT_BRIDGE_BMAPm)) {
                port_bridge_bmap_entry_t entry;

                SOC_IF_ERROR_RETURN(soc_mem_read(unit, PORT_BRIDGE_BMAPm,
                            MEM_BLOCK_ANY, 0, &entry));
                soc_mem_pbmp_field_get(unit, PORT_BRIDGE_BMAPm, &entry,
                        BITMAPf, &pbmp);
                if (value && !SOC_PBMP_MEMBER(pbmp, port)) {
                    SOC_PBMP_PORT_ADD(pbmp, port);
                } else if (!value && SOC_PBMP_MEMBER(pbmp, port)) {
                    SOC_PBMP_PORT_REMOVE(pbmp, port);
                } else {
                    return BCM_E_NONE;
                }
                soc_mem_pbmp_field_set(unit, PORT_BRIDGE_BMAPm, &entry,
                        BITMAPf, &pbmp);
                SOC_IF_ERROR_RETURN(soc_mem_write(unit, PORT_BRIDGE_BMAPm,
                            MEM_BLOCK_ANY, 0, &entry));
            }
            if (SOC_REG_IS_VALID(unit, PORT_BRIDGE_BMAP_64r)) {
                uint64      buf64;           /* Buffer for reg64 value. */
                SOC_PBMP_CLEAR(pbmp);

                BCM_IF_ERROR_RETURN
                    (READ_PORT_BRIDGE_BMAP_64r(unit, &buf64));

                /* Set l3 port bitmap. */
                SOC_PBMP_WORD_SET(pbmp, 0,
                        soc_reg64_field32_get(unit, PORT_BRIDGE_BMAP_64r,
                            buf64, BITMAP_LOf));
                if (!SOC_IS_ENDURO(unit) && !SOC_IS_HURRICANEX(unit) &&
                        !SOC_IS_GREYHOUND(unit) && !SOC_IS_GREYHOUND2(unit)) {
                    SOC_PBMP_WORD_SET(pbmp, 1,
                            soc_reg64_field32_get(unit, PORT_BRIDGE_BMAP_64r,
                                    buf64, BITMAP_HIf));
                }

                if (SOC_PBMP_MEMBER(pbmp, port) && value) {
                    return BCM_E_NONE;
                }
                if (!SOC_PBMP_MEMBER(pbmp, port) && !value) {
                    return BCM_E_NONE;
                }
                if (!SOC_PBMP_MEMBER(pbmp, port) && value) {
                    SOC_PBMP_PORT_ADD(pbmp, port);
                } else if (SOC_PBMP_MEMBER(pbmp, port) && !value) {
                    SOC_PBMP_PORT_REMOVE(pbmp, port);
                }

                soc_reg64_field32_set(unit, PORT_BRIDGE_BMAP_64r,
                        &buf64, BITMAP_LOf,
                        SOC_PBMP_WORD_GET(pbmp, 0));
                if (!SOC_IS_ENDURO(unit) && !SOC_IS_HURRICANEX(unit) &&
                        !SOC_IS_GREYHOUND(unit)) {
                    soc_reg64_field32_set(unit, PORT_BRIDGE_BMAP_64r,
                            &buf64, BITMAP_HIf,
                            SOC_PBMP_WORD_GET(pbmp, 1));
                }

                BCM_IF_ERROR_RETURN
                    (WRITE_PORT_BRIDGE_BMAP_64r(unit, buf64));
            } else if (SOC_REG_IS_VALID(unit, PORT_BRIDGE_BMAP_LO_64r)) {
                /*
                 * Both PORT_BRIDGE_BMAP_LO_64r and PORT_BRIDGE_BMAP_HI_64r
                 * are expected been valid here.
                 */

                uint64      fval64, rval64;
                uint32      t_port;
                soc_reg_t   reg;
                pbmp_t      curr_pbmp;

                BCM_PBMP_CLEAR(curr_pbmp);
                COMPILER_64_ZERO(fval64);
                COMPILER_64_ZERO(rval64);


                if (port < 64) {
                    reg = PORT_BRIDGE_BMAP_LO_64r;
                    t_port = port;
                } else {
                    reg = PORT_BRIDGE_BMAP_HI_64r;
                    t_port = port - 64;
                }
                rv = soc_reg_get(unit, reg, REG_PORT_ANY, 0, &rval64);
                if (BCM_SUCCESS(rv)) {
                    fval64 = soc_reg64_field_get(unit, reg,
                                                    rval64, BITMAPf);
                    SOC_PBMP_WORD_SET(curr_pbmp, 0,
                                        COMPILER_64_LO(fval64));
                    SOC_PBMP_WORD_SET(curr_pbmp, 1,
                                        COMPILER_64_HI(fval64));

                    if (value && !SOC_PBMP_MEMBER(curr_pbmp, t_port)) {
                        SOC_PBMP_PORT_ADD(curr_pbmp, t_port);
                    } else if (!value && SOC_PBMP_MEMBER(curr_pbmp, t_port)) {
                        SOC_PBMP_PORT_REMOVE(curr_pbmp, t_port);
                    } else {
                        return BCM_E_NONE;
                    }

                    COMPILER_64_SET(fval64,
                                    SOC_PBMP_WORD_GET(curr_pbmp, 1),
                                    SOC_PBMP_WORD_GET(curr_pbmp, 0));
                    soc_reg64_field_set(unit, reg, &rval64,
                                        BITMAPf, fval64);
                    rv = soc_reg_set(unit, reg,
                                        REG_PORT_ANY, 0, rval64);
                }
            }

        }
        if (IS_HG_PORT(unit, port)) {

            if (SOC_MEM_IS_VALID(unit, PORT_BRIDGE_MIRROR_BMAPm)) {
                port_bridge_mirror_bmap_entry_t entry;

                SOC_IF_ERROR_RETURN(soc_mem_read(unit, PORT_BRIDGE_MIRROR_BMAPm,
                            MEM_BLOCK_ANY, 0, &entry));
                soc_mem_pbmp_field_get(unit, PORT_BRIDGE_MIRROR_BMAPm, &entry,
                        BITMAPf, &pbmp);
                /* it might be different to port_tab, so don't return */
                if (value && !SOC_PBMP_MEMBER(pbmp, port)) {
                    SOC_PBMP_PORT_ADD(pbmp, port);
                } else if (!value && SOC_PBMP_MEMBER(pbmp, port)) {
                    SOC_PBMP_PORT_REMOVE(pbmp, port);
                }
                soc_mem_pbmp_field_set(unit, PORT_BRIDGE_MIRROR_BMAPm, &entry,
                        BITMAPf, &pbmp);
                SOC_IF_ERROR_RETURN(soc_mem_write(unit, PORT_BRIDGE_MIRROR_BMAPm,
                            MEM_BLOCK_ANY, 0, &entry));
            }

            if (SOC_REG_IS_VALID(unit, PORT_BRIDGE_MIRROR_BMAP_64r)) {
                uint64      buf64;           /* Buffer for reg64 value. */
                SOC_PBMP_CLEAR(pbmp);

                BCM_IF_ERROR_RETURN
                    (READ_PORT_BRIDGE_MIRROR_BMAP_64r(unit, &buf64));

                /* Set port bitmap. */
                SOC_PBMP_WORD_SET(pbmp, 0,
                        soc_reg64_field32_get(unit, PORT_BRIDGE_MIRROR_BMAP_64r,
                            buf64, BITMAP_LOf));
                if (!SOC_IS_ENDURO(unit) && !SOC_IS_HURRICANEX(unit) &&
                        !SOC_IS_GREYHOUND(unit) && !SOC_IS_GREYHOUND2(unit)) {
                    SOC_PBMP_WORD_SET(pbmp, 1,
                            soc_reg64_field32_get(unit, PORT_BRIDGE_MIRROR_BMAP_64r,
                                    buf64, BITMAP_HIf));
                }

                if (!SOC_PBMP_MEMBER(pbmp, port) && value) {
                    SOC_PBMP_PORT_ADD(pbmp, port);
                } else if (SOC_PBMP_MEMBER(pbmp, port) && !value) {
                    SOC_PBMP_PORT_REMOVE(pbmp, port);
                } else {
                    return BCM_E_NONE;
                }

                soc_reg64_field32_set(unit, PORT_BRIDGE_MIRROR_BMAP_64r,
                        &buf64, BITMAP_LOf, SOC_PBMP_WORD_GET(pbmp, 0));
                if (!SOC_IS_ENDURO(unit) && !SOC_IS_HURRICANEX(unit) &&
                        !SOC_IS_GREYHOUND(unit) && !SOC_IS_GREYHOUND2(unit)) {
                    soc_reg64_field32_set(unit, PORT_BRIDGE_MIRROR_BMAP_64r,
                            &buf64, BITMAP_HIf, SOC_PBMP_WORD_GET(pbmp, 1));
                }

                BCM_IF_ERROR_RETURN
                    (WRITE_PORT_BRIDGE_MIRROR_BMAP_64r(unit, buf64));
            } else if (SOC_REG_IS_VALID(unit, PORT_BRIDGE_MIRROR_BMAP_LOr)) {
                /*
                 * Both PORT_BRIDGE_MIRROR_BMAP_LOr and PORT_BRIDGE_MIRROR_BMAP_HIr
                 * are expected been valid here.
                 */

                uint64      fval64, rval64;
                uint32      t_port;
                soc_reg_t   reg;
                pbmp_t      curr_pbmp;

                BCM_PBMP_CLEAR(curr_pbmp);
                COMPILER_64_ZERO(fval64);
                COMPILER_64_ZERO(rval64);


                if (port < 64) {
                    reg = PORT_BRIDGE_MIRROR_BMAP_LOr;
                    t_port = port;
                } else {
                    reg = PORT_BRIDGE_MIRROR_BMAP_HIr;
                    t_port = port - 64;
                }
                rv = soc_reg_get(unit, reg, REG_PORT_ANY, 0, &rval64);
                if (BCM_SUCCESS(rv)) {
                    fval64 = soc_reg64_field_get(unit, reg,
                                                    rval64, BITMAPf);
                    SOC_PBMP_WORD_SET(curr_pbmp, 0,
                                        COMPILER_64_LO(fval64));
                    SOC_PBMP_WORD_SET(curr_pbmp, 1,
                                        COMPILER_64_HI(fval64));

                    if (value && !SOC_PBMP_MEMBER(curr_pbmp, t_port)) {
                        SOC_PBMP_PORT_ADD(curr_pbmp, t_port);
                    } else if (!value && SOC_PBMP_MEMBER(curr_pbmp, t_port)) {
                        SOC_PBMP_PORT_REMOVE(curr_pbmp, t_port);
                    } else {
                        return BCM_E_NONE;
                    }

                    COMPILER_64_SET(fval64,
                                    SOC_PBMP_WORD_GET(curr_pbmp, 1),
                                    SOC_PBMP_WORD_GET(curr_pbmp, 0));
                    soc_reg64_field_set(unit, reg, &rval64,
                                        BITMAPf, fval64);
                    rv = soc_reg_set(unit, reg,
                                        REG_PORT_ANY, 0, rval64);
                }
            }
        }

        /* Allow to set bridging on higig ports as well */
        return _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                PORT_BRIDGEf, (value) ? 1 : 0);
    }
#endif /* BCM_TRIUMPH_SUPPORT */

    if (SOC_IS_XGS3_SWITCH(unit)) {
        /* Allow to set bridging on higig ports as well */
        rv =_bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                PORT_BRIDGEf, (value) ? 1 : 0);
        BCM_IF_ERROR_RETURN(rv);

        if (IS_E_PORT(unit, port) || IS_CPU_PORT(unit, port)) {

#if defined(BCM_RAPTOR_SUPPORT) || defined(BCM_FIREBOLT2_SUPPORT) || \
            defined(BCM_SCORPION_SUPPORT)
            if (soc_feature(unit, soc_feature_src_trunk_port_bridge)) {
                bcm_pbmp_t  pbmp;            /* Port bitmap to update.*/
                uint32      port_bridge_map;
#if defined (BCM_RAPTOR_SUPPORT)
                uint32 port_bridge_map_hi;
#endif

                SOC_PBMP_CLEAR(pbmp);
                BCM_IF_ERROR_RETURN
                    (READ_PORT_BRIDGE_BMAPr(unit, &port_bridge_map));

                SOC_PBMP_WORD_SET(pbmp, 0,
                        soc_reg_field_get(unit, PORT_BRIDGE_BMAPr,
                            port_bridge_map, BITMAPf));
#if defined (BCM_RAPTOR_SUPPORT)
                if (soc_feature(unit, soc_feature_register_hi)) {
                    BCM_IF_ERROR_RETURN
                        (READ_PORT_BRIDGE_BMAP_HIr(unit,
                                                   &port_bridge_map_hi));
                    SOC_PBMP_WORD_SET(pbmp, 1,
                            soc_reg_field_get(unit, PORT_BRIDGE_BMAP_HIr,
                                port_bridge_map_hi, BITMAPf));
                }
#endif
                if (!SOC_PBMP_MEMBER(pbmp, port) && value) {
                    SOC_PBMP_PORT_ADD(pbmp, port);
                    soc_reg_field_set(unit, PORT_BRIDGE_BMAPr,
                            &port_bridge_map, BITMAPf,
                            SOC_PBMP_WORD_GET(pbmp, 0));
                    BCM_IF_ERROR_RETURN
                        (WRITE_PORT_BRIDGE_BMAPr(unit, port_bridge_map));
#if defined (BCM_RAPTOR_SUPPORT)

                    if (soc_feature(unit, soc_feature_register_hi)) {
                        soc_reg_field_set(unit, PORT_BRIDGE_BMAP_HIr,
                                &port_bridge_map_hi, BITMAPf,
                                SOC_PBMP_WORD_GET(pbmp, 1));
                        BCM_IF_ERROR_RETURN
                            (WRITE_PORT_BRIDGE_BMAP_HIr(unit,
                                                        port_bridge_map_hi));
                    }
#endif
                } else if (SOC_PBMP_MEMBER(pbmp, port) && !value) {
                    SOC_PBMP_PORT_REMOVE(pbmp, port);
                    soc_reg_field_set(unit, PORT_BRIDGE_BMAPr,
                            &port_bridge_map, BITMAPf,
                            SOC_PBMP_WORD_GET(pbmp, 0));
                    BCM_IF_ERROR_RETURN
                        (WRITE_PORT_BRIDGE_BMAPr(unit, port_bridge_map));
#if defined (BCM_RAPTOR_SUPPORT)
                    if (soc_feature(unit, soc_feature_register_hi)) {
                        soc_reg_field_set(unit, PORT_BRIDGE_BMAP_HIr,
                                &port_bridge_map_hi, BITMAPf,
                                SOC_PBMP_WORD_GET(pbmp, 1));
                        BCM_IF_ERROR_RETURN
                            (WRITE_PORT_BRIDGE_BMAP_HIr(unit,
                                                        port_bridge_map_hi));
                    }
#endif
                }
            }
#endif /* BCM_RAPTOR_SUPPORT || BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */

        } else if (IS_HG_PORT(unit, port)) {
#ifdef BCM_SCORPION_SUPPORT
            if (SOC_REG_IS_VALID(unit, PORT_BRIDGE_MIRROR_BMAPr)) {
                bcm_pbmp_t  pbmp;            /* Port bitmap to update.*/
                uint32      port_bridge_mirror_map;

                SOC_PBMP_CLEAR(pbmp);
                BCM_IF_ERROR_RETURN(READ_PORT_BRIDGE_MIRROR_BMAPr(unit,
                            &port_bridge_mirror_map));
                SOC_PBMP_WORD_SET(pbmp, 0,
                        soc_reg_field_get(unit, PORT_BRIDGE_MIRROR_BMAPr,
                            port_bridge_mirror_map, BITMAPf));

                if (!SOC_PBMP_MEMBER(pbmp, port) && value) {
                    SOC_PBMP_PORT_ADD(pbmp, port);
                } else if (SOC_PBMP_MEMBER(pbmp, port) && !value) {
                    SOC_PBMP_PORT_REMOVE(pbmp, port);
                } else {
                    return BCM_E_NONE;
                }

                soc_reg_field_set(unit, PORT_BRIDGE_MIRROR_BMAPr,
                        &port_bridge_mirror_map, BITMAPf,
                        SOC_PBMP_WORD_GET(pbmp, 0));
                BCM_IF_ERROR_RETURN(WRITE_PORT_BRIDGE_MIRROR_BMAPr(unit,
                            port_bridge_mirror_map));
            }
#endif /* BCM_SCORPION_SUPPORT */
        }
    }
    return rv;
}

#if defined(BCM_TRIUMPH3_SUPPORT) && defined(INCLUDE_REGEX)
STATIC int
_bcm_esw_port_regex_control_set(int unit, bcm_gport_t gport,
                                int udp, int tcp, int enable)
{
    int vp = -1;
    bcm_port_t local_port;
    source_vp_entry_t svp_entry;
    source_trunk_map_table_entry_t stm_entry;
    ft_dst_port_config_entry_t ftdcfg;
    bcm_module_t my_modid;
    int index;
    int rv;

    if (!soc_feature(unit, soc_feature_regex)) {
        return BCM_E_UNAVAIL;
    }

    enable = !!enable;

    if (BCM_GPORT_IS_MIM_PORT(gport)) {
        vp = BCM_GPORT_MIM_PORT_ID_GET(gport);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMim)) {
            return BCM_E_NOT_FOUND;
        }
    } else if (BCM_GPORT_IS_MPLS_PORT(gport)) {
        vp = BCM_GPORT_MPLS_PORT_ID_GET(gport);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMpls)) {
            return BCM_E_NOT_FOUND;
        }
    } else if (BCM_GPORT_IS_WLAN_PORT(gport)) {
        vp = BCM_GPORT_WLAN_PORT_ID_GET(gport);
    }

    if (vp >= 0) {
        SOC_IF_ERROR_RETURN
            (READ_SOURCE_VPm(unit, MEM_BLOCK_ANY, vp, &svp_entry));
        if (tcp) {
            soc_SOURCE_VPm_field32_set(unit, &svp_entry,
                                       DPI_TCP_CREATE_ENf, enable);
            tcp = enable;
        } else {
            tcp = soc_SOURCE_VPm_field32_get(unit, &svp_entry,
                                             DPI_TCP_CREATE_ENf);
        }
        if (udp) {
            soc_SOURCE_VPm_field32_set(unit, &svp_entry,
                                       DPI_UDP_CREATE_ENf, enable);
            udp = enable;
        } else {
            udp = soc_SOURCE_VPm_field32_get(unit, &svp_entry,
                                             DPI_UDP_CREATE_ENf);
        }
        if (tcp + udp) {
            soc_SOURCE_VPm_field32_set(unit, &svp_entry, DPI_ENABLEf, 1);
        } else {
            soc_SOURCE_VPm_field32_set(unit, &svp_entry, DPI_ENABLEf, 0);
        }
        BCM_IF_ERROR_RETURN(WRITE_SOURCE_VPm(unit, MEM_BLOCK_ALL, vp, &svp_entry));
    } else {
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_gport_validate(unit, gport, &local_port));
        /* Port sanity check. */
        if (!SOC_PORT_ADDRESSABLE(unit, local_port)) {
            return (BCM_E_PORT);
        }

        /* Get local module id. */
        BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, &my_modid));

        soc_mem_lock(unit, SOURCE_TRUNK_MAP_TABLEm);

        /* Calculate table index. */
        rv = _bcm_esw_src_mod_port_table_index_get(unit, my_modid,
                                                   local_port, &index);

        if(BCM_FAILURE(rv)) {
            soc_mem_unlock(unit, SOURCE_TRUNK_MAP_TABLEm);
            return rv;
        }

        rv = READ_SOURCE_TRUNK_MAP_TABLEm(unit, MEM_BLOCK_ANY,
                                         index, &stm_entry);
        if(BCM_FAILURE(rv)) {
            soc_mem_unlock(unit, SOURCE_TRUNK_MAP_TABLEm);
            return rv;
        }

        if (tcp) {
            soc_SOURCE_TRUNK_MAP_TABLEm_field32_set(unit, &stm_entry,
                                                    DPI_TCP_CREATE_ENf, enable);
            tcp = enable;
        } else {
            tcp = soc_SOURCE_TRUNK_MAP_TABLEm_field32_get(unit, &stm_entry,
                                                          DPI_TCP_CREATE_ENf);
        }
        if (udp) {
            soc_SOURCE_TRUNK_MAP_TABLEm_field32_set(unit, &stm_entry,
                                                    DPI_UDP_CREATE_ENf, enable);
            udp = enable;
        } else {
            udp = soc_SOURCE_TRUNK_MAP_TABLEm_field32_get(unit, &stm_entry,
                                                          DPI_UDP_CREATE_ENf);
        }
        if (tcp + udp) {
            soc_SOURCE_TRUNK_MAP_TABLEm_field32_set(unit, &stm_entry, DPI_ENABLEf, 1);
        } else {
            soc_SOURCE_TRUNK_MAP_TABLEm_field32_set(unit, &stm_entry, DPI_ENABLEf, 0);
        }

        rv = WRITE_SOURCE_TRUNK_MAP_TABLEm(unit, MEM_BLOCK_ALL,
                                          index, &stm_entry);

        soc_mem_unlock(unit, SOURCE_TRUNK_MAP_TABLEm);
        if(BCM_FAILURE(rv)) {
            return rv;
        }

        SOC_IF_ERROR_RETURN(READ_FT_DST_PORT_CONFIGm(unit, MEM_BLOCK_ANY,
                                                     local_port, &ftdcfg));
        soc_FT_DST_PORT_CONFIGm_field32_set(unit, &ftdcfg,
                                            DPI_TCP_CREATE_ENf, !!tcp);
        soc_FT_DST_PORT_CONFIGm_field32_set(unit, &ftdcfg,
                                            DPI_UDP_CREATE_ENf, !!udp);
        if (tcp + udp) {
            soc_FT_DST_PORT_CONFIGm_field32_set(unit, &ftdcfg, DPI_ENABLEf, 1);
        } else {
            soc_FT_DST_PORT_CONFIGm_field32_set(unit, &ftdcfg, DPI_ENABLEf, 0);
        }
        SOC_IF_ERROR_RETURN(WRITE_FT_DST_PORT_CONFIGm(unit, MEM_BLOCK_ANY,
                                                      local_port, &ftdcfg));
    }
    return BCM_E_NONE;
}

STATIC int _bcm_esw_port_regex_control_get(int unit, bcm_gport_t gport,
                                           int *udp, int *tcp, int *enable)
{
    int vp = -1;
    bcm_port_t local_port;
    source_vp_entry_t svp_entry;
    source_trunk_map_table_entry_t stm_entry;
    ft_dst_port_config_entry_t ftdcfg;
    bcm_module_t my_modid;
    int index;

    if (!soc_feature(unit, soc_feature_regex)) {
        return BCM_E_UNAVAIL;
    }

    if (BCM_GPORT_IS_MIM_PORT(gport)) {
        vp = BCM_GPORT_MIM_PORT_ID_GET(gport);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMim)) {
            return BCM_E_NOT_FOUND;
        }
    } else if (BCM_GPORT_IS_MPLS_PORT(gport)) {
        vp = BCM_GPORT_MPLS_PORT_ID_GET(gport);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMpls)) {
            return BCM_E_NOT_FOUND;
        }
    } else if (BCM_GPORT_IS_WLAN_PORT(gport)) {
        vp = BCM_GPORT_WLAN_PORT_ID_GET(gport);
    }

    if (vp >= 0) {
        SOC_IF_ERROR_RETURN(READ_SOURCE_VPm(unit, MEM_BLOCK_ANY, vp, &svp_entry));
        *tcp    = soc_SOURCE_VPm_field32_get(unit, &svp_entry, DPI_TCP_CREATE_ENf);
        *udp    = soc_SOURCE_VPm_field32_get(unit, &svp_entry, DPI_UDP_CREATE_ENf);
        *enable = soc_SOURCE_VPm_field32_get(unit, &svp_entry, DPI_ENABLEf);
    } else {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, gport, &local_port));
        /* Port sanity check. */
        if (!SOC_PORT_ADDRESSABLE(unit, local_port)) {
            return (BCM_E_PORT);
        }

        /* Get local module id. */
        BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, &my_modid));

        /* Calculate table index. */
        BCM_IF_ERROR_RETURN(_bcm_esw_src_mod_port_table_index_get(unit, my_modid,
                                                                  local_port, &index));

        BCM_IF_ERROR_RETURN(READ_SOURCE_TRUNK_MAP_TABLEm(unit, MEM_BLOCK_ANY,
                                                         index, &stm_entry));
        *tcp = soc_SOURCE_TRUNK_MAP_TABLEm_field32_get(unit, &stm_entry,
                                                       DPI_TCP_CREATE_ENf);
        *udp = soc_SOURCE_TRUNK_MAP_TABLEm_field32_get(unit, &stm_entry,
                                                       DPI_UDP_CREATE_ENf);
        SOC_IF_ERROR_RETURN(READ_FT_DST_PORT_CONFIGm(unit, MEM_BLOCK_ANY,
                                                     local_port, &ftdcfg));
        *enable = soc_FT_DST_PORT_CONFIGm_field32_get(unit, &ftdcfg, DPI_ENABLEf);
    }
    return BCM_E_NONE;
}
#endif

#if defined(BCM_SHADOW_SUPPORT)
STATIC int
_bcm_port_type_shadow_support (int unit, bcm_port_t port,
                                    bcm_port_control_t type)
{
    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "_bcm_port_type_shadow_support : u=%d p=%d type=%d\n"),
              unit, port, (int)type));

    switch (type)
    {
        /* Shadoow supported port control types */
        case bcmPortControlManagementPacketIp6Reserved:
        case bcmPortControlManagementPacketIp4Reserved:
        case bcmPortControlManagementPacketLinkConstrained:
        case bcmPortControlManagementPacketGarp:
        case bcmPortControlManagementPacketCos:
        case bcmPortControlManagementPacketColor:
        case bcmPortControlTaggedL3PacketPktPri:
        case bcmPortControlTaggedMPLSPacketPktPri:
        case bcmPortControlTaggedMPLSL3PacketPktPri:
        case bcmPortControlRxEnable:
        case bcmPortControlTxEnable:
        case bcmPortControlPFCEthertype:
        case bcmPortControlPFCOpcode:
        case bcmPortControlPFCReceive:
        case bcmPortControlPFCTransmit:
        case bcmPortControlPFCClasses:
        case bcmPortControlPFCPassFrames:
        case bcmPortControlPFCDestMacOui:
        case bcmPortControlPFCDestMacNonOui:
        case bcmPortControlPFCRefreshTime:
        case bcmPortControlPFCXOffTime:
        case bcmPortControlEEETransmitWakeTime:
        case bcmPortControlEEEReceiveWakeTime:
        case bcmPortControlEEETransmitSleepTime:
        case bcmPortControlEEEReceiveSleepTime:
        case bcmPortControlEEETransmitQuietTime:
        case bcmPortControlEEEReceiveQuietTime:
        case bcmPortControlEEETransmitRefreshTime:
        case bcmPortControlEEEEnable:
        case bcmPortControlEEETransmitIdleTime:
        case bcmPortControlEEETransmitEventCount:
        case bcmPortControlEEETransmitDuration:
        case bcmPortControlEEEReceiveEventCount:
        case bcmPortControlEEEReceiveDuration:
        case bcmPortControlEEETransmitIdleTimeHund:
        case bcmPortControlEEETransmitWakeTimeHund:
        case bcmPortControlEEETransmitMinLPITime:
        case bcmPortControlEEETransmitMinLPITimeHund:
            if (IS_IL_PORT(unit, port)) { /* No support for IL port type */
                return FALSE;
            }
            /* Fall through */
        case bcmPortControlPrbsMode:
        case bcmPortControlPrbsPolynomial:
        case bcmPortControlPrbsTxEnable:
        case bcmPortControlPrbsRxEnable:
        case bcmPortControlPrbsTxInvertData:
        case bcmPortControlPrbsRxStatus:
        case bcmPortControlLanes:
            return TRUE;

        default:
            return FALSE;
    }
}
#endif /* BCM_SHADOW_SUPPORT */

static int
_bcm_esw_mac_rx_control(int unit, bcm_port_t port, uint8 optype, int *enable)
{
    int rv = BCM_E_NONE;

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return(bcmi_esw_portctrl_mac_rx_control(unit, port, optype, enable));
    } else {
        PORT_LOCK(unit);
        if (optype) { /* get */
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_RX_SET, enable);
        } else { /* set */
             rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                  SOC_MAC_CONTROL_RX_SET, *enable);
        }
        PORT_UNLOCK(unit);
    }
    return rv;
}
/*
 * Function:
 *     bcm_esw_port_enqueue_set
 * Description:
 *      This function enable and disable the enqueuing
 *      packets on a port
 * Parameters:
 *      unit      - (IN) Device number
 *      port      - (IN) Port to resolve
 *      enable    - (IN) TRUE to enable enqueuing
 *                       FALSE to disable enqueuing
 * Return Value:
 *      BCM_E_XXX
 */

static int
bcm_esw_port_enqueue_set(int unit, bcm_port_t port,int enable)
{
    int rv = BCM_E_NONE;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#ifdef BCM_TRIDENT3_SUPPORT
    if (SOC_IS_TRIDENT3X(unit)) {
        int link;
        rv = bcm_esw_port_link_status_get(unit, port, &link);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
        if (link == BCM_PORT_LINK_STATUS_UP) {
            /* FALSE to disable enqueuing and MMU cells drain */
            PORT_LOCK(unit);
            if (SOC_PORT_USE_PORTCTRL(unit, port)) {
                rv = bcmi_esw_portctrl_mac_enable_set(unit, port, enable);
            } else {
                rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, enable);
            }
            if (BCM_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return rv;
            }
            PORT_UNLOCK(unit);
        }
    } else
#endif
#ifdef BCM_TOMAHAWK_SUPPORT
    if (SOC_IS_TOMAHAWKX(unit)) {
        int link;
        rv = bcm_esw_port_link_status_get(unit, port, &link);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
        if (link == BCM_PORT_LINK_STATUS_UP || SOC_FAST_REBOOT(unit)) {
            /* FALSE to disable enqueuing and MMU cells drain */
            PORT_LOCK(unit);
            if (SOC_PORT_USE_PORTCTRL(unit, port)) {
                rv = bcmi_esw_portctrl_mac_enable_set(unit, port, enable);
            } else {
                rv = MAC_ENABLE_SET(PORT(unit, port).p_mac, unit, port, enable);
            }
            if (BCM_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return rv;
            }
            PORT_UNLOCK(unit);
        }
    } else
#endif
#ifdef BCM_MONTEREY_SUPPORT
    if (SOC_IS_MONTEREY(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_mn_port_enqueue_set(unit,port,enable));
    } else
#endif
#ifdef BCM_APACHE_SUPPORT
    if (SOC_IS_APACHE(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_ap_port_enqueue_set(unit,port,enable));
    } else
#endif
#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_td2_port_enqueue_set(unit,port,enable));
    } else
#endif
#ifdef BCM_TRIDENT_SUPPORT
    if (SOC_IS_TD_TT(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_td_port_enqueue_set(unit,port,enable));
    } else
#endif
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_HELIX4_SUPPORT)
    if (SOC_IS_TRIUMPH3(unit) || SOC_IS_HELIX4(unit)) {
         BCM_IF_ERROR_RETURN
            (_bcm_tr3_port_enqueue_set(unit,port,enable));
    } else
#endif /* BCM_TRIUMPH3_SUPPORT */
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_kt2_port_enqueue_set(unit,port,enable));
    } else
#endif
    {
        return BCM_E_UNAVAIL;
    }
    return rv;
}

/*
 * Function:
 *     bcm_esw_port_enqueue_get
 * Description:
 *      This function get enqueuing state
 *      packets on a port
 * Parameters:
 *      unit      - (IN) Device number
 *      port      - (IN) Port to resolve
 *      enable    - (OUT) TRUE to when enqueuing is enabled
 *                       FALSE to when enqueuing is disabled
 * Return Value:
 *      BCM_E_XXX
 */
static int
bcm_esw_port_enqueue_get(int unit, bcm_port_t port, int *enable)
{
    int rv = BCM_E_NONE;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#ifdef BCM_TRIDENT3_SUPPORT
    if (SOC_IS_TRIDENT3X(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_td3_port_enable_get(unit, port, enable));
    } else
#endif
#ifdef BCM_TOMAHAWK_SUPPORT
    if (SOC_IS_TOMAHAWKX(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_th_port_enqueue_get(unit, port, enable));
    } else
#endif
#ifdef BCM_APACHE_SUPPORT
    if (SOC_IS_APACHE(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_ap_port_enqueue_get(unit,port,enable));
    } else
#endif
#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_td2_port_enqueue_get(unit,port,enable));
    } else
#endif
#ifdef BCM_TRIDENT_SUPPORT
    if (SOC_IS_TD_TT(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_td_port_enqueue_get(unit,port,enable));
    }  else
#endif
    {
        return BCM_E_UNAVAIL;
    }
    return rv;
}

/*
 * Function:
 *     bcm_esw_port_drain_cells
 * Description:i
 *      This function will drains the MMU cells which the port
 *      is holding
 * Parameters:
 *      unit      - (IN) Device number
 *      port      - (IN) Port to resolve
 *      value     - (IN) TRUE to drain the cells
 *                       FALSE to just ignore
 * Return Value:
 *      BCM_E_XXX
 */
static int
bcm_esw_port_drain_cells(int unit, bcm_port_t port, int value)
{
    int rv = BCM_E_NONE;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    if (value == FALSE ) {
        return rv;
    }
#ifdef BCM_TRIDENT3_SUPPORT
    if (SOC_IS_TRIDENT3X(unit)) {
        if (IS_CPU_PORT(unit, port)) {
            return BCM_E_PORT;
        }
        /* MMU cells were drained when enqueuing is disabled */
        return rv;
    } else
#endif
#ifdef BCM_TOMAHAWK_SUPPORT
    if (SOC_IS_TOMAHAWKX(unit)) {
        if (IS_CPU_PORT(unit, port)) {
            return BCM_E_PORT;
        }
        /* MMU cells were drained when enqueuing is disabled */
        return rv;

    } else
#endif
#ifdef BCM_MONTEREY_SUPPORT
    if (SOC_IS_MONTEREY(unit)) {
        BCM_IF_ERROR_RETURN
            (bcm_monterey_port_drain_cells(unit, port));
    } else
#endif
#ifdef BCM_APACHE_SUPPORT
    if (SOC_IS_APACHE(unit)) {
        BCM_IF_ERROR_RETURN
            (bcm_apache_port_drain_cells(unit, port));
    } else
#endif
#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        BCM_IF_ERROR_RETURN
            (bcm_td2_port_drain_cells(unit, port));
    } else
#endif
#ifdef BCM_TRIDENT_SUPPORT
    if (SOC_IS_TD_TT(unit)) {
        BCM_IF_ERROR_RETURN
            (bcm_td_port_drain_cells(unit, port));
    } else
#endif
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_HELIX4_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit) || SOC_IS_HELIX4(unit)) {
        BCM_IF_ERROR_RETURN
            (bcm_tr3_port_drain_cells(unit, port));
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN
            (bcm_kt2_port_drain_cells(unit, port));
    } else
#endif

    {
        return BCM_E_UNAVAIL;
    }
    return rv;
}

/*
 * Function:
 *     _bcm_esw_port_llfc_set
 * Description:
 *      This function will set the LLFC_RX/TX_ENABLE field,
 *       and LLFC_EN field can possibly be set accordingly.
 * Parameters:
 *      unit - (IN) Device number
 *      port - (IN) Port to resolve
 *      type - (IN) Enum value of the feature
 *      value - (IN) Value to be set
 * Return Value:
 *      BCM_E_XXX
 */
STATIC int
_bcm_esw_port_llfc_set(int unit, bcm_port_t port, bcm_port_control_t type, int value)
{
    int rv = BCM_E_UNAVAIL;
    soc_reg_t port_config;
    int llfc_enable;
#ifdef BCM_TRIDENT2_SUPPORT
    uint32 rval;
#endif

    if(SOC_PORT_USE_PORTCTRL(unit, port)) {
        return(bcmi_esw_portctrl_llfc_set(unit,port, type, value));
    }

    switch(type) {
    case bcmPortControlLLFCReceive:
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    case bcmPortControlSAFCReceive:
#endif
#if defined(BCM_XGS3_SWITCH_SUPPORT)
        if (SOC_IS_XGS3_SWITCH(unit)) {

            if (!SOC_PORT_VALID(unit, port)) {
                return BCM_E_PORT;
            }

            BCM_IF_ERROR_RETURN
                (MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_LLFC_RX_ENABLE, value));
            if (value == 0) {
                BCM_IF_ERROR_RETURN
                    (MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                     SOC_MAC_CONTROL_LLFC_TX_ENABLE,
                                     &llfc_enable));
            } else {
                llfc_enable = TRUE;
            }

            if (SOC_REG_FIELD_VALID(unit, XLPORT_CONFIGr, LLFC_ENf)) {
                port_config = XLPORT_CONFIGr;
            } else if (SOC_REG_FIELD_VALID(unit, XPORT_CONFIGr, LLFC_ENf)) {
                port_config = XPORT_CONFIGr;
            } else if (SOC_REG_FIELD_VALID(unit, PORT_CONFIGr, LLFC_ENf)) {
                port_config = PORT_CONFIGr;
            } else {
                port_config = INVALIDr;
            }

            if (port_config != INVALIDr){
                BCM_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, port_config, port, LLFC_ENf,
                                            llfc_enable ? 1 : 0));
            }

            rv = BCM_E_NONE;
        }
#endif /* BCM_XGS3_SWITCH_SUPPORT */
        break;
    case bcmPortControlLLFCTransmit:
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    case bcmPortControlSAFCTransmit:
#endif
#if defined(BCM_XGS3_SWITCH_SUPPORT)
        if (SOC_IS_XGS3_SWITCH(unit)) {
            if (!SOC_PORT_VALID(unit, port)) {
                return BCM_E_PORT;
            }

            BCM_IF_ERROR_RETURN
                (MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_LLFC_TX_ENABLE, value));
            if (value == 0) {
                BCM_IF_ERROR_RETURN
                    (MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                     SOC_MAC_CONTROL_LLFC_RX_ENABLE,
                                     &llfc_enable));
            } else {
                llfc_enable = TRUE;
            }

            if (SOC_REG_FIELD_VALID(unit, XLPORT_CONFIGr, LLFC_ENf)) {
                port_config = XLPORT_CONFIGr;
            } else if (SOC_REG_FIELD_VALID(unit, XPORT_CONFIGr, LLFC_ENf)) {
                port_config = XPORT_CONFIGr;
            } else if (SOC_REG_FIELD_VALID(unit, PORT_CONFIGr, LLFC_ENf)) {
                port_config = PORT_CONFIGr;
            } else {
                port_config = INVALIDr;
            }

            if (port_config != INVALIDr){
                BCM_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, port_config, port, LLFC_ENf,
                                            llfc_enable ? 1 : 0));
            }

#ifdef BCM_TRIDENT2_SUPPORT
            if (SOC_IS_TD2_TT2(unit)) {
                SOC_IF_ERROR_RETURN
                    (soc_reg32_get(unit, THDI_INPUT_PORT_XON_ENABLESr,
                                   port, 0, &rval));

                soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
                                  PORT_PRI_XON_ENABLEf,
                                  value ? 0xffff : 0);
                soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
                                  PORT_PAUSE_ENABLEf, value ? 0 : 1);

                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, THDI_INPUT_PORT_XON_ENABLESr,
                                   port, 0, rval));
            }
#endif

            rv = BCM_E_NONE;
        }
#endif /* BCM_XGS3_SWITCH_SUPPORT */
        break;
    default:
        break;
    }

    return rv;
}

/*
 * Function:
 *     _bcm_esw_port_llfc_get
 * Description:
 *      This function will get the LLFC_TX/RX_ENABLE field.
 * Parameters:
 *      unit - (IN) Device number
 *      port - (IN) Port to resolve
 *      type - (IN) Enum value of the feature
 *      value - (OUT) Current value of the port feature
 * Return Value:
 *      BCM_E_XXX
 */
STATIC int
_bcm_esw_port_llfc_get(int unit, bcm_port_t port, bcm_port_control_t type, int *value)
{
    int rv = BCM_E_UNAVAIL;

    if(SOC_PORT_USE_PORTCTRL(unit, port)) {
        return(bcmi_esw_portctrl_llfc_get(unit,port, type, value));
    }

    switch(type) {
    case bcmPortControlLLFCReceive:
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    case bcmPortControlSAFCReceive:
#endif
#if defined(BCM_XGS3_SWITCH_SUPPORT)
        if (SOC_IS_XGS3_SWITCH(unit)) {
            if (!SOC_PORT_VALID(unit, port)) {
                return BCM_E_PORT;
            }
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_LLFC_RX_ENABLE, value);
        }
#endif /* BCM_XGS3_SWITCH_SUPPORT */
        break;
    case bcmPortControlLLFCTransmit:
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    case bcmPortControlSAFCTransmit:
#endif
#if defined(BCM_XGS3_SWITCH_SUPPORT)
        if (SOC_IS_XGS3_SWITCH(unit)) {
            if (!SOC_PORT_VALID(unit, port)) {
                return BCM_E_PORT;
            }
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_LLFC_TX_ENABLE, value);
        }
#endif /* BCM_XGS3_SWITCH_SUPPORT */
        break;
    default:
        break;
    }

    return rv;
}

#ifdef BCM_TRIUMPH3_SUPPORT
STATIC int
_bcm_tr3_port_lanes_set(int unit, bcm_port_t port, int value)
{
    int i, incr = 1, ports = 3, okay;
    int rv = BCM_E_NONE, rv1, old_value;
    int retry_count = 0, mode_change = -1;
    uint16 phy;
    uint32 flags;
    soc_info_t *si = &SOC_INFO(unit);
    int phy_port = -1;
    int old_port[4];
    if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }

    /* coverity[overrun-local : FALSE] */
    phy_port = si->port_l2p_mapping[port];
    for (i = 0; i < 4; i++) {
        old_port[i] = si->flex_port_p2l_mapping[phy_port+i];
    }

_reconfig:
    rv = soc_tr3_port_lanes_set(unit, port, value, &old_value, &mode_change);
    if (rv != SOC_E_NONE) {
        return rv;
    }
    if (value == 1) {
#ifdef BCM_HELIX4_SUPPORT
        /* coverity[overrun-local : FALSE] */
        if (SOC_IS_HELIX4(unit) && ((_tr3_port_config_id[unit] == 410) &&
                (si->port_l2p_mapping[port] == 57 || si->port_l2p_mapping[port] == 61))){
            ports = 1;
        }else if(SOC_IS_HELIX4(unit) && (((_tr3_port_config_id[unit] == 463) ||
               (_tr3_port_config_id[unit] == 413)) && (si->port_l2p_mapping[port] == 57 ||
               si->port_l2p_mapping[port] == 61))){
           ports = 2;
        }
        else
#endif
        /* coverity[overrun-local : FALSE] */
        if (SOC_IS_TRIUMPH3(unit) && !SOC_IS_HELIX4(unit) &&
            ((_tr3_port_config_id[unit] == 112 || _tr3_port_config_id[unit] == 12) &&
            (si->port_l2p_mapping[port] == 73 || si->port_l2p_mapping[port] == 77))) {
            ports = 1;
        } else {
            ports = 4;
        }
    } else if (value == 2) {
#ifdef BCM_HELIX4_SUPPORT
    if(SOC_IS_HELIX4(unit) &&((_tr3_port_config_id[unit] == 463) ||
           _tr3_port_config_id[unit] == 413) && (si->port_l2p_mapping[port] == 57 ||
           si->port_l2p_mapping[port] == 61)){
           ports = 1;
           incr = 2;
       }
       else
#endif
       {
           incr = 2;
       }
    } else if (value == 4) {
        ports = 1;
    }
    if (value == 2 && old_value == 1) {
#ifdef BCM_HELIX4_SUPPORT
    if(SOC_IS_HELIX4(unit) && (((_tr3_port_config_id[unit] == 463) ||
        (_tr3_port_config_id[unit] == 413)) && (si->port_l2p_mapping[port] == 57 ||
         si->port_l2p_mapping[port] == 61))){
        SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, si->port_p2l_mapping[si->port_l2p_mapping[port] + 1]));
      }else
#endif
      {
        SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, port + 1));
        SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, port + 3));
      }
    } else if (value == 4 && old_value == 1) {
        if ((SOC_IS_HELIX4(unit) && (_tr3_port_config_id[unit] == 410)) ||
            (SOC_IS_TRIUMPH3(unit) && !SOC_IS_HELIX4(unit) &&
            (_tr3_port_config_id[unit] == 112 || _tr3_port_config_id[unit] == 12))){
            if (old_port[1] > 0) {
                SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, old_port[1]));
            }
            if (old_port[2] > 0) {
                SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, old_port[2]));
            }
            if (old_port[3] > 0) {
                SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, old_port[3]));
            }
        } else {
            SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, port + 1));
            SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, port + 2));
            SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, port + 3));
        }
    } else if (value == 4 && old_value == 2) {
        SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, port + 2));
    }
    for (i = 0; i < ports; i+=incr) {
        flags = 0;
        phy = soc_property_port_get(unit, port + i, spn_FLEX_PORT_PHY_ADDR, 0);
        if (!phy) {
            SOC_IF_ERROR_RETURN(soc_tr3_phy_addr_get(unit, port + i, &phy));
            flags = _SHR_PORT_PHY_INTERNAL;
        }
        SOC_IF_ERROR_RETURN(soc_phy_cfg_addr_set(unit, port + i, flags, phy));
        BCM_IF_ERROR_RETURN(_bcm_port_probe(unit, port + i, &okay));
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Port %d probe: %d\n"), port + i, okay));
        if (!okay) {
            return BCM_E_INTERNAL;
        }
        BCM_IF_ERROR_RETURN(_bcm_port_mode_setup(unit, port + i, TRUE));
    }
#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        return rv;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    for (i = 0; i < ports; i+=incr) {
        if (SOC_PBMP_MEMBER(si->port.disabled_bitmap, port+i)) {
            continue;
        }
        rv1 = _bcm_tr3_port_ur_chk(unit, ports, port + i);
        if (rv1 == BCM_E_PORT) {
            /* Error encountered in the newly created flex ports.
               Lets revert back to old mode and retry if retry count not exceeded */
            if (++retry_count > _BCM_TR3_PORT_UR_RETRY_MAX) {
                return BCM_E_INTERNAL;
            }
            rv = soc_tr3_port_lanes_set(unit, port, old_value, &old_value, &mode_change);
            if (rv != SOC_E_NONE) {
                return rv;
            }
            goto _reconfig;
        }
        if (rv1 != BCM_E_NONE) {
            return rv1;
        }
    }

    /* Note: Following is currently a brute force solution */
    for (i = 0; i < ports; i+=incr) {
        if (mode_change == BCM_PORT_ENCAP_HIGIG) {
            /* coverity[overrun-call : FALSE] */
            BCM_IF_ERROR_RETURN
                (_bcm_port_encap_xport_set(unit, port + i, BCM_PORT_ENCAP_HIGIG,
                                           TRUE));
        } else if (mode_change == BCM_PORT_ENCAP_IEEE) {
            /* coverity[overrun-call : FALSE] */
            BCM_IF_ERROR_RETURN
                (_bcm_port_encap_xport_set(unit, port + i, BCM_PORT_ENCAP_IEEE,
                                           TRUE));
        }
    }
    return rv;
}

STATIC int
_bcm_tr3_port_lanes_get(int unit, bcm_port_t port, int *value)
{
    int rv = BCM_E_NONE;
    if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }
    rv = soc_tr3_port_lanes_get(unit, port, value);
    return rv;
}
#endif /* BCM_TRIUMPH3_SUPPORT */

#ifdef BCM_TRIDENT_SUPPORT
STATIC int
_bcm_td_port_lanes_set(int unit, bcm_port_t port, int value)
{
    soc_info_t *si;
    int rv, okay, i;
    uint32 rval, phy_mode, core_mode;
    uint32 reset_status;
    bcm_port_t phy_port;

    rv = READ_XLPORT_MODE_REGr(unit, port, &rval);
    if (BCM_SUCCESS(rv)) {
        phy_mode = soc_reg_field_get(unit, XLPORT_MODE_REGr, rval,
                                     PHY_PORT_MODEf);
        core_mode = soc_reg_field_get(unit, XLPORT_MODE_REGr, rval,
                                     CORE_PORT_MODEf);
        if (phy_mode == 0) { /* single mode */
            /* Case of 40G port --> 10G XFI */
            if (value == 1) {
                SOC_INFO(unit).port_speed_max[port]=10000;
            }
        } else if (phy_mode == 1) { /* dual mode */
            if (value != 2 && value != 4) {
                rv = BCM_E_PARAM;
            } else if (value == 4) {
                core_mode = 0;
                soc_reg_field_set(unit, XLPORT_MODE_REGr, &rval, CORE_PORT_MODEf, core_mode);
                SOC_IF_ERROR_RETURN(WRITE_XLPORT_MODE_REGr(unit, port, rval));
            }
        } else {  /* phy_mode == 2 */
            if (value == 4) {
                /* 10G XFI --> 10G XAUI or 10G XFI --> 40G */
                if (core_mode == 0) {
                    /* 10GXFI --> 40G */
                    SOC_INFO(unit).port_speed_max[port]=40000;
                }
            }
        }
    }
    if (BCM_SUCCESS(rv)) {
        si = &SOC_INFO(unit);
        phy_port = si->port_l2p_mapping[port];
        for (i = 0; i < value; i++) {
            if ((si->port_p2l_mapping[phy_port + i]) == -1) {
                continue;
            }
            rv = soc_phyctrl_detach
                (unit, si->port_p2l_mapping[phy_port + i]);
            if (BCM_FAILURE(rv)) {
                break;
            }
        }
    }
    if (BCM_SUCCESS(rv)) {
        si = &SOC_INFO(unit);
        si->port_num_lanes[port] = value;
        if (BCM_SUCCESS(rv)) {
            rv = _bcm_port_phy_probe(unit, port, &okay);
        }
    }

    /* Do XMAC reset when port mode is changed */
    SOC_IF_ERROR_RETURN(READ_XLPORT_XMAC_CONTROLr(unit, port, &rval));
    reset_status = soc_reg_field_get(unit, XLPORT_XMAC_CONTROLr, rval, XMAC_RESETf);
    if (reset_status != 1) {
        soc_reg_field_set(unit, XLPORT_XMAC_CONTROLr, &rval, XMAC_RESETf, 1);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_XMAC_CONTROLr(unit, port, rval));
        sal_udelay(10);
        soc_reg_field_set(unit, XLPORT_XMAC_CONTROLr, &rval, XMAC_RESETf, 0);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_XMAC_CONTROLr(unit, port, rval));
    }

    return rv;
}
#endif /* BCM_TRIDENT_SUPPORT */

#ifdef BCM_TRIDENT2_SUPPORT
STATIC int
_bcm_td2_port_lanes_set(int unit, bcm_port_t port_base, int lanes)
{
    soc_info_t *si = &SOC_INFO(unit);
    soc_td2_port_lanes_t lanes_ctrl;
    int port, i;
    int enable, okay;
    soc_control_t *soc = SOC_CONTROL(unit);

    if(SOC_PORT_USE_PORTCTRL(unit, port_base)) {
        return(bcmi_esw_td2_portctrl_lanes_set(unit, port_base, lanes));
    }

    sal_memset(&lanes_ctrl, 0, sizeof(lanes_ctrl));
    lanes_ctrl.port_base = port_base;
    lanes_ctrl.lanes = lanes;
    SOC_IF_ERROR_RETURN
        (soc_trident2_port_lanes_validate(unit, &lanes_ctrl));

    if (lanes_ctrl.lanes == lanes_ctrl.cur_lanes) {
        return BCM_E_NONE;
    }

    /* All existing ports are required to be disasbled */
    SOC_IF_ERROR_RETURN(bcm_esw_port_enable_get(unit, port_base, &enable));
    if (enable) {
        return BCM_E_BUSY;
    }
    if (lanes_ctrl.lanes > lanes_ctrl.cur_lanes) { /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl.phy_ports_len; i++) {
            port = si->port_p2l_mapping[lanes_ctrl.phy_ports[i]];
            SOC_IF_ERROR_RETURN(bcm_esw_port_enable_get(unit, port, &enable));
            if (enable) {
                return BCM_E_BUSY;
            }
        }
    }

    SOC_IF_ERROR_RETURN
        (soc_trident2_port_lanes_set(unit, &lanes_ctrl));

    /* Detach PHY on all existing port(s) */
    SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, port_base));
    if (lanes_ctrl.lanes > lanes_ctrl.cur_lanes) { /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl.phy_ports_len; i++) {
            port = si->port_p2l_mapping[lanes_ctrl.phy_ports[i]];
            SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, port));
            COUNTER_LOCK(unit);
            SOC_PBMP_PORT_REMOVE(soc->counter_pbmp, port);
            COUNTER_UNLOCK(unit);
        }
    }
    /* Probe PHY on all port(s) after conversion */
    BCM_IF_ERROR_RETURN(_bcm_port_probe(unit, port_base, &okay));
    BCM_IF_ERROR_RETURN(_bcm_port_mode_setup(unit, port_base, FALSE));
    if (lanes_ctrl.lanes < lanes_ctrl.cur_lanes) { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl.phy_ports_len; i++) {
            port = si->port_p2l_mapping[lanes_ctrl.phy_ports[i]];
            BCM_IF_ERROR_RETURN(_bcm_port_probe(unit, port, &okay));
            BCM_IF_ERROR_RETURN(_bcm_port_mode_setup(unit, port, FALSE));
            COUNTER_LOCK(unit);
            SOC_PBMP_PORT_ADD(soc->counter_pbmp, port);
            COUNTER_UNLOCK(unit);
        }
    }

    return BCM_E_NONE;
}
#endif /* BCM_TRIDENT2_SUPPORT */

#ifdef BCM_TOMAHAWK_SUPPORT
STATIC int
_bcm_th_port_lanes_set(int unit, bcm_port_t port_base, int lanes)
{
    soc_info_t *si = &SOC_INFO(unit);
    soc_control_t *soc = SOC_CONTROL(unit);
    soc_th_port_lanes_t lanes_ctrl;
    int port, i;
    int enable, okay;
    int speed;

    sal_memset(&lanes_ctrl, 0, sizeof(lanes_ctrl));
    lanes_ctrl.port_base = port_base;
    lanes_ctrl.lanes = lanes;

    /* All existing ports are required to be disabled */
    SOC_IF_ERROR_RETURN(bcm_esw_port_enable_get(unit, port_base, &enable));
    if (enable) {
        return BCM_E_PORT;
    }
    SOC_IF_ERROR_RETURN
        (soc_tomahawk_port_lanes_validate(unit, &lanes_ctrl));
    if (lanes_ctrl.lanes == lanes_ctrl.cur_lanes) {
        return BCM_E_NONE;
    }

    if (lanes_ctrl.lanes > lanes_ctrl.cur_lanes) { /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl.phy_ports_len; i++) {
            port = si->port_p2l_mapping[lanes_ctrl.phy_ports[i]];
            SOC_IF_ERROR_RETURN(bcm_esw_port_enable_get(unit, port, &enable));
            if (enable) {
                return BCM_E_PORT;
            }
        }
    }

    SOC_IF_ERROR_RETURN
        (soc_tomahawk_port_lanes_set(unit, &lanes_ctrl));
    SOC_IF_ERROR_RETURN
        (soc_tomahawk_port_lanes_consolidation(unit, &lanes_ctrl));

    /* Detach PHY on all existing port(s) */
    SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, port_base));
    if (lanes_ctrl.lanes > lanes_ctrl.cur_lanes) { /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl.phy_ports_len; i++) {
            port = si->port_p2l_mapping[lanes_ctrl.phy_ports[i]];
            SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, port));
            COUNTER_LOCK(unit);
            SOC_PBMP_PORT_REMOVE(soc->counter_pbmp, port);
            COUNTER_UNLOCK(unit);
        }
    }

    /* Probe PHY on all port(s) after conversion */
    BCM_IF_ERROR_RETURN(_bcm_port_probe(unit, port_base, &okay));
    BCM_IF_ERROR_RETURN(_bcm_port_mode_setup(unit, port_base, FALSE));
    if (lanes_ctrl.lanes < lanes_ctrl.cur_lanes) { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl.phy_ports_len; i++) {
            port = si->port_p2l_mapping[lanes_ctrl.phy_ports[i]];
            BCM_IF_ERROR_RETURN(_bcm_port_probe(unit, port, &okay));
            BCM_IF_ERROR_RETURN(_bcm_port_mode_setup(unit, port, FALSE));
            COUNTER_LOCK(unit);
            SOC_PBMP_PORT_ADD(soc->counter_pbmp, port);
            COUNTER_UNLOCK(unit);
        }
    }

    /* Update port ASF setting to SAF */
    /* Base Port */
    speed = si->port_init_speed[port_base];
    BCM_IF_ERROR_RETURN(soc_th_port_asf_mode_set
                            (unit, port_base, speed, _SOC_TH_ASF_MODE_SAF));
    /* Newly added ports */
    if (lanes_ctrl.lanes < lanes_ctrl.cur_lanes) { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl.phy_ports_len; i++) {
            port = si->port_p2l_mapping[lanes_ctrl.phy_ports[i]];
            speed = si->port_init_speed[port];
            BCM_IF_ERROR_RETURN(soc_th_port_asf_mode_set
                                    (unit, port, speed, _SOC_TH_ASF_MODE_SAF));
        }
    }

    return BCM_E_NONE;
}
#endif /* BCM_TOMAHAWK_SUPPORT */

#ifdef BCM_HURRICANE2_SUPPORT
STATIC int
_bcm_hu2_port_lanes_set(int unit, bcm_port_t port_base, int lanes)
{
    soc_info_t *si = &SOC_INFO(unit);
    int cur_lanes;
    int port, phy_ports[3], phy_ports_len, i;
    int okay;

    SOC_IF_ERROR_RETURN
        (soc_hurricane2_port_lanes_set(unit, port_base, lanes, &cur_lanes,
                                     phy_ports, &phy_ports_len));
    if (lanes == cur_lanes) {
        return BCM_E_NONE;
    }

    if (lanes > cur_lanes) { /* port(s) to be removed */
        for (i = 0; i < phy_ports_len; i++) {
            port = si->port_p2l_mapping[phy_ports[i]];
            SOC_IF_ERROR_RETURN(soc_phyctrl_detach(unit, port));
        }
    }

    /* The specified port */
    BCM_IF_ERROR_RETURN(_bcm_port_probe(unit, port_base, &okay));
    BCM_IF_ERROR_RETURN(_bcm_port_mode_setup(unit, port_base, TRUE));

    if (lanes < cur_lanes) { /* port(s) to be added */
        for (i = 0; i < phy_ports_len; i++) {
            port = si->port_p2l_mapping[phy_ports[i]];
            BCM_IF_ERROR_RETURN(_bcm_port_probe(unit, port, &okay));
            BCM_IF_ERROR_RETURN(_bcm_port_mode_setup(unit, port, TRUE));
        }
    }

    return BCM_E_NONE;
}
#endif

#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
int
_bcm_sc_tr_port_pfc_tx_set(int unit, bcm_port_t port, uint32 pri_bmp)
{
    int pfc_enable;
    uint32 rval;
    int value, val_count = 0;
    soc_reg_t reg;
    uint32 values[2];
    int chk_gx_port = (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
                       SOC_IS_VALKYRIE2(unit) || SOC_IS_SCORPION(unit));
    soc_field_t fields[] = {PFC_ENABLEf, LLFC_ENf};

    if (!soc_feature(unit, soc_feature_priority_flow_control)) {
        return BCM_E_UNAVAIL;
    }
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    if (chk_gx_port && !IS_GX_PORT(unit, port)) { /* IS_GX_PORT == IS_XL_PORT */
        return BCM_E_PORT;
    }
    if (pri_bmp >= (1U << 16)) {
        return  BCM_E_PARAM;
    }

    value = (pri_bmp == 0)? 0 : 1;
    BCM_IF_ERROR_RETURN
        (MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                         SOC_MAC_CONTROL_PFC_TX_ENABLE, value));
    if (value == 0) {
        BCM_IF_ERROR_RETURN
            (MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                             SOC_MAC_CONTROL_PFC_RX_ENABLE,
                             &pfc_enable));
    } else {
        pfc_enable = TRUE;
    }

    if (!soc_feature(unit, soc_feature_mmu_config_property)) {
        rval = 0;
        if (SOC_REG_IS_VALID(unit,PORT_PRI_XON_ENABLEr)) {
           if (value) {
              soc_reg_field_set(unit, PORT_PRI_XON_ENABLEr, &rval,
                                PORT_PRI_XON_ENABLEf, 0xff);
              if (soc_reg_field_valid(unit, PORT_PRI_XON_ENABLEr,
                                      PORT_PG7PAUSE_DISABLEf)) {
                  soc_reg_field_set(unit, PORT_PRI_XON_ENABLEr, &rval,
                                    PORT_PG7PAUSE_DISABLEf, 1);
              }
           }
           BCM_IF_ERROR_RETURN
              (WRITE_PORT_PRI_XON_ENABLEr(unit, port, rval));
        }
    } else if (SOC_IS_TRIDENT(unit)) {
       rval = 0;
       if (SOC_REG_IS_VALID(unit,PORT_PRI_XON_ENABLEr)) {
           if(value) {
               /* Get flow_control_enable info from mmu config
                * property for each priority group, and enable
                * generation of XON/XOFF for priority group
                * accordingly. */
               int idx = 0, prifc_en = 0, fval = 0;
               char suffix;
               for(idx = 0; idx < 8; idx ++) {
                   /* By default, enable generation of XON and XOFF
                    * LLFC messages for priority 7 */
                   prifc_en = (idx == 7) ? 1 : 0;
                   prifc_en = soc_property_port_obj_attr_get(unit,
                                        port, spn_BUF, spn_PRIGROUP,
                                        idx, spn_FLOW_CONTROL_ENABLE,
                                        0, &suffix, prifc_en);
                   if(prifc_en != 0) {
                       fval |= (1 << idx);
                   }
               }
               soc_reg_field_set(unit, PORT_PRI_XON_ENABLEr, &rval,
                                   PORT_PRI_XON_ENABLEf, fval);
           }
           /* When disable PFC on port, generation of XON/XOFF
            * for all priority groups must be disabled also. */
           BCM_IF_ERROR_RETURN
                 (WRITE_PORT_PRI_XON_ENABLEr(unit, port, rval));
        }
    }

    /* Port config settings */
    values[0] = pfc_enable ? 1 : 0;
    values[1] = 0;

    if (SOC_IS_TD2_TT2(unit)) {
#ifdef BCM_TOMAHAWK3_SUPPORT
        if(SOC_IS_TOMAHAWK3(unit)) {
            SOC_IF_ERROR_RETURN
                (bcm_th3_mmu_pfc_tx_config_set(unit, port,
                                        pfc_enable, pri_bmp));
        } else
#endif
        {
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, THDI_INPUT_PORT_XON_ENABLESr,
                               port, 0, &rval));
            soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
                              PORT_PRI_XON_ENABLEf,
                              pfc_enable ? pri_bmp : 0);

            soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
                              PORT_PAUSE_ENABLEf, pfc_enable ? 0 : 1);
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, THDI_INPUT_PORT_XON_ENABLESr,
                               port, 0, rval));
        }
#ifdef BCM_TOMAHAWK_SUPPORT
        if (SOC_IS_TOMAHAWKX(unit) && IS_CL_PORT(unit, port)) {
            soc_info_t *si;
            uint64 rval64;
            int phy_port_base, phy_port, lane, block_idx, pipe, clport, obm;
            static const soc_reg_t obm_fc_config_regs[] = {
                IDB_OBM0_FLOW_CONTROL_CONFIGr, IDB_OBM1_FLOW_CONTROL_CONFIGr,
                IDB_OBM2_FLOW_CONTROL_CONFIGr, IDB_OBM3_FLOW_CONTROL_CONFIGr,
                IDB_OBM4_FLOW_CONTROL_CONFIGr, IDB_OBM5_FLOW_CONTROL_CONFIGr,
                IDB_OBM6_FLOW_CONTROL_CONFIGr, IDB_OBM7_FLOW_CONTROL_CONFIGr,
#ifdef BCM_TOMAHAWK2_SUPPORT
                IDB_OBM8_FLOW_CONTROL_CONFIGr, IDB_OBM9_FLOW_CONTROL_CONFIGr,
                IDB_OBM10_FLOW_CONTROL_CONFIGr, IDB_OBM11_FLOW_CONTROL_CONFIGr,
                IDB_OBM12_FLOW_CONTROL_CONFIGr, IDB_OBM13_FLOW_CONTROL_CONFIGr,
                IDB_OBM14_FLOW_CONTROL_CONFIGr, IDB_OBM15_FLOW_CONTROL_CONFIGr
#endif
            };

            COMPILER_64_ZERO(rval64);
            si = &SOC_INFO(unit);
            phy_port = si->port_l2p_mapping[port];
            phy_port_base = PORT_BLOCK_BASE_PORT(port);
            lane = (phy_port - phy_port_base) & 3;
            block_idx = SOC_PORT_IDX_BLOCK(unit, phy_port_base, 0);
            pipe = si->port_pipe[port];
            clport = SOC_BLOCK_NUMBER(unit, block_idx);
            if (SOC_IS_TOMAHAWK(unit)) {
                /* obm number is reversed (mirrored) in odd pipe */
                obm = pipe & 1 ? (7- (clport & 7)) : (clport & 7);
            } else {
                obm = clport & 15;
            }
            reg = SOC_REG_UNIQUE_ACC(unit, obm_fc_config_regs[obm])[pipe];
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, reg, REG_PORT_ANY, lane, &rval64));
            soc_reg64_field32_set(unit, reg, &rval64, FC_TYPEf, pfc_enable);
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, reg, REG_PORT_ANY, lane, rval64));
        }
#endif /* BCM_TOMAHAWK_SUPPORT */
        reg = INVALIDr;
    } else if (SOC_IS_TD_TT(unit)) {
        int mmu_port;
        uint64 r64val;
        soc_info_t *si;

        /* disable pause if pfc is enabled, vice versa */
        si = &SOC_INFO(unit);
        mmu_port = si->port_p2m_mapping[si->port_l2p_mapping[port]];
        reg = (mmu_port < 33) ? PORT_PAUSE_ENABLE0_64r : PORT_PAUSE_ENABLE1_64r;
        mmu_port = (mmu_port < 33) ? mmu_port : mmu_port - 33;
        SOC_IF_ERROR_RETURN(
            soc_reg_get(unit, reg, REG_PORT_ANY, 0, &r64val));
        if (value) {
            COMPILER_64_BITCLR(r64val, mmu_port);
        } else {
            COMPILER_64_BITSET(r64val, mmu_port);
        }
        SOC_IF_ERROR_RETURN(
            soc_reg_set(unit, reg, REG_PORT_ANY, 0, r64val));

        reg = XLPORT_CONFIGr;
        val_count=2;
    } else if (SOC_IS_SHADOW(unit)) {
        reg = XLPORT_CONFIGr;
        val_count=2;
    } else if (SOC_IS_TRIUMPH3(unit)) {
        reg = PORT_CONFIGr;
        val_count=2;
    }  else if (SOC_IS_SABER2(unit)) {
        /* No port level config required */
        reg = INVALIDr;
        val_count = 0;
    } else if (SOC_IS_KATANAX(unit)) {
        reg = XPORT_CONFIGr;
        val_count=2;
    } else {
        reg = INVALIDr;
    }

    if (val_count > 0) {
        BCM_IF_ERROR_RETURN
            (soc_reg_fields32_modify(unit, reg, port,
                                     COUNTOF(values), fields, values));
    } else if (SOC_IS_SC_CQ(unit) || SOC_IS_TR_VL(unit)) {
        if (SOC_REG_IS_VALID(unit, PPFC_ENr)) {
            BCM_IF_ERROR_RETURN
              (soc_reg_field32_modify(unit, PPFC_ENr, port,
                                      PPFC_FEATURE_ENf,
                                      pfc_enable ? 1 : 0));
        }
        if (soc_reg_field_valid(unit, XPORT_CONFIGr, PPP_ENABLEf)) {
            BCM_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, XPORT_CONFIGr, port,
                                        PPP_ENABLEf,
                                        pfc_enable ? 1 : 0));
        }
    }

    /* Stats enable */
    BCM_IF_ERROR_RETURN
        (MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                         SOC_MAC_CONTROL_PFC_STATS_ENABLE,
                         pfc_enable ? 1 : 0));

    return BCM_E_NONE;
}
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */


/*
 * Function:
 *      bcm_esw_port_control_wlan_validate
 * Description:
 *      Checks that port control is valid for a WLAN GPORT.
 *      Resolves port to expected port value for the given port control type.
 * Parameters:
 *      port      - (IN) Port to resolve
 *      type      - (IN) Port control type
 *      port_out  - (OUT) Returns port (gport or BCM format) that
 *                  is expected for corresponding port control type.
 * Return Value:
 *      BCM_E_XXX
 */
STATIC int
bcm_esw_port_control_wlan_validate(bcm_port_t port,
                                   bcm_port_control_t type,
                                   bcm_port_t *port_out)
{
    int rv = BCM_E_PORT;
    int support = FALSE;

    switch (type) {
    case bcmPortControlBridge:
    case bcmPortControlTrunkHashSet:
    case bcmPortControlFabricTrunkHashSet:
    case bcmPortControlECMPHashSet:
    case bcmPortControlLoadBalanceHashSet:
    case bcmPortControlLoadBalancingNumber:
    case bcmPortControlIP4:
    case bcmPortControlIP6:
    case bcmPortControlIP4Mcast:
    case bcmPortControlIP6Mcast:
    case bcmPortControlMpls:
    case bcmPortControlMacInMac:
    case bcmPortControlSrcBmacMissToCpu:
    case bcmPortControlIP4McastL2:
    case bcmPortControlIP6McastL2:
    case bcmPortControlFilterLookup:
    case bcmPortControlFilterIngress:
    case bcmPortControlPreservePacketPriority:
    case bcmPortControlLearnClassEnable:
    case bcmPortControlTrustIncomingVlan:
    case bcmPortControlDoNotCheckVlan:
    case bcmPortControlIEEE8021ASEnableIngress:
    case bcmPortControlIpfixRate:
    case bcmPortControlForwardStaticL2MovePkt:
    case bcmPortControlTrillHashSelect:
    case bcmPortControlFabricSourceKnockout:
    case bcmPortControlL2GreEnable:
    case bcmPortControlL2GreTunnelbasedVpnId:
    case bcmPortControlL2GreDefaultTunnelEnable:
    case bcmPortControlVxlanEnable:
    case bcmPortControlVxlanTunnelbasedVnId:
    case bcmPortControlVxlanDefaultTunnelEnable:
    case bcmPortControlRegex:
    case bcmPortControlRegexTcp:
    case bcmPortControlRegexUdp:
        support = TRUE;
        break;
    default:
        support = FALSE;
        break;
    }

    if (support) {
        *port_out = port;
        rv = BCM_E_NONE;
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_control_proxy_validate
 * Description:
 *      Checks that port control is valid for a PROXY GPORT.
 *      Resolves port to expected port value for the given port control type.
 * Parameters:
 *      unit      - (IN) Device number
 *      port      - (IN) Port to resolve
 *      type      - (IN) Port control type
 *      port_out  - (OUT) Returns port (gport or BCM format) that
 *                  is expected for corresponding port control type.
 * Return Value:
 *      BCM_E_XXX
 */
STATIC int
bcm_esw_port_control_proxy_validate(int unit, bcm_port_t port,
                                    bcm_port_control_t type,
                                    bcm_port_t *port_out)
{
    int rv = BCM_E_PORT;
    int support = FALSE;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (!soc_feature(unit, soc_feature_proxy_port_property)) {
        return BCM_E_PORT;
    }

    switch(type) {
    case bcmPortControlBridge:
    case bcmPortControlTrunkHashSet:
    case bcmPortControlFabricTrunkHashSet:
    case bcmPortControlECMPHashSet:
    case bcmPortControlLoadBalanceHashSet:
    case bcmPortControlLoadBalancingNumber:
    case bcmPortControlIP4:
    case bcmPortControlIP6:
    case bcmPortControlIP4Mcast:
    case bcmPortControlIP6Mcast:
    case bcmPortControlMpls:
    case bcmPortControlMacInMac:
    case bcmPortControlSrcBmacMissToCpu:
    case bcmPortControlIP4McastL2:
    case bcmPortControlIP6McastL2:
    case bcmPortControlFilterLookup:
    case bcmPortControlFilterIngress:
    case bcmPortControlPreservePacketPriority:
    case bcmPortControlLearnClassEnable:
    case bcmPortControlTrustIncomingVlan:
    case bcmPortControlDoNotCheckVlan:
    case bcmPortControlIEEE8021ASEnableIngress:
    case bcmPortControlIpfixRate:
    case bcmPortControlOAMEnable:
    case bcmPortControlForwardStaticL2MovePkt:
    case bcmPortControlTrill:
    case bcmPortControlTrillAllow:
    case bcmPortControlNonTrillAllow:
    case bcmPortControlTrillCoreISISToCPU:
    case bcmPortControlTrillHashSelect:
    case bcmPortControlNivNonVntagDrop:
    case bcmPortControlNonEtagDrop:
    case bcmPortControlNivVntagDrop:
    case bcmPortControlEtagDrop:
    case bcmPortControlNivNonVntagAdd:
    case bcmPortControlNonEtagAdd:
    case bcmPortControlNivVntagIngressReplace:
    case bcmPortControlEtagIngressReplace:
    case bcmPortControlNivVntagIngressDelete:
    case bcmPortControlEtagIngressDelete:
    case bcmPortControlNivRpfCheck:
    case bcmPortControlExtenderRpfCheck:
    case bcmPortControlNivNameSpace:
    case bcmPortControlExtenderNameSpace:
    case bcmPortControlUseEtagPri:
    case bcmPortControlProhibitedDot1p:
    case bcmPortControlFabricSourceKnockout:
    case bcmPortControlMplsEntropyHashSet:
    case bcmPortControlL2GreEnable:
    case bcmPortControlL2GreTunnelbasedVpnId:
    case bcmPortControlL2GreDefaultTunnelEnable:
    case bcmPortControlVxlanEnable:
    case bcmPortControlVxlanTunnelbasedVnId:
    case bcmPortControlVxlanDefaultTunnelEnable:
        support = TRUE;
        break;
    default:
        support = FALSE;
        break;
    }

    if (support) {
        *port_out = port;
        rv = BCM_E_NONE;
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_control_scheduler_validate
 * Description:
 *      Checks that port control is valid for a SCHEDULER GPORT.
 *      Resolves port to expected port value for the given port control type.
 * Parameters:
 *      unit      - (IN) Device number
 *      port      - (IN) Port to resolve
 *      type      - (IN) Port control type
 *      port_out  - (OUT) Returns port (gport or BCM format) that
 *                  is expected for corresponding port control type.
 * Return Value:
 *      BCM_E_XXX
 */
STATIC int
bcm_esw_port_control_scheduler_validate(int unit, bcm_port_t port,
                                        bcm_port_control_t type,
                                        bcm_port_t *port_out)
{
    int rv = BCM_E_PORT;
    int support = FALSE;

    switch (type) {
    case bcmPortControlWredDropCountUpdateEnableQueueMask:
    case bcmPortControlWredDropCountUpdateEnableColorMask:
        support = TRUE;
        break;
    default:
        support = FALSE;
        break;
    }

    if (support) {
        *port_out = port;
        rv = BCM_E_NONE;
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_control_local_port_validate
 * Description:
 *      Checks that port control is valid for a BCM local physical port.
 *      Resolves port to expected port value for the given port control type.
 * Parameters:
 *      unit      - (IN) Device number
 *      port      - (IN) Port to resolve
 *      type      - (IN) Port control type
 *      port_out  - (OUT) Returns port (gport or BCM format) that
 *                  is expected for corresponding port control type.
 * Return Value:
 *      BCM_E_XXX
 *
 *      Unlike the other similar routines
 *      (i.e. bcm_esw_port_control_wlan_support), note that the default
 *      support is VALID and checks for INVALID types, since most
 *      port controls are valid for this type of port.
 */
STATIC int
bcm_esw_port_control_local_port_validate(int unit, bcm_port_t port,
                                         bcm_port_control_t type,
                                         bcm_port_t *port_out)
{
    int rv = BCM_E_PORT;
    int support = TRUE;
    bcm_port_t local_port;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Check for valid BCM local physical port */
    BCM_IF_ERROR_RETURN
        (_bcm_esw_port_gport_validate(unit, port, &local_port));

    if (IS_ST_PORT(unit, local_port)) {
        switch(type) {
        case bcmPortControlIP4:
        case bcmPortControlIP6:
        case bcmPortControlIP4Mcast:
        case bcmPortControlIP6Mcast:
        case bcmPortControlMpls:
        case bcmPortControlMacInMac:
        case bcmPortControlIP4McastL2:
        case bcmPortControlIP6McastL2:
        case bcmPortControlIPMC4Ucast:
        case bcmPortControlIPMC6Ucast:
            support = FALSE;
            break;
        default:
            support = TRUE;
            break;
        }
    }

    if (support) {
        if (!IS_E_PORT(unit, local_port)) {
            switch(type) {
            case bcmPortControlEEEEnable:
            case bcmPortControlEEETransmitIdleTime:
            case bcmPortControlEEEStatisticsClear:
            case bcmPortControlEEETransmitRefreshTime:
            case bcmPortControlEEETransmitSleepTime:
            case bcmPortControlEEETransmitQuietTime:
            case bcmPortControlEEETransmitWakeTime:
            case bcmPortControlEEEReceiveSleepTime:
            case bcmPortControlEEEReceiveQuietTime:
            case bcmPortControlEEEReceiveWakeTime:
            case bcmPortControlEEEEventCountSymmetric:
            case bcmPortControlEEELinkActiveDuration:
            case bcmPortControlEEEReceiveDuration:
            case bcmPortControlEEETransmitEventCount:
            case bcmPortControlEEETransmitDuration:
            case bcmPortControlEEEReceiveEventCount:
                support = FALSE;
                break;
            default:
                support = TRUE;
                break;
            }
        }
    }

    if (support) {
        *port_out = local_port;
        rv = BCM_E_NONE;
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_control_validate
 * Description:
 *      Checks that port is valid and that control is supported
 *      for the given port type.  Resolves port to expected
 *      port value for the given port control type.
 *      Current valid port types are:
 *          GPORT WLAN
 *          GPORT PROXY
 *          GPORT (various types) that resolves to local physical port
 *          BCM port (non-gport)
 * Parameters:
 *      unit      - (IN) Device number
 *      port      - (IN) Port to resolve
 *      type      - (IN) Port control type
 *      port_out  - (OUT) Returns port (gport or BCM format) that
 *                  is expected for corresponding port control type.
 * Return Value:
 *      BCM_E_XXX
 */
STATIC int
bcm_esw_port_control_validate(int unit, bcm_port_t port,
                              bcm_port_control_t type,
                              bcm_port_t *port_out)
{
    int rv = BCM_E_PORT;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (BCM_GPORT_IS_WLAN_PORT(port)) {
        rv = bcm_esw_port_control_wlan_validate(port, type, port_out);
    } else if (BCM_GPORT_IS_PROXY(port)) {
        rv = bcm_esw_port_control_proxy_validate(unit, port, type, port_out);
    } else if (BCM_GPORT_IS_SCHEDULER(port)) {
        rv = bcm_esw_port_control_scheduler_validate(unit, port,
                                                     type, port_out);
    } else {
        rv = bcm_esw_port_control_local_port_validate(unit, port, type,
                                                      port_out);
    }

    return rv;
}


int
_bcm_esw_port_vrf_set(int unit, bcm_port_t port, int value)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_HAWKEYE_SUPPORT) || defined(BCM_HURRICANE_SUPPORT)
        if (SOC_IS_HAWKEYE(unit) || SOC_IS_HURRICANEX(unit) ||
            !soc_feature(unit, soc_feature_l3))  {
            return BCM_E_UNAVAIL;
        }
#endif /* BCM_HAWKEYE_SUPPORT || BCM_HURRICANE_SUPPORT */
        if (soc_mem_field_valid(unit, PORT_TABm, VRF_IDf)) {
            if ((value > 0 ) && (value < SOC_VRF_MAX(unit) )) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           VRF_IDf, value);
                BCM_IF_ERROR_RETURN(rv);
                if (soc_mem_field_valid(unit, PORT_TABm, VRF_PORT_ENABLEf)) {
                    rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                               VRF_PORT_ENABLEf, 0x1);
                }
            } else {
                if (soc_mem_field_valid(unit, PORT_TABm, VRF_PORT_ENABLEf)) {
                    rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                               VRF_PORT_ENABLEf, 0x0);
                    BCM_IF_ERROR_RETURN(rv);
                }
                if (soc_mem_field_valid(unit, PORT_TABm, VRF_IDf)) {
                    rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                               VRF_IDf, 0x0);
                }
            }
        }

#if defined(BCM_TRIUMPH_SUPPORT)
        else {
            if (soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm, VRF_IDf)) {
                if  ((value > 0 ) && (value < SOC_VRF_MAX(unit) )) {
#if defined(BCM_KATANA2_SUPPORT)
                    if (SOC_IS_KATANA2(unit)) {
                        rv = _bcm_kt2_source_trunk_map_set(unit, port,
                                VRF_IDf, value);
                    } else
#endif
                    {
                        rv = _bcm_trx_source_trunk_map_set(unit, port,
                                VRF_IDf, value);
                    }
                    BCM_IF_ERROR_RETURN(rv);
                    if (soc_mem_field_valid(unit, PORT_TABm,
                                            PORT_OPERATIONf) ||
                        SOC_IS_TRIDENT3X(unit)) {
                        rv = _bcm_esw_port_tab_set(unit, port,
                                                   _BCM_CPU_TABS_BOTH,
                                                   PORT_OPERATIONf, 0x3);
                    }
                } else {
                    if (soc_mem_field_valid(unit, PORT_TABm,
                                            PORT_OPERATIONf) ||
                        SOC_IS_TRIDENT3X(unit)) {
                        rv = _bcm_esw_port_tab_set(unit, port,
                                                   _BCM_CPU_TABS_BOTH,
                                                   PORT_OPERATIONf, 0x0);
                    }
                }
            }
        }
#endif  /* BCM_TRIUMPH_SUPPORT */
    return rv;
}

int
_bcm_esw_port_vrf_get(int unit, bcm_port_t port, int *value)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_HAWKEYE_SUPPORT) || defined(BCM_HURRICANE_SUPPORT)
    if (SOC_IS_HAWKEYE(unit) || SOC_IS_HURRICANEX(unit) ||
        !soc_feature(unit, soc_feature_l3)) {
        return BCM_E_UNAVAIL;
    }
#endif /* BCM_HAWKEYE_SUPPORT || BCM_HURRICANE_SUPPORT */
    if (soc_mem_field_valid(unit, PORT_TABm, VRF_PORT_ENABLEf)) {
        rv = _bcm_esw_port_tab_get(unit, port, VRF_PORT_ENABLEf, value);

        if ((*value == 0x1 ) && (soc_mem_field_valid(unit, PORT_TABm,
                                                     VRF_IDf ))) {
              rv = _bcm_esw_port_tab_get(unit, port, VRF_IDf, value);
        } else {
              *value = 0;
        }
    } else if (soc_mem_field_valid(unit, PORT_TABm, VRF_IDf)) {
        rv = _bcm_esw_port_tab_get(unit, port, VRF_IDf, value);
    }

#if defined(BCM_TRIUMPH_SUPPORT)
    else {
        *value = 0;
        if (soc_mem_field_valid(unit, PORT_TABm, PORT_OPERATIONf) ||
            SOC_IS_TRIDENT3X(unit)) {
            rv = _bcm_esw_port_tab_get(unit, port, PORT_OPERATIONf, value);
            BCM_IF_ERROR_RETURN(rv);
        }
        if ((*value == 0x3) &&
            (soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm,
                                     VRF_IDf))) {
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
                rv = _bcm_kt2_source_trunk_map_get(unit, port, VRF_IDf,
                                           (uint32 *)value);
            } else
#endif
            {
                rv = _bcm_trx_source_trunk_map_get(unit, port, VRF_IDf,
                                           (uint32 *)value);
            }
        }
    }

#endif /* BCM_TRIUMPH_SUPPORT */
    return rv;
}

#ifdef BCM_TRIDENT2_SUPPORT
STATIC void
_bcm_flex_port_phy_control_software_rx_los_get(int unit, bcm_port_t control_port) {
    int        rv = BCM_E_NONE;
    bcm_pbmp_t ancillary_pbmp;
    bcm_port_t ancillary_port;
    uint32     rx_los;

    rv = bcm_esw_port_subsidiary_ports_get(unit, control_port, &ancillary_pbmp);
    if (BCM_FAILURE(rv)) {
        return;
    }
    PBMP_ITER(ancillary_pbmp, ancillary_port) {
        rv = bcm_esw_port_phy_control_get(unit, ancillary_port, BCM_PORT_PHY_CONTROL_SOFTWARE_RX_LOS, &rx_los);
        if (BCM_SUCCESS(rv)) {
            PORT_INFO_RX_LOS_SET(unit, ancillary_port, BCM_PORT_PHY_CONTROL_SOFTWARE_RX_LOS, rx_los);
        }
    }
    return;
}
#endif

int
bcm_esw_port_phy_fec_error_inject_set(int unit, bcm_port_t port,
                                      uint16 error_control_map,
                                      bcm_port_phy_fec_error_mask_t bit_error_mask)
{
    int rv = BCM_E_UNAVAIL;
    soc_phy_control_fec_error_mask_t error_mask;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_phy_fec_error_inject_set(unit, port, error_control_map, bit_error_mask);
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!(BCM_PBMP_MEMBER(PBMP_PORT_ALL(unit), port))) {
        return BCM_E_PORT;
    }
    error_mask.error_mask_bit_31_0 = bit_error_mask.error_mask_bit_31_0;
    error_mask.error_mask_bit_63_32 = bit_error_mask.error_mask_bit_63_32;
    error_mask.error_mask_bit_79_64 = bit_error_mask.error_mask_bit_79_64;

    PORT_LOCK(unit);
    rv = soc_phyctrl_fec_error_inject_set(unit, port, error_control_map, error_mask);
    PORT_UNLOCK(unit);

    return rv;
}

int
bcm_esw_port_phy_fec_error_inject_get(int unit, bcm_port_t port,
                                          uint16 *error_control_map,
                                          bcm_port_phy_fec_error_mask_t *bit_error_mask)
{
    int rv = BCM_E_UNAVAIL;
    soc_phy_control_fec_error_mask_t error_mask;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_phy_fec_error_inject_get(unit, port, error_control_map, bit_error_mask);
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!(BCM_PBMP_MEMBER(PBMP_PORT_ALL(unit), port))) {
        return BCM_E_PORT;
    }

    PORT_LOCK(unit);
    rv = soc_phyctrl_fec_error_inject_get(unit, port, error_control_map, &error_mask);
    PORT_UNLOCK(unit);

    bit_error_mask->error_mask_bit_31_0 = error_mask.error_mask_bit_31_0;
    bit_error_mask->error_mask_bit_63_32 = error_mask.error_mask_bit_63_32;
    bit_error_mask->error_mask_bit_79_64 = error_mask.error_mask_bit_79_64;

    return rv;
}

/*
 * Function:
 *      _bcm_esw_port_eee_stat_clear
 * Description:
 *      Clear EEE statistics directly by
 *      writing EEE counter register to 0
 * Parameters:
 *      unit - Device number
 *      port - Port number
 * Return Value:
 *      BCM_E_XXX
 */
#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_TRIDENT_SUPPORT) || \
    defined(BCM_HAWKEYE_SUPPORT) || defined(BCM_HURRICANE2_SUPPORT)
STATIC int
_bcm_esw_port_eee_stat_clear(int unit, bcm_port_t port)
{
    int idx;
    uint64 val64;
    soc_reg_t def_regs[] = {
        RX_EEE_LPI_DURATION_COUNTERr,
        RX_EEE_LPI_EVENT_COUNTERr,
        TX_EEE_LPI_DURATION_COUNTERr,
        TX_EEE_LPI_EVENT_COUNTERr
    };
    soc_reg_t ge_regs[] = {
        GRX_EEE_LPI_DURATION_COUNTERr,
        GRX_EEE_LPI_EVENT_COUNTERr,
        GTX_EEE_LPI_DURATION_COUNTERr,
        GTX_EEE_LPI_EVENT_COUNTERr
    };
    soc_reg_t *regs = def_regs;

    COMPILER_64_ZERO(val64);

    if (IS_GE_PORT(unit, port) && !IS_XL_PORT(unit, port)) {
        regs = ge_regs;
    }

    for (idx = 0; idx < sizeof(def_regs) / sizeof(def_regs[0]); idx++) {
        SOC_IF_ERROR_RETURN(soc_counter_set(unit, port, regs[idx], 0, val64));
    }

    return BCM_E_NONE;
}
#endif

/*
 * Function:
 *      bcm_esw_port_control_set
 * Description:
 *      Enable/Disable specified port feature.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      type - Enum value of the feature
 *      value - value to be set
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_UNAVAIL - Functionality not available
 */
int
bcm_esw_port_control_set(int unit, bcm_port_t port,
                         bcm_port_control_t type, int value)
{
    int rv = BCM_E_UNAVAIL;
    int valid = 0;
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    soc_reg_t egr_port_reg;
#endif
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
    int chk_gx_port = (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
                       SOC_IS_VALKYRIE2(unit) || SOC_IS_SCORPION(unit));
#endif
#if defined(BCM_GREYHOUND_SUPPORT)
    int cur_val = 0;
#endif
#if defined (BCM_METROLITE_SUPPORT)
    bcm_pbmp_t pbm;
#endif
#if defined(BCM_TOMAHAWK3_SUPPORT)
int_turnaround_en_bmap_entry_t int_turnaround_en_bmap_entry;
bcm_pbmp_t  pbmp;
#endif

    LOG_INFO(BSL_LS_BCM_PORT,
             (BSL_META_U(unit,
                         "bcm_port_control_set: u=%d p=%d rv=%d : %d\n"),
              unit, port, value, (int)type));

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port) &&
            (type != bcmPortControlSatEnable)) {
        /* Only bcmPortControlSatEnable is permitted on oamp port */
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        /*
         * Check that port control feature is valid in Port Control.
         * If valid, call Port Control routine to handle feature; otherwise
         * continue with rest of logic.
         */
        BCM_IF_ERROR_RETURN
            (bcmi_esw_portctrl_control_validate(unit, type, &valid));
        if (valid) {
            return bcmi_esw_portctrl_control_set(unit, port, type, value);
        }
    }

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    egr_port_reg = (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
                    SOC_IS_VALKYRIE2(unit)|| SOC_IS_GREYHOUND(unit) ||
                    SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) ?
                    EGR_PORT_64r : EGR_PORTr;
#endif

#if defined(BCM_SHADOW_SUPPORT)
    if (SOC_IS_SHADOW(unit)) {
        /*  If unsupported port control type, return unavail */
        if (!_bcm_port_type_shadow_support (unit, port, type)) {
            return BCM_E_UNAVAIL;
        }
    }
#endif /* BCM_SHADOW_SUPPORT */

    if (type == bcmPortControlEsmEligibility) {
#ifdef BCM_TRIUMPH3_SUPPORT
        /* For bcmPortControlEsmEligibility, a non-local port
         * is accepted. For other port controls, a non-local
         * port is not accepted. Hence, bcmPortControlEsmEligibility
         * is implemented here, before the _bcm_esw_port_gport_validate
         * procedure below.
         */
        return bcm_tr3_port_esm_eligible_set(unit, port, value);
#endif /* BCM_TRIUMPH3_SUPPORT */
    }

#if defined(BCM_TRIDENT_SUPPORT) && defined(INCLUDE_L3)
    if (
#ifdef BCM_HGPROXY_COE_SUPPORT
        ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        (soc_feature(unit, soc_feature_channelized_switching))) &&
         _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port) &&
         ((type == bcmPortControlVlanVpGroupIngress) ||
          (type == bcmPortControlVlanVpGroupEgress))) ||
#endif
        BCM_GPORT_IS_TRUNK(port) ||
        BCM_GPORT_IS_VLAN_PORT(port) ||
        BCM_GPORT_IS_NIV_PORT(port) ||
        BCM_GPORT_IS_VXLAN_PORT(port) ||
        BCM_GPORT_IS_MIM_PORT(port) ||
        BCM_GPORT_IS_MPLS_PORT(port) ||
        BCM_GPORT_IS_L2GRE_PORT(port) ||
        BCM_GPORT_IS_FLOW_PORT(port) ||
        BCM_GPORT_IS_EXTENDER_PORT(port)) {
        return bcm_td_vp_control_set(unit, port, type, value);
    } else
#endif /* BCM_TRIDENT_SUPPORT && INCLUDE_L3 */
#if defined(BCM_KATANA2_SUPPORT)
    if ((BCM_GPORT_IS_MIM_PORT(port) || BCM_GPORT_IS_MPLS_PORT(port))
         && SOC_IS_KATANA2(unit)) {
        rv = BCM_E_NONE;
    } else
#endif /* BCM_KATANA2_SUPPORT */
    if ((BCM_GPORT_IS_LOCAL_CPU_IEEE(port)) ||
        (BCM_GPORT_IS_LOCAL_CPU_HIGIG(port))) {
        rv = BCM_E_NONE;
    } else
#ifdef BCM_HGPROXY_COE_SUPPORT
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        (soc_feature(unit, soc_feature_channelized_switching))) &&
        _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
        rv = BCM_E_NONE;
    } else
#endif
#ifdef BCM_TRIDENT3_SUPPORT
    if (soc_feature(unit, soc_feature_pp_port_control) &&
        (type == bcmPortControlPacketProcssingPort) ) {
        rv = BCM_E_NONE;
    } else
#endif
    {
        rv = bcm_esw_port_control_validate(unit, port, type, &port);
    }
    BCM_IF_ERROR_RETURN(rv);
    rv = BCM_E_UNAVAIL;

    /*
     * At this point, 'port' can be:
     *    GPORT WLAN
     *    GPORT PROXY
     *    BCM valid local port
     *
     * Some switch cases only handles 'port' in BCM port format
     * (non-gport).  Corresponding checks must be added in those
     * cases to ensure that 'port' is not a gport.
     */
    switch (type) {
    case bcmPortControlBridge:
        if (BCM_GPORT_IS_SET(port)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       PORT_BRIDGEf, value);
        } else {
            PORT_LOCK(unit);
            rv = _bcm_esw_port_control_bridge_set(unit, port, value);
            PORT_UNLOCK(unit);
        }
        break;
    case bcmPortControlTrunkHashSet:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return BCM_E_UNAVAIL;
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
#if defined(BCM_BRADLEY_SUPPORT)
            if (SOC_IS_HBX(unit) || SOC_IS_TRX(unit)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           RTAG7_HASH_CFG_SEL_TRUNKf,
                                           (value) ? 1 : 0);
            }
#endif /* BCM_BRADLEY_SUPPORT */
        }
        break;
    case bcmPortControlFabricTrunkHashSet:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return BCM_E_UNAVAIL;
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
#if defined(BCM_BRADLEY_SUPPORT)
            if (SOC_IS_HBX(unit) || SOC_IS_TRX(unit)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf,
                                           (value) ? 1 : 0);
            }
#endif /* BCM_BRADLEY_SUPPORT */
        }
        break;
    case bcmPortControlECMPHashSet:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return BCM_E_UNAVAIL;
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
#if defined(BCM_BRADLEY_SUPPORT)
            if (SOC_IS_HBX(unit) || SOC_IS_TRX(unit)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           RTAG7_HASH_CFG_SEL_ECMPf,
                                           (value) ? 1 : 0);
            }
#endif /* BCM_BRADLEY_SUPPORT */
        }
        break;
    case bcmPortControlLoadBalanceHashSet:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return BCM_E_UNAVAIL;
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
#if defined(BCM_BRADLEY_SUPPORT)
            if (SOC_IS_HBX(unit) || SOC_IS_TRX(unit)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           RTAG7_HASH_CFG_SEL_LBIDf,
                                           (value) ? 1 : 0);
            }
#endif /* BCM_BRADLEY_SUPPORT */
        }
        break;
    case bcmPortControlLoadBalancingNumber:
#if defined(BCM_BRADLEY_SUPPORT)
        if (SOC_IS_HBX(unit) || SOC_IS_TRX(unit)) {
#if defined(BCM_TOMAHAWK3_SUPPORT)
            if (SOC_IS_TOMAHAWK3(unit)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       RTAG7_PORT_LBNf,
                                       (value) & 0x3f);
            } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
            {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       RTAG7_PORT_LBNf,
                                       (value) & 0xf);
            }
        }
#endif /* BCM_BRADLEY_SUPPORT */
        break;
    case bcmPortControlErrorSymbolDetect:
#if defined(BCM_GREYHOUND_SUPPORT)
        if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
            SOC_IS_GREYHOUND2(unit)) {
            rv = BCM_E_UNAVAIL;
        } else
#endif /* BCM_GREYHOUND_SUPPORT */
        {
#ifdef BCM_XGS3_SWITCH_SUPPORT
            if (SOC_IS_XGS3_SWITCH(unit)) {
                rv = _bcm_esw_port_err_sym_detect_set(unit, port, value);
            }
#endif
        }
        break;
    case bcmPortControlErrorSymbolCount:
#if defined(BCM_GREYHOUND_SUPPORT)
        if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
            SOC_IS_GREYHOUND2(unit)) {
            rv = BCM_E_UNAVAIL;
        } else
#endif /* BCM_GREYHOUND_SUPPORT */
        {
#ifdef BCM_XGS3_SWITCH_SUPPORT
            if (SOC_IS_XGS3_SWITCH(unit)) {
             int temp = 0;
                /* Error symbol count is read only and cleared on read. */
                rv = _bcm_esw_port_err_sym_count_get(unit, port, &temp);
            }
#endif
        }
        break;
#if defined(INCLUDE_L3)
    case bcmPortControlIP4:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            if (BCM_GPORT_LOCAL_CPU_IEEE == port) {
                rv = _bcm_esw_port_tab_set(unit, CMIC_PORT(unit), _BCM_CPU_TABS_ETHER,
                                           V4L3_ENABLEf, (value) ? 1 : 0);
            } else if (BCM_GPORT_LOCAL_CPU_HIGIG == port) {
                rv = _bcm_esw_port_tab_set(unit, CMIC_PORT(unit), _BCM_CPU_TABS_HIGIG,
                                           V4L3_ENABLEf, (value) ? 1 : 0);
            } else {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                           V4L3_ENABLEf, (value) ? 1 : 0);
            }

#if defined(BCM_TRIUMPH_SUPPORT)
            if (BCM_SUCCESS(rv) &&
                soc_feature(unit, soc_feature_esm_support)) {
                if (SOC_IS_TRIUMPH3(unit)) { 
                    break;
                }
                if (!BCM_GPORT_IS_SET(port)) {
                    rv = _bcm_tr_l3_enable(unit, port, 0, (value) ? 1 : 0);
                }
            }
#endif /* BCM_TRIUMPH_SUPPORT */
        }
        break;
    case bcmPortControlIP6:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       V6L3_ENABLEf, (value) ? 1 : 0);
#if defined(BCM_TRIUMPH_SUPPORT)
            if (BCM_SUCCESS(rv) &&
                soc_feature(unit, soc_feature_esm_support)) {
                if (SOC_IS_TRIUMPH3(unit)) { 
                    break;
                }
                if (!BCM_GPORT_IS_SET(port)) {
                    rv = _bcm_tr_l3_enable(unit, port, BCM_L3_IP6,
                                           (value) ? 1 : 0);
                }
            }
#endif /* BCM_TRIUMPH_SUPPORT */
        }
        break;
    case bcmPortControlIP4Mcast:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       V4IPMC_ENABLEf, (value) ? 1 : 0);
        }
        break;
    case bcmPortControlIP6Mcast:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       V6IPMC_ENABLEf, (value) ? 1 : 0);
        }
        break;
    case bcmPortControlIPMC4Ucast:
        if (soc_feature(unit, soc_feature_ipmc_unicast)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                    IPMCV4_UNICAST_MACDA_ENABLEf, (value) ? 1 : 0);
        }
        break;
    case bcmPortControlIPMC6Ucast:
        if (soc_feature(unit, soc_feature_ipmc_unicast)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                    IPMCV6_UNICAST_MACDA_ENABLEf, (value) ? 1 : 0);
        }
        break;
    case bcmPortControlMpls:
#if defined(BCM_TRIUMPH_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                   MPLS_ENABLEf, (value) ? 1 : 0);
#endif
        break;
    case bcmPortControlMacInMac:
        if (!soc_feature(unit, soc_feature_mim)) {
            break;
        }
#if defined(BCM_TRIUMPH2_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                   MIM_TERM_ENABLEf, (value) ? 1 : 0);
        if(rv == BCM_E_NONE) {
#if defined(BCM_TRIDENT3_SUPPORT)
            if(SOC_IS_TRIDENT3X(unit)) {
                int app = 0;
                if (0x0 != value)  {
                    app = CANCUN_APP__PORT_TABLE__MIM_MC_TERM_ENABLE;
                } else {
                    app = CANCUN_APP__PORT_TABLE__MIM_MC_TERM_DISABLE;
                }
                rv = soc_cancun_app_dest_entry_set (unit,
                    PORT_TABm, port, PORT_TYPEf, app, 0x0);
                if (BCM_E_NONE != rv ) {
                    LOG_ERROR(BSL_LS_BCM_L2,
                        (BSL_META_U(unit,
                        "MIM_MC_TERM_ENABLE cfg error\n")));
                }
            } else
#endif
            {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                           MIM_MC_TERM_ENABLEf, (value) ? 1 : 0);
            }
        }
#endif
        break;

    case bcmPortControlMimUcastTermEnable:
        if (!soc_feature(unit, soc_feature_mim)) {
            break;
        }
#if defined(BCM_TRIUMPH2_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                   MIM_TERM_ENABLEf, (value) ? 1 : 0);
#endif
        break;

    case bcmPortControlMimMcastTermEnable:
        if (!soc_feature(unit, soc_feature_mim)) {
            break;
        }
#if defined(BCM_TRIUMPH2_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       MIM_MC_TERM_ENABLEf, (value) ? 1 : 0);
#endif
        break;

    case bcmPortControlSrcBmacMissToCpu:
#ifdef BCM_TRIUMPH2_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) { /* see SDK-124007 */
            return BCM_E_UNAVAIL;
        }
        if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
            SOC_IS_VALKYRIE2(unit) || SOC_IS_ENDURO(unit) ||
            SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit) ||
            SOC_IS_KATANA(unit)) {
            /* 0x2: ToCPU 0x1: Drop(default) */
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       CML_BMAC_NEWf, (value) ? 0x2 : 0x1);
        }
#endif /* BCM_TRIUMPH2_SUPPORT */
        break;

    case bcmPortControlQosRemarkResolution:
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            /* Two resolution supported by TD3 hardware:
             * 1: Serial resolution.
             * 3: Layered resolution.
             * Default is Layered resolution
             */
            if (value == BCM_PORT_QOS_SERIAL_RESOLUTION) {
                value = 1;
            } else if (value == BCM_PORT_QOS_LAYERED_RESOLUTION) {
                value = 3;
            } else {
                return BCM_E_PARAM;
            }
            rv = _bcm_esw_egr_port_tab_set(unit, port, QOS_CTRL_IDf, value);
        }
#endif /* BCM_TRIDENT3_SUPPORT */
        break;

    case bcmPortControlFabricQueue:
#if defined(BCM_TRIUMPH2_SUPPORT)
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
#if defined(BCM_TRIDENT3_SUPPORT)
        if (SOC_IS_TRIDENT3X(unit) &&
            soc_feature(unit, soc_feature_egr_lport_tab_profile)) {
            rv = bcm_esw_port_egr_lport_field_set(
                  unit, port, EGR_LPORT_PROFILEm, EH_EXT_HDR_ENABLEf,
                  (value) ? 1 : 0);
            BCM_IF_ERROR_RETURN(rv);
        }
#endif
        if (IS_ST_PORT(unit, port)) {
            if (SOC_REG_FIELD_VALID(unit, EGR_PORT_64r, EH_EXT_HDR_ENABLEf)) {
                rv = soc_reg_field32_modify(unit, EGR_PORT_64r, port,
                                            EH_EXT_HDR_ENABLEf,(value) ? 1 : 0);
            }
            else if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, EH_EXT_HDR_ENABLEf)){
                rv = soc_mem_field32_modify(unit, EGR_PORTm, port,
                                            EH_EXT_HDR_ENABLEf,(value) ? 1 : 0 );
            }
        } else {
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
            /* Allow CPU port on TD2+ to add extended header */
            if (SOC_IS_TRIDENT2PLUS(unit) && IS_CPU_PORT(unit, port)) {
                rv = soc_mem_field32_modify(unit, EGR_PORTm, port,
                                            EH_EXT_HDR_ENABLEf,(value) ? 1 : 0 );
            }
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
            if (SOC_IS_TOMAHAWKX(unit) && IS_CPU_PORT(unit, port)) {
                rv = soc_mem_field32_modify(unit, EGR_PORTm, port,
                                            EH_EXT_HDR_ENABLEf,(value) ? 1 : 0 );
            }
#endif
        }
#endif
        break;
#endif /* INCLUDE_L3 */
    case bcmPortControlIP4McastL2:
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
                soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm,
                                                 IPMCV4_L2_ENABLEf)) {
            rv = _bcm_trx_source_trunk_map_set(unit, port,
                                  IPMCV4_L2_ENABLEf, (value) ? 1 : 0);
        } else {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                    V4IPMC_L2_ENABLEf, (value) ? 1 : 0);
        }
#endif /* BCM_TRX_SUPPORT */
        break;
    case bcmPortControlIP6McastL2:
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TD2_TT2(unit) &&
                soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm,
                                                 IPMCV6_L2_ENABLEf)) {
            rv = _bcm_trx_source_trunk_map_set(unit, port,
                                  IPMCV6_L2_ENABLEf, (value) ? 1 : 0);
        } else {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       V6IPMC_L2_ENABLEf, (value) ? 1 : 0);
        }
#endif /* BCM_TRX_SUPPORT */
        break;
    case bcmPortControlPassControlFrames:
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
#ifdef BCM_XGS3_SWITCH_SUPPORT
        if (SOC_IS_XGS3_SWITCH(unit) && IS_E_PORT(unit, port)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_NONE,
                                       PASS_CONTROL_FRAMESf,
                                       (value) ? 1 : 0);
        }
#endif
#ifdef BCM_XGS_SWITCH_SUPPORT
        if (IS_XE_PORT(unit, port) || IS_CE_PORT(unit, port) ||
            (IS_GE_PORT(unit, port)
             && soc_feature(unit, soc_feature_unified_port)) ||
            (SOC_IS_KATANAX(unit) && IS_MXQ_PORT(unit, port))) {
            /* Enable Control Frames in BigMAC */
            if(soc_feature(unit, soc_feature_pgw_mac_control_frame)) {
                uint32 rval32 = 0;
                PORT_LOCK(unit);
                rv = READ_PGW_MAC_RSV_MASKr(unit, port, &rval32);
                if (BCM_SUCCESS(rv)) {
                    /* PGW_MAC_RSV_MASK: Bit 11 Control Frame recieved
                     * Enable  Control Frame : Set 0. Packet go through
                     * Disable Control Frame : Set 1. Packet is purged.
                     */
                    if(value) {
                        rval32 &= ~(1 << 11);
                    } else {
                        rval32 |= (1 << 11);
                    }
                    rv = WRITE_PGW_MAC_RSV_MASKr(unit, port, rval32);
                }
                PORT_UNLOCK(unit);
            } else {
                PORT_LOCK(unit);

                if (SOC_IS_SABER2(unit)) {
                    if (IS_MXQ_PORT(unit, port)) {
                        rv = soc_reg_field32_modify(unit, XPORT_CONFIGr, port,
                                                   PASS_PAUSE_FRAMEf, value ? 1 : 0);
                        if (rv == SOC_E_NONE)
                            rv = soc_reg_field32_modify(unit, XPORT_CONFIGr, port,
                                                   PASS_CONTROL_FRAMEf, value ? 1 : 0);
                    } else {
                        rv = soc_reg_field32_modify(unit, IECELL_CONFIGr, port,
                                                   PASS_PAUSE_FRAMEf, value ? 1 : 0);
                        if (rv == SOC_E_NONE)
                            rv = soc_reg_field32_modify(unit,  IECELL_CONFIGr, port,
                                                   PASS_CONTROL_FRAMEf, value ? 1 : 0);
                    }
                }
                rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                     SOC_MAC_PASS_CONTROL_FRAME, value);
                PORT_UNLOCK(unit);
            }
        }
#endif
        break;
#ifdef BCM_XGS3_SWITCH_SUPPORT
    case bcmPortControlFilterLookup:
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        value = value ? 1 : 0;
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       VFP_ENABLEf, value);
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case bcmPortControlFilterIngress:
        value = value ? 1 : 0;
            /* Enable/disable ingress filtering. */
        if (BCM_GPORT_LOCAL_CPU_IEEE == port) {
            rv = _bcm_esw_port_tab_set(unit, CMIC_PORT(unit), _BCM_CPU_TABS_ETHER,
                                       FILTER_ENABLEf, value);
        } else if (BCM_GPORT_LOCAL_CPU_HIGIG == port) {
            rv = _bcm_esw_port_tab_set(unit, CMIC_PORT(unit), _BCM_CPU_TABS_HIGIG,
                                       FILTER_ENABLEf, value);
        } else {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       FILTER_ENABLEf, value);
        }

        break;
    case bcmPortControlFilterEgress:
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
        value = value ? 1 : 0;
        /* Enable/disable egress filtering. */
        if (SOC_REG_FIELD_VALID(unit, egr_port_reg, EFP_FILTER_ENABLEf)) {
            rv = soc_reg_field32_modify(unit, egr_port_reg, port,
                                        EFP_FILTER_ENABLEf, value);
        } else {
            rv = _bcm_esw_egr_port_tab_set(unit, port,
                                          EFP_FILTER_ENABLEf, value);
        }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case bcmPortControlFrameSpacingStretch:
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
        rv = (MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                              SOC_MAC_CONTROL_FRAME_SPACING_STRETCH,
                              value));
        break;
    case bcmPortControlPreservePacketPriority:
#if ((defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)) \
    || defined(BCM_RAVEN_SUPPORT))
        if (SOC_IS_TRIUMPH3(unit)) {
            /* Triumph3 has unity mapping to ING_OUTER_DOT1P_MAPPING_TABLE */
            if (value) {
                /* Remap pointer to default dot1p profile */
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           DOT1P_REMAP_POINTERf, 0);
            }
        } else {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       USE_INCOMING_DOT1Pf, (value) ? 1 : 0);
        }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT || defined(BCM_RAVEN_SUPPORT) */
#if defined(BCM_SHADOW_SUPPORT)
        if (SOC_IS_SHADOW(unit)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            rv = soc_reg_field32_modify(unit, PRIORITY_MAPPING_SELECTr, port,
                                        USE_INPUT_PRIORIYf, 1 );
        }
#endif
        break;
    case bcmPortControlLearnClassEnable:
#if defined(BCM_TRX_SUPPORT)
        if (soc_feature(unit, soc_feature_class_based_learning)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       CLASS_BASED_SM_ENABLEf, value ? 1 : 0);
        }
#endif /* BCM_TRX_SUPPORT */
          break;
    case bcmPortControlTrustIncomingVlan:
#if defined(BCM_TRIDENT3_SUPPORT)
        if (SOC_IS_TRIDENT3X(unit)) {
            uint32 tpid_enables = value;
            if (tpid_enables) {
                uint32 tpid_index;
                /* recover tpid_index from egress */
                BCM_IF_ERROR_RETURN(
                    _bcm_fb2_egr_vlan_control_field_get(
                    unit, port, OUTER_TPID_INDEXf, &tpid_index));
                tpid_enables = 1 << tpid_index;
            }
            rv = _bcm_fb2_port_tpid_enable_set(unit, port, tpid_enables);
            BCM_IF_ERROR_RETURN(rv);
        }  else
#endif
#if defined(BCM_RAVEN_SUPPORT) || defined(BCM_TRX_SUPPORT)
        {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   TRUST_INCOMING_VIDf, (value) ? 1 : 0);
        }
#endif /* BCM_RAVEN_SUPPORT || BCM_TRX_SUPPORT */
          break;
    case bcmPortControlDoNotCheckVlan:
#if defined(BCM_TRX_SUPPORT)
#if defined(BCM_TRIDENT3_SUPPORT)
        if (SOC_IS_TRIDENT3X(unit)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       DISABLE_VLAN_CHECKSf, (value) ? 1 : 0);
            BCM_IF_ERROR_RETURN(rv);
        }
#endif
        if (soc_mem_field_valid(unit, PORT_TABm, DISABLE_VLAN_CHECKSf)) {
            if (CMIC_PORT(unit) == port) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_HIGIG,
                                           DISABLE_VLAN_CHECKSf, (value) ? 1 : 0);
            } else {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           DISABLE_VLAN_CHECKSf, (value) ? 1 : 0);
            }
        } else if (soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm,
                    DISABLE_VLAN_CHECKSf)) {
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
                rv = _bcm_kt2_source_trunk_map_set(unit, port,
                        DISABLE_VLAN_CHECKSf, (value) ? 1 : 0);
            } else
#endif
            {
                rv = _bcm_trx_source_trunk_map_set(unit, port,
                        DISABLE_VLAN_CHECKSf, (value) ? 1 : 0);
            }
        }
#endif /* BCM_TRX_SUPPORT */
        break;
    case bcmPortControlDoNotCheckVlanFromCpu:
#if defined(BCM_TRX_SUPPORT)
#if defined(BCM_TRIDENT3_SUPPORT)
        if (CMIC_PORT(unit) == port) {
            if (SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       DISABLE_VLAN_CHECKSf, (value) ? 1 : 0);
                BCM_IF_ERROR_RETURN(rv);
            }
        }
#endif
        if (CMIC_PORT(unit) == port) {
            if (soc_mem_field_valid(unit, PORT_TABm, DISABLE_VLAN_CHECKSf)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       DISABLE_VLAN_CHECKSf, (value) ? 1 : 0);
            } else if (soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm,
                        DISABLE_VLAN_CHECKSf)) {
                rv = _bcm_trx_source_trunk_map_set(unit, port,
                    DISABLE_VLAN_CHECKSf, (value) ? 1 : 0);
            }
        } else {
            rv = BCM_E_PORT;
        }
#endif /* BCM_TRX_SUPPORT */
        break;
    case bcmPortControlIEEE8021ASEnableIngress:
        if (soc_feature(unit, soc_feature_rx_timestamp)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       IEEE_802_1AS_ENABLEf, (value) ? 1 : 0);
        }
        break;
    case bcmPortControlIEEE8021ASEnableEgress:
#if defined(BCM_HAWKEYE_SUPPORT)
        if (SOC_IS_HAWKEYE(unit)) {
            rv = soc_reg_field32_modify(unit, EGR_PORTr, port,
                                        IEEE_802_1AS_ENABLEf, (value) ? 1 : 0);
        }
#endif /* BCM_HAWKEYE_SUPPORT */
        break;
    case bcmPortControlEgressVlanPriUsesPktPri:
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit) && !SOC_IS_SHADOW(unit)) {
#if defined (BCM_HGPROXY_COE_SUPPORT)
            if (!(soc_feature(unit, soc_feature_hgproxy_subtag_coe) &&
                BCM_GPORT_IS_SUBPORT_PORT(port)))
#endif
            {
                BCM_IF_ERROR_RETURN(
                    _bcm_esw_port_gport_validate(unit, port, &port));
            }
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (soc_feature(unit, soc_feature_egr_vlan_control_is_memory)) {
                if (soc_feature(unit, soc_feature_egr_all_profile)) {
                    rv = bcm_esw_port_egr_lport_field_set(unit,
                        port, EGR_VLAN_CONTROL_1m, REMARK_OUTER_DOT1Pf,
                        value ? 0 : 1);
                } else {
#if defined (BCM_HGPROXY_COE_SUPPORT)
                    if (soc_feature(unit, soc_feature_hgproxy_subtag_coe) &&
                        BCM_GPORT_IS_SUBPORT_PORT(port)) {
                        rv = bcm_esw_port_egr_lport_field_set(
                                unit, port, EGR_VLAN_CONTROL_1m,
                                REMARK_OUTER_DOT1Pf, value ? 0 : 1);
                    } else
#endif
                    {
                        rv = soc_mem_field32_modify(
                                unit, EGR_VLAN_CONTROL_1m, port,
                                REMARK_OUTER_DOT1Pf, value ? 0 : 1);
                    }
                }
            } else
#endif
            {
                rv = soc_reg_field32_modify(unit, EGR_VLAN_CONTROL_1r, port,
                                            REMARK_OUTER_DOT1Pf,
                                            value ? 0 : 1);
#if defined(BCM_GREYHOUND_SUPPORT)
                if (soc_feature(unit, soc_feature_pktpri_as_dot1p)) {
                    if (BCM_FAILURE(rv)) {
                        return rv;
                    }
                    /*
                     * Make sure TREAT_PKTPRI_AS_DOT1P bit is set for
                     * Egress VLAN internal priority mapping.
                     */
                    rv = bcmi_esw_port_treat_pktpri_as_dot1p_ref_cnt_update
                             (unit, (value) ? 1 : -1);
                }
#endif /* BCM_GREYHOUND_SUPPORT */
            }
        }
#endif /* BCM_TRX_SUPPORT */
        break;
    case bcmPortControlEgressModifyDscp:
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit) && !SOC_IS_SHADOW(unit)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (soc_feature(unit, soc_feature_egr_vlan_control_is_memory)) {
                if (soc_feature(unit, soc_feature_egr_all_profile)) {
                    rv = bcm_esw_port_egr_lport_field_set(unit,
                        port, EGR_VLAN_CONTROL_1m, REMARK_OUTER_DSCPf,
                        value ? 1 : 0);
                } else {
                    rv = soc_mem_field32_modify(unit,
                        EGR_VLAN_CONTROL_1m, port, REMARK_OUTER_DSCPf,
                        value ? 1 : 0);
                }
            } else
#endif
            {
                rv = soc_reg_field32_modify(unit, EGR_VLAN_CONTROL_1r, port,
                                            REMARK_OUTER_DSCPf,
                                            value ? 1 : 0);
            }
        }
#endif /* BCM_TRX_SUPPORT */
        break;
    case bcmPortControlIpfixRate:
#ifdef BCM_TRIUMPH2_SUPPORT
        if (soc_feature(unit, soc_feature_ipfix_rate)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       IPFIX_FLOW_METER_IDf, value);
        }
#endif /* BCM_TRIUMPH2_SUPPORT */
        break;
    case bcmPortControlCustomerQueuing:
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
#ifdef BCM_ENDURO_SUPPORT
        if (SOC_IS_ENDURO(unit) && !IS_HG_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }
#endif
#ifdef BCM_HELIX5_SUPPORT
        if (SOC_IS_HELIX5(unit) || SOC_IS_HURRICANE4(unit) ||
            SOC_IS_FIREBOLT6(unit)) {

            uint64 rval64, rval64_tmp, rval64_reset_tmp;
            soc_reg_t reg;
            uint32 phy_port;
            uint32 mmu_port;
            soc_info_t *si = &SOC_INFO(unit);

            if (value < 0 || value > 1) {
                return BCM_E_PARAM;
            }

            COMPILER_64_ZERO(rval64);
            COMPILER_64_ZERO(rval64_tmp);
            COMPILER_64_ZERO(rval64_reset_tmp);
            if (SOC_MEM_IS_VALID(unit, ING_COS_MODEm)) {
               rv = soc_mem_field32_modify(unit, ING_COS_MODEm, port, COS_MODEf, value);
               BCM_IF_ERROR_RETURN(rv);
            } else {

                rv = soc_reg_get(unit, ING_COS_MODEr, port, 0, &rval64);
                BCM_IF_ERROR_RETURN(rv);
                soc_reg64_field32_set(unit, ING_COS_MODEr, &rval64, COS_MODEf,
                                  value);
                rv = soc_reg_set(unit, ING_COS_MODEr, port, 0, rval64);
                BCM_IF_ERROR_RETURN(rv);

                phy_port = si->port_l2p_mapping[port];
                mmu_port = si->port_p2m_mapping[phy_port];
                mmu_port &= (SOC_HX5_MMU_PORT_STRIDE - 1);

                if (mmu_port < 16) {
                    reg = COS_MODE_SPLIT0r;  /* 2 bits per Port 0-15 */
                    COMPILER_64_SET(rval64_tmp, 0, (1 << (mmu_port * 2)));
                    COMPILER_64_SET(rval64_reset_tmp, 0, (3 << (mmu_port * 2)));
                } else {
                    reg = COS_MODE_64_SPLIT1r; /* 1 bit per Port 16-71 */
                    mmu_port -= 16;
                    if (mmu_port < 32) {
                        COMPILER_64_SET(rval64_tmp, 0, (1 << mmu_port));
                    } else {
                        COMPILER_64_SET(rval64_tmp, (1 << (mmu_port - 32)), 0);
                    }
                    COMPILER_64_COPY(rval64_reset_tmp, rval64_tmp);
                }

                SOC_IF_ERROR_RETURN
                    (soc_trident3_xpe_reg_get(unit, reg, -1, si->port_pipe[port],
                                          0, &rval64));
                if (value) {
                    COMPILER_64_OR(rval64, rval64_tmp);
                } else {
                    COMPILER_64_NOT(rval64_reset_tmp);
                    COMPILER_64_AND(rval64, rval64_reset_tmp);
                }
                SOC_IF_ERROR_RETURN
                    (soc_trident3_xpe_reg_set(unit, reg, -1, si->port_pipe[port],
                                          0, rval64));
                rv = BCM_E_NONE;
               }
            break;
        }
#endif /* BCM_HELIX5_SUPPORT */
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            uint64 rval64, rval64_tmp;
            soc_reg_t reg;
            uint32 pipe_portNum;
            soc_info_t *si = &SOC_INFO(unit);

            if (value < 0 || value > 1) {
                return BCM_E_PARAM;
            }

            COMPILER_64_ZERO(rval64);
            COMPILER_64_ZERO(rval64_tmp);

            rv = soc_reg_get(unit, ING_COS_MODEr, port, 0, &rval64);
            BCM_IF_ERROR_RETURN(rv);
            soc_reg64_field32_set(unit, ING_COS_MODEr, &rval64, COS_MODEf,
                    value);
            rv = soc_reg_set(unit, ING_COS_MODEr, port, 0, rval64);
            BCM_IF_ERROR_RETURN(rv);

            pipe_portNum = port % _TD3_PORTS_PER_PIPE;
            if (pipe_portNum < 64) {
                reg = COS_MODE_64_SPLIT0r;
            } else {
                reg = COS_MODE_SPLIT1r;
            }

            if (pipe_portNum < 32) {
                COMPILER_64_SET(rval64_tmp, 0, (1 << pipe_portNum));
            } else {
                COMPILER_64_SET(rval64_tmp, (1 << (pipe_portNum - 32)), 0);
            }

            SOC_IF_ERROR_RETURN
                (soc_trident3_xpe_reg_get(unit, reg, -1, si->port_pipe[port],
                                          0, &rval64));
            if (value) {
                COMPILER_64_OR(rval64, rval64_tmp);
            } else {
                COMPILER_64_NOT(rval64_tmp);
                COMPILER_64_AND(rval64, rval64_tmp);
            }

            SOC_IF_ERROR_RETURN
                (soc_trident3_xpe_reg_set(unit, reg, -1, si->port_pipe[port],
                                          0, rval64));
            rv = BCM_E_NONE;
            break;
        }
#endif /* BCM_TRIDENT3_SUPPORT */
#ifdef BCM_TOMAHAWK_SUPPORT
        if (SOC_IS_TOMAHAWKX(unit)) {
            uint64 rval64, rval64_tmp;
            int pipe, phy_port, mmu_port;
            soc_info_t *si;

            if (SOC_REG_IS_VALID(unit, ING_COS_MODEr)) {

                if (value < 0 || value > 1) {
                    return BCM_E_PARAM;
                }

                COMPILER_64_ZERO(rval64);
                COMPILER_64_ZERO(rval64_tmp);

                rv = soc_reg_get(unit, ING_COS_MODEr, port, 0, &rval64);
                BCM_IF_ERROR_RETURN(rv);
                soc_reg64_field32_set(unit, ING_COS_MODEr, &rval64, COS_MODEf,
                                      value);
                rv = soc_reg_set(unit, ING_COS_MODEr, port, 0, rval64);
                BCM_IF_ERROR_RETURN(rv);

                SOC_IF_ERROR_RETURN(soc_port_pipe_get(unit, port, &pipe));
                si = &SOC_INFO(unit);
                phy_port = si->port_l2p_mapping[port];
                mmu_port = si->port_p2m_mapping[phy_port];
                mmu_port &= (SOC_TH_MMU_PORT_STRIDE - 1);

                COMPILER_64_SET(rval64_tmp, 0, (1 << mmu_port));
                COMPILER_64_ZERO(rval64);
                SOC_IF_ERROR_RETURN
                    (soc_tomahawk_xpe_reg_get(unit, COS_MODE_64r, -1, pipe, 0,
                                              &rval64));
                if (value) {
                    COMPILER_64_OR(rval64, rval64_tmp);
                } else {
                    COMPILER_64_NOT(rval64_tmp);
                    COMPILER_64_AND(rval64, rval64_tmp);
                }

                SOC_IF_ERROR_RETURN
                    (soc_tomahawk_xpe_reg_set(unit, COS_MODE_64r, -1, pipe, 0,
                                              rval64));
                rv = BCM_E_NONE;
            }
            break;
        }
#endif /* BCM_TOMAHAWK_SUPPORT */

#ifdef BCM_TRIDENT2_SUPPORT
        if (SOC_IS_TD2_TT2(unit)) {
            uint32 fval = 0;
            uint64 rval;

            if (value <= 4) {
                fval = value;
            }

            if (!SOC_REG_FIELD_VALID(unit, ING_COS_MODE_64r, QUEUE_MODEf)) {
                return BCM_E_UNAVAIL;
            }

            rv = READ_ING_COS_MODE_64r(unit, port, &rval);
            BCM_IF_ERROR_RETURN(rv);

            soc_reg64_field32_set(unit, ING_COS_MODE_64r, &rval,
                                  QUEUE_MODEf, fval);
            rv = WRITE_ING_COS_MODE_64r(unit, port, rval);
            break;
        }
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIUMPH2_SUPPORT
        if (soc_feature(unit, soc_feature_vlan_queue_map)) {
            uint32 fval = 0;
            if (SOC_IS_TRIUMPH3(unit)) {
                if (value <= 4) {
                    fval = value;
                }
            } else {
                if (value) {
                    fval = 3;
                } else {
                    fval = 0;
                }
            }

            rv = BCM_E_UNAVAIL;

            if (SOC_REG_IS_VALID(unit, ING_COS_MODEr)) {
                if (SOC_REG_FIELD_VALID(unit, ING_COS_MODEr, SELECTf)) {
                    rv = soc_reg_field32_modify(unit, ING_COS_MODEr, port,
                                                SELECTf, fval);
                }
                if (SOC_REG_FIELD_VALID(unit, ING_COS_MODEr, QUEUE_MODEf)) {
                    rv = soc_reg_field32_modify(unit, ING_COS_MODEr, port,
                                                QUEUE_MODEf, fval);
                    /* 0 - COS1 port COS, 1 - COS2 vlan COS */
                    rv = soc_reg_field32_modify(unit, ING_COS_MODEr, port,
                                                COS_MODEf, 1);

                }
            }
            if (SOC_REG_IS_VALID(unit, COS_MODEr)) {
                if (SOC_REG_FIELD_VALID(unit, COS_MODEr, SELECTf)) {
                    rv = soc_reg_field32_modify(unit, COS_MODEr, REG_PORT_ANY,
                                                SELECTf, fval);
                }
            }

        }
#endif /* BCM_TRIUMPH2_SUPPORT */
#ifdef BCM_KATANA_SUPPORT
        if (SOC_IS_KATANAX(unit)) {
            uint32 ing_cos_mode ;
            uint32 rqe_cos_mode;
            uint32      rval = 0;
/*
 * If custom queueing is enabled the ing_cos_mode is set to 1 but 1 is not
 * valid for rqe_cos_mode
 * setting it to 0 if the ing_cos_mode is 1.
 * if value is 4 that means configure service queuing only for unicast
 * traffic. i.e if value = 4 then ing_cos_mode = 3 and rqe_cos_mode 0 or 2.
 */         if (value == 4) {
                ing_cos_mode = 3;
            } else {
                ing_cos_mode = (value <= 3 ? value : 0);
            }
            if (IS_HG_PORT(unit, port)) {
                rqe_cos_mode = ((ing_cos_mode == 1) || (value == 4)) ? 2 : ing_cos_mode;
            } else {
                rqe_cos_mode = ((ing_cos_mode == 1) || (value == 4)) ? 0 : ing_cos_mode;
            }

            if (SOC_REG_FIELD_VALID(unit, ING_COS_MODEr, COS_MODEf)) {
                rv = soc_reg_field32_modify(unit, ING_COS_MODEr, port,
                                            COS_MODEf, ing_cos_mode);
            }

            if (SOC_IS_KATANA(unit)) {
                SOC_IF_ERROR_RETURN(READ_RQE_PORT_CONFIGr(unit, port, &rval));
                soc_reg_field_set(unit, RQE_PORT_CONFIGr, &rval, COS_MODEf,
                                  rqe_cos_mode);
                SOC_IF_ERROR_RETURN(WRITE_RQE_PORT_CONFIGr(unit, port, rval));
            } else {
#if defined(BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit)) {
                    SOC_IF_ERROR_RETURN(READ_RQE_PP_PORT_CONFIGr(unit, port, &rval));
                    soc_reg_field_set(unit, RQE_PP_PORT_CONFIGr, &rval, COS_MODEf,
                                      rqe_cos_mode);
                    SOC_IF_ERROR_RETURN(WRITE_RQE_PP_PORT_CONFIGr(unit, port, rval));
                }
#endif
            }
        }
#endif /* BCM_KATANA_SUPPORT */
        break;
#endif /* BCM_XGS3_SWITCH_SUPPORT */

#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_APOLLO_SUPPORT)
    case bcmPortControlOAMEnable:
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   OAM_ENABLEf, value ? 1 : 0);
#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            rv = _bcm_esw_egr_port_tab_set(unit, port,
                                   OAM_ENABLEf, value ? 1 : 0);
        }
#endif
        break;
#endif /* defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_APOLLO_SUPPORT) */

#if defined(BCM_OLP_SUPPORT)
    case bcmPortControlOlpEnable:

        if (soc_feature(unit, soc_feature_olp)) {
            ing_en_efilter_bitmap_entry_t efilter_entry;
            bcm_module_t module_id = 0;
            bcm_module_t my_modid;
            bcm_port_t port_id;
            bcm_trunk_t trunk_id = BCM_TRUNK_INVALID;
            int         local_id;
            uint32      olp_enable;
            pbmp_t      pbmp;

            olp_enable = value ? 1 : 0;

            BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, &my_modid));

            if (BCM_GPORT_IS_SET(port)) {
                SOC_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port, &module_id,
                            &port_id, &trunk_id, &local_id));

#if defined(BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit) &&
                        (BCM_GPORT_IS_SUBPORT_PORT(port)) &&
                        ((_BCM_KT2_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) ||
                         (_BCM_KT2_GPORT_IS_LINKPHY_SUBPORT_PORT(unit, port)))) {

                    LOG_ERROR(BSL_LS_BCM_L2,
                            (BSL_META_U(unit,
                                        "OLP is not allowed on SUBPORT. \
                                        \n")));
                    return BCM_E_PARAM;
                }
#endif
            } else {
                port_id = port;
            }
            if ((module_id == 0) || (module_id == my_modid)) {
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
                if(SOC_IS_TRIDENT2PLUS(unit) || SOC_IS_APACHE(unit)) {
                    iarb_ing_port_table_entry_t entry;
                    port_tab_entry_t            port_entry;
                    uint64                      mac;
                    int                         prefix_check = 0;

                    SOC_IF_ERROR_RETURN(soc_mem_read(unit, IARB_ING_PORT_TABLEm,
                                        MEM_BLOCK_ANY, port_id, &entry));
                    soc_IARB_ING_PORT_TABLEm_field32_set(unit, &entry,
                                                          OLP_ENABLEf, olp_enable);
                    SOC_IF_ERROR_RETURN(soc_mem_write(unit, IARB_ING_PORT_TABLEm,
                                         MEM_BLOCK_ALL, port_id, &entry));


                    /* Enable/Disable the prefix checking on the OLP port
                     * If OLP is being enabled  - Disable prefix checking
                     * If OLP is being disabled - Enable prefix checking if it
                     *                            is configured.
                     */
                    prefix_check = 0;
                    if (0 == olp_enable) {
                        SOC_IF_ERROR_RETURN(READ_ING_OLP_CONFIG_0_64r(unit, &mac));
                        if (!COMPILER_64_IS_ZERO(mac)) {
                            prefix_check = 1;
                        }
                    }
                    SOC_IF_ERROR_RETURN(READ_PORT_TABm(unit,
                                                       MEM_BLOCK_ANY,
                                                       port_id,
                                                       &port_entry));
                    soc_PORT_TABm_field32_set(unit,
                                              &port_entry,
                                              OLP_MAC_DA_PREFIX_CHECK_ENABLEf,
                                              prefix_check);

                    SOC_IF_ERROR_RETURN(WRITE_PORT_TABm(unit,
                                                        MEM_BLOCK_ALL,
                                                        port_id,
                                                        &port_entry));
                } else
#endif
                {
                    iarb_ing_physical_port_entry_t  entry;
                    ing_physical_port_table_entry_t port_entry;
                    uint64                          mac;
                    int                             prefix_check = 0;

                    SOC_IF_ERROR_RETURN(soc_mem_read(unit, IARB_ING_PHYSICAL_PORTm,
                                         MEM_BLOCK_ANY, port_id, &entry));
                    soc_IARB_ING_PHYSICAL_PORTm_field32_set(unit, &entry,
                                         OLP_ENABLEf, olp_enable);
                    SOC_IF_ERROR_RETURN(soc_mem_write(unit, IARB_ING_PHYSICAL_PORTm,
                                         MEM_BLOCK_ALL, port_id, &entry));

                    /* Enable/Disable the prefix checking on the OLP port
                     * If OLP is being enabled  - Disable prefix checking
                     * If OLP is being disabled - Enable prefix checking if it
                     *                            is configured.
                     */
                    prefix_check = 0;
                    if (0 == olp_enable) {
                        SOC_IF_ERROR_RETURN(READ_ING_OLP_CONFIG_0_64r(unit, &mac));
                        if (!COMPILER_64_IS_ZERO(mac)) {
                            prefix_check = 1;
                        }
                    }
                    SOC_IF_ERROR_RETURN(
                                   READ_ING_PHYSICAL_PORT_TABLEm(unit,
                                                                 MEM_BLOCK_ANY,
                                                                 port_id,
                                                                 &port_entry));

                    soc_ING_PHYSICAL_PORT_TABLEm_field32_set(unit,
                                                             &port_entry,
                                                             OLP_MAC_DA_PREFIX_CHECK_ENABLEf,
                                                             prefix_check);
                    SOC_IF_ERROR_RETURN(
                                   WRITE_ING_PHYSICAL_PORT_TABLEm(unit,
                                                                  MEM_BLOCK_ALL,
                                                                  port_id,
                                                                  &port_entry));
                }
                /* Disable EFILTER */
                SOC_IF_ERROR_RETURN(soc_mem_read(unit, ING_EN_EFILTER_BITMAPm,
                                       MEM_BLOCK_ANY, 0, &efilter_entry));
                soc_mem_pbmp_field_get(unit, ING_EN_EFILTER_BITMAPm,
                                       &efilter_entry, BITMAPf, &pbmp);
                if (olp_enable) {
                    SOC_PBMP_PORT_REMOVE(pbmp, port_id);
                } else {
                    SOC_PBMP_PORT_ADD(pbmp, port_id);
                }
                soc_mem_pbmp_field_set(unit, ING_EN_EFILTER_BITMAPm,
                        &efilter_entry, BITMAPf, &pbmp);
                SOC_IF_ERROR_RETURN(soc_mem_write(unit, ING_EN_EFILTER_BITMAPm,
                            MEM_BLOCK_ALL, 0, &efilter_entry));
            }
            rv = BCM_E_NONE;
        }
        break;
#endif /* BCM_OLP_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT) || defined (BCM_APACHE_SUPPORT)
    case bcmPortControlPortMacOui:
    case bcmPortControlPortMacNonOui:

        /*
         * In case of KT2, SB2 and TD2+ NONTCAM STATION related to OAM, OLP, XGS can be programmed
         * by either of bcm_l2_station_xxx API or  bcm_switch_olp_l2_addr_xxx
         *
         * Use either of two set of APIs
         */

        if (_BCM_SWITCH_OLP_APIV(unit) == _BCM_SWITCH_OLP_L2_STATION_API) {
            LOG_VERBOSE(BSL_LS_BCM_L2,
                        (BSL_META_U(unit,
                                    "use bcm_l2_station_xxx API\n")));
            return BCM_E_UNAVAIL;
        }
        _BCM_SWITCH_OLP_APIV_SET(unit, _BCM_SWITCH_OLP_TRUE_API);

#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit) &&
                 (soc_feature(unit, soc_feature_oam)  ||
                  soc_feature(unit, soc_feature_sat))) {
            uint32 val_lo, val_hi;
            uint64 mac_field;

            PORT_LOCK(unit);

            rv = _bcm_kt2_port_mac_get(unit, port, &mac_field);

            if (BCM_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }

            COMPILER_64_TO_32_LO(val_lo, mac_field);
            COMPILER_64_TO_32_HI(val_hi, mac_field);

            switch (type) {
                case bcmPortControlPortMacOui:
                    val_lo = (val_lo & 0xffffff) | ((value & 0xff) << 24);
                    val_hi = (value >> 8) & 0xffff;
                    COMPILER_64_SET(mac_field, val_hi, val_lo);
                    break;

                case bcmPortControlPortMacNonOui:
                    val_lo = (val_lo & 0xff000000) | (value & 0xffffff);
                    COMPILER_64_SET(mac_field, val_hi, val_lo);
                    break;

                default:
                     break;
            }

            rv = _bcm_kt2_port_mac_set(unit, port, mac_field);
            PORT_UNLOCK(unit);
        }
#endif /* BCM_KATANA2_SUPPORT */

#if defined(BCM_MONTEREY_SUPPORT)
        if (SOC_IS_MONTEREY(unit)) {
            PORT_LOCK(unit);
            rv = _bcm_monterey_port_mac_set(unit,
                                          port,
                                          type == bcmPortControlPortMacOui,
                                          value);
            PORT_UNLOCK(unit);
        }
#endif /* BCM_MONTEREY_SUPPORT */
#if defined(BCM_APACHE_SUPPORT)
        if (SOC_IS_APACHE(unit) && !SOC_IS_MONTEREY(unit)) {
            PORT_LOCK(unit);
            rv = _bcm_apache_port_mac_set(unit,
                                          port,
                                          type == bcmPortControlPortMacOui,
                                          value);
            PORT_UNLOCK(unit);
        }
#endif /* BCM_APACHE_SUPPORT */
        break;
#endif /* BCM_KATANA2_SUPPORT || BCM_APACHE_SUPPORT */
#ifdef BCM_TRX_SUPPORT
    case bcmPortControlOamLoopback:
        if (SOC_IS_TRX(unit) && !SOC_IS_HURRICANE(unit)
            && !SOC_IS_SHADOW(unit)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

            if (soc_reg_field_valid(unit,ING_MISC_PORT_CONFIGr,
                                    OAM_DO_NOT_MODIFYf)) {

                rv = soc_reg_field32_modify(unit, ING_MISC_PORT_CONFIGr, port,
                                            OAM_DO_NOT_MODIFYf, value ? 1 : 0);
            } else {
                return BCM_E_UNAVAIL;
            }
        }

        break;
#endif /* BCM_TRX_SUPPORT */

    case bcmPortControlLanes:
        if (soc_feature(unit, soc_feature_flexport_no_legacy)) {
            return BCM_E_UNAVAIL;
        }
#if defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_flex_port)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
#ifdef BCM_TRIDENT_SUPPORT
            if (SOC_IS_TRIDENT(unit) || SOC_IS_TITAN(unit)) {
                bcm_port_t phy_port;
                int bindex;

                if (!SOC_PORT_VALID(unit, port)) {
                    return BCM_E_PORT;
                }
                if (value != 1 && value != 2 && value != 4) {
                    return BCM_E_PARAM;
                }
                /* coverity[overrun-local : FALSE] */
                phy_port = SOC_INFO(unit).port_l2p_mapping[port];
                bindex = SOC_PORT_BINDEX(unit, phy_port);
                if (bindex & (value - 1)) { /* port alignment check */
                    return BCM_E_PARAM;
                }
            }
#endif /* BCM_TRIDENT_SUPPORT */
            _bcm_esw_port_mirror_lock(unit);

#ifdef BCM_XGS5_SWITCH_PORT_SUPPORT
            if (soc_feature(unit, soc_feature_xgs5_flexport_legacy_mode)) {
                rv = bcmi_xgs5_port_lanes_set(unit, port, value);
            }
#endif /* BCM_XGS5_SWITCH_PORT_SUPPORT */
#if defined(BCM_ENDURO_SUPPORT)
            if (SOC_IS_ENDURO(unit)) {
                rv = _bcm_en_port_lanes_set(unit, port, value);
            } else
#endif
#if defined(BCM_HURRICANE1_SUPPORT)
            if (SOC_IS_HURRICANE(unit)) {
                rv = _bcm_hu_port_lanes_set(unit, port, value);
            } else
#endif
#if defined(BCM_HURRICANE2_SUPPORT)
            if (SOC_IS_HURRICANE2(unit)) {
                rv = _bcm_hu2_port_lanes_set(unit, port, value);
            } else
#endif
#ifdef BCM_TOMAHAWK_SUPPORT
            if (SOC_IS_TOMAHAWK(unit) || SOC_IS_TRIDENT3X(unit)) {
                /* coverity[overrun-call : FALSE] */
                rv = _bcm_th_port_lanes_set(unit, port, value);
            } else
#endif
#if defined(BCM_MONTEREY_SUPPORT)
            if (SOC_IS_MONTEREY(unit)) {
                rv = bcmi_monterey_port_lanes_set(unit, port, value);
            } else
#endif
#if defined(BCM_APACHE_SUPPORT)
            if (SOC_IS_APACHE(unit)) {
                rv = bcmi_apache_port_lanes_set(unit, port, value);
            } else
#endif
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
            if (SOC_IS_TD2P_TT2P(unit)) {
                rv = bcmi_td2p_port_lanes_set(unit, port, value);
            } else
#endif
#ifdef BCM_TRIDENT2_SUPPORT
            if (SOC_IS_TD2_TT2(unit)) {
                rv = _bcm_td2_port_lanes_set(unit, port, value);
                _bcm_flex_port_phy_control_software_rx_los_get(unit, port);
            } else
#endif
#ifdef BCM_TRIDENT_SUPPORT
            if (SOC_IS_TD_TT(unit)) {
                /* coverity[overrun-call : FALSE] */
                rv = _bcm_td_port_lanes_set(unit, port, value);
            } else
#endif /* BCM_TRIDENT_SUPPORT */
#ifdef BCM_SHADOW_SUPPORT
            if (SOC_IS_SHADOW(unit)) {
                soc_info_t *si = NULL;
                int okay;
                int i;

                rv = _bcm_shadow_port_lanes_set(unit, port, value);
                if (BCM_SUCCESS(rv)) {
                    si = &SOC_INFO(unit);
                    if (value == 1) { /* Probe other ports */
                        for (i = port; i < port+4; i++) {
                            rv = soc_phyctrl_detach(unit, i);
                            if (SOC_FAILURE(rv)) {
                                _bcm_esw_port_mirror_unlock(unit);
                                return (rv);
                            }
                        }
                        for (i = port; i < port+4; i++) {
                            /* coverity[overrun-local : FALSE] */
                            si->port_num_lanes[i] = value;
                            rv = _bcm_port_probe(unit, i, &okay);
                        }
                    } else if (value == 4) { /* Probe other ports */
                        si = &SOC_INFO(unit);
                        for (i = port; i < port+4; i++) {
                            rv = soc_phyctrl_detach(unit, i);
                            if (SOC_FAILURE(rv)) {
                                _bcm_esw_port_mirror_unlock(unit);
                                return (rv);
                            }
                        }
                        /* coverity[overrun-local : FALSE] */
                        si->port_num_lanes[port] = value;
                        rv = _bcm_port_probe(unit, port, &okay);
                    }
                }
            } else
#endif /* BCM_SHADOW_SUPPORT */
#ifdef BCM_TRIUMPH3_SUPPORT
            if (SOC_IS_TRIUMPH3(unit)) {
                if (!SOC_IS_HELIX4(unit) && (_tr3_port_config_id[unit] == 112 ||
                    _tr3_port_config_id[unit] == 12)&&
                    (port == 54 || port == 55)) {
                    _bcm_esw_port_mirror_unlock(unit);
                    return BCM_E_PARAM;
                }
                COUNTER_LOCK(unit);
                rv = _bcm_tr3_port_lanes_set(unit, port, value);
                COUNTER_UNLOCK(unit);
            } else
#endif /* BCM_TRIUMPH3_SUPPORT */
#ifdef  BCM_METROLITE_SUPPORT
             if (SOC_IS_METROLITE(unit)) {
                 COUNTER_LOCK(unit);
                 SOC_L2_DEL_SYNC_LOCK(SOC_CONTROL(unit));
                 rv = _bcm_ml_port_lanes_set(unit, port, value);
                SOC_L2_DEL_SYNC_UNLOCK(SOC_CONTROL(unit));
                 COUNTER_UNLOCK(unit);
            } else
#endif /* BCM_METROLITE_SUPPORT */
#ifdef BCM_SABER2_SUPPORT
            if (SOC_IS_SABER2(unit)) {
                COUNTER_LOCK(unit);
                SOC_L2_DEL_SYNC_LOCK(SOC_CONTROL(unit));
                rv = _bcm_sb2_port_lanes_set(unit, port, value);
                SOC_L2_DEL_SYNC_UNLOCK(SOC_CONTROL(unit));
                COUNTER_UNLOCK(unit);
            } else
#endif /* BCM_SABER2_SUPPORT */
#ifdef BCM_KATANA2_SUPPORT
            if (SOC_IS_KATANA2(unit)) {
                COUNTER_LOCK(unit);
                SOC_L2_DEL_SYNC_LOCK(SOC_CONTROL(unit));
                rv = _bcm_kt2_port_lanes_set(unit, port, value);
                SOC_L2_DEL_SYNC_UNLOCK(SOC_CONTROL(unit));
                COUNTER_UNLOCK(unit);
            } else
#endif /* BCM_KATANA2_SUPPORT */
            {
                rv = _bcm_tr2_port_lanes_set(unit, port, value);
            }
            _bcm_esw_port_mirror_unlock(unit);
#ifdef  BCM_METROLITE_SUPPORT
            if (BCM_SUCCESS(rv) && SOC_IS_METROLITE(unit)) {
                COUNTER_LOCK(unit);
                SOC_L2_DEL_SYNC_LOCK(SOC_CONTROL(unit));
                rv = _bcm_ml_port_lanes_set_post_operation(unit, port);
                SOC_L2_DEL_SYNC_UNLOCK(SOC_CONTROL(unit));
                COUNTER_UNLOCK(unit);
            } else
#endif /* BCM_METROLITE_SUPPORT */
#ifdef BCM_SABER2_SUPPORT
            if (BCM_SUCCESS(rv) && SOC_IS_SABER2(unit)) {
                COUNTER_LOCK(unit);
                SOC_L2_DEL_SYNC_LOCK(SOC_CONTROL(unit));
                rv = _bcm_sb2_port_lanes_set_post_operation(unit, port);
                SOC_L2_DEL_SYNC_UNLOCK(SOC_CONTROL(unit));
                COUNTER_UNLOCK(unit);
            } else
#endif
#ifdef BCM_KATANA2_SUPPORT
            /* Dead Lock (with port lock) so calling separately */
            if (BCM_SUCCESS(rv) && SOC_IS_KATANA2(unit)) {
                COUNTER_LOCK(unit);
                SOC_L2_DEL_SYNC_LOCK(SOC_CONTROL(unit));
                rv = _bcm_kt2_port_lanes_set_post_operation(unit, port);
                SOC_L2_DEL_SYNC_UNLOCK(SOC_CONTROL(unit));
                COUNTER_UNLOCK(unit);
            }
#endif
        }
#endif
        break;

    case bcmPortControlPFCEthertype:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }
            if (value < 0 || value > 0xffff) {
                return BCM_E_PARAM;
            }
            rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_TYPE, value);
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
        break;

    case bcmPortControlPFCOpcode:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }
            if (value < 0 || value > 0xffff) {
                return BCM_E_PARAM;
            }
            rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_OPCODE, value);
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
        break;

    case bcmPortControlPFCReceive:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            int pfc_enable;
            int val_count = 0;
            soc_reg_t reg;
            uint32 values[2];
            soc_field_t fields[] = {PFC_ENABLEf, LLFC_ENf};

            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }

            BCM_IF_ERROR_RETURN
                (MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_RX_ENABLE, value));
            if (value == 0) {
                BCM_IF_ERROR_RETURN
                    (MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                     SOC_MAC_CONTROL_PFC_TX_ENABLE,
                                     &pfc_enable));
            } else {
                pfc_enable = TRUE;
            }

            if (SOC_IS_SC_CQ(unit)) {
                BCM_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, MMU_LLFC_RX_CONFIGr,
                                            port, RX_ENABLEf, value ? 1 : 0));
            }

            if (value == 0) {
                /* Disabling RX, flush MMU XOFF state */
                BCM_IF_ERROR_RETURN
                    (MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                     SOC_MAC_CONTROL_PFC_FORCE_XON, 1));
                BCM_IF_ERROR_RETURN
                    (MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                     SOC_MAC_CONTROL_PFC_FORCE_XON, 0));
            }

            /* Port config settings */
            values[0] = pfc_enable ? 1 : 0;
            values[1] = 0;

            if (SOC_IS_TD2_TT2(unit)) {
                reg = INVALIDr;
            } else if (SOC_IS_TD_TT(unit) || SOC_IS_SHADOW(unit)) {
                reg = XLPORT_CONFIGr;
                val_count=2;
            } else if (SOC_IS_TRIUMPH3(unit)) {
                reg = PORT_CONFIGr;
                val_count=2;
            } else if (SOC_IS_SABER2(unit)) {
                /* No port level config required */
                reg = INVALIDr;
                val_count = 0;
            } else if (SOC_IS_KATANAX(unit)) {
                reg = XPORT_CONFIGr;
                val_count=2;
            } else {
                reg = INVALIDr;
            }

            if (val_count > 0) {
                BCM_IF_ERROR_RETURN
                    (soc_reg_fields32_modify(unit, reg, port,
                                             COUNTOF(values), fields, values));
            } else if (SOC_IS_TD2_TT2(unit)) {
                ;
            } else if (SOC_IS_SC_CQ(unit) || SOC_IS_TR_VL(unit)) {
                if (SOC_REG_IS_VALID(unit, PPFC_ENr)) {
                    /* Feature enable */
                    BCM_IF_ERROR_RETURN
                        (soc_reg_field32_modify(unit, PPFC_ENr, port,
                                                PPFC_FEATURE_ENf,
                                                pfc_enable ? 1 : 0));
                }
                if (soc_reg_field_valid(unit, XPORT_CONFIGr, PPP_ENABLEf)) {
                    BCM_IF_ERROR_RETURN
                        (soc_reg_field32_modify(unit, XPORT_CONFIGr,
                                                port, PPP_ENABLEf,
                                                pfc_enable ? 1 : 0));
                }
            }

            /* Stats enable */
            rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_STATS_ENABLE,
                                 pfc_enable ? 1 : 0);

            if (SOC_REG_IS_VALID(unit, XPORT_TO_MMU_BKPr) && pfc_enable == 0) {
                BCM_IF_ERROR_RETURN(WRITE_XPORT_TO_MMU_BKPr(unit, port, 0));
            }
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
        break;

    case bcmPortControlPFCTransmit:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            rv = _bcm_sc_tr_port_pfc_tx_set(unit, port, (value)? 0xffff : 0);
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
        break;

    case bcmPortControlPFCClasses:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }
            rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_CLASSES, value);
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
        break;

    case bcmPortControlPFCPassFrames:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }
            if(soc_feature(unit, soc_feature_pgw_mac_pfc_frame)) {
                uint32 rval32 = 0;
                soc_reg_t reg = INVALIDr;
                if(SOC_REG_IS_VALID(unit, PGW_MAC_RSV_MASKr)) {
                    reg = PGW_MAC_RSV_MASKr;
                } else if(IS_CL_PORT(unit, port) &&
                          SOC_REG_IS_VALID(unit, CLPORT_MAC_RSV_MASKr)) {
                    reg = CLPORT_MAC_RSV_MASKr;
                } else if(IS_XL_PORT(unit, port) &&
                          SOC_REG_IS_VALID(unit, XLPORT_MAC_RSV_MASKr)) {
                    reg = XLPORT_MAC_RSV_MASKr;
                } else {
                    reg = INVALIDr;
                }

                if (reg != INVALIDr) {
                    PORT_LOCK(unit);
                    rv = soc_reg32_get(unit, reg, port, 0, &rval32);
                    if (BCM_SUCCESS(rv)) {
                        /* xxx_MAC_RSV_MASK: Bit 18 PFC frame detected
                         * Enable  PFC Frame : Set 0. Go through
                         * Disable PFC Frame : Set 1. Purged.
                         */
                        if(value) {
                            rval32 &= ~(1 << 18);
                        } else {
                            rval32 |= (1 << 18);
                        }
                        rv = soc_reg32_set(unit, reg, port, 0, rval32);
                    }
                    PORT_UNLOCK(unit);
                } else {
                    rv = BCM_E_UNAVAIL;
                }
            } else {
                PORT_LOCK(unit);
                rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                     SOC_MAC_CONTROL_PFC_RX_PASS, value);
                PORT_UNLOCK(unit);
            }
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
        break;

    case bcmPortControlPFCDestMacOui:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }
            if (value < 0 || value > 0xffffff) {
                return BCM_E_PARAM;
            }
            rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_MAC_DA_OUI, value);
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
        break;

    case bcmPortControlPFCDestMacNonOui:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }
            if (value < 0 || value > 0xffffff) {
                return BCM_E_PARAM;
            }
            rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_MAC_DA_NONOUI, value);
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
        break;

    case bcmPortControlPFCRefreshTime:
#if defined(BCM_TRIDENT_SUPPORT)||defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (value < 0 || value > 0xffff) {
                return BCM_E_PARAM;
            }
            rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_REFRESH_TIME, value);
        }
#endif /* BCM_TRIDENT_SUPPORT */
        break;

    case bcmPortControlPFCXOffTime:
#if defined(BCM_TRIDENT_SUPPORT)||defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (value < 0 || value > 0xffff) {
                return BCM_E_PARAM;
            }
            rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_XOFF_TIME, value);
        }
#endif /* BCM_TRIDENT_SUPPORT */
        break;

    case bcmPortControlVrf:
        rv = _bcm_esw_port_vrf_set(unit, port, value);
        break;

    case bcmPortControlL3Ingress:
#if defined(BCM_TRIUMPH_SUPPORT)
        if (!soc_feature(unit, soc_feature_l3_ingress_interface)) {
            return BCM_E_UNAVAIL;
        }

        if (soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm, L3_IIFf)) {
            if ((value >= 1) && (value < soc_mem_index_count(unit, L3_IIFm))) {
#if defined(BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit)) {
                    rv = _bcm_kt2_source_trunk_map_set(unit, port, L3_IIFf, value);
                } else
#endif
                {
                    rv = _bcm_trx_source_trunk_map_set(unit, port, L3_IIFf, value);
                }
                BCM_IF_ERROR_RETURN(rv);
                if (soc_mem_field_valid(unit, PORT_TABm, PORT_OPERATIONf) ||
                    SOC_IS_TRIDENT3X(unit)) {
                    rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                               PORT_OPERATIONf, 0x2);
                }
            } else {
#if defined(BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit)) {
                    rv = _bcm_kt2_source_trunk_map_set(unit, port, L3_IIFf, 0);
                } else
#endif
                {
                    rv = _bcm_trx_source_trunk_map_set(unit, port, L3_IIFf, 0);
                }
                BCM_IF_ERROR_RETURN(rv);
                if (soc_mem_field_valid(unit, PORT_TABm, PORT_OPERATIONf)) {
                    rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                               PORT_OPERATIONf, 0x0);
                }
            }
        }
#endif  /* BCM_TRIUMPH_SUPPORT */
        break;

    case bcmPortControlL2Learn:
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit)) {
            uint32 hw_val = 0;
            bcm_port_cfg_t port_cfg;

            BCM_IF_ERROR_RETURN(
                _bcm_trx_port_cml_flags2hw(unit, value, &hw_val));
            BCM_IF_ERROR_RETURN(mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &port_cfg));
            port_cfg.pc_cml = hw_val;
            rv = mbcm_driver[unit]->mbcm_port_cfg_set(unit, port, &port_cfg);
        }
#endif /* BCM_TRX_SUPPORT */
          break;

    case bcmPortControlL2Move:
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit)) {
            uint32 hw_val = 0;
            bcm_port_cfg_t port_cfg;

            BCM_IF_ERROR_RETURN(
                _bcm_trx_port_cml_flags2hw(unit, value, &hw_val));
            BCM_IF_ERROR_RETURN(mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &port_cfg));
            port_cfg.pc_cml_move = hw_val;
            rv = mbcm_driver[unit]->mbcm_port_cfg_set(unit, port, &port_cfg);
        }
#endif /* BCM_TRX_SUPPORT */
          break;

    case bcmPortControlForwardStaticL2MovePkt:
#if defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   DISABLE_STATIC_MOVE_DROPf, value ? 1 : 0);
#endif /* BCM_TRX_SUPPORT */
        break;

    case bcmPortControlPrbsMode:
        if (value != 0) {
            return BCM_E_PARAM;
        }
        rv = BCM_E_NONE;
        break;

    case bcmPortControlPrbsPolynomial:
        /*prbs polynomial value check*/
        if((value < BCM_PORT_PRBS_POLYNOMIAL_X7_X6_1)
            || (value > BCM_PORT_PRBS_POLYNOMIAL_PAM4_13Q))
        {
            return BCM_E_PARAM;
        }
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_set(unit, port,
                                     SOC_PHY_CONTROL_PRBS_POLYNOMIAL, value);
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlPrbsTxEnable:
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_set(unit, port,
                                     SOC_PHY_CONTROL_PRBS_TX_ENABLE, value);
        PORT_UNLOCK(unit);
        break;

    case bcmPortControlPrbsRxEnable:
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_set(unit, port,
                                     SOC_PHY_CONTROL_PRBS_RX_ENABLE, value);
        PORT_UNLOCK(unit);
        break;

    case bcmPortControlPrbsTxInvertData:
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_set(unit, port,
                                     SOC_PHY_CONTROL_PRBS_TX_INVERT_DATA,
                                     value);
        PORT_UNLOCK(unit);
        break;

    case bcmPortControlLinkFaultLocalEnable:
        rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                             SOC_MAC_CONTROL_FAULT_LOCAL_ENABLE, value);
        break;
    case bcmPortControlLinkFaultRemoteEnable:
        rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                             SOC_MAC_CONTROL_FAULT_REMOTE_ENABLE, value);
        break;
    case bcmPortControlSerdesDriverTune:
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_set(unit, port,
                SOC_PHY_CONTROL_SERDES_DRIVER_TUNE, value);
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlLinkdownTransmit:
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_set(unit, port,
                SOC_PHY_CONTROL_LINKDOWN_TRANSMIT, value);
        PORT_UNLOCK(unit);
        /* Most of PHYs have nothing to configure and simply return UNAVAIL*/
        if ((rv == SOC_E_NONE) || (rv == SOC_E_UNAVAIL)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_link_down_tx_set(unit, port, value));
#ifdef BCM_HURRICANE4_SUPPORT
            if (SOC_IS_HURRICANE4(unit) && IS_EGPHY_PORT(unit, port)) {
                return rv;
            }
#endif
#if defined(BCM_TRIUMPH3_SUPPORT)
            if (SOC_REG_PORT_VALID(unit, XMAC_RX_LSS_CTRLr, port)) {
                rv = soc_reg_field32_modify(unit, XMAC_RX_LSS_CTRLr,
                         port, LOCAL_FAULT_DISABLEf, (value ? 1 : 0));
            } else if (SOC_REG_PORT_VALID(unit, XLMAC_RX_LSS_CTRLr, port)) {
                rv = soc_reg_field32_modify(unit, XLMAC_RX_LSS_CTRLr,
                         port, LOCAL_FAULT_DISABLEf, (value ? 1 : 0));
            }
#endif
        }
        break;
    case bcmPortControlSerdesTuneMarginMode:
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_set(unit, port,
                SOC_PHY_CONTROL_SERDES_TUNE_MARGIN_MODE, value);
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlSerdesTuneMarginValue:
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_set(unit, port,
                SOC_PHY_CONTROL_SERDES_TUNE_MARGIN_VALUE, value);
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlStatOversize:
        rv = _bcm_esw_stat_ovr_threshold_set(unit, port, value);
        break;

    case bcmPortControlStatOversizeIsError:
        rv = _bcm_esw_stat_ovr_error_control_set(unit, port, value);
        break;

    case bcmPortControlTimestampEnable:
#if defined(BCM_HAWKEYE_SUPPORT)
        if (SOC_IS_HAWKEYE(unit)) {
            uint32 rval;
            if (!SOC_PORT_VALID(unit, port)) {
                return BCM_E_PORT;
            }
            SOC_IF_ERROR_RETURN(READ_EAV_ENABLE_BMAPr(unit, &rval));
            if (value) {
                /* coverity[BAD_SHIFT: FALSE] */
                rval |= (port >= 32 ? 0 : (1 << port));
            } else {
                /* coverity[BAD_SHIFT: FALSE] */
                rval &= ~(port >= 32 ? 0 : (1 << port));
            }
            SOC_IF_ERROR_RETURN(WRITE_EAV_ENABLE_BMAPr(unit, rval));

            /* Enable MMU */
            SOC_IF_ERROR_RETURN(WRITE_MMUEAVENABLEr(unit, rval));

            /* Program EGR_PORT register */
            SOC_IF_ERROR_RETURN(READ_EGR_PORTr(unit, port, &rval));
            soc_reg_field_set(unit, EGR_PORTr, &rval, EAV_CAPABLEf, value);
            SOC_IF_ERROR_RETURN(WRITE_EGR_PORTr(unit, port, rval));

            rv = BCM_E_NONE;
        } else
#endif /* BCM_HAWKEYE_SUPPORT */
        if (soc_feature (unit, soc_feature_xlmac_timestamp_disable)) {
            if (IS_XL_PORT(unit, port)) {
                /* Enable/disable timesatmp on XLMAC */
                uint32 rval;
                SOC_IF_ERROR_RETURN(READ_XLPORT_MAC_CONTROLr(unit,
                                                             port, &rval));
                soc_reg_field_set(unit, XLPORT_MAC_CONTROLr, &rval,
                                  XLMAC_TS_DISABLEf, (value) ? 0 : 1);
                SOC_IF_ERROR_RETURN(WRITE_XLPORT_MAC_CONTROLr(unit,
                                                              port, rval));
                rv = BCM_E_NONE;
            }
        }
        break;

    case bcmPortControlEEEEnable:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }

        PORT_LOCK(unit);

#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_HAWKEYE_SUPPORT) \
        || defined(BCM_TRIDENT_SUPPORT) || defined(BCM_SHADOW_SUPPORT) \
        || defined(BCM_HURRICANE2_SUPPORT)
        if (soc_feature (unit, soc_feature_eee)) {
            int mac_val;
            uint32 phy_val;

            if ((MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_EEE_ENABLE,
                                 &mac_val) != SOC_E_UNAVAIL) &&
                (soc_phyctrl_control_get(unit, port,
                                         BCM_PORT_PHY_CONTROL_EEE,
                                         &phy_val) != SOC_E_UNAVAIL)) {

                /* If MAC/Switch is EEE aware (Native EEE mode is supported)
                 * and PHY also supports Native EEE mode
                 */

                /* a. Disable AutoGrEEEn mode by PHY if applicable */
                rv = (soc_phyctrl_control_get(unit, port,
                                              BCM_PORT_PHY_CONTROL_EEE_AUTO,
                                              &phy_val));

                if ((rv != SOC_E_UNAVAIL) && (phy_val != 0)) {
                    rv = soc_phyctrl_control_set(unit, port,
                                                 BCM_PORT_PHY_CONTROL_EEE_AUTO,
                                                 0);
                }

                /* b. Enable/Disable Native EEE in PHY */
                rv = soc_phyctrl_control_set (unit, port,
                        BCM_PORT_PHY_CONTROL_EEE, value ? 1 : 0);

                if (SOC_SUCCESS(rv)) {
                    /* EEE standard compliance Work Around:
                     * Store the software copy of eee value in eee_cfg flag
                     */
                    eee_cfg[unit][port] = value;
                    /* If (value==1), EEE will be enabled in MAC after 1 sec.
                     * during linkscan update*/
                    if (value == 0) {
                        /* Disable EEE in MAC immediately*/
                        rv = MAC_CONTROL_SET(PORT(unit, port).p_mac,
                                             unit, port,
                                             SOC_MAC_CONTROL_EEE_ENABLE, 0);
                    }

                    /* Notify Int-PHY to bypass LPI for native EEE mode.
                     *
                     * Note :
                     *  1. Not all internal SerDes support the setting to
                     *     enable/disable bypass LPI signal.
                     *  2. Int-PHY to bypass LPI will sync with Ext-PHY's EEE
                     *     enabling status for Native EEE mode.
                     */
                    (void)soc_phyctrl_notify(unit, port,
                                            phyEventLpiBypass, value? 1: 0);
                }

            } else {
                /* If native EEE mode is not supported,
                 * set PHY in AutoGrEEEn mode.
                 */

                /* a. Disable Native EEE mode in PHY if applicable */
                rv = (soc_phyctrl_control_get(unit, port,
                                              BCM_PORT_PHY_CONTROL_EEE,
                                              &phy_val));

                if ((rv != SOC_E_UNAVAIL) && (phy_val != 0)) {
                    rv = soc_phyctrl_control_set (unit, port,
                                                  BCM_PORT_PHY_CONTROL_EEE,
                                                  0);
                }

                /* b. Enable/Disable AutoGrEEEn in PHY.
                 * If PHY does not support AutoGrEEEn mode,
                 * rv will be assigned SOC_E_UNAVAIL.
                 */
                rv = soc_phyctrl_control_set (unit, port,
                                              BCM_PORT_PHY_CONTROL_EEE_AUTO,
                                              value ? 1 : 0);
                if (SOC_SUCCESS(rv)) {
                    eee_cfg[unit][port] = value;
                }
            }
        } else
#endif /* BCM_HURRICANE_SUPPORT || BCM_HAWKEYE_SUPPORT ||
          BCM_TRIDENT_SUPPORT || BCM_SHADOW_SUPPORT */

        {
            /* For legacy devices that don't support native EEE,
             * set PHY in AutoGrEEEn mode.
             */
            uint32 phy_val;

            /* a. Disable Native EEE mode in PHY if applicable */
            rv = (soc_phyctrl_control_get(unit, port,
                                          BCM_PORT_PHY_CONTROL_EEE,
                                          &phy_val));

            if ((rv != SOC_E_UNAVAIL) && (phy_val != 0)) {
                rv = soc_phyctrl_control_set (unit, port,
                                              BCM_PORT_PHY_CONTROL_EEE, 0);
            }

            /* b. Enable/Disable AutoGrEEEn in PHY.
             * If PHY does not support AutoGrEEEn mode,
             * rv will be assigned BCM_E_UNAVAIL.
             */
            rv = soc_phyctrl_control_set (unit, port,
                                          BCM_PORT_PHY_CONTROL_EEE_AUTO,
                                          value ? 1 : 0);
        }

        PORT_UNLOCK(unit);

        break;

    case bcmPortControlEEEStatisticsClear:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }

        PORT_LOCK(unit);

#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_TRIDENT_SUPPORT) || \
    defined(BCM_HAWKEYE_SUPPORT) || defined(BCM_HURRICANE2_SUPPORT)
        if (soc_feature(unit, soc_feature_eee)) {
            uint32 val = 0;
            uint64 val64;
            int mac_val;
            uint32 phy_val;

            COMPILER_64_ZERO(val64);
            if ((MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_EEE_ENABLE, &mac_val)
                 != SOC_E_UNAVAIL) &&
                (soc_phyctrl_control_get(unit, port,
                                         BCM_PORT_PHY_CONTROL_EEE, &phy_val)
                 != SOC_E_UNAVAIL)) {

                if (soc_feature(unit, soc_feature_eee_stat_clear_directly) ||
                    SOC_IS_TD2_TT2(unit)) {
                    rv = _bcm_esw_port_eee_stat_clear(unit, port);

                    PORT_UNLOCK (unit);
                    break;
                }

                /* MAC/Switch is EEE aware (Native EEE mode is supported) */
                if (soc_feature(unit, soc_feature_unified_port)) {
                    if (SOC_REG_IS_VALID(unit,PORT_XGXS_COUNTER_MODEr)) {
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_PORT_XGXS_COUNTER_MODEr(unit, port, &val));
                        soc_reg_field_set(unit, PORT_XGXS_COUNTER_MODEr, &val,
                                          CNT_MODEf, 0);
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (WRITE_PORT_XGXS_COUNTER_MODEr(unit, port, val));
                    }
                } else {
                    if (SOC_REG_IS_VALID(unit,GE0_EEE_CONFIGr)) {
                        /*set counter rollover bit to 0*/
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                            READ_GE0_EEE_CONFIGr(unit, port, &val));
                        soc_reg_field_set(unit, GE0_EEE_CONFIGr, &val,
                            COUNTER_ROLLOVERf, 0);
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE0_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE1_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE2_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE3_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE4_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE5_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE6_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE7_EEE_CONFIGr(unit, port, val));
                    }
                }

                /*Read counters to clear them*/
                if (IS_GE_PORT(unit, port) && !IS_XL_PORT(unit, port) &&
                    (SOC_IS_HURRICANE2(unit) || SOC_IS_HURRICANE3(unit) ||
                     SOC_IS_GREYHOUND(unit))) {
                    _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                        (READ_GRX_EEE_LPI_DURATION_COUNTERr(unit, port, &val));
                    _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                        (READ_GRX_EEE_LPI_EVENT_COUNTERr(unit, port, &val));
                    _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                        (READ_GTX_EEE_LPI_DURATION_COUNTERr(unit, port, &val));
                    _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                        (READ_GTX_EEE_LPI_EVENT_COUNTERr(unit, port, &val));
#ifdef BCM_GREYHOUND2_SUPPORT
                } else if (SOC_IS_GREYHOUND2(unit)) {

                    if (IS_CL_PORT(unit, port)) {
                        /* for port with CLMAC */
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_CLMIB_RX_EEE_LPI_DURATION_COUNTERr(unit, port, &val64));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_CLMIB_RX_EEE_LPI_EVENT_COUNTERr(unit, port, &val64));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_CLMIB_TX_EEE_LPI_DURATION_COUNTERr(unit, port, &val64));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_CLMIB_TX_EEE_LPI_EVENT_COUNTERr(unit, port, &val64));
                    } else if (IS_XL_PORT(unit, port)) {
                        /* for port with XLMAC */
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_XLMIB_RX_EEE_LPI_DURATION_COUNTERr(unit, port, &val64));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_XLMIB_RX_EEE_LPI_EVENT_COUNTERr(unit, port, &val64));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_XLMIB_TX_EEE_LPI_DURATION_COUNTERr(unit, port, &val64));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_XLMIB_TX_EEE_LPI_EVENT_COUNTERr(unit, port, &val64));

                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_XLPMIB_RX_EEE_LPI_DURATION_COUNTERr(unit, port, &val64));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_XLPMIB_RX_EEE_LPI_EVENT_COUNTERr(unit, port, &val64));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_XLPMIB_TX_EEE_LPI_DURATION_COUNTERr(unit, port, &val64));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_XLPMIB_TX_EEE_LPI_EVENT_COUNTERr(unit, port, &val64));
                    } else {
                        /* for port with UniMAC */
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_GRX_EEE_LPI_DURATION_COUNTERr(unit, port, &val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_GRX_EEE_LPI_EVENT_COUNTERr(unit, port, &val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_GTX_EEE_LPI_DURATION_COUNTERr(unit, port, &val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_GTX_EEE_LPI_EVENT_COUNTERr(unit, port, &val));
                    }
#endif
                } else {
                    _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                        (READ_RX_EEE_LPI_DURATION_COUNTERr(unit, port, &val64));
                    _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                        (READ_RX_EEE_LPI_EVENT_COUNTERr(unit, port, &val64));
                    _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                        (READ_TX_EEE_LPI_DURATION_COUNTERr(unit, port, &val64));
                    _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                        (READ_TX_EEE_LPI_EVENT_COUNTERr(unit, port, &val64));
                }

                /*set counter rollover bit to 1*/
                if (soc_feature(unit, soc_feature_unified_port)) {
                    if (SOC_REG_IS_VALID(unit,PORT_XGXS_COUNTER_MODEr)) {
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (READ_PORT_XGXS_COUNTER_MODEr(unit, port, &val));
                        soc_reg_field_set(unit, PORT_XGXS_COUNTER_MODEr, &val,
                                          CNT_MODEf, 1);
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                            (WRITE_PORT_XGXS_COUNTER_MODEr(unit, port, val));
                    }
                } else {
                    if (SOC_REG_IS_VALID(unit,GE0_EEE_CONFIGr)) {
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                            READ_GE0_EEE_CONFIGr(unit, port, &val));
                        soc_reg_field_set(unit, GE0_EEE_CONFIGr, &val,
                            COUNTER_ROLLOVERf, 1);
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE0_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE1_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE2_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE3_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE4_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE5_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE6_EEE_CONFIGr(unit, port, val));
                        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
                                (WRITE_GE7_EEE_CONFIGr(unit, port, val));
                    }
                }
                rv = BCM_E_NONE;
            } else {
                /* native EEE mode is not supported, */
                rv = soc_phyctrl_control_set
                    (unit, port,
                     BCM_PORT_PHY_CONTROL_EEE_STATISTICS_CLEAR, value);
            }
        } else
#endif /* BCM_HURRICANE_SUPPORT || BCM_TRIDENT_SUPPORT
          || BCM_HAWKEYE_SUPPORT*/
        {
            /* On legacy devices that don't support native EEE,
             * get counter value from PHY. If PHY does not support
             * EEE counters, rv will be assigned BCM_E_UNAVAIL.
             */
            rv = soc_phyctrl_control_set
                (unit, port,
                 BCM_PORT_PHY_CONTROL_EEE_STATISTICS_CLEAR, value);
        }
        PORT_UNLOCK (unit);
        break;


 /**********************      EEE Mode Overview    ************************
 *                      |DET|                              |  WT |
 *   Signalling   |idles|   |------------------------------|     | idles   |
 *   from Tx MAC  | or  |   |   Low Power Idle (LPI)       |idles|  or     |
 *   to local PHY |data |   |------------------------------|     | data    |
 *                          *                              *
 *                          *                              *
 *                          *  -------LPI state------------*
 *   Local PHY    |         |  |      |  |       |  |      |   |           |
 *   signaling    |   Active|Ts|  Tq  |Tr|  Tq   |Tr|  Tq  |Tw |Active     |
 *   on MDI       |         |  |      |  |       |  |      |   |           |
 *                          *------------------------------*
 *                          *                              *
 *                          *                               *
 *   Signaling    |   idles |-------------------------------|id| PHY is    |
 *   from LP PHY  |     or  |  Low Power Idle (LPI)         |le| ready     |
 *   to Rx MAC    |   data  |-------------------------------|s | for data  |
 *
 *   where DET = Delay Entry Timer    WT = Tx MAC Wake Timer
 */
    case bcmPortControlEEETransmitIdleTime:
        /* DET = Time (in microsecs) for which condition to move to LPI state
         * is satisfied, at the end of which MAC TX transitions to LPI state */
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }

        PORT_LOCK(unit);
#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_HAWKEYE_SUPPORT)     \
    || defined(BCM_TRIDENT_SUPPORT) || defined(BCM_SHADOW_SUPPORT)     \
    || defined (BCM_HURRICANE2_SUPPORT)
        if (soc_feature (unit, soc_feature_eee)) {
            rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_EEE_TX_IDLE_TIME, value);
        } else
#endif /* BCM_HURRICANE_SUPPORT || BCM_HAWKEYE_SUPPORT ||
          BCM_TRIDENT_SUPPORT || BCM_SHADOW_SUPPORT */
        {
            rv = BCM_E_UNAVAIL;
        }
        PORT_UNLOCK(unit);
        break;

    case bcmPortControlEEETransmitRefreshTime:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }

        PORT_LOCK(unit);
        rv = soc_phyctrl_control_set(unit, port,
                BCM_PORT_PHY_CONTROL_EEE_TRANSMIT_REFRESH_TIME, value);
        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEETransmitSleepTime:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        PORT_LOCK (unit);
        rv = soc_phyctrl_control_set(unit, port,
                BCM_PORT_PHY_CONTROL_EEE_TRANSMIT_SLEEP_TIME, value);
        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEETransmitQuietTime:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_set(unit, port,
                BCM_PORT_PHY_CONTROL_EEE_TRANSMIT_QUIET_TIME, value);
        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEETransmitWakeTime:
        /* Time(in microsecs) to wait before transmitter can leave LPI State*/
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }

        PORT_LOCK (unit);

#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_HAWKEYE_SUPPORT) \
        || defined(BCM_TRIDENT_SUPPORT) || defined(BCM_SHADOW_SUPPORT) \
        || defined(BCM_HURRICANE2_SUPPORT)
            if (soc_feature (unit, soc_feature_eee)) {
                rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                        SOC_MAC_CONTROL_EEE_TX_WAKE_TIME, value);
            }
#endif /* BCM_HURRICANE_SUPPORT || BCM_HAWKEYE_SUPPORT || BCM_TRIDENT_SUPPORT ||
         BCM_SHADOW_SUPPORT */

        PORT_UNLOCK (unit);
        break;

     case bcmPortControlEEEReceiveSleepTime:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        PORT_LOCK (unit);
        rv = soc_phyctrl_control_set(unit, port,
                BCM_PORT_PHY_CONTROL_EEE_RECEIVE_SLEEP_TIME, value);
        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEEReceiveQuietTime:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_set(unit, port,
                BCM_PORT_PHY_CONTROL_EEE_RECEIVE_QUIET_TIME, value);
        PORT_UNLOCK(unit);
        break;

    case bcmPortControlEEEReceiveWakeTime:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);

        rv = soc_phyctrl_control_set (unit, port,
                BCM_PORT_PHY_CONTROL_EEE_RECEIVE_WAKE_TIME, value);
        PORT_UNLOCK(unit);
        break;

    case bcmPortControlEEEEventCountSymmetric:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }
#if defined(BCM_HURRICANE2_SUPPORT)
        if (SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
            SOC_IS_GREYHOUND2(unit)) {
            soc_reg_t   reg;

            if (IS_XL_PORT(unit, port) || IS_CL_PORT(unit, port)) {
                reg = IS_XL_PORT(unit, port) ? XLPORT_EEE_COUNTER_MODEr :
                                               CLPORT_EEE_COUNTER_MODEr;

                if (SOC_REG_FIELD_VALID(unit, reg, MODE_BITf)) {
                    rv = soc_reg_field32_modify(unit, reg, port,
                                                MODE_BITf, (value) ? 1 : 0);
                } else {
                    return BCM_E_INTERNAL;
                }
            } else {
                return BCM_E_PORT;
            }
        } else
#endif
        {
#if defined(BCM_TRIUMPH3_SUPPORT)
            if (SOC_REG_FIELD_VALID(unit, PORT_EEE_COUNTER_MODEr, MODE_BITf)) {
                rv = soc_reg_field32_modify(unit, PORT_EEE_COUNTER_MODEr, port,
                                            MODE_BITf, (value) ? 1 : 0);
            }
#endif
        }
        break;

    case bcmPortControlEEELinkActiveDuration:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }
#if defined(BCM_HURRICANE2_SUPPORT)
        if (SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit) ||
            SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
            soc_reg_t   reg;

            if (IS_XL_PORT(unit, port) || IS_CL_PORT(unit, port)) {
                reg = IS_XL_PORT(unit, port) ? XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr :
                                               CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr;
                if (SOC_REG_FIELD_VALID(unit, reg, ONE_SECOND_TIMERf)) {
                    if (value >= (1 << soc_reg_field_length(unit,
                                                            reg,
                                                            ONE_SECOND_TIMERf))) {
                        return BCM_E_PARAM;
                    }
                    rv = soc_reg_field32_modify(unit,
                                                reg,
                                                port,
                                                ONE_SECOND_TIMERf,
                                                value);
                }
            } else {
                return BCM_E_PORT;
            }
        } else
#endif
        {
#if defined(BCM_TRIUMPH3_SUPPORT)
            {
                soc_reg_t reg;

                reg = IS_C_PORT(unit, port) ?
                    CMAC_EEE_1_SEC_LINK_STATUS_TIMERr :
                    XMAC_EEE_1_SEC_LINK_STATUS_TIMERr;
                if (SOC_REG_FIELD_VALID(unit, reg, ONE_SECOND_TIMERf)) {
                    if (value >= (1 << soc_reg_field_length(unit, reg,
                                                     ONE_SECOND_TIMERf))) {
                        return BCM_E_PARAM;
                    }
                    rv = soc_reg_field32_modify(unit, reg, port,
                                                ONE_SECOND_TIMERf, value);
                }
            }
#endif
        }
        break;

    case bcmPortControlRemoteCpuEnable:
        if (soc_feature(unit, soc_feature_rcpu_1)) {
            bcm_pbmp_t   pbmp;
            uint32       rval;

            rval = 0;
            if (SOC_REG_IS_VALID(unit, CMIC_PKT_PORTSr)) {
                READ_CMIC_PKT_PORTSr(unit, &rval);
                SOC_PBMP_WORD_SET(pbmp, 0, rval);
            } else if (SOC_REG_IS_VALID(unit, CMIC_PKT_PORTS_0r)) {
                READ_CMIC_PKT_PORTS_0r(unit, &rval);
                SOC_PBMP_WORD_SET(pbmp, 0, rval);
            } else if (SOC_REG_IS_VALID(unit, CMIC_RPE_PKT_PORTS_0r)) {
                READ_CMIC_RPE_PKT_PORTS_0r(unit, &rval);
                SOC_PBMP_WORD_SET(pbmp, 0, rval);
            }

            if (SOC_REG_IS_VALID(unit, CMIC_PKT_PORTS_HIr)) {
                READ_CMIC_PKT_PORTS_HIr(unit, &rval);
                SOC_PBMP_WORD_SET(pbmp, 1, rval);
            } else if (SOC_REG_IS_VALID(unit, CMIC_PKT_PORTS_1r)) {
                READ_CMIC_PKT_PORTS_1r(unit, &rval);
                SOC_PBMP_WORD_SET(pbmp, 1, rval);
            } else if (SOC_REG_IS_VALID(unit, CMIC_RPE_PKT_PORTS_1r)) {
                READ_CMIC_RPE_PKT_PORTS_1r(unit, &rval);
                SOC_PBMP_WORD_SET(pbmp, 1, rval);
            }

            if (SOC_REG_IS_VALID(unit, CMIC_PKT_PORTS_HI_2r)) {
                READ_CMIC_PKT_PORTS_HI_2r(unit, &rval);
                SOC_PBMP_WORD_SET(pbmp, 2, rval);
            } else if (SOC_REG_IS_VALID(unit, CMIC_PKT_PORTS_2r)) {
                READ_CMIC_PKT_PORTS_2r(unit, &rval);
                SOC_PBMP_WORD_SET(pbmp, 2, rval);
            } else if (SOC_REG_IS_VALID(unit, CMIC_RPE_PKT_PORTS_2r)) {
                READ_CMIC_RPE_PKT_PORTS_2r(unit, &rval);
                SOC_PBMP_WORD_SET(pbmp, 2, rval);
            }

            if (value) {
                SOC_PBMP_PORT_ADD(pbmp, port);
            } else {
                SOC_PBMP_PORT_REMOVE(pbmp, port);
            }
            rval = 0;

            if (SOC_REG_IS_VALID(unit, CMIC_PKT_PORTSr)) {
                soc_reg_field_set(unit, CMIC_PKT_PORTSr, &rval, PORTSf,
                                 SOC_PBMP_WORD_GET(pbmp, 0));
                (void) WRITE_CMIC_PKT_PORTSr(unit, rval);
            } else if (SOC_REG_IS_VALID(unit, CMIC_PKT_PORTS_0r)) {
                soc_reg_field_set(unit, CMIC_PKT_PORTS_0r, &rval, PORTSf,
                                 SOC_PBMP_WORD_GET(pbmp, 0));
                (void) WRITE_CMIC_PKT_PORTS_0r(unit, rval);
            } else if (SOC_REG_IS_VALID(unit, CMIC_RPE_PKT_PORTS_0r)) {
                soc_reg_field_set(unit, CMIC_RPE_PKT_PORTS_0r, &rval, PORTSf,
                                 SOC_PBMP_WORD_GET(pbmp, 0));
                (void) WRITE_CMIC_RPE_PKT_PORTS_0r(unit, rval);
            }

            if (SOC_REG_IS_VALID(unit, CMIC_PKT_PORTS_HIr)) {
                rval = 0;
                soc_reg_field_set(unit, CMIC_PKT_PORTS_HIr, &rval, PORTS_HIf,
                              SOC_PBMP_WORD_GET(pbmp, 1));
                (void) WRITE_CMIC_PKT_PORTS_HIr(unit, rval);
            } else if (SOC_REG_IS_VALID(unit, CMIC_PKT_PORTS_1r)) {
                rval = 0;
                soc_reg_field_set(unit, CMIC_PKT_PORTS_1r, &rval, PORTS_HIf,
                              SOC_PBMP_WORD_GET(pbmp, 1));
                (void) WRITE_CMIC_PKT_PORTS_1r(unit, rval);
            } else if (SOC_REG_IS_VALID(unit, CMIC_RPE_PKT_PORTS_1r)) {
                rval = 0;
                soc_reg_field_set(unit, CMIC_RPE_PKT_PORTS_1r, &rval, PORTS_HIf,
                              SOC_PBMP_WORD_GET(pbmp, 1));
                (void) WRITE_CMIC_RPE_PKT_PORTS_1r(unit, rval);
            }

            if (SOC_REG_IS_VALID(unit, CMIC_PKT_PORTS_HI_2r)) {
                rval = 0;
                soc_reg_field_set(unit, CMIC_PKT_PORTS_HI_2r, &rval, PORTS_HIf,
                              SOC_PBMP_WORD_GET(pbmp, 2));
                (void) WRITE_CMIC_PKT_PORTS_HI_2r(unit, rval);
            } else if (SOC_REG_IS_VALID(unit, CMIC_PKT_PORTS_2r)) {
                rval = 0;
                soc_reg_field_set(unit, CMIC_PKT_PORTS_2r, &rval, PORTS_HIf,
                              SOC_PBMP_WORD_GET(pbmp, 2));
                (void) WRITE_CMIC_PKT_PORTS_2r(unit, rval);
            } else if (SOC_REG_IS_VALID(unit, CMIC_RPE_PKT_PORTS_2r)) {
                rval = 0;
                soc_reg_field_set(unit, CMIC_RPE_PKT_PORTS_2r, &rval, PORTS_HIf,
                              SOC_PBMP_WORD_GET(pbmp, 2));
                (void) WRITE_CMIC_RPE_PKT_PORTS_2r(unit, rval);
            }

            rv = BCM_E_NONE;
        } else {
            rv = BCM_E_UNAVAIL;
        }
        break;

    case bcmPortControlRemoteCpuTcMapping:
        if (soc_feature(unit, soc_feature_rcpu_tc_mapping)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       REMOTE_CPU_ENf, (value) ? 1 : 0);
            /* If BCM port, then set property in LPORT table too */
            if (BCM_SUCCESS(rv) && !BCM_GPORT_IS_SET(port)) {
                rv = bcm_esw_port_lport_field_set(unit, port,
                                                  LPORT_PROFILE_LPORT_TAB,
                                                  REMOTE_CPU_ENf,
                                                  (value) ? 1 : 0);
            }
        } else {
            rv = BCM_E_UNAVAIL;
        }
        break;

    case bcmPortControlTrill:
#if defined(BCM_TRIDENT_SUPPORT)
        if (soc_feature(unit, soc_feature_trill)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       TRILL_ENABLEf, (value) ? 1 : 0);
            if (BCM_SUCCESS(rv) && !BCM_GPORT_IS_SET(port)) {
                if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, TRILL_ENABLEf)) {
                    rv = soc_mem_field32_modify(unit, EGR_PORTm, port,
                                                TRILL_ENABLEf,
                                                (value) ? 1 : 0);
                }
            }
        }
#endif /* BCM_TRIDENT_SUPPORT */
       break;

    case bcmPortControlTrillAllow:
#if defined(BCM_TRIDENT_SUPPORT)
         if (soc_feature(unit, soc_feature_trill)) {
             rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                        ALLOW_TRILL_FRAMESf,
                                        (value) ? 1 : 0);
             if (BCM_SUCCESS(rv) && !BCM_GPORT_IS_SET(port)) {
                 if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm,
                                         ALLOW_TRILL_FRAMESf)) {
                     rv = soc_mem_field32_modify(unit, EGR_PORTm, port,
                                                 ALLOW_TRILL_FRAMESf,
                                                 (value) ? 1 : 0);
                 }
             }
         }
#endif /* BCM_TRIDENT_SUPPORT */
         break;

    case bcmPortControlNonTrillAllow:
#if defined(BCM_TRIDENT_SUPPORT)
         if (soc_feature(unit, soc_feature_trill)) {
             rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                        ALLOW_NON_TRILL_FRAMESf,
                                        (value) ? 1 : 0);
             if (BCM_SUCCESS(rv) && !BCM_GPORT_IS_SET(port)) {
                 if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm,
                                         ALLOW_NON_TRILL_FRAMESf)) {
                     rv = soc_mem_field32_modify(unit, EGR_PORTm, port,
                                                 ALLOW_NON_TRILL_FRAMESf,
                                                 (value) ? 1 : 0);
                 }
             }
         }
#endif /* BCM_TRIDENT_SUPPORT */
         break;

    case bcmPortControlTrillCoreISISToCPU:
#if defined(BCM_TRIDENT_SUPPORT)
         if (soc_feature(unit, soc_feature_trill)) {
             rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                        COPY_CORE_IS_IS_TO_CPUf,
                                        (value) ? 1 : 0);
         }
#endif /* BCM_TRIDENT_SUPPORT */
         break;

    case bcmPortControlTrillHashSelect:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return BCM_E_UNAVAIL;
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
#if defined(BCM_TRIDENT_SUPPORT)
             if (soc_feature(unit, soc_feature_trill)) {
                   rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                            RTAG7_HASH_CFG_SEL_TRILL_ECMPf, (value) ? 1 : 0);
             }
#endif /* BCM_TRIDENT_SUPPORT */
        }
         break;

    case bcmPortControlNivAccessVirtualInterfaceId:
    case bcmPortControlExtendedPortVid:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_niv) ||
            soc_feature(unit, soc_feature_port_extension)) {
            int mod_port_index;

            if ((value < 0) || (value > 0xfff)) {
                return BCM_E_PARAM;
            }
            BCM_IF_ERROR_RETURN(
                 _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       NIV_VIF_IDf, value));
            BCM_IF_ERROR_RETURN(
                _bcm_esw_src_mod_port_table_index_get_from_port(
                    unit, port, &mod_port_index));
            SOC_IF_ERROR_RETURN(
                soc_mem_field32_modify(unit, EGR_GPP_ATTRIBUTESm, mod_port_index,
                                       SRC_NIV_VIF_IDf, value));

            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
                uint64 val64;

                rv = READ_EGR_PORT_64r(unit, port, &val64);
                if (BCM_SUCCESS(rv)) {
                    soc_reg64_field32_set(unit, EGR_PORT_64r,
                        &val64,
                        NIV_VIF_IDf, value);
                }
                rv = WRITE_EGR_PORT_64r(unit, port, val64);
            } else {
                 rv = _bcm_esw_egr_port_tab_set(unit, port, NIV_VIF_IDf, value);
            }
         }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlNivNonVntagDrop:
    case bcmPortControlNonEtagDrop:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
             soc_feature(unit, soc_feature_port_extension)) {
             rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                     DISCARD_IF_VNTAG_NOT_PRESENTf, (value) ? 1 : 0);
         }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT*/
         break;

    case bcmPortControlNivVntagDrop:
    case bcmPortControlEtagDrop:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
             soc_feature(unit, soc_feature_port_extension)) {
             rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                     DISCARD_IF_VNTAG_PRESENTf, (value) ? 1 : 0);
         }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlSubportPktTagDrop:
#if defined(BCM_KATANA2_SUPPORT)
        if (soc_feature(unit, soc_feature_lltag)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                     DISCARD_IF_LLTAG_PRESENTf, (value) ? 1 : 0);
        }
#endif  /* BCM_KATANA2_SUPPORT */
        break;

    case bcmPortControlNoSubportPktTagDrop:
#if defined(BCM_KATANA2_SUPPORT)
        if (soc_feature(unit, soc_feature_lltag)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                     DISCARD_IF_LLTAG_NOT_PRESENTf, (value) ? 1 : 0);
        }
#endif  /* BCM_KATANA2_SUPPORT */
        break;

    case bcmPortControlNivNonVntagAdd:
    case bcmPortControlNonEtagAdd:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
                 soc_feature(unit, soc_feature_port_extension)) {
             rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                     VNTAG_ACTIONS_IF_NOT_PRESENTf,
                     (value) ?
                     ((type == bcmPortControlNonEtagAdd) ? 2 : VNTAG_ADD) :
                     VNTAG_NOOP);
         }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlNivVntagIngressReplace:
    case bcmPortControlEtagIngressReplace:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
                 soc_feature(unit, soc_feature_port_extension)) {
             rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                     VNTAG_ACTIONS_IF_PRESENTf,
                     (value) ? VNTAG_REPLACE : VNTAG_NOOP);
         }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlNivVntagEgressReplace:
    case bcmPortControlEtagEgressReplace:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
                 soc_feature(unit, soc_feature_port_extension)) {
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
                uint64 val64;

                if (type == bcmPortControlEtagEgressReplace) {
                    return BCM_E_UNAVAIL;
                }

                rv = READ_EGR_PORT_64r(unit, port, &val64);
                if (BCM_SUCCESS(rv)) {
                    soc_reg64_field32_set(unit, EGR_PORT_64r,
                        &val64,
                        VNTAG_ACTIONS_IF_PRESENTf,
                        (value) ? VNTAG_REPLACE : VNTAG_NOOP);
                }
                rv = WRITE_EGR_PORT_64r(unit, port, val64);
            } else {
                 rv = _bcm_esw_egr_port_tab_set(
                          unit, port, VNTAG_ACTIONS_IF_PRESENTf,
                          (value) ? VNTAG_REPLACE : VNTAG_NOOP);
            }
         }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlNivVntagIngressDelete:
    case bcmPortControlEtagIngressDelete:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
                 soc_feature(unit, soc_feature_port_extension)) {
             rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                     VNTAG_ACTIONS_IF_PRESENTf,
                     (value) ? VNTAG_DELETE : VNTAG_NOOP);
         }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlNivVntagEgressDelete:
    case bcmPortControlEtagEgressDelete:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
                 soc_feature(unit, soc_feature_port_extension)) {
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
                uint64 val64;
                rv = READ_EGR_PORT_64r(unit, port, &val64);
                if (BCM_SUCCESS(rv)) {
                    soc_reg64_field32_set(unit, EGR_PORT_64r,
                        &val64,
                        VNTAG_ACTIONS_IF_PRESENTf,
                        (value) ? VNTAG_DELETE : VNTAG_NOOP);
                }
                rv = WRITE_EGR_PORT_64r(unit, port, val64);
            } else {
                rv = _bcm_esw_egr_port_tab_set(
                         unit, port, VNTAG_ACTIONS_IF_PRESENTf,
                         (value) ? VNTAG_DELETE: VNTAG_NOOP);
            }
         }
#endif /* BCM_TRIDENT_SUPPORT  || BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlNivRpfCheck:
    case bcmPortControlExtenderRpfCheck:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
                 soc_feature(unit, soc_feature_port_extension)) {
             rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                     NIV_RPF_CHECK_ENABLEf, (value) ? 1 : 0);
         }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlNivSourceKnockout:
    case bcmPortControlExtenderSourceKnockout:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
                 soc_feature(unit, soc_feature_port_extension)) {
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
                uint64 val64;
                rv = READ_EGR_PORT_64r(unit, port, &val64);
                if (BCM_SUCCESS(rv)) {
                    soc_reg64_field32_set(unit, EGR_PORT_64r,
                        &val64,
                        NIV_PRUNE_ENABLEf,
                        (value) ? 1 : 0);
                }
                rv = WRITE_EGR_PORT_64r(unit, port, val64);
            } else {
                 rv = _bcm_esw_egr_port_tab_set(unit, port, NIV_PRUNE_ENABLEf,
                                                (value) ? 1 : 0);
            }
         }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlNivForwardPort:
    case bcmPortControlExtenderForwardPort:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
             soc_feature(unit, soc_feature_port_extension)) {
             int mod_port_index;
             bcm_module_t mod_out;
             bcm_port_t port_out;
             bcm_trunk_t trunk_out;
             int id_out;
             int tx_dest_port;

             if (value == -1) {
                 BCM_IF_ERROR_RETURN
                     (_bcm_esw_port_tab_set(unit, port,
                                            _BCM_CPU_TABS_ETHER,
                                            NIV_UPLINK_PORTf, 1));
                if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                    SOC_IS_GREYHOUND2(unit)) {
                    uint64 val64;
                    rv = READ_EGR_PORT_64r(unit, port, &val64);
                    if (BCM_SUCCESS(rv)) {
                        soc_reg64_field32_set(unit, EGR_PORT_64r,
                            &val64,
                            NIV_UPLINK_PORTf, 1);
                    }
                    rv = WRITE_EGR_PORT_64r(unit, port, val64);
                } else {
                    BCM_IF_ERROR_RETURN(
                        _bcm_esw_egr_port_tab_set(unit, port,
                                                  NIV_UPLINK_PORTf, 1));
                    BCM_IF_ERROR_RETURN(
                        _bcm_esw_src_mod_port_table_index_get_from_port(
                            unit, port, &mod_port_index));
                    SOC_IF_ERROR_RETURN(
                        soc_mem_field32_modify(unit, EGR_GPP_ATTRIBUTESm,
                                               mod_port_index,
                                               SRC_IS_NIV_UPLINK_PORTf, 1));
                 }
                 rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                            NIV_VIF_LOOKUP_ENABLEf, 1);
             } else {
                BCM_IF_ERROR_RETURN
                    (_bcm_esw_gport_resolve(unit, value, &mod_out, &port_out,
                                             &trunk_out, &id_out));
                if (id_out != -1) {
                    return BCM_E_PARAM;
                }

                if (soc_feature(unit, soc_feature_generic_dest)) {
                    uint32 dval;
                    if (trunk_out != -1) {
                        dval = _soc_mem_dest_value_construct(unit,
                                    SOC_MEM_FIF_DEST_LAG, trunk_out);
                    } else {
                        dval = _soc_mem_dest_value_construct(unit,
                                    SOC_MEM_FIF_DEST_DGPP,
                                    mod_out << SOC_MEM_FIF_DGPP_MOD_ID_SHIFT_BITS | port_out);
                    }
                    BCM_IF_ERROR_RETURN
                        (_bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                               DESTINATIONf, dval));
                } else {
                    if (trunk_out != -1) {
                        tx_dest_port = (1 << SOC_TRUNK_BIT_POS(unit)) + trunk_out;
                    } else {
#if defined(BCM_METROLITE_SUPPORT)
                   /* Metrolite DGLP still uses 7 bits for ports like saber2 */
                      if (SOC_IS_METROLITE(unit)) {
                          tx_dest_port = ((mod_out << 7) | (port_out));
                      } else
#endif
                          tx_dest_port = mod_out * (SOC_PORT_ADDR_MAX(unit) + 1) +
                                    port_out;
                    }

                    BCM_IF_ERROR_RETURN
                        (_bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                               TX_DEST_PORTf, tx_dest_port));
                }
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                           TX_DEST_PORT_ENABLEf, 1);
            }
        }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlNivType:
        if (soc_feature(unit, soc_feature_niv)) {
             if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
#if defined(BCM_GREYHOUND_SUPPORT)
                 rv = bcm_gh_port_niv_type_set(unit, port, value);
#endif /* BCM_GREYHOUND_SUPPORT */
            } else {
#if defined(BCM_TRIDENT_SUPPORT)
                 rv = bcm_td_port_niv_type_set(unit, port, value);
#endif /* BCM_TRIDENT_SUPPORT */
            }
        }
         break;

    case bcmPortControlExtenderType:
        if (soc_feature(unit, soc_feature_port_extension)) {
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
#if defined(BCM_GREYHOUND_SUPPORT)
                 rv = bcm_gh_port_extender_type_set(unit, port, value);
#endif /* BCM_GREYHOUND_SUPPORT */
            } else {
#if defined(BCM_TRIUMPH3_SUPPORT)
                 rv = bcm_tr3_port_extender_type_set(unit, port, value);
#endif /* BCM_TRIUMPH3_SUPPORT */
            }
        }
         break;

    case bcmPortControlNivNameSpace:
    case bcmPortControlExtenderNameSpace:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
                 soc_feature(unit, soc_feature_port_extension)) {
             if ((value < 0) || (value > 0xfff)) {
                 return BCM_E_PARAM;
             }
             rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                     NIV_NAMESPACEf, value);
         }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlEtagPcpDeSelect:
#if defined(INCLUDE_L3)
        if (soc_feature(unit, soc_feature_port_extension)) {
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
#if defined(BCM_GREYHOUND_SUPPORT)
                rv = bcm_gh_port_etag_pcp_de_source_set(unit, port, value);
#endif /* BCM_GREYHOUND_SUPPORT */
            } else {
#if defined(BCM_TRIUMPH3_SUPPORT)
                rv = bcm_tr3_port_etag_pcp_de_source_set(unit, port, value);
#endif /* BCM_TRIUMPH3_SUPPORT */
            }
        }
#endif /* INCLUDE_L3 */
         break;

    case bcmPortControlEtagPcp:
#if defined(BCM_TRIUMPH3_SUPPORT)
         if (soc_feature(unit, soc_feature_port_extension)) {
             if ((value < 0) || (value > 7)) {
                 return BCM_E_PARAM;
             }
             if (SOC_MEM_FIELD_VALID(unit, EGR_ING_PORTm, ETAG_PCPf)) {
                 BCM_IF_ERROR_RETURN(soc_mem_field32_modify(unit,
                                     EGR_ING_PORTm, port,
                                     ETAG_PCPf, value));
             }
             rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                     ETAG_PCPf, value);
         }
#endif /* BCM_TRIUMPH3_SUPPORT */
#if defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_port_extension)) {
            if ((value < 0) || (value > 7)) {
                return BCM_E_PARAM;
            }
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                    ETAG_PCPf, value);
        }
#endif /* BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlEtagDe:
#if defined(BCM_TRIUMPH3_SUPPORT)
         if (soc_feature(unit, soc_feature_port_extension)) {
             if ((value < 0) || (value > 1)) {
                 return BCM_E_PARAM;
             }
             if (SOC_MEM_FIELD_VALID(unit, EGR_ING_PORTm, ETAG_DEf)) {
                 BCM_IF_ERROR_RETURN(soc_mem_field32_modify(unit,
                                     EGR_ING_PORTm, port,
                                     ETAG_DEf, value));
             }
             rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                     ETAG_DEf, value);
         }
#endif /* BCM_TRIUMPH3_SUPPORT */
#if defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_port_extension)) {
            if ((value < 0) || (value > 1)) {
                return BCM_E_PARAM;
            }
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                           ETAG_DEf, value);
         }
#endif /* BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlUseEtagPri:
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_port_extension)) {
            if ((value < 0) || (value > 1)) {
                return BCM_E_PARAM;
            }
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       PHB_FROM_ETAGf, value);
#if defined(BCM_GREYHOUND_SUPPORT)
            if (soc_feature(unit, soc_feature_pktpri_as_dot1p)) {
                if (BCM_FAILURE(rv)) {
                    return rv;
                }
                /*
                 * Make sure TREAT_PKTPRI_AS_DOT1P bit is set for
                 * ETAG internal priority mapping.
                 */
                rv = bcmi_esw_port_treat_pktpri_as_dot1p_ref_cnt_update
                         (unit, (value) ? 1 : -1);
            }
#endif /* BCM_GREYHOUND_SUPPORT */
        }
#endif /* BCM_TRIUMPH3_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlUseSubportPktTagPri:
#if defined(BCM_KATANA2_SUPPORT)
         if (soc_feature(unit, soc_feature_lltag)) {
             rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                     PHB_FROM_LLTAGf, value);
         }
#endif /* BCM_KATANA2_SUPPORT */
         break;

    case bcmPortControlProhibitedDot1p:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                 PROHIBITED_DOT1Pf, value);
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlFabricSourceKnockout:
        if (SOC_MEM_FIELD_VALID(unit, PORT_TABm, REMOVE_HG_HDR_SRC_PORTf) ||
            SOC_IS_TRIDENT3X(unit)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                REMOVE_HG_HDR_SRC_PORTf, (value) ? 1 : 0);

            if (!SOC_IS_TOMAHAWK3(unit)) {
                /* If BCM port, then set property in LPORT table too */
                if (BCM_SUCCESS(rv) && !BCM_GPORT_IS_SET(port)) {
                    rv = bcm_esw_port_lport_field_set(unit, port,
                                                  LPORT_PROFILE_LPORT_TAB,
                                                  ALLOW_SRC_MODf, value);
                }
            }
        }
        break;
    case bcmPortControlRxEnable:
        rv = _bcm_esw_mac_rx_control(unit, port, 0, &value);
        break;
    case bcmPortControlTxEnable:

        if (SOC_REG_IS_VALID(unit, COSMASKr)) {
            /* Use egress scheduling control if available */
            uint32 val;
            if (value > 0) {
                if (!(PORT(unit, port).flags & _PORT_INFO_STOP_TX)) {
                    /* Port tx was never stopped */
                    rv = BCM_E_NONE;
                    break;
                }
                /* Restore values */
                val = PORT(unit, port).cosmask;
                rv =  soc_reg_field32_modify(unit, COSMASKr, port,
                                             COSMASKf, val);
                /* clear flag */
                PORT(unit, port).flags &= ~_PORT_INFO_STOP_TX;
            } else {
                uint32 rval;
                /* Read and save current values */
                SOC_IF_ERROR_RETURN(READ_COSMASKr(unit, port, &rval));
                PORT(unit, port).cosmask = soc_reg_field_get(unit, COSMASKr,
                                                             rval, COSMASKf);
                /* set flag */
                PORT(unit, port).flags |= _PORT_INFO_STOP_TX;
                /* Disable Tx */
                val = (1 << soc_reg_field_length(unit, COSMASKr,
                                                 COSMASKf)) - 1;
                rv =  soc_reg_field32_modify(unit, COSMASKr, port,
                                             COSMASKf, val);
            }
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_HELIX4_SUPPORT)
        } else if  (SOC_IS_HELIX4(unit) || SOC_IS_TRIUMPH3(unit)) {
            rv = BCM_E_NONE;
            if (value > 0 ) {
                if (!(PORT(unit, port).flags & _PORT_INFO_STOP_TX)) {
                    /* Port tx already enabled */
                    break;
                }
                PORT(unit, port).flags &= ~_PORT_INFO_STOP_TX;
                BCM_IF_ERROR_RETURN(_bcm_tr3_port_tx_set(unit, port, 1));
            } else {
                if ((PORT(unit, port).flags & _PORT_INFO_STOP_TX)) {
                    /* Port tx already disabled */
                    break;
                }
                PORT(unit, port).flags |= _PORT_INFO_STOP_TX;
                BCM_IF_ERROR_RETURN(_bcm_tr3_port_tx_set(unit, port, 0));
            }
            break;
#endif
        } else if ((SOC_REG_IS_VALID(unit, EGRMETERINGCONFIGr)) ||
                    (SOC_REG_IS_VALID(unit, EGRMETERINGBUCKETr))) { /* Use egress metering control if available */
                uint32 rval1 = 0, rval2 = 0;
                if (value > 0 ) {
                    if (!(PORT(unit, port).flags & _PORT_INFO_STOP_TX)) {
                        /* Port tx was never stopped */
                        break;
                    }
                /* Restore values */
                BCM_IF_ERROR_RETURN(READ_EGRMETERINGCONFIGr(unit, port,
                                                            &rval1));
                BCM_IF_ERROR_RETURN(READ_EGRMETERINGBUCKETr(unit, port,
                                                            &rval2));
                soc_reg_field_set(unit, EGRMETERINGCONFIGr, &rval1,
                                  REFRESHf, PORT(unit, port).m_info.refresh);
                soc_reg_field_set(unit, EGRMETERINGCONFIGr, &rval1,
                                  THD_SELf, PORT(unit, port).m_info.threshold);
                soc_reg_field_set(unit, EGRMETERINGBUCKETr, &rval2,
                                  BUCKETf, PORT(unit, port).m_info.bucket);
                soc_reg_field_set(unit, EGRMETERINGBUCKETr, &rval2,
                                  IN_PROFILE_FLAGf,
                                  PORT(unit, port).m_info.in_profile);
                BCM_IF_ERROR_RETURN(WRITE_EGRMETERINGCONFIGr(unit, port,
                                                             rval1));
                BCM_IF_ERROR_RETURN(WRITE_EGRMETERINGBUCKETr(unit, port,
                                                             rval2));
                /* clear flag */
                PORT(unit, port).flags &= ~_PORT_INFO_STOP_TX;
                rv = BCM_E_NONE;

            } else {
                /* Read and save current values */
                BCM_IF_ERROR_RETURN(READ_EGRMETERINGCONFIGr(unit, port,
                                                            &rval1));
                PORT(unit, port).m_info.refresh =
                    soc_reg_field_get(unit, EGRMETERINGCONFIGr, rval1,
                                      REFRESHf);
                PORT(unit, port).m_info.threshold =
                    soc_reg_field_get(unit, EGRMETERINGCONFIGr, rval1,
                                      THD_SELf);
                BCM_IF_ERROR_RETURN(READ_EGRMETERINGBUCKETr(unit, port,
                                                            &rval2));
                PORT(unit, port).m_info.bucket =
                    soc_reg_field_get(unit, EGRMETERINGBUCKETr, rval2,
                                      BUCKETf);
                PORT(unit, port).m_info.in_profile =
                    soc_reg_field_get(unit, EGRMETERINGBUCKETr, rval2,
                                      IN_PROFILE_FLAGf);
                /* set flag */
                PORT(unit, port).flags |= _PORT_INFO_STOP_TX;
                /* Disable Tx */
                soc_reg_field_set(unit, EGRMETERINGCONFIGr, &rval1,
                                  REFRESHf, 0);
                soc_reg_field_set(unit, EGRMETERINGCONFIGr, &rval1,
                                  THD_SELf, 1);
                soc_reg_field_set(unit, EGRMETERINGBUCKETr, &rval2,
                                  BUCKETf, 0x100000);
                soc_reg_field_set(unit, EGRMETERINGBUCKETr, &rval2,
                                  IN_PROFILE_FLAGf, 1);
                BCM_IF_ERROR_RETURN(WRITE_EGRMETERINGCONFIGr(unit, port,
                                                             rval1));
                BCM_IF_ERROR_RETURN(WRITE_EGRMETERINGBUCKETr(unit, port,
                                                             rval2));
                rv = BCM_E_NONE;
            }
        } else {
            int (*port_tx_enable_set) (int, soc_port_t, int);
#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)
            if (SOC_IS_TRIDENT2PLUS(unit) || SOC_IS_TRIDENT2(unit)) {
                port_tx_enable_set = soc_td2_port_traffic_egr_enable_set;
            } else
#endif
#if defined(BCM_TRIDENT3_SUPPORT)
            if (SOC_IS_TRIDENT3X(unit)) {
                port_tx_enable_set = soc_td3_port_traffic_egr_enable_set;
            } else
#endif
#if defined(BCM_MONTEREY_SUPPORT)
            if (SOC_IS_MONTEREY(unit)) {
                port_tx_enable_set = soc_monterey_port_traffic_egr_enable_set;
            } else
#endif
#if defined(BCM_APACHE_SUPPORT)
            if (SOC_IS_APACHE(unit)) {
                port_tx_enable_set = soc_apache_port_traffic_egr_enable_set;
            } else
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
            if (SOC_IS_TOMAHAWKX(unit)) {
                port_tx_enable_set = soc_tomahawk_port_traffic_egr_enable_set;
            } else
#endif
            {
                port_tx_enable_set = NULL;
            }
            if (port_tx_enable_set != NULL ) {
                rv = BCM_E_NONE;
                if (value > 0 ) {
                    if (!(PORT(unit, port).flags & _PORT_INFO_STOP_TX)) {
                        /* Port tx was never stopped */
                        break;
                    }
                    PORT(unit, port).flags &= ~_PORT_INFO_STOP_TX;
                    BCM_IF_ERROR_RETURN(((*port_tx_enable_set)(unit, port, 1)));
                } else {
                    if ((PORT(unit, port).flags & _PORT_INFO_STOP_TX)) {
                        /* Port tx alrady enabled */
                        break;
                    }
                    PORT(unit, port).flags |= _PORT_INFO_STOP_TX;
                    BCM_IF_ERROR_RETURN(((*port_tx_enable_set)(unit, port, 0)));
                }
                break;
            } else {
                rv = BCM_E_UNAVAIL;
            }
        }
        break;
    case bcmPortControlMplsEntropyHashSet:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return BCM_E_UNAVAIL;
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            return BCM_E_UNAVAIL;
        } else
#endif /* BCM_KATANA2_SUPPORT */
        {
#if defined(BCM_KATANA_SUPPORT)
            if (soc_feature(unit, soc_feature_mpls)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                           RTAG7_HASH_CFG_SEL_ENTROPY_LABELf,
                                           (value) ? 1 : 0);
            }
#endif /* BCM_KATANA_SUPPORT */
        }
        break;

    case bcmPortControlL2GreEnable:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_l2gre)
#if defined(BCM_TRIDENT3_SUPPORT)
            || soc_feature(unit, soc_feature_flex_flow)
#endif
            ) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       L2GRE_TERMINATION_ALLOWEDf,
                                       (value) ? 1 : 0);
        }
#endif /* BCM_TRIUMPH3_SUPPORT */
       break;

    case bcmPortControlL2GreTunnelbasedVpnId:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_l2gre)
#if defined(BCM_TRIDENT3_SUPPORT)
            || soc_feature(unit, soc_feature_flex_flow)
#endif
            ) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       L2GRE_VPNID_LOOKUP_KEY_TYPEf,
                                       (value) ? 1 : 0);

            if (BCM_SUCCESS(rv) && !BCM_GPORT_IS_SET(port)) {
                if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm,
                                        L2GRE_VFI_LOOKUP_KEY_TYPEf)) {
                    rv = soc_mem_field32_modify(unit, EGR_PORTm, port,
                                                L2GRE_VFI_LOOKUP_KEY_TYPEf,
                                                (value) ? 1 : 0);
                }
            }
        }
#endif /* BCM_TRIUMPH3_SUPPORT */
       break;

    case bcmPortControlL2GreDefaultTunnelEnable:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_l2gre)
#if defined(BCM_TRIDENT3_SUPPORT)
            || soc_feature(unit, soc_feature_flex_flow)
#endif
            ) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       L2GRE_DEFAULT_SVP_ENABLEf,
                                       (value) ? 1 : 0);
        }
#endif /* BCM_TRIUMPH3_SUPPORT */
       break;

    case bcmPortControlVxlanEnable:
#if defined(BCM_TRIDENT2_SUPPORT)
        if ((soc_feature(unit, soc_feature_vxlan)) ||
            (soc_feature(unit, soc_feature_flex_flow))) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       VXLAN_TERMINATION_ALLOWEDf,
                                       (value) ? 1 : 0);
        }
#endif /* BCM_TRIDENT2_SUPPORT */
       break;

    case bcmPortControlVxlanTunnelbasedVnId:
#if defined(BCM_TRIDENT2_SUPPORT)
        if ((soc_feature(unit, soc_feature_vxlan)) ||
            (soc_feature(unit, soc_feature_flex_flow))) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       VXLAN_VN_ID_LOOKUP_KEY_TYPEf,
                                       (value) ? 1 : 0);
            if (BCM_SUCCESS(rv) && !BCM_GPORT_IS_SET(port)) {
                if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm,
                                        VXLAN_VFI_LOOKUP_KEY_TYPEf)) {
                    rv = soc_mem_field32_modify(unit, EGR_PORTm, port,
                                                VXLAN_VFI_LOOKUP_KEY_TYPEf,
                                                (value) ? 1 : 0);
                }
            }
#if defined(BCM_TRIDENT3_SUPPORT) && defined(CANCUN_SUPPORT)
            if (BCM_SUCCESS(rv) && SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_td3_port_cmh_ctrl_set(unit, port, type, value);
            }
#endif
        }
#endif /* BCM_TRIDENT2_SUPPORT */
    break;
    case bcmPortControlVxlanVpnAssignmentCriteria:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (soc_feature(unit, soc_feature_vrf_aware_vxlan_termination)) {
            if ((value < bcmPortVxlanVpnAssignOnVnid)
                || (value > bcmPortVxlanVpnAssignOnVnidOuterVlanSrcIp)) {
                return BCM_E_PARAM;
            }
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       VXLAN_VN_ID_LOOKUP_KEY_TYPEf, value);
        }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
    break;
    case bcmPortControlVxlanTerminationMatchCriteria:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (soc_feature(unit, soc_feature_vrf_aware_vxlan_termination)) {
            if ((value < bcmPortVxlanTerminationMatchDstIp)
                || (value > bcmPortVxlanTerminationMatchOuterVlanDstIp)) {
                return BCM_E_PARAM;
            }
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       VXLAN_TERMINATION_LOOKUP_TYPEf, value);
        }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
    break;
    case bcmPortControlVxlanGportAssignmentCriteria:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (soc_feature(unit, soc_feature_vrf_aware_vxlan_termination)) {
            if ((value < bcmPortVxlanGportAssignOnSrcIp)
                || (value > bcmPortVxlanGportAssignOnOuterVlanSrcIp)) {
                return BCM_E_PARAM;
            }
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       VXLAN_SVP_ASSIGNMENT_KEY_TYPEf, value);
        }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
    break;
    case bcmPortControlVxlanDefaultTunnelEnable:
#if defined(BCM_TRIDENT2_SUPPORT)
        if ((soc_feature(unit, soc_feature_vxlan)) ||
            (soc_feature(unit, soc_feature_flex_flow))) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       VXLAN_DEFAULT_SVP_ENABLEf,
                                       (value) ? 1 : 0);
        }
#endif /* BCM_TRIDENT2_SUPPORT */
    break;

#if defined(BCM_TRIUMPH3_SUPPORT) && defined(INCLUDE_REGEX)
    case bcmPortControlRegex:
        if (!SOC_IS_TRIUMPH3(unit)) {
            return BCM_E_UNAVAIL;
        }
        rv = _bcm_esw_port_regex_control_set(unit, port, 1, 1, !!value);
        break;
    case bcmPortControlRegexTcp:
        if (!SOC_IS_TRIUMPH3(unit)) {
            return BCM_E_UNAVAIL;
        }
        rv = _bcm_esw_port_regex_control_set(unit, port, 0, 1, !!value);
        break;
    case bcmPortControlRegexUdp:
        if (!SOC_IS_TRIUMPH3(unit)) {
            return BCM_E_UNAVAIL;
        }
        rv = _bcm_esw_port_regex_control_set(unit, port, 1, 0, !!value);
        break;
#endif
#ifdef BCM_SHADOW_SUPPORT
    case bcmPortControlManagementPacketIp6Reserved:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        if (value == 0) {
            /* Clear the MGMT Frame classification */
            rv = soc_reg_field32_modify(unit, MGMT_FRAME_ENABLEr, port,
                                        IPV6_RESVf, 0);
        } else {
            rv = soc_reg_field32_modify(unit, MGMT_FRAME_ENABLEr, port,
                                        IPV6_RESVf, 1);
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlManagementPacketIp4Reserved:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        if (value == 0) {
            /* Clear the MGMT Frame classification */
            rv = soc_reg_field32_modify(unit, MGMT_FRAME_ENABLEr, port,
                                        IPV6_RESVf, 0);
        } else {
            rv = soc_reg_field32_modify(unit, MGMT_FRAME_ENABLEr, port,
                                        IPV4_RESVf, 1);
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlManagementPacketLinkConstrained:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        if (value == 0) {
            /* Clear the MGMT Frame classification */
            rv = soc_reg_field32_modify(unit, MGMT_FRAME_ENABLEr, port,
                                        LINK_CONSTf, 0);
        } else {
            rv = soc_reg_field32_modify(unit, MGMT_FRAME_ENABLEr, port,
                                        LINK_CONSTf, 1);
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlManagementPacketGarp:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        if (value == 0) {
            /* Clear the MGMT Frame classification */
            rv = soc_reg_field32_modify(unit, MGMT_FRAME_ENABLEr, port,
                                        DOT1D_GARPf, 0);
        } else {
            rv = soc_reg_field32_modify(unit, MGMT_FRAME_ENABLEr, port,
                                        DOT1D_GARPf, 1);
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlManagementPacketCos:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        if ((value >= 0) && (value <= 7)) {
            /* Clear the MGMT Frame classification */
            rv = soc_reg_field32_modify(unit, COSDP_REMAP_CONTROLr, port,
                                        MGMT_FRAME_COSf, value);
        } else {
            rv = BCM_E_PARAM;
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlManagementPacketColor:
        rv = BCM_E_UNAVAIL;
        break;
    case bcmPortControlTaggedL3PacketPktPri:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        switch ((bcm_port_cos_remap_t)value) {
        case BCM_PORT_COS_REMAP_VLAN_PRI:
            /* Clear the MGMT Frame classification */
            rv = soc_reg_field32_modify(unit, COSDP_REMAP_CONTROLr, port,
                                        SELECT5f, 0);
        break;
        case BCM_PORT_COS_REMAP_DSCP:
            /* Clear the MGMT Frame classification */
            rv = soc_reg_field32_modify(unit, COSDP_REMAP_CONTROLr, port,
                                        SELECT5f, 2);
        break;
        default:
            rv = BCM_E_PARAM;
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlTaggedMPLSPacketPktPri:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        switch ((bcm_port_cos_remap_t)value) {
        case BCM_PORT_COS_REMAP_VLAN_PRI:
            /* Clear the MGMT Frame classification */
            rv = soc_reg_field32_modify(unit, COSDP_REMAP_CONTROLr, port,
                                        SELECT3f, 0);
        break;
        case BCM_PORT_COS_REMAP_EXP:
            /* Clear the MGMT Frame classification */
            rv = soc_reg_field32_modify(unit, COSDP_REMAP_CONTROLr, port,
                                        SELECT3f, 1);
        break;
        default:
            rv = BCM_E_PARAM;
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlTaggedMPLSL3PacketPktPri:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        switch(value) {
        case BCM_PORT_COS_REMAP_VLAN_PRI:
            /* Clear the MGMT Frame classification */
            rv = soc_reg_field32_modify(unit, COSDP_REMAP_CONTROLr, port,
                                        SELECT7f, 0);
        break;
        case BCM_PORT_COS_REMAP_DSCP:
            /* Clear the MGMT Frame classification */
            rv = soc_reg_field32_modify(unit, COSDP_REMAP_CONTROLr, port,
                                        SELECT7f, 2);
        break;
        case BCM_PORT_COS_REMAP_EXP:
            /* Clear the MGMT Frame classification */
            rv = soc_reg_field32_modify(unit, COSDP_REMAP_CONTROLr, port,
                                        SELECT7f, 1);
        break;
        default:
            rv = BCM_E_PARAM;
        }
        PORT_UNLOCK(unit);
        break;

#endif
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    case bcmPortControlFieldEgressClassSelect:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (soc_feature(unit, soc_feature_misc_i2e_hgclass_combo_profile)) {
            rv = _bcm_td2p_port_control_egress_class_select_set(unit, port, value);
        } else
#endif
        {
            rv = _bcm_trx_port_control_egress_class_select_set(unit, port, value);
        }
        break;
#endif
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    case bcmPortControlFieldHiGigClassSelect:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (soc_feature(unit, soc_feature_misc_i2e_hgclass_combo_profile)) {
            rv = _bcm_td2p_port_control_higig_class_select_set(unit, port, value);
        } else
#endif
        {
            rv = _bcm_trx_port_control_higig_class_select_set(unit, port, value);
        }
        break;
#endif
    case bcmPortControlSubportTagEnable:

#if defined (BCM_HGPROXY_COE_SUPPORT)
        if((soc_feature(unit, soc_feature_hgproxy_subtag_coe)) ||
            (soc_feature(unit, soc_feature_channelized_switching))) {
            rv = bcmi_xgs5_port_control_subtag_status_set(unit, port, value);
        }
#endif
#if defined (BCM_KATANA2_SUPPORT)
        if (soc_feature(unit, soc_feature_subtag_coe)) {
            if (SOC_IS_KATANA2(unit)) {
                rv = bcm_kt2_port_control_subtag_status_set(unit, port, value);
            }
#if defined (BCM_METROLITE_SUPPORT)
            /*In Metrolite physical port PP port is [re]used for the subports
             * to achieve the MAX number of streams.*/
            if((soc_feature(unit, soc_feature_discontinuous_pp_port)) && (rv == BCM_E_NONE)){
                BCM_PBMP_CLEAR(pbm);
                BCM_PBMP_PORT_ADD(pbm, port);
                if(value){
                    bcm_esw_vlan_port_remove(unit, BCM_VLAN_DEFAULT, pbm);
                }else{
                    bcm_esw_vlan_port_add(unit, BCM_VLAN_DEFAULT, pbm, pbm);
                }
            }
#endif
        }
#endif
        break;

    case bcmPortControlLinkPhyEnable:
#if defined (BCM_KATANA2_SUPPORT)
        if (soc_feature(unit, soc_feature_linkphy_coe)) {
            if (SOC_IS_KATANA2(unit)) {
                rv = bcm_kt2_port_control_linkphy_status_set(unit, port, value);
            }
#if defined (BCM_METROLITE_SUPPORT)
            /*In Metrolite physical port PP port is [re]used for the subports
             * to achieve the MAX number of streams.*/
            if((soc_feature(unit, soc_feature_discontinuous_pp_port)) && (rv == BCM_E_NONE)){
                BCM_PBMP_CLEAR(pbm);
                BCM_PBMP_PORT_ADD(pbm, port);
                if(value){
                    bcm_esw_vlan_port_remove(unit, BCM_VLAN_DEFAULT, pbm);
                }else{
                    bcm_esw_vlan_port_add(unit, BCM_VLAN_DEFAULT, pbm, pbm);
                }
            }
#endif
        }
#endif
        break;

#if defined(BCM_TRIDENT2_SUPPORT)

    case bcmPortControlFcoeRouteEnable:
        if (soc_feature(unit, soc_feature_fcoe)) {
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           FCOE_ROUTE_ENABLEf,
                                           (value) ? 1 : 0);
                if ((rv == BCM_E_NONE) &&
                    SOC_MEM_IS_VALID(unit, EGR_PORTm) &&
                    SOC_MEM_FIELD_VALID(unit, EGR_PORTm, FCOE_ROUTE_ENABLEf)) {
                    rv = soc_mem_field32_modify(unit, EGR_PORTm, port,
                                                FCOE_ROUTE_ENABLEf,
                                                (value) ? 1 : 0);
                }
            } else
#endif
            {
                if (SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_ROUTE_ENABLEf)) {
                    rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                               FCOE_ROUTE_ENABLEf,
                                               (value) ? 1 : 0);
                }
                if ((rv == BCM_E_NONE) &&
                    SOC_MEM_IS_VALID(unit, EGR_PORTm) &&
                    SOC_MEM_FIELD_VALID(unit, EGR_PORTm, FCOE_ROUTE_ENABLEf)) {
                    rv = soc_mem_field32_modify(unit, EGR_PORTm, port,
                                                FCOE_ROUTE_ENABLEf,
                                                (value) ? 1 : 0);
                }
            }
        }
        break;

    case bcmPortControlFcoeVftEnable:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_IS_TRIDENT3X(unit) || SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_VFT_ENABLEf)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           FCOE_VFT_ENABLEf, (value) ? 1 : 0);
            }
        }
        break;

    case bcmPortControlFcoeZoneCheckEnable:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_IS_TRIDENT3X(unit) || (SOC_MEM_FIELD_VALID(unit, PORT_TABm,
                                    FCOE_ZONE_CHECK_ENABLEf))) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           FCOE_ZONE_CHECK_ENABLEf,
                                           (value) ? 1 : 0);
            }
        }
        break;

    case bcmPortControlFcoeSourceBindCheckEnable:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_MEM_FIELD_VALID(unit, PORT_TABm,
                                    FCOE_SRC_BIND_CHECK_ENABLEf)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           FCOE_SRC_BIND_CHECK_ENABLEf,
                                           (value) ? 1 : 0);
            }
        }
        break;

    case bcmPortControlFcoeFpmaPrefixCheckEnable:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_MEM_FIELD_VALID(unit, PORT_TABm,
                                    FCOE_SRC_FPMA_PREFIX_CHECK_ENABLEf)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           FCOE_SRC_FPMA_PREFIX_CHECK_ENABLEf,
                                           (value) ? 1 : 0);
            }
        }
        break;

    case bcmPortControlFcoeDoNotLearn:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_IS_TRIDENT3X(unit) || (SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_DO_NOT_LEARNf))) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           FCOE_DO_NOT_LEARNf,
                                           (value) ? 1 : 0);
            }
        }
        break;

    case bcmPortControlFcoeNetworkPort:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_IS_TRIDENT3X(unit) || (SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_NETWORK_PORTf))) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           FCOE_NETWORK_PORTf,
                                           (value) ? 1 : 0);
            }
        }
        break;

    case bcmPortControlFcoeFabricSel:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_IS_TRIDENT3X(unit) || SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_FABRIC_SELf)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           FCOE_FABRIC_SELf, value);
            }
        }
        break;

    case bcmPortControlFcoeFabricId:
        if (soc_feature(unit, soc_feature_fcoe)) {
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                    rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                               FCOE_FABRIC_IDf, value);
            } else
#endif
            {
                if (SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_FABRIC_IDf)) {
                    rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                               FCOE_FABRIC_IDf, value);
                }
            }
        }
        break;

    case bcmPortControlFcoeFabricPri:
        if (soc_feature(unit, soc_feature_fcoe)) {
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                    rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                               FCOE_FABRIC_PRIf, value);
            } else
#endif
            {
                if (SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_FABRIC_PRIf)) {
                    rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                               FCOE_FABRIC_PRIf, value);
                }
            }
        }
        break;

    case bcmPortControlFcoeFcCrcAction:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_MEM_FIELD_VALID(unit, EGR_ING_PORTm,
                                    FCOE_FC_CRC_ACTIONf)) {
                /* 2 bits but only 0,1 are valid */
                rv = soc_mem_field32_modify(unit, EGR_ING_PORTm, port,
                                            FCOE_FC_CRC_ACTIONf, value);
            }
        }
        break;

    case bcmPortControlFcoeFcCrcRecompute:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_MEM_IS_VALID(unit, EGR_PORTm) &&
                SOC_MEM_FIELD_VALID(unit, EGR_PORTm,
                                    FCOE_FC_CRC_RECOMPUTEf)) {
                rv = soc_mem_field32_modify(unit, EGR_PORTm, port,
                                            FCOE_FC_CRC_RECOMPUTEf, value);
            }
        }
        break;

    case bcmPortControlFcoeFcEofIgnore:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_MEM_FIELD_VALID(unit, EGR_ING_PORTm,
                                    FCOE_FC_EOF_IGNOREf)) {
                rv = soc_mem_field32_modify(unit, EGR_ING_PORTm, port,
                                            FCOE_FC_EOF_IGNOREf,
                                            (value) ? 1 : 0);
            }
        }
        break;

    case bcmPortControlFcoeTranslateKeyFirst:
    case bcmPortControlFcoeTranslateKeySecond:
        if (soc_feature(unit, soc_feature_fcoe)) {

            /* first, translate value to HW value */
            int key_type = 0;
            int key_type_value;
            int use_port = 0;

            switch (value) {
                case bcmFcoeVsanTranslateKeyPortDouble:
                use_port = 1; /* fall thru */
                case bcmFcoeVsanTranslateKeyDouble:
                    key_type = VLXLT_HASH_KEY_TYPE_IVID_OVID;
                    break;
                case bcmFcoeVsanTranslateKeyPortOuterTag:
                use_port = 1; /* fall thru */
                case bcmFcoeVsanTranslateKeyOuterTag:
                    key_type = VLXLT_HASH_KEY_TYPE_OTAG;
                    break;
                case bcmFcoeVsanTranslateKeyPortInnerTag:
                use_port = 1; /* fall thru */
                case bcmFcoeVsanTranslateKeyInnerTag:
                    key_type = VLXLT_HASH_KEY_TYPE_ITAG;
                    break;
                case bcmFcoeVsanTranslateKeyPortOuter:
                use_port = 1; /* fall thru */
                case bcmFcoeVsanTranslateKeyOuter:
                    key_type = VLXLT_HASH_KEY_TYPE_OVID;
                    break;
                case bcmFcoeVsanTranslateKeyPortInner:
                use_port = 1; /* fall thru */
                case bcmFcoeVsanTranslateKeyInner:
                    key_type = VLXLT_HASH_KEY_TYPE_IVID;
                    break;
                case bcmFcoeVsanTranslateKeyPortOuterPri:
                use_port = 1; /* fall thru */
                case bcmFcoeVsanTranslateKeyOuterPri:
                    key_type = VLXLT_HASH_KEY_TYPE_PRI_CFI;
                    break;
                case bcmFcoeVsanTranslateKeyPortDoubleVsan:
                use_port = 1; /* fall thru */
                case bcmFcoeVsanTranslateKeyDoubleVsan:
                    key_type = VLXLT_HASH_KEY_TYPE_IVID_OVID_VSAN;
                    break;
                case bcmFcoeVsanTranslateKeyPortInnerVsan:
                use_port = 1; /* fall thru */
                case bcmFcoeVsanTranslateKeyInnerVsan:
                    key_type = VLXLT_HASH_KEY_TYPE_IVID_VSAN;
                    break;
                case bcmFcoeVsanTranslateKeyPortOuterVsan:
                use_port = 1; /* fall thru */
                case bcmFcoeVsanTranslateKeyOuterVsan:
                    key_type = VLXLT_HASH_KEY_TYPE_OVID_VSAN;
                    break;
                default:
                    return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN(
                _bcm_esw_vlan_xlate_key_type_value_get(unit, key_type,
                                                       &key_type_value));

            if (type == bcmPortControlFcoeTranslateKeyFirst) {
                if (SOC_IS_TRIDENT3X(unit) || SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_VT_KEY_TYPE_1f)) {
                    rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                               FCOE_VT_KEY_TYPE_1f,
                                               key_type_value);
                }
                if (BCM_SUCCESS(rv)) {
                    rv = _bcm_esw_port_config_set(unit, port,
                                                  _bcmPortVTKeyPortFirst,
                                                  use_port);
                }
            } else {
                if (SOC_IS_TRIDENT3X(unit) || SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_VT_KEY_TYPE_2f)) {
                    rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                               FCOE_VT_KEY_TYPE_2f,
                                               key_type_value);
                }
                if (BCM_SUCCESS(rv)) {
                    rv = _bcm_esw_port_config_set(unit, port,
                                                  _bcmPortVTKeyPortSecond,
                                                  use_port);
                }
            }
        }
        break;

    case bcmPortControlFcoeTranslateKeyFirstEgress:
    case bcmPortControlFcoeTranslateKeySecondEgress:
        if (soc_feature(unit, soc_feature_fcoe)) {

            /* first, translate value to HW value */
            int key_type_value = 0;

            switch (value) {
                case bcmFcoeVsanTranslateKeyEgressDoubleVsan:
                    key_type_value = EGR_VLXLT_HASH_KEY_TYPE_IVID_OVID_VSAN;
                    break;
                case bcmFcoeVsanTranslateKeyEgressVsan:
                    key_type_value = EGR_VLXLT_HASH_KEY_TYPE_VSAN;
                    break;
                case bcmFcoeVsanTranslateKeyEgressInnerVsan:
                    key_type_value = EGR_VLXLT_HASH_KEY_TYPE_IVID_VSAN;
                    break;
                case bcmFcoeVsanTranslateKeyEgressOuterVsan:
                    key_type_value = EGR_VLXLT_HASH_KEY_TYPE_OVID_VSAN;
                    break;
                case bcmFcoeVsanTranslateKeyEgressDouble:
                    key_type_value = EGR_VLXLT_HASH_KEY_TYPE_IVID_OVID;
                    break;
                case bcmFcoeVsanTranslateKeyEgressInner:
                    key_type_value = EGR_VLXLT_HASH_KEY_TYPE_IVID;
                    break;
                case bcmFcoeVsanTranslateKeyEgressOuter:
                    key_type_value = EGR_VLXLT_HASH_KEY_TYPE_OVID;
                    break;
                default:
                    return BCM_E_PARAM;
            }

            if (type == bcmPortControlFcoeTranslateKeyFirstEgress) {
                if (SOC_IS_TRIDENT3X(unit) ||
                    SOC_MEM_FIELD_VALID(unit, EGR_PORTm, FCOE_VT_LOOKUP_1f)) {
                    rv = _bcm_esw_egr_port_tab_set(unit, port,
                                                   FCOE_VT_LOOKUP_1f,
                                                   key_type_value);
                }
            } else {
                if (SOC_IS_TRIDENT3X(unit) ||
                    SOC_MEM_FIELD_VALID(unit, EGR_PORTm, FCOE_VT_LOOKUP_2f)) {
                    rv = _bcm_esw_egr_port_tab_set(unit, port,
                                                   FCOE_VT_LOOKUP_2f,
                                                   key_type_value);
                }
            }
        }
        break;

#endif  /* TRIDENT2 */
    case bcmPortControlEEEMode:
        if (soc_feature(unit, soc_feature_eee_bb_mode)) {
            uint32 rval = 0;
            uint32 fval = 0;
            uint32 temp = 0;
            if (soc_feature (unit, soc_feature_high_portcount_register)) {
                soc_reg_t eee_bb_reg;
                int phy_port;
                int mmu_port;
                int offset;

                phy_port = SOC_INFO(unit).port_l2p_mapping[port];
                mmu_port = SOC_INFO(unit).port_p2m_mapping[phy_port];
                if (mmu_port < 32) {
                    eee_bb_reg = EEE_BB_ENABLE_0r;
                    offset = mmu_port;
                } else if ((mmu_port >=32) && (mmu_port < 64)) {
                    eee_bb_reg = EEE_BB_ENABLE_1r;
                    offset = mmu_port - 32;
                } else { /* mmu_port >= 64 */
                    eee_bb_reg = EEE_BB_ENABLE_2r;
                    offset = mmu_port - 64;
                }
                temp = (1 << offset);
                BCM_IF_ERROR_RETURN(
                    soc_reg32_get(unit, eee_bb_reg, REG_PORT_ANY, 0, &rval));
                fval = soc_reg_field_get(unit, eee_bb_reg, rval,
                                         EEE_BB_ENABLEf);
                if (value == bcmPortEEEBurstAndBatchMode) {
                    fval |= temp;
                } else if (value == bcmPortEEENativeMode) {
                    fval &= ~temp;
                } else {
                    return BCM_E_PARAM;
                }
                rv = soc_reg_field32_modify(unit, eee_bb_reg, REG_PORT_ANY,
                                            EEE_BB_ENABLEf,
                                            fval);
            } else {
                temp = (1 << port);
                temp >>= 2;
                READ_EEE_BB_ENABLEr(unit, &rval);
                fval = soc_reg_field_get(unit, EEE_BB_ENABLEr, rval,
                                         EEE_BB_ENABLEf);
                if (value == bcmPortEEEBurstAndBatchMode) {
                    fval |= temp;
                } else if (value == bcmPortEEENativeMode) {
                    fval &= ~temp;
                } else {
                    return BCM_E_PARAM;
                }
                rv = soc_reg_field32_modify(unit, EEE_BB_ENABLEr, REG_PORT_ANY,
                                            EEE_BB_ENABLEf,
                                            fval);
            }
        }
        break;
#ifdef BCM_GREYHOUND_SUPPORT
    case bcmPortControlWredDropCountUpdateEnableQueueMask:
        if (soc_feature(unit, soc_feature_wred_drop_counter_per_port)) {
#if defined(BCM_GREYHOUND2_SUPPORT)
            if (SOC_IS_GREYHOUND2(unit)) {
                rv = bcmi_gh2_cosq_wred_port_control_set(unit, port, type,
                                                         value);
            } else
#endif /* BCM_GREYHOUND2_SUPPORT */
            {
                rv = soc_reg_field32_modify(unit, WRED_DROP_CTR_CONFIGr,
                                            port, QUEUE_MASKf, value);
            }
        }
        break;
    case bcmPortControlWredDropCountUpdateEnableColorMask:
        if (soc_feature(unit, soc_feature_wred_drop_counter_per_port)) {
            /* parameter checking */
            if (value & ~((0x1 << bcmColorGreen) |
                (0x1 << bcmColorYellow) |
                (0x1 << bcmColorRed))) {
                return BCM_E_PARAM;
            }
#if defined(BCM_GREYHOUND2_SUPPORT)
            if (SOC_IS_GREYHOUND2(unit)) {
                rv = bcmi_gh2_cosq_wred_port_control_set(unit, port, type,
                                                         value);
            } else
#endif /* BCM_GREYHOUND2_SUPPORT */
            {
                cur_val = 0;
                if (value & (0x1 << bcmColorGreen)) {
                    cur_val |= 0x4;
                }
                if (value & (0x1 << bcmColorYellow)) {
                    cur_val |= 0x2;
                }
                if (value & (0x1 << bcmColorRed)) {
                    cur_val |= 0x1;
                }
                rv = soc_reg_field32_modify(unit, WRED_DROP_CTR_CONFIGr,
                                            port, COLOR_MASKf, cur_val);
            }
        }
        break;
#endif /* BCM_GREYHOUND_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    case bcmPortControlProbeSerdesReset:
        if (SOC_IS_TD2_TT2(unit)) {
            PORT_LOCK(unit);
            if (value) {
                PORT(unit, port).flags |= _PORT_INFO_PROBE_RESET_SERDES;
            } else {
                PORT(unit, port).flags &= ~_PORT_INFO_PROBE_RESET_SERDES;
            }
            PORT_UNLOCK(unit);
            rv = BCM_E_NONE;
        }
        break;
#endif /* BCM_TRIDENT2_SUPPORT */
    case bcmPortControlMmuDrain:
        rv = bcm_esw_port_drain_cells(unit, port, value);
        break;
    case bcmPortControlMmuTrafficEnable:
        rv = bcm_esw_port_enqueue_set(unit, port, value);
        break;
    case bcmPortControlRxFastLOS:
        rv = _bcm_esw_link_fast_set(unit, port, value);
        break;
    case bcmPortControlStatCollectionEnable:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        rv = soc_counter_port_collect_enable_set(unit, port, value);
        break;
    case bcmPortControlLLFCReceive:
    case bcmPortControlLLFCTransmit:
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    case bcmPortControlSAFCReceive:
    case bcmPortControlSAFCTransmit:
#endif
        rv = _bcm_esw_port_llfc_set(unit, port, type, value);
        break;
    case bcmPortControlTrunkLoadBalancingRandomizer:
#ifdef BCM_TOMAHAWK_SUPPORT
        if (soc_feature(unit, soc_feature_randomized_load_balance)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       OFFSET_TRUNK_RANDOM_LBf, value);
        }
#endif /* BCM_TOMAHAWK_SUPPORT */
        break;
    case bcmPortControlECMPLevel1LoadBalancingRandomizer:
#ifdef BCM_TOMAHAWK_SUPPORT
        if (soc_feature(unit, soc_feature_ecmp_random)) {
            if ((value < 0) || (value > 15)) {
                return BCM_E_PARAM;
            }
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       OFFSET_ECMP_RANDOM_LBf, value);
        }
#endif /* BCM_TOMAHAWK_SUPPORT */
        break;
    case bcmPortControlECMPLevel2LoadBalancingRandomizer:
#ifdef BCM_TOMAHAWK_SUPPORT
        if (soc_feature(unit, soc_feature_ecmp_random)) {
            if ((value < 0) || (value > 15)) {
                return BCM_E_PARAM;
            }
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       OFFSET_ECMP_LEVEL2_RANDOM_LBf,
                                       value);
        }
#endif /* BCM_TOMAHAWK_SUPPORT */
        break;
    case bcmPortControlMcastGroupRemap:
          if (SOC_MEM_FIELD_VALID(unit, SOURCE_VPm, NETWORK_PORTf)) {
              rv = soc_mem_field32_modify(unit, SOURCE_VPm, port,
                      NETWORK_PORTf, value ? 1 : 0);
          }
          break;
    case bcmPortControlOOBFCTxReportIngEnable:
        if (soc_feature(unit, soc_feature_oob_fc)) {
#ifdef BCM_TOMAHAWK_SUPPORT
            if (SOC_IS_TOMAHAWKX(unit)) {
                rv = _bcm_th_oob_fc_tx_port_control_set(unit, port, value, 0);
            }
#endif
#ifdef BCM_KATANA2_SUPPORT
            if (SOC_IS_KATANA2(unit)) {
                rv = _bcm_kt2_oob_fc_tx_port_control_set(unit, port, value, 0);
            }
#endif
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_td3_oob_fc_tx_port_control_set(unit, port, value, 0);
            }
#endif
#ifdef BCM_APACHE_SUPPORT
            if (SOC_IS_APACHE(unit) && !SOC_IS_MONTEREY(unit)) {
                rv = _bcm_ap_oob_fc_tx_port_control_set(unit, port, value, 0);
            }
#endif
        }
        break;
    case bcmPortControlOOBFCTxReportEgrEnable:
        if (soc_feature(unit, soc_feature_oob_fc)) {
#ifdef BCM_TOMAHAWK_SUPPORT
            if (SOC_IS_TOMAHAWKX(unit)) {
                rv = _bcm_th_oob_fc_tx_port_control_set(unit, port, value, 1);
            }
#endif
#ifdef BCM_APACHE_SUPPORT
            if (SOC_IS_APACHE(unit) && !SOC_IS_MONTEREY(unit)) {
                rv = _bcm_ap_oob_fc_tx_port_control_set(unit, port, value, 1);
            }
#endif
#ifdef BCM_KATANA2_SUPPORT
            if (SOC_IS_KATANA2(unit)) {
                rv = _bcm_kt2_oob_fc_tx_port_control_set(unit, port, value, 1);
            }
#endif
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_th_oob_fc_tx_port_control_set(unit, port, value, 1);
            }
#endif
        }
        break;

	case bcmPortControlSubportTagSize:
#ifdef BCM_HGPROXY_COE_SUPPORT
          if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm,
                                  DESTINATION_SUBPORT_TAG_TYPEf)) {

              int local_port = 0;
              if (BCM_GPORT_IS_SET(port)) {
                  BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, port, &local_port));
              } else {
                  if(!SOC_PORT_VALID(unit, port)) {
                      return BCM_E_PORT;
                  } else {
                      local_port = port;
                  }
              }

              /* Setting of tag_type to 8Byte is not supported currently,
                 hence return error if 'value' is non-zero */
              if(value) {
                  return BCM_E_UNAVAIL;
              }

              rv = soc_mem_field32_modify(unit, EGR_PORTm, local_port,
                      DESTINATION_SUBPORT_TAG_TYPEf, value ? 1 : 0);
          }
          if (SOC_IS_TRIDENT3X(unit)) {
              if (value) {
                  return BCM_E_UNAVAIL;
              }
              else {
                  return BCM_E_NONE;
              }
          }
#endif
		  break;

	case bcmPortControlSystemPortOverride:
#ifdef BCM_HGPROXY_COE_SUPPORT
        if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, VT_SYS_PORT_OVERRIDEf)) {
            rv = bcmi_xgs5_subport_subtag_port_override_set(unit, port, value);
        }
#endif
        break;
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
    case bcmPortControlSampleIngressDest:
        if(soc_feature(unit, soc_feature_sflow_ing_mem)) {
            sflow_ing_data_source_entry_t sflow_entry;
            uint32 field_values[2] = {0, 0};
            if ((value < 0) || (value > 3)) {
                return BCM_E_PARAM;
            }

            if ((value & BCM_PORT_CONTROL_SAMPLE_DEST_CPU) ==
                 BCM_PORT_CONTROL_SAMPLE_DEST_CPU) {
                field_values[0] = 1;
            }
            if ((value & BCM_PORT_CONTROL_SAMPLE_DEST_MIRROR) ==
                 BCM_PORT_CONTROL_SAMPLE_DEST_MIRROR) {
                field_values[1] = 1;
            }

            BCM_IF_ERROR_RETURN
                (READ_SFLOW_ING_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                             &sflow_entry));
            soc_SFLOW_ING_DATA_SOURCEm_field_set(unit, &sflow_entry,
                                                 CPUf, &field_values[0]);
            soc_SFLOW_ING_DATA_SOURCEm_field_set(unit, &sflow_entry,
                                                 MIRRORf, &field_values[1]);
            BCM_IF_ERROR_RETURN
                (WRITE_SFLOW_ING_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                              &sflow_entry));
            rv = BCM_E_NONE;
        }
        break;
    case bcmPortControlSampleFlexDest:
        if(soc_feature(unit, soc_feature_sflow_flex)) {
            sflow_ing_flex_data_source_entry_t sflow_entry;
            uint32 field_values[2] = {0, 0};
            if ((value < 0) || (value > 3)) {
                return BCM_E_PARAM;
            }

            if ((value & BCM_PORT_CONTROL_SAMPLE_DEST_CPU) ==
                 BCM_PORT_CONTROL_SAMPLE_DEST_CPU) {
                field_values[0] = 1;
            }
            if ((value & BCM_PORT_CONTROL_SAMPLE_DEST_MIRROR) ==
                 BCM_PORT_CONTROL_SAMPLE_DEST_MIRROR) {
                field_values[1] = 1;
            }

            BCM_IF_ERROR_RETURN
                (READ_SFLOW_ING_FLEX_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                                  &sflow_entry));
            soc_SFLOW_ING_FLEX_DATA_SOURCEm_field_set(unit, &sflow_entry,
                                                      CPUf, &field_values[0]);
            soc_SFLOW_ING_FLEX_DATA_SOURCEm_field_set(unit, &sflow_entry,
                                                      MIRRORf, &field_values[1]);
            BCM_IF_ERROR_RETURN
                (WRITE_SFLOW_ING_FLEX_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                                   &sflow_entry));
            rv = BCM_E_NONE;
        }
        break;
    case bcmPortControlSampleFlexRate:
        if(soc_feature(unit, soc_feature_sflow_flex)) {
            uint32 values[2] = {0, 0};
            sflow_ing_flex_data_source_entry_t sflow_entry;
            soc_counter_non_dma_t *non_dma = NULL;
            soc_control_t *soc;
            uint32 count = 0, subset_ct = 0;

            if (value < 0) {
                return BCM_E_PARAM;
            }
            /* Set sampling threshold */
            if (value > 0) {
                /* Enable sFlow */
                values[0] = 1;

                /* Set sampling threshold */
                if (value == 1) {
                    /* Needs special handling to avoid register overflow */
                    values[1] = (1 << (SFLOW_RANGE_MAX(unit))) - 1;
                } else {
                    /* Calculate threshold based on sampling rate */
                    values[1] = (1 << (SFLOW_RANGE_MAX(unit))) / value;
                }
            }

            /* Update Flex rate limiting data table. */
            BCM_IF_ERROR_RETURN
                (READ_SFLOW_ING_FLEX_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                                  &sflow_entry));
            soc_SFLOW_ING_FLEX_DATA_SOURCEm_field_set(unit, &sflow_entry,
                                                      ENABLEf, &values[0]);
            soc_SFLOW_ING_FLEX_DATA_SOURCEm_field_set(unit, &sflow_entry,
                                                      THRESHOLDf, &values[1]);
            BCM_IF_ERROR_RETURN
                (WRITE_SFLOW_ING_FLEX_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                                   &sflow_entry));

            /* Enable counter thread for Flex sFlow samplers */
            if (values[0] == 1) {
                soc = SOC_CONTROL(unit);
                non_dma = &soc->counter_non_dma[
                            SOC_COUNTER_NON_DMA_SFLOW_FLEX_PKT -
                            SOC_COUNTER_NON_DMA_START];
                if (!(non_dma->flags & _SOC_COUNTER_NON_DMA_VALID)) {
                    /* Do PACKET_CTRf and BYTE_CTRf sequentially. Hence 2x loop */
                    subset_ct = non_dma->extra_ctr_ct << 1;
                    non_dma->flags |= _SOC_COUNTER_NON_DMA_VALID;
                    non_dma = non_dma->extra_ctrs;

                    do {
                        non_dma->flags |= _SOC_COUNTER_NON_DMA_VALID;
                        /* BYTE_CTRf not currently supported */
                        count += 2;
                        non_dma += 2;
                    } while ((count < subset_ct));
                }
            }
            rv = BCM_E_NONE;
        }
        break;
#endif /* BCM_TOMAHAWK_SUPPORT || BCM_TRIDENT3_SUPPORT */
#ifdef BCM_XGS3_SWITCH_SUPPORT
    case bcmPortControlSampleIngressEnable:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            uint32 regval       = 0;
            uint32 field_enable = 0;
#ifdef BCM_TOMAHAWK_SUPPORT
            sflow_ing_data_source_entry_t sflow_entry;
            soc_counter_non_dma_t *non_dma = NULL;
            soc_control_t *soc;
            uint32 count = 0, subset_ct = 0;
#endif /* BCM_TOMAHAWK_SUPPORT */

            field_enable = value ? 1 : 0;
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
            /* Update Ingress rate limiting data table. */
            if(soc_feature(unit, soc_feature_sflow_ing_mem)) {
                BCM_IF_ERROR_RETURN(
                    READ_SFLOW_ING_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                                &sflow_entry));
                soc_SFLOW_ING_DATA_SOURCEm_field_set(unit, &sflow_entry, ENABLEf,
                                                     &field_enable);

                BCM_IF_ERROR_RETURN(
                    WRITE_SFLOW_ING_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                                 &sflow_entry));

                /* Enable counter thread for Ingress sFlow samplers */
                if (field_enable) {
                    soc = SOC_CONTROL(unit);
                    non_dma = &soc->counter_non_dma[SOC_COUNTER_NON_DMA_SFLOW_ING_PKT -
                                                    SOC_COUNTER_NON_DMA_START];
                    if (!(non_dma->flags & _SOC_COUNTER_NON_DMA_VALID)) {
                        /* Do PACKET_CTRf and BYTE_CTRf sequentially. Hence 2x loop */
                        subset_ct = non_dma->extra_ctr_ct << 1;
                        non_dma->flags |= _SOC_COUNTER_NON_DMA_VALID;
                        non_dma = non_dma->extra_ctrs;

                        do {
                            non_dma->flags |= _SOC_COUNTER_NON_DMA_VALID;
                            /* BYTE_CTRf not currently supported */
                            count += 2;
                            non_dma += 2;
                        } while ((count < subset_ct));
                    }
                }
                rv =  BCM_E_NONE;
            } else
#endif /* BCM_TOMAHAWK_SUPPORT || BCM_TRIDENT3_SUPPORT */
            {
                if (!SOC_REG_IS_VALID(unit, SFLOW_ING_THRESHOLDr)) {
                    return BCM_E_UNAVAIL;
                }
                BCM_IF_ERROR_RETURN(READ_SFLOW_ING_THRESHOLDr(unit, port, &regval));
                soc_reg_field_set(unit, SFLOW_ING_THRESHOLDr, &regval,
                                  ENABLEf, field_enable);

                BCM_IF_ERROR_RETURN(WRITE_SFLOW_ING_THRESHOLDr(unit, port, regval));
                rv = BCM_E_NONE;
            }
        } else {
            rv = BCM_E_UNAVAIL;
        }
        break;
    case bcmPortControlSampleEgressEnable:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            uint32 regval       = 0;
            uint32 field_enable = 0;

            if (!SOC_REG_IS_VALID(unit, SFLOW_EGR_THRESHOLDr)) {
                return BCM_E_UNAVAIL;
            }
            BCM_IF_ERROR_RETURN(READ_SFLOW_EGR_THRESHOLDr(unit, port, &regval));

            field_enable = value ? 1 : 0;
            soc_reg_field_set(unit, SFLOW_EGR_THRESHOLDr, &regval,
                              ENABLEf, field_enable);

            BCM_IF_ERROR_RETURN(WRITE_SFLOW_EGR_THRESHOLDr(unit, port, regval));
            rv = BCM_E_NONE;
        } else {
            rv = BCM_E_UNAVAIL;
        }
        break;
    case bcmPortControlSampleIngressRate:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            uint32 field_value = 0;
            uint32 regval = 0;
#ifdef BCM_TOMAHAWK_SUPPORT
            sflow_ing_data_source_entry_t sflow_entry;
#endif /* BCM_TOMAHAWK_SUPPORT */


                /*           rate         - (IN)Every 1/rate a packet will be sampled
                 *            1 indicating sample all.
                 *            0 indicating sample none.*/
            if (value > 0) {
                /* Set sampling threshold */
                if (value == 1) {
                    /* Needs special handling to avoid register overflow */
                    field_value = (1 << (SFLOW_RANGE_MAX(unit))) - 1;
                } else if (value <= ((1 << (SFLOW_RANGE_MAX(unit))) - 1)) {
                    /* Calculate threshold based on sampling rate */
                    field_value = (1 << (SFLOW_RANGE_MAX(unit))) / value;
                } else {
                    return BCM_E_PARAM;
                }

                /*
                 * For early sFlow implementations the 16-bit threshold value
                 * is compared to bits [23:8] of the sFlow random number.
                 */
                if (soc_feature(unit, soc_feature_sample_offset8)) {
                    field_value >>= 8;
                }

                /* Cut the value in case 16 bit threshold can not accomodate it. */
                if (soc_feature(unit, soc_feature_sample_thresh16)) {
                    if (field_value >= (1 << 16)) {
                        field_value = (1 << 16) - 1;
                    }
                }
            }

#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
            /* Update Ingress rate limiting data table. */
            if(soc_feature(unit, soc_feature_sflow_ing_mem)) {
                BCM_IF_ERROR_RETURN(
                    READ_SFLOW_ING_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                                &sflow_entry));
                soc_SFLOW_ING_DATA_SOURCEm_field_set(unit, &sflow_entry, THRESHOLDf,
                                                     &field_value);

                BCM_IF_ERROR_RETURN(
                    WRITE_SFLOW_ING_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                                 &sflow_entry));

                rv =  BCM_E_NONE;
            } else
#endif /* BCM_TOMAHAWK_SUPPORT || BCM_TRIDENT3_SUPPORT */
            {
                if (!SOC_REG_IS_VALID(unit, SFLOW_ING_THRESHOLDr)) {
                    return BCM_E_UNAVAIL;
                }
                BCM_IF_ERROR_RETURN(READ_SFLOW_ING_THRESHOLDr(unit, port, &regval));
                soc_reg_field_set(unit, SFLOW_ING_THRESHOLDr, &regval,
                                  THRESHOLDf, field_value);

                BCM_IF_ERROR_RETURN(WRITE_SFLOW_ING_THRESHOLDr(unit, port, regval));
                rv = BCM_E_NONE;
            }
        } else {
            rv = BCM_E_UNAVAIL;
        }
        break;
    case bcmPortControlSampleEgressRate:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            uint32 field_value = 0, regval = 0;

                /*           rate         - (IN)Every 1/rate a packet will be sampled
                 *            1 indicating sample all.
                 *            0 indicating sample none.*/
            if (value > 0) {
                /* Set sampling threshold */
                if (value == 1) {
                    /* Needs special handling to avoid register overflow */
                    field_value = (1 << (SFLOW_RANGE_MAX(unit))) - 1;
                } else if (value <= ((1 << (SFLOW_RANGE_MAX(unit))) - 1)) {
                    /* Calculate threshold based on sampling rate */
                    field_value = (1 << (SFLOW_RANGE_MAX(unit))) / value;
                } else {
                    return BCM_E_PARAM;
                }

                /*
                 * For early sFlow implementations the 16-bit threshold value
                 * is compared to bits [23:8] of the sFlow random number.
                 */
                if (soc_feature(unit, soc_feature_sample_offset8)) {
                    field_value >>= 8;
                }

                /* Cut the value in case 16 bit threshold can not accomodate it. */
                if (soc_feature(unit, soc_feature_sample_thresh16)) {
                    if (field_value >= (1 << 16)) {
                        field_value = (1 << 16) - 1;
                    }
                }
            }

            if (!SOC_REG_IS_VALID(unit, SFLOW_EGR_THRESHOLDr)) {
                return BCM_E_UNAVAIL;
            }

            BCM_IF_ERROR_RETURN(READ_SFLOW_EGR_THRESHOLDr(unit, port, &regval));
            soc_reg_field_set(unit, SFLOW_EGR_THRESHOLDr, &regval,
                              THRESHOLDf, field_value);

            BCM_IF_ERROR_RETURN(WRITE_SFLOW_EGR_THRESHOLDr(unit, port, regval));
            rv = BCM_E_NONE;
        } else {
            rv = BCM_E_UNAVAIL;
        }
        break;
#endif
    case bcmPortControlExternalBufferEnable:
#if defined(BCM_KATANA2_SUPPORT)
          if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_ddr3)) {
              rv = _bcm_kt2_cosq_port_ext_buf_set(unit, port, value);
          }
#endif
          break;
#ifdef BCM_HURRICANE3_SUPPORT
    case bcmPortControlTrustMimlPri:
        if (soc_feature(unit, soc_feature_miml)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       USE_MIML_PCP_FOR_PRIf, value ? 1 : 0);
            if (soc_feature(unit, soc_feature_pktpri_as_dot1p)) {
                if (BCM_FAILURE(rv)) {
                    return rv;
                }
                /*
                 * Make sure TREAT_PKTPRI_AS_DOT1P bit is set for
                 * MiML internal priority mapping.
                 */
                rv = bcmi_esw_port_treat_pktpri_as_dot1p_ref_cnt_update
                         (unit, (value) ? 1 : -1);
            }
        }
        break;
    case bcmPortControlTrustCustomHeaderPri:
        if (soc_feature(unit, soc_feature_custom_header)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       USE_CUSTOM_HEADER_FOR_PRIf,
                                       value ? 1 : 0);
        }
        break;
    case bcmPortControlCustomHeaderEncapEnable:
        if (soc_feature(unit, soc_feature_custom_header)) {
            uint64 val64;

            rv = READ_EGR_PORT_64r(unit, port, &val64);
            if (BCM_SUCCESS(rv)) {
                soc_reg64_field32_set(unit, EGR_PORT_64r,
                    &val64,
                    CUSTOM_HEADER_ENABLEf, value ? 1 : 0);
            }

            rv = WRITE_EGR_PORT_64r(unit, port, val64);
        }
        break;
#endif /* BCM_HURRICANE3_SUPPORT */
#if defined(BCM_SABER2_SUPPORT)
    case bcmPortControlSatEnable:
        PORT_LOCK(unit);
        if (SOC_IS_SABER2(unit)) {
            COUNTER_LOCK(unit);
            SOC_L2_DEL_SYNC_LOCK(SOC_CONTROL(unit));
            rv = _bcm_sb2_port_oamp_enable(unit, port, value);
            COUNTER_UNLOCK(unit);
            SOC_L2_DEL_SYNC_UNLOCK(SOC_CONTROL(unit));
        } else {
            rv = BCM_E_UNAVAIL;
        }
        PORT_UNLOCK(unit);
        break;
#endif
    case bcmPortControl1588P2PDelay:
        {
            int p_speed=0;
            rv = bcm_esw_port_speed_get(unit, port, &p_speed);
            if (BCM_FAILURE(rv)) {
                rv = BCM_E_FAIL;
            }
            PORT(unit, port).link_delay_offset = value;
            rv = _bcm_esw_port_link_delay_update(unit, port, p_speed);
        }
        break;
    case bcmPortControlPacketTimeStampInsertRx:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            BCM_IF_ERROR_RETURN(
                _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                      INSERT_RX_TIMESTAMPf, value ? 1 : 0));
            rv = BCM_E_NONE;
        }
        break;
#endif
    case bcmPortControlPacketTimeStampInsertTx:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            SOC_IF_ERROR_RETURN(
                soc_reg_field32_modify(unit, EGR_TS_CONTROLr, port,
                                       INSERT_TX_TIMESTAMPf, value ? 1 : 0));
            rv = BCM_E_NONE;
        }
        break;
#endif
    case bcmPortControlPacketTimeStampSrcPortInsertCancel:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            BCM_IF_ERROR_RETURN(
                _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                      DISABLE_TIMESTAMPINGf, value ? 1 : 0));
            rv = BCM_E_NONE;
        }
        break;
#endif
    case bcmPortControlPacketTimeStampDestPortInsertCancel:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            SOC_IF_ERROR_RETURN(
                soc_reg_field32_modify(unit, EGR_TS_CONTROLr, port,
                                       DISABLE_TIMESTAMPINGf, value ? 1 : 0));
            rv = BCM_E_NONE;
        }
        break;
#endif
    case bcmPortControlPacketTimeStampRxId:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if ((value < 0) || (value >= 0x7FFFFF)) {
                return BCM_E_PARAM;
            }
            if (SOC_REG_IS_VALID(unit,EGR_TS_ING_PORT_MAPr)) {
                SOC_IF_ERROR_RETURN(
                     soc_reg_field32_modify(unit, EGR_TS_ING_PORT_MAPr,
                                       port, TS_RX_ORIGIN_IDf, value));
            } else {
                SOC_IF_ERROR_RETURN(
                soc_mem_field32_modify(unit, EGR_TS_ING_PORT_MAPm,
                                       port, TS_RX_ORIGIN_IDf, value));
            }
            rv = BCM_E_NONE;
        }
#endif
        break;
    case bcmPortControlPacketTimeStampTxId:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if ((value < 0) || (value >= 0x7FFFFF)) {
                return BCM_E_PARAM;
            }
            if (soc_reg_field_valid(unit, EGR_TS_CONTROL_2r, TS_TX_ORIGIN_IDf))
            {
                rv = soc_reg_field32_modify(unit, EGR_TS_CONTROL_2r,
                                            port, TS_TX_ORIGIN_IDf, value);
            } else {
                rv = soc_reg_field32_modify(unit, EGR_TS_CONTROLr,
                                            port, TS_TX_ORIGIN_IDf, value);
            }
        }
#endif
        break;
    case bcmPortControlPacketTimeStampByteMeterAdjust:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp) && !SOC_IS_TOMAHAWK3(unit))
        {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            rv = soc_reg_field32_modify(unit, EGR_TS_CONTROLr, port,
                                        TS_ADJUST_METERSf, (value) ? 1 : 0);
        }
#endif
        break;
    case bcmPortControlE2EFCTransmitEnable:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint64 val;
#if defined(BCM_KATANA2_SUPPORT)
            uint32 val32;
#endif
            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
                val32 = value ? 1: 0;
                rv = WRITE_E2EFC_IBP_ENr(unit, val32);
            } else
#endif
            if (IS_XL_PORT(unit, port)) {
                BCM_IF_ERROR_RETURN(READ_XLMAC_E2E_CTRLr(unit, port, &val));
                soc_reg64_field32_set(unit, XLMAC_E2E_CTRLr,
                                      &val, E2E_ENABLEf, value ? 1 : 0);
                rv = WRITE_XLMAC_E2E_CTRLr(unit, port, val);
            } else if (IS_CL_PORT(unit, port)) {
                BCM_IF_ERROR_RETURN(READ_CLMAC_E2E_CTRLr(unit, port, &val));
                soc_reg64_field32_set(unit, CLMAC_E2E_CTRLr,
                                      &val, E2E_ENABLEf, value ? 1 : 0);
                rv = WRITE_CLMAC_E2E_CTRLr(unit, port, val);
            } else {
                return BCM_E_PARAM;
            }
        }
        break;
    case bcmPortControlE2EFCReceiveEnable:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val;

            BCM_IF_ERROR_RETURN(READ_IE2E_CONTROLr(unit, port, &val));
            soc_reg_field_set(unit, IE2E_CONTROLr,
                              &val, IBP_ENABLEf, value ? 1 : 0);
            rv = WRITE_IE2E_CONTROLr(unit, port, val);
        }
        break;
    case bcmPortControlE2EFCCopyToCpuEnable:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val;

            BCM_IF_ERROR_RETURN(READ_IE2E_CONTROLr(unit, port, &val));
            soc_reg_field_set(unit, IE2E_CONTROLr,
                              &val, IBP_TOCPUf, value ? 1 : 0);
            rv = WRITE_IE2E_CONTROLr(unit, port, val);
        }
        break;
    /* Higher 3 bytes of Destination MAC address */
    case bcmPortControlE2EFCDestMacOui:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val_lo, val_hi;
            uint64 val_64, data_0;
#if defined(BCM_KATANA2_SUPPORT)
            uint32 val;
#endif
            soc_reg_t reg;

            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
#if defined(BCM_SABER2_SUPPORT)
                if (SOC_IS_SABER2(unit)) {
                    /* Do nothing */
                } else
#endif /* BCM_SABER2_SUPPORT */
               {
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D0r, port, 0, &val));
                    val_hi = soc_reg_field_get(unit, XIBP_D0r, val, DATA_BYTES_0_3f);
                    val_hi = (val_hi & 0xff) | ((value & 0xffffff) << 8);
                    soc_reg_field_set(unit, XIBP_D0r, &val, DATA_BYTES_0_3f, val_hi);
                    BCM_IF_ERROR_RETURN(soc_reg32_set(unit, XIBP_D0r, port, 0, val));
                    rv = BCM_E_NONE;
                    break;
               }
           }
#endif /* BCM_KATANA2_SUPPORT */
            if (IS_XL_PORT(unit, port)) {
                reg = XLMAC_E2EFC_DATA_HDR_0r;
            } else if (IS_CL_PORT(unit, port)) {
                reg = CLMAC_E2EFC_DATA_HDR_0r;
            } else {
                return BCM_E_PARAM;
            }
            BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg, port,
                                            0, &val_64));
            data_0 = soc_reg64_field_get(unit, reg,
                                         val_64, E2EFC_DATA_HDR_0f);
            COMPILER_64_TO_32_LO(val_lo, data_0);
            COMPILER_64_TO_32_HI(val_hi, data_0);
            val_hi = (val_hi & 0xff) | ((value & 0xffffff) << 8);
            COMPILER_64_SET(data_0, val_hi, val_lo);
            soc_reg64_field_set(unit, reg, &val_64, E2EFC_DATA_HDR_0f,
                                data_0);
            rv = soc_reg64_set(unit, reg, port, 0, val_64);
        }
        break;
    /* Lower 3 bytes of Destination MAC address */
    case bcmPortControlE2EFCDestMacNonOui:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val_lo, val_hi;
            uint64 val_64, data_0;
            soc_reg_t reg;
#if defined(BCM_KATANA2_SUPPORT)
            uint32 val;
#endif

            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
#if defined(BCM_SABER2_SUPPORT)
                if (SOC_IS_SABER2(unit)) {
                    /* Do nothing */
                } else
#endif /* BCM_SABER2_SUPPORT */
               {
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D1r, port, 0, &val));
                    val_lo = soc_reg_field_get(unit, XIBP_D1r, val, DATA_BYTES_4_7f);
                    val_lo = (val_lo & 0xffff) | ((value & 0xffff) << 16);
                    soc_reg_field_set(unit, XIBP_D1r, &val, DATA_BYTES_4_7f, val_lo);
                    BCM_IF_ERROR_RETURN(soc_reg32_set(unit, XIBP_D1r, port, 0, val));

                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D0r, port, 0, &val));
                    val_hi = soc_reg_field_get(unit, XIBP_D0r, val, DATA_BYTES_0_3f);
                    val_hi = (val_hi & 0xffffff00) | ((value >> 16) & 0xff);
                    soc_reg_field_set(unit, XIBP_D0r, &val, DATA_BYTES_0_3f, val_hi);
                    BCM_IF_ERROR_RETURN(soc_reg32_set(unit, XIBP_D0r, port, 0, val));
                    rv = BCM_E_NONE;
                    break;
               }
           }
#endif /* BCM_KATANA2_SUPPORT */
            if (IS_XL_PORT(unit, port)) {
                reg = XLMAC_E2EFC_DATA_HDR_0r;
            } else if (IS_CL_PORT(unit, port)) {
                reg = CLMAC_E2EFC_DATA_HDR_0r;
            } else {
                return BCM_E_PARAM;
            }
            BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg, port,
                                            0, &val_64));
            data_0 = soc_reg64_field_get(unit, reg,
                                         val_64, E2EFC_DATA_HDR_0f);
            COMPILER_64_TO_32_LO(val_lo, data_0);
            COMPILER_64_TO_32_HI(val_hi, data_0);
            val_hi = (val_hi & 0xffffff00) | ((value >> 16) & 0xff);
            val_lo = (val_lo & 0xffff) | ((value & 0xffff) << 16);
            COMPILER_64_SET(data_0, val_hi, val_lo);
            soc_reg64_field_set(unit, reg, &val_64, E2EFC_DATA_HDR_0f,
                                data_0);
            rv = soc_reg64_set(unit, reg, port, 0, val_64);
        }
        break;
    /* Higher 3 bytes of Source MAC address */
    case bcmPortControlE2EFCSrcMacOui:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val_lo, val_hi;
            uint64 val_64, data_1, data_0;
            soc_reg_t reg_1, reg_0;
#if defined(BCM_KATANA2_SUPPORT)
            uint32 val;
#endif
            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
#if defined(BCM_SABER2_SUPPORT)
                if (SOC_IS_SABER2(unit)) {
                    /* Do nothing */
                } else
#endif /* BCM_SABER2_SUPPORT */
               {
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D1r, port, 0, &val));
                    val_lo = soc_reg_field_get(unit, XIBP_D1r, val, DATA_BYTES_4_7f);
                    val_lo = (val_lo & 0xffff0000) | ((value >> 8) & 0xffff);
                    soc_reg_field_set(unit, XIBP_D1r, &val, DATA_BYTES_4_7f, val_lo);
                    BCM_IF_ERROR_RETURN(soc_reg32_set(unit, XIBP_D1r, port, 0, val));

                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D2r, port, 0, &val));
                    val_hi = soc_reg_field_get(unit, XIBP_D2r, val, DATA_BYTES_8_11f);
                    val_hi = (val_hi & 0xffffff) | ((value & 0xff) << 24);
                    soc_reg_field_set(unit, XIBP_D2r, &val, DATA_BYTES_8_11f, val_hi);
                    BCM_IF_ERROR_RETURN(soc_reg32_set(unit, XIBP_D2r, port, 0, val));
                    rv = BCM_E_NONE;
                    break;
               }
           }
#endif /* BCM_KATANA2_SUPPORT */
            if (IS_XL_PORT(unit, port)) {
                reg_1 = XLMAC_E2EFC_DATA_HDR_1r;
                reg_0 = XLMAC_E2EFC_DATA_HDR_0r;
            } else if (IS_CL_PORT(unit, port)) {
                reg_1 = CLMAC_E2EFC_DATA_HDR_1r;
                reg_0 = CLMAC_E2EFC_DATA_HDR_0r;
            } else {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg_1, port,
                                            0, &val_64));
            data_1 = soc_reg64_field_get(unit, reg_1,
                                         val_64, E2EFC_DATA_HDR_1f);
            COMPILER_64_TO_32_LO(val_lo, data_1);
            COMPILER_64_TO_32_HI(val_hi, data_1);
            val_hi = (val_hi & 0xffffff) | ((value & 0xff) << 24);
            COMPILER_64_SET(data_1, val_hi, val_lo);
            soc_reg64_field_set(unit, reg_1, &val_64, E2EFC_DATA_HDR_1f,
                                data_1);
            BCM_IF_ERROR_RETURN(soc_reg64_set(unit, reg_1,  port, 0, val_64));
            /* SA MAC setting across 2 registers */
            COMPILER_64_ZERO(val_64);
            BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg_0, port,
                                            0, &val_64));
            data_0 = soc_reg64_field_get(unit, reg_0,
                                         val_64, E2EFC_DATA_HDR_0f);
            COMPILER_64_TO_32_LO(val_lo, data_0);
            COMPILER_64_TO_32_HI(val_hi, data_0);
            val_lo = (val_lo & 0xffff0000) | ((value >> 8) & 0xffff);
            COMPILER_64_SET(data_0, val_hi, val_lo);
            soc_reg64_field_set(unit, reg_0, &val_64, E2EFC_DATA_HDR_0f,
                                data_0);
            rv = soc_reg64_set(unit, reg_0, port, 0, val_64);
        }
        break;
    /* Lower 3 bytes of Source MAC address */
    case bcmPortControlE2EFCSrcMacNonOui:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val_lo, val_hi;
            uint64 val_64, data_1;
            soc_reg_t reg;
#if defined(BCM_KATANA2_SUPPORT)
            uint32 val;
#endif
            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
#if defined(BCM_SABER2_SUPPORT)
                if (SOC_IS_SABER2(unit)) {
                    /* Do nothing */
                } else
#endif /* BCM_SABER2_SUPPORT */
               {
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D2r, port, 0, &val));
                    val_hi = soc_reg_field_get(unit, XIBP_D2r, val, DATA_BYTES_8_11f);
                    val_hi = (val_hi & 0xff000000) | (value & 0xffffff);
                    soc_reg_field_set(unit, XIBP_D2r, &val, DATA_BYTES_8_11f, val_hi);
                    BCM_IF_ERROR_RETURN(soc_reg32_set(unit, XIBP_D2r, port, 0, val));
                    rv = BCM_E_NONE;
                    break;
               }
            }
#endif /* BCM_KATANA2_SUPPORT */
            if (IS_XL_PORT(unit, port)) {
                reg = XLMAC_E2EFC_DATA_HDR_1r;
            } else if (IS_CL_PORT(unit, port)) {
                reg = CLMAC_E2EFC_DATA_HDR_1r;
            } else {
                return BCM_E_PARAM;
            }
            BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg, port,
                                            0, &val_64));
            data_1 = soc_reg64_field_get(unit, reg,
                                         val_64, E2EFC_DATA_HDR_1f);
            COMPILER_64_TO_32_LO(val_lo, data_1);
            COMPILER_64_TO_32_HI(val_hi, data_1);
            val_hi = (val_hi & 0xff000000) | (value & 0xffffff);
            COMPILER_64_SET(data_1, val_hi, val_lo);
            soc_reg64_field_set(unit, reg, &val_64, E2EFC_DATA_HDR_1f,
                                data_1);

            rv = soc_reg64_set(unit, reg, port, 0, val_64);
        }
        break;
    case bcmPortControlE2EFCEtherType:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val_lo, val_hi;
            uint64 val_64, data_1;
            soc_reg_t reg;
#if defined(BCM_KATANA2_SUPPORT)
            uint32 val;
#endif
            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
#if defined(BCM_SABER2_SUPPORT)
                if (SOC_IS_SABER2(unit)) {
                    /* Do nothing */
                } else
#endif /* BCM_SABER2_SUPPORT */
               {
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D3r, port, 0, &val));
                    val_lo = soc_reg_field_get(unit, XIBP_D3r, val, D_BYTES_12_15f);
                    val_lo = (val_lo & 0xffff) | ((value & 0xffff) << 16);
                    soc_reg_field_set(unit, XIBP_D3r, &val, D_BYTES_12_15f, val_lo);
                    BCM_IF_ERROR_RETURN(soc_reg32_set(unit, XIBP_D3r, port, 0, val));
                    rv = BCM_E_NONE;
                    break;
               }
            }
#endif /* BCM_KATANA2_SUPPORT */
            if (IS_XL_PORT(unit, port)) {
                reg = XLMAC_E2EFC_DATA_HDR_1r;
            } else if (IS_CL_PORT(unit, port)) {
                reg = CLMAC_E2EFC_DATA_HDR_1r;
            } else {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg, port,
                                            0, &val_64));
            data_1 = soc_reg64_field_get(unit, reg,
                                         val_64, E2EFC_DATA_HDR_1f);
            COMPILER_64_TO_32_LO(val_lo, data_1);
            COMPILER_64_TO_32_HI(val_hi, data_1);
            val_lo = (val_lo & 0xffff) | ((value & 0xffff) << 16);
            COMPILER_64_SET(data_1, val_hi, val_lo);
            soc_reg64_field_set(unit, reg, &val_64, E2EFC_DATA_HDR_1f,
                                data_1);
            rv = soc_reg64_set(unit, reg, port, 0, val_64);
        }
        break;
    case bcmPortControlE2EFCOpcode:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val_lo, val_hi;
            uint64 val_64, data_1;
            soc_reg_t reg;
#if defined(BCM_KATANA2_SUPPORT)
            uint32 val;
#endif

            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
#if defined(BCM_SABER2_SUPPORT)
                if (SOC_IS_SABER2(unit)) {
                    /* Do nothing */
                } else
#endif /* BCM_SABER2_SUPPORT */
               {
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D3r, port, 0, &val));
                    val_lo = soc_reg_field_get(unit, XIBP_D3r, val, D_BYTES_12_15f);
                    val_lo = (val_lo & 0xffff0000) | (value & 0xffff);
                    soc_reg_field_set(unit, XIBP_D3r, &val, D_BYTES_12_15f, val_lo);
                    BCM_IF_ERROR_RETURN(soc_reg32_set(unit, XIBP_D3r, port, 0, val));
                    rv = BCM_E_NONE;
                    break;
               }
            }
#endif /* BCM_KATANA2_SUPPORT */
            if (IS_XL_PORT(unit, port)) {
                reg = XLMAC_E2EFC_DATA_HDR_1r;
            } else if (IS_CL_PORT(unit, port)) {
                reg = CLMAC_E2EFC_DATA_HDR_1r;
            } else {
                return BCM_E_PARAM;
            }
            BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg, port,
                                            0, &val_64));
            data_1 = soc_reg64_field_get(unit, reg,
                                         val_64, E2EFC_DATA_HDR_1f);
            COMPILER_64_TO_32_LO(val_lo, data_1);
            COMPILER_64_TO_32_HI(val_hi, data_1);
            val_lo = (val_lo & 0xffff0000) | (value & 0xffff);
            COMPILER_64_SET(data_1, val_hi, val_lo);
            soc_reg64_field_set(unit, reg, &val_64, E2EFC_DATA_HDR_1f,
                                data_1);
            rv = soc_reg64_set(unit, reg, port, 0, val_64);
        }
        break;
    case bcmPortControlResetSerdes:


#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TOMAHAWKPLUS_SUPPORT)
        if (SOC_IS_TOMAHAWK(unit) || SOC_IS_TOMAHAWKPLUS(unit)) {
            rv = soc_th_reset_serdes(unit, port, value);

        } else
#endif

#if defined(BCM_HURRICANE3_SUPPORT)
        if (SOC_IS_HURRICANE3(unit)) {
            rv = soc_hurricane3_tsc_core_reset(unit, port, value);
        } else
#endif
        {
            rv = BCM_E_UNAVAIL;
        }
        break;
    case bcmPortControlIntEnable:
#if defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_inband_network_telemetry)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_NONE, INT_ENABLEf, value);
        }
#endif
        break;
    case bcmPortControlIntTurnaround:
#if defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_inband_network_telemetry)) {
            SOC_IF_ERROR_RETURN
                (READ_INT_TURNAROUND_EN_BMAPm(unit, MEM_BLOCK_ANY, 0,
                                     &int_turnaround_en_bmap_entry));
            soc_mem_pbmp_field_get(unit, INT_TURNAROUND_EN_BMAPm,
                           &int_turnaround_en_bmap_entry, PORT_BITMAPf, &pbmp);
            if (value)
                SOC_PBMP_PORT_ADD(pbmp, port);
            else
                SOC_PBMP_PORT_REMOVE(pbmp, port);

            soc_mem_pbmp_field_set(unit, INT_TURNAROUND_EN_BMAPm,
                           &int_turnaround_en_bmap_entry, PORT_BITMAPf, &pbmp);
            SOC_IF_ERROR_RETURN
                (WRITE_INT_TURNAROUND_EN_BMAPm(unit, MEM_BLOCK_ANY, 0,
                                      &int_turnaround_en_bmap_entry));
            rv = BCM_E_NONE;
        }
#endif
        break;
    case bcmPortControlObmClassifierPriority:
    case bcmPortControlObmClassifierEnableDscp:
    case bcmPortControlObmClassifierEnableMpls:
    case bcmPortControlObmClassifierEnableEtag:
    case bcmPortControlObmClassifierEtagEthertype:
    case bcmPortControlObmClassifierVntagEthertype:

#if defined(BCM_MONTEREY_SUPPORT)
        if (SOC_IS_MONTEREY(unit)) {
            rv = bcm_mn_obm_classifier_port_control_set(unit, port, type, value);
        } else
#endif
#if defined(BCM_APACHE_SUPPORT)
        if (SOC_IS_APACHE(unit)) {
            rv = bcm_apache_obm_classifier_port_control_set(unit, port, type, value);
        } else
#endif
#if defined(BCM_HELIX5_SUPPORT)
        if (SOC_IS_HELIX5(unit)) {
            rv = bcm_hx5_obm_classifier_port_control_set(unit, port, type, value);
        } else
#endif
#if defined(BCM_TRIDENT3_SUPPORT)
        if (soc_feature(unit, soc_feature_td3_style_obm_classifier_map)) {
            rv = bcm_td3_obm_classifier_port_control_set(unit, port, type, value);
        } else
#endif
        {
            rv = BCM_E_UNAVAIL;
        }
        break;
    case bcmPortControlObmClassifierInternal:
#if defined(BCM_MONTEREY_SUPPORT)
        if (SOC_IS_MONTEREY(unit)) {
            rv = bcm_mn_obm_classifier_port_control_set(unit, port, type, value);
        } else
#endif
        {
            rv = BCM_E_UNAVAIL;
        }
        break;

   case bcmPortControlWirelessCosMapSelect:
#if defined(BCM_HELIX5_SUPPORT)
        if (SOC_IS_HELIX5(unit) || SOC_IS_HURRICANE4(unit)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_ETHER,
                                       WIRED_WIRELESSf, (value) ? 1 : 0);
        } else
#endif
        {
           rv = BCM_E_UNAVAIL;
        }
    break;

   case bcmPortControlHiGigCosSelect:
#if defined(BCM_HURRICANE4_SUPPORT)
        if (SOC_IS_HURRICANE4(unit)) {
            rv = bcm_hr4_hgcos_select_port_control_set(unit, port, type, value);
        } else
#endif
#if defined(BCM_HELIX5_SUPPORT)
        if (SOC_IS_HELIX5(unit)) {
            rv = bcm_hx5_hgcos_select_port_control_set(unit, port, type, value);
        } else
#endif
        {
           rv = BCM_E_UNAVAIL;
        }
    break;
    case bcmPortControlInternalLoopback:
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            rv = bcmi_td3_port_internal_loopback_set(unit,port,value);

        } else
#endif
        {
            rv = BCM_E_UNAVAIL;
        }
        break;
#ifdef BCM_MONTEREY_SUPPORT
    case bcmPortControlObmInterruptTypeDropPreempt :
    case bcmPortControlObmInterruptTypeOverflowPreempt :
    case bcmPortControlObmInterruptTypeDropExpress :
    case  bcmPortControlObmInterruptTypeOverflowExpress :
        if (SOC_IS_MONTEREY(unit)) {
            rv = bcm_mn_obm_interrupt_port_control_set(unit, port, type, value);

        } else
#endif
        {
            rv = BCM_E_UNAVAIL;
        }
        break;
    case bcmPortControlRuntThreshold:
        rv = MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                             SOC_MAC_CONTROL_RX_RUNT_THRESHOLD, value);
        break;
    case bcmPortControlPacketProcssingPort:
#ifdef BCM_TRIDENT3_SUPPORT
        if (soc_feature(unit, soc_feature_pp_port_control)) {
            rv = bcmi_td3_port_pp_num_set(unit, port, value);
        } else
#endif /* BCM_TRIDENT3_SUPPORT */
        {
            rv = BCM_E_UNAVAIL;
        }
        break;
    default:
        break;
    }
    return rv;
}


/*
 * Function:
 *      bcm_esw_port_control_get
 * Description:
 *      Get the status of specified port feature.
 * Parameters:
 *      unit - Device number
 *      port - Port number
 *      type - Enum  value of the feature
 *      value - (OUT) Current value of the port feature
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_UNAVAIL - Functionality not available
 */
int
bcm_esw_port_control_get(int unit, bcm_port_t port,
                         bcm_port_control_t type, int *value)
{
    int rv = BCM_E_UNAVAIL;
    int valid = 0;
#if defined(BCM_SHADOW_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
    uint32 val = 0;
#endif /* BCM_SHADOW_SUPPORT || BCM_GREYHOUND_SUPPORT */
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
    int chk_gx_port = (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
                       SOC_IS_VALKYRIE2(unit) || SOC_IS_SCORPION(unit));
#endif
#if defined(BCM_TRIUMPH3_SUPPORT) && defined(INCLUDE_REGEX)
    int udp;
    int tcp;
    int enable;
#endif
    source_vp_entry_t svp_entry;
#if defined(BCM_TOMAHAWK3_SUPPORT)
int_turnaround_en_bmap_entry_t int_turnaround_en_bmap_entry;
bcm_pbmp_t  pbmp;
#endif
    if (value == NULL) {
        return BCM_E_PARAM;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if(bcm_common_oamp_port_enable_get(unit, port) &&
            (type != bcmPortControlSatEnable)) {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META("Error: Not permitted on OAMP port %d.n"),
                   port));
        return BCM_E_PARAM;
    }

    /* Call Port Control module */
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        /*
         * Check that port control feature is valid in Port Control.
         * If valid, call Port Control routine to handle feature; otherwise
         * continue with rest of logic.
         */
        BCM_IF_ERROR_RETURN
            (bcmi_esw_portctrl_control_validate(unit, type, &valid));
        if (valid) {
            return bcmi_esw_portctrl_control_get(unit, port, type, value);
        }
    }

#if defined(BCM_SHADOW_SUPPORT)
    if (SOC_IS_SHADOW(unit)) {
        /*  If unsupported port control type, return unavail */
        if (!_bcm_port_type_shadow_support (unit, port, type)) {
            return BCM_E_UNAVAIL;
        }
    }
#endif /* BCM_SHADOW_SUPPORT */

    if (type == bcmPortControlEsmEligibility) {
#ifdef BCM_TRIUMPH3_SUPPORT
        /* For bcmPortControlEsmEligibility, a non-local port
         * is accepted. For other port controls, a non-local
         * port is not accepted. Hence, bcmPortControlEsmEligibility
         * is implemented here, before the _bcm_esw_port_gport_validate
         * procedure below.
         */
        return bcm_tr3_port_esm_eligible_get(unit, port, value);
#endif /* BCM_TRIUMPH3_SUPPORT */
    }

#if defined(BCM_TRIDENT_SUPPORT) && defined(INCLUDE_L3)
    if (
#ifdef BCM_HGPROXY_COE_SUPPORT
        ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
            soc_feature(unit, soc_feature_channelized_switching)) &&
         _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port) &&
         ((type == bcmPortControlVlanVpGroupIngress) ||
          (type == bcmPortControlVlanVpGroupEgress))) ||
#endif
        BCM_GPORT_IS_TRUNK(port) ||
        BCM_GPORT_IS_VLAN_PORT(port) ||
        BCM_GPORT_IS_NIV_PORT(port) ||
        BCM_GPORT_IS_VXLAN_PORT(port) ||
        BCM_GPORT_IS_MIM_PORT(port) ||
        BCM_GPORT_IS_MPLS_PORT(port) ||
        BCM_GPORT_IS_L2GRE_PORT(port) ||
        BCM_GPORT_IS_FLOW_PORT(port) ||
        BCM_GPORT_IS_EXTENDER_PORT(port)) {
        return bcm_td_vp_control_get(unit, port, type, value);
    } else
#endif /* BCM_TRIDENT_SUPPORT && INCLUDE_L3 */
#if defined(BCM_KATANA2_SUPPORT)
    if (((BCM_GPORT_IS_MIM_PORT(port)) ||
         (BCM_GPORT_IS_MPLS_PORT(port))) && SOC_IS_KATANA2(unit)) {
        rv = BCM_E_NONE;
    } else
#endif /* BCM_KATANA2_SUPPORT */
    if ((BCM_GPORT_IS_LOCAL_CPU_IEEE(port)) ||
        (BCM_GPORT_IS_LOCAL_CPU_HIGIG(port))) {
        rv = BCM_E_NONE;
    } else
#ifdef BCM_HGPROXY_COE_SUPPORT
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        soc_feature(unit, soc_feature_channelized_switching)) &&
        _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
        rv = BCM_E_NONE;
    } else
#endif
#ifdef BCM_TRIDENT3_SUPPORT
    if (soc_feature(unit, soc_feature_pp_port_control) &&
        (type == bcmPortControlPacketProcssingPort) ) {
        rv = BCM_E_NONE;
    } else
#endif
    {
        rv = bcm_esw_port_control_validate(unit, port, type, &port);
    }
    BCM_IF_ERROR_RETURN(rv);
    rv = BCM_E_UNAVAIL;

    /*
     * At this point, 'port' can be:
     *    GPORT WLAN
     *    GPORT PROXY
     *    BCM valid local port
     *
     * Some switch cases only handles 'port' in BCM port format
     * (non-gport).  Corresponding checks must be added in those
     * cases to ensure that 'port' is not a gport.
     */
    switch (type) {
    case bcmPortControlBridge:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            rv = _bcm_esw_port_tab_get(unit, port, PORT_BRIDGEf, value);
        }
        break;
    case bcmPortControlTrunkHashSet:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return BCM_E_UNAVAIL;
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
#if defined(BCM_BRADLEY_SUPPORT)
            if (SOC_IS_HBX(unit) || SOC_IS_TRX(unit)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           RTAG7_HASH_CFG_SEL_TRUNKf, value);
            }
#endif /* BCM_BRADLEY_SUPPORT */
        }
        break;
    case bcmPortControlFabricTrunkHashSet:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return BCM_E_UNAVAIL;
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
#if defined(BCM_BRADLEY_SUPPORT)
            if (SOC_IS_HBX(unit) || SOC_IS_TRX(unit)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           RTAG7_HASH_CFG_SEL_HIGIG_TRUNKf,
                                           value);
            }
#endif /* BCM_BRADLEY_SUPPORT */
        }
        break;
    case bcmPortControlECMPHashSet:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return BCM_E_UNAVAIL;
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
#if defined(BCM_BRADLEY_SUPPORT)
            if (SOC_IS_HBX(unit) || SOC_IS_TRX(unit)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           RTAG7_HASH_CFG_SEL_ECMPf, value);
            }
#endif /* BCM_BRADLEY_SUPPORT */
        }
        break;
    case bcmPortControlLoadBalanceHashSet:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            return BCM_E_UNAVAIL;
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
        {
#if defined(BCM_BRADLEY_SUPPORT)
            if (SOC_IS_HBX(unit) || SOC_IS_TRX(unit)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           RTAG7_HASH_CFG_SEL_LBIDf, value);
            }
#endif /* BCM_BRADLEY_SUPPORT */
        }
        break;
    case bcmPortControlLoadBalancingNumber:
#if defined(BCM_BRADLEY_SUPPORT)
        if (SOC_IS_HBX(unit) || SOC_IS_TRX(unit)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       RTAG7_PORT_LBNf, value);
        }
#endif /* BCM_BRADLEY_SUPPORT */
        break;
    case bcmPortControlErrorSymbolDetect:
#if defined(BCM_GREYHOUND_SUPPORT)
        if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
            SOC_IS_GREYHOUND2(unit)) {
            rv = BCM_E_UNAVAIL;
        } else
#endif /* BCM_GREYHOUND_SUPPORT */
        {
#ifdef BCM_XGS3_SWITCH_SUPPORT
            if (SOC_IS_XGS3_SWITCH(unit)) {
                 rv = _bcm_esw_port_err_sym_detect_get(unit, port, value);
            }
#endif
        }
        break;
    case bcmPortControlErrorSymbolCount:
#if defined(BCM_GREYHOUND_SUPPORT)
        if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
            SOC_IS_GREYHOUND2(unit)) {
            rv = BCM_E_UNAVAIL;
        } else
#endif /* BCM_GREYHOUND_SUPPORT */
        {
#ifdef BCM_XGS3_SWITCH_SUPPORT
            if (SOC_IS_XGS3_SWITCH(unit)) {
                rv = _bcm_esw_port_err_sym_count_get(unit, port, value);
            }
#endif
        }
        break;
    case bcmPortControlIP4:
        if (SOC_IS_XGS3_SWITCH(unit)) {
#if defined(BCM_TRX_SUPPORT)
            if (BCM_GPORT_LOCAL_CPU_HIGIG == port) {
                rv = _bcm_esw_iport_tab_get(unit, CMIC_PORT(unit), V4L3_ENABLEf, value);
            } else
#endif
            {
                rv = _bcm_esw_port_tab_get(unit, port, V4L3_ENABLEf, value);
            }
        }
        break;
    case bcmPortControlIP6:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            rv = _bcm_esw_port_tab_get(unit, port, V6L3_ENABLEf, value);
        }
        break;
    case bcmPortControlIP4Mcast:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            rv = _bcm_esw_port_tab_get(unit, port, V4IPMC_ENABLEf, value);
        }
        break;
    case bcmPortControlIP6Mcast:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            rv = _bcm_esw_port_tab_get(unit, port, V6IPMC_ENABLEf, value);
        }
        break;
    case bcmPortControlIPMC4Ucast:
        if (soc_feature(unit, soc_feature_ipmc_unicast)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                    IPMCV4_UNICAST_MACDA_ENABLEf, value);
        }
        break;
    case bcmPortControlIPMC6Ucast:
        if (soc_feature(unit, soc_feature_ipmc_unicast)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                    IPMCV6_UNICAST_MACDA_ENABLEf, value);
        }
        break;
    case bcmPortControlIP4McastL2:
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_XGS3_SWITCH(unit)) {
            if (SOC_IS_TD2_TT2(unit) &&
                    soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm,
                                                         IPMCV4_L2_ENABLEf)) {
                rv = _bcm_trx_source_trunk_map_get(unit, port,
                                     IPMCV4_L2_ENABLEf, (uint32 *)value);
            } else {
                rv = _bcm_esw_port_tab_get(unit, port, V4IPMC_L2_ENABLEf, value);
            }
        }
#endif /* BCM_TRX_SUPPORT */
        break;
    case bcmPortControlIP6McastL2:
#ifdef BCM_TRX_SUPPORT
        if (SOC_IS_XGS3_SWITCH(unit)) {
            if (SOC_IS_TD2_TT2(unit) &&
                    soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm,
                                                         IPMCV6_L2_ENABLEf)) {
                rv = _bcm_trx_source_trunk_map_get(unit, port,
                                    IPMCV6_L2_ENABLEf, (uint32 *)value);
            } else {
                rv = _bcm_esw_port_tab_get(unit, port, V6IPMC_L2_ENABLEf, value);
            }
        }
#endif
        break;

    case bcmPortControlMpls:
#if defined(BCM_TRIUMPH_SUPPORT)
        if (SOC_IS_XGS3_SWITCH(unit)) {
            rv = _bcm_esw_port_tab_get(unit, port, MPLS_ENABLEf, value);
        }
#endif
        break;

    case bcmPortControlMacInMac:
#if defined(BCM_TRIUMPH2_SUPPORT)
        if (SOC_IS_XGS3_SWITCH(unit) && soc_feature(unit, soc_feature_mim)) {
            rv = _bcm_esw_port_tab_get(unit, port, MIM_TERM_ENABLEf, value);
        }
#endif
        break;

    case bcmPortControlMimUcastTermEnable:
#if defined(BCM_TRIUMPH2_SUPPORT)
        if (SOC_IS_XGS3_SWITCH(unit) && soc_feature(unit, soc_feature_mim)) {
            rv = _bcm_esw_port_tab_get(unit, port, MIM_TERM_ENABLEf, value);
        }
#endif
        break;

    case bcmPortControlMimMcastTermEnable:
#if defined(BCM_TRIUMPH2_SUPPORT)
        if (SOC_IS_XGS3_SWITCH(unit) && soc_feature(unit, soc_feature_mim)) {
            rv = _bcm_esw_port_tab_get(unit, port, MIM_MC_TERM_ENABLEf, value);
        }
#endif
        break;

    case bcmPortControlSrcBmacMissToCpu:
#ifdef BCM_TRIUMPH2_SUPPORT
     if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
         SOC_IS_VALKYRIE2(unit) || SOC_IS_ENDURO(unit) ||
         SOC_IS_TD_TT(unit) || SOC_IS_TRIUMPH3(unit) || SOC_IS_KATANA(unit)) {
         /* 0x2: ToCPU 0x1: Drop(default) */
         rv = _bcm_esw_port_tab_get(unit, port, CML_BMAC_NEWf, value);
         *value = (*value == 0x2) ? TRUE : FALSE;
     }
#endif /* BCM_TRIUMPH2_SUPPORT */
         break;

    case bcmPortControlQosRemarkResolution:
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            rv = _bcm_esw_egr_port_tab_get(unit, port, QOS_CTRL_IDf, value);
            /* TD3 only supports 2 of the 4 valid hardware configurations for now.
             * 1: Serial resolution.
             * 3: Layered resolution.
             * Other value: Invalid.
             */
            if (rv == BCM_E_NONE) {
                if (*value == 1) {
                    *value = BCM_PORT_QOS_SERIAL_RESOLUTION;
                } else if (*value == 3) {
                    *value = BCM_PORT_QOS_LAYERED_RESOLUTION;
                } else {
                    return BCM_E_PARAM;
                }
            }
        }
#endif /* BCM_TRIDENT3_SUPPORT */
         break;

    case bcmPortControlFabricQueue:
#if defined(BCM_TRIUMPH2_SUPPORT)
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
        if (IS_ST_PORT(unit, port)) {
            if  (SOC_REG_FIELD_VALID(unit, EGR_PORT_64r, EH_EXT_HDR_ENABLEf)) {
                uint64 egr_val64;
                rv = READ_EGR_PORT_64r(unit, port, &egr_val64);
                if (BCM_SUCCESS(rv)) {
                    *value = soc_reg64_field32_get(unit, EGR_PORT_64r,
                                              egr_val64, EH_EXT_HDR_ENABLEf);
                }
            }
            else if(SOC_MEM_FIELD_VALID(unit, EGR_PORTm, EH_EXT_HDR_ENABLEf)){
                egr_port_entry_t entry;
                rv = soc_mem_read(unit, EGR_PORTm, MEM_BLOCK_ANY, port,
                            &entry);
                 if (BCM_SUCCESS(rv)) {
                    *value = soc_mem_field32_get(unit, EGR_PORTm, &entry,
                                            EH_EXT_HDR_ENABLEf);
                }
            }
        } else {
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
            /* Allow CPU port on TD2+ to add extended header */
            if (SOC_IS_TRIDENT2PLUS(unit) && IS_CPU_PORT(unit, port)) {
                egr_port_entry_t entry;
                rv = soc_mem_read(unit, EGR_PORTm, MEM_BLOCK_ANY, port,
                            &entry);
                 if (BCM_SUCCESS(rv)) {
                    *value = soc_mem_field32_get(unit, EGR_PORTm, &entry,
                                            EH_EXT_HDR_ENABLEf);
                }
            }
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
            if (SOC_IS_TOMAHAWKX(unit) && IS_CPU_PORT(unit, port)) {
                egr_port_entry_t entry;
                rv = soc_mem_read(unit, EGR_PORTm, MEM_BLOCK_ANY, port, &entry);
                if (BCM_SUCCESS(rv)) {
                    *value = soc_mem_field32_get(unit, EGR_PORTm, &entry,
                                            EH_EXT_HDR_ENABLEf);
                }
            }
#endif
        }
#if defined(BCM_TRIDENT3_SUPPORT)
        if (SOC_IS_TRIDENT3X(unit) &&
            soc_feature(unit, soc_feature_egr_lport_tab_profile)) {
            uint32 enable = 0;
            rv = bcm_esw_port_egr_lport_field_get(
                  unit, port, EGR_LPORT_PROFILEm, EH_EXT_HDR_ENABLEf,
                  &enable);
            BCM_IF_ERROR_RETURN(rv);
            *value = (enable) ? 1: 0;
        }
#endif
#endif
        break;
    case bcmPortControlPassControlFrames:
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
#ifdef BCM_XGS_SWITCH_SUPPORT
        if (IS_XE_PORT(unit, port) || IS_CE_PORT(unit, port) ||
            (IS_GE_PORT(unit, port)
             && soc_feature(unit, soc_feature_unified_port)) ||
            (SOC_IS_KATANAX(unit) && IS_MXQ_PORT(unit, port))) {
            if(soc_feature(unit, soc_feature_pgw_mac_control_frame)) {
                uint32 rval32 = 0;
                rv = READ_PGW_MAC_RSV_MASKr(unit, port, &rval32);
                if (BCM_SUCCESS(rv)) {
                    /* PGW_MAC_RSV_MASK: Bit 11 Control Frame recieved
                     * the bit value needs to be reversed
                     */
                    *value = ((rval32 & 0x800) >> 11) ? 0 : 1 ;
                }
            } else {
                rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                     SOC_MAC_PASS_CONTROL_FRAME, value);
            }
        }
#endif
        break;
#ifdef BCM_XGS3_SWITCH_SUPPORT
    case bcmPortControlFilterLookup:
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_get(unit, port, VFP_ENABLEf, value);
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case bcmPortControlFilterIngress:
#if defined(BCM_TRX_SUPPORT)
        if (BCM_GPORT_LOCAL_CPU_HIGIG == port) {
            rv = _bcm_esw_iport_tab_get(unit, CMIC_PORT(unit), FILTER_ENABLEf, value);
        } else
#endif
        if (BCM_GPORT_LOCAL_CPU_IEEE == port) {
            rv = _bcm_esw_port_tab_get(unit, CMIC_PORT(unit), FILTER_ENABLEf, value);
        } else {
            rv = _bcm_esw_port_tab_get(unit, port, FILTER_ENABLEf, value);
        }
        break;
    case bcmPortControlFilterEgress:
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
        if (SOC_REG_FIELD_VALID(unit, EGR_PORTr, EFP_FILTER_ENABLEf)) {
            uint32 egr_val;

            rv = READ_EGR_PORTr(unit, port, &egr_val);
            if (BCM_SUCCESS(rv)) {
                *value = soc_reg_field_get(unit, EGR_PORTr, egr_val,
                                           EFP_FILTER_ENABLEf);
            }
        } else if (SOC_REG_FIELD_VALID(unit, EGR_PORT_64r,
                                       EFP_FILTER_ENABLEf)) {
            uint64 egr_val64;

            rv = READ_EGR_PORT_64r(unit, port, &egr_val64);
            if (BCM_SUCCESS(rv)) {
                *value = soc_reg64_field32_get(unit, EGR_PORT_64r,
                                               egr_val64,
                                               EFP_FILTER_ENABLEf);
            }
        } else {
            rv = _bcm_esw_egr_port_tab_get(unit, port, EFP_FILTER_ENABLEf, value);

        }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case bcmPortControlFrameSpacingStretch:
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
        rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                             SOC_MAC_CONTROL_FRAME_SPACING_STRETCH, value);
        break;
    case bcmPortControlPreservePacketPriority:
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            /* Triumph3 has unity mapping to ING_OUTER_DOT1P_MAPPING_TABLE */
            rv = _bcm_esw_port_tab_get(unit, port,
                                       DOT1P_REMAP_POINTERf, value);
            if (BCM_SUCCESS(rv)) {
               /* True if pointed to default dot1p profile */
               *value = (*value) ? 0 : 1;
            }
        } else {
            rv = _bcm_esw_port_tab_get(unit, port, USE_INCOMING_DOT1Pf, value);
        }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case bcmPortControlLearnClassEnable:
#if defined(BCM_TRX_SUPPORT)
        if (soc_feature(unit, soc_feature_class_based_learning)) {
            rv = _bcm_esw_port_tab_get(unit, port, CLASS_BASED_SM_ENABLEf,
                                       value);
        }
#endif /* BCM_TRX_SUPPORT */
        break;
    case bcmPortControlTrustIncomingVlan:
#if defined(BCM_TRIDENT3_SUPPORT)
        if (SOC_IS_TRIDENT3X(unit)) {
            uint32 tpid_enable;
            rv = _bcm_fb2_port_tpid_enable_get(unit, port, &tpid_enable);
            *value = tpid_enable ? 1 : 0;
        } else
#endif
#if defined(BCM_RAVEN_SUPPORT) || defined(BCM_TRX_SUPPORT)
        {
            rv = _bcm_esw_port_tab_get(unit, port, TRUST_INCOMING_VIDf, value);
        }
#endif /* BCM_RAVEN_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case bcmPortControlDoNotCheckVlan:
#if defined(BCM_TRX_SUPPORT)
        if (!SOC_IS_SHADOW(unit)) {
#if defined(BCM_TRIDENT3_SUPPORT)
            if (SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           DISABLE_VLAN_CHECKSf, value);
            } else
#endif
            if (soc_mem_field_valid(unit, PORT_TABm, DISABLE_VLAN_CHECKSf)) {
                if (CMIC_PORT(unit) == port) {
                    rv = _bcm_esw_iport_tab_get(unit, port,
                                                DISABLE_VLAN_CHECKSf, value);
                } else {
                    rv = _bcm_esw_port_tab_get(unit, port,
                                               DISABLE_VLAN_CHECKSf, value);
                }
            } else if (soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm,
                        DISABLE_VLAN_CHECKSf)) {
#if defined(BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit)) {
                    rv = _bcm_kt2_source_trunk_map_get(unit, port,
                            DISABLE_VLAN_CHECKSf, (uint32 *)value);
                } else
#endif
                {
                    rv = _bcm_trx_source_trunk_map_get(unit, port,
                            DISABLE_VLAN_CHECKSf, (uint32 *)value);
                }
            }
        }
#endif /* BCM_TRX_SUPPORT */
          break;
    case bcmPortControlDoNotCheckVlanFromCpu:
#if defined(BCM_TRX_SUPPORT)
        if (!SOC_IS_SHADOW(unit)) {
            if (CMIC_PORT(unit) == port) {
                if (soc_mem_field_valid(unit, PORT_TABm, DISABLE_VLAN_CHECKSf) ||
                    SOC_IS_TRIDENT3X(unit)) {
                    rv = _bcm_esw_port_tab_get(unit, port,
                                           DISABLE_VLAN_CHECKSf, value);
                } else if (soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm,
                        DISABLE_VLAN_CHECKSf)) {
                    rv = _bcm_trx_source_trunk_map_get(unit, port,
                        DISABLE_VLAN_CHECKSf, (uint32 *)value);
                }
            } else {
                rv = BCM_E_PORT;
            }
        }
#endif /* BCM_TRX_SUPPORT */
         break;
    case bcmPortControlIEEE8021ASEnableIngress:
#if defined(BCM_HAWKEYE_SUPPORT) || defined(BCM_ENDURO_SUPPORT)
        if (soc_feature(unit, soc_feature_rx_timestamp)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       IEEE_802_1AS_ENABLEf, value);
        }
#endif /* BCM_HAWKEYE_SUPPORT */
        break;
    case bcmPortControlIEEE8021ASEnableEgress:
#if defined(BCM_HAWKEYE_SUPPORT)
        if (SOC_IS_HAWKEYE(unit)) {
            uint32 egr_val;

            rv = READ_EGR_PORTr(unit, port, &egr_val);
            if (BCM_SUCCESS(rv)) {
                *value = soc_reg_field_get(unit, EGR_PORTr, egr_val,
                                           IEEE_802_1AS_ENABLEf);
            }
        }
#endif /* BCM_HAWKEYE_SUPPORT */
        break;
    case bcmPortControlEgressVlanPriUsesPktPri:
#if defined(BCM_TRX_SUPPORT)
#if defined (BCM_HGPROXY_COE_SUPPORT)
        if (!((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
            (soc_feature(unit, soc_feature_channelized_switching))) &&
            BCM_GPORT_IS_SUBPORT_PORT(port)))
#endif
        {
            BCM_IF_ERROR_RETURN(
                _bcm_esw_port_gport_validate(unit, port, &port));
        }
        if (SOC_IS_TRX(unit) && !SOC_IS_SHADOW(unit)) {
            uint32 val;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (soc_feature(unit, soc_feature_egr_vlan_control_is_memory)) {
                if (soc_feature(unit, soc_feature_egr_all_profile)) {
                    rv = bcm_esw_port_egr_lport_field_get(unit,
                        port, EGR_VLAN_CONTROL_1m, REMARK_OUTER_DOT1Pf,
                        (uint32 *)value);
                    *value = *value ? 0 : 1;
                } else {
#if defined (BCM_HGPROXY_COE_SUPPORT)
                    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
                        (soc_feature(unit, soc_feature_channelized_switching))) &&
                        BCM_GPORT_IS_SUBPORT_PORT(port)) {
                        rv = bcm_esw_port_egr_lport_field_get(
                                unit, port, EGR_VLAN_CONTROL_1m,
                                REMARK_OUTER_DOT1Pf, (uint32 *)value);
                        *value = *value ? 0 : 1;
                    } else
#endif
                    {
                        egr_vlan_control_1_entry_t entry;
                        rv = READ_EGR_VLAN_CONTROL_1m(
                                unit, MEM_BLOCK_ANY, port, &entry);
                        if (BCM_SUCCESS(rv)) {
                            *value = soc_EGR_VLAN_CONTROL_1m_field32_get(
                                        unit, &entry,
                                        REMARK_OUTER_DOT1Pf) ? 0 : 1;
                        }
                    }
                }
            } else
#endif
            {
                rv = READ_EGR_VLAN_CONTROL_1r(unit, port, &val);
                if (BCM_SUCCESS(rv)) {
                    *value = (soc_reg_field_get(unit, EGR_VLAN_CONTROL_1r, val,
                                                REMARK_OUTER_DOT1Pf)) ? 0 : 1;
                }
            }
        }
#endif /* BCM_TRX_SUPPORT */
        break;
    case bcmPortControlEgressModifyDscp:
#if defined(BCM_TRX_SUPPORT)
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
        if (SOC_IS_TRX(unit) && !SOC_IS_SHADOW(unit)) {
            uint32 val;
#ifdef BCM_TRIDENT2PLUS_SUPPORT
            if (soc_feature(unit, soc_feature_egr_vlan_control_is_memory)) {
                if (soc_feature(unit, soc_feature_egr_all_profile)) {
                    rv = bcm_esw_port_egr_lport_field_get(unit,
                        port, EGR_VLAN_CONTROL_1m, REMARK_OUTER_DSCPf,
                        (uint32 *)value);
                    *value = *value ? 1 : 0;
                } else {
                    egr_vlan_control_1_entry_t entry;
                    rv = READ_EGR_VLAN_CONTROL_1m(unit, MEM_BLOCK_ANY, port, &entry);
                    if (BCM_SUCCESS(rv)) {
                        *value = soc_EGR_VLAN_CONTROL_1m_field32_get(unit, &entry,
                                                REMARK_OUTER_DSCPf) ? 1 : 0;
                    }
                }
            } else
#endif
            {
                rv = READ_EGR_VLAN_CONTROL_1r(unit, port, &val);
                if (BCM_SUCCESS(rv)) {
                    *value = (soc_reg_field_get(unit, EGR_VLAN_CONTROL_1r, val,
                                                REMARK_OUTER_DSCPf)) ? 1 : 0;
                }
            }
        }
#endif /* BCM_TRX_SUPPORT */
        break;
    case bcmPortControlIpfixRate:
#ifdef BCM_TRIUMPH2_SUPPORT
        if (soc_feature(unit, soc_feature_ipfix_rate)) {
            rv = _bcm_esw_port_tab_get(unit, port, IPFIX_FLOW_METER_IDf,
                                       value);
        }
#endif /* BCM_TRIUMPH2_SUPPORT */
        break;
    case bcmPortControlCustomerQueuing:
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
#ifdef BCM_ENDURO_SUPPORT
        if (SOC_IS_ENDURO(unit) && !IS_HG_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }
#endif
#ifdef BCM_KATANA_SUPPORT
        if (SOC_IS_KATANAX(unit)) {
            uint32 rval, ing_cos_mode, rqe_cos_mode;
            BCM_IF_ERROR_RETURN(READ_ING_COS_MODEr(unit, port, &rval));
            ing_cos_mode = soc_reg_field_get(unit, ING_COS_MODEr, rval, COS_MODEf);
            if (SOC_IS_KATANA(unit)) {
                SOC_IF_ERROR_RETURN(READ_RQE_PORT_CONFIGr(unit, port, &rval));
                rqe_cos_mode = soc_reg_field_get(unit, RQE_PORT_CONFIGr, rval, COS_MODEf);
            } else {
                SOC_IF_ERROR_RETURN(READ_RQE_PP_PORT_CONFIGr(unit, port, &rval));
                rqe_cos_mode = soc_reg_field_get(unit, RQE_PP_PORT_CONFIGr, rval, COS_MODEf);
            }
            if ((ing_cos_mode != rqe_cos_mode) && (ing_cos_mode != 1)) {
                *value = 4;
            } else {
                *value = ing_cos_mode;
            }
            rv = BCM_E_NONE;
            break;
        }
#endif /* BCM_KATANA_SUPPORT */
#if defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
        if ((SOC_IS_TRIDENT3X(unit)) || (SOC_IS_TOMAHAWKX(unit))) {
            uint64 rval1;
            if (SOC_REG_IS_VALID(unit, ING_COS_MODEr)) {
                rv = soc_reg_get(unit, ING_COS_MODEr, port, 0, &rval1);
                BCM_IF_ERROR_RETURN(rv);
                *value = soc_reg64_field32_get(unit, ING_COS_MODEr, rval1,
                                               COS_MODEf);
            }

            if (SOC_MEM_IS_VALID(unit, ING_COS_MODEm)) {
               ing_cos_mode_entry_t entry;
               rv = soc_mem_read(unit, ING_COS_MODEm, MEM_BLOCK_ANY, port, &entry);
               BCM_IF_ERROR_RETURN(rv);
               *value = soc_mem_field32_get(unit, ING_COS_MODEm, &entry, COS_MODEf);
            }

            break;
        }
#endif /* BCM_TRIDENT3_SUPPORT || BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
        if (SOC_IS_TD2_TT2(unit)) {
            uint64 rval;
            rv = READ_ING_COS_MODE_64r(unit, port, &rval);
            BCM_IF_ERROR_RETURN(rv);

            if (SOC_REG_FIELD_VALID(unit, ING_COS_MODE_64r, QUEUE_MODEf)) {
                *value = soc_reg64_field32_get(unit, ING_COS_MODE_64r, rval,
                                               QUEUE_MODEf);
                break;
            }
        }
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIUMPH2_SUPPORT
        if (soc_feature(unit, soc_feature_vlan_queue_map)) {
            uint32 rval;
            soc_field_t field;
            if (SOC_REG_IS_VALID(unit, ING_COS_MODEr)) {
                rv = READ_ING_COS_MODEr(unit, port, &rval);
                if (SOC_REG_FIELD_VALID(unit, ING_COS_MODEr, SELECTf)) {
                    field = SELECTf;
                } else if (SOC_REG_FIELD_VALID(unit, ING_COS_MODEr,
                                               QUEUE_MODEf)) {
                    field = QUEUE_MODEf;
                } else {
                    rv = BCM_E_UNAVAIL;
                    break;
                }
                if (SOC_IS_TRIUMPH3(unit)) {
                    *value = soc_reg_field_get(unit, ING_COS_MODEr, rval, field);
                } else {
                    if (soc_reg_field_get(unit, ING_COS_MODEr, rval, field)
                        == 3) {
                        *value = 1;
                    } else {
                        *value = 0;
                    }
                }
            }
        }
#endif /* BCM_TRIUMPH2_SUPPORT */
        break;
#endif /* BCM_XGS3_SWITCH_SUPPORT */

#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_APOLLO_SUPPORT)
    case bcmPortControlOAMEnable:
        rv = _bcm_esw_port_tab_get(unit, port, OAM_ENABLEf, value);
        break;
#endif /* defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_APOLLO_SUPPORT) */

#if defined (BCM_OLP_SUPPORT)
    case bcmPortControlOlpEnable:
        if (soc_feature(unit, soc_feature_olp)) {
            bcm_module_t module_id = 0;
            bcm_module_t my_modid;
            bcm_port_t port_id;
            bcm_trunk_t trunk_id = BCM_TRUNK_INVALID;
            int         local_id;

            BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, &my_modid));

            if (BCM_GPORT_IS_SET(port)) {
                SOC_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port, &module_id,
                            &port_id, &trunk_id, &local_id));

#if defined(BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit) &&
                        (BCM_GPORT_IS_SUBPORT_PORT(port)) &&
                        ((_BCM_KT2_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) ||
                         (_BCM_KT2_GPORT_IS_LINKPHY_SUBPORT_PORT(unit, port)))) {

                    LOG_ERROR(BSL_LS_BCM_L2,
                            (BSL_META_U(unit,
                                        "OLP is not allowed on SUBPORT. \
                                        \n")));
                    return BCM_E_PARAM;
                }
#endif
            } else {
                port_id = port;
            }
            if ((module_id == 0) || (module_id == my_modid)) {
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
                if(SOC_IS_TRIDENT2PLUS(unit) || SOC_IS_APACHE(unit)) {
                    iarb_ing_port_table_entry_t entry;

                    SOC_IF_ERROR_RETURN(soc_mem_read(unit, IARB_ING_PORT_TABLEm,
                                        MEM_BLOCK_ANY, port_id, &entry));
                    *value = soc_IARB_ING_PORT_TABLEm_field32_get(unit,
                                                            &entry, OLP_ENABLEf);

                } else
#endif
                {
                    iarb_ing_physical_port_entry_t entry;
                    SOC_IF_ERROR_RETURN(soc_mem_read(unit, IARB_ING_PHYSICAL_PORTm,
                                         MEM_BLOCK_ANY, port_id, &entry));
                    *value = soc_IARB_ING_PHYSICAL_PORTm_field32_get(unit,
                                                        &entry, OLP_ENABLEf);
                }
            }
            rv = BCM_E_NONE;
        }
        break;
#endif /* BCM_OLP_SUPPORT*/
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_APACHE_SUPPORT)

    case bcmPortControlPortMacOui:
    case bcmPortControlPortMacNonOui:

        /*
         * In case of KT2, SB2 and TD2+ NONTCAM STATION related to OAM, OLP, XGS can be programmed
         * by either of bcm_l2_station_xxx API or  bcm_switch_olp_l2_addr_xxx
         *
         * Use either of two set of APIs
         */

        if (_BCM_SWITCH_OLP_APIV(unit) == _BCM_SWITCH_OLP_L2_STATION_API) {
            LOG_VERBOSE(BSL_LS_BCM_L2,
                        (BSL_META_U(unit,
                                    "use bcm_l2_station_xxx API\n")));
            return BCM_E_UNAVAIL;
        }
        _BCM_SWITCH_OLP_APIV_SET(unit, _BCM_SWITCH_OLP_TRUE_API);

#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit) &&
                 (soc_feature(unit, soc_feature_oam)  ||
                  soc_feature(unit, soc_feature_sat))) {

            uint32 val_lo, val_hi;
            uint64 mac_field;

            PORT_LOCK(unit);

            rv = _bcm_kt2_port_mac_get(unit, port, &mac_field);
            if (BCM_FAILURE(rv)) {
                PORT_UNLOCK(unit);
                return (rv);
            }
            COMPILER_64_TO_32_LO(val_lo, mac_field);
            COMPILER_64_TO_32_HI(val_hi, mac_field);

            switch (type) {
                case bcmPortControlPortMacOui:
                    *value = 0xffffff & ((val_hi << 8) | ((val_lo >> 24) & 0xff));
                    break;

                case bcmPortControlPortMacNonOui:
                    *value = (val_lo & 0xffffff);
                    break;
                default:
                     break;
            }
            PORT_UNLOCK(unit);

            rv = BCM_E_NONE;
        }
#endif /* BCM_KATANA2_SUPPORT */

#if defined(BCM_MONTEREY_SUPPORT)
        if (SOC_IS_MONTEREY(unit)) {
            uint32 mac;

            PORT_LOCK(unit);
            rv = _bcm_monterey_port_mac_get(unit,
                                          port,
                                          type == bcmPortControlPortMacOui,
                                          &mac);
            PORT_UNLOCK(unit);

            *value = mac;
        }
#endif
#if defined(BCM_APACHE_SUPPORT)
        if (SOC_IS_APACHE(unit) && !SOC_IS_MONTEREY(unit)) {
            uint32 mac;

            PORT_LOCK(unit);
            rv = _bcm_apache_port_mac_get(unit,
                                          port,
                                          type == bcmPortControlPortMacOui,
                                          &mac);
            PORT_UNLOCK(unit);

            *value = mac;
        }
#endif /* BCM_APACHE_SUPPORT */
        break;
#endif /* BCM_KATANA2_SUPPORT || BCM_APACHE_SUPPORT*/

#ifdef BCM_TRX_SUPPORT
     case bcmPortControlOamLoopback:
        if (SOC_IS_TRX(unit) && !SOC_IS_HURRICANE(unit)
            && !SOC_IS_SHADOW(unit))
        {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (soc_reg_field_valid(unit,ING_MISC_PORT_CONFIGr,
                                    OAM_DO_NOT_MODIFYf)) {
                uint32 reg_value;

                rv = READ_ING_MISC_PORT_CONFIGr(unit, port, &reg_value);

                if (SOC_SUCCESS(rv)) {
                    *value = soc_reg_field_get(unit, ING_MISC_PORT_CONFIGr,
                                               reg_value, OAM_DO_NOT_MODIFYf);
                }
            } else {
                return BCM_E_UNAVAIL;
            }
        }

        break;
#endif /* BCM_TRX_SUPPORT */

    case bcmPortControlLanes:
        if (soc_feature(unit, soc_feature_flexport_no_legacy)) {
            return BCM_E_UNAVAIL;
        }
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
#if defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_flex_port)) {
#ifdef BCM_XGS5_SWITCH_PORT_SUPPORT
            if (soc_feature(unit, soc_feature_xgs5_flexport_legacy_mode)) {
                rv = bcmi_xgs5_port_lanes_get(unit, port, value);
            } else
#endif /* BCM_XGS5_SWITCH_PORT_SUPPORT */
#if defined(BCM_ENDURO_SUPPORT)
            if (SOC_IS_ENDURO(unit)) {
                rv = _bcm_en_port_lanes_get(unit, port, value);
            } else
#endif
#if defined(BCM_HURRICANE1_SUPPORT)
            if (SOC_IS_HURRICANE(unit)) {
                rv = _bcm_hu_port_lanes_get(unit, port, value);
            } else
#endif
#if defined(BCM_HURRICANE2_SUPPORT)
            if (SOC_IS_HURRICANE2(unit)) {
                rv = soc_hurricane2_port_lanes_get(unit, port, value);
            } else
#endif
#if defined(BCM_MONTEREY_SUPPORT)
            if (SOC_IS_MONTEREY(unit)) {
                rv = bcmi_monterey_port_lanes_get(unit, port, value);
            } else
#endif
#if defined(BCM_APACHE_SUPPORT)
            if (SOC_IS_APACHE(unit)) {
                rv = bcmi_apache_port_lanes_get(unit, port, value);
            } else
#endif
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
            if (SOC_IS_TD2P_TT2P(unit)) {
                rv = bcmi_td2p_port_lanes_get(unit, port, value);
            } else
#endif
#if defined(BCM_TRIDENT2_SUPPORT)
            if (SOC_IS_TD2_TT2(unit)) {
                rv = soc_trident2_port_lanes_get(unit, port, value);
            } else
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIDENT_SUPPORT
            if (SOC_IS_TD_TT(unit)) {
                if (!SOC_PORT_VALID(unit, port)) {
                    return BCM_E_PORT;
                }
                /* coverity[overrun-local : FALSE] */
                *value = SOC_INFO(unit).port_num_lanes[port];
                rv = BCM_E_NONE;
            } else
#endif /* BCM_TRIDENT_SUPPORT */
#ifdef BCM_SHADOW_SUPPORT
            if (SOC_IS_SHADOW(unit)) {
                if (!SOC_PORT_VALID(unit, port)) {
                    return BCM_E_PORT;
                }
                /* coverity[overrun-local : FALSE] */
                *value = SOC_INFO(unit).port_num_lanes[port];
                rv = BCM_E_NONE;
            } else
#endif /* BCM_SHADOW_SUPPORT */
#ifdef BCM_TRIUMPH3_SUPPORT
            if (SOC_IS_TRIUMPH3(unit)) {
                rv = _bcm_tr3_port_lanes_get(unit, port, value);
            } else
#endif /* BCM_TRIUMPH3_SUPPORT */
#ifdef BCM_METROLITE_SUPPORT
            if (SOC_IS_METROLITE(unit)) {
                rv = _bcm_ml_port_lanes_get(unit, port, value);
            } else
#endif /* BCM_METROLITE_SUPPORT */
#ifdef BCM_SABER2_SUPPORT
            if (SOC_IS_SABER2(unit)) {
                rv = _bcm_sb2_port_lanes_get(unit, port, value);
            } else
#endif /* BCM_SABER2_SUPPORT */
#ifdef BCM_KATANA2_SUPPORT
            if (SOC_IS_KATANA2(unit)) {
                rv = _bcm_kt2_port_lanes_get(unit, port, value);
            } else
#endif /* BCM_KATANA2_SUPPORT */
            {
                rv = _bcm_tr2_port_lanes_get(unit, port, value);
            }
        }
#endif
        break;
    case bcmPortControlPFCEthertype:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_TYPE, value);
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
          break;
    case bcmPortControlPFCOpcode:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_OPCODE, value);
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
          break;
    case bcmPortControlPFCReceive:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_RX_ENABLE, value);
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
          break;
    case bcmPortControlPFCTransmit:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_TX_ENABLE, value);
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
          break;
    case bcmPortControlPFCClasses:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_CLASSES, value);
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
        break;
    case bcmPortControlPFCPassFrames:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }

            if(soc_feature(unit, soc_feature_pgw_mac_pfc_frame)) {
                uint32 rval32 = 0;
                soc_reg_t reg = INVALIDr;
                if(SOC_REG_IS_VALID(unit, PGW_MAC_RSV_MASKr)) {
                    reg = PGW_MAC_RSV_MASKr;
                } else if(IS_CL_PORT(unit, port) &&
                          SOC_REG_IS_VALID(unit, CLPORT_MAC_RSV_MASKr)) {
                    reg = CLPORT_MAC_RSV_MASKr;
                } else if(IS_XL_PORT(unit, port) &&
                          SOC_REG_IS_VALID(unit, XLPORT_MAC_RSV_MASKr)) {
                    reg = XLPORT_MAC_RSV_MASKr;
                } else {
                    reg = INVALIDr;
                }

                if (reg != INVALIDr) {
                    rv = soc_reg32_get(unit, reg, port, 0, &rval32);
                    if (BCM_SUCCESS(rv)) {
                        /* xxx_MAC_RSV_MASK: Bit 18 PFC frame detected
                         * the bit value needs to be reversed
                         */
                        *value = ((rval32 & 0x40000) >> 18) ? 0 : 1 ;
                    }
                } else {
                    rv = BCM_E_UNAVAIL;
                }
            } else {
                rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                     SOC_MAC_CONTROL_PFC_RX_PASS, value);
            }
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
        break;

    case bcmPortControlPFCDestMacOui:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_MAC_DA_OUI, value);
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
        break;

    case bcmPortControlPFCDestMacNonOui:
#if defined(BCM_SCORPION_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (chk_gx_port && !IS_GX_PORT(unit, port)) {
                /* IS_GX_PORT == IS_XL_PORT */
                return BCM_E_PORT;
            }
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_MAC_DA_NONOUI, value);
        }
#endif /* BCM_SCORPION_SUPPORT || BCM_TRIUMPH2_SUPPORT */
        break;

    case bcmPortControlPFCRefreshTime:
#if defined(BCM_TRIDENT_SUPPORT)|defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_REFRESH_TIME, value);
        }
#endif /* BCM_TRIDENT_SUPPORT */
        break;

    case bcmPortControlPFCXOffTime:
#if defined(BCM_TRIDENT_SUPPORT)||defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_priority_flow_control)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_PFC_XOFF_TIME, value);
        }
#endif /* BCM_TRIDENT_SUPPORT */
        break;

    case bcmPortControlVrf:
        rv = _bcm_esw_port_vrf_get(unit, port, value);
        break;

    case bcmPortControlL3Ingress:
#if defined(BCM_TRIUMPH_SUPPORT)
        {
            if (!soc_feature(unit, soc_feature_l3_ingress_interface)) {
                return BCM_E_UNAVAIL;
            }

            *value = 0;
            if (soc_mem_field_valid(unit, PORT_TABm, PORT_OPERATIONf) ||
                SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_port_tab_get(unit, port, PORT_OPERATIONf, value);
                BCM_IF_ERROR_RETURN(rv);
                if ((*value == 0x2) &&
                    (soc_mem_field_valid(unit, SOURCE_TRUNK_MAP_TABLEm,
                                         L3_IIFf)) ) {
#if defined(BCM_KATANA2_SUPPORT)
                    if (SOC_IS_KATANA2(unit)) {
                        rv = _bcm_kt2_source_trunk_map_get(unit, port, L3_IIFf,
                                                       (uint32 *)value);
                    } else
#endif
                    {
                        rv = _bcm_trx_source_trunk_map_get(unit, port, L3_IIFf,
                                                       (uint32 *)value);
                    }
                }
            }
        }
#endif  /* BCM_TRIUMPH_SUPPORT */
        break;

    case bcmPortControlL2Learn:
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit)) {
            bcm_port_cfg_t port_cfg;

            rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &port_cfg);
            if (BCM_SUCCESS(rv)) {
                rv = _bcm_trx_port_cml_hw2flags(unit, port_cfg.pc_cml,
                                                (uint32 *)value);
            }
        }
#endif /* BCM_TRX_SUPPORT */
        break;

    case bcmPortControlL2Move:
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit)) {
            bcm_port_cfg_t port_cfg;

            rv = mbcm_driver[unit]->mbcm_port_cfg_get(unit, port, &port_cfg);
            if (BCM_SUCCESS(rv)) {
                rv = _bcm_trx_port_cml_hw2flags(unit, port_cfg.pc_cml_move,
                                                (uint32 *)value);
            }
        }
#endif /* BCM_TRX_SUPPORT */
          break;

    case bcmPortControlForwardStaticL2MovePkt:
#if defined(BCM_TRX_SUPPORT)
         rv = _bcm_esw_port_tab_get(unit, port, DISABLE_STATIC_MOVE_DROPf,
                                    value);
#endif /* BCM_TRX_SUPPORT */
         break;

    case bcmPortControlPrbsRxStatus:
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_get(unit, port,
                                     SOC_PHY_CONTROL_PRBS_RX_STATUS,
                                     (uint32 *)value);
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlLinkFaultLocalEnable:
        rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                             SOC_MAC_CONTROL_FAULT_LOCAL_ENABLE, value);
        break;
    case bcmPortControlLinkFaultRemoteEnable:
        rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                             SOC_MAC_CONTROL_FAULT_REMOTE_ENABLE, value);
        break;
    case bcmPortControlLinkFaultLocal:
        rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                             SOC_MAC_CONTROL_FAULT_LOCAL_STATUS, value);
        break;
    case bcmPortControlLinkFaultRemote:
        rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                             SOC_MAC_CONTROL_FAULT_REMOTE_STATUS, value);
        break;
    case bcmPortControlTimestampTransmit:
#if defined(BCM_TIMESYNC_SUPPORT)
        if (soc_feature(unit, soc_feature_timesync_support)) {
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                                 SOC_MAC_CONTROL_TIMESTAMP_TRANSMIT, value);
        } else
#endif  /* BCM_TIMESYNC_SUPPORT */
        {
            return BCM_E_UNAVAIL;
        }
        break;
    case bcmPortControlTimestampEnable:
#if defined(BCM_HAWKEYE_SUPPORT)
        if (SOC_IS_HAWKEYE(unit)) {
            uint32 rval;
            if (!SOC_PORT_VALID(unit, port)) {
                return BCM_E_PORT;
            }
            SOC_IF_ERROR_RETURN(READ_EAV_ENABLE_BMAPr(unit, &rval));
            if ( port < 32 ) {
                *value = (rval & (1 << port)) ? TRUE:FALSE;
            } else {
                *value = FALSE;
            }
            rv = BCM_E_NONE;
        } else
#endif /* BCM_HAWKEYE_SUPPORT */
        if (soc_feature (unit, soc_feature_xlmac_timestamp_disable)) {
            if (IS_XL_PORT(unit, port)) {
                int tmp;
                uint32 rval;
                SOC_IF_ERROR_RETURN(READ_XLPORT_MAC_CONTROLr(unit,
                                                             port, &rval));
                tmp = soc_reg_field_get(unit, XLPORT_MAC_CONTROLr,
                                        rval, XLMAC_TS_DISABLEf);
                if (tmp) {
                    *value = FALSE;
                } else {
                    *value = TRUE;
                }
                rv = BCM_E_NONE;
            }
        }
        break;
    case bcmPortControlSerdesDriverEqualizationTuneStatusFarEnd:
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_get(unit, port,
             SOC_PHY_CONTROL_SERDES_DRIVER_EQUALIZATION_TUNE_STATUS_FAR_END,
                                     (uint32 *)value);
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlLinkdownTransmit:
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_get(unit, port,
                                     SOC_PHY_CONTROL_LINKDOWN_TRANSMIT,
                                     (uint32 *)value);
        PORT_UNLOCK(unit);
        /* Most of PHYs have nothing to configure and simply return UNAVAIL*/
        if ((rv == SOC_E_NONE) || (rv == SOC_E_UNAVAIL)) {
            rv = _bcm_esw_link_down_tx_get(unit, port, value);
        }
        break;
    case bcmPortControlSerdesTuneMarginMode:
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_get(unit, port,
                                     SOC_PHY_CONTROL_SERDES_TUNE_MARGIN_MODE,
                                     (uint32 *)value);
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlSerdesTuneMarginValue:
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_get(unit, port,
                                     SOC_PHY_CONTROL_SERDES_TUNE_MARGIN_VALUE,
                                     (uint32 *)value);
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlSerdesTuneMarginMax:
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_get(unit, port,
                                     SOC_PHY_CONTROL_SERDES_TUNE_MARGIN_MAX,
                                     (uint32 *)value);
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlStatOversize:
        rv = _bcm_esw_stat_ovr_threshold_get(unit, port, value);
        break;

    case bcmPortControlStatOversizeIsError:
        rv = _bcm_esw_stat_ovr_error_control_get(unit, port, value);
        break;

    case bcmPortControlEEEEnable:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }

        PORT_LOCK(unit);

#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_HAWKEYE_SUPPORT) \
        || defined(BCM_TRIDENT_SUPPORT) || defined(BCM_SHADOW_SUPPORT) \
        || defined(BCM_HURRICANE2_SUPPORT)

        if (soc_feature(unit, soc_feature_eee)) {
            *value = eee_cfg[unit][port];
            rv = BCM_E_NONE;
        } else
#endif /* BCM_HURRICANE_SUPPORT || BCM_HAWKEYE_SUPORT ||
          BCM_TRIDENT_SUPPORT || BCM_SHADOW_SUPPORT */

        {
            uint32 eeenative, eeeauto;
            int rv1 = BCM_E_UNAVAIL, rv2 = BCM_E_UNAVAIL;

            rv = BCM_E_NONE;

            if ((rv1 = soc_phyctrl_control_get(unit, port,
                            BCM_PORT_PHY_CONTROL_EEE, &eeenative)) !=
                SOC_E_UNAVAIL) {
                *value = eeenative;
            }

            if ((rv2 = soc_phyctrl_control_get(unit, port,
                            BCM_PORT_PHY_CONTROL_EEE_AUTO, &eeeauto)) !=
                SOC_E_UNAVAIL) {
                *value = eeeauto;
            }

            /* If neither Native EEE nor AutoGrEEEn mode is supported */
            if ((rv1 == SOC_E_UNAVAIL) && (rv2 == SOC_E_UNAVAIL)) {
                rv = BCM_E_UNAVAIL;
            }

            /* If both Native EEE and AutoGrEEEn mode are supported */
            if ((rv1 != SOC_E_UNAVAIL) && (rv2 != SOC_E_UNAVAIL)) {
                *value = eeenative ? (eeeauto ? 0 : 1) : (eeeauto ? 1 : 0);
            }
        }

        PORT_UNLOCK (unit);

        break;

 /**********************      EEE Mode Overview    ************************
 *                      |DET|                              |  WT |
 *   Signalling   |idles|   |------------------------------|     | idles   |
 *   from Tx MAC  | or  |   |   Low Power Idle (LPI)       |idles|  or     |
 *   to local PHY |data |   |------------------------------|     | data    |
 *                          *                              *
 *                          *                              *
 *                          *  -------LPI state------------*
 *   Local PHY    |         |  |      |  |       |  |      |   |           |
 *   signaling    |   Active|Ts|  Tq  |Tr|  Tq   |Tr|  Tq  |Tw |Active     |
 *   on MDI       |         |  |      |  |       |  |      |   |           |
 *                          *------------------------------*
 *                          *                              *
 *                          *                               *
 *   Signaling    |   idles |-------------------------------|id| PHY is    |
 *   from LP PHY  |     or  |  Low Power Idle (LPI)         |le| ready     |
 *   to Rx MAC    |   data  |-------------------------------|s | for data  |
 *
 *   where DET = Delay Entry Timer    WT = MAC Wake Timer
 */
    case bcmPortControlEEETransmitIdleTime:
        /* DET = Time (in microsecs) for which condition to move to LPI state
         * is satisfied, at the end of which MAC TX transitions to LPI state */
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }

        PORT_LOCK(unit);
#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_HAWKEYE_SUPPORT) \
        || defined(BCM_TRIDENT_SUPPORT) || defined(BCM_SHADOW_SUPPORT) \
        || defined(BCM_HURRICANE2_SUPPORT)
        if (soc_feature (unit, soc_feature_eee)) {
            rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                    SOC_MAC_CONTROL_EEE_TX_IDLE_TIME, value);
        } else
#endif /* BCM_HURRICANE_SUPPORT || BCM_HAWKEYE_SUPPORT ||
          BCM_TRIDENT_SUPPORT || BCM_SHADOW_SUPPORT */
        {
            rv = BCM_E_UNAVAIL;
        }
        PORT_UNLOCK(unit);
        break;

    case bcmPortControlEEETransmitEventCount:
        /* Number of time MAC TX enters LPI state for
         * a given measurement interval*/
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }

        PORT_LOCK(unit);

#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_HAWKEYE_SUPPORT) \
        || defined(BCM_TRIDENT_SUPPORT) || defined(BCM_SHADOW_SUPPORT) \
        || defined(BCM_HURRICANE2_SUPPORT)
        if (soc_feature(unit, soc_feature_eee)) {
            int mac_val;
            uint32 phy_val;
            uint64 rval64, rval64_2nd;
            soc_reg_t reg, reg_2nd = INVALIDr;

            COMPILER_64_ZERO(rval64);
            COMPILER_64_ZERO(rval64_2nd);

            if ((MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                     SOC_MAC_CONTROL_EEE_ENABLE, &mac_val) != SOC_E_UNAVAIL) &&
                (soc_phyctrl_control_get(unit, port,
                     BCM_PORT_PHY_CONTROL_EEE, &phy_val) != SOC_E_UNAVAIL)) {
                /* If MAC/Switch is EEE aware (Native EEE mode is supported)
                 * and PHY also supports Native mode
                 */

                /* On Katana TX/RX register are swapped */
                reg = (SOC_IS_KATANAX(unit)) ? RX_EEE_LPI_EVENT_COUNTERr :
                      ((SOC_IS_HURRICANE2(unit) && IS_GE_PORT(unit, port)) ?
                      GTX_EEE_LPI_EVENT_COUNTERr :
                      TX_EEE_LPI_EVENT_COUNTERr);
                if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit)) {
                    if (IS_XL_PORT(unit, port)){
                        reg = TX_EEE_LPI_EVENT_COUNTERr;
                    } else {
                        reg = GTX_EEE_LPI_EVENT_COUNTERr;
                    }
                } else if (SOC_IS_GREYHOUND2(unit)) {
                    if (IS_CL_PORT(unit, port)){
                        reg = CLMIB_TX_EEE_LPI_EVENT_COUNTERr;
                    } else if (IS_XL_PORT(unit, port)) {
                        reg = XLMIB_TX_EEE_LPI_EVENT_COUNTERr;
                        reg_2nd = XLPMIB_TX_EEE_LPI_EVENT_COUNTERr;
                    } else {
#if defined(BCM_FIRELIGHT_SUPPORT)
                        if (soc_feature(unit, soc_feature_fl) && IS_QSGMII_PORT(unit, port)) {
                            if (soc_feature(unit, soc_feature_gport_eee_lpi_tx_rx_swap)) {
                                reg = GRX_EEE_LPI_EVENT_COUNTERr;
                            } else {
                                reg = GTX_EEE_LPI_EVENT_COUNTERr;
                            }
                        } else
#endif
                        {
                            reg = GTX_EEE_LPI_EVENT_COUNTERr;
                        }
                    }
                }

#ifdef BCM_HURRICANE4_SUPPORT
                if (SOC_IS_HURRICANE4(unit) && IS_EGPHY_PORT(unit, port)) {
                    if (soc_feature(unit, soc_feature_gport_eee_lpi_tx_rx_swap)) {
                        reg = GRX_EEE_LPI_EVENT_COUNTERr;
                    } else {
                        reg = GTX_EEE_LPI_EVENT_COUNTERr;
                    }
                }
#endif /* BCM_HURRICANE4_SUPPORT */

                rv = soc_reg_get(unit, reg, port, 0, &rval64);

                if (BCM_SUCCESS(rv)) {
                    *value = COMPILER_64_LO(rval64);
                }

                if (SOC_REG_IS_VALID(unit, reg_2nd)) {
                    rv = soc_reg_get(unit, reg_2nd, port, 0, &rval64_2nd);

                    if (BCM_SUCCESS(rv)) {
                        *value += COMPILER_64_LO(rval64_2nd);
                    }
                }
            } else {
                /* Get counter value from PHY. If PHY does not support
                 * EEE counters, rv will be assigned SOC_E_UNAVAIL.
                 */
                rv = soc_phyctrl_control_get(unit, port,
                        BCM_PORT_PHY_CONTROL_EEE_TRANSMIT_EVENTS, &phy_val);
                if (SOC_SUCCESS(rv)) {
                    *value = phy_val;
                }
            }
        } else
#endif /* BCM_HURRICANE_SUPPORT || BCM_HAWKEYE_SUPPORT ||
          BCM_TRIDENT_SUPPORT || BCM_SHADOW_SUPPORT */

        {
            /* On legacy devices that don't support native EEE,
             * get counter value from PHY. If PHY does not support
             * EEE counters, rv will be assigned SOC_E_UNAVAIL.
             */
            uint32 phy_val;
            rv = soc_phyctrl_control_get(unit, port,
                    BCM_PORT_PHY_CONTROL_EEE_TRANSMIT_EVENTS, &phy_val);
            if (SOC_SUCCESS(rv)) {
                *value = phy_val;
            }
        }

        PORT_UNLOCK (unit);

        break;

    case bcmPortControlEEETransmitDuration:
        /* Time in (microsecs) for which MAC TX enters LPI state
         * during a measurement interval*/
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }

        PORT_LOCK(unit);

#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_HAWKEYE_SUPPORT) \
        || defined(BCM_TRIDENT_SUPPORT) || defined(BCM_SHADOW_SUPPORT) \
        || defined(BCM_HURRICANE2_SUPPORT)
        if (soc_feature(unit, soc_feature_eee)) {
            int mac_val;
            uint32 phy_val;
            uint64 rval64, rval64_2nd;
            soc_reg_t reg, reg_2nd = INVALIDr;

            COMPILER_64_ZERO(rval64);
            COMPILER_64_ZERO(rval64_2nd);

            if ((MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                     SOC_MAC_CONTROL_EEE_ENABLE, &mac_val) != SOC_E_UNAVAIL) &&
                (soc_phyctrl_control_get(unit, port,
                     BCM_PORT_PHY_CONTROL_EEE, &phy_val) != SOC_E_UNAVAIL)) {
                /* If MAC/Switch is EEE aware (Native EEE mode is supported)
                 * and PHY also supports Native mode
                 */
                /* On Katana TX/RX register are swapped */
                reg = (SOC_IS_KATANAX(unit)) ? RX_EEE_LPI_DURATION_COUNTERr :
                      ((SOC_IS_HURRICANE2(unit) && IS_GE_PORT(unit, port)) ?
                      GTX_EEE_LPI_DURATION_COUNTERr :
                      TX_EEE_LPI_DURATION_COUNTERr);
                if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit)) {
                    if (IS_XL_PORT(unit, port)) {
                        reg = TX_EEE_LPI_DURATION_COUNTERr;
                    } else {
                        reg = GTX_EEE_LPI_DURATION_COUNTERr;
                    }
                } else if (SOC_IS_GREYHOUND2(unit)) {
                    if (IS_CL_PORT(unit, port)){
                        reg = CLMIB_TX_EEE_LPI_DURATION_COUNTERr;
                    } else if (IS_XL_PORT(unit, port)) {
                        reg = XLMIB_TX_EEE_LPI_DURATION_COUNTERr;
                        reg_2nd = XLPMIB_TX_EEE_LPI_DURATION_COUNTERr;
                    } else {
#if defined(BCM_FIRELIGHT_SUPPORT)
                        if (soc_feature(unit, soc_feature_fl) && IS_QSGMII_PORT(unit, port)) {
                            if (soc_feature(unit, soc_feature_gport_eee_lpi_tx_rx_swap)) {
                                reg = GRX_EEE_LPI_DURATION_COUNTERr;
                            } else {
                                reg = GTX_EEE_LPI_DURATION_COUNTERr;
                            }
                        } else
#endif
                        {
                            reg = GTX_EEE_LPI_DURATION_COUNTERr;
                        }
                    }
                }

#ifdef BCM_HURRICANE4_SUPPORT
                if (SOC_IS_HURRICANE4(unit) && IS_EGPHY_PORT(unit, port)) {
                    if (soc_feature(unit, soc_feature_gport_eee_lpi_tx_rx_swap)) {
                        reg = GRX_EEE_LPI_DURATION_COUNTERr;
                    } else {
                        reg = GTX_EEE_LPI_DURATION_COUNTERr;
                    }
                }
#endif /* BCM_HURRICANE4_SUPPORT */

                rv = soc_reg_get(unit, reg, port, 0, &rval64);

                if (BCM_SUCCESS(rv)) {
                    *value = COMPILER_64_LO(rval64);
                }

                if (SOC_REG_IS_VALID(unit, reg_2nd)) {
                    rv = soc_reg_get(unit, reg_2nd, port, 0, &rval64_2nd);
                    if (BCM_SUCCESS(rv)) {
                        /* add the 2nd register */
                        *value += COMPILER_64_LO(rval64_2nd);
                    }
                }
            } else {
                /* Get counter value from PHY. If PHY does not support
                 * EEE counters, rv will be assigned SOC_E_UNAVAIL.
                 */
                rv = soc_phyctrl_control_get(unit, port,
                        BCM_PORT_PHY_CONTROL_EEE_TRANSMIT_DURATION, &phy_val);
                if (SOC_SUCCESS(rv)) {
                    *value = phy_val;
                }
            }
        } else
#endif /* BCM_HURRICANE_SUPPORT || BCM_HAWKEYE_SUPPORT ||
          BCM_TRIDENT_SUPPORT || BCM_SHADOW_SUPPORT */
        {
            /* On legacy devices that don't support native EEE,
             * get counter value from PHY. If PHY does not support
             * EEE counters, rv will be assigned SOC_E_UNAVAIL.
             */
            uint32 phy_val;
            rv = soc_phyctrl_control_get(unit, port,
                    BCM_PORT_PHY_CONTROL_EEE_TRANSMIT_DURATION, &phy_val);
            if (SOC_SUCCESS(rv)) {
                *value = phy_val;
            }
        }

        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEEReceiveEventCount:
        /* Number of time MAC RX enters LPI state for
         * a given measurement interval */
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }

        PORT_LOCK(unit);

#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_HAWKEYE_SUPPORT) \
        || defined(BCM_TRIDENT_SUPPORT) || defined(BCM_SHADOW_SUPPORT) \
        || defined(BCM_HURRICANE2_SUPPORT)
        if (soc_feature(unit, soc_feature_eee)) {
            int mac_val;
            uint32 phy_val;
            uint64 rval64, rval64_2nd;
            soc_reg_t reg, reg_2nd = INVALIDr;

            COMPILER_64_ZERO(rval64);
            COMPILER_64_ZERO(rval64_2nd);

            if ((MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                     SOC_MAC_CONTROL_EEE_ENABLE, &mac_val) != SOC_E_UNAVAIL) &&
                (soc_phyctrl_control_get(unit, port,
                     BCM_PORT_PHY_CONTROL_EEE, &phy_val) != SOC_E_UNAVAIL)) {
                /* If MAC/Switch is EEE aware (Native EEE mode is supported)
                 * and PHY also supports Native mode
                 */
                /* On Katana TX/RX register are swapped */
                reg = (SOC_IS_KATANAX(unit)) ? TX_EEE_LPI_EVENT_COUNTERr :
                      ((SOC_IS_HURRICANE2(unit) && IS_GE_PORT(unit, port)) ?
                      GRX_EEE_LPI_EVENT_COUNTERr :
                      RX_EEE_LPI_EVENT_COUNTERr);
                if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit)) {
                    if (IS_XL_PORT(unit, port)) {
                        reg = RX_EEE_LPI_EVENT_COUNTERr;
                    } else {
                        reg = GRX_EEE_LPI_EVENT_COUNTERr;
                    }
                } else if (SOC_IS_GREYHOUND2(unit)) {
                    if (IS_CL_PORT(unit, port)){
                        reg = CLMIB_RX_EEE_LPI_EVENT_COUNTERr;
                    } else if (IS_XL_PORT(unit, port)) {
                        reg = XLMIB_RX_EEE_LPI_EVENT_COUNTERr;
                        reg_2nd = XLPMIB_RX_EEE_LPI_EVENT_COUNTERr;
                    } else {
#if defined(BCM_FIRELIGHT_SUPPORT)
                        if (soc_feature(unit, soc_feature_fl) && IS_QSGMII_PORT(unit, port)) {
                            if (soc_feature(unit, soc_feature_gport_eee_lpi_tx_rx_swap)) {
                                reg = GTX_EEE_LPI_EVENT_COUNTERr;
                            } else {
                                reg = GRX_EEE_LPI_EVENT_COUNTERr;
                            }
                        } else
#endif
                        {
                            reg = GRX_EEE_LPI_EVENT_COUNTERr;
                        }
                    }
                }

#ifdef BCM_HURRICANE4_SUPPORT
                if (SOC_IS_HURRICANE4(unit) && IS_EGPHY_PORT(unit, port)) {
                    if (soc_feature(unit, soc_feature_gport_eee_lpi_tx_rx_swap)) {
                        reg = GTX_EEE_LPI_EVENT_COUNTERr;
                    } else {
                        reg = GRX_EEE_LPI_EVENT_COUNTERr;
                    }
                }
#endif /* BCM_HURRICANE4_SUPPORT */

                rv = soc_reg_get(unit, reg, port, 0, &rval64);

                if (BCM_SUCCESS(rv)) {
                    *value = COMPILER_64_LO(rval64);
                }

                if (SOC_REG_IS_VALID(unit, reg_2nd)) {
                    rv = soc_reg_get(unit, reg_2nd, port, 0, &rval64_2nd);
                    if (BCM_SUCCESS(rv)) {
                        /* add the 2nd register */
                        *value += COMPILER_64_LO(rval64_2nd);
                    }
                }
            } else {
                /* Get counter value from PHY. If PHY does not support
                 * EEE counters, rv will be assigned SOC_E_UNAVAIL.
                 */
                rv = soc_phyctrl_control_get(unit, port,
                        BCM_PORT_PHY_CONTROL_EEE_RECEIVE_EVENTS, &phy_val);
                if (SOC_SUCCESS(rv)) {
                    *value = phy_val;
                }
            }
        } else
#endif /* BCM_HURRICANE_SUPPORT || BCM_HAWKEYE_SUPPORT ||
          BCM_TRIDENT_SUPPORT || BCM_SHADOW_SUPPORT */
        {
            /* On legacy devices that don't support native EEE,
             * get counter value from PHY. If PHY does not support
             * EEE counters, rv will be assigned SOC_E_UNAVAIL.
             */
            uint32 phy_val;
            rv = soc_phyctrl_control_get(unit, port,
                    BCM_PORT_PHY_CONTROL_EEE_RECEIVE_EVENTS, &phy_val);
            if (SOC_SUCCESS(rv)) {
                *value = phy_val;
            }
        }

        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEEReceiveDuration:
        /* Time in (microsecs) for which MAC RX enters LPI state
         * during a measurement interval*/
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }

        PORT_LOCK(unit);

#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_HAWKEYE_SUPPORT) \
        || defined(BCM_TRIDENT_SUPPORT) || defined(BCM_HURRICANE2_SUPPORT)
        if (soc_feature(unit, soc_feature_eee)) {
            int mac_val;
            uint32 phy_val;
            uint64 rval64, rval64_2nd;
            soc_reg_t reg, reg_2nd = INVALIDr;

            COMPILER_64_ZERO(rval64);
            COMPILER_64_ZERO(rval64_2nd);

            if ((MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                     SOC_MAC_CONTROL_EEE_ENABLE, &mac_val) != SOC_E_UNAVAIL) &&
                (soc_phyctrl_control_get(unit, port,
                     BCM_PORT_PHY_CONTROL_EEE, &phy_val) != SOC_E_UNAVAIL)) {
                /* If MAC/Switch is EEE aware (Native EEE mode is supported)
                 * and PHY also supports Native mode
                 */
                /* On Katana TX/RX register are swapped */
                reg = (SOC_IS_KATANAX(unit)) ? TX_EEE_LPI_DURATION_COUNTERr :
                      ((SOC_IS_HURRICANE2(unit) && IS_GE_PORT(unit, port)) ?
                      GRX_EEE_LPI_DURATION_COUNTERr :
                      RX_EEE_LPI_DURATION_COUNTERr);
                if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit)) {
                    if (IS_XL_PORT(unit, port)) {
                        reg = RX_EEE_LPI_DURATION_COUNTERr;
                    } else {
                        reg = GRX_EEE_LPI_DURATION_COUNTERr;
                    }
                } else if (SOC_IS_GREYHOUND2(unit)) {
                    if (IS_CL_PORT(unit, port)){
                        reg = CLMIB_RX_EEE_LPI_DURATION_COUNTERr;
                    } else if (IS_XL_PORT(unit, port)) {
                        reg = XLMIB_RX_EEE_LPI_DURATION_COUNTERr;
                        reg_2nd = XLPMIB_RX_EEE_LPI_DURATION_COUNTERr;
                    } else {
#if defined(BCM_FIRELIGHT_SUPPORT)
                        if (soc_feature(unit, soc_feature_fl) && IS_QSGMII_PORT(unit, port)) {
                            if (soc_feature(unit, soc_feature_gport_eee_lpi_tx_rx_swap)) {
                                reg = GTX_EEE_LPI_DURATION_COUNTERr;
                            } else {
                                reg = GRX_EEE_LPI_DURATION_COUNTERr;
                            }
                        } else
#endif
                        {
                            reg = GRX_EEE_LPI_DURATION_COUNTERr;
                        }
                    }
                }

#ifdef BCM_HURRICANE4_SUPPORT
                if (SOC_IS_HURRICANE4(unit) && IS_EGPHY_PORT(unit, port)) {
                    if (soc_feature(unit, soc_feature_gport_eee_lpi_tx_rx_swap)) {
                        reg = GTX_EEE_LPI_DURATION_COUNTERr;
                    } else {
                        reg = GRX_EEE_LPI_DURATION_COUNTERr;
                    }
                }
#endif /* BCM_HURRICANE4_SUPPORT */

                rv = soc_reg_get(unit, reg, port, 0, &rval64);

                if (BCM_SUCCESS(rv)) {
                    *value = COMPILER_64_LO(rval64);
                }

                if (SOC_REG_IS_VALID(unit, reg_2nd)) {
                    rv = soc_reg_get(unit, reg_2nd, port, 0, &rval64_2nd);
                    if (BCM_SUCCESS(rv)) {
                        /* add the 2nd register */
                        *value += COMPILER_64_LO(rval64_2nd);
                    }
                }
            } else {
                /* Get counter value from PHY. If PHY does not support
                 * EEE counters, rv will be assigned SOC_E_UNAVAIL.
                 */
                rv = soc_phyctrl_control_get(unit, port,
                        BCM_PORT_PHY_CONTROL_EEE_RECEIVE_DURATION, &phy_val);
                if (SOC_SUCCESS(rv)) {
                    *value = phy_val;
                }
            }
        } else
#endif /* BCM_HURRICANE_SUPPORT || BCM_HAWKEYE_SUPPORT ||
          BCM_TRIDENT_SUPPORT */
        {
            /* On legacy devices that don't support native EEE,
             * get counter value from PHY. If PHY does not support
             * EEE counters, rv will be assigned SOC_E_UNAVAIL.
             */
            uint32 phy_val;
            rv = soc_phyctrl_control_get(unit, port,
                    BCM_PORT_PHY_CONTROL_EEE_RECEIVE_DURATION, &phy_val);
            if (SOC_SUCCESS(rv)) {
                *value = phy_val;
            }
        }

        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEETransmitRefreshTime:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_get(unit, port,
                BCM_PORT_PHY_CONTROL_EEE_TRANSMIT_REFRESH_TIME,
                                     (uint32 *)value);
        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEETransmitSleepTime:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_get(unit, port,
                BCM_PORT_PHY_CONTROL_EEE_TRANSMIT_SLEEP_TIME, (uint32 *)value);
        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEETransmitQuietTime:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_get(unit, port,
                BCM_PORT_PHY_CONTROL_EEE_TRANSMIT_QUIET_TIME, (uint32 *)value);
        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEETransmitWakeTime:
        /* Time(in microsecs) to wait before transmitter can leave LPI State*/
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }

        PORT_LOCK(unit);

#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_HAWKEYE_SUPPORT) \
        || defined(BCM_TRIDENT_SUPPORT) || defined(BCM_HURRICANE2_SUPPORT)
        if (soc_feature(unit, soc_feature_eee)) {
            int mac_val;
            uint32 phy_val;

            if ((MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                     SOC_MAC_CONTROL_EEE_ENABLE, &mac_val) != SOC_E_UNAVAIL) &&
                (soc_phyctrl_control_get(unit, port,
                     BCM_PORT_PHY_CONTROL_EEE, &phy_val) != SOC_E_UNAVAIL)) {
                /* If MAC/Switch is EEE aware (Native EEE mode is supported)
                 * and PHY also supports Native mode
                 */
                rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                        SOC_MAC_CONTROL_EEE_TX_WAKE_TIME, value);

            } else {
                /* Get timer value from PHY. If PHY does not support
                 * EEE timers, rv will be assigned SOC_E_UNAVAIL.
                 */
                rv = soc_phyctrl_control_get(unit, port,
                        BCM_PORT_PHY_CONTROL_EEE_TRANSMIT_WAKE_TIME, &phy_val);
                if (SOC_SUCCESS(rv)) {
                    *value = phy_val;
                }
            }
        } else
#endif /* BCM_HURRICANE_SUPPORT || BCM_HAWKEYE_SUPPORT ||
          BCM_TRIDENT_SUPPORT */
        {
            /* On legacy devices that don't support native EEE,
             * get timer value from PHY. If PHY does not support
             * EEE timers, rv will be assigned SOC_E_UNAVAIL.
             */
            uint32 phy_val;
            rv = soc_phyctrl_control_get(unit, port,
                    BCM_PORT_PHY_CONTROL_EEE_TRANSMIT_WAKE_TIME, &phy_val);
            if (SOC_SUCCESS(rv)) {
                *value = phy_val;
            }
        }

        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEEReceiveSleepTime:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_get(unit, port,
                BCM_PORT_PHY_CONTROL_EEE_RECEIVE_SLEEP_TIME, (uint32 *)value);
        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEEReceiveQuietTime:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_get(unit, port,
                BCM_PORT_PHY_CONTROL_EEE_RECEIVE_QUIET_TIME, (uint32 *)value);
        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEEReceiveWakeTime:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = soc_phyctrl_control_get(unit, port,
                BCM_PORT_PHY_CONTROL_EEE_RECEIVE_WAKE_TIME, (uint32 *)value);
        PORT_UNLOCK (unit);
        break;

    case bcmPortControlEEEEventCountSymmetric:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }
#if defined(BCM_HURRICANE2_SUPPORT)
        if (SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit) ||
            SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
            uint32      reg_value;
            soc_reg_t   reg;
            if (IS_XL_PORT(unit, port) || IS_CL_PORT(unit, port)) {
                reg = IS_XL_PORT(unit, port) ? XLPORT_EEE_COUNTER_MODEr :
                                               CLPORT_EEE_COUNTER_MODEr;

                if (SOC_REG_FIELD_VALID(unit, reg, MODE_BITf)) {
                    rv = soc_reg32_get(unit, reg, port, 0, &reg_value);
                    if (SOC_SUCCESS(rv)) {
                        *value = soc_reg_field_get(unit, reg,
                                                   reg_value, MODE_BITf);
                    }
                } else {
                    return BCM_E_INTERNAL;
                }
            } else {
                return BCM_E_PORT;
            }
        } else
#endif
        {
#if defined(BCM_TRIUMPH3_SUPPORT)
            if (SOC_REG_FIELD_VALID(unit, PORT_EEE_COUNTER_MODEr, MODE_BITf)) {
                  uint32 reg_value;

                  rv = READ_PORT_EEE_COUNTER_MODEr(unit, port, &reg_value);

                  if (SOC_SUCCESS(rv)) {
                      *value = soc_reg_field_get(unit, PORT_EEE_COUNTER_MODEr,
                          reg_value, MODE_BITf);
                  }
            }
#endif
       }
        break;

    case bcmPortControlEEELinkActiveDuration:
        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        if (!IS_E_PORT(unit, port)) {
            return BCM_E_UNAVAIL;
        }
#if defined(BCM_HURRICANE2_SUPPORT)
        if (SOC_IS_HURRICANE2(unit) || SOC_IS_GREYHOUND(unit) ||
            SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
            soc_reg_t   reg;

            if (IS_XL_PORT(unit, port) || IS_CL_PORT(unit, port)) {

                reg = IS_XL_PORT(unit, port) ?
                                XLMAC_EEE_1_SEC_LINK_STATUS_TIMERr :
                                CLMAC_EEE_1_SEC_LINK_STATUS_TIMERr;
                if (SOC_REG_FIELD_VALID(unit, reg, ONE_SECOND_TIMERf)) {
                    uint64 reg_value;

                    rv = soc_reg_get(unit, reg, port, 0, &reg_value);
                    if (SOC_SUCCESS(rv)) {
                        *value = soc_reg64_field32_get(unit,
                                                       reg, reg_value,
                                                       ONE_SECOND_TIMERf);
                    }
                }
            } else {
                return BCM_E_PORT;
            }
        } else
#endif
        {
#if defined(BCM_TRIUMPH3_SUPPORT)
            {
                soc_reg_t reg;

                reg = IS_C_PORT(unit, port) ?
                    CMAC_EEE_1_SEC_LINK_STATUS_TIMERr :
                    XMAC_EEE_1_SEC_LINK_STATUS_TIMERr;
                if (SOC_REG_FIELD_VALID(unit, reg, ONE_SECOND_TIMERf)) {
                    uint64 reg_value;

                    rv = soc_reg_get(unit, reg, port, 0, &reg_value);
                    if (SOC_SUCCESS(rv)) {
                        *value = soc_reg64_field32_get(unit, reg, reg_value,
                                                     ONE_SECOND_TIMERf);
                    }
                }
            }
#endif
        }
        break;

    case bcmPortControlRemoteCpuTcMapping:
        if (soc_feature(unit, soc_feature_rcpu_tc_mapping)) {
            rv = _bcm_esw_port_tab_get(unit, port, REMOTE_CPU_ENf, value);
        } else {
            rv = BCM_E_UNAVAIL;
        }
        break;

    case bcmPortControlTrill:
#if defined(BCM_TRIDENT_SUPPORT)
        if (soc_feature(unit, soc_feature_trill)) {
            rv = _bcm_esw_port_tab_get(unit, port, TRILL_ENABLEf, value);
        }
#endif /* BCM_TRIDENT_SUPPORT */
        break;

    case bcmPortControlTrillAllow:
#if defined(BCM_TRIDENT_SUPPORT)
        if (soc_feature(unit, soc_feature_trill)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       ALLOW_TRILL_FRAMESf, value);
        }
#endif /* BCM_TRIDENT_SUPPORT */
        break;

    case bcmPortControlNonTrillAllow:
#if defined(BCM_TRIDENT_SUPPORT)
        if (soc_feature(unit, soc_feature_trill)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       ALLOW_NON_TRILL_FRAMESf, value);
        }
#endif /* BCM_TRIDENT_SUPPORT */
        break;

    case bcmPortControlTrillCoreISISToCPU:
#if defined(BCM_TRIDENT_SUPPORT)
        if (soc_feature(unit, soc_feature_trill)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       COPY_CORE_IS_IS_TO_CPUf, value);
        }
#endif /* BCM_TRIDENT_SUPPORT */
        break;

    case bcmPortControlTrillHashSelect:
#if defined(BCM_TRIDENT_SUPPORT)
        if (soc_feature(unit, soc_feature_trill)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       RTAG7_HASH_CFG_SEL_TRILL_ECMPf, value);
        }
#endif /* BCM_TRIDENT_SUPPORT */
        break;

    case bcmPortControlNivAccessVirtualInterfaceId:
    case bcmPortControlExtendedPortVid:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
                 soc_feature(unit, soc_feature_port_extension)) {
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
                uint64 val64;
                rv = READ_EGR_PORT_64r(unit, port, &val64);
                if (BCM_SUCCESS(rv)) {
                    *value = soc_reg64_field32_get(unit, EGR_PORT_64r,
                                            val64, NIV_VIF_IDf);
                }
            } else {
                rv = _bcm_esw_port_tab_get(unit, port, NIV_VIF_IDf, value);
            }
         }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlNivNonVntagDrop:
    case bcmPortControlNonEtagDrop:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
                 soc_feature(unit, soc_feature_port_extension)) {
             rv = _bcm_esw_port_tab_get(unit, port,
                     DISCARD_IF_VNTAG_NOT_PRESENTf, value);
         }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlNivVntagDrop:
    case bcmPortControlEtagDrop:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_niv) ||
            soc_feature(unit, soc_feature_port_extension)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       DISCARD_IF_VNTAG_PRESENTf, value);
        }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
        break;

    case bcmPortControlSubportPktTagDrop:
#if defined(BCM_KATANA2_SUPPORT)
         if (soc_feature(unit, soc_feature_lltag)) {
             rv = _bcm_esw_port_tab_get(unit, port,
                     DISCARD_IF_LLTAG_PRESENTf, value);
         }
#endif /* BCM_KATANA2_SUPPORT */
         break;

    case bcmPortControlNoSubportPktTagDrop:
#if defined(BCM_KATANA2_SUPPORT)
         if (soc_feature(unit, soc_feature_lltag)) {
             rv = _bcm_esw_port_tab_get(unit, port,
                     DISCARD_IF_LLTAG_NOT_PRESENTf, value);
         }
#endif /* BCM_KATANA2_SUPPORT */
         break;

    case bcmPortControlNivNonVntagAdd:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_niv)) {
            int vntag_action;
            rv = _bcm_esw_port_tab_get(unit, port,
                                       VNTAG_ACTIONS_IF_NOT_PRESENTf,
                                       &vntag_action);
            if (BCM_SUCCESS(rv)) {
                *value = (vntag_action == VNTAG_ADD) ? TRUE : FALSE;
            }
        }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
        break;

    case bcmPortControlNonEtagAdd:
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_port_extension)) {
            int etag_action;
            rv = _bcm_esw_port_tab_get(unit, port,
                                       VNTAG_ACTIONS_IF_NOT_PRESENTf,
                                       &etag_action);
            if (BCM_SUCCESS(rv)) {
                *value = (etag_action == 2) ? TRUE : FALSE;
            }
        }
#endif /* BCM_TRIUMPH3_SUPPORT||BCM_GREYHOUND_SUPPORT */
        break;

    case bcmPortControlNivVntagIngressReplace:
    case bcmPortControlEtagIngressReplace:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_niv) ||
            soc_feature(unit, soc_feature_port_extension)) {
            int vntag_action;
            rv = _bcm_esw_port_tab_get(unit, port,
                                       VNTAG_ACTIONS_IF_PRESENTf,
                                       &vntag_action);
            if (BCM_SUCCESS(rv)) {
                *value = (vntag_action == VNTAG_REPLACE) ? TRUE : FALSE;
            }
        }
#endif /* BCM_TRIDENT_SUPPORT ||BCM_GREYHOUND_SUPPORT */
        break;

    case bcmPortControlNivVntagEgressReplace:
    case bcmPortControlEtagEgressReplace:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
         if (soc_feature(unit, soc_feature_niv) ||
                 soc_feature(unit, soc_feature_port_extension)) {
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
                uint64 val64;
                int vntag_action;

                if (type == bcmPortControlEtagEgressReplace) {
                    return BCM_E_UNAVAIL;
                }

                rv = READ_EGR_PORT_64r(unit, port, &val64);
                if (BCM_SUCCESS(rv)) {
                    vntag_action = soc_reg64_field32_get(unit, EGR_PORT_64r,
                                            val64, VNTAG_ACTIONS_IF_PRESENTf);
                    *value = (vntag_action == VNTAG_REPLACE) ? TRUE : FALSE;
                }
            } else {
                int vntag_action;
                rv = _bcm_esw_egr_port_tab_get(unit, port,
                                               VNTAG_ACTIONS_IF_PRESENTf,
                                               &vntag_action);
                if (BCM_SUCCESS(rv)) {
                    *value = (vntag_action == VNTAG_REPLACE) ? TRUE : FALSE;
                }
            }
         }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlNivVntagIngressDelete:
    case bcmPortControlEtagIngressDelete:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_niv) ||
            soc_feature(unit, soc_feature_port_extension)) {
            int vntag_action;
            rv = _bcm_esw_port_tab_get(unit, port,
                                       VNTAG_ACTIONS_IF_PRESENTf,
                                       &vntag_action);
            if (BCM_SUCCESS(rv)) {
                *value = (vntag_action == VNTAG_DELETE) ? TRUE : FALSE;
            }
        }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
        break;

    case bcmPortControlNivVntagEgressDelete:
    case bcmPortControlEtagEgressDelete:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_niv) ||
            soc_feature(unit, soc_feature_port_extension)) {
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
                uint64 val64;
                int vntag_action;
                rv = READ_EGR_PORT_64r(unit, port, &val64);
                if (BCM_SUCCESS(rv)) {
                    vntag_action = soc_reg64_field32_get(unit, EGR_PORT_64r,
                                            val64, VNTAG_ACTIONS_IF_PRESENTf);
                    *value = (vntag_action == VNTAG_DELETE) ? TRUE : FALSE;
                }
            } else {
                int vntag_action;
                rv = _bcm_esw_egr_port_tab_get(unit, port,
                                               VNTAG_ACTIONS_IF_PRESENTf,
                                               &vntag_action);
                if (BCM_SUCCESS(rv)) {
                    *value = (vntag_action == VNTAG_DELETE) ? TRUE : FALSE;
                }
            }
        }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
        break;

    case bcmPortControlNivRpfCheck:
    case bcmPortControlExtenderRpfCheck:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_niv) ||
            soc_feature(unit, soc_feature_port_extension)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       NIV_RPF_CHECK_ENABLEf, value);
        }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
        break;

    case bcmPortControlNivSourceKnockout:
    case bcmPortControlExtenderSourceKnockout:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_niv) ||
            soc_feature(unit, soc_feature_port_extension)) {
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
                uint64 val64;
                rv = READ_EGR_PORT_64r(unit, port, &val64);
                if (BCM_SUCCESS(rv)) {
                    *value = soc_reg64_field32_get(unit, EGR_PORT_64r,
                                            val64, NIV_PRUNE_ENABLEf);
                }
            } else {
                rv = _bcm_esw_egr_port_tab_get(unit, port,
                                               NIV_PRUNE_ENABLEf, value);
            }
        }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
         break;

    case bcmPortControlNivForwardPort:
    case bcmPortControlExtenderForwardPort:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_niv) ||
            soc_feature(unit, soc_feature_port_extension)) {
            int is_niv_uplink;
            int tx_dest_port;
            _bcm_gport_dest_t dest;

            BCM_IF_ERROR_RETURN
                (_bcm_esw_port_tab_get(unit, port,
                                       NIV_UPLINK_PORTf, &is_niv_uplink));
            if (is_niv_uplink) {
                *value = -1;
            } else {
                if (soc_feature(unit, soc_feature_generic_dest)) {
                    uint32 dt, dval;
                    BCM_IF_ERROR_RETURN
                        (_bcm_esw_port_tab_get(unit, port, DESTINATIONf,
                                               &tx_dest_port));
                    _soc_mem_dest_value_resolve(unit, tx_dest_port, &dt, &dval);
                    if (dt == SOC_MEM_FIF_DEST_LAG) {
                        dest.tgid = dval;
                        dest.gport_type = _SHR_GPORT_TYPE_TRUNK;
                    } else {
                        dest.port = dval & SOC_MEM_FIF_DGPP_PORT_MASK;
                        dest.modid = (dval & SOC_MEM_FIF_DGPP_MOD_ID_MASK) >>
                                        SOC_MEM_FIF_DGPP_MOD_ID_SHIFT_BITS;
                        dest.gport_type = _SHR_GPORT_TYPE_MODPORT;
                    }
                } else {
                    BCM_IF_ERROR_RETURN
                        (_bcm_esw_port_tab_get(unit, port,
                                               TX_DEST_PORTf, &tx_dest_port));
                    if ((tx_dest_port >> SOC_TRUNK_BIT_POS(unit)) & 0x1) {
                        dest.tgid = tx_dest_port - (1 << SOC_TRUNK_BIT_POS(unit));
                        dest.gport_type = _SHR_GPORT_TYPE_TRUNK;
                    } else {
#if defined(BCM_METROLITE_SUPPORT)
                  /* Metrolite DGLP still uses 7 bits for port like saber 2 */
                      if (SOC_IS_METROLITE(unit)) {
                          dest.port = tx_dest_port & 0x7f;
                          dest.modid =( tx_dest_port & 0xff10) >> 7;
                      } else
#endif
                      {
                          dest.port = tx_dest_port & SOC_PORT_ADDR_MAX(unit);
                          dest.modid = (tx_dest_port - dest.port) /
                                   (SOC_PORT_ADDR_MAX(unit) + 1);
                      }
                        dest.gport_type = _SHR_GPORT_TYPE_MODPORT;
                    }
                }
                BCM_IF_ERROR_RETURN
                    (_bcm_esw_gport_construct(unit, &dest, value));
            }
            rv = BCM_E_NONE;
        }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
        break;

    case bcmPortControlNivType:
        if (soc_feature(unit, soc_feature_niv)) {
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
#if defined(BCM_GREYHOUND_SUPPORT)
                rv = bcm_gh_port_niv_type_get(unit, port, value);
#endif /* BCM_GREYHOUND_SUPPORT */
            } else {
#if defined(BCM_TRIDENT_SUPPORT)
                rv = bcm_td_port_niv_type_get(unit, port, value);
#endif /* BCM_TRIDENT_SUPPORT */
            }
        }
        break;

    case bcmPortControlExtenderType:
        if (soc_feature(unit, soc_feature_port_extension)) {
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
#if defined(BCM_GREYHOUND_SUPPORT)
                rv = bcm_gh_port_extender_type_get(unit, port, value);
#endif /* BCM_GREYHOUND_SUPPORT */
            } else {
#if defined(BCM_TRIUMPH3_SUPPORT)
                rv = bcm_tr3_port_extender_type_get(unit, port, value);
#endif /* BCM_TRIUMPH3_SUPPORT */
            }
        }
        break;

    case bcmPortControlNivNameSpace:
    case bcmPortControlExtenderNameSpace:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_niv) ||
            soc_feature(unit, soc_feature_port_extension)) {
            rv = _bcm_esw_port_tab_get(unit, port, NIV_NAMESPACEf, value);
        }
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
        break;

    case bcmPortControlEtagPcpDeSelect:
#if defined(INCLUDE_L3)
        if (soc_feature(unit, soc_feature_port_extension)) {
            if (SOC_IS_GREYHOUND(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
#if defined(BCM_GREYHOUND_SUPPORT)
                rv = bcm_gh_port_etag_pcp_de_source_get(unit, port, value);
#endif /* BCM_GREYHOUND_SUPPORT */
            } else {
#if defined(BCM_TRIUMPH3_SUPPORT)
                rv = bcm_tr3_port_etag_pcp_de_source_get(unit, port, value);
#endif /* BCM_TRIUMPH3_SUPPORT */
            }
        }
#endif /* INCLUDE_L3 */
        break;

    case bcmPortControlEtagPcp:
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_port_extension)) {
            rv = _bcm_esw_port_tab_get(unit, port, ETAG_PCPf, value);
        }
#endif /* BCM_TRIUMPH3_SUPPORT||BCM_GREYHOUND_SUPPORT */
        break;

    case bcmPortControlEtagDe:
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_port_extension)) {
            rv = _bcm_esw_port_tab_get(unit, port, ETAG_DEf, value);
        }
#endif /* BCM_TRIUMPH3_SUPPORT||BCM_GREYHOUND_SUPPORT */
        break;

    case bcmPortControlUseEtagPri:
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_port_extension)) {
            rv = _bcm_esw_port_tab_get(unit, port, PHB_FROM_ETAGf, value);
        }
#endif /* BCM_TRIUMPH3_SUPPORT||BCM_GREYHOUND_SUPPORT */
        break;

    case bcmPortControlUseSubportPktTagPri:
#if defined(BCM_KATANA2_SUPPORT)
         if (soc_feature(unit, soc_feature_lltag)) {
             rv = _bcm_esw_port_tab_get(unit, port, PHB_FROM_LLTAGf, value);
         }
#endif /* BCM_KATANA2_SUPPORT */
         break;

    case bcmPortControlProhibitedDot1p:
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_GREYHOUND_SUPPORT)
        rv = _bcm_esw_port_tab_get(unit, port, PROHIBITED_DOT1Pf, value);
#endif /* BCM_TRIDENT_SUPPORT||BCM_GREYHOUND_SUPPORT */
        break;

    case bcmPortControlFabricSourceKnockout:
        rv = _bcm_esw_port_tab_get(unit, port, REMOVE_HG_HDR_SRC_PORTf,
                                   value);
        break;

    case bcmPortControlPrbsPolynomial:
        rv = soc_phyctrl_control_get(unit, port,
                                     SOC_PHY_CONTROL_PRBS_POLYNOMIAL,
                                     (uint32 *)value);
        break;
    case bcmPortControlPrbsTxEnable:
        rv = soc_phyctrl_control_get(unit, port,
                                     SOC_PHY_CONTROL_PRBS_TX_ENABLE,
                                     (uint32 *)value);
        break;

    case bcmPortControlPrbsRxEnable:
        rv = soc_phyctrl_control_get(unit, port,
                                     SOC_PHY_CONTROL_PRBS_RX_ENABLE,
                                     (uint32 *)value);
        break;

    case bcmPortControlPrbsTxInvertData:
        rv = soc_phyctrl_control_get(unit, port,
                                     SOC_PHY_CONTROL_PRBS_TX_INVERT_DATA,
                                     (uint32 *)value);
        break;

    case bcmPortControlRxEnable:
        rv = _bcm_esw_mac_rx_control(unit, port, 1, value);
        break;
    case bcmPortControlTxEnable:
        if (SOC_REG_IS_VALID(unit, COSMASKr) ||
#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)
            /* Trident2plus/Trident2 uses soc_td2_port_traffic_egr_enable_set */
            SOC_IS_TRIDENT2PLUS(unit) || SOC_IS_TRIDENT2(unit) ||
#endif
#ifdef BCM_APACHE_SUPPORT
            SOC_IS_APACHE(unit) ||
#endif
#ifdef BCM_TRIDENT3_SUPPORT
            SOC_IS_TRIDENT3X(unit) ||
#endif
#ifdef BCM_TOMAHAWK_SUPPORT
            SOC_IS_TOMAHAWKX(unit) ||
#endif
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_HELIX4_SUPPORT)
            (SOC_IS_HELIX4(unit) || SOC_IS_TRIUMPH3(unit)) ||
#endif
            (SOC_REG_IS_VALID(unit, EGRMETERINGCONFIGr) &&
             SOC_REG_IS_VALID(unit, EGRMETERINGBUCKETr))) {
            *value = 1;
            if (PORT(unit, port).flags & _PORT_INFO_STOP_TX) {
                *value = 0;
            }
            rv = SOC_E_NONE;
        }
        break;

    case bcmPortControlL2GreEnable:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_l2gre)
#if defined(BCM_TRIDENT3_SUPPORT)
            || soc_feature(unit, soc_feature_flex_flow)
#endif
            ) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       L2GRE_TERMINATION_ALLOWEDf, value);
        }
#endif /* BCM_TRIUMPH3_SUPPORT */
       break;

    case bcmPortControlL2GreTunnelbasedVpnId:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_l2gre)
#if defined(BCM_TRIDENT3_SUPPORT)
            || soc_feature(unit, soc_feature_flex_flow)
#endif
            ) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       L2GRE_VPNID_LOOKUP_KEY_TYPEf, value);
        }
#endif /* BCM_TRIUMPH3_SUPPORT */
        break;

    case bcmPortControlL2GreDefaultTunnelEnable:
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_l2gre)
#if defined(BCM_TRIDENT3_SUPPORT)
            || soc_feature(unit, soc_feature_flex_flow)
#endif
            ) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       L2GRE_DEFAULT_SVP_ENABLEf, value);
        }
#endif /* BCM_TRIUMPH3_SUPPORT */

       break;

    case bcmPortControlVxlanEnable:
#if defined(BCM_TRIDENT2_SUPPORT)
        if ((soc_feature(unit, soc_feature_vxlan)) ||
            (soc_feature(unit, soc_feature_flex_flow))) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       VXLAN_TERMINATION_ALLOWEDf, value);
        }
#endif /* BCM_TRIDENT2_SUPPORT */
       break;

    case bcmPortControlVxlanTunnelbasedVnId:
#if defined(BCM_TRIDENT2_SUPPORT)
        if ((soc_feature(unit, soc_feature_vxlan)) ||
            (soc_feature(unit, soc_feature_flex_flow))) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       VXLAN_VN_ID_LOOKUP_KEY_TYPEf, value);
        }
#endif /* BCM_TRIDENT2_SUPPORT */
       break;
    case bcmPortControlVxlanVpnAssignmentCriteria:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (soc_feature(unit, soc_feature_vrf_aware_vxlan_termination)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       VXLAN_VN_ID_LOOKUP_KEY_TYPEf, value);
        }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
        break;
    case bcmPortControlVxlanTerminationMatchCriteria:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (soc_feature(unit, soc_feature_vrf_aware_vxlan_termination)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       VXLAN_TERMINATION_LOOKUP_TYPEf, value);
        }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
        break;
    case bcmPortControlVxlanGportAssignmentCriteria:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (soc_feature(unit, soc_feature_vrf_aware_vxlan_termination)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       VXLAN_SVP_ASSIGNMENT_KEY_TYPEf, value);
        }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
        break;
    case bcmPortControlVxlanDefaultTunnelEnable:
#if defined(BCM_TRIDENT2_SUPPORT)
        if ((soc_feature(unit, soc_feature_vxlan)) ||
            (soc_feature(unit, soc_feature_flex_flow))) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       VXLAN_DEFAULT_SVP_ENABLEf, value);
        }
#endif /* BCM_TRIDENT2_SUPPORT */
        break;

#if defined(BCM_TRIUMPH3_SUPPORT) && defined(INCLUDE_REGEX)
    case bcmPortControlRegex:
        rv = _bcm_esw_port_regex_control_get(unit, port, &udp, &tcp, &enable);
        if (enable != 0) {
            *value = 1;
        } else {
            *value = 0;
        }
        break;
    case bcmPortControlRegexTcp:
        rv = _bcm_esw_port_regex_control_get(unit, port, &udp, &tcp, &enable);
        if (tcp != 0) {
            *value = 1;
        } else {
            *value = 0;
        }
        break;
    case bcmPortControlRegexUdp:
        rv = _bcm_esw_port_regex_control_get(unit, port, &udp, &tcp, &enable);
        if (udp != 0) {
            *value = 1;
        } else {
            *value = 0;
        }
        break;
#endif

    case bcmPortControlMplsEntropyHashSet:
#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            return BCM_E_UNAVAIL;
        } else
#endif /* BCM_KATANA2_SUPPORT */
        {
#if defined(BCM_KATANA_SUPPORT)
            if (soc_feature(unit, soc_feature_mpls)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           RTAG7_HASH_CFG_SEL_ENTROPY_LABELf,
                                           value);
            }
#endif /* BCM_KATANA_SUPPORT */
        }
        break;

#ifdef BCM_SHADOW_SUPPORT
    case bcmPortControlManagementPacketIp6Reserved:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = READ_MGMT_FRAME_ENABLEr(unit, port, &val);
        if (BCM_SUCCESS(rv)) {
            *value = soc_reg_field_get(unit, MGMT_FRAME_ENABLEr,
                                       val, IPV6_RESVf);
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlManagementPacketIp4Reserved:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = READ_MGMT_FRAME_ENABLEr(unit, port, &val);
        if (BCM_SUCCESS(rv)) {
            *value = soc_reg_field_get(unit, MGMT_FRAME_ENABLEr,
                                       val, IPV4_RESVf);
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlManagementPacketLinkConstrained:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = READ_MGMT_FRAME_ENABLEr(unit, port, &val);
        if (BCM_SUCCESS(rv)) {
            *value = soc_reg_field_get(unit, MGMT_FRAME_ENABLEr,
                                       val, LINK_CONSTf);
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlManagementPacketGarp:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = READ_MGMT_FRAME_ENABLEr(unit, port, &val);
        if (BCM_SUCCESS(rv)) {
            *value = soc_reg_field_get(unit, MGMT_FRAME_ENABLEr,
                                       val, DOT1D_GARPf);
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlManagementPacketCos:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = READ_COSDP_REMAP_CONTROLr(unit, port, &val);
        if (BCM_SUCCESS(rv)) {
            *value = soc_reg_field_get(unit, COSDP_REMAP_CONTROLr,
                                       val, MGMT_FRAME_COSf);
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlManagementPacketColor:
        rv = BCM_E_UNAVAIL;
        break;
    case bcmPortControlTaggedL3PacketPktPri:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = READ_COSDP_REMAP_CONTROLr(unit, port, &val);
        if (BCM_SUCCESS(rv)) {
            *value = soc_reg_field_get(unit, COSDP_REMAP_CONTROLr,
                                       val, SELECT5f);
            switch (*value) {
            case 0:
                *value = BCM_PORT_COS_REMAP_DSCP;
            break;
            case 1:
                *value = BCM_PORT_COS_REMAP_EXP;
            break;
            case 2:
                *value = BCM_PORT_COS_REMAP_VLAN_PRI;
            break;
            default:
                *value = BCM_PORT_COS_REMAP_VLAN_PRI;
            }
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlTaggedMPLSPacketPktPri:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = READ_COSDP_REMAP_CONTROLr(unit, port, &val);
        if (BCM_SUCCESS(rv)) {
            *value = soc_reg_field_get(unit, COSDP_REMAP_CONTROLr,
                                       val, SELECT3f);
            switch (*value) {
            case 0:
                *value = BCM_PORT_COS_REMAP_DSCP;
            break;
            case 1:
                *value = BCM_PORT_COS_REMAP_EXP;
            break;
            case 2:
                *value = BCM_PORT_COS_REMAP_VLAN_PRI;
            break;
            default:
                *value = BCM_PORT_COS_REMAP_VLAN_PRI;
            }
        }
        PORT_UNLOCK(unit);
        break;
    case bcmPortControlTaggedMPLSL3PacketPktPri:
        if (!SOC_IS_SHADOW(unit)) {
            return BCM_E_UNAVAIL;
        }
        PORT_LOCK(unit);
        rv = READ_COSDP_REMAP_CONTROLr(unit, port, &val);
        if (BCM_SUCCESS(rv)) {
            *value = soc_reg_field_get(unit, COSDP_REMAP_CONTROLr,
                                       val, SELECT7f);
            switch (*value) {
            case 0:
                *value = BCM_PORT_COS_REMAP_DSCP;
            break;
            case 1:
                *value = BCM_PORT_COS_REMAP_EXP;
            break;
            case 2:
                *value = BCM_PORT_COS_REMAP_VLAN_PRI;
            break;
            default:
                *value = BCM_PORT_COS_REMAP_VLAN_PRI;
            }
        }
        PORT_UNLOCK(unit);
        break;
#endif
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    case bcmPortControlFieldEgressClassSelect:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (soc_feature(unit, soc_feature_misc_i2e_hgclass_combo_profile)) {
            rv = _bcm_td2p_port_control_egress_class_select_get(unit, port,
                                                                (uint32 *)value);
        } else
#endif
        {
            rv = _bcm_trx_port_control_egress_class_select_get(unit, port,
                                                               (uint32 *)value);
        }
        break;
#endif
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    case bcmPortControlFieldHiGigClassSelect:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (soc_feature(unit, soc_feature_misc_i2e_hgclass_combo_profile)) {
            rv = _bcm_td2p_port_control_higig_class_select_get(unit, port,
                                                               (uint32 *)value);
        } else
#endif
        {
            rv = _bcm_trx_port_control_higig_class_select_get(unit, port,
                                                              (uint32 *)value);
        }
        break;
#endif
    case bcmPortControlSubportTagEnable:
#if defined (BCM_HGPROXY_COE_SUPPORT)
        if (soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
            soc_feature(unit, soc_feature_channelized_switching)) {
            rv = bcmi_xgs5_port_control_subtag_status_get(unit, port, value);
        }
#endif
#if defined (BCM_KATANA2_SUPPORT)
        if (soc_feature(unit, soc_feature_subtag_coe)) {
            if (SOC_IS_KATANA2(unit)) {
                rv = bcm_kt2_port_control_subtag_status_get(unit, port, value);
            }
        }
#endif
        break;


    case bcmPortControlLinkPhyEnable:
#if defined (BCM_KATANA2_SUPPORT)
        if (soc_feature(unit, soc_feature_linkphy_coe)) {
            if (SOC_IS_KATANA2(unit)) {
                rv = bcm_kt2_port_control_linkphy_status_get(unit, port, value);
            }
        }
#endif
        break;

#if defined(BCM_TRIDENT2_SUPPORT)

    case bcmPortControlFcoeRouteEnable:
        if (soc_feature(unit, soc_feature_fcoe)) {
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                       FCOE_ROUTE_ENABLEf, value);
            } else
#endif
            {
                if (SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_ROUTE_ENABLEf)) {
                     rv = _bcm_esw_port_tab_get(unit, port,
                                                FCOE_ROUTE_ENABLEf, value);
                }
            }
        }
        break;

    case bcmPortControlFcoeVftEnable:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_IS_TRIDENT3X(unit) || SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_VFT_ENABLEf)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           FCOE_VFT_ENABLEf, value);
            }
        }
        break;

    case bcmPortControlFcoeZoneCheckEnable:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_IS_TRIDENT3X(unit) || SOC_MEM_FIELD_VALID(unit, PORT_TABm,
                                    FCOE_ZONE_CHECK_ENABLEf)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           FCOE_ZONE_CHECK_ENABLEf, value);
            }
        }
        break;

    case bcmPortControlFcoeSourceBindCheckEnable:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_MEM_FIELD_VALID(unit, PORT_TABm,
                                    FCOE_SRC_BIND_CHECK_ENABLEf)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           FCOE_SRC_BIND_CHECK_ENABLEf,
                                           value);
            }
        }
        break;

    case bcmPortControlFcoeFpmaPrefixCheckEnable:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_MEM_FIELD_VALID(unit, PORT_TABm,
                                    FCOE_SRC_FPMA_PREFIX_CHECK_ENABLEf)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           FCOE_SRC_FPMA_PREFIX_CHECK_ENABLEf,
                                           value);
            }
        }
        break;

    case bcmPortControlFcoeDoNotLearn:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_IS_TRIDENT3X(unit) || (SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_DO_NOT_LEARNf))) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           FCOE_DO_NOT_LEARNf, value);
            }
        }
        break;

    case bcmPortControlFcoeNetworkPort:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_IS_TRIDENT3X(unit) || (SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_NETWORK_PORTf))) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           FCOE_NETWORK_PORTf, value);
            }
        }
        break;

    case bcmPortControlFcoeFabricSel:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_IS_TRIDENT3X(unit) || SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_FABRIC_SELf)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           FCOE_FABRIC_SELf, value);
            }
        }
        break;

    case bcmPortControlFcoeFabricId:
        if (soc_feature(unit, soc_feature_fcoe)) {
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                    rv = _bcm_esw_port_tab_get(unit, port,
                                           FCOE_FABRIC_IDf, value);
            } else
#endif
            {
                if (SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_FABRIC_IDf)) {
                    rv = _bcm_esw_port_tab_get(unit, port,
                                               FCOE_FABRIC_IDf, value);
                }
            }
        }
        break;

    case bcmPortControlFcoeFabricPri:
        if (soc_feature(unit, soc_feature_fcoe)) {
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           FCOE_FABRIC_PRIf, value);
            } else
#endif
            if (SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_FABRIC_PRIf)) {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           FCOE_FABRIC_PRIf, value);
            }
        }
        break;

    case bcmPortControlFcoeFcCrcAction:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_MEM_FIELD_VALID(unit, EGR_ING_PORTm,
                                    FCOE_FC_CRC_ACTIONf)) {
                egr_ing_port_entry_t egr_ing_port_entry;

                rv = READ_EGR_ING_PORTm(unit, MEM_BLOCK_ANY, port,
                                        &egr_ing_port_entry);
                if (BCM_SUCCESS(rv)) {
                    *value = soc_mem_field32_get(unit, EGR_ING_PORTm,
                                                 &egr_ing_port_entry,
                                                 FCOE_FC_CRC_ACTIONf);
                }
            }
        }
        break;

    case bcmPortControlFcoeFcCrcRecompute:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_MEM_IS_VALID(unit, EGR_PORTm) &&
                SOC_MEM_FIELD_VALID(unit, EGR_PORTm,
                                    FCOE_FC_CRC_RECOMPUTEf)) {
                egr_port_entry_t egr_port_entry;

                rv = READ_EGR_PORTm(unit, MEM_BLOCK_ANY, port,
                                    &egr_port_entry);
                if (BCM_SUCCESS(rv)) {
                    *value = soc_mem_field32_get(unit, EGR_PORTm,
                                                 &egr_port_entry,
                                                 FCOE_FC_CRC_RECOMPUTEf);
                }
            }
        }
        break;

    case bcmPortControlFcoeFcEofIgnore:
        if (soc_feature(unit, soc_feature_fcoe)) {
            if (SOC_MEM_FIELD_VALID(unit, EGR_ING_PORTm,
                                    FCOE_FC_EOF_IGNOREf)) {
                egr_ing_port_entry_t egr_ing_port_entry;

                rv = READ_EGR_ING_PORTm(unit, MEM_BLOCK_ANY, port,
                                        &egr_ing_port_entry);
                if (BCM_SUCCESS(rv)) {
                    *value = soc_mem_field32_get(unit, EGR_ING_PORTm,
                                                 &egr_ing_port_entry,
                                                 FCOE_FC_EOF_IGNOREf);
                }
            }
        }
        break;

    case bcmPortControlFcoeTranslateKeyFirst:
    case bcmPortControlFcoeTranslateKeySecond:
        if (soc_feature(unit, soc_feature_fcoe)) {
            int reg_val;
            int key_type;
            int use_port = 0;
            int vt_port_type;

            if (type == bcmPortControlFcoeTranslateKeyFirst) {
                if (SOC_IS_TRIDENT3X(unit) || SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_VT_KEY_TYPE_1f)) {
                    rv = _bcm_esw_port_tab_get(unit, port,
                                               FCOE_VT_KEY_TYPE_1f, &reg_val);
                }

                if (BCM_SUCCESS(rv)) {
                    rv = _bcm_esw_port_config_get(unit, port,
                                                  _bcmPortVTKeyPortFirst,
                                                 &vt_port_type);
                    if (BCM_SUCCESS(rv)) {
                        if (vt_port_type != 0) {
                            use_port = 1;
                        }
                    }
                }
            } else {
                if (SOC_IS_TRIDENT3X(unit) || SOC_MEM_FIELD_VALID(unit, PORT_TABm, FCOE_VT_KEY_TYPE_2f)) {
                    rv = _bcm_esw_port_tab_get(unit, port,
                                               FCOE_VT_KEY_TYPE_2f, &reg_val);
                }
                if (BCM_SUCCESS(rv)) {
                    rv = _bcm_esw_port_config_get(unit, port,
                                                  _bcmPortVTKeyPortSecond,
                                                 &vt_port_type);
                    if (BCM_SUCCESS(rv)) {
                        if (vt_port_type != 0) {
                            use_port = 1;
                        }
                    }
                }
            }

            if (BCM_SUCCESS(rv)) {
                /* convert register value to common key type */
                rv = _bcm_esw_vlan_xlate_key_type_get(unit, reg_val, &key_type);
                if (!BCM_SUCCESS(rv)) {
                    break;
                }

                /* convert common key type value to
                   bcm_fcoe_vsan_translate_key_t */
                switch (key_type) {
                    case VLXLT_HASH_KEY_TYPE_IVID_OVID:
                        if (use_port) {
                            *value = bcmFcoeVsanTranslateKeyPortDouble;
                        } else {
                            *value = bcmFcoeVsanTranslateKeyDouble;
                        }
                        break;
                    case VLXLT_HASH_KEY_TYPE_OTAG:
                        if (use_port) {
                            *value = bcmFcoeVsanTranslateKeyPortOuterTag;
                        } else {
                            *value = bcmFcoeVsanTranslateKeyOuterTag;
                        }
                        break;
                    case VLXLT_HASH_KEY_TYPE_ITAG:
                        if (use_port) {
                            *value = bcmFcoeVsanTranslateKeyPortInnerTag;
                        } else {
                            *value = bcmFcoeVsanTranslateKeyInnerTag;
                        }
                        break;
                    case VLXLT_HASH_KEY_TYPE_OVID:
                        if (use_port) {
                            *value = bcmFcoeVsanTranslateKeyPortOuter;
                        } else {
                            *value = bcmFcoeVsanTranslateKeyOuter;
                        }
                        break;
                    case VLXLT_HASH_KEY_TYPE_IVID:
                        if (use_port) {
                            *value = bcmFcoeVsanTranslateKeyPortInner;
                        } else {
                            *value = bcmFcoeVsanTranslateKeyInner;
                        }
                        break;
                    case VLXLT_HASH_KEY_TYPE_PRI_CFI:
                        if (use_port) {
                            *value = bcmFcoeVsanTranslateKeyPortOuterPri;
                        } else {
                            *value = bcmFcoeVsanTranslateKeyOuterPri;
                        }
                        break;
                    case VLXLT_HASH_KEY_TYPE_IVID_OVID_VSAN:
                        if (use_port) {
                            *value = bcmFcoeVsanTranslateKeyPortDoubleVsan;
                        } else {
                            *value = bcmFcoeVsanTranslateKeyDoubleVsan;
                        }
                        break;
                    case VLXLT_HASH_KEY_TYPE_IVID_VSAN:
                        if (use_port) {
                            *value = bcmFcoeVsanTranslateKeyPortInnerVsan;
                        } else {
                            *value = bcmFcoeVsanTranslateKeyInnerVsan;
                        }
                        break;
                    case VLXLT_HASH_KEY_TYPE_OVID_VSAN:
                        if (use_port) {
                            *value = bcmFcoeVsanTranslateKeyPortOuterVsan;
                        } else {
                            *value = bcmFcoeVsanTranslateKeyOuterVsan;
                        }
                        break;
                    default:
                        *value = bcmFcoeVsanTranslateKeyInvalid;
                        break;
                }
            }
        } else {
            rv = BCM_E_UNAVAIL;
        }
        break;

    case bcmPortControlFcoeTranslateKeyFirstEgress:
    case bcmPortControlFcoeTranslateKeySecondEgress:
        if (soc_feature(unit, soc_feature_fcoe)) {
            int key_type = -1;

            if (type == bcmPortControlFcoeTranslateKeyFirstEgress) {
                if (SOC_IS_TRIDENT3X(unit) ||
                    SOC_MEM_FIELD_VALID(unit, EGR_PORTm, FCOE_VT_LOOKUP_1f)) {
                    rv = _bcm_esw_egr_port_tab_get(unit, port,
                                                   FCOE_VT_LOOKUP_1f,
                                                   &key_type);
                }
            } else {
                if (SOC_IS_TRIDENT3X(unit) ||
                    SOC_MEM_FIELD_VALID(unit, EGR_PORTm, FCOE_VT_LOOKUP_2f)) {
                    rv = _bcm_esw_egr_port_tab_get(unit, port,
                                                   FCOE_VT_LOOKUP_2f,
                                                   &key_type);
                }
            }

            if (BCM_SUCCESS(rv)) {
                /* convert common key type value to
                   bcm_fcoe_vsan_translate_key_egress_t */
                switch (key_type) {
                    case EGR_VLXLT_HASH_KEY_TYPE_IVID_OVID_VSAN:
                        *value = bcmFcoeVsanTranslateKeyEgressDoubleVsan;
                        break;
                    case EGR_VLXLT_HASH_KEY_TYPE_VSAN:
                        *value = bcmFcoeVsanTranslateKeyEgressVsan;
                        break;
                    case EGR_VLXLT_HASH_KEY_TYPE_IVID_VSAN:
                        *value = bcmFcoeVsanTranslateKeyEgressInnerVsan;
                        break;
                    case EGR_VLXLT_HASH_KEY_TYPE_OVID_VSAN:
                        *value = bcmFcoeVsanTranslateKeyEgressOuterVsan;
                        break;
                    case EGR_VLXLT_HASH_KEY_TYPE_IVID_OVID:
                        *value = bcmFcoeVsanTranslateKeyEgressDouble;
                        break;
                    case EGR_VLXLT_HASH_KEY_TYPE_IVID:
                        *value = bcmFcoeVsanTranslateKeyEgressInner;
                        break;
                    case EGR_VLXLT_HASH_KEY_TYPE_OVID:
                        *value = bcmFcoeVsanTranslateKeyEgressOuter;
                        break;
                    default:
                        *value = bcmFcoeVsanTranslateKeyEgressInvalid;
                        break;
                }
            }
        } else {
            rv = BCM_E_UNAVAIL;
        }
        break;

#endif  /* BCM_TRIDENT2_SUPPORT */
    case bcmPortControlEEEMode:
        if (soc_feature(unit, soc_feature_eee_bb_mode)) {
            uint32 fval = 0;
            uint32 rval = 0;
            uint32 temp = 0;
            if (soc_feature (unit, soc_feature_high_portcount_register)) {
                soc_reg_t eee_bb_reg;
                int phy_port;
                int mmu_port;
                int offset;

                phy_port = SOC_INFO(unit).port_l2p_mapping[port];
                mmu_port = SOC_INFO(unit).port_p2m_mapping[phy_port];
                if (mmu_port < 32) {
                    eee_bb_reg = EEE_BB_ENABLE_0r;
                    offset = mmu_port;
                } else if ((mmu_port >=32) && (mmu_port < 64)) {
                    eee_bb_reg = EEE_BB_ENABLE_1r;
                    offset = mmu_port - 32;
                } else { /* mmu_port >= 64 */
                    eee_bb_reg = EEE_BB_ENABLE_2r;
                    offset = mmu_port - 64;
                }
                temp = (1 << offset);
                BCM_IF_ERROR_RETURN(
                    soc_reg32_get(unit, eee_bb_reg, REG_PORT_ANY, 0, &rval));
                fval = soc_reg_field_get(unit, eee_bb_reg, rval,
                                         EEE_BB_ENABLEf);
                *value = (fval & temp) ? \
                         bcmPortEEEBurstAndBatchMode:bcmPortEEENativeMode;
            } else {
                temp = (1 << port);
                temp >>= 2;
                rv = READ_EEE_BB_ENABLEr(unit, &rval);
                if (BCM_SUCCESS(rv)) {
                    fval = soc_reg_field_get(unit, EEE_BB_ENABLEr, rval,
                                               EEE_BB_ENABLEf);
                    *value = (fval & temp) ? \
                     bcmPortEEEBurstAndBatchMode:bcmPortEEENativeMode;
                }
            }
        }
        break;
#ifdef BCM_GREYHOUND_SUPPORT
        case bcmPortControlWredDropCountUpdateEnableQueueMask:
            if (soc_feature(unit, soc_feature_wred_drop_counter_per_port)) {
#if defined(BCM_GREYHOUND2_SUPPORT)
                if (SOC_IS_GREYHOUND2(unit)) {
                    rv = bcmi_gh2_cosq_wred_port_control_get(unit, port, type,
                                                             value);
                } else
#endif /* BCM_GREYHOUND2_SUPPORT */
                {
                    rv = READ_WRED_DROP_CTR_CONFIGr(unit, port, &val);
                    *value = soc_reg_field_get(unit, WRED_DROP_CTR_CONFIGr,
                                               val, QUEUE_MASKf);
                }
            }
            break;
        case bcmPortControlWredDropCountUpdateEnableColorMask:
            if (soc_feature(unit, soc_feature_wred_drop_counter_per_port)) {
#if defined(BCM_GREYHOUND2_SUPPORT)
                if (SOC_IS_GREYHOUND2(unit)) {
                    rv = bcmi_gh2_cosq_wred_port_control_get(unit, port, type,
                                                             value);
                } else
#endif /* BCM_GREYHOUND2_SUPPORT */
                {
                    uint32 fld_val;
                    rv = READ_WRED_DROP_CTR_CONFIGr(unit, port, &val);
                    if (BCM_SUCCESS(rv)) {
                        fld_val = soc_reg_field_get(unit, WRED_DROP_CTR_CONFIGr,
                                                    val, COLOR_MASKf);
                        *value = 0;
                        if (fld_val & 0x4) {
                            *value |= (0x1 << bcmColorGreen);
                        }
                        if (fld_val & 0x2) {
                            *value |= (0x1 << bcmColorYellow);
                        }
                        if (fld_val & 0x1) {
                            *value |= (0x1 << bcmColorRed);
                        }
                    }
                }
            }
            break;
#endif /* BCM_GREYHOUND_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    case bcmPortControlProbeSerdesReset:
        if (SOC_IS_TD2_TT2(unit)) {
            *value =
                PORT(unit, port).flags & _PORT_INFO_PROBE_RESET_SERDES ?
                1 : 0;
            rv = BCM_E_NONE;
        }
        break;
#endif /* BCM_TRIDENT2_SUPPORT */
        case bcmPortControlMmuTrafficEnable:
            rv = bcm_esw_port_enqueue_get(unit, port, value);
            break;
    case bcmPortControlRxFastLOS:
        rv = _bcm_esw_link_fast_get(unit, port, value);
        break;
    case bcmPortControlLLFCReceive:
    case bcmPortControlLLFCTransmit:
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    case bcmPortControlSAFCReceive:
    case bcmPortControlSAFCTransmit:
#endif
        rv = _bcm_esw_port_llfc_get(unit, port, type, value);
        break;
    case bcmPortControlTrunkLoadBalancingRandomizer:
#ifdef BCM_TOMAHAWK_SUPPORT
        if (soc_feature(unit, soc_feature_randomized_load_balance)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       OFFSET_TRUNK_RANDOM_LBf, value);
        }
#endif /* BCM_TOMAHAWK_SUPPORT */
        break;
    case bcmPortControlECMPLevel1LoadBalancingRandomizer:
#ifdef BCM_TOMAHAWK_SUPPORT
        if (soc_feature(unit, soc_feature_ecmp_random)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       OFFSET_ECMP_RANDOM_LBf , value);
        }
#endif /* BCM_TOMAHAWK_SUPPORT */
        break;
    case bcmPortControlECMPLevel2LoadBalancingRandomizer:
#ifdef BCM_TOMAHAWK_SUPPORT
        if (soc_feature(unit, soc_feature_ecmp_random)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       OFFSET_ECMP_LEVEL2_RANDOM_LBf,
                                       value);
        }
#endif /* BCM_TOMAHAWK_SUPPORT */
        break;
    case bcmPortControlMcastGroupRemap:
       if (SOC_MEM_FIELD_VALID(unit, SOURCE_VPm, NETWORK_PORTf)) {
           SOC_IF_ERROR_RETURN
               (READ_SOURCE_VPm(unit, MEM_BLOCK_ANY, port, &svp_entry));
           *value = soc_SOURCE_VPm_field32_get(unit, &svp_entry,
                                               NETWORK_PORTf);
           rv = BCM_E_NONE;
       }
       break;
    case bcmPortControlOOBFCTxReportIngEnable:
        if (soc_feature(unit, soc_feature_oob_fc)) {
#ifdef BCM_TOMAHAWK_SUPPORT
            if (SOC_IS_TOMAHAWKX(unit)) {
                rv = _bcm_th_oob_fc_tx_port_control_get(unit, port, value, 0);
            }
#endif
#ifdef BCM_KATANA2_SUPPORT
            if (SOC_IS_KATANA2(unit)) {
                rv = _bcm_kt2_oob_fc_tx_port_control_get(unit, port, value, 0);
            }
#endif
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_td3_oob_fc_tx_port_control_get(unit, port, value, 0);
            }
#endif
#ifdef BCM_APACHE_SUPPORT
            if (SOC_IS_APACHE(unit) && !SOC_IS_MONTEREY(unit)) {
                rv = _bcm_ap_oob_fc_tx_port_control_get(unit, port, value, 0);
            }
#endif
        }
        break;
    case bcmPortControlOOBFCTxReportEgrEnable:
        if (soc_feature(unit, soc_feature_oob_fc)) {
#ifdef BCM_TOMAHAWK_SUPPORT
            if (SOC_IS_TOMAHAWKX(unit)) {
                rv = _bcm_th_oob_fc_tx_port_control_get(unit, port, value, 1);
            }
#endif
#ifdef BCM_APACHE_SUPPORT
            if (SOC_IS_APACHE(unit) && !SOC_IS_MONTEREY(unit)) {
                rv = _bcm_ap_oob_fc_tx_port_control_get(unit, port, value, 1);
            }
#endif
#ifdef BCM_KATANA2_SUPPORT
            if (SOC_IS_KATANA2(unit)) {
                rv = _bcm_kt2_oob_fc_tx_port_control_get(unit, port, value, 1);
            }
#endif
#ifdef BCM_TRIDENT3_SUPPORT
            if (SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_td3_oob_fc_tx_port_control_get(unit, port, value, 1);
            }
#endif
        }
        break;

	case bcmPortControlSubportTagSize:
#ifdef BCM_HGPROXY_COE_SUPPORT
          if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm,
                                  DESTINATION_SUBPORT_TAG_TYPEf)) {

              int local_port = 0;
			  egr_port_entry_t  egr_port_entry;
              if (BCM_GPORT_IS_SET(port)) {
                  BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, port, &local_port));
              } else {
                  if(!SOC_PORT_VALID(unit, port)) {
                      return BCM_E_PORT;
                  } else {
                      local_port = port;
                  }
              }

              SOC_IF_ERROR_RETURN
                  (READ_EGR_PORTm(unit, MEM_BLOCK_ANY, local_port, &egr_port_entry));
              *value = soc_EGR_PORTm_field32_get(unit, &egr_port_entry,
                                                  DESTINATION_SUBPORT_TAG_TYPEf);
              rv = BCM_E_NONE;
          }
          if (SOC_IS_TRIDENT3X(unit)) {
              *value = 0;
              rv = BCM_E_NONE;
          }
#endif
		  break;

	case bcmPortControlSystemPortOverride:
#ifdef BCM_HGPROXY_COE_SUPPORT
          if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm,
                                  VT_SYS_PORT_OVERRIDEf)) {

              rv = bcmi_xgs5_subport_subtag_port_override_get(unit, port,
                                                              value);
          }
#endif
          break;
#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
    case bcmPortControlSampleIngressDest:
        if(soc_feature(unit, soc_feature_sflow_ing_mem)) {
            sflow_ing_data_source_entry_t sflow_entry;
            uint32 field_values[2] = {0, 0};
            BCM_IF_ERROR_RETURN
                (READ_SFLOW_ING_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                             &sflow_entry));
            soc_SFLOW_ING_DATA_SOURCEm_field_get(unit, &sflow_entry,
                                                 CPUf, &field_values[0]);
            soc_SFLOW_ING_DATA_SOURCEm_field_get(unit, &sflow_entry,
                                                 MIRRORf, &field_values[1]);
            *value = field_values[0] | (field_values[1] << 1);
            rv = BCM_E_NONE;
        }
        break;
    case bcmPortControlSampleFlexDest:
        if(soc_feature(unit, soc_feature_sflow_flex)) {
            sflow_ing_flex_data_source_entry_t sflow_entry;
            uint32 field_values[2] = {0, 0};
            BCM_IF_ERROR_RETURN
                (READ_SFLOW_ING_FLEX_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                                  &sflow_entry));
            soc_SFLOW_ING_FLEX_DATA_SOURCEm_field_get(unit, &sflow_entry,
                                                      CPUf, &field_values[0]);
            soc_SFLOW_ING_FLEX_DATA_SOURCEm_field_get(unit, &sflow_entry,
                                                      MIRRORf, &field_values[1]);
            *value = field_values[0] | (field_values[1] << 1);
            rv = BCM_E_NONE;
        }
        break;
    case bcmPortControlSampleFlexRate:
        if(soc_feature(unit, soc_feature_sflow_flex)) {
            sflow_ing_flex_data_source_entry_t sflow_entry;
            uint32 field_enable, field_thresh;

            /* Read ENABLE and THRESHOLD fields from flex rate data table */
            BCM_IF_ERROR_RETURN
                (READ_SFLOW_ING_FLEX_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                                  &sflow_entry));
            soc_SFLOW_ING_FLEX_DATA_SOURCEm_field_get(unit, &sflow_entry,
                                                      ENABLEf, &field_enable);
            soc_SFLOW_ING_FLEX_DATA_SOURCEm_field_get(unit, &sflow_entry,
                                                      THRESHOLDf,
                                                      &field_thresh);

            if (field_enable) {
                if (field_thresh) {
                    *value = (1 << (SFLOW_RANGE_MAX(unit))) / field_thresh;
                } else {
                    *value = 1 << (SFLOW_RANGE_MAX(unit));
                }
            } else {
                *value = 0;
                if (field_thresh) {
                    return BCM_E_INTERNAL;
                }
            }
            rv = BCM_E_NONE;
        }
        break;
#endif /* BCM_TOMAHAWK_SUPPORT || BCM_TRIDENT3_SUPPORT */
#ifdef BCM_XGS3_SWITCH_SUPPORT
    case bcmPortControlSampleIngressEnable:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            uint32 regval       = 0;
            uint32 field_enable = 0;
#ifdef BCM_TOMAHAWK_SUPPORT
            sflow_ing_data_source_entry_t sflow_entry;
#endif /* BCM_TOMAHAWK_SUPPORT */

#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
            if (soc_feature(unit, soc_feature_sflow_ing_mem)) {
                BCM_IF_ERROR_RETURN(
                    READ_SFLOW_ING_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                                &sflow_entry));

                soc_SFLOW_ING_DATA_SOURCEm_field_get(unit, &sflow_entry, ENABLEf,
                                             &field_enable);
            } else
#endif /* BCM_TOMAHAWK_SUPPORT || BCM_TRIDENT3_SUPPORT */
            {
                if (!SOC_REG_IS_VALID(unit, SFLOW_ING_THRESHOLDr)) {
                    return BCM_E_UNAVAIL;
                }
                BCM_IF_ERROR_RETURN(READ_SFLOW_ING_THRESHOLDr(unit, port, &regval));
                field_enable = soc_reg_field_get(unit, SFLOW_ING_THRESHOLDr, regval,
                                                         ENABLEf);
            }

            *value = field_enable ? 1 : 0;
            rv = BCM_E_NONE;
        } else {
            rv = BCM_E_UNAVAIL;
        }
        break;
    case bcmPortControlSampleEgressEnable:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            uint32 regval       = 0;
            uint32 field_enable = 0;

            if (!SOC_REG_IS_VALID(unit, SFLOW_EGR_THRESHOLDr)) {
                return BCM_E_UNAVAIL;
            }
            BCM_IF_ERROR_RETURN(READ_SFLOW_EGR_THRESHOLDr(unit, port, &regval));
            field_enable = soc_reg_field_get(unit, SFLOW_EGR_THRESHOLDr, regval,
                                                    ENABLEf);

            *value = field_enable ? 1 : 0;
            rv = BCM_E_NONE;
        } else {
            rv = BCM_E_UNAVAIL;
        }
        break;
    case bcmPortControlSampleIngressRate:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            uint32 regval       = 0;
            uint32 field_value;
#ifdef BCM_TOMAHAWK_SUPPORT
            sflow_ing_data_source_entry_t sflow_entry;
#endif /* BCM_TOMAHAWK_SUPPORT */

#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT3_SUPPORT)
            if (soc_feature(unit, soc_feature_sflow_ing_mem)) {
                BCM_IF_ERROR_RETURN(
                    READ_SFLOW_ING_DATA_SOURCEm(unit, MEM_BLOCK_ANY, port,
                                                &sflow_entry));

                soc_SFLOW_ING_DATA_SOURCEm_field_get(unit, &sflow_entry, THRESHOLDf,
                                             &field_value);
            } else
#endif /* BCM_TOMAHAWK_SUPPORT || BCM_TRIDENT3_SUPPORT */
            {
                if (!SOC_REG_IS_VALID(unit, SFLOW_ING_THRESHOLDr)) {
                    return BCM_E_UNAVAIL;
                }
                BCM_IF_ERROR_RETURN(READ_SFLOW_ING_THRESHOLDr(unit, port, &regval));

                field_value = soc_reg_field_get(unit, SFLOW_ING_THRESHOLDr,
                                                     regval, THRESHOLDf);
            }

            /*
             * For early sFlow implementations the 16-bit threshold value
             * is compared to bits [23:8] of the sFlow random number.
             */
            if (soc_feature(unit, soc_feature_sample_offset8)) {
                field_value <<= 8;
            }

            if (field_value) {
                *value = (1 << (SFLOW_RANGE_MAX(unit))) / field_value;
            } else {
                *value = 0;
            }
            rv = BCM_E_NONE;
        } else {
            rv = BCM_E_UNAVAIL;
        }
        break;
    case bcmPortControlSampleEgressRate:
        if (SOC_IS_XGS3_SWITCH(unit)) {
            uint32 regval;
            uint32 field_value;

            if (!SOC_REG_IS_VALID(unit, SFLOW_EGR_THRESHOLDr)) {
                return BCM_E_UNAVAIL;
            }
            BCM_IF_ERROR_RETURN(READ_SFLOW_EGR_THRESHOLDr(unit, port, &regval));

            field_value = soc_reg_field_get(unit, SFLOW_EGR_THRESHOLDr,
                                                    regval, THRESHOLDf);

            /*
             * For early sFlow implementations the 16-bit threshold value
             * is compared to bits [23:8] of the sFlow random number.
             */
            if (soc_feature(unit, soc_feature_sample_offset8)) {
                field_value <<= 8;
            }

            if (field_value) {
                *value = (1 << (SFLOW_RANGE_MAX(unit))) / field_value;
            } else {
                *value = 0;
            }
            rv = BCM_E_NONE;
        } else {
            rv = BCM_E_UNAVAIL;
        }
        break;
#endif
    case bcmPortControlExternalBufferEnable:
#if defined(BCM_KATANA2_SUPPORT)
          if (SOC_IS_KATANA2(unit) && soc_feature(unit, soc_feature_ddr3)) {
              rv = _bcm_kt2_cosq_port_ext_buf_get(unit, port, value);
          }
#endif
        break;
#ifdef BCM_HURRICANE3_SUPPORT
    case bcmPortControlTrustMimlPri:
        if (soc_feature(unit, soc_feature_miml)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       USE_MIML_PCP_FOR_PRIf, value);
        }
        break;
    case bcmPortControlTrustCustomHeaderPri:
        if (soc_feature(unit, soc_feature_custom_header)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       USE_CUSTOM_HEADER_FOR_PRIf, value);
        }
        break;
    case bcmPortControlCustomHeaderEncapEnable:
        if (soc_feature(unit, soc_feature_custom_header)) {
            uint64 val64;

            rv = READ_EGR_PORT_64r(unit, port, &val64);
            if (BCM_SUCCESS(rv)) {
                *value = soc_reg64_field32_get(unit, EGR_PORT_64r,
                                        val64, CUSTOM_HEADER_ENABLEf);
            }
        }
        break;
#endif /* BCM_HURRICANE3_SUPPORT */
    case bcmPortControl1588P2PDelay:
        {
            uint32 link_delay;
            int mac_rx_latency = 0;
            int speed;
            rv = bcm_esw_port_speed_get(unit, port, &speed);
            soc_property_port_get(unit, port,
                                              spn_LINK_DELAY(speed), mac_rx_latency);

            if (SOC_REG_PORT_VALID(unit, EGR_1588_LINK_DELAYr, port)) {
                soc_reg32_get(unit, EGR_1588_LINK_DELAYr,
                                        port, LINK_DELAYf, &link_delay);
                *value = link_delay - mac_rx_latency;
                rv =  BCM_E_NONE;
            } else if (SOC_REG_PORT_VALID(unit, EGR_1588_LINK_DELAY_64r, port)) {
                soc_reg_above_64_field32_read(unit, EGR_1588_LINK_DELAY_64r,
                                            port, 0, LINK_DELAYf, &link_delay);
                *value = link_delay - mac_rx_latency;
                rv =  BCM_E_NONE;
            } else {
                rv = BCM_E_UNAVAIL;
                /* No LINK_DELAY register, so no-op */
            }
        }
        break;
    case bcmPortControlPacketTimeStampInsertRx:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp)) {
            int ing_insert;
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

            BCM_IF_ERROR_RETURN(
                _bcm_esw_port_tab_get(unit, port, INSERT_RX_TIMESTAMPf,
                                      &ing_insert));
            *value = ing_insert;
            rv = BCM_E_NONE;
        }
#endif
        break;
    case bcmPortControlPacketTimeStampInsertTx:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp)) {
            uint32 regval;
            uint32 egr_insert;
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

            BCM_IF_ERROR_RETURN(READ_EGR_TS_CONTROLr(unit, port, &regval));
            egr_insert = soc_reg_field_get(unit, EGR_TS_CONTROLr, regval,
                                           INSERT_TX_TIMESTAMPf);
            *value = (int)egr_insert;
            rv = BCM_E_NONE;
        }
#endif
        break;
    case bcmPortControlPacketTimeStampSrcPortInsertCancel:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp)) {
            int ing_disable;
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

            BCM_IF_ERROR_RETURN(
                _bcm_esw_port_tab_get(unit, port, DISABLE_TIMESTAMPINGf,
                                      &ing_disable));
            *value = ing_disable;
            rv = BCM_E_NONE;
        }
#endif
        break;
    case bcmPortControlPacketTimeStampDestPortInsertCancel:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp)) {
            uint32 regval;
            uint32 egr_disable;
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

            BCM_IF_ERROR_RETURN(READ_EGR_TS_CONTROLr(unit, port, &regval));
            egr_disable = soc_reg_field_get(unit, EGR_TS_CONTROLr, regval,
                                            DISABLE_TIMESTAMPINGf);
            *value = (int)egr_disable;
            rv = BCM_E_NONE;
        }
#endif
        break;
    case bcmPortControlPacketTimeStampRxId:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp)) {
            uint32 regval;
            egr_ts_ing_port_map_entry_t egr_ts_entry;
            uint32 id;
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
            if (SOC_REG_IS_VALID(unit, EGR_TS_ING_PORT_MAPr)) {
                BCM_IF_ERROR_RETURN(READ_EGR_TS_ING_PORT_MAPr(unit, port, &regval));
                id = soc_reg_field_get(unit, EGR_TS_ING_PORT_MAPr, regval,
                                           TS_RX_ORIGIN_IDf);
                *value = (int)id;
            } else {

                BCM_IF_ERROR_RETURN(
                      READ_EGR_TS_ING_PORT_MAPm(unit, MEM_BLOCK_ANY, port, &egr_ts_entry));
                soc_EGR_TS_ING_PORT_MAPm_field_get(unit, &egr_ts_entry, TS_RX_ORIGIN_IDf,
                                               &regval);
                *value = (int)regval;

            }
            rv = BCM_E_NONE;
       }
#endif
       break;
    case bcmPortControlPacketTimeStampTxId:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp)) {
            uint32 regval;
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

            if (soc_reg_field_valid(unit, EGR_TS_CONTROL_2r, TS_TX_ORIGIN_IDf))
            {
                BCM_IF_ERROR_RETURN(
                            READ_EGR_TS_CONTROL_2r(unit, port, &regval));
                *value = soc_reg_field_get(
                            unit, EGR_TS_CONTROL_2r, regval, TS_TX_ORIGIN_IDf);
            } else {
                BCM_IF_ERROR_RETURN(READ_EGR_TS_CONTROLr(unit, port, &regval));
                *value = soc_reg_field_get(
                            unit, EGR_TS_CONTROLr, regval, TS_TX_ORIGIN_IDf);
            }
            rv = BCM_E_NONE;
        }
#endif
        break;
    case bcmPortControlPacketTimeStampByteMeterAdjust:
#if defined(BCM_TOMAHAWK2_SUPPORT) || \
    defined(BCM_TRIDENT3_SUPPORT) || defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_timestamp) && !SOC_IS_TOMAHAWK3(unit))
        {
            uint32 regval;
            BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

            BCM_IF_ERROR_RETURN(READ_EGR_TS_CONTROLr(unit, port, &regval));
            *value = soc_reg_field_get(unit, EGR_TS_CONTROLr, regval,
                                       TS_ADJUST_METERSf);
            rv = BCM_E_NONE;
        }
#endif
        break;
    case bcmPortControlE2EFCTransmitEnable:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 fval;
            uint64 val;

            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
                BCM_IF_ERROR_RETURN(READ_E2EFC_IBP_ENr(unit, &fval));
                *value = fval;
            } else
#endif
            if (IS_XL_PORT(unit, port)) {
                BCM_IF_ERROR_RETURN(READ_XLMAC_E2E_CTRLr(unit, port, &val));
                fval = soc_reg64_field32_get(unit, XLMAC_E2E_CTRLr,
                                             val, E2E_ENABLEf);
                *value = fval;
            } else if (IS_CL_PORT(unit, port)) {
                BCM_IF_ERROR_RETURN(READ_CLMAC_E2E_CTRLr(unit, port, &val));
                fval = soc_reg64_field32_get(unit, CLMAC_E2E_CTRLr,
                                             val, E2E_ENABLEf);
                *value = fval;
            } else {
                return BCM_E_PARAM;
            }

            rv = BCM_E_NONE;
        }
        break;
    case bcmPortControlE2EFCReceiveEnable:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val, fval;

            BCM_IF_ERROR_RETURN(READ_IE2E_CONTROLr(unit, port, &val));
            fval = soc_reg_field_get(unit, IE2E_CONTROLr,
                                     val, IBP_ENABLEf);
            *value = fval;
            rv = BCM_E_NONE;
        }
        break;
    case bcmPortControlE2EFCCopyToCpuEnable:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val, fval;

            BCM_IF_ERROR_RETURN(READ_IE2E_CONTROLr(unit, port, &val));
            fval = soc_reg_field_get(unit, IE2E_CONTROLr,
                                     val, IBP_TOCPUf);
            *value = fval;
            rv = BCM_E_NONE;
        }
        break;
    /* Higher 3 bytes of Destination MAC address */
    case bcmPortControlE2EFCDestMacOui:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val_hi;
            uint64 val_64, data_0;
            soc_reg_t reg;
#if defined(BCM_KATANA2_SUPPORT)
            uint32 val;
#endif
            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
#if defined(BCM_SABER2_SUPPORT)
                if (SOC_IS_SABER2(unit)) {
                    /* Do nothing */
                } else
#endif /* BCM_SABER2_SUPPORT */
              {
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D0r, port, 0, &val));
                    val_hi = soc_reg_field_get(unit, XIBP_D0r, val, DATA_BYTES_0_3f);
                    *value = (val_hi >> 8) & 0xffffff;
                    rv = BCM_E_NONE;
                    break;
               }
           }
#endif /* BCM_KATANA2_SUPPORT */
            if (IS_XL_PORT(unit, port)) {
                reg = XLMAC_E2EFC_DATA_HDR_0r;
            } else if (IS_CL_PORT(unit, port)) {
                reg = CLMAC_E2EFC_DATA_HDR_0r;
            } else {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg,
                                            port, 0, &val_64));
            data_0 = soc_reg64_field_get(unit, reg,
                                         val_64, E2EFC_DATA_HDR_0f);
            COMPILER_64_TO_32_HI(val_hi, data_0);
            *value = (val_hi >> 8) & 0xffffff;
            rv = BCM_E_NONE;
        }
        break;
    /* Lower 3 bytes of Destination MAC address */
    case bcmPortControlE2EFCDestMacNonOui:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val_lo, val_hi;
            uint64 val_64, data_0;
            soc_reg_t reg;
#if defined(BCM_KATANA2_SUPPORT)
            uint32 val;
#endif
            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
#if defined(BCM_SABER2_SUPPORT)
                if (SOC_IS_SABER2(unit)) {
                    /* Do nothing */
                } else
#endif /* BCM_SABER2_SUPPORT */
              {
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D0r, port, 0, &val));
                    val_hi = soc_reg_field_get(unit, XIBP_D0r, val, DATA_BYTES_0_3f);
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D1r, port, 0, &val));
                    val_lo = soc_reg_field_get(unit, XIBP_D1r, val, DATA_BYTES_4_7f);
                    *value = ((val_hi & 0xff) << 16) | ((val_lo >> 16) & 0xffff);
                    rv = BCM_E_NONE;
                    break;
               }
           }
#endif /* BCM_KATANA2_SUPPORT */
            if (IS_XL_PORT(unit, port)) {
                reg = XLMAC_E2EFC_DATA_HDR_0r;
            } else if (IS_CL_PORT(unit, port)) {
                reg = CLMAC_E2EFC_DATA_HDR_0r;
            } else {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg,
                                            port, 0, &val_64));
            data_0 = soc_reg64_field_get(unit, reg,
                                         val_64, E2EFC_DATA_HDR_0f);
            COMPILER_64_TO_32_LO(val_lo, data_0);
            COMPILER_64_TO_32_HI(val_hi, data_0);
            *value = ((val_hi & 0xff) << 16) | ((val_lo >> 16) & 0xffff);
            rv = BCM_E_NONE;
        }
        break;
    /* Higher 3 bytes of Source MAC address */
    case bcmPortControlE2EFCSrcMacOui:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val_0_lo, val_1_hi;
            uint64 val_64, data_1, data_0;
            soc_reg_t reg_0, reg_1;
#if defined(BCM_KATANA2_SUPPORT)
            uint32 val;
#endif
            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
#if defined(BCM_SABER2_SUPPORT)
                if (SOC_IS_SABER2(unit)) {
                    /* Do nothing */
                } else
#endif /* BCM_SABER2_SUPPORT */
              {
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D1r, port, 0, &val));
                    val_0_lo = soc_reg_field_get(unit, XIBP_D1r, val, DATA_BYTES_4_7f);
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D2r, port, 0, &val));
                    val_1_hi = soc_reg_field_get(unit, XIBP_D2r, val, DATA_BYTES_8_11f);
                    *value = ((val_1_hi >> 24) & 0xff) | ((val_0_lo & 0xffff) << 8);
                    rv = BCM_E_NONE;
                   break;
               }
           }
#endif /* BCM_KATANA2_SUPPORT */
            if (IS_XL_PORT(unit, port)) {
                reg_0 = XLMAC_E2EFC_DATA_HDR_0r;
                reg_1 = XLMAC_E2EFC_DATA_HDR_1r;
            } else if (IS_CL_PORT(unit, port)) {
                reg_0 = CLMAC_E2EFC_DATA_HDR_0r;
                reg_1 = CLMAC_E2EFC_DATA_HDR_1r;
            } else {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg_1,
                                            port, 0, &val_64));
            data_1 = soc_reg64_field_get(unit, reg_1,
                                         val_64, E2EFC_DATA_HDR_1f);
            COMPILER_64_TO_32_HI(val_1_hi, data_1);
            /* SA MAC setting across 2 registers */
            COMPILER_64_ZERO(val_64);
            BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg_0,
                                            port, 0, &val_64));
            data_0 = soc_reg64_field_get(unit, reg_0,
                                         val_64, E2EFC_DATA_HDR_0f);
            COMPILER_64_TO_32_LO(val_0_lo, data_0);
            *value = ((val_1_hi >> 24) & 0xff) | ((val_0_lo & 0xffff) << 8);
            rv = BCM_E_NONE;
        }
        break;
    /* Lower 3 bytes of Source MAC address */
    case bcmPortControlE2EFCSrcMacNonOui:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val_hi;
            uint64 val_64, data_1;
            soc_reg_t   reg;
#if defined(BCM_KATANA2_SUPPORT)
            uint32 val;
#endif
            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
#if defined(BCM_SABER2_SUPPORT)
               if (SOC_IS_SABER2(unit)) {
                    /* Do nothing */
                } else
#endif /* BCM_SABER2_SUPPORT */
               {
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D2r, port, 0, &val));
                    val_hi = soc_reg_field_get(unit, XIBP_D2r, val, DATA_BYTES_8_11f);
                    *value = val_hi & 0xffffff;
                    rv = BCM_E_NONE;
                    break;
               }
            }
#endif /* BCM_KATANA2_SUPPORT */

            if (IS_XL_PORT(unit, port)) {
                reg = XLMAC_E2EFC_DATA_HDR_1r;
            } else if (IS_CL_PORT(unit, port)) {
                reg = CLMAC_E2EFC_DATA_HDR_1r;
            } else {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg,
                                            port, 0, &val_64));
            data_1 = soc_reg64_field_get(unit, reg,
                                         val_64, E2EFC_DATA_HDR_1f);
            COMPILER_64_TO_32_HI(val_hi, data_1);
            *value = val_hi & 0xffffff;
            rv = BCM_E_NONE;
        }
        break;
    case bcmPortControlE2EFCEtherType:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val_lo;
            uint64 val_64, data_1;
            soc_reg_t reg;
#if defined(BCM_KATANA2_SUPPORT)
            uint32 val;
#endif
            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
#if defined(BCM_SABER2_SUPPORT)
               if (SOC_IS_SABER2(unit)) {
                    /* Do nothing */
                } else
#endif /* BCM_SABER2_SUPPORT */
               {
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D3r, port, 0, &val));
                    val_lo = soc_reg_field_get(unit, XIBP_D3r, val, D_BYTES_12_15f);
                    *value = (val_lo >> 16) & 0xffff;
                    rv = BCM_E_NONE;
                    break;
               }
            }
#endif /* BCM_KATANA2_SUPPORT */
            if (IS_XL_PORT(unit, port)) {
                reg = XLMAC_E2EFC_DATA_HDR_1r;
            } else if (IS_CL_PORT(unit, port)) {
                reg = CLMAC_E2EFC_DATA_HDR_1r;
            } else {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN(
                soc_reg_get(unit, reg, port, 0, &val_64));
                data_1 = soc_reg64_field_get(unit, reg,
                                             val_64, E2EFC_DATA_HDR_1f);
            COMPILER_64_TO_32_LO(val_lo, data_1);
            *value = (val_lo >> 16) & 0xffff;
            rv = BCM_E_NONE;
        }
        break;
    case bcmPortControlE2EFCOpcode:
        if (soc_feature(unit, soc_feature_e2efc)) {
            uint32 val_lo;
            uint64 val_64, data_1;
            soc_reg_t reg;
#if defined(BCM_KATANA2_SUPPORT)
            uint32 val;
#endif
            if (!IS_HG_PORT(unit, port)) {
                LOG_ERROR(
                    BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Error: unit %d port %d is not a Higig port. "
                                "E2EFC messages can only be transmitted to "
                                "or received from Higig ports.\n"),
                     unit, port));
                return BCM_E_PARAM;
            }
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
#if defined(BCM_SABER2_SUPPORT)
               if (SOC_IS_SABER2(unit)) {
                    /* Do nothing */
                } else
#endif /* BCM_SABER2_SUPPORT */
               {
                    BCM_IF_ERROR_RETURN(soc_reg32_get(unit, XIBP_D3r, port, 0, &val));
                    val_lo = soc_reg_field_get(unit, XIBP_D3r, val, D_BYTES_12_15f);
                    *value = val_lo & 0xffff;
                    rv = BCM_E_NONE;
                    break;
               }
            }
#endif /* BCM_KATANA2_SUPPORT */
            if (IS_XL_PORT(unit, port)) {
                reg = XLMAC_E2EFC_DATA_HDR_1r;
            } else if (IS_CL_PORT(unit, port)) {
                reg = CLMAC_E2EFC_DATA_HDR_1r;
            } else {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN(soc_reg_get(unit, reg,
                                            port, 0, &val_64));
            data_1 = soc_reg64_field_get(unit, reg,
                                         val_64, E2EFC_DATA_HDR_1f);
            COMPILER_64_TO_32_LO(val_lo, data_1);
            *value = val_lo & 0xffff;
            rv = BCM_E_NONE;
        }
        break;
    case bcmPortControlIntEnable:
#if defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_inband_network_telemetry)) {
            rv = _bcm_esw_port_tab_get(unit, port, INT_ENABLEf, value);
        }
#endif
        break;
    case bcmPortControlIntTurnaround:
#if defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_inband_network_telemetry)) {
            SOC_IF_ERROR_RETURN
                (READ_INT_TURNAROUND_EN_BMAPm(unit, MEM_BLOCK_ANY, 0,
                                     &int_turnaround_en_bmap_entry));
            soc_mem_pbmp_field_get(unit, INT_TURNAROUND_EN_BMAPm,
                           &int_turnaround_en_bmap_entry, PORT_BITMAPf, &pbmp);
            *value = 0;
            if (SOC_PBMP_MEMBER(pbmp, port)) {
                *value = 1;
            }

            rv = BCM_E_NONE;
        }
#endif
        break;
    case bcmPortControlObmClassifierPriority:
    case bcmPortControlObmClassifierEnableDscp:
    case bcmPortControlObmClassifierEnableMpls:
    case bcmPortControlObmClassifierEnableEtag:
    case bcmPortControlObmClassifierEtagEthertype:
    case bcmPortControlObmClassifierVntagEthertype:

#if defined(BCM_MONTEREY_SUPPORT)
        if (SOC_IS_MONTEREY(unit)) {
            rv = bcm_mn_obm_classifier_port_control_get(unit, port, type, value);
        } else
#endif
#if defined(BCM_APACHE_SUPPORT)
        if (SOC_IS_APACHE(unit)) {
            rv = bcm_apache_obm_classifier_port_control_get(unit, port, type, value);
        } else
#endif
#if defined(BCM_HELIX5_SUPPORT)
        if (SOC_IS_HELIX5(unit)) {
            rv = bcm_hx5_obm_classifier_port_control_get(unit, port, type, value);
        } else
#endif
#if defined(BCM_TRIDENT3_SUPPORT)
        if (soc_feature(unit, soc_feature_td3_style_obm_classifier_map)) {
            rv = bcm_td3_obm_classifier_port_control_get(unit, port, type, value);
        } else
#endif
        {
            rv = BCM_E_UNAVAIL;
        }
        break;
    case bcmPortControlObmClassifierInternal:
#if defined(BCM_MONTEREY_SUPPORT)
        if (SOC_IS_MONTEREY(unit)) {
            rv = bcm_mn_obm_classifier_port_control_get(unit, port, type, value);
        } else
#endif
        {
            rv = BCM_E_UNAVAIL;
        }
        break;

   case bcmPortControlWirelessCosMapSelect:
#if defined(BCM_HELIX5_SUPPORT)
        if (SOC_IS_HELIX5(unit) || SOC_IS_HURRICANE4(unit)) {
            rv = _bcm_esw_port_tab_get(unit, port, WIRED_WIRELESSf, value);
        } else
#endif
        {
           rv = BCM_E_UNAVAIL;
        }
    break;

   case bcmPortControlHiGigCosSelect:
#if defined(BCM_HURRICANE4_SUPPORT)
        if (SOC_IS_HURRICANE4(unit)) {
            rv = bcm_hr4_hgcos_select_port_control_get(unit, port, type, value);
        } else
#endif
#if defined(BCM_HELIX5_SUPPORT)
        if (SOC_IS_HELIX5(unit)) {
            rv = bcm_hx5_hgcos_select_port_control_get(unit, port, type, value);
        } else
#endif
        {
           rv = BCM_E_UNAVAIL;
        }
    break;
    case bcmPortControlInternalLoopback:
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            int port_type;
            rv = _bcm_esw_port_tab_get(unit, port, PORT_TYPEf, &port_type);
            (port_type == 2) ? (*value = 1) : (*value = 0);
        } else
#endif
        {
            rv = BCM_E_UNAVAIL;
        }
    break;
#ifdef BCM_MONTEREY_SUPPORT
    case bcmPortControlObmInterruptTypeDropPreempt :
    case bcmPortControlObmInterruptTypeOverflowPreempt :
    case bcmPortControlObmInterruptTypeDropExpress :
    case  bcmPortControlObmInterruptTypeOverflowExpress :
        if (SOC_IS_MONTEREY(unit)) {
            rv = bcm_mn_obm_interrupt_port_control_get(unit, port, type, value);

        }else
#endif
        {
            rv = BCM_E_UNAVAIL;
        }
        break;
    case bcmPortControlRuntThreshold:
        rv = MAC_CONTROL_GET(PORT(unit, port).p_mac, unit, port,
                             SOC_MAC_CONTROL_RX_RUNT_THRESHOLD, value);
        break;
    case bcmPortControlPacketProcssingPort:
#ifdef BCM_TRIDENT3_SUPPORT
        if (soc_feature(unit, soc_feature_pp_port_control)) {
            rv = bcmi_td3_port_pp_num_get(unit, port, value);
        } else
#endif /* BCM_TRIDENT3_SUPPORT */
        {
            rv = BCM_E_UNAVAIL;
        }
        break;
     default:
        break;
    }

    if (BCM_SUCCESS(rv)) {
        LOG_INFO(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit,
                             "bcm_port_control_get: u=%d p=%d v=%d\n"),
                  unit, port, *value));
    } else {
        /* On error, the value is not guaranteed valid */
        LOG_INFO(BSL_LS_BCM_PORT,
                 (BSL_META_U(unit,
                             "bcm_port_control_get failure: u=%d p=%d: %s\n"),
                  unit, port, bcm_errmsg(rv)));
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_mac_failover_notify
 * Description:
 *      disable RX routine on MAC
 *      note: omitting XLMAC since it should not be disabled during failover
 * Parameters:
 *      unit - Device number
 *      port - Port number
 * Return Value:
 *      BCM_E_NONE
 *      BCM_E_UNAVAIL - Functionality not available
 */
int
_bcm_esw_port_mac_failover_notify(int unit, bcm_port_t port)
{
    int rv = BCM_E_NONE;

    if (!SOC_PORT_USE_PORTCTRL(unit, port)) {
        /* disable RX for MAC and XMAC controller.
           for TD2, lag failover has been implemented within XLMAC;
           thus, XLMAC rx should not be disabled during failover */
        PORT_LOCK(unit);
        rv = (MAC_CONTROL_SET(PORT(unit, port).p_mac, unit, port,
                          SOC_MAC_CONTROL_FAILOVER_RX_SET, FALSE));
        PORT_UNLOCK(unit);
    }
    return rv;
}


/*
 * Function:
 *      _bcm_esw_port_policer_get
 * Purpose:
 *       Internal function to Retrieve the Policer ID accociated
 *       with specified physical port.
 * Parameters:
 *     Unit                  - (IN) unit number
 *     port                  - (IN) Port Number
 *     policer_id            - (OUT) policer Id
 * Returns:
 *     BCM_E_XXX
 */
int _bcm_esw_port_policer_get(
    int unit,
    bcm_port_t port,
    bcm_policer_t *policer_id)
{
    int rv = BCM_E_NONE;

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_GREYHOUND2_SUPPORT)
    int index = 0;
    int offset_mode = 0;

    BCM_IF_ERROR_RETURN
            (_bcm_esw_port_config_get(unit, port,
                                      _bcmPortSvcMeterIndex, &index));
    BCM_IF_ERROR_RETURN
            (_bcm_esw_port_config_get(unit, port,
                                    _bcmPortSvcMeterOffsetMode, &offset_mode));
    _bcm_esw_get_policer_id_from_index_offset(unit, index,
                                                    offset_mode, policer_id);
#endif /* BCM_KATANA_SUPPORT || BCM_TRIUMPH3_SUPPORT ||
          BCM_GREYHOUND2_SUPPORT */
    return rv;
}

/*
 * Function:
 *      bcm_esw_port_policer_get
 * Purpose:
 *       Retrieve the Policer ID accociated for the specified physical port.
 * Parameters:
 *     Unit                  - (IN) unit number
 *     port                  - (IN) Port Number
 *     policer_id            - (OUT) policer Id
 * Returns:
 *     BCM_E_XXX
 */
int bcm_esw_port_policer_get(
    int unit,
    bcm_port_t port,
    bcm_policer_t *policer_id)
{
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_GREYHOUND2_SUPPORT)
    int rv = BCM_E_NONE;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    if (!soc_feature(unit, soc_feature_global_meter)) {
        return BCM_E_UNAVAIL;
    }
    BCM_IF_ERROR_RETURN(_check_global_meter_init(unit));
    rv = _bcm_esw_port_gport_validate(unit, port, &port);
    BCM_IF_ERROR_RETURN(rv);
    rv = _bcm_esw_port_policer_get(unit, port, policer_id);
    return rv;
#else /* BCM_KATANA_SUPPORT || BCM_TRIUMPH3_SUPPORT ||
         BCM_GREYHOUND2_SUPPORT */
    return BCM_E_UNAVAIL;
#endif /* BCM_KATANA_SUPPORT || BCM_TRIUMPH3_SUPPORT ||
          BCM_GREYHOUND2_SUPPORT */
}

#if defined(BCM_GLOBAL_METER_V2_SUPPORT)
/*
 * Function:
 *     bcmi_esw_port_policer_set
 * Purpose:
 *     Set the Policer ID accociated for the specified physical port.
 * Parameters:
 *     Unit                  - (IN) unit number
 *     port                  - (IN) Port Number
 *     policer_id            - (IN) policer Id
 * Returns:
 *     BCM_E_XXX
 */
STATIC int
bcmi_esw_port_policer_set(
    int unit,
    bcm_port_t port,
    bcm_policer_t policer_id)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_GREYHOUND2_SUPPORT)
    int index = 0;
    int offset_mode = 0;
    bcm_policer_t current_policer_id = 0;

    if (SOC_IS_GREYHOUND2(unit)) {
        /* Make sure port module is initialized. */
        PORT_INIT(unit);
        if (!soc_feature(unit, soc_feature_global_meter)) {
            return BCM_E_UNAVAIL;
        }
        BCM_IF_ERROR_RETURN(_check_global_meter_init(unit));
        rv = _bcm_esw_port_gport_validate(unit, port, &port);
        BCM_IF_ERROR_RETURN(rv);
        /* validate policer id */
        rv = _bcm_esw_policer_validate(unit, &policer_id);
        if (BCM_FAILURE(rv)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "Invalid policer id passed: %x \n"),
                         policer_id));
            return (rv);
        }
        /* get the policer id that is currently configured */
        rv = _bcm_esw_port_policer_get(unit, port, &current_policer_id);
        if (BCM_FAILURE(rv)) {
            LOG_VERBOSE(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "Unabel to get the current policer configured \n")));
            return (rv);
        }

        /* Set policer id */
        BCM_IF_ERROR_RETURN(
            _bcm_esw_get_policer_table_index(unit, policer_id, &index));
        BCM_IF_ERROR_RETURN(
            _bcm_esw_policer_offset_mode_get(unit, policer_id, &offset_mode));

        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_config_set(
                unit, port, _bcmPortSvcMeterIndex, index));
        BCM_IF_ERROR_RETURN(
            _bcm_esw_port_config_set(
                unit, port, _bcmPortSvcMeterOffsetMode, offset_mode));

        /* increment new set policer ref_cnt */
        rv = _bcm_esw_policer_increment_ref_count(unit, policer_id);
        BCM_IF_ERROR_RETURN(rv);

        /* decrement current hw policer ref_cnt */
        rv = _bcm_esw_policer_validate(unit, &current_policer_id);

        /* Don't need to handle fail case since existed index could be 0 */
        if (BCM_SUCCESS(rv)) {
            rv = _bcm_esw_policer_decrement_ref_count(unit, current_policer_id);
            BCM_IF_ERROR_RETURN(rv);
        }

        rv = BCM_E_NONE;
    }
#endif /* BCM_GREYHOUND2_SUPPORT */
    return rv;
}

#endif /* BCM_GLOBAL_METER_V2_SUPPORT */

/*
 * Function:
 *      bcm_esw_port_policer_set
 * Purpose:
 *      Set the Policer ID accociated for the specified physical port.
 * Parameters:
 *     Unit                  - (IN) unit number
 *     port                  - (IN) Port Number
 *     policer_id            - (IN) policer Id
 * Returns:
 *     BCM_E_XXX
 */
int bcm_esw_port_policer_set(
    int unit,
    bcm_port_t port,
    bcm_policer_t policer)
{
#if (defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) ||    \
     defined(BCM_APACHE_SUPPORT))
    int rv = BCM_E_NONE;
    int index=0;
    int offset_mode=0;
    bcm_policer_t current_policer = 0;
#endif /* BCM_KATANA_SUPPORT || BCM_TRIUMPH3_SUPPORT ||
         BCM_APACHE_SUPPORT */

#if defined(BCM_GLOBAL_METER_V2_SUPPORT)
    if (soc_feature(unit, soc_feature_global_meter_v2)) {
        return bcmi_esw_port_policer_set(unit, port, policer);
    }
#endif /* BCM_GLOBAL_METER_V2_SUPPORT */

#if (defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) ||    \
     defined(BCM_APACHE_SUPPORT))

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    if (!soc_feature(unit, soc_feature_global_meter)) {
        return BCM_E_UNAVAIL;
    }
    BCM_IF_ERROR_RETURN(_check_global_meter_init(unit));
    rv = _bcm_esw_port_gport_validate(unit, port, &port);
    BCM_IF_ERROR_RETURN(rv);
    /* validate policer id */
    rv = _bcm_esw_policer_validate(unit, &policer);
    if (BCM_FAILURE(rv)) {
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Invalid policer id passed: %x \n"),
                     policer));
        return (rv);
    }
    /* get the policer id that is currently configured */
    rv = _bcm_esw_port_policer_get(unit, port, &current_policer);
    if (BCM_FAILURE(rv)) {
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Unabel to get the current policer configured \n")));
        return (rv);
    }
    rv = BCM_E_UNAVAIL;
    /* Set policer id */
    _bcm_esw_get_policer_table_index(unit, policer, &index);
    offset_mode = (((policer) & BCM_POLICER_GLOBAL_METER_MODE_MASK) >>
                                    BCM_POLICER_GLOBAL_METER_MODE_SHIFT);
    if (SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit)) {
        if ((offset_mode == 0) && (policer != 0)) {
            /*
             * Not a Global meter policer,
             * policer zero is used to detach already configured policer
             */
            return (BCM_E_PARAM);
        }
    }
    if (offset_mode >= 1) {
        offset_mode = offset_mode - 1;
    }
    if (index >= soc_mem_index_count(unit,SVM_METER_TABLEm))  {
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Invalid table index\n")));
        return BCM_E_PARAM;
    }
    if (offset_mode >= (soc_mem_index_count(unit,SVM_OFFSET_TABLEm) >>
                               BCM_POLICER_SVC_METER_OFFSET_TABLE_KEY_SIZE))  {
        LOG_VERBOSE(BSL_LS_BCM_PORT,
                    (BSL_META_U(unit,
                                "Invalid offset mode\n")));
        return BCM_E_PARAM;
    }
    BCM_IF_ERROR_RETURN(
            _bcm_esw_port_config_set(unit, port,
                                      _bcmPortSvcMeterIndex, index));
    BCM_IF_ERROR_RETURN(
             _bcm_esw_port_config_set(unit, port,
                                     _bcmPortSvcMeterOffsetMode, offset_mode));
    /* decrement current policer if any */
    if ((current_policer & BCM_POLICER_GLOBAL_METER_INDEX_MASK) > 0) {
        rv = _bcm_esw_policer_decrement_ref_count(unit, current_policer);
        BCM_IF_ERROR_RETURN(rv);
    }
    /* increment policer reference count */
    if ((policer & BCM_POLICER_GLOBAL_METER_INDEX_MASK) > 0 ) {
        rv = _bcm_esw_policer_increment_ref_count(unit, policer);
        BCM_IF_ERROR_RETURN(rv);
    }
    return rv;
#else /* BCM_KATANA_SUPPORT || BCM_TRIUMPH3_SUPPORT ||
         BCM_APACHE_SUPPORT */
    return BCM_E_UNAVAIL;
#endif
}

/*
 * Function:
 *      bcm_port_vlan_inner_tag_set
 * Purpose:
 *      Set the inner tag to be added to the packet.
 * Parameters:
 *      unit       - (IN) BCM unit.
 *      port       - (IN) Port number.
 *      inner_tag  - (IN) Inner tag.
 *                    Priority[15:13] CFI[12] VLAN ID [11:0]
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_vlan_inner_tag_set(int unit, bcm_port_t port, uint16 inner_tag)
{
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    rv = BCM_E_UNAVAIL;

#ifdef BCM_TRX_SUPPORT
    if (SOC_IS_TRX(unit)) {
        bcm_vlan_action_set_t action;

        if (!soc_feature(unit, soc_feature_vlan_action)) {
            return BCM_E_UNAVAIL;
        }

        PORT_LOCK(unit);
        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
            (_bcm_trx_vlan_port_default_action_get(unit, port, &action));
        action.new_inner_vlan = BCM_VLAN_CTRL_ID(inner_tag);
#if defined(BCM_KATANA2_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
        if (SOC_IS_KATANA2(unit) || SOC_IS_TOMAHAWKX(unit) || SOC_IS_TRIDENT3X(unit)) {
            rv =_bcm_trx_vlan_port_default_action_profile_set(unit, port, &action);
        } else
#endif
        {
            rv = _bcm_trx_vlan_port_default_action_set(unit, port, &action);
        }
        PORT_UNLOCK(unit);
        return rv;
    }
#endif

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAVEN_SUPPORT)
    if (SOC_IS_FIREBOLT2(unit) || SOC_IS_RAVEN(unit) || SOC_IS_HAWKEYE(unit)) {
        PORT_LOCK(unit);

        rv = soc_reg_field32_modify(unit, EGR_SRC_PORTr, port,
                                    INNER_TAGf, inner_tag);
        PORT_UNLOCK(unit);
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_RAVEN_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_port_vlan_inner_tag_get
 * Purpose:
 *      Get the inner tag to be added to the packet.
 * Parameters:
 *      unit       - (IN) BCM unit.
 *      port       - (IN) Port number.
 *      inner_tag  - (OUT) Inner tag.
 *                    Priority[15:13] CFI[12] VLAN ID [11:0]
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_vlan_inner_tag_get(int unit, bcm_port_t port, uint16 *inner_tag)
{
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    rv = BCM_E_UNAVAIL;

#ifdef BCM_TRX_SUPPORT
    if (SOC_IS_TRX(unit)) {
        bcm_vlan_action_set_t action;

        if (!soc_feature(unit, soc_feature_vlan_action)) {
            return BCM_E_UNAVAIL;
        }

        PORT_LOCK(unit);
        _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK
            (_bcm_trx_vlan_port_default_action_get(unit, port, &action));
        *inner_tag = action.new_inner_vlan;
        PORT_UNLOCK(unit);
        return BCM_E_NONE;
    }
#endif

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAVEN_SUPPORT)
        if (SOC_IS_FIREBOLT2(unit) || SOC_IS_RAVEN(unit) || SOC_IS_HAWKEYE(unit)) {
        uint32 value;

        rv = READ_EGR_SRC_PORTr(unit, port, &value);
        *inner_tag = soc_reg_field_get(unit, EGR_SRC_PORTr, value,
                                       INNER_TAGf);
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_RAVEN_SUPPORT */
    return rv;
}

#if defined(INCLUDE_L3) && defined(BCM_TRIDENT_SUPPORT)
STATIC int
_bcm_esw_port_vp_type_id_get(int unit, bcm_port_t port,
                             _bcm_vp_type_e *vp_type, int *vp)
{
    *vp = -1;
    *vp_type = _bcmVpTypeAny;

    if (BCM_GPORT_IS_MIM_PORT(port) && soc_feature(unit, soc_feature_mim)) {
        *vp_type = _bcmVpTypeMim;
        *vp = BCM_GPORT_MIM_PORT_ID_GET(port);
    } else if (BCM_GPORT_IS_TRILL_PORT(port) && soc_feature(unit, soc_feature_trill)) {
        *vp_type = _bcmVpTypeTrill;
        *vp = BCM_GPORT_TRILL_PORT_ID_GET(port);
    } else if (BCM_GPORT_IS_VXLAN_PORT(port) && soc_feature(unit, soc_feature_vxlan)) {
        *vp_type = _bcmVpTypeVxlan;
        *vp = BCM_GPORT_VXLAN_PORT_ID_GET(port);
    } else if (BCM_GPORT_IS_MPLS_PORT(port) && soc_feature(unit, soc_feature_mpls)) {
        *vp_type = _bcmVpTypeMpls;
        *vp = BCM_GPORT_MPLS_PORT_ID_GET(port);
    } else if (BCM_GPORT_IS_EXTENDER_PORT(port) && soc_feature(unit, soc_feature_port_extension)) {
        *vp_type = _bcmVpTypeExtender;
        *vp = BCM_GPORT_EXTENDER_PORT_ID_GET(port);
    } else if (BCM_GPORT_IS_WLAN_PORT(port) && soc_feature(unit, soc_feature_wlan)) {
        *vp_type = _bcmVpTypeWlan;
        *vp = BCM_GPORT_WLAN_PORT_ID_GET(port);
    } else if (BCM_GPORT_IS_NIV_PORT(port) && soc_feature(unit, soc_feature_niv)) {
        *vp_type = _bcmVpTypeNiv;
        *vp = BCM_GPORT_NIV_PORT_ID_GET(port);
    } else if (BCM_GPORT_IS_VLAN_PORT(port) && soc_feature(unit, soc_feature_vlan_vp)) {
        *vp_type = _bcmVpTypeVlan;
        *vp = BCM_GPORT_VLAN_PORT_ID_GET(port);
    } else if (BCM_GPORT_IS_L2GRE_PORT(port) && soc_feature(unit, soc_feature_l2gre)) {
        *vp_type = _bcmVpTypeL2Gre;
        *vp = BCM_GPORT_L2GRE_PORT_ID_GET(port);
    } else if (BCM_GPORT_IS_FLOW_PORT(port) && soc_feature(unit, soc_feature_flex_flow)) {
        *vp_type = _bcmVpTypeFlow;
        *vp = BCM_GPORT_FLOW_PORT_ID_GET(port);
    } else if (BCM_GPORT_IS_TRUNK(port) && soc_feature(unit, soc_feature_vp_lag)) {
        *vp_type = _bcmVpTypeVpLag;
        BCM_IF_ERROR_RETURN(
            _bcm_esw_trunk_tid_to_vp_lag_vp(unit, BCM_GPORT_TRUNK_GET(port),
                                            vp));
    }
    return BCM_E_NONE;
}
#endif

/*
 * Function    :
 *     bcm_port_class_set
 * Description :
 *     Set the ports class ID. Ports with the
 *     same class ID can be treated as a group in
 *     field processing and VLAN translation.
 * Parameters  :
 *     (IN) unit      - BCM device number
 *     (IN) port      - Device or logical port number
 *     (IN) pclass    - Classification type
 *     (IN) pclass_id - New class ID of the port.
 * Returns     :
 *     BCM_E_NONE     - Success
 *     BCM_E_XXX      - Failed
 */
int
bcm_esw_port_class_set(int unit, bcm_port_t port,
                       bcm_port_class_t pclass, uint32 pclass_id)
{
    int        rv = BCM_E_UNAVAIL;
    bcm_port_t port_out = port;
#if defined(BCM_TOMAHAWK_SUPPORT)
    soc_mem_t port_mem = PORT_TABm;
#endif

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined(INCLUDE_L3)
#if defined(BCM_TRIDENT_SUPPORT)
    if (BCM_GPORT_IS_SET(port)) {
        int vp;
        _bcm_vp_type_e vp_type;
        BCM_IF_ERROR_RETURN(_bcm_esw_port_vp_type_id_get(unit, port,
                                                         &vp_type, &vp));
        switch (pclass) {
        case bcmPortClassFieldIngress:
            if (vp_type == _bcmVpTypeMim || vp_type == _bcmVpTypeTrill ||
                vp_type == _bcmVpTypeVxlan || vp_type == _bcmVpTypeMpls ||
                vp_type == _bcmVpTypeExtender || vp_type == _bcmVpTypeWlan ||
                vp_type == _bcmVpTypeNiv || vp_type == _bcmVpTypeVlan ||
                vp_type == _bcmVpTypeL2Gre || vp_type == _bcmVpTypeVpLag ||
                vp_type == _bcmVpTypeFlow){

                if (!_bcm_vp_used_get(unit, vp, vp_type)) {
                    return BCM_E_PORT;
                }
                rv = soc_mem_field32_modify(unit, SOURCE_VPm, vp, CLASS_IDf, pclass_id);
                return rv;
            }
            break;
        case bcmPortClassVlanTranslateEgress:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
            /* class_id of DVP used in egress VLAN translation */
        /* class_id of DVP used in egress VLAN translation */
            if ((vp_type == _bcmVpTypeVxlan) || (vp_type == _bcmVpTypeMim) ||
                 (vp_type == _bcmVpTypeMpls) || (vp_type == _bcmVpTypeL2Gre) ||
                 (vp_type == _bcmVpTypeFlow) ) {
                int network_port;
                source_vp_entry_t svp;
                _bcm_vp_info_t vp_info;

                if (!_bcm_vp_used_get(unit, vp, vp_type)) {
                    return BCM_E_PORT;
                }
                BCM_IF_ERROR_RETURN (READ_SOURCE_VPm(unit, MEM_BLOCK_ANY, vp, &svp));
                BCM_IF_ERROR_RETURN(_bcm_vp_info_get(unit, vp, &vp_info));
                if (vp_info.flags & _BCM_VP_INFO_NETWORK_PORT) {
                    network_port = TRUE;
                } else {
                    network_port = FALSE;
                }

                if (SOC_MEM_FIELD_VALID(unit, EGR_DVP_ATTRIBUTEm,
                                                        VT_DVP_GROUP_IDf)
#if defined(BCM_TRIDENT3_SUPPORT)
                  || (SOC_IS_TRIDENT3X(unit) && SOC_MEM_FIELD_VALID(unit, EGR_DVP_ATTRIBUTEm,
                                                        COMMON__VT_DVP_GROUP_IDf))
#endif
                    ) {
                    if ((network_port) && (vp_type == _bcmVpTypeVxlan)) {
                        rv = soc_mem_field32_modify(unit, EGR_DVP_ATTRIBUTEm, vp,
                                                    VXLAN__VT_DVP_GROUP_IDf, pclass_id);
                    } else if ((network_port) && (vp_type == _bcmVpTypeL2Gre)) {
                        rv = soc_mem_field32_modify(unit, EGR_DVP_ATTRIBUTEm, vp,
                                                    L2GRE__VT_DVP_GROUP_IDf, pclass_id);
                    } else {
                        rv = soc_mem_field32_modify(unit, EGR_DVP_ATTRIBUTEm, vp,
                                                    COMMON__VT_DVP_GROUP_IDf, pclass_id);
                    }
                } else {
                    return BCM_E_UNAVAIL;
                }
                return rv;
            }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
            break;
#if defined(BCM_TOMAHAWK_SUPPORT)
        case bcmPortClassFieldIngressSourceGport:
            if  (!soc_feature(unit, soc_feature_multi_pipe_mapped_ports)) {
                return BCM_E_UNAVAIL;
            }
            if (pclass_id > 33) {
                return BCM_E_PARAM;
            }
            if (vp_type == _bcmVpTypeVxlan || vp_type == _bcmVpTypeVlan ||
                vp_type == _bcmVpTypeExtender || vp_type == _bcmVpTypeVpLag ||
                vp_type == _bcmVpTypeNiv || vp_type == _bcmVpTypeMpls ||
                vp_type == _bcmVpTypeL2Gre || vp_type == _bcmVpTypeMim ||
                vp_type == _bcmVpTypeFlow) {
                if (!_bcm_vp_used_get(unit, vp, vp_type)) {
                    return BCM_E_PORT;
                }
                rv = soc_mem_field32_modify(unit, SOURCE_VPm, vp,
                                            IPBM_INDEXf, pclass_id);
                return rv;
            }
            break;
#endif /* BCM_TOMAHAWK_SUPPORT */

        default:
            break;
        }
    }
#endif /* BCM_TRIDENT_SUPPORT*/
#endif /* INCLUDE_L3 */

#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (SOC_IS_XGS3_SWITCH(unit)) {
#if defined(BCM_TOMAHAWK_SUPPORT)
        bcm_module_t mod;
        bcm_trunk_t tid_out;
        int id_out;
        int index;
#endif /* BCM_TOMAHAWK_SUPPORT */
        switch (pclass) {
            case bcmPortClassFieldIngressSystemPort:
#if defined(BCM_TOMAHAWK_SUPPORT)
                if  (!soc_feature(unit, soc_feature_multi_pipe_mapped_ports)) {
                    return BCM_E_UNAVAIL;
                }
                if (pclass_id > 33) {
#if defined(BCM_TRIDENT3_SUPPORT)
                    if (!SOC_IS_TRIDENT3X(unit) ||
                      soc_feature(unit, soc_feature_ifp_no_inports_support))
#endif
                    return BCM_E_PARAM;
                }
                if (BCM_GPORT_IS_SET(port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                                        &mod, &port_out, &tid_out, &id_out));
                    if (-1 != tid_out || -1 != id_out) {
                        return BCM_E_PORT;
                    }
                } else {
                    if (!SOC_PORT_VALID(unit, port)) {
                        return BCM_E_PORT;
                    }
                    port_out = port;
                    BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, &mod));
                }
                BCM_IF_ERROR_RETURN(_bcm_esw_src_mod_port_table_index_get(unit,
                                    mod, port_out, &index));
#if defined(BCM_TRIDENT3_SUPPORT)
                if (SOC_IS_TRIDENT3X(unit) &&
                      !soc_feature(unit, soc_feature_ifp_no_inports_support)) {
                    rv = bcm_td3_port_ipbm_opaque_set(unit, index, pclass_id);
                    return rv;
                }
#endif
                rv = soc_mem_field32_modify(unit, SOURCE_TRUNK_MAP_TABLEm, index,
                                                IPBM_INDEXf, pclass_id);
                return rv;
#endif /* BCM_TOMAHAWK_SUPPORT */
                break;
            default:
                break;
        }
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT */
    /*
     * Skip port validation if soc_feature_shg_support_remote_port
     * is true and ptype is bcmPortClassFieldIngress.
     */
    if (!(soc_feature(unit, soc_feature_shg_support_remote_port) &&
        (pclass == bcmPortClassFieldIngress))) {
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port_out));
    }


#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (SOC_IS_XGS3_SWITCH(unit)) {
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        int        port_class_id;
        soc_reg_t egr_port_reg;
        egr_port_reg = (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
                        SOC_IS_VALKYRIE2(unit) || SOC_IS_GREYHOUND(unit) ||
                        SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) ?
                        EGR_PORT_64r : EGR_PORTr;
#endif /* BCM_FIREBOLT_SUPPORT || BCM_TRX_SUPPORT */

        switch (pclass) {
            case bcmPortClassFieldIngressGroupSel:
#if defined(BCM_TOMAHAWK_SUPPORT)
                if (SOC_IS_TRIDENT3X(unit)) {
                    port_mem = LPORT_TABm;
                }
                if (soc_mem_field_valid(unit, port_mem, IFP_KEY_SEL_CLASS_IDf)) {
                    rv = soc_mem_field_pbmp_fit(unit, port_mem,
                                                IFP_KEY_SEL_CLASS_IDf, &pclass_id);
                    if (rv == BCM_E_NONE) {
                        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                                   IFP_KEY_SEL_CLASS_IDf, pclass_id);
                    }
                }
#endif
                break;
        case bcmPortClassFieldLookup:
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
            if (soc_mem_field_valid(unit, PORT_TABm, VFP_PORT_GROUP_IDf) ||
                SOC_IS_TRIDENT3X(unit)) {
                /* Intentional use of var pclass_id, to be filled here */
                if (soc_mem_field_valid(unit, PORT_TABm, VFP_PORT_GROUP_IDf)) {
                    /* coverity [callee_ptr_arith] */
                    rv = soc_mem_field_pbmp_fit(unit, PORT_TABm,
                                VFP_PORT_GROUP_IDf, &pclass_id);
                } else if (SOC_IS_TRIDENT3X(unit)) {
                    rv = soc_mem_field_pbmp_fit(unit, LPORT_TABm,
                                VFP_PORT_GROUP_IDf, &pclass_id);
                }
                if (rv == BCM_E_NONE) {
                    port_class_id = (int) pclass_id;
                    rv = _bcm_esw_port_tab_set(unit, port,
                                               _BCM_CPU_TABS_BOTH,
                                               VFP_PORT_GROUP_IDf,
                                               port_class_id);
                }
            }
#endif /* BCM_FIREBOLT_SUPPORT || BCM_TRX_SUPPORT */
#if defined(BCM_TRX_SUPPORT)
            if ((SOC_MEM_FIELD_VALID(unit, SOURCE_TRUNK_MAP_TABLEm,
                                     VFP_PORT_GROUP_IDf)) &&
                (BCM_SUCCESS(rv))) {
#if defined(BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit)) {
                    rv = _bcm_kt2_source_trunk_map_set(unit, port_out,
                                                   VFP_PORT_GROUP_IDf,
                                                   pclass_id);
                } else
#endif
                {
                    rv = _bcm_trx_source_trunk_map_set(unit, port,
                                                   VFP_PORT_GROUP_IDf,
                                                   pclass_id);
                }
            }
#endif /* BCM_TRX_SUPPORT */
            break;
        case bcmPortClassVlanTranslateIngress:
#if defined(BCM_TRIDENT2_SUPPORT)
            if (SOC_MEM_FIELD_VALID(unit, SOURCE_TRUNK_MAP_TABLEm, PORT_GROUPf)) {
                rv = _bcm_trx_source_trunk_map_set(unit, port,
                                                   PORT_GROUPf, pclass_id);
            }
#endif /* BCM_TRIDENT2_SUPPORT */
            break;
        case bcmPortClassFieldIngress:
#if defined(BCM_TRX_SUPPORT)
            if (SOC_MEM_FIELD_VALID(unit, SOURCE_TRUNK_MAP_TABLEm, CLASS_IDf)) {
#if defined(BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit)) {
                    rv = _bcm_kt2_source_trunk_map_set(unit, port_out,
                                                    CLASS_IDf, pclass_id);
                } else
#endif
                {
                    rv = _bcm_trx_source_trunk_map_set(unit, port,
                                                   CLASS_IDf, pclass_id);
                }
            }
#endif /* BCM_TRX_SUPPORT */
            break;
        case bcmPortClassFieldEgress:
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
            if (soc_reg_field_valid(unit, egr_port_reg, EGR_PORT_GROUP_IDf)) {
                rv = soc_reg_field32_modify(unit, egr_port_reg, port_out,
                                            EGR_PORT_GROUP_IDf, pclass_id);
            }
#ifdef BCM_TRIDENT_SUPPORT
            else if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, EGR_PORT_GROUP_IDf) ||
                     SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_egr_port_tab_set(unit, port,
                                               EGR_PORT_GROUP_IDf, pclass_id);
            }
#endif /* BCM_TRIDENT_SUPPORT */
#endif /* BCM_FIREBOLT_SUPPORT || BCM_TRX_SUPPORT */
            break;
        case bcmPortClassVlanTranslateEgress:
#if defined(BCM_TRX_SUPPORT)
            if (soc_reg_field_valid(unit, egr_port_reg, VT_PORT_GROUP_IDf)) {
                soc_control_t   *sc = SOC_CONTROL(unit);

                if (sc->soc_flags & SOC_F_PORT_CLASS_BLOCKED) {
                    return BCM_E_CONFIG;
                }
                rv = soc_reg_field32_modify(unit, egr_port_reg, port_out,
                                            VT_PORT_GROUP_IDf, pclass_id);
                if (BCM_SUCCESS(rv)) {
                    /* Once port class is changed system will not allow */
                    /* To use bcm_vlan_translate_egress */
                    sc->soc_flags |= SOC_F_XLATE_EGR_BLOCKED;
                }
            }
#ifdef BCM_TRIDENT_SUPPORT
            else if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, VT_PORT_GROUP_IDf) ||
                     SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_egr_port_tab_set(unit, port,
                                               VT_PORT_GROUP_IDf, pclass_id);
            }
#endif /* BCM_TRIDENT_SUPPORT */
#endif /* BCM_TRX_SUPPORT */
            break;
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
         case bcmPortClassEgress:
            if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, CLASS_IDf) ||
                SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_egr_port_tab_set(unit, port,
                                               CLASS_IDf, pclass_id);
            }
            break;
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
         case bcmPortClassFieldIngressDevicePort:
            if  (!soc_feature(unit, soc_feature_multi_pipe_mapped_ports)) {
                return BCM_E_UNAVAIL;
            }
            if (pclass_id > 33) {
                return BCM_E_PARAM;
            }
#if defined (BCM_TOMAHAWK3_SUPPORT)
            if (SOC_IS_TOMAHAWK3(unit)) {
                if (pclass_id > 19) {
                    return BCM_E_PARAM;
                }
            }
#endif

            if (BCM_GPORT_IS_SET(port)) {
                bcm_module_t mod;
                bcm_trunk_t tid_out;
                int id_out;
                BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                                    &mod, &port_out, &tid_out, &id_out));
                if (-1 != tid_out || -1 != id_out) {
                    return BCM_E_PORT;
                }
            } else {
                if (!SOC_PORT_VALID(unit, port)) {
                    return BCM_E_PORT;
                }
            }
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       PORT_IPBM_INDEXf, pclass_id);
            break;
#endif /* BCM_TOMAHAWK_SUPPORT */
        default:
            rv = BCM_E_PARAM;
        }
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT */

    return rv;
}

/*
 * Function    :
 *     bcm_port_class_get
 * Description :
 *     Get the ports class ID. Ports with the
 *     same class ID can be treated as a group in
 *     field processing and VLAN translation.
 * Parameters  :
 *     (IN) unit       - BCM device number
 *     (IN) port       - Device or logical port number
 *     (IN) pclass     - Classification type
 *     (OUT) pclass_id - New class ID of the port.
 * Returns     :
 *     BCM_E_NONE      - Success
 *     BCM_E_XXX       - Failed
 */
int
bcm_esw_port_class_get(int unit, bcm_port_t port,
                       bcm_port_class_t pclass, uint32 *pclass_id)
{
    int        rv = BCM_E_UNAVAIL;
    bcm_port_t port_out = port;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined(INCLUDE_L3)
#if defined(BCM_TRIDENT_SUPPORT)
    if (BCM_GPORT_IS_SET(port)) {
        int vp;
        _bcm_vp_type_e vp_type;
        source_vp_entry_t entry;
        BCM_IF_ERROR_RETURN(_bcm_esw_port_vp_type_id_get(unit, port,
                                                         &vp_type, &vp));
        switch (pclass) {
        case bcmPortClassFieldIngress:
            if (vp_type == _bcmVpTypeMim || vp_type == _bcmVpTypeTrill ||
                vp_type == _bcmVpTypeVxlan || vp_type == _bcmVpTypeMpls ||
                vp_type == _bcmVpTypeExtender || vp_type == _bcmVpTypeWlan ||
                vp_type == _bcmVpTypeNiv || vp_type == _bcmVpTypeVlan ||
                vp_type == _bcmVpTypeL2Gre || vp_type == _bcmVpTypeVpLag ||
                vp_type == _bcmVpTypeFlow){

                if (!_bcm_vp_used_get(unit, vp, vp_type)) {
                    return BCM_E_PORT;
                }
                rv = READ_SOURCE_VPm(unit, MEM_BLOCK_ANY, vp, &entry);
                if (BCM_SUCCESS(rv)) {
                    *pclass_id = soc_mem_field32_get(unit, SOURCE_VPm,
                                                                        &entry, CLASS_IDf);
                }
                return rv;
            }
            break;
        case bcmPortClassVlanTranslateEgress:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
          /* class_id of DVP used in egress VLAN translation */
            if ((vp_type == _bcmVpTypeVxlan) || (vp_type == _bcmVpTypeMim) ||
                (vp_type == _bcmVpTypeMpls) || (vp_type == _bcmVpTypeL2Gre)) {
                int network_port;
                egr_dvp_attribute_entry_t dvp_entry;
                _bcm_vp_info_t vp_info;

                if (!_bcm_vp_used_get(unit, vp, vp_type)) {
                    return BCM_E_PORT;
                }

                BCM_IF_ERROR_RETURN(_bcm_vp_info_get(unit, vp, &vp_info));
                if (vp_info.flags & _BCM_VP_INFO_NETWORK_PORT) {
                    network_port = TRUE;
                } else {
                    network_port = FALSE;
                }

                if (SOC_MEM_FIELD_VALID(unit, EGR_DVP_ATTRIBUTEm,
                                        VT_DVP_GROUP_IDf)
#if defined(BCM_TRIDENT3_SUPPORT)
                  || (SOC_IS_TRIDENT3X(unit) && SOC_MEM_FIELD_VALID(unit, EGR_DVP_ATTRIBUTEm,
                                                        COMMON__VT_DVP_GROUP_IDf))
#endif
                   ) {
                    rv = READ_EGR_DVP_ATTRIBUTEm(unit, MEM_BLOCK_ANY,
                                                                   vp, &dvp_entry);
                    if (BCM_SUCCESS(rv)) {
                        if ((network_port) && (vp_type == _bcmVpTypeVxlan)) {
                            *pclass_id = soc_mem_field32_get
                                        (unit, EGR_DVP_ATTRIBUTEm, &dvp_entry,
                                         VXLAN__VT_DVP_GROUP_IDf);
                       } else if ((network_port) && (vp_type == _bcmVpTypeL2Gre)) {
                            *pclass_id = soc_mem_field32_get
                                        (unit, EGR_DVP_ATTRIBUTEm, &dvp_entry,
                                         L2GRE__VT_DVP_GROUP_IDf);
                       } else {
                            *pclass_id = soc_mem_field32_get
                                        (unit, EGR_DVP_ATTRIBUTEm, &dvp_entry,
                                         COMMON__VT_DVP_GROUP_IDf);
                       }
                    }
                } else {
                    return BCM_E_UNAVAIL;
                }
                return rv;
            }

#endif  /* BCM_TRIDENT2PLUS_SUPPORT */
            break;
#if defined(BCM_TOMAHAWK_SUPPORT)
        case bcmPortClassFieldIngressSourceGport:
            if  (!soc_feature(unit, soc_feature_multi_pipe_mapped_ports)) {
                return BCM_E_UNAVAIL;
            }
            if (vp_type == _bcmVpTypeVxlan || vp_type == _bcmVpTypeVlan ||
                vp_type == _bcmVpTypeExtender || vp_type == _bcmVpTypeVpLag ||
                vp_type == _bcmVpTypeNiv || vp_type == _bcmVpTypeMpls ||
                vp_type == _bcmVpTypeL2Gre || vp_type == _bcmVpTypeMim ||
                vp_type == _bcmVpTypeFlow) {
                if (!_bcm_vp_used_get(unit, vp, vp_type)) {
                    return BCM_E_PORT;
                }
                rv = READ_SOURCE_VPm(unit, MEM_BLOCK_ANY, vp, &entry);
                if (BCM_SUCCESS(rv)) {
                    *pclass_id = soc_mem_field32_get(unit, SOURCE_VPm,
                                                     &entry, IPBM_INDEXf);
                }
                return rv;
            }
            break;
#endif /* BCM_TOMAHAWK_SUPPORT */
        default:
            break;
        }
    }
#endif /* BCM_TRIDENT_SUPPORT */
#endif /* INCLUDE_L3 */
#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (SOC_IS_XGS3_SWITCH(unit)) {
#if defined(BCM_TOMAHAWK_SUPPORT)
        source_trunk_map_table_entry_t entry;
        bcm_module_t mod;
        bcm_trunk_t tid_out;
        int id_out;
        int index;
#endif /* BCM_TOMAHAWK_SUPPORT */

        switch (pclass) {
            case bcmPortClassFieldIngressSystemPort:
#if defined(BCM_TOMAHAWK_SUPPORT)
                if  (!soc_feature(unit, soc_feature_multi_pipe_mapped_ports)) {
                    return BCM_E_UNAVAIL;
                }
                if (BCM_GPORT_IS_SET(port)) {
                    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                                        &mod, &port_out, &tid_out, &id_out));
                    if (-1 != tid_out || -1 != id_out) {
                        return BCM_E_PORT;
                    }
                } else {
                    if (!SOC_PORT_VALID(unit, port)) {
                        return BCM_E_PORT;
                    }
                    port_out = port;
                    BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, &mod));
                }
                BCM_IF_ERROR_RETURN(_bcm_esw_src_mod_port_table_index_get(unit,
                                    mod, port_out, &index));
#if defined(BCM_TRIDENT3_SUPPORT)
                if (SOC_IS_TRIDENT3X(unit) &&
                      !soc_feature(unit, soc_feature_ifp_no_inports_support)){
                    rv = bcm_td3_port_ipbm_opaque_get(unit, index, pclass_id);
                    return rv;
                }
#endif
                SOC_IF_ERROR_RETURN(soc_mem_read(unit, SOURCE_TRUNK_MAP_TABLEm,
                                                 MEM_BLOCK_ANY, index, &entry));
                *pclass_id = soc_SOURCE_TRUNK_MAP_TABLEm_field32_get(unit,
                               &entry, IPBM_INDEXf);
                return BCM_E_NONE;
#endif /* BCM_TOMAHAWK_SUPPORT */
                break;
            default:
                break;
        }
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT */
    /*
     * Skip port validation if soc_feature_shg_support_remote_port
     * is true and ptype is bcmPortClassFieldIngress.
     */
    if (!(soc_feature(unit, soc_feature_shg_support_remote_port) &&
        (pclass == bcmPortClassFieldIngress))) {
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port_out));
    }

    if (NULL == pclass_id) {
        return BCM_E_PARAM;
    }

#ifdef BCM_XGS3_SWITCH_SUPPORT
    if (SOC_IS_XGS3_SWITCH(unit)) {
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        uint32 reg_val;
        uint64 reg_val64;
        int    port_class_id;
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        switch (pclass) {
            case bcmPortClassFieldIngressGroupSel:
#if defined(BCM_TOMAHAWK_SUPPORT)
                rv = _bcm_esw_port_tab_get(unit, port, IFP_KEY_SEL_CLASS_IDf,
                                           (int32*) pclass_id);
#endif
                break;

        case bcmPortClassFieldLookup:
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
            if (soc_mem_field_valid(unit, PORT_TABm, VFP_PORT_GROUP_IDf) ||
                SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_port_tab_get(unit, port, VFP_PORT_GROUP_IDf,
                                           &port_class_id);
                *pclass_id = (uint32) port_class_id;
            }
#endif /* BCM_FIREBOLT_SUPPORT || BCM_TRX_SUPPORT */
            break;
        case bcmPortClassVlanTranslateIngress:
#if defined(BCM_TRIDENT2_SUPPORT)
            if (SOC_MEM_FIELD_VALID(unit, SOURCE_TRUNK_MAP_TABLEm, PORT_GROUPf)) {
                rv = _bcm_trx_source_trunk_map_get(unit, port,
                                                   PORT_GROUPf, pclass_id);
            }
#endif /* BCM_TRIDENT2_SUPPORT */
            break;
        case bcmPortClassFieldIngress:
#if defined(BCM_TRX_SUPPORT)
            if (SOC_MEM_FIELD_VALID(unit, SOURCE_TRUNK_MAP_TABLEm, CLASS_IDf)) {
#if defined(BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit)) {
                    rv = _bcm_kt2_source_trunk_map_get(unit, port_out,
                                                   CLASS_IDf, pclass_id);
                } else
#endif
                {
                    rv = _bcm_trx_source_trunk_map_get(unit, port,
                                                   CLASS_IDf, pclass_id);
                }
            }
#endif /* BCM_TRX_SUPPORT */
            break;
        case bcmPortClassFieldEgress:
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
            if (soc_reg_field_valid(unit, EGR_PORT_64r, EGR_PORT_GROUP_IDf)) {
                rv = READ_EGR_PORT_64r(unit, port_out, &reg_val64);
                if (BCM_SUCCESS(rv)) {
                    *pclass_id = soc_reg64_field32_get(unit, EGR_PORT_64r,
                                                   reg_val64, EGR_PORT_GROUP_IDf);
                }
            } else if (soc_reg_field_valid(unit, EGR_PORTr, EGR_PORT_GROUP_IDf)) {
                rv = READ_EGR_PORTr(unit, port_out, &reg_val);
                if (BCM_SUCCESS(rv)) {
                    *pclass_id = soc_reg_field_get(unit, EGR_PORTr,
                                                   reg_val, EGR_PORT_GROUP_IDf);
                }
            }
#ifdef BCM_TRIDENT_SUPPORT
            else if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, EGR_PORT_GROUP_IDf) ||
                     SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_egr_port_tab_get(unit, port, EGR_PORT_GROUP_IDf,
                                               (int *)pclass_id);

            }
#endif /* BCM_TRIDENT_SUPPORT */
#endif /* BCM_FIREBOLT_SUPPORT || BCM_TRX_SUPPORT */
            break;
        case bcmPortClassVlanTranslateEgress:
#if defined(BCM_TRX_SUPPORT)
            if (soc_reg_field_valid(unit, EGR_PORT_64r, VT_PORT_GROUP_IDf)) {
                if (SOC_REG_IS_VALID(unit, EGR_PORT_64r)) {
                    rv = READ_EGR_PORT_64r(unit, port_out, &reg_val64);
                    if (BCM_SUCCESS(rv)) {
                        *pclass_id = soc_reg64_field32_get(unit, EGR_PORT_64r,
                                                       reg_val64, VT_PORT_GROUP_IDf);
                    }
                }
            } else if (soc_reg_field_valid(unit, EGR_PORTr, VT_PORT_GROUP_IDf)) {
                    rv = READ_EGR_PORTr(unit, port_out, &reg_val);
                    if (BCM_SUCCESS(rv)) {
                        *pclass_id = soc_reg_field_get(unit, EGR_PORTr,
                                                       reg_val, VT_PORT_GROUP_IDf);
                    }
            }
#ifdef BCM_TRIDENT_SUPPORT
            else if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, VT_PORT_GROUP_IDf) ||
                     SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_egr_port_tab_get(unit, port, VT_PORT_GROUP_IDf,
                                               (int *)pclass_id);
            }
#endif /* BCM_TRIDENT_SUPPORT */
#endif /* BCM_TRX_SUPPORT */
            break;
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
         case bcmPortClassEgress:
            if (SOC_MEM_FIELD_VALID(unit, EGR_PORTm, CLASS_IDf) ||
                SOC_IS_TRIDENT3X(unit)) {
                rv = _bcm_esw_egr_port_tab_get(unit, port, CLASS_IDf,
                                               (int *)pclass_id);
            }
            break;
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
         case bcmPortClassFieldIngressDevicePort:
            if  (!soc_feature(unit, soc_feature_multi_pipe_mapped_ports)) {
                return BCM_E_UNAVAIL;
            }
            rv = _bcm_esw_port_tab_get(unit, port, PORT_IPBM_INDEXf,
                                       &port_class_id);
            if (BCM_SUCCESS(rv)) {
                *pclass_id = (uint32) port_class_id;
            }
            break;
#endif /* BCM_TOMAHAWK_SUPPORT */

        default:
            rv = BCM_E_PARAM;
        }
    }
#endif /* BCM_XGS3_SWITCH_SUPPORT */

    return rv;
}


/*
 * Function    : _bcm_esw_port_config_set
 * Description : Internal function to set port configuration.
 * Parameters  : (IN)unit  - BCM device number.
 *               (IN)port  - Port number (see Notes for valid port formats).
 *               (IN)type  - Port property.
 *               (IN)value - New property value.
 * Returns     : BCM_E_XXX
 * Notes:
 *      Current valid port types are:
 *          GPORT PROXY
 *          GPORT SUBPORT
 *          GPORT (various types) that resolves to local physical port
 *          BCM port (non-gport), local physical port
 */
int
_bcm_esw_port_config_set(int unit, bcm_port_t port,
                         _bcm_port_config_t type, int value)
{
    int rv = BCM_E_UNAVAIL;    /* Operation return status. */

#ifdef BCM_HGPROXY_COE_SUPPORT
    if (BCM_GPORT_IS_SET(port) &&
        _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port) &&
        (soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        soc_feature(unit, soc_feature_channelized_switching))) {
        /* Don't resolve port */
    } else
#endif
    if (BCM_GPORT_IS_PROXY(port)) {
        /* Don't resolve port */
    } else {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    }


    PORT_LOCK(unit);

    switch (type) {
    case _bcmPortL3UrpfMode:
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   URPF_MODEf, value);
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case _bcmPortL3UrpfDefaultRoute:
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   URPF_DEFAULTROUTECHECKf,
                                   (value) ? 0 : 1);
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case _bcmPortVlanTranslate:
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   VT_ENABLEf, value);
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_KATANA2_SUPPORT)
        if ((SOC_IS_TRIUMPH3(unit) ||
             SOC_IS_TD2_TT2(unit) ||
             SOC_IS_KATANA2(unit)) && (rv == SOC_E_NONE)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       VT_PORT_TYPE_SELECTf, value);
            if (rv == SOC_E_NONE) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           VT_PORT_TYPE_SELECT_2f, value);
            }
        } else
#endif
        {
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit) && (rv == SOC_E_NONE)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       VT_KEY_TYPE_USE_GLPf, value);
            if (rv == SOC_E_NONE) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           VT_KEY_TYPE_2_USE_GLPf, value);
            }
        }
#endif
        }
        break;
    case _bcmPortVlanPrecedence:
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   VLAN_PRECEDENCEf, value);
        break;
    case _bcmPortVTMissDrop:
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   VT_MISS_DROPf, value);
        break;
    case _bcmPortLookupMACEnable:
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   MAC_BASED_VID_ENABLEf, value);
        break;
    case _bcmPortLookupIPEnable:
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   SUBNET_BASED_VID_ENABLEf,
                                   value);
        break;
    case _bcmPortUseInnerPri:
#if defined(BCM_RAVEN_SUPPORT) || defined(BCM_FIREBOLT2_SUPPORT) || \
    defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   USE_INNER_PRIf, value);
#endif /* BCM_RAVEN_SUPPORT || BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case _bcmPortUseOuterPri:
#if defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   TRUST_OUTER_DOT1Pf, value);
#endif /* BCM_TRX_SUPPORT */
        break;
    case _bcmPortVerifyOuterTpid:
#if defined(BCM_RAVEN_SUPPORT) || defined(BCM_FIREBOLT2_SUPPORT) || \
    defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   OUTER_TPID_VERIFYf, value);
#endif /* BCM_RAVEN_SUPPORT || BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case _bcmPortVTKeyTypeFirst:
#if defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   VT_KEY_TYPEf, value);
#endif /* BCM_TRX_SUPPORT */
        break;
    case _bcmPortVTKeyPortFirst:
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_KATANA2_SUPPORT)
       if (SOC_IS_TRIUMPH3(unit) ||
           SOC_IS_TD2_TT2(unit) ||
           SOC_IS_KATANA2(unit)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       VT_PORT_TYPE_SELECTf, value);
        } else
#endif
        {
#if defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   VT_KEY_TYPE_USE_GLPf, value);
#endif /* BCM_TRX_SUPPORT */
        }
        break;
    case _bcmPortVTKeyTypeSecond:
#if defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   VT_KEY_TYPE_2f, value);
#endif /* BCM_TRX_SUPPORT */
        break;
    case _bcmPortVTKeyPortSecond:
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit) ||
            SOC_IS_TD2_TT2(unit) ||
            SOC_IS_KATANA2(unit)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   VT_PORT_TYPE_SELECT_2f, value);
        } else
#endif
        {
#if defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   VT_KEY_TYPE_2_USE_GLPf, value);
#endif /* BCM_TRX_SUPPORT */
        }
        break;
    case _bcmPortIpmcV4Enable:
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   V4IPMC_ENABLEf, value);
        break;
    case _bcmPortIpmcV6Enable:
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   V6IPMC_ENABLEf, value);
        break;
    case _bcmPortIpmcVlanKey:
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   IPMC_DO_VLANf, value);
        break;
    case _bcmPortCfiAsCng:
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   CFI_AS_CNGf, value);
        break;
    case _bcmPortNni:
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   NNI_PORTf, value);
        break;
    case _bcmPortHigigTrunkId:
#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_TRX_SUPPORT)
        if (value < 0) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       HIGIG_TRUNKf, 0);
            if (BCM_SUCCESS(rv)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           HIGIG_TRUNK_IDf, 0);
            }
        } else {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       HIGIG_TRUNK_IDf, value);
            if (BCM_SUCCESS(rv)) {
                rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                           HIGIG_TRUNKf, 1);
            }
        }
#endif /* BCM_BRADLEY_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case _bcmPortModuleLoopback:
        rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   ALLOW_SRC_MODf, value);
        break;
    case _bcmPortOuterTpidEnables:
#if defined(BCM_RAVEN_SUPPORT) || defined(BCM_FIREBOLT2_SUPPORT) || \
    defined(BCM_TRX_SUPPORT)
        if (SOC_MEM_FIELD_VALID(unit, SOURCE_TRUNK_MAP_TABLEm,
                                OUTER_TPID_ENABLEf)) {
#ifdef BCM_TRX_SUPPORT
            rv = _bcm_trx_source_trunk_map_set(unit, port, OUTER_TPID_ENABLEf,
                                               (uint32)value);
#endif
        } else {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                       OUTER_TPID_ENABLEf, value);
        }
#endif /* BCM_RAVEN_SUPPORT || BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_GREYHOUND2_SUPPORT)
    case _bcmPortSvcMeterIndex:
        if (SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit) ||    \
            SOC_IS_APACHE(unit) || SOC_IS_GREYHOUND2(unit)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   SVC_METER_INDEXf, value);
        }
        break;
    case _bcmPortSvcMeterOffsetMode:
        if (SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit) ||    \
            SOC_IS_APACHE(unit) || SOC_IS_GREYHOUND2(unit)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   SVC_METER_OFFSET_MODEf, value);
        }
        break;
#endif /* BCM_KATANA_SUPPORT || BCM_TRIUMPH3_SUPPORT ||
          BCM_GREYHOUND2_SUPPORT */
#if defined(BCM_KATANA2_SUPPORT)
    case _bcmPortOamUseXlatedInnerVlan:
        if (SOC_IS_KATANA2(unit)) {
            rv = _bcm_esw_port_tab_set(unit, port, _BCM_CPU_TABS_BOTH,
                                   OAM_CVLAN_MEP_AFTER_VXLTf, value);
            rv = _bcm_esw_egr_port_tab_set(unit, port,
                                   OAM_CVLAN_MEP_AFTER_VXLTf, value);
        }
        break;
#endif /* BCM_KATANA2_SUPPORT */
    default:
        rv = BCM_E_INTERNAL;
    }

    PORT_UNLOCK(unit);
    return (rv);
}

/*
 * Function    : _bcm_esw_port_config_get
 * Description : Internal function to get port configuration.
 * Parameters  : (IN)unit  - BCM device number.
 *               (IN)port  - Port number.
 *               (IN)type  - Port property.
 *               (OUT)value -Port property value.
 * Returns     : BCM_E_XXX
 * Notes:
 *      Current valid port types are:
 *          GPORT PROXY
 *          GPORT SUBPORT
 *          GPORT (various types) that resolves to local physical port
 *          BCM port (non-gport), local physical port
 */
int
_bcm_esw_port_config_get(int unit, bcm_port_t port,
                     _bcm_port_config_t type, int *value)
{
    int rv = BCM_E_UNAVAIL;    /* Operation return status. */
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    int tmp_value; /* Temporary value.     */
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */

#ifdef BCM_HGPROXY_COE_SUPPORT
    if (BCM_GPORT_IS_SET(port) &&
        _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port) &&
        (soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        soc_feature(unit, soc_feature_channelized_switching))) {
        /* Don't resolve port */
    } else
#endif
    if (BCM_GPORT_IS_PROXY(port)) {
        /* Don't resolve port */
    } else {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    }

    PORT_LOCK(unit);

    switch (type) {
    case _bcmPortL3UrpfMode:
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_get(unit, port, URPF_MODEf, value);
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case _bcmPortL3UrpfDefaultRoute:
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_get(unit, port, URPF_DEFAULTROUTECHECKf,
                                   &tmp_value);
        *value = (tmp_value) ? FALSE : TRUE;
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case _bcmPortVlanTranslate:
        rv = _bcm_esw_port_tab_get(unit, port, VT_ENABLEf, value);
        break;
    case _bcmPortVlanPrecedence:
        rv = _bcm_esw_port_tab_get(unit, port, VLAN_PRECEDENCEf, value);
        break;
    case _bcmPortVTMissDrop:
        rv = _bcm_esw_port_tab_get(unit, port, VT_MISS_DROPf, value);
        break;
    case _bcmPortLookupMACEnable:
        rv = _bcm_esw_port_tab_get(unit, port, MAC_BASED_VID_ENABLEf, value);
        break;
    case _bcmPortLookupIPEnable:
        rv = _bcm_esw_port_tab_get(unit, port, SUBNET_BASED_VID_ENABLEf,
                                   value);
        break;
    case _bcmPortUseInnerPri:
#if defined(BCM_RAVEN_SUPPORT) || defined(BCM_FIREBOLT2_SUPPORT) || \
    defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_get(unit, port, USE_INNER_PRIf, value);
#endif /* BCM_RAVEN_SUPPORT || BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case _bcmPortUseOuterPri:
#if defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_get(unit, port, TRUST_OUTER_DOT1Pf, value);
#endif /* BCM_TRX_SUPPORT */
        break;
    case _bcmPortVerifyOuterTpid:
#if defined(BCM_RAVEN_SUPPORT) || defined(BCM_FIREBOLT2_SUPPORT) || \
    defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_get(unit, port, OUTER_TPID_VERIFYf, value);
#endif /* BCM_RAVEN_SUPPORT || BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case _bcmPortVTKeyTypeFirst:
#if defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_get(unit, port, VT_KEY_TYPEf, value);
#endif /* BCM_TRX_SUPPORT */
        break;
    case _bcmPortVTKeyPortFirst:
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_KATANA2_SUPPORT)
       if (SOC_IS_TRIUMPH3(unit) ||
           SOC_IS_TD2_TT2(unit) ||
           SOC_IS_KATANA2(unit)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                                       VT_PORT_TYPE_SELECTf, value);
        } else
#endif
        {
#if defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_get(unit, port, VT_KEY_TYPE_USE_GLPf, value);
#endif /* BCM_TRX_SUPPORT */
        }
        break;
    case _bcmPortVTKeyTypeSecond:
#if defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_get(unit, port, VT_KEY_TYPE_2f, value);
#endif /* BCM_TRX_SUPPORT */
        break;
    case _bcmPortVTKeyPortSecond:
#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit) ||
            SOC_IS_TD2_TT2(unit) ||
            SOC_IS_KATANA2(unit)) {
            rv = _bcm_esw_port_tab_get(unit, port,
                         VT_PORT_TYPE_SELECT_2f, value);
        } else
#endif
        {
#if defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_get(unit, port, VT_KEY_TYPE_2_USE_GLPf, value);
#endif /* BCM_TRX_SUPPORT */
        }
        break;
    case _bcmPortIpmcV4Enable:
        rv = _bcm_esw_port_tab_get(unit, port, V4IPMC_ENABLEf, value);
        break;
    case _bcmPortIpmcV6Enable:
        rv = _bcm_esw_port_tab_get(unit, port, V6IPMC_ENABLEf, value);
        break;
    case _bcmPortIpmcVlanKey:
        rv = _bcm_esw_port_tab_get(unit, port, IPMC_DO_VLANf, value);
        break;
    case _bcmPortCfiAsCng:
        rv = _bcm_esw_port_tab_get(unit, port, CFI_AS_CNGf, value);
        break;
    case _bcmPortNni:
        rv = _bcm_esw_port_tab_get(unit, port, NNI_PORTf, value);
        break;
    case _bcmPortHigigTrunkId:
#if defined(BCM_BRADLEY_SUPPORT) || defined(BCM_TRX_SUPPORT)
        rv = _bcm_esw_port_tab_get(unit, port, HIGIG_TRUNKf, value);
        if (BCM_SUCCESS(rv)) {
            if (*value == 0) {
                *value = -1;
            } else {
                rv = _bcm_esw_port_tab_get(unit, port,
                                           HIGIG_TRUNK_IDf, value);
            }
        }
#endif /* BCM_BRADLEY_SUPPORT || BCM_TRX_SUPPORT */
        break;
    case _bcmPortModuleLoopback:
        rv = _bcm_esw_port_tab_get(unit, port, ALLOW_SRC_MODf, value);
        break;
    case _bcmPortOuterTpidEnables:
#if defined(BCM_RAVEN_SUPPORT) || defined(BCM_FIREBOLT2_SUPPORT) || \
    defined(BCM_TRX_SUPPORT)
        if (SOC_MEM_FIELD_VALID(unit, SOURCE_TRUNK_MAP_TABLEm,
                                OUTER_TPID_ENABLEf)) {
#ifdef BCM_TRX_SUPPORT
            rv = _bcm_trx_source_trunk_map_get(unit, port, OUTER_TPID_ENABLEf,
                                               (uint32 *)value);
#endif
        } else {
            rv = _bcm_esw_port_tab_get(unit, port, OUTER_TPID_ENABLEf, value);
        }
#endif /* BCM_RAVEN_SUPPORT || BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
        break;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_GREYHOUND2_SUPPORT)
    case _bcmPortSvcMeterIndex:
        if (SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit)       \
            || SOC_IS_APACHE(unit) || SOC_IS_GREYHOUND2(unit)) {
            rv = _bcm_esw_port_tab_get(unit, port, SVC_METER_INDEXf, value);
        }
        break;
    case _bcmPortSvcMeterOffsetMode:
        if (SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit)       \
            || SOC_IS_APACHE(unit) || SOC_IS_GREYHOUND2(unit)) {
            rv = _bcm_esw_port_tab_get(unit, port, SVC_METER_OFFSET_MODEf, value);
        }
        break;
#endif /* BCM_KATANA_SUPPORT || BCM_TRIUMPH3_SUPPORT ||
          BCM_GREYHOUND2_SUPPORT */
#if defined(BCM_KATANA2_SUPPORT)
    case _bcmPortOamUseXlatedInnerVlan:
        if (SOC_IS_KATANA2(unit)) {
            rv = _bcm_esw_port_tab_get(unit, port, OAM_CVLAN_MEP_AFTER_VXLTf,
                                       value);
        }
        break;
#endif /* BCM_KATANA2_SUPPORT */
    default:
        rv = BCM_E_INTERNAL;
    }
    PORT_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_port_force_vlan_set
 * Description:
 *     To set the force vlan attribute of a port
 * Parameters:
 *     unit        device number
 *     port        port number
 *     vlan        vlan identifier
 *                 (0 - 4095) - use this VLAN id if egress packet is tagged
 *     pkt_prio    egress packet priority (-1, 0..7)
 *                 any negative priority value disable the priority
 *                 override if the egress packet is tagged
 *     flags       bit fields
 *                 BCM_PORT_FORCE_VLAN_ENABLE - enable force vlan on this
 *                                              port
 *                 BCM_PORT_FORCE_VLAN_UNTAG - egress untagged when force
 *                                             vlan is enabled on this port
 *
 * Return:
 *     BCM_E_NONE
 *     BCM_E_UNIT
 *     BCM_E_PORT
 *     BCM_E_PARAM
 *     BCM_E_UNAVAIL
 *     BCM_E_XXX
 */
int
bcm_esw_port_force_vlan_set(int unit, bcm_port_t port, bcm_vlan_t vlan,
                            int pkt_prio, uint32 flags)
{
    int rv = BCM_E_UNAVAIL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined(BCM_TRIDENT_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_VLAN_PORT(port) ||
        BCM_GPORT_IS_NIV_PORT(port) ||
        BCM_GPORT_IS_EXTENDER_PORT(port)) {
        return bcm_td_vp_force_vlan_set(unit, port, vlan, flags);
    }
#endif /* BCM_TRIDENT_SUPPORT && INCLUDE_L3 */

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
#if defined(BCM_TRX_SUPPORT)
    if ((!soc_feature(unit, soc_feature_egr_pvlan_eport_control_is_mem) &&
         SOC_REG_FIELD_VALID(unit, EGR_PVLAN_EPORT_CONTROLr, PVLAN_UNTAGf)) ||
        (soc_feature(unit, soc_feature_egr_pvlan_eport_control_is_mem) &&
         SOC_MEM_FIELD_VALID(unit, EGR_PVLAN_EPORT_CONTROLm, PVLAN_UNTAGf))) {
        rv = _bcm_trx_port_force_vlan_set(unit, port, vlan, pkt_prio, flags);
    }

#endif /* defined(BCM_TRX_SUPPORT) */

    return rv;
}

/*
 * Function:
 *     bcm_port_force_vlan_get
 * Description:
 *     To get the force vlan attribute of a port
 * Parameters:
 *     unit        device number
 N_UNTAGf*     port        port number
 *     vlan        pointer to vlan identifier
 *                 (0 - 4095) - use this VLAN id if egress packet is tagged
 *                 valid only when BCM_PORT_FORCE_VLAN_ENABLE is set and
 *                 BCM_PORT_FORCE_VLAN_UNTAG is clear
 *     pkt_prio    egress packet priority (-1, 0 - 7)
 *                 valid only when BCM_PORT_FORCE_VLAN_ENABLE is set and
 *                 BCM_PORT_FORCE_VLAN_UNTAG is clear
 *     flags       bit fields
 *                 BCM_PORT_FORCE_VLAN_ENABLE - enable force vlan on this
 *                                              port
 *                 BCM_PORT_FORCE_VLAN_UNTAG - egress untagged when force
 *                                             vlan is enabled on this port
 *
 * Return:
 *     BCM_E_XXX
 */
int
bcm_esw_port_force_vlan_get(int unit, bcm_port_t port, bcm_vlan_t *vlan,
                            int *pkt_prio, uint32 *flags)
{
    int rv = BCM_E_UNAVAIL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined(BCM_TRIDENT_SUPPORT) && defined(INCLUDE_L3)
    if (BCM_GPORT_IS_VLAN_PORT(port) ||
        BCM_GPORT_IS_NIV_PORT(port) ||
        BCM_GPORT_IS_EXTENDER_PORT(port)) {
        return bcm_td_vp_force_vlan_get(unit, port, vlan, flags);
    }
#endif /* BCM_TRIDENT_SUPPORT && INCLUDE_L3 */

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#if defined(BCM_TRX_SUPPORT)
    if (SOC_REG_FIELD_VALID(unit, EGR_PVLAN_EPORT_CONTROLr, PVLAN_UNTAGf)) {
        rv = _bcm_trx_port_force_vlan_get(unit, port, vlan, pkt_prio, flags);
    }
#endif /* defined(BCM_TRX_SUPPORT) */

    return rv;
}

/*
 * Function:
 *     bcm_port_phy_control_set
 * Description:
 *     Set PHY specific properties
 * Parameters:
 *     unit        device number
 *     port        port number
 *     type        configuration type
 *     value       new value for the configuration
 * Return:
 *     BCM_E_XXX
 */
int
bcm_esw_port_phy_control_set(int unit, bcm_port_t port,
                             bcm_port_phy_control_t type, uint32 value)
{
    int rv;
    bcm_port_t local_port = 0;
    int phy_lane = -1;
    int phyn = 0, sys_side = 0;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        BCM_IF_ERROR_RETURN
            (bcmi_esw_portctrl_phy_control_set(unit, port, type, value));
#ifdef BCM_TOMAHAWK_SUPPORT
        /* If FEC/CL91/CL108 is enabled/disabled on the 25/27/50/53G ports, we will need to update ASF parameters */
        if (SOC_IS_TOMAHAWKX(unit)) {
            if ((type == _SHR_PORT_PHY_CONTROL_FORWARD_ERROR_CORRECTION_CL91)
                || (type == _SHR_PORT_PHY_CONTROL_FORWARD_ERROR_CORRECTION_CL108)) {
                bcm_port_info_t port_info;

                bcm_port_info_t_init(&port_info);
                BCM_IF_ERROR_RETURN(bcm_esw_port_info_get(unit, port, &port_info));

                if ((port_info.speed == 25000) || (port_info.speed == 27000) ||
                        (port_info.speed == 50000) || (port_info.speed == 53000) ||
                        (port_info.speed == 100000) || (port_info.speed == 106000)){
                    int mode;

                    BCM_IF_ERROR_RETURN(bcm_esw_port_asf_mode_get(unit, port, &mode));
                    BCM_IF_ERROR_RETURN(bcm_esw_port_asf_mode_set(unit, port, mode));
                }
            }
        }
#endif
        return BCM_E_NONE;
    }

    if(BCM_PHY_GPORT_IS_PHYN(port)) {
        local_port = BCM_PHY_GPORT_PHYN_PORT_PORT_GET(port);
        phyn = BCM_PHY_GPORT_PHYN_PORT_PHYN_GET(port);
        phy_lane = -1;
    } else if(BCM_PHY_GPORT_IS_PHYN_LANE(port)) {
        local_port = BCM_PHY_GPORT_PHYN_LANE_PORT_PORT_GET(port);
        phyn = BCM_PHY_GPORT_PHYN_LANE_PORT_PHYN_GET(port);
        phy_lane = BCM_PHY_GPORT_PHYN_LANE_PORT_LANE_GET(port);
    } else if(BCM_PHY_GPORT_IS_PHYN_SYS_SIDE(port)) {
        local_port = BCM_PHY_GPORT_PHYN_SYS_SIDE_PORT_PORT_GET(port);
        phyn = BCM_PHY_GPORT_PHYN_SYS_SIDE_PORT_PHYN_GET(port);
        sys_side = TRUE;
        phy_lane = -1;
    } else if(BCM_PHY_GPORT_IS_PHYN_SYS_SIDE_LANE(port)) {
        local_port = BCM_PHY_GPORT_PHYN_SYS_SIDE_LANE_PORT_PORT_GET(port);
        phyn = BCM_PHY_GPORT_PHYN_SYS_SIDE_LANE_PORT_PHYN_GET(port);
        phy_lane = BCM_PHY_GPORT_PHYN_SYS_SIDE_LANE_PORT_LANE_GET(port);
        sys_side = TRUE;
    } else if (BCM_PHY_GPORT_IS_LANE(port)) {
        local_port = BCM_PHY_GPORT_LANE_PORT_PORT_GET(port);
        phy_lane = BCM_PHY_GPORT_LANE_PORT_LANE_GET(port);
    } else {
        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_gport_validate(unit, port, &local_port));

        PORT_LOCK(unit);
        rv = soc_phyctrl_control_set(unit, local_port, (soc_phy_control_t) type, value);
        if (BCM_SUCCESS(rv)) {
            PORT_INFO_RX_LOS_SET(unit, local_port, type, value);
        }
        PORT_UNLOCK(unit);

#ifdef BCM_TOMAHAWK_SUPPORT
        /* If FEC/CL91/CL108 is enabled/disabled on the 25/27/50/53G ports, we will need to update ASF parameters */
        if (SOC_IS_TOMAHAWKX(unit)) {
            if ((type == _SHR_PORT_PHY_CONTROL_FORWARD_ERROR_CORRECTION_CL91)
                || (type == _SHR_PORT_PHY_CONTROL_FORWARD_ERROR_CORRECTION_CL108)) {
                bcm_port_info_t port_info;

                bcm_port_info_t_init(&port_info);
                BCM_IF_ERROR_RETURN(bcm_esw_port_info_get(unit, port, &port_info));

                if ((port_info.speed == 25000) || (port_info.speed == 27000) ||
                        (port_info.speed == 50000) || (port_info.speed == 53000) ||
                        (port_info.speed == 100000) || (port_info.speed == 106000)){
                    int mode;

                    BCM_IF_ERROR_RETURN(bcm_esw_port_asf_mode_get(unit, port, &mode));
                    BCM_IF_ERROR_RETURN(bcm_esw_port_asf_mode_set(unit, port, mode));
                }
            }
        }
#endif
        return rv;
    }

    if (!SOC_PORT_VALID(unit, local_port)) {
        return BCM_E_PORT;
    }

    PORT_LOCK(unit);
    rv = soc_phyctrl_redirect_control_set(unit, local_port, phyn, phy_lane,
                                          sys_side, (soc_phy_control_t) type, value);
    if (BCM_SUCCESS(rv)) {
        PORT_INFO_RX_LOS_SET(unit, local_port, type, value);
    }
    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *     bcm_esw_port_phy_control_get
 * Description:
 *     Set PHY specific properties
 * Parameters:
 *     unit        device number
 *     port        port number
 *     type        configuration type
 *     value       value for the configuration
 * Return:
 *     BCM_E_XXX
 */
int
bcm_esw_port_phy_control_get(int unit, bcm_port_t port,
                             bcm_port_phy_control_t type, uint32 *value)
{
    int rv;
    bcm_port_t local_port;
    int phy_lane = -1;
    int phyn = 0, sys_side = 0;

    if (NULL == value) {
        return BCM_E_PARAM;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_phy_control_get(unit, port, type, value);
    }

    if(BCM_PHY_GPORT_IS_PHYN(port)) {
        local_port = BCM_PHY_GPORT_PHYN_PORT_PORT_GET(port);
        phyn = BCM_PHY_GPORT_PHYN_PORT_PHYN_GET(port);
        phy_lane = -1;
    } else if(BCM_PHY_GPORT_IS_PHYN_LANE(port)) {
        local_port = BCM_PHY_GPORT_PHYN_LANE_PORT_PORT_GET(port);
        phyn = BCM_PHY_GPORT_PHYN_LANE_PORT_PHYN_GET(port);
        phy_lane = BCM_PHY_GPORT_PHYN_LANE_PORT_LANE_GET(port);
    } else if(BCM_PHY_GPORT_IS_PHYN_SYS_SIDE(port)) {
        local_port = BCM_PHY_GPORT_PHYN_SYS_SIDE_PORT_PORT_GET(port);
        phyn = BCM_PHY_GPORT_PHYN_SYS_SIDE_PORT_PHYN_GET(port);
        sys_side = TRUE;
        phy_lane = -1;
    } else if(BCM_PHY_GPORT_IS_PHYN_SYS_SIDE_LANE(port)) {
        local_port = BCM_PHY_GPORT_PHYN_SYS_SIDE_LANE_PORT_PORT_GET(port);
        phyn = BCM_PHY_GPORT_PHYN_SYS_SIDE_LANE_PORT_PHYN_GET(port);
        phy_lane = BCM_PHY_GPORT_PHYN_SYS_SIDE_LANE_PORT_LANE_GET(port);
        sys_side = TRUE;
    } else if (BCM_PHY_GPORT_IS_LANE(port)) {
        local_port = BCM_PHY_GPORT_LANE_PORT_PORT_GET(port);
        phy_lane = BCM_PHY_GPORT_LANE_PORT_LANE_GET(port);
    } else {
        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_gport_validate(unit, port, &port));

        PORT_LOCK(unit);
        rv = soc_phyctrl_control_get(unit, port, (soc_phy_control_t) type, value);
        PORT_UNLOCK(unit);
        return rv;
    }

    if (!SOC_PORT_VALID(unit, local_port)) {
        return BCM_E_PORT;
    }

    PORT_LOCK(unit);
    rv = soc_phyctrl_redirect_control_get(unit, local_port, phyn, phy_lane,
                                          sys_side, (soc_phy_control_t) type, value);
    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_phy_firmware_set
 * Purpose:
 *      Write the firmware to the PHY device's non-volatile storage.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port number
 *      flags - (IN) PHY spcific flags, such as BCM_PORT_PHY_INTERNAL
 *      offset - (IN) Offset to the firmware data array
 *      array - (IN)  The firmware data array
 *      length - (IN) The length of the firmware data array
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_phy_firmware_set(int unit, bcm_port_t port, uint32 flags,
                              int offset, uint8 *array, int length)
{
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);
    rv = soc_phyctrl_firmware_set(unit, port, flags,offset,array,length);
    PORT_UNLOCK(unit);

    return rv;
}

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
/*
 * Function    : _bcm_esw_port_subport_index_get
 * Description : Get the subport index for the specified mod port.
 *
 * Parameters  : (IN)  unit             - BCM device number
 *               (IN) modport        - GPORT ID
 *               (OUT)  subport_index - subport index
 * Returns     : BCM_E_XXX
 */
int
_bcm_esw_port_subport_index_get(int unit, bcm_gport_t modport,
                                int *subport_index)
{
    int id_out = 0;
    bcm_module_t mod_out = 0;
    bcm_port_t port_out = 0;
    bcm_trunk_t tgid_out = 0;
    int base_index = 0;
    int result = FALSE;
    modid_base_ptr_entry_t modid_base_entry;
    soc_info_t *si = &SOC_INFO(unit);
    int i = 0, valid = 0, modid = 0;

    BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, modport,
                            &mod_out, &port_out, &tgid_out, &id_out));
    if ((-1 != tgid_out) || (-1 != id_out)) {
        return BCM_E_PARAM;
    }

    if (soc_feature(unit, soc_feature_multi_next_hops_on_port)) {
        for (i = 0; i < si->num_modules; i++) {
            if (src_modid_base_index_bk[unit]->multi_nexthop_module_id_list[i]
                == mod_out) {
                BCM_IF_ERROR_RETURN(
                    _bcm_esw_stk_get_mod_config_by_type(unit,
                    BCM_MODID_TYPE_MULTI_NEXT_HOPS, i + 1, &modid, &valid,
                    &base_index));
                if ((valid == 1) && (modid == mod_out)) {
                    if (port_out >
                        src_modid_base_index_bk[unit]->num_ports[modid]) {
                        return BCM_E_PARAM;
                    }
                    *subport_index = base_index + port_out;
                    return BCM_E_NONE;
                }
            }
        }
    }

    /* Check modport in one of additional module */
    BCM_IF_ERROR_RETURN (
        _bcm_esw_my_modid_additional_check(unit, mod_out, &result));
    if(result == FALSE) {
        return BCM_E_PORT;
    }
    MODULE_ID_LOWER_6_BITS(mod_out); /* lower 6 bit */
    SOC_IF_ERROR_RETURN(
        READ_MODID_BASE_PTRm(unit, MEM_BLOCK_ANY, mod_out,
        &modid_base_entry));
    base_index = soc_MODID_BASE_PTRm_field32_get(
                    unit, &modid_base_entry, MODID_BASEf);
    *subport_index = base_index; /* the index is indicated by module base ptr */

    return BCM_E_NONE;
}

/*
 * Function    : _bcm_esw_modport_local_get
 * Description : Get the physical port for the specified mod port.
 *
 * Parameters  : (IN)     unit                 - BCM device number
 *                     (IN)     modport          - Gport number
 *                     (OUT)  local_port        - port number
 *
 * Returns     : BCM_E_XXX
 */
int _bcm_esw_modport_local_get(int unit, bcm_gport_t modport, bcm_port_t *local_port)
{
    int subport_index = 0;
    modport_map_subport_entry_t modport_map_subport_entry;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Parameter check */
    if (!BCM_GPORT_IS_MODPORT(modport)) {
        return BCM_E_PARAM;
    }

    if(local_port == NULL) {
        return BCM_E_PARAM;
    }

    SOC_IF_ERROR_RETURN(
        _bcm_esw_port_subport_index_get(unit, modport, &subport_index));

    SOC_IF_ERROR_RETURN(
        READ_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ANY, subport_index,
                                  &modport_map_subport_entry));
    *local_port = soc_MODPORT_MAP_SUBPORTm_field32_get(
                     unit, &modport_map_subport_entry, DESTf);

    return BCM_E_NONE;
}
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

/*
 * Function    : bcm_esw_port_local_get
 * Description : Get the local port from the given GPORT ID.
 *
 * Parameters  : (IN)  unit         - BCM device number
 *               (IN)  gport        - global port identifier
 *               (OUT) local_port   - local port encoded in gport
 * Returns     : BCM_E_XXX
 */
int
bcm_esw_port_local_get(int unit, bcm_gport_t gport, bcm_port_t *local_port)
{
    bcm_module_t my_mod, encap_mod;
    bcm_port_t encap_port;
    int num_modid, isLocal = 0;
    soc_info_t *si = &SOC_INFO(unit);

#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
    int rv = BCM_E_NONE;
#endif

#if defined(BCM_KATANA2_SUPPORT)
    bcm_trunk_t trunk_id = BCM_TRUNK_INVALID;
    int         id = -1;
    int         pp_port = 0;
    int         min_pp_port = SOC_INFO(unit).pp_port_index_min;
    int         max_pp_port = SOC_INFO(unit).pp_port_index_max;
#endif /* BCM_KATANA2_SUPPORT */

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(bcm_esw_stk_modid_count(unit, &num_modid));
    if ((!num_modid) && !BCM_GPORT_IS_DEVPORT(gport) ){
        /* Only devport gport can be supported on device with no modid */
        return BCM_E_UNAVAIL;
    }

    if (BCM_GPORT_IS_LOCAL(gport)) {
         *local_port = BCM_GPORT_LOCAL_GET(gport);
    } else if (BCM_GPORT_IS_LOCAL_CPU(gport)) {
        *local_port = CMIC_PORT(unit);
    } else if (BCM_GPORT_IS_DEVPORT(gport)) {
        *local_port = BCM_GPORT_DEVPORT_PORT_GET(gport);
        if (unit != BCM_GPORT_DEVPORT_DEVID_GET(gport)) {
            return BCM_E_PORT;
        }
    } else if (BCM_GPORT_IS_MODPORT(gport) || BCM_GPORT_IS_PROXY(gport)) {
        BCM_IF_ERROR_RETURN(
            bcm_esw_stk_my_modid_get(unit, &my_mod));

        if (BCM_GPORT_IS_MODPORT(gport)) {
            encap_mod = BCM_GPORT_MODPORT_MODID_GET(gport);
            encap_port = BCM_GPORT_MODPORT_PORT_GET(gport);
        } else {
            encap_mod = BCM_GPORT_PROXY_MODID_GET(gport);
            encap_port = BCM_GPORT_PROXY_PORT_GET(gport);
        }

        if (encap_mod == my_mod){
            *local_port = encap_port;
        } else if ((num_modid > 1) &&
                   !si->coe_stacking_mode) {
            BCM_IF_ERROR_RETURN(
                _bcm_esw_modid_is_local(unit, encap_mod, &isLocal));
            if (isLocal) {
#if defined(BCM_TOMAHAWK_SUPPORT)
                /* Call asymmetric dual modid unmapping function */
                if (soc_feature(unit, soc_feature_asymmetric_dual_modid)) {
                    BCM_IF_ERROR_RETURN (
                        _bcm_esw_stk_asymmetric_dual_modmap_map(unit,
                                BCM_STK_MODMAP_SET, &encap_mod, &encap_port));
                    *local_port = encap_port;
                } else
#endif /* BCM_TOMAHAWK_SUPPORT */
                {
                    *local_port = encap_port +
                        (encap_mod - my_mod) * (SOC_MODPORT_MAX(unit) + 1);
                }
            } else {
                return BCM_E_PORT;
            }
        } else {

#if defined(BCM_KATANA2_SUPPORT)
            if (soc_feature(unit, soc_feature_linkphy_coe) ||
                soc_feature(unit, soc_feature_subtag_coe)) {
                if (_bcm_kt2_mod_is_coe_mod_check(unit, encap_mod) == BCM_E_NONE) {
                    BCM_IF_ERROR_RETURN(
                        _bcm_kt2_modport_to_pp_port_get(unit,
                            encap_mod, encap_port, &pp_port));
#if defined BCM_METROLITE_SUPPORT
                    if (soc_feature(unit, soc_feature_discontinuous_pp_port)) {
                        if (_SOC_IS_PP_PORT_LINKPHY_SUBTAG(unit, pp_port)) {
                            *local_port = pp_port;
                            return BCM_E_NONE;
                        }
                    } else
#endif
                    {
                        if ((pp_port >= min_pp_port) && (pp_port <= max_pp_port)) {
                            *local_port = pp_port;
                            return BCM_E_NONE;
                        }
                    }
                }
            } else
#endif
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
            if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
                soc_feature(unit, soc_feature_channelized_switching)) &&
                _bcm_xgs5_subport_coe_mod_port_local(unit, encap_mod, encap_port)) {
                BCM_IF_ERROR_RETURN(
                _bcmi_coe_subport_mod_port_physical_port_get(unit, encap_mod,
                                                        encap_port, local_port));
            }
            /* Call modport to local function */
            else if (soc_feature(unit, soc_feature_multi_next_hops_on_port)) {
                BCM_IF_ERROR_RETURN (
                    _bcm_esw_modport_local_get(unit, gport, &encap_port));
                *local_port = encap_port;
            } else
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
            {
                return BCM_E_PORT;
            }
        }
        if (soc_feature(unit, soc_feature_sysport_remap)) {
            BCM_XLATE_SYSPORT_S2P(unit, local_port);
        }
        if (!SOC_PORT_VALID(unit, *local_port)) {
            return BCM_E_PORT;
        }
    } else if (BCM_GPORT_IS_SUBPORT_PORT(gport)) {

#if defined(BCM_HGPROXY_COE_SUPPORT)
        if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
            soc_feature(unit, soc_feature_channelized_switching)) &&
            _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, gport)) {
            return _bcmi_coe_subport_physical_port_get(unit, gport, local_port);
        } else
#endif /* BCM_HGPROXY_COE_SUPPORT */
#if defined(BCM_KATANA2_SUPPORT)
        if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit, gport)) {
            pp_port = BCM_GPORT_SUBPORT_PORT_GET(gport);
            BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, &my_mod));
            BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, gport, &encap_mod,
                                    &encap_port, &trunk_id, &id));
            if (_bcm_kt2_mod_is_coe_mod_check(unit, encap_mod) == BCM_E_NONE) {
#if defined BCM_METROLITE_SUPPORT
                if (soc_feature(unit, soc_feature_discontinuous_pp_port)) {
                    if (_SOC_IS_PP_PORT_LINKPHY_SUBTAG(unit, pp_port)) {
                        *local_port = pp_port;
                        return BCM_E_NONE;
                    }
                } else
#endif
                {
                    if ((pp_port >= min_pp_port) && (pp_port <= max_pp_port)) {
                        *local_port = pp_port;
                        return BCM_E_NONE;
                    }
                }
            }
        }
#endif
        return BCM_E_PORT;
    } else if (BCM_GPORT_IS_VLAN_PORT(gport)) {
        *local_port = BCM_GPORT_VLAN_PORT_ID_GET(gport);
    } else if (BCM_GPORT_IS_EXTENDER_PORT(gport)) {
        *local_port = BCM_GPORT_EXTENDER_PORT_ID_GET(gport);
    } else if (BCM_GPORT_IS_NIV_PORT(gport)) {
        *local_port = BCM_GPORT_NIV_PORT_ID_GET(gport);
    } else if (BCM_GPORT_IS_VXLAN_PORT(gport)) {
        *local_port = BCM_GPORT_VXLAN_PORT_ID_GET(gport);
    } else if (BCM_GPORT_IS_FLOW_PORT(gport)) {
        *local_port = BCM_GPORT_FLOW_PORT_ID_GET(gport);
    } else if (BCM_GPORT_IS_L2GRE_PORT(gport)) {
        *local_port = BCM_GPORT_L2GRE_PORT_ID_GET(gport);
    } else if (BCM_GPORT_IS_MIM_PORT(gport)) {
        *local_port = BCM_GPORT_MIM_PORT_ID_GET(gport);
    } else if (BCM_GPORT_IS_MPLS_PORT(gport)) {
        *local_port = BCM_GPORT_MPLS_PORT_ID_GET(gport);
    } else if (BCM_GPORT_IS_TRUNK(gport)) {
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
        if (soc_feature(unit, soc_feature_vp_lag)) {
            rv = _bcm_esw_trunk_tid_to_vp_lag_vp(unit,
                     BCM_GPORT_TRUNK_GET(gport),local_port);
            return (rv != BCM_E_NONE) ? BCM_E_PORT : BCM_E_NONE;
        }
#endif /* BCM_TRIDENT2_SUPPORT && INCLUDE_L3 */
        return BCM_E_PORT;
    } else if (BCM_GPORT_IS_VP_GROUP(gport)) {
        *local_port = BCM_GPORT_VP_GROUP_GET(gport);
    } else {
        return BCM_E_PORT;
    }

    return BCM_E_NONE;
}

#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_KATANA2_SUPPORT)

/*
 * Function    : _bcm_esw_modid_is_coe_mod
 * Description : Identifies if given modid is a CoE module
 *
 * Parameters  : (IN)   unit      - BCM device number
 *               (IN)   modnd     - Module ID
 * Returns     : BCM_E_NONE, if it is a CoE Module
 *               BCM_E_NOT_FOUND, if it is not a CoE Module
 */

int
_bcm_esw_modid_is_coe_mod(int unit, bcm_module_t modid)
{
    bcm_stk_modid_config_t mod_cfg;
    mod_cfg.modid = modid;

	mod_cfg.modid_type = bcmStkModidTypeCoe;

    /* Also check if this is one of the CoE modules */
    return bcm_esw_stk_modid_config_get(unit, &mod_cfg);
}
#endif

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
/*
 * Function    : _bcm_esw_modid_is_multi_nexthop_mod
 * Description : Identifies if given modid is a Multi Next Hop module
 *
 * Parameters  : (IN)   unit      - BCM device number
 *               (IN)   modnd     - Module ID
 * Returns     : BCM_E_NONE, if it is a Multi Next Hop Module
 *               BCM_E_NOT_FOUND, if it is not a Multi Next Hop Module
 */

int
_bcm_esw_modid_is_multi_nexthop_mod(int unit, bcm_module_t modid)
{
    bcm_stk_modid_config_t mod_cfg;

    if ((modid < 0) || (modid > SOC_MODID_MAX(unit))) {
        return BCM_E_PARAM;
    }
    mod_cfg.modid = modid;
    mod_cfg.modid_type = bcmStkModidTypeMultiNextHops;

    /* Also check if this is one of the Multi Next Hop modules */
    return bcm_esw_stk_modid_config_get(unit, &mod_cfg);
}

/*
  * Function    : _bcm_esw_is_multi_nexthop_mod_port
  * Description : Identifies if given modid is a Multi Next Hop module port
  *
  * Parameters  : (IN)   unit - BCM device number
  *               (IN)   modid - Mod Id value
  *               (IN)   port - Port Id value
  * Returns : TRUE if is Multi Next Hop module port, FALSE otherwise
  */
int
_bcm_esw_is_multi_nexthop_mod_port(int unit, bcm_module_t modid,
                                         bcm_port_t port)
{
    int rv = BCM_E_NONE;
    int result = FALSE;

    if(_bcm_esw_modid_is_multi_nexthop_mod(unit, modid) == BCM_E_NONE) {
        if (port <= src_modid_base_index_bk[unit]->num_ports[modid]) {
            return TRUE;
        }
    } else {
        rv = _bcm_esw_my_modid_additional_check(unit, modid, &result);
        if (BCM_FAILURE(rv)) {
            return FALSE;
        }
        return result;
    }
    return FALSE;
}
#endif

/*
 * Function    : _bcm_esw_modid_is_local
 * Description : Identifies if given modid is local on a given unit
 *
 * Parameters  : (IN)   unit      - BCM device number
 *               (IN)   modnd     - Module ID
 *               (OUT)  result    - TRUE if modid is local, FALSE otherwise
 * Returns     : BCM_E_XXX
 */
int
_bcm_esw_modid_is_local(int unit, bcm_module_t modid, int *result)
{
    bcm_module_t    mymodid;
    int             rv;
    soc_info_t *si=&SOC_INFO(unit);

    /* Input parameters check. */
    if (NULL == result) {
        return (BCM_E_PARAM);
    }

    COMPILER_REFERENCE(si);

    /* Get local module id. */
    rv = bcm_esw_stk_my_modid_get(unit, &mymodid);
    if (BCM_E_UNAVAIL == rv) {
        if (BCM_MODID_INVALID == modid) {
            *result = TRUE;
        } else {
#if defined(BCM_HGPROXY_COE_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
            /* If hg_proxy or if (subtag/linkPhy-Coe && stacking-mode)
               check the local modid */
            if (((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
                soc_feature(unit, soc_feature_channelized_switching)) ||
                ((soc_feature(unit, soc_feature_subtag_coe) ||
                  (soc_feature(unit, soc_feature_linkphy_coe))) &&
                  si->coe_stacking_mode)) &&
                (_bcm_esw_modid_is_coe_mod(unit, modid) == BCM_E_NONE)) {
                    *result = TRUE;
            } else
#endif
            {
                *result = FALSE;
            }
        }
        return (BCM_E_NONE);
    }

    if (mymodid == modid) {
        *result = TRUE;
    } else if ((modid > mymodid) && (modid < mymodid + NUM_MODID(unit))) {
        *result = TRUE;
    }
#if defined(BCM_HGPROXY_COE_SUPPORT)  || defined(BCM_KATANA2_SUPPORT)
    /* If hg_proxy or if (subtag/linkPhy-Coe && stacking-mode)
       check the local modid */
    else if (((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        soc_feature(unit, soc_feature_channelized_switching)) ||
        ((soc_feature(unit, soc_feature_subtag_coe) ||
          (soc_feature(unit, soc_feature_linkphy_coe))) &&
          si->coe_stacking_mode)) &&
        (_bcm_esw_modid_is_coe_mod(unit, modid) == BCM_E_NONE)) {
            *result = TRUE;
	}
#endif /* BCM_HGPROXY_COE_SUPPORT || BCM_KATANA2_SUPPORT */
    else {
        *result = FALSE;
    }

    return (BCM_E_NONE);
}


/*
 * Function    : _bcm_gport_modport_hw2api_map
 * Description : Remaps module and port from HW space to API space
 *
 * Parameters  : (IN)  unit      - BCM device number
 *               (IN)  mod_in    - Module ID to map
 *               (IN)  port_in   - Physical port to map
 *               (OUT)  mod_out  - Module ID after mapping
 *               (OUT)  port_out - Port number after mapping
 * Returns     : BCM_E_XXX
 * Notes       : If mod_out == NULL then port_out will be local physical port.
 */
int
_bcm_gport_modport_hw2api_map(int unit, bcm_module_t mod_in, bcm_port_t port_in,
                              bcm_module_t *mod_out, bcm_port_t *port_out)
{
    if (port_out == NULL) {
        return (BCM_E_PARAM);
    }

    if (NUM_MODID(unit) == 1) { /* HW device has single modid */
        if (mod_out != NULL) {
            *mod_out = mod_in;
        }
        *port_out = port_in;

        return (BCM_E_NONE);
    }
    /* Here only for devices with multiple modid NUM_MODID(unit) > 1 */
    if (mod_out == NULL) {  /* physical port requested */
        int             isLocal = 0;
        bcm_module_t    mymodid;
        BCM_IF_ERROR_RETURN(
            _bcm_esw_modid_is_local(unit, mod_in, &isLocal));
        if (isLocal != TRUE) {
            return (BCM_E_PARAM);
        }
        BCM_IF_ERROR_RETURN (bcm_esw_stk_my_modid_get(unit, &mymodid));

#if defined(BCM_TOMAHAWK_SUPPORT)
        /* Call asymmetric dual modid unmapping function */
        if (soc_feature(unit, soc_feature_asymmetric_dual_modid)) {
            BCM_IF_ERROR_RETURN (
                _bcm_esw_stk_asymmetric_dual_modmap_map(unit,
                            BCM_STK_MODMAP_SET, &mod_in, &port_in));
            *port_out = port_in;
        } else
#endif /* BCM_TOMAHAWK_SUPPORT */
        {
            *port_out = port_in +
                (mod_in - mymodid) * (SOC_MODPORT_MAX(unit) + 1);
        }
    } else {    /* NUM_MODID(unit) > 1 and not local physical port */
#if defined(BCM_TOMAHAWK_SUPPORT)
        /* Call asymmetric dual modid mapping function */
        if (soc_feature(unit, soc_feature_asymmetric_dual_modid)) {
            BCM_IF_ERROR_RETURN (
                _bcm_esw_stk_asymmetric_dual_modmap_map(unit,
                            BCM_STK_MODMAP_GET, &mod_in, &port_in));
            *mod_out = mod_in;
            *port_out = port_in;
        } else
#endif /* BCM_TOMAHAWK_SUPPORT */
        {
            *port_out = port_in % (SOC_MODPORT_MAX(unit) + 1);
            *mod_out = mod_in + port_in / (SOC_MODPORT_MAX(unit) + 1);
        }
    }

    return (BCM_E_NONE);
}

/*
 * Function    : bcm_port_gport_get
 * Description : Get the GPORT ID for the specified physical port.
 *
 * Parameters  : (IN)  unit      - BCM device number
 *               (IN)  port      - Port number
 *               (OUT) gport     - GPORT ID
 * Returns     : BCM_E_XXX
 * Notes:
 *     Always returns a MODPORT gport or an error.
 */
int
bcm_esw_port_gport_get(int unit, bcm_port_t port, bcm_gport_t *gport)
{
    int                 rv;
    _bcm_gport_dest_t   dest;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    _bcm_gport_dest_t_init(&dest);

#if defined(BCM_FIREBOLT6_SUPPORT)
    if (SOC_IS_FIREBOLT6(unit)) {
        BCM_IF_ERROR_RETURN
            (bcm_fb6_port_param_check(unit, port));
    } else
#endif
    {
        PORT_PARAM_CHECK(unit, port);
    }

    rv = bcm_esw_stk_my_modid_get(unit, &dest.modid);

    if (BCM_FAILURE(rv)) {
        return BCM_E_UNAVAIL;
    }

    if (soc_feature(unit, soc_feature_sysport_remap)) {
        BCM_XLATE_SYSPORT_P2S(unit, &port);
    }

    dest.port = port;
    dest.gport_type = _SHR_GPORT_TYPE_MODPORT;

    /* In this case we can safely assume that a port is in hw format */
    /* since it is a physical port number */
    BCM_IF_ERROR_RETURN
        (_bcm_gport_modport_hw2api_map(unit, dest.modid, dest.port,
                                       &(dest.modid), &(dest.port)));

    return _bcm_esw_gport_construct(unit, &dest, gport);
}

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
/*
 * Function    : bcm_port_gport_add
 * Description : Add the GPORT ID for the specified physical port.
 *
 * Parameters  : (IN)  unit             - BCM device number
 *               (IN)  local_port     - Port number
 *               (IN)  modport       - GPORT ID
 * Returns     : BCM_E_XXX
 */
int
_bcm_esw_port_gport_add(int unit, bcm_port_t local_port,
                               bcm_gport_t modport)
{
    int subport_index = 0;
    bcm_port_t old_local_port = 0;
    modport_map_subport_entry_t modport_map_subport_entry;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Parameter check */
    PORT_PARAM_CHECK(unit, local_port);
    if (!BCM_GPORT_IS_MODPORT(modport)) {
        return BCM_E_PARAM;
    }

    SOC_IF_ERROR_RETURN(
        _bcm_esw_port_subport_index_get(unit, modport, &subport_index));

    SOC_IF_ERROR_RETURN
        (READ_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ANY, subport_index,
                                       &modport_map_subport_entry));
    old_local_port = soc_MODPORT_MAP_SUBPORTm_field32_get(unit,
                                       &modport_map_subport_entry, DESTf);
    if(old_local_port == local_port) {
        return BCM_E_NONE;
    }
    if(old_local_port) {
        return BCM_E_RESOURCE;
    }

    soc_MODPORT_MAP_SUBPORTm_field32_set (unit,
                         &modport_map_subport_entry, DESTf, local_port);
    soc_MODPORT_MAP_SUBPORTm_field32_set (unit,
                         &modport_map_subport_entry, ISTRUNKf, 0);
    soc_MODPORT_MAP_SUBPORTm_field32_set (unit,
                         &modport_map_subport_entry, ENABLEf, 1);
    SOC_IF_ERROR_RETURN
        (WRITE_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ANY, subport_index,
                                        &modport_map_subport_entry));

    return BCM_E_NONE;
}

/*
 * Function    : bcm_port_gport_get_all
 * Description : Get all the extra GPORT ID for the specified physical port.
 *
 * Parameters  : (IN)     unit                 - BCM device number
 *                     (IN)     local_port        - Port number
 *                     (IN)     modport_max   - size of gport array
 *                     (OUT)  gport_array      - Gport number
 *                     (OUT)  count              - GPORT count
 * Returns     : BCM_E_XXX
 * Notes:
 *     Always returns MODPORT gports or an error.
 */
int _bcm_esw_port_gport_get_all(int unit, bcm_port_t local_port, int size,
                                      bcm_gport_t *gport_array, int *count)
{
    int rv = BCM_E_NONE;
    int mod_idx = 0;
    int port_idx = 0;
    int base_index = 0;
    bcm_gport_t modport = 0;
    _bcm_gport_dest_t dest;
    bcm_port_t egress_port = 0;
    bcm_stk_modid_config_t mod_cfg;
    modid_base_ptr_entry_t modid_base_entry;
    modport_map_subport_entry_t modport_map_subport_entry;
    soc_info_t *si = &SOC_INFO(unit);
    int i = 0, valid = 0, modid = 0, n_ports = 0;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Parameter check */
    PORT_PARAM_CHECK(unit, local_port);
    if (size < 0 || count == NULL) {
        return BCM_E_PARAM;
    }

    if ((size > 0) && gport_array == NULL) {
        return BCM_E_PARAM;
    }

    mod_cfg.modid_type = bcmStkModidTypeMultiNextHops;
    mod_cfg.modid = BCM_MODID_INVALID;
    BCM_IF_ERROR_RETURN(bcm_esw_stk_modid_config_get(unit, &mod_cfg));

    *count = 0;
    if (size == 0) {
        if (soc_feature(unit, soc_feature_multi_next_hops_on_port)) {
            for (i = 0; i < si->num_modules; i++) {
                if (src_modid_base_index_bk[unit]->multi_nexthop_module_id_list[i] ==
                    BCM_MODID_INVALID) {
                    continue;
                }
                BCM_IF_ERROR_RETURN(
                    _bcm_esw_stk_get_mod_config_by_type(unit,
                    BCM_MODID_TYPE_MULTI_NEXT_HOPS, i + 1, &modid, &valid,
                    &base_index));
                if (valid == 0) {
                    continue;
                }
                n_ports = src_modid_base_index_bk[unit]->num_ports[modid];
                for (port_idx = base_index; port_idx < base_index + n_ports;
                     port_idx++) {
                     SOC_IF_ERROR_RETURN
                         (READ_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ANY, port_idx,
                                                    &modport_map_subport_entry));
                     /* Check if index is used. */
                     egress_port = soc_MODPORT_MAP_SUBPORTm_field32_get(unit,
                                                 &modport_map_subport_entry, DESTf);
                     if(egress_port == local_port) {/*  Entry found. */
                         (*count)++;
                     }
                }
            }
        }

        for (mod_idx = mod_cfg.modid; mod_idx < mod_cfg.modid + mod_cfg.num_mods;
             mod_idx ++) {
            MODULE_ID_LOWER_6_BITS(mod_idx); /* lower 6 bit */
            SOC_IF_ERROR_RETURN(
                READ_MODID_BASE_PTRm(unit, MEM_BLOCK_ANY, mod_idx,
                &modid_base_entry));
            base_index =
                soc_MODID_BASE_PTRm_field32_get(unit, &modid_base_entry,
                MODID_BASEf);
            SOC_IF_ERROR_RETURN(
                READ_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ANY, base_index,
                &modport_map_subport_entry));
            /* Check if index is used. */
            egress_port =
                soc_MODPORT_MAP_SUBPORTm_field32_get(unit,
                &modport_map_subport_entry, DESTf);
            if (egress_port == local_port) {/*  Entry found. */
                (*count)++;
            }
        }
        return BCM_E_NONE;
    }

    _bcm_gport_dest_t_init(&dest);
    if (soc_feature(unit, soc_feature_multi_next_hops_on_port)) {
        for (i = 0; i < si->num_modules; i++) {
            if (src_modid_base_index_bk[unit]->multi_nexthop_module_id_list[i] ==
                BCM_MODID_INVALID) {
                continue;
            }
            BCM_IF_ERROR_RETURN(
                _bcm_esw_stk_get_mod_config_by_type(unit,
                BCM_MODID_TYPE_MULTI_NEXT_HOPS, i + 1, &modid, &valid,
                &base_index));
            if (valid == 0) {
                continue;
            }
            n_ports = src_modid_base_index_bk[unit]->num_ports[modid];
            for (port_idx = base_index; port_idx < base_index + n_ports;
                 port_idx++) {
                if ((*count) < size) {
                    SOC_IF_ERROR_RETURN
                        (READ_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ANY, port_idx,
                                                   &modport_map_subport_entry));
                    /* Check if index is used. */
                    egress_port = soc_MODPORT_MAP_SUBPORTm_field32_get(unit,
                                                &modport_map_subport_entry, DESTf);
                    if (egress_port == local_port) {
                        /*  Entry found. */
                        dest.port = port_idx - base_index;
                        dest.modid = modid;
                        dest.gport_type = _SHR_GPORT_TYPE_MODPORT;
                        rv = _bcm_esw_gport_construct(unit, &dest, &modport);
                        gport_array[(*count)++] = modport;
                    }
                }
            }
        }
    }

    for (mod_idx = mod_cfg.modid; mod_idx < mod_cfg.modid + mod_cfg.num_mods;
         mod_idx ++) {
        MODULE_ID_LOWER_6_BITS(mod_idx); /* lower 6 bit */
        SOC_IF_ERROR_RETURN
            (READ_MODID_BASE_PTRm(unit, MEM_BLOCK_ANY, mod_idx, &modid_base_entry));
        base_index = soc_MODID_BASE_PTRm_field32_get(unit,
                                       &modid_base_entry, MODID_BASEf);
        if ((*count) < size) {
            SOC_IF_ERROR_RETURN(
                READ_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ANY, base_index,
                &modport_map_subport_entry));
            /* Check if index is used. */
            egress_port =
                soc_MODPORT_MAP_SUBPORTm_field32_get(unit,
                &modport_map_subport_entry, DESTf);
            if (egress_port == local_port) {
                /*  Entry found. */
                dest.port = BCM_PORT_INVALID;
                dest.modid = mod_idx;
                dest.gport_type = _SHR_GPORT_TYPE_MODPORT;
                rv = _bcm_esw_gport_construct(unit, &dest, &modport);
                gport_array[(*count)++] = modport;
            }
        }
    }

    return rv;
}

/*
 * Function    : bcm_port_gport_delete
 * Description : Delete the mapping of the specified GPORT.
 *
 * Parameters  : (IN)  unit             - BCM device number
 *                     (IN) modport        - GPORT ID
 * Returns     : BCM_E_XXX
 */
int
_bcm_esw_port_gport_delete(int unit, bcm_port_t local_port, bcm_gport_t modport)
{
    int subport_index = 0;
    modport_map_subport_entry_t modport_map_subport_entry;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Parameter check */
    PORT_PARAM_CHECK(unit, local_port);
    if (!BCM_GPORT_IS_MODPORT(modport)) {
        return BCM_E_PARAM;
    }

    SOC_IF_ERROR_RETURN(
        _bcm_esw_port_subport_index_get(unit, modport, &subport_index));

    SOC_IF_ERROR_RETURN
        (READ_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ANY, subport_index,
                                   &modport_map_subport_entry));
    soc_MODPORT_MAP_SUBPORTm_field32_set(unit,
                                   &modport_map_subport_entry, DESTf, 0);
    soc_MODPORT_MAP_SUBPORTm_field32_set (unit,
                                   &modport_map_subport_entry, ISTRUNKf, 0);
    soc_MODPORT_MAP_SUBPORTm_field32_set (unit,
                                 &modport_map_subport_entry, ENABLEf, 0);
    SOC_IF_ERROR_RETURN
        (WRITE_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ANY, subport_index,
                                        &modport_map_subport_entry));

    return BCM_E_NONE;
}

/*
 * Function    : bcm_port_gport_delete_all
 * Description : Delete all the extra mapping of the specified physical port.
 *
 * Parameters  : (IN)  unit             - BCM device number
 *                     (IN) local_port      - PORT ID
 * Returns     : BCM_E_XXX
 */
int
_bcm_esw_port_gport_delete_all(int unit, bcm_port_t local_port)
{
    int mod_idx = 0;
    int port_idx = 0;
    int base_index = 0;
    bcm_port_t egress_port = 0;
    bcm_stk_modid_config_t mod_cfg;
    modid_base_ptr_entry_t modid_base_entry;
    modport_map_subport_entry_t modport_map_subport_entry;
    soc_info_t *si = &SOC_INFO(unit);
    int i = 0, valid = 0, modid = 0, n_ports = 0;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Parameter check */
    PORT_PARAM_CHECK(unit, local_port);

    mod_cfg.modid_type = bcmStkModidTypeMultiNextHops;
    mod_cfg.modid = BCM_MODID_INVALID;
    BCM_IF_ERROR_RETURN(
        bcm_esw_stk_modid_config_get(unit, &mod_cfg));

    if (soc_feature(unit, soc_feature_multi_next_hops_on_port)) {
        for (i = 0; i < si->num_modules; i++) {
            if (src_modid_base_index_bk[unit]->multi_nexthop_module_id_list[i] ==
                BCM_MODID_INVALID) {
                continue;
            }
            BCM_IF_ERROR_RETURN(
                _bcm_esw_stk_get_mod_config_by_type(unit,
                BCM_MODID_TYPE_MULTI_NEXT_HOPS, i + 1, &modid, &valid,
                &base_index));
            if (valid == 0) {
                continue;
            }
            n_ports = src_modid_base_index_bk[unit]->num_ports[modid];
            for (port_idx = base_index; port_idx < base_index + n_ports;
                 port_idx++) {
                 SOC_IF_ERROR_RETURN
                     (READ_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ANY, port_idx,
                                                &modport_map_subport_entry));
                 /* Check if index is used. */
                 egress_port = soc_MODPORT_MAP_SUBPORTm_field32_get(unit,
                                             &modport_map_subport_entry, DESTf);
                 if(egress_port == local_port) {
                     /*  Entry found. */
                     soc_MODPORT_MAP_SUBPORTm_field32_set(
                         unit, &modport_map_subport_entry, DESTf, 0);
                     soc_MODPORT_MAP_SUBPORTm_field32_set(
                         unit, &modport_map_subport_entry, ENABLEf, 0);
                     SOC_IF_ERROR_RETURN
                         (WRITE_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ANY, port_idx,
                                                     &modport_map_subport_entry));
                 }
            }
        }
    }

    for (mod_idx = mod_cfg.modid; mod_idx < mod_cfg.modid + mod_cfg.num_mods;
         mod_idx ++) {
        MODULE_ID_LOWER_6_BITS(mod_idx); /* lower 6 bit */
        SOC_IF_ERROR_RETURN
            (READ_MODID_BASE_PTRm(unit, MEM_BLOCK_ANY, mod_idx, &modid_base_entry));
        base_index = soc_MODID_BASE_PTRm_field32_get(unit,
                                           &modid_base_entry, MODID_BASEf);
        SOC_IF_ERROR_RETURN(
            READ_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ANY, base_index,
            &modport_map_subport_entry));
        /* Check if index is used. */
        egress_port =
            soc_MODPORT_MAP_SUBPORTm_field32_get(unit,
            &modport_map_subport_entry, DESTf);
        if (egress_port == local_port) {
            /*  Entry found. */
            soc_MODPORT_MAP_SUBPORTm_field32_set(
                unit, &modport_map_subport_entry, DESTf, 0);
            soc_MODPORT_MAP_SUBPORTm_field32_set(
                unit, &modport_map_subport_entry, ENABLEf, 0);
            SOC_IF_ERROR_RETURN(
                WRITE_MODPORT_MAP_SUBPORTm(unit, MEM_BLOCK_ANY, port_idx,
                &modport_map_subport_entry));
        }
    }

    return BCM_E_NONE;
}

#endif /* BCM_TRIDENT2PLUS_SUPPORT */

/*
 * Function    : bcm_port_gport_add
 * Description : Add the GPORT ID for the specified physical port.
 *
 * Parameters  : (IN)  unit             - BCM device number
 *                     (IN)  local_port     - Port number
 *                     (IN)  modport       - GPORT ID
 * Returns     : BCM_E_XXX
 */
int
bcm_esw_port_gport_add(int unit, bcm_port_t local_port,
                               bcm_gport_t modport)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (soc_feature(unit, soc_feature_multi_next_hops_on_port)) {
        rv = _bcm_esw_port_gport_add(unit, local_port, modport);
    }
#endif
    return rv;
}

/*
 * Function    : bcm_port_gport_get_all
 * Description : Get all the extra GPORT ID for the specified physical port.
 *
 * Parameters  : (IN)     unit                 - BCM device number
 *                     (IN)     local_port        - Port number
 *                     (IN)     modport_max   - size of gport array
 *                     (OUT)  gport_array      - Gport number
 *                     (OUT)  count              - GPORT count
 * Returns     : BCM_E_XXX
 * Notes:
 */
int bcm_esw_port_gport_get_all(int unit, bcm_port_t local_port, int size,
                                      bcm_gport_t *gport_array, int *count)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (soc_feature(unit, soc_feature_multi_next_hops_on_port)) {
        if (size < 0 || count == NULL) {
            return BCM_E_PARAM;
        }

        if ((size > 0) && gport_array == NULL) {
            return BCM_E_PARAM;
        }

        rv = _bcm_esw_port_gport_get_all(unit, local_port, size, gport_array, count);
    }
#endif
    return rv;
}

/*
 * Function    : bcm_port_gport_delete
 * Description : Delete the mapping of the specified GPORT.
 *
 * Parameters  : (IN)  unit             - BCM device number
 *                     (IN) modport        - GPORT ID
 * Returns     : BCM_E_XXX
 */
int
bcm_esw_port_gport_delete(int unit, bcm_port_t local_port, bcm_gport_t modport)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (soc_feature(unit, soc_feature_multi_next_hops_on_port)) {
        rv = _bcm_esw_port_gport_delete(unit, local_port, modport);
    }
#endif
    return rv;
}

/*
 * Function    : bcm_port_gport_delete_all
 * Description : Delete all the extra mapping of the specified physical port.
 *
 * Parameters  : (IN)  unit             - BCM device number
 *                     (IN) local_port      - PORT ID
 * Returns     : BCM_E_XXX
 */
int
bcm_esw_port_gport_delete_all(int unit, bcm_port_t local_port)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (soc_feature(unit, soc_feature_multi_next_hops_on_port)) {
        rv = _bcm_esw_port_gport_delete_all(unit, local_port);
    }
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_port_gport_is_free
 * Purpose:
 *      Request if the given gport value is available on the device
 * Parameters:
 *      unit - (IN) Unit number.
 *      gport - (IN) GPORT ID.
 * Returns:
 *      BCM_E_NONE -    gport is valid and available on the device
 *      BCM_E_EXISTS -  gport is valid but already in use
 *                      on this device
 *      BCM_E_PARAM -   gport is not valid on this device
 *      BCM_E_UNAVAIL - Feature unavailable
 * Notes:
 */
int
bcm_esw_port_gport_is_free(int unit, bcm_gport_t gport)
{
#if defined(BCM_TRIUMPH_SUPPORT) && defined(INCLUDE_L3)
    int             rv = BCM_E_PARAM;
    int             vp = 0, vp_idx, rv_vp = 0, is_vp = FALSE;
    int             vp_count = 1;     /* Required consecutive VP's */

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (!soc_mem_is_valid(unit, SOURCE_VPm)) {
        /* No virtual ports at this time. */
        return BCM_E_UNAVAIL;
    }

#if defined(BCM_MPLS_SUPPORT)
    if (BCM_GPORT_IS_MPLS_PORT(gport) &&
             soc_feature(unit, soc_feature_mpls)) {
        is_vp = TRUE;
        vp = BCM_GPORT_MPLS_PORT_ID_GET(gport);
        if (vp > soc_mem_index_count(unit, SOURCE_VPm)) {
            rv_vp = -1;
        } else {
            rv_vp = _bcm_vp_used_get(unit, vp, _bcmVpTypeMpls);
        }
    } else
#endif /* BCM_MPLS_SUPPORT */
    if (BCM_GPORT_IS_MIM_PORT(gport) &&
             soc_feature(unit, soc_feature_mim)) {
        is_vp = TRUE;
        vp = BCM_GPORT_MIM_PORT_ID_GET(gport);
        if (vp > soc_mem_index_count(unit, SOURCE_VPm)) {
            rv_vp = -1;
        } else {
            rv_vp = _bcm_vp_used_get(unit, vp, _bcmVpTypeMim);
        }
    } else if (BCM_GPORT_IS_L2GRE_PORT(gport) &&
             soc_feature(unit, soc_feature_l2gre)) {
        is_vp = TRUE;
        vp = BCM_GPORT_L2GRE_PORT_ID_GET(gport);
        if (vp > soc_mem_index_count(unit, SOURCE_VPm)) {
            rv_vp = -1;
        } else {
            rv_vp = _bcm_vp_used_get(unit, vp, _bcmVpTypeL2Gre);
        }
    } else if (BCM_GPORT_IS_VXLAN_PORT(gport) &&
             soc_feature(unit, soc_feature_vxlan)) {
        is_vp = TRUE;
        vp = BCM_GPORT_VXLAN_PORT_ID_GET(gport);
        if (vp > soc_mem_index_count(unit, SOURCE_VPm)) {
            rv_vp = -1;
        } else {
            rv_vp = _bcm_vp_used_get(unit, vp, _bcmVpTypeVxlan);
        }
    } else if (BCM_GPORT_IS_FLOW_PORT(gport) &&
             soc_feature(unit, soc_feature_flex_flow)) {
        is_vp = TRUE;
        vp = BCM_GPORT_FLOW_PORT_ID_GET(gport);
        if (vp > soc_mem_index_count(unit, SOURCE_VPm)) {
            rv_vp = -1;
        } else {
            rv_vp = _bcm_vp_used_get(unit, vp, _bcmVpTypeFlow);
        }
    } else if (BCM_GPORT_IS_WLAN_PORT(gport) &&
             soc_feature(unit, soc_feature_wlan)) {
        is_vp = TRUE;
        vp = BCM_GPORT_WLAN_PORT_ID_GET(gport);
        if (SOC_MEM_IS_VALID(unit, WLAN_SVP_TABLEm)) {
            if (vp > soc_mem_index_count(unit, WLAN_SVP_TABLEm)) {
                rv_vp = -1;
            } else {
                rv_vp = _bcm_vp_used_get(unit, vp, _bcmVpTypeWlan);
            }

        } else if (SOC_MEM_IS_VALID(unit, SOURCE_VP_ATTRIBUTES_2m)) {
            if (vp > soc_mem_index_count(unit, SOURCE_VP_ATTRIBUTES_2m)) {
                rv_vp = -1;
            } else {
                rv_vp = _bcm_vp_used_get(unit, vp, _bcmVpTypeWlan);
            }
        } else {
            rv_vp = -1;
        }
    } else if (BCM_GPORT_IS_TRILL_PORT(gport) &&
             soc_feature(unit, soc_feature_trill)) {
        is_vp = TRUE;
        vp = BCM_GPORT_TRILL_PORT_ID_GET(gport);
        if (vp > soc_mem_index_count(unit, SOURCE_VPm)) {
            rv_vp = -1;
        } else {
            rv_vp = _bcm_vp_used_get(unit, vp, _bcmVpTypeTrill);
        }
    } else if (BCM_GPORT_IS_VLAN_PORT(gport) &&
             soc_feature(unit, soc_feature_vlan_vp)) {
        is_vp = TRUE;
        vp = BCM_GPORT_VLAN_PORT_ID_GET(gport);
        if (vp > soc_mem_index_count(unit, SOURCE_VPm)) {
            rv_vp = -1;
        } else {
            rv_vp = _bcm_vp_used_get(unit, vp, _bcmVpTypeVlan);
        }
    } else if (BCM_GPORT_IS_NIV_PORT(gport) &&
             soc_feature(unit, soc_feature_niv)) {
        is_vp = TRUE;
        vp = BCM_GPORT_NIV_PORT_ID_GET(gport);
        if (vp > soc_mem_index_count(unit, SOURCE_VPm)) {
            rv_vp = -1;
        } else {
            rv_vp = _bcm_vp_used_get(unit, vp, _bcmVpTypeNiv);
        }
    }
#if defined(BCM_TRIUMPH2_SUPPORT)
    else if ((BCM_GPORT_IS_SUBPORT_GROUP(gport) ||
              BCM_GPORT_IS_SUBPORT_PORT(gport)) &&
             soc_feature(unit, soc_feature_subport_enhanced)) {
        /* No TR/SC support for now */
        rv_vp = _bcm_tr2_subport_gport_used(unit, gport);
        if (BCM_E_NOT_FOUND == rv_vp) {
            rv = BCM_E_NONE;
            /* Now we need to check if the VP is in use by something else,
             * using the logic below. */
            is_vp = TRUE;
            rv_vp = 0;
            if (BCM_GPORT_IS_SUBPORT_GROUP(gport)) {
                vp = BCM_GPORT_SUBPORT_GROUP_GET(gport);
                vp = (vp / 8) * 8;
                vp_count = 8;
            } else {
                vp = BCM_GPORT_SUBPORT_PORT_GET(gport);
            }
        } else if (BCM_E_NONE == rv_vp) {
            rv = BCM_E_EXISTS;
        } else {
            rv = rv_vp;
        }
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

    if (is_vp) {
        if (0 == rv_vp) {
            /* Double-check no other protocol is using this VP */
            for (vp_idx = 0; vp_idx < vp_count; vp_idx++) {
                rv_vp = _bcm_vp_used_get(unit, vp + vp_idx, _bcmVpTypeAny);
                if (0 == rv_vp) {
                    rv = BCM_E_NONE;
                } else {
                    rv = BCM_E_EXISTS;
                    break;
                }
            }
        } else if (-1 != rv_vp) {
            rv =  BCM_E_EXISTS;
        } /* else parameter error */
    }
    /* subport */

    return rv;
#else
    return BCM_E_UNAVAIL;
#endif /* BCM_TRIUMPH_SUPPORT && INCLUDE_L3 */
}

/*
 * Function:
 *      bcm_esw_port_gport_free_range_get
 * Purpose:
 *      Retrieve the minimum and maximum unallocated gport values for
 *       a given gport type.
 * Parameters:
 *      unit - (IN) Unit number.
 *      gport_type - (IN) One of BCM_GPORT_TYPE_* or BCM_GPORT_*_PORT values.
 *      gport_min - (OUT) Minimum available gport value of type gport_type
 *      gport_max - (OUT) Maximum available gport value of type gport_type
 * Returns:
 *      BCM_E_NONE -      Valid gports range of requested type returned
 *      BCM_E_NOT_FOUND - No available gports of this type
 *      BCM_E_PARAM -     Gport type is not valid on this device
 *      BCM_E_UNAVAIL -   Feature unavailable
 * Notes:
 */
int
bcm_esw_port_gport_free_range_get(int unit, uint32 gport_type,
                                  bcm_gport_t *gport_min,
                                  bcm_gport_t *gport_max)
{
#if defined(BCM_TRIUMPH_SUPPORT) && defined(INCLUDE_L3)
    bcm_gport_t     dev_min, dev_max, gport, free_min, free_max;
    int             rv = BCM_E_PARAM;
    int             svp_max;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (soc_mem_is_valid(unit, SOURCE_VPm)) {
        svp_max = soc_mem_index_max(unit, SOURCE_VPm);
    } else {
        /* No virtual ports at this time. */
        return BCM_E_UNAVAIL;
    }

    switch (gport_type) {
    case BCM_GPORT_MPLS_PORT:
        BCM_GPORT_MPLS_PORT_ID_SET(dev_min, 0);
        BCM_GPORT_MPLS_PORT_ID_SET(dev_max, svp_max);
        break;
    case BCM_GPORT_MIM_PORT:
        BCM_GPORT_MIM_PORT_ID_SET(dev_min, 0);
        BCM_GPORT_MIM_PORT_ID_SET(dev_max, svp_max);
        break;
    case BCM_GPORT_L2GRE_PORT:
        BCM_GPORT_L2GRE_PORT_ID_SET(dev_min, 0);
        BCM_GPORT_L2GRE_PORT_ID_SET(dev_max, svp_max);
        break;
    case BCM_GPORT_VXLAN_PORT:
        BCM_GPORT_VXLAN_PORT_ID_SET(dev_min, 0);
        BCM_GPORT_VXLAN_PORT_ID_SET(dev_max, svp_max);
        break;
    case BCM_GPORT_WLAN_PORT:
        BCM_GPORT_WLAN_PORT_ID_SET(dev_min, 0);
        BCM_GPORT_WLAN_PORT_ID_SET(dev_max, svp_max);
        break;
    case BCM_GPORT_TRILL_PORT:
        BCM_GPORT_TRILL_PORT_ID_SET(dev_min, 0);
        BCM_GPORT_TRILL_PORT_ID_SET(dev_max, svp_max);
        break;
    case BCM_GPORT_VLAN_PORT:
        BCM_GPORT_VLAN_PORT_ID_SET(dev_min, 0);
        BCM_GPORT_VLAN_PORT_ID_SET(dev_max, svp_max);
        break;
    case BCM_GPORT_NIV_PORT:
        BCM_GPORT_NIV_PORT_ID_SET(dev_min, 0);
        BCM_GPORT_NIV_PORT_ID_SET(dev_max, svp_max);
        break;
    case BCM_GPORT_SUBPORT_GROUP:
        BCM_GPORT_SUBPORT_GROUP_SET(dev_min, 0);
        BCM_GPORT_SUBPORT_GROUP_SET(dev_max, svp_max);
        break;
    case BCM_GPORT_SUBPORT_PORT:
        BCM_GPORT_SUBPORT_PORT_SET(dev_min, 0);
        BCM_GPORT_SUBPORT_PORT_SET(dev_max, svp_max);
        break;
    default:
        /* Not a supported gport type at this time */
        return rv;
    }

    free_min = free_max = 0; /* Invalid multicast group */
    for (gport = dev_min; gport <= dev_max; gport++) {
        rv = bcm_esw_port_gport_is_free(unit, gport);
        if (BCM_SUCCESS(rv)) {
            if (0 == free_min) {
                free_min = gport;
            }
            free_max = gport;
        } else if (BCM_E_EXISTS == rv) {
            /* Nothing to do but clear the error */
            rv = BCM_E_NONE;
        } else if (BCM_E_PARAM == rv) {
            /* Range is less than expected, stop iterating */
            rv = BCM_E_NONE;
            break;
        } else {
            /* Real error, return */
            break;
        }
    }

    if (BCM_SUCCESS(rv)) {
        if (0 == free_min) {
            /* No available groups of this type */
            return BCM_E_NOT_FOUND;
        } else {
            /* Copy the results */
            *gport_min = free_min;
            *gport_max = free_max;
        }
    }

    return rv;

#else
    return BCM_E_UNAVAIL;
#endif /* BCM_TRIUMPH_SUPPORT && INCLUDE_L3 */
}

#if defined(BCM_TRIUMPH2_SUPPORT)
int
_bcm_esw_port_flex_stat_index_set(int unit, bcm_gport_t port, int fs_idx,
                                  uint32 flags)
{
    bcm_port_t loc_port;
    int rv;

    rv = bcm_esw_port_local_get(unit, port, &loc_port);
    if (BCM_FAILURE(rv)) {
        return BCM_E_NOT_FOUND;  /* Local port disabled */
    }

    PORT_LOCK(unit); /* Keep port tables in sync */
    rv = BCM_E_NONE;
    if (flags & _BCM_FLEX_STAT_HW_INGRESS) {
        rv = soc_mem_field32_modify(unit, PORT_TABm, loc_port, VINTF_CTR_IDXf,
                                fs_idx);
    }

    if (flags & _BCM_FLEX_STAT_HW_EGRESS) {
        if (BCM_SUCCESS(rv)) {
#ifdef BCM_TRIDENT_SUPPORT
            if (SOC_IS_TD_TT(unit)) {
                rv = soc_mem_field32_modify(unit, EGR_PORTm, loc_port,
                                        VINTF_CTR_IDXf,  fs_idx);
            } else
#endif /* BCM_TRIDENT_SUPPORT */
            {
                rv = soc_reg_field32_modify(unit, EGR_PORT_64r, loc_port,
                                        VINTF_CTR_IDXf, fs_idx);
            }
        }
    }
    PORT_UNLOCK(unit);
    return rv;
}

STATIC int
_bcm_esw_port_stat_param_verify(int unit, bcm_gport_t port)
{
    int vp;

    if (BCM_GPORT_IS_MPLS_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT) && defined(INCLUDE_L3)
        vp = BCM_GPORT_MPLS_PORT_ID_GET(port);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMpls)) {
            return BCM_E_PARAM;
        }
#endif
    } else if (BCM_GPORT_IS_NIV_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT) && defined(INCLUDE_L3)
        vp = BCM_GPORT_NIV_PORT_ID_GET(port);
	    if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeNiv)) {
	        return BCM_E_PARAM;
	    }
#endif
    } else if (BCM_GPORT_IS_SUBPORT_GROUP(port) ||
               BCM_GPORT_IS_SUBPORT_PORT(port)) {

#if defined(BCM_HGPROXY_COE_SUPPORT)
        if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
            soc_feature(unit, soc_feature_channelized_switching)) &&
            _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {
            return bcm_esw_port_local_get(unit, port, &vp);
        }
#endif
#if defined(BCM_KATANA2_SUPPORT)
        if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit, port)){
            return bcm_esw_port_local_get(unit, port, &vp);
        }
#endif
#if defined(INCLUDE_L3)
        if (BCM_FAILURE(_bcm_tr2_subport_gport_used(unit, port))) {
            return BCM_E_PARAM;
        }
    } else if (BCM_GPORT_IS_MIM_PORT(port)) {
        vp = BCM_GPORT_MIM_PORT_ID_GET(port);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMim)) {
            return BCM_E_PARAM;
        }
    } else if (BCM_GPORT_IS_WLAN_PORT(port)) {
        vp = BCM_GPORT_WLAN_PORT_ID_GET(port);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeWlan)) {
            return BCM_E_PARAM;
        }
#endif
    } else {
        BCM_IF_ERROR_RETURN(
            bcm_esw_port_local_get(unit, port, &vp));
    }

    return BCM_E_NONE;
}
STATIC int
_bcm_esw_port_stat_param_valid(int unit, bcm_gport_t port)
{
    PORT_INIT(unit);

    if (!soc_feature(unit, soc_feature_gport_service_counters)) {
           return BCM_E_UNAVAIL;
    }
    return _bcm_esw_port_stat_param_verify(unit, port);
}

STATIC _bcm_flex_stat_t
_bcm_esw_port_stat_to_flex_stat(bcm_port_stat_t stat)
{
    _bcm_flex_stat_t flex_stat;

    switch (stat) {
    case bcmPortStatIngressPackets:
        flex_stat = _bcmFlexStatIngressPackets;
        break;
    case bcmPortStatIngressBytes:
        flex_stat = _bcmFlexStatIngressBytes;
        break;
    case bcmPortStatEgressPackets:
        flex_stat = _bcmFlexStatEgressPackets;
        break;
    case bcmPortStatEgressBytes:
        flex_stat = _bcmFlexStatEgressBytes;
        break;
    default:
        flex_stat = _bcmFlexStatNum;
    }

    return flex_stat;
}

/* Requires "idx" variable */
#define BCM_PORT_VALUE_ARRAY_VALID(unit, nstat, value_arr) \
    for (idx = 0; idx < nstat; idx++) { \
        if (NULL == value_arr + idx) { \
            return (BCM_E_PARAM); \
        } \
    }

STATIC int
_bcm_port_stat_array_convert(int unit, int nstat, bcm_port_stat_t *stat_arr,
                             _bcm_flex_stat_t *fs_arr)
{
    int idx;

    if ((nstat <= 0) || (nstat > _bcmFlexStatNum)) {
        return BCM_E_PARAM;
    }
    if ((NULL == stat_arr) || (NULL == fs_arr)) {
         return (BCM_E_PARAM);
    }

    for (idx = 0; idx < nstat; idx++) {
        fs_arr[idx] = _bcm_esw_port_stat_to_flex_stat(stat_arr[idx]);
    }
    return BCM_E_NONE;
}
#endif /* BCM_TRIUMPH2_SUPPORT */

/*
 * Function:
 *      bcm_esw_port_stat_enable_set
 * Purpose:
 *      Enable/disable packet and byte counters for the selected
 *      gport.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) GPORT ID
 *      enable - (IN) Non-zero to enable counter collection, zero to disable.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_stat_enable_set(int unit, bcm_gport_t port, int enable)
{
#if defined(BCM_TRIUMPH2_SUPPORT)
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  uint32                     num_of_tables=0;
  uint32                     num_stat_counter_ids=0;
  bcm_stat_flex_table_info_t table_info[BCM_STAT_FLEX_COUNTER_MAX_DIRECTION];
  bcm_stat_object_t          object=bcmStatObjectIngPort;
  uint32                     stat_counter_id[
                                     BCM_STAT_FLEX_COUNTER_MAX_DIRECTION]={0};
  uint32                     num_entries=0;
  int                        index=0;
  int                        rv;

#endif

  /* Make sure port module is initialized. */
  PORT_INIT(unit);

  if (!soc_feature(unit,soc_feature_advanced_flex_counter)) {
    BCM_IF_ERROR_RETURN
        (_bcm_esw_port_stat_param_valid(unit, port));
    return _bcm_esw_flex_stat_enable_set(unit, _bcmFlexStatTypeGport,
                             _bcm_esw_port_flex_stat_hw_index_set,
                                         NULL, port, enable,0);
  }
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  BCM_IF_ERROR_RETURN(_bcm_esw_port_stat_get_table_info(
                        unit,port,&num_of_tables,&table_info[0]));
    if (enable) {
        rv = _bcm_esw_stat_flex_get_counter_id(unit, num_of_tables,
                 &table_info[0], &num_stat_counter_ids, &stat_counter_id[0]);
        if (BCM_SUCCESS(rv)) {
            return BCM_E_EXISTS;
        } else if (rv != BCM_E_NOT_FOUND) {
            return rv;
        }

       for(index=0;index < num_of_tables ;index++) {
	   if(table_info[index].direction == bcmStatFlexDirectionIngress) {
              BCM_IF_ERROR_RETURN(_bcm_esw_stat_flex_get_ingress_object(
                                  unit,table_info[index].table,
                                  table_info[index].index,NULL,&object));
           } else {
              BCM_IF_ERROR_RETURN(_bcm_esw_stat_flex_get_egress_object(
                                  unit,table_info[index].table,
                                  table_info[index].index,NULL,&object));
           }
           BCM_IF_ERROR_RETURN(bcm_esw_stat_group_create(
                               unit,object,bcmStatGroupModeSingle,
                               &stat_counter_id[table_info[index].direction],
                               &num_entries));
           BCM_IF_ERROR_RETURN(bcm_esw_port_stat_attach(
                               unit,port,
                               stat_counter_id[table_info[index].direction]));
       }
       return BCM_E_NONE;
  } else {
      BCM_IF_ERROR_RETURN(_bcm_esw_stat_flex_get_counter_id(
                           unit, num_of_tables,&table_info[0],
                           &num_stat_counter_ids,&stat_counter_id[0]));
      if ((stat_counter_id[bcmStatFlexDirectionIngress] == 0) &&
          (stat_counter_id[bcmStatFlexDirectionEgress] == 0)) {
          return BCM_E_PARAM;
      }
      BCM_IF_ERROR_RETURN(bcm_esw_port_stat_detach(unit,port));
      if (stat_counter_id[bcmStatFlexDirectionIngress] != 0) {
          BCM_IF_ERROR_RETURN(bcm_esw_stat_group_destroy(
                                unit,
                                stat_counter_id[bcmStatFlexDirectionIngress]));
      }
      if (stat_counter_id[bcmStatFlexDirectionEgress] != 0) {
          BCM_IF_ERROR_RETURN(bcm_esw_stat_group_destroy(
                                unit,
                                stat_counter_id[bcmStatFlexDirectionEgress]));
      }
      return BCM_E_NONE;
    }
#else
    return BCM_E_UNAVAIL;
#endif
#else
    return BCM_E_UNAVAIL;
#endif
}

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
/*
 * Function:
 *      _bcm_esw_port_stat_get_table_info
 * Description:
 *      Provides relevant flex table information(table-name,index with
 *      direction)  for given gport.
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      port             - (IN) GPORT ID
 *      num_of_tables    - (OUT) Number of flex counter tables
 *      table_info       - (OUT) Flex counter tables information
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
STATIC
bcm_error_t _bcm_esw_port_stat_get_table_info(
                   int                        unit,
                   bcm_gport_t                port,
                   uint32                     *num_of_tables,
                   bcm_stat_flex_table_info_t *table_info)
{
#if defined(INCLUDE_L3)
	int         vp=0;
	int         rv=0;
	int         nh_index=0;
        int         vp_base=0;
        int         vt_index =-1;
	bcm_vlan_t  ovid = 0;
	uint32      port_class = 0;
	bcm_port_t  egress_port = 0;
	ing_l3_next_hop_entry_t ing_nh={{0}};
	egr_vlan_xlate_entry_t 	egr_vent={{0}};
	ing_dvp_table_entry_t   dvp={{0}};
	egr_l3_next_hop_entry_t egr_nh={{0}};
    source_vp_entry_t       svp;
    int                     l3_idx=0;
    egr_l3_intf_entry_t     l3_intf;

#endif
	bcm_port_t  loc_port=0;

        (*num_of_tables) = 0;

	if (!soc_feature(unit,soc_feature_advanced_flex_counter)) {
		return BCM_E_UNAVAIL;
	}
    BCM_IF_ERROR_RETURN(_bcm_esw_port_stat_param_verify(unit, port));
	if (BCM_GPORT_IS_MPLS_PORT(port) ||
	    BCM_GPORT_IS_NIV_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT) && defined(INCLUDE_L3)
	if (BCM_GPORT_IS_MPLS_PORT(port)) {
		vp = BCM_GPORT_MPLS_PORT_ID_GET(port);
		if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMpls)) {
			return BCM_E_NOT_FOUND;
		}
    }
    if (BCM_GPORT_IS_NIV_PORT(port)) {
        vp = BCM_GPORT_NIV_PORT_ID_GET(port);
		if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeNiv)) {
		    return BCM_E_NOT_FOUND;
		}
	}

    /* Ingress Side */
    table_info[*num_of_tables].table=SOURCE_VPm;
    table_info[*num_of_tables].index=vp;
    table_info[*num_of_tables].direction=bcmStatFlexDirectionIngress;
    (*num_of_tables)++;
	/* Egress Side */
	if (BCM_SUCCESS(READ_ING_DVP_TABLEm(unit, MEM_BLOCK_ANY, vp, &dvp))) {
	    nh_index = soc_mem_field32_get(unit, ING_DVP_TABLEm, &dvp,
                                           NEXT_HOP_INDEXf);
			if (BCM_SUCCESS(soc_mem_read(unit, EGR_L3_NEXT_HOPm, MEM_BLOCK_ANY,
                                         nh_index,&egr_nh))) {
                table_info[*num_of_tables].table= EGR_L3_NEXT_HOPm;
                                    table_info[*num_of_tables].index=nh_index;
            table_info[*num_of_tables].direction = bcmStatFlexDirectionEgress;
            (*num_of_tables)++;
				}
			}
                return BCM_E_NONE;
#endif/* BCM_MPLS_SUPPORT  && INCLUDE_L3*/
	} else if (BCM_GPORT_IS_SUBPORT_GROUP(port) ||
               BCM_GPORT_IS_SUBPORT_PORT(port)) {


#if defined(BCM_HGPROXY_COE_SUPPORT)
        if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
             soc_feature(unit, soc_feature_channelized_switching)) &&
            _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, port)) {

#if defined(BCM_CHANNELIZED_SWITCHING_SUPPORT)
            if (soc_feature(unit, soc_feature_channelized_switching)) {
                int subport_num=0;
                BCM_IF_ERROR_RETURN(
                    _bcm_coe_subtag_subport_port_subport_num_get(unit,
                        port, NULL, &subport_num));

                table_info[*num_of_tables].table = LPORT_TABm;
                table_info[*num_of_tables].index = subport_num;
                table_info[*num_of_tables].direction = bcmStatFlexDirectionIngress;
                (*num_of_tables)++;
                table_info[*num_of_tables].table = EGR_LPORT_PROFILEm;
                table_info[*num_of_tables].index = subport_num;
                table_info[*num_of_tables].direction = bcmStatFlexDirectionEgress;
                (*num_of_tables)++;
                return BCM_E_NONE;
            }
#endif

            if(BCM_FAILURE(bcm_esw_port_local_get(unit, port, &loc_port))) {
                return BCM_E_NOT_FOUND;  /* Local port disabled */
            }
            table_info[*num_of_tables].table = PORT_TABm;
            table_info[*num_of_tables].index =loc_port;
            table_info[*num_of_tables].direction = bcmStatFlexDirectionIngress;
            (*num_of_tables)++;
            table_info[*num_of_tables].table = EGR_PORTm;
            table_info[*num_of_tables].index = loc_port;
            table_info[*num_of_tables].direction = bcmStatFlexDirectionEgress;
            (*num_of_tables)++;
            return BCM_E_NONE;
        }
#endif
#if defined(BCM_KATANA2_SUPPORT)
        if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit, port)){
            if(BCM_FAILURE(bcm_esw_port_local_get(unit, port, &loc_port))) {
                return BCM_E_NOT_FOUND;  /* Local port disabled */
            }
            table_info[*num_of_tables].table = PORT_TABm;
            table_info[*num_of_tables].index =loc_port;
            table_info[*num_of_tables].direction = bcmStatFlexDirectionIngress;
            (*num_of_tables)++;
            table_info[*num_of_tables].table = EGR_PORTm;
            table_info[*num_of_tables].index = loc_port;
            table_info[*num_of_tables].direction = bcmStatFlexDirectionEgress;
            (*num_of_tables)++;
            return BCM_E_NONE;
        }
#endif /* BCM_KATANA2_SUPPORT */
#if defined(INCLUDE_L3)
		if (BCM_GPORT_IS_SUBPORT_PORT(port)) {
                   l3_idx = BCM_GPORT_SUBPORT_PORT_GET(port) & 0xfff;
                   BCM_IF_ERROR_RETURN(soc_mem_read(
                                       unit, EGR_L3_INTFm, MEM_BLOCK_ALL,
                                       l3_idx, &l3_intf));
                   vp = soc_mem_field32_get(unit,EGR_L3_INTFm, &l3_intf, IVIDf);
                   BCM_IF_ERROR_RETURN(READ_SOURCE_VPm(
                                       unit,MEM_BLOCK_ALL,vp,&svp));
                   vp_base = soc_SOURCE_VPm_field32_get(unit, &svp, DVPf);
                   /* vp = BCM_GPORT_SUBPORT_PORT_GET(port); */
			/* Get the base group VP */
                   /* vp_base = vp & ~(0x7); */
			/* Get the group's next-hop index */
                   BCM_IF_ERROR_RETURN(READ_ING_DVP_TABLEm(
                                       unit, MEM_BLOCK_ALL, vp_base, &dvp));
                   nh_index = soc_ING_DVP_TABLEm_field32_get(
                                       unit, &dvp, NEXT_HOP_INDEXf);
                   /*Get the group's OVID from the group's egress NextHopEntry*/
                   BCM_IF_ERROR_RETURN(soc_mem_read(
                                       unit, EGR_L3_NEXT_HOPm,
                                             MEM_BLOCK_ALL, nh_index, &egr_nh));
                   ovid = soc_mem_field32_get(
                                  unit, EGR_L3_NEXT_HOPm, &egr_nh, OVIDf);
			/* Get the egress port class */
                   BCM_IF_ERROR_RETURN (soc_mem_read(
                                        unit, ING_L3_NEXT_HOPm,
                                              MEM_BLOCK_ANY,nh_index, &ing_nh));
			if (!soc_ING_L3_NEXT_HOPm_field32_get(unit, &ing_nh, Tf)) {
			egress_port = soc_ING_L3_NEXT_HOPm_field32_get(
                                          unit, &ing_nh, PORT_NUMf);
				BCM_IF_ERROR_RETURN(bcm_esw_port_class_get(
                                    unit, egress_port,
                                    bcmPortClassVlanTranslateEgress,
                                    &port_class));
			}
			sal_memset(&egr_vent, 0, sizeof(egr_vent));
			soc_EGR_VLAN_XLATEm_field32_set(unit, &egr_vent, VALIDf, 1);
                   soc_EGR_VLAN_XLATEm_field32_set(unit, &egr_vent, OVIDf,ovid);
			if (soc_feature(unit, soc_feature_subport_enhanced)) {
                       soc_EGR_VLAN_XLATEm_field32_set(unit,&egr_vent,IVIDf,vp);
    			}
                   soc_EGR_VLAN_XLATEm_field32_set(
                                       unit,&egr_vent,ENTRY_TYPEf, 0x01);
		   soc_EGR_VLAN_XLATEm_field32_set(
                                      unit,&egr_vent,PORT_GROUP_IDf,port_class);
			MEM_LOCK(unit, EGR_VLAN_XLATEm);
		   rv = soc_mem_search(unit,EGR_VLAN_XLATEm,MEM_BLOCK_ALL,
                                       &vt_index, &egr_vent, &egr_vent, 0);
			if (rv < 0) {
				MEM_UNLOCK(unit, EGR_VLAN_XLATEm);
				return rv;
			}
			rv = soc_mem_write(unit, EGR_VLAN_XLATEm,
                                           MEM_BLOCK_ALL, vt_index,&egr_vent);
			if (BCM_FAILURE(rv)) {
                            MEM_UNLOCK(unit, EGR_VLAN_XLATEm);
                            return rv;
			}
                        table_info[*num_of_tables].table= EGR_VLAN_XLATEm;
                        table_info[*num_of_tables].index=vt_index;
                        table_info[*num_of_tables].direction=
                                                  bcmStatFlexDirectionEgress;
                        (*num_of_tables)++;
                        MEM_UNLOCK(unit, EGR_VLAN_XLATEm);
                        return BCM_E_NONE;
		} else { /*BCM_GPORT_IS_SUBPORT_GROUP(port) */
#if defined(BCM_TRIUMPH2_SUPPORT)
			vp_base = BCM_GPORT_SUBPORT_GROUP_GET(port);
			BCM_IF_ERROR_RETURN(_bcm_tr2_subport_gport_used(unit,port));
                        table_info[*num_of_tables].table= SOURCE_VPm;
                        table_info[*num_of_tables].index=vp_base;
                        table_info[*num_of_tables].direction=
                                                  bcmStatFlexDirectionIngress;
                        (*num_of_tables)++;
                        return BCM_E_NONE;
#endif
		}
	} else if (BCM_GPORT_IS_MIM_PORT(port)) {
		vp = BCM_GPORT_MIM_PORT_ID_GET(port);
		/*MIM_LOCK(unit); */
		if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMim)) {
        		/*MIM_UNLOCK(unit); */
        		return BCM_E_NOT_FOUND;
    		}
		/* Ingress side */
                table_info[*num_of_tables].table= SOURCE_VPm;
                table_info[*num_of_tables].index=vp;
                table_info[*num_of_tables].direction=
                                           bcmStatFlexDirectionIngress;
                (*num_of_tables)++;
		/* Egress side */
               if (BCM_SUCCESS(READ_ING_DVP_TABLEm(
                                    unit, MEM_BLOCK_ANY, vp, &dvp))) {
			nh_index = soc_mem_field32_get(unit, ING_DVP_TABLEm, &dvp,
                                           NEXT_HOP_INDEXf);
                   if (BCM_SUCCESS(soc_mem_read(
                                       unit, EGR_L3_NEXT_HOPm, MEM_BLOCK_ANY,
                                         nh_index,&egr_nh))) {
                            table_info[*num_of_tables].table= EGR_L3_NEXT_HOPm;
                            table_info[*num_of_tables].index=nh_index;
                            table_info[*num_of_tables].direction=
                                                   bcmStatFlexDirectionEgress;
                            (*num_of_tables)++;
			}
		}
                return BCM_E_NONE;
	} else if (BCM_GPORT_IS_WLAN_PORT(port)) {
		vp = BCM_GPORT_WLAN_PORT_ID_GET(port);
		/*WLAN_LOCK(unit); */
		if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeWlan)) {
        		/*WLAN_UNLOCK(unit); */
        		return BCM_E_NOT_FOUND;
    		}
		/*Ingress Side */
                table_info[*num_of_tables].table= SOURCE_VPm;
                table_info[*num_of_tables].index=vp;
               table_info[*num_of_tables].direction=bcmStatFlexDirectionIngress;
                (*num_of_tables)++;
               BCM_IF_ERROR_RETURN(READ_ING_DVP_TABLEm(
                                        unit, MEM_BLOCK_ANY, vp, &dvp));
               nh_index = soc_ING_DVP_TABLEm_field32_get(
                                  unit, &dvp, NEXT_HOP_INDEXf);
                table_info[*num_of_tables].table= EGR_L3_NEXT_HOPm;
                table_info[*num_of_tables].index=nh_index;
                table_info[*num_of_tables].direction=bcmStatFlexDirectionEgress;
                (*num_of_tables)++;
                return BCM_E_NONE;
	} else if (BCM_GPORT_IS_VLAN_PORT(port)) {
                vp = BCM_GPORT_VLAN_PORT_ID_GET(port);

                if (!(_bcm_vp_used_get(unit, vp, _bcmVpTypeVlan))) {
                       return BCM_E_NOT_FOUND;
                }

                /*Ingress Side */
                table_info[*num_of_tables].table= SOURCE_VPm;
                table_info[*num_of_tables].index=vp;
                table_info[*num_of_tables].direction=bcmStatFlexDirectionIngress;
                (*num_of_tables)++;
                BCM_IF_ERROR_RETURN(READ_ING_DVP_TABLEm(
                                        unit, MEM_BLOCK_ANY, vp, &dvp));
                nh_index = soc_ING_DVP_TABLEm_field32_get(
                                  unit, &dvp, NEXT_HOP_INDEXf);
                table_info[*num_of_tables].table= EGR_L3_NEXT_HOPm;
                table_info[*num_of_tables].index=nh_index;
                table_info[*num_of_tables].direction=bcmStatFlexDirectionEgress;
                (*num_of_tables)++;
                return BCM_E_NONE;
#endif
        }
#if defined(BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
    else if (BCM_GPORT_IS_TRUNK(port)) {
        if (!soc_feature(unit, soc_feature_vp_lag)) {
            return BCM_E_UNAVAIL;
        }
        BCM_IF_ERROR_RETURN(
            _bcm_esw_trunk_tid_to_vp_lag_vp(unit, BCM_GPORT_TRUNK_GET(port),
                                            &vp));
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeVpLag)) {
            return BCM_E_NOT_FOUND;
        }
        /* Ingress Side */
        table_info[*num_of_tables].table = SOURCE_VPm;
        table_info[*num_of_tables].index = vp;
        table_info[*num_of_tables].direction = bcmStatFlexDirectionIngress;
        (*num_of_tables)++;
        return BCM_E_NONE;
    }
#endif /* BCM_TRIDENT2_SUPPORT && INCLUDE_L3*/
    else {
		if(BCM_FAILURE(bcm_esw_port_local_get(unit, port, &loc_port))) {
			return BCM_E_NOT_FOUND;  /* Local port disabled */
		}
		/*PORT_LOCK(unit); */
#if defined(BCM_TRIDENT3_SUPPORT)
                if (SOC_IS_TRIDENT3X(unit)) {
                    table_info[*num_of_tables].table = LPORT_TABm;
                    table_info[*num_of_tables].index = loc_port;
                    table_info[*num_of_tables].direction = bcmStatFlexDirectionIngress;
                    (*num_of_tables)++;
                    if (soc_mem_field_valid(unit, EGR_PORTm, EGR_LPORT_PROFILE_IDXf) &&
                        soc_mem_is_valid(unit, EGR_LPORT_PROFILEm)) {
                        table_info[*num_of_tables].table = EGR_LPORT_PROFILEm;
                        table_info[*num_of_tables].index = loc_port;
                        table_info[*num_of_tables].direction = bcmStatFlexDirectionEgress;
                        (*num_of_tables)++;
                    } else {
                        return BCM_E_NOT_FOUND;
                    }
                } else
#endif
                {
                    table_info[*num_of_tables].table= PORT_TABm;
                    table_info[*num_of_tables].index=loc_port;
                    table_info[*num_of_tables].direction= bcmStatFlexDirectionIngress;
                    (*num_of_tables)++;
                    table_info[*num_of_tables].table= EGR_PORTm;
                    table_info[*num_of_tables].index=loc_port;
                    table_info[*num_of_tables].direction=bcmStatFlexDirectionEgress;
                    (*num_of_tables)++;
                }
                return BCM_E_NONE;
	}
	return BCM_E_NOT_FOUND;
}
#endif
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
/*
 * Function:
 *      _bcm_esw_port_stat_attach
 * Description:
 *      Attach counter entries to the given GPORT
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      port             - (IN) GPORT ID
 *      stat_counter_id  - (IN) Stat Counter ID.
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int _bcm_esw_port_stat_attach(
            int	        unit,
            bcm_gport_t	port,
            uint32      stat_counter_id)
{
    soc_mem_t                 table=0;
    bcm_stat_flex_direction_t direction=bcmStatFlexDirectionIngress;
    uint32                    pool_number=0;
    uint32                    base_index=0;
    bcm_stat_flex_mode_t      offset_mode=0;
    bcm_stat_object_t         object=bcmStatObjectIngPort;
    bcm_stat_group_mode_t     group_mode= bcmStatGroupModeSingle;
    uint32                    count=0;
    uint32                     actual_num_tables=0;
    uint32                     num_of_tables=0;
    bcm_stat_flex_table_info_t table_info[BCM_STAT_FLEX_COUNTER_MAX_DIRECTION];
    uint8                     skip_table_check = 0;

    _bcm_esw_stat_get_counter_id_info(
                  unit, stat_counter_id,
                  &group_mode,&object,&offset_mode,&pool_number,&base_index);
    BCM_IF_ERROR_RETURN(_bcm_esw_stat_validate_object(unit,object,&direction));
    BCM_IF_ERROR_RETURN(_bcm_esw_stat_validate_group(unit,group_mode));
    BCM_IF_ERROR_RETURN(_bcm_esw_stat_flex_get_table_info(
                        unit,object,1,&actual_num_tables,&table,&direction));

    BCM_IF_ERROR_RETURN(_bcm_esw_port_stat_get_table_info(
                   unit, port,&num_of_tables,&table_info[0]));
    skip_table_check = soc_property_get(unit, spn_FLEX_STAT_SHARE_ENABLE, 0);
    for (count=0; count < num_of_tables ; count++) {
      if ( (table_info[count].direction == direction) &&
           ((table_info[count].table == table) || (skip_table_check)) ) {
           if(direction == bcmStatFlexDirectionIngress) {
              return _bcm_esw_stat_flex_attach_ingress_table_counters(
                     unit,
                     table_info[count].table,
                     table_info[count].index,
                     offset_mode,
                     base_index,
                     pool_number);
           } else {
              return _bcm_esw_stat_flex_attach_egress_table_counters(
                     unit,
                     table_info[count].table,
                     table_info[count].index,
                     0,
                     offset_mode,
                     base_index,
                     pool_number);
           }
      }
    }
    return BCM_E_NOT_FOUND;
}
#endif

/*
 * Function:
 *      bcm_esw_port_stat_attach
 * Description:
 *      Attach counter entries to the given GPORT
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      port             - (IN) GPORT ID
 *      stat_counter_id  - (IN) Stat Counter ID.
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_port_stat_attach(
            int         unit,
            bcm_gport_t port,
            uint32      stat_counter_id)
{
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    if (soc_feature(unit,soc_feature_advanced_flex_counter)) {
        return _bcm_esw_port_stat_attach(unit,port,stat_counter_id);
    } else
#endif
#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIDENT_SUPPORT)
    if (soc_feature(unit,soc_feature_gport_service_counters)) {
        _bcm_flex_stat_type_t fs_type;
        uint32 fs_inx;
        uint32 flag;
        int rv;

        fs_type = _BCM_FLEX_STAT_TYPE(stat_counter_id);
        fs_inx  = _BCM_FLEX_STAT_COUNT_INX(stat_counter_id);

        if (!((fs_type == _bcmFlexStatTypeGport ||
            fs_type == _bcmFlexStatTypeEgressGport) && fs_inx)) {
            return BCM_E_PARAM;
        }
        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_stat_param_valid(unit, port));

        flag = fs_type==_bcmFlexStatTypeGport? _BCM_FLEX_STAT_HW_INGRESS:
                         _BCM_FLEX_STAT_HW_EGRESS;

        rv = _bcm_esw_flex_stat_enable_set(unit, fs_type,
                             _bcm_esw_port_flex_stat_hw_index_set,
                                      INT_TO_PTR(flag),
                                      port, TRUE,fs_inx);
        return rv;
    } else
#endif
    {
        return BCM_E_UNAVAIL;
    }
}

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
/*
 * Function:
 *      _bcm_esw_port_stat_detach
 * Description:
 *      Detach counter entries to the given GPORT
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      port             - (IN) GPORT ID
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int _bcm_esw_port_stat_detach(
            int	        unit,
            bcm_gport_t	port)
{
    uint32                     count=0;
    uint32                     num_of_tables=0;
    bcm_stat_flex_table_info_t table_info[BCM_STAT_FLEX_COUNTER_MAX_DIRECTION];
    bcm_error_t                rv = BCM_E_NONE;
    bcm_error_t                err_code[BCM_STAT_FLEX_COUNTER_MAX_DIRECTION] = {BCM_E_NONE};

    BCM_IF_ERROR_RETURN(_bcm_esw_port_stat_get_table_info(
                   unit, port,&num_of_tables,&table_info[0]));

    for (count=0; count < num_of_tables ; count++) {
      if (table_info[count].direction == bcmStatFlexDirectionIngress) {
           rv = _bcm_esw_stat_flex_detach_ingress_table_counters(
                         unit,
                         table_info[count].table,
                         table_info[count].index);
           if (BCM_E_NONE != rv &&
                BCM_E_NONE == err_code[bcmStatFlexDirectionIngress]) {
                err_code[bcmStatFlexDirectionIngress] = rv;
           }
      } else {
           rv = _bcm_esw_stat_flex_detach_egress_table_counters(
                          unit,
                          0,
                          table_info[count].table,
                          table_info[count].index);
           if (BCM_E_NONE != rv &&
                BCM_E_NONE == err_code[bcmStatFlexDirectionEgress]) {
                err_code[bcmStatFlexDirectionEgress] = rv;
           }
      }
    }

    BCM_STAT_FLEX_DETACH_RETURN(err_code)
}

/*
 * Function:
 *      _bcm_esw_port_stat_detach_with_id
 * Description:
 *      Detach counter entries to the given GPORT with a given stat counter id
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      port             - (IN) GPORT ID
 *      stat_counter_id  - (IN) Stat Counter ID
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
bcm_error_t _bcm_esw_port_stat_detach_with_id(
            int	        unit,
            bcm_gport_t	port,
            uint32 stat_counter_id)
{
    uint32                     count=0;
    uint32                     num_of_tables=0;
    bcm_stat_flex_table_info_t table_info[BCM_STAT_FLEX_COUNTER_MAX_DIRECTION];
    bcm_error_t                rv = BCM_E_NONE;
    bcm_error_t                err_code[BCM_STAT_FLEX_COUNTER_MAX_DIRECTION] = {BCM_E_NONE};
    bcm_stat_flex_direction_t direction=bcmStatFlexDirectionIngress;
    uint32                    pool_number=0;
    uint32                    base_index=0;
    bcm_stat_flex_mode_t      offset_mode=0;
    bcm_stat_object_t         object=bcmStatObjectIngPort;
    bcm_stat_group_mode_t     group_mode= bcmStatGroupModeSingle;
    uint32                     actual_num_tables=0;
    soc_mem_t                 table=0;

    _bcm_esw_stat_get_counter_id_info(unit, stat_counter_id, &group_mode, &object,
                                      &offset_mode, &pool_number, &base_index);
    BCM_IF_ERROR_RETURN
        (_bcm_esw_stat_validate_object(unit, object, &direction));
    BCM_IF_ERROR_RETURN(_bcm_esw_stat_validate_group(unit, group_mode));
    BCM_IF_ERROR_RETURN
        (_bcm_esw_stat_flex_get_table_info(unit, object, 1, &actual_num_tables,
                                           &table, &direction));

    BCM_IF_ERROR_RETURN(_bcm_esw_port_stat_get_table_info(
                   unit, port,&num_of_tables,&table_info[0]));

    for (count=0; count < num_of_tables ; count++) {
        if((table_info[count].direction == direction) &&
             (table_info[count].table == table)) {
           if(direction == bcmStatFlexDirectionIngress) {
               rv = _bcm_esw_stat_flex_detach_ingress_table_counters(
                             unit,
                             table_info[count].table,
                             table_info[count].index);
               if (BCM_E_NONE != rv &&
                    BCM_E_NONE == err_code[bcmStatFlexDirectionIngress]) {
                    err_code[bcmStatFlexDirectionIngress] = rv;
               }
            } else {
               rv = _bcm_esw_stat_flex_detach_egress_table_counters(
                              unit,
                              0,
                              table_info[count].table,
                              table_info[count].index);
               if (BCM_E_NONE != rv &&
                    BCM_E_NONE == err_code[bcmStatFlexDirectionEgress]) {
                    err_code[bcmStatFlexDirectionEgress] = rv;
               }
            }
        }
    }

    BCM_STAT_FLEX_DETACH_RETURN(err_code)
}
#endif

/*
 * Function:
 *      bcm_esw_port_stat_detach
 * Description:
 *      Detach counter entries to the given GPORT
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      port             - (IN) GPORT ID
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_port_stat_detach(
            int         unit,
            bcm_gport_t port)
{
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    if (soc_feature(unit,soc_feature_advanced_flex_counter)) {
        return _bcm_esw_port_stat_detach(unit,port);
    } else
#endif
#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIDENT_SUPPORT)
    if (soc_feature(unit,soc_feature_gport_service_counters)) {
        uint32 flag;
        int rv;
        int rv1;

        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_stat_param_valid(unit, port));

        /* no count_id, detach all counters associated with this port.*/
        flag= _BCM_FLEX_STAT_HW_INGRESS;
        rv = _bcm_esw_flex_stat_enable_set(unit, _bcmFlexStatTypeGport,
                             _bcm_esw_port_flex_stat_hw_index_set,
                                      INT_TO_PTR(flag),
                                      port, FALSE,1);
        flag= _BCM_FLEX_STAT_HW_EGRESS;
        rv1 = _bcm_esw_flex_stat_enable_set(unit,
                         _bcmFlexStatTypeEgressGport,
                         _bcm_esw_port_flex_stat_hw_index_set,
                                  INT_TO_PTR(flag),
                                  port, FALSE,1);
        if (BCM_SUCCESS(rv) && BCM_SUCCESS(rv1)) {
            return BCM_E_NONE;
        } else {
            return BCM_E_NOT_FOUND;
        }
    } else
#endif
    {
        return BCM_E_UNAVAIL;
    }
}

/*
 * Function:
 *      bcm_esw_port_stat_detach_with_id
 * Description:
 *      Detach counter entries to the given GPORT with a given stat counter id
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      port             - (IN) GPORT ID
 *      stat_counter_id  - (IN) Stat Counter ID
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
bcm_error_t bcm_esw_port_stat_detach_with_id(
            int         unit,
            bcm_gport_t port,
            uint32 stat_counter_id)
{
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    if (soc_feature(unit,soc_feature_advanced_flex_counter)) {
        return _bcm_esw_port_stat_detach_with_id(unit, port, stat_counter_id);
    } else
#endif
    {
        return BCM_E_UNAVAIL;
    }
}


#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
/*
 * Function:
 *      _bcm_esw_port_stat_counter_get
 * Description:
 *      retrieve set of counter statistic values for the given GPORT
 *      if sync_mode is set, sync the sw accumulated count
 *      with hw count value first, else return sw count.
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      port             - (IN) GPORT ID
 *      stat             - (IN) Type of the counter to retrieve
 *                              I.e. ingress/egress byte/packet)
 *      num_entries      - (IN) Number of counter Entries
 *      counter_indexes  - (IN) Pointer to Counter indexes entries
 *      counter_values   - (OUT) Pointer to counter values
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int _bcm_esw_port_stat_counter_get(
            int	             unit,
            int	             sync_mode,
            bcm_gport_t      port,
            bcm_port_stat_t  stat,
            uint32           num_entries,
            uint32           *counter_indexes,
            bcm_stat_value_t *counter_values)
{
    uint32                          table_count=0;
    uint32                          index_count=0;
    uint32                          num_of_tables=0;
    bcm_stat_flex_direction_t       direction=bcmStatFlexDirectionIngress;
    uint32                          byte_flag=0;
    bcm_stat_flex_table_info_t table_info[BCM_STAT_FLEX_COUNTER_MAX_DIRECTION];

    if ((stat == bcmPortStatIngressPackets) ||
        (stat == bcmPortStatIngressBytes)) {
         direction = bcmStatFlexDirectionIngress;
    } else {
         direction = bcmStatFlexDirectionEgress;
    }
    if ((stat == bcmPortStatIngressPackets) ||
        (stat == bcmPortStatEgressPackets)) {
        byte_flag=0;
    } else {
        byte_flag=1;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_stat_get_table_info(
                   unit, port,&num_of_tables,&table_info[0]));

    for (table_count=0; table_count < num_of_tables ; table_count++) {
      if (table_info[table_count].direction == direction) {
          for (index_count=0; index_count < num_entries ; index_count++) {
               /*ctr_offset_info.offset_index = counter_indexes[index_count];*/
            BCM_IF_ERROR_RETURN(_bcm_esw_stat_counter_get(
                         unit, sync_mode,
                         table_info[table_count].index,
                         table_info[table_count].table,
                         0,
                         byte_flag,
                         counter_indexes[index_count],
                         &counter_values[index_count]));
          }
      }
    }
    return BCM_E_NONE;
}
#endif

/*
 * Function:
 *      _bcm_esw_port_flex_stat_counter_get
 * Description:
 *      retrieve set of counter statistic values for the given GPORT
 *      if sync_mode is set, sync the sw accumulated count
 *      with hw count value first, else return sw count.
 * Parameters:
 *      unit             - (IN) unit number
 *      sync_mode        - (IN) hwcount is to be synced to sw count
 *      port             - (IN) GPORT ID
 *      stat             - (IN) Type of the counter to retrieve
 *                              I.e. ingress/egress byte/packet)
 *      num_entries      - (IN) Number of counter Entries
 *      counter_indexes  - (IN) Pointer to Counter indexes entries
 *      counter_values   - (OUT) Pointer to counter values
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int _bcm_esw_port_flex_stat_counter_get(int              unit,
                                        int              sync_mode,
                                        bcm_gport_t      port,
                                        bcm_port_stat_t  stat,
                                        uint32           num_entries,
                                        uint32           *counter_indexes,
                                        bcm_stat_value_t *counter_values)
{
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    if (soc_feature(unit,soc_feature_advanced_flex_counter)) {
        return _bcm_esw_port_stat_counter_get(unit, sync_mode, port, stat,
                                              num_entries, counter_indexes,
                                              counter_values);
    } else
#endif
#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIDENT_SUPPORT)
    if (soc_feature(unit,soc_feature_gport_service_counters)) {
        uint64 val;
        int rv = BCM_E_NONE;

        rv =  _bcm_esw_flex_stat_get(unit, sync_mode,
               ((stat == bcmPortStatIngressPackets) ||
                (stat == bcmPortStatIngressBytes)) ?
                 _bcmFlexStatTypeGport:_bcmFlexStatTypeEgressGport,
                port,
                _bcm_esw_port_stat_to_flex_stat(stat), &val);

        if ((stat == bcmPortStatIngressPackets) ||
            (stat == bcmPortStatEgressPackets)) {
            counter_values->packets = COMPILER_64_LO(val);
        } else {
            COMPILER_64_SET(counter_values->bytes,
                      COMPILER_64_HI(val),
                      COMPILER_64_LO(val));
        }
        return rv;

    } else
#endif
    {
        return BCM_E_UNAVAIL;
    }

}


/*
 * Function:
 *      bcm_esw_port_stat_counter_get
 * Description:
 *      retrieve set of counter statistic values for the given GPORT
 * Parameters:
 *      unit             - (IN) unit number
 *      port             - (IN) GPORT ID
 *      stat             - (IN) Type of the counter to retrieve
 *                              I.e. ingress/egress byte/packet)
 *      num_entries      - (IN) Number of counter Entries
 *      counter_indexes  - (IN) Pointer to Counter indexes entries
 *      counter_values   - (OUT) Pointer to counter values
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_port_stat_counter_get(int              unit,
                                  bcm_gport_t      port,
                                  bcm_port_stat_t  stat,
                                  uint32           num_entries,
                                  uint32           *counter_indexes,
                                  bcm_stat_value_t *counter_values)
{
    int rv = BCM_E_UNAVAIL;

    rv = _bcm_esw_port_flex_stat_counter_get(unit, 0, port, stat, num_entries,
                                             counter_indexes, counter_values);

    return rv;
}


/*
 * Function:
 *      bcm_esw_port_stat_counter_sync_get
 * Description:
 *      retrieve set of counter statistic values for the given GPORT
 *      sw accumulated counters synced with hw count.
 * Parameters:
 *      unit             - (IN) unit number
 *      port             - (IN) GPORT ID
 *      stat             - (IN) Type of the counter to retrieve
 *                              I.e. ingress/egress byte/packet)
 *      num_entries      - (IN) Number of counter Entries
 *      counter_indexes  - (IN) Pointer to Counter indexes entries
 *      counter_values   - (OUT) Pointer to counter values
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_port_stat_counter_sync_get(int              unit,
                                       bcm_gport_t      port,
                                       bcm_port_stat_t  stat,
                                       uint32           num_entries,
                                       uint32           *counter_indexes,
                                       bcm_stat_value_t *counter_values)
{
    int rv = BCM_E_UNAVAIL;

    rv = _bcm_esw_port_flex_stat_counter_get(unit, 1, port, stat, num_entries,
                                        counter_indexes, counter_values);

    return rv;
}
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
/*
 * Function:
 *      _bcm_esw_port_stat_counter_set
 * Description:
 *      set counter statistic values for the given GPORT
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      port             - (IN) GPORT ID
 *      stat             - (IN) Type of the counter to retrieve
 *                              I.e. ingress/egress byte/packet)
 *      num_entries      - (IN) Number of counter Entries
 *      counter_indexes  - (IN) Pointer to Counter indexes entries
 *      counter_values   - (IN) Pointer to counter values
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int _bcm_esw_port_stat_counter_set(
            int	             unit,
            bcm_gport_t      port,
            bcm_port_stat_t  stat,
            uint32           num_entries,
            uint32           *counter_indexes,
            bcm_stat_value_t *counter_values)
{
    uint32                          table_count=0;
    uint32                          index_count=0;
    uint32                          num_of_tables=0;
    bcm_stat_flex_direction_t       direction=bcmStatFlexDirectionIngress;
    uint32                          byte_flag=0;
    bcm_stat_flex_table_info_t table_info[BCM_STAT_FLEX_COUNTER_MAX_DIRECTION];

    if ((stat == bcmPortStatIngressPackets) ||
        (stat == bcmPortStatIngressBytes)) {
         direction = bcmStatFlexDirectionIngress;
    } else {
         direction = bcmStatFlexDirectionEgress;
    }
    if ((stat == bcmPortStatIngressPackets) ||
        (stat == bcmPortStatEgressPackets)) {
        byte_flag=0;
    } else {
        byte_flag=1;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_stat_get_table_info(
                   unit, port,&num_of_tables,&table_info[0]));

    for (table_count=0; table_count < num_of_tables ; table_count++) {
      if (table_info[table_count].direction == direction) {
          for (index_count=0; index_count < num_entries ; index_count++) {
            BCM_IF_ERROR_RETURN(_bcm_esw_stat_counter_set(
                                unit,
                                table_info[table_count].index,
                                table_info[table_count].table,
                                0,
                                byte_flag,
                                counter_indexes[index_count],
                                &counter_values[index_count]));
          }
      }
    }
    return BCM_E_NONE;
}
#endif
/*
 * Function:
 *      bcm_esw_port_stat_counter_set
 * Description:
 *      set counter statistic values for the given GPORT
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      port             - (IN) GPORT ID
 *      stat             - (IN) Type of the counter to retrieve
 *                              I.e. ingress/egress byte/packet)
 *      num_entries      - (IN) Number of counter Entries
 *      counter_indexes  - (IN) Pointer to Counter indexes entries
 *      counter_values   - (IN) Pointer to counter values
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_port_stat_counter_set(
            int              unit,
            bcm_gport_t      port,
            bcm_port_stat_t  stat,
            uint32           num_entries,
            uint32           *counter_indexes,
            bcm_stat_value_t *counter_values)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    if (soc_feature(unit,soc_feature_advanced_flex_counter)) {
        return _bcm_esw_port_stat_counter_set(unit,port,stat,
                      num_entries,counter_indexes,counter_values);
    } else
#endif
#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIDENT_SUPPORT)
    if (soc_feature(unit,soc_feature_gport_service_counters)) {
        uint64 val;
        int rv = BCM_E_NONE;

        if ((stat == bcmPortStatIngressPackets) ||
            (stat == bcmPortStatEgressPackets)) {
            COMPILER_64_SET(val,0,counter_values->packets);
        } else {
            COMPILER_64_SET(val,
                      COMPILER_64_HI(counter_values->bytes),
                      COMPILER_64_LO(counter_values->bytes));
        }
        rv =  _bcm_esw_flex_stat_set(unit,
               ((stat == bcmPortStatIngressPackets) ||
                (stat == bcmPortStatIngressBytes)) ?
                 _bcmFlexStatTypeGport:_bcmFlexStatTypeEgressGport,
                port,
                _bcm_esw_port_stat_to_flex_stat(stat), val);

        return rv;

    } else
#endif
    {
        return BCM_E_UNAVAIL;
    }
}
/*
 * Function:
 *      bcm_esw_port_stat_id_get
 * Description:
 *      Get stat counter id associated with given gport
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      port             - (IN) GPORT ID
 *      stat             - (IN) Type of the counter to retrieve
 *                              I.e. ingress/egress byte/packet)
 *      Stat_counter_id  - (OUT) Stat Counter ID
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_port_stat_id_get(
            int              unit,
            bcm_gport_t      port,
            bcm_port_stat_t  stat,
            uint32           *stat_counter_id)
{
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    bcm_stat_flex_direction_t  direction=bcmStatFlexDirectionIngress;
    uint32                     num_of_tables=0;
    bcm_stat_flex_table_info_t table_info[BCM_STAT_FLEX_COUNTER_MAX_DIRECTION];
    uint32                     index=0;
    uint32                     num_stat_counter_ids=0;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if ((stat == bcmPortStatIngressPackets) ||
        (stat == bcmPortStatIngressBytes)) {
         direction = bcmStatFlexDirectionIngress;
    } else {
         direction = bcmStatFlexDirectionEgress;
    }
    BCM_IF_ERROR_RETURN(_bcm_esw_port_stat_get_table_info(
                        unit,port,&num_of_tables,&table_info[0]));
    for (index=0; index < num_of_tables ; index++) {
         if (table_info[index].direction == direction)
             return _bcm_esw_stat_flex_get_counter_id(
                                  unit, 1, &table_info[index],
                                  &num_stat_counter_ids,stat_counter_id);
    }
    return BCM_E_NOT_FOUND;
#else
    return BCM_E_UNAVAIL;
#endif
}


/*
 * Function:
 *      _bcm_esw_port_stat_get
 * Purpose:
 *      Get 64-bit counter value for specified port statistic type.
 *      if sync_mode is set, sync the sw accumulated count
 *      with hw count value first, else return sw count.
 * Parameters:
 *      unit        - (IN) Unit number.
 *      sync_mode   - (IN) hwcount is to be synced to sw count
 *      port        - (IN) GPORT ID
 *      stat        - (IN) Type of the counter to retrieve.
 *      val         - (OUT) Pointer to a counter value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_esw_port_stat_get(int unit, int sync_mode, bcm_gport_t port,
                       bcm_port_stat_t stat, uint64 *val)
{
#if defined(BCM_TRIUMPH2_SUPPORT)
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  uint32           counter_indexes=0;
  bcm_stat_value_t counter_values={0};
#endif

  /* Make sure port module is initialized. */
  PORT_INIT(unit);

#if defined(BCM_PREEMPTION_SUPPORT)
  if (soc_feature(unit, soc_feature_preemption_cnt)) {
    bcm_port_t local_port;
    BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, port, &local_port));
    return bcmi_esw_preemption_counter_get(unit, sync_mode, local_port,
                                           stat, val);
  }
#endif /* BCM_PREEMPTION_SUPPORT */

  if (!soc_feature(unit,soc_feature_advanced_flex_counter)) {
    BCM_IF_ERROR_RETURN
        (_bcm_esw_port_stat_param_valid(unit, port));
    return _bcm_esw_flex_stat_get(unit, sync_mode, _bcmFlexStatTypeGport, port,
                                  _bcm_esw_port_stat_to_flex_stat(stat), val);
  }
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  BCM_IF_ERROR_RETURN(_bcm_esw_port_stat_counter_get(unit, sync_mode, port,
                                                     stat, 1, &counter_indexes,
                                                     &counter_values));
  if ((stat == bcmPortStatIngressPackets) ||
      (stat == bcmPortStatEgressPackets)) {
      COMPILER_64_SET(*val,
                      COMPILER_64_HI(counter_values.packets64),
                      COMPILER_64_LO(counter_values.packets64));
  } else {
      COMPILER_64_SET(*val,
                      COMPILER_64_HI(counter_values.bytes),
                      COMPILER_64_LO(counter_values.bytes));
  }
  return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
#else
    return BCM_E_UNAVAIL;
#endif
}


/*
 * Function:
 *      bcm_esw_port_stat_get
 * Purpose:
 *      Get 64-bit counter value for specified port statistic type.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) GPORT ID
 *      stat - (IN) Type of the counter to retrieve.
 *      val - (OUT) Pointer to a counter value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_stat_get(int unit, bcm_gport_t port, bcm_port_stat_t stat,
                      uint64 *val)
{
    int rv = BCM_E_UNAVAIL;

    rv = _bcm_esw_port_stat_get(unit, 0, port, stat, val);

    return rv;
}


/*
 * Function:
 *      bcm_esw_port_stat_sync_get
 * Purpose:
 *      Get 64-bit counter value for specified port statistic type.
 *      sw accumulated counters synced with hw count.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) GPORT ID
 *      stat - (IN) Type of the counter to retrieve.
 *      val - (OUT) Pointer to a counter value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_stat_sync_get(int unit, bcm_gport_t port, bcm_port_stat_t stat,
                      uint64 *val)
{
    int rv = BCM_E_UNAVAIL;

    rv = _bcm_esw_port_stat_get(unit, 1, port, stat, val);

    return rv;
}

/*
 * Function:
 *      _bcm_esw_port_stat_get32
 * Purpose:
 *      Get lower 32-bit counter value for specified port statistic
 *      type.
 *      if sync_mode is set, sync the sw accumulated count
 *      with hw count value first, else return sw count.
 * Parameters:
 *      unit        - (IN) Unit number.
 *      sync_mode   - (IN) hwcount is to be synced to sw count
 *      port        - (IN) GPORT ID
 *      stat        - (IN) Type of the counter to retrieve.
 *      val         - (OUT) Pointer to a counter value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
_bcm_esw_port_stat_get32(int unit, int sync_mode, bcm_gport_t port,
                         bcm_port_stat_t stat, uint32 *val)
{
#if defined(BCM_TRIUMPH2_SUPPORT)
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  uint32           counter_indexes=0;
  bcm_stat_value_t counter_values={0};
#endif

  /* Make sure port module is initialized. */
  PORT_INIT(unit);

#if defined(BCM_PREEMPTION_SUPPORT)
  if (soc_feature(unit, soc_feature_preemption_cnt)) {
    bcm_port_t local_port;
    BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, port, &local_port));
    return bcmi_esw_preemption_counter_get32(unit, sync_mode, local_port,
                                             stat, val);
  }
#endif /* BCM_PREEMPTION_SUPPORT */

  if (!soc_feature(unit,soc_feature_advanced_flex_counter)) {
    BCM_IF_ERROR_RETURN
        (_bcm_esw_port_stat_param_valid(unit, port));
    return _bcm_esw_flex_stat_get32(unit, sync_mode,
                                    _bcmFlexStatTypeGport, port,
                                    _bcm_esw_port_stat_to_flex_stat(stat), val);
  }
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  BCM_IF_ERROR_RETURN(_bcm_esw_port_stat_counter_get(unit, sync_mode,
                                                     port, stat, 1,
                                                     &counter_indexes,
                                                     &counter_values));
  if ((stat == bcmPortStatIngressPackets) ||
      (stat == bcmPortStatEgressPackets)) {
      *val = counter_values.packets;
  } else {
      /* Ignoring Hi bytes value */
      *val = COMPILER_64_LO(counter_values.bytes);
  }
  return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
#else
    return BCM_E_UNAVAIL;
#endif
}


/*
 * Function:
 *      bcm_esw_port_stat_get32
 * Purpose:
 *      Get lower 32-bit counter value for specified port statistic
 *      type.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) GPORT ID
 *      stat - (IN) Type of the counter to retrieve.
 *      val - (OUT) Pointer to a counter value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_stat_get32(int unit, bcm_gport_t port,
                        bcm_port_stat_t stat, uint32 *val)
{
    int rv = BCM_E_UNAVAIL;

    rv = _bcm_esw_port_stat_get32(unit, 0, port, stat, val);

    return rv;

}


/*
 * Function:
 *      bcm_esw_port_stat_sync_get32
 * Purpose:
 *      Get lower 32-bit counter value for specified port statistic
 *      type. sw accumulated counters synced with hw count.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) GPORT ID
 *      stat - (IN) Type of the counter to retrieve.
 *      val - (OUT) Pointer to a counter value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_stat_sync_get32(int unit, bcm_gport_t port,
                             bcm_port_stat_t stat, uint32 *val)
{
    int rv = BCM_E_UNAVAIL;

    rv = _bcm_esw_port_stat_get32(unit, 1, port, stat, val);

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_stat_set
 * Purpose:
 *      Set 64-bit counter value for specified port statistic type.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) GPORT ID
 *      stat - (IN) Type of the counter to retrieve.
 *      val - (IN) New counter value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_stat_set(int unit, bcm_gport_t port, bcm_port_stat_t stat,
                      uint64 val)
{
#if defined(BCM_TRIUMPH2_SUPPORT)
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  uint32           counter_indexes=0;
  bcm_stat_value_t counter_values={0};
#endif

  /* Make sure port module is initialized. */
  PORT_INIT(unit);

#if defined(BCM_PREEMPTION_SUPPORT)
  if (soc_feature(unit, soc_feature_preemption_cnt)) {
    bcm_port_t local_port;
    BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, port, &local_port));
    return bcmi_esw_preemption_counter_set(unit, local_port,
                                           stat, val);
  }
#endif /* BCM_PREEMPTION_SUPPORT */

  if (!soc_feature(unit,soc_feature_advanced_flex_counter)) {
    BCM_IF_ERROR_RETURN
        (_bcm_esw_port_stat_param_valid(unit, port));
    return _bcm_esw_flex_stat_set(unit, _bcmFlexStatTypeGport, port,
                           _bcm_esw_port_stat_to_flex_stat(stat), val);
  }
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  if ((stat == bcmPortStatIngressPackets) ||
      (stat == bcmPortStatEgressPackets)) {
      counter_values.packets = COMPILER_64_LO(val);
  } else {
      COMPILER_64_SET(counter_values.bytes,
                      COMPILER_64_HI(val),
                      COMPILER_64_LO(val));
  }
  BCM_IF_ERROR_RETURN(bcm_esw_port_stat_counter_set(
                        unit,port,stat, 1, &counter_indexes, &counter_values));
  return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
#else
    return BCM_E_UNAVAIL;
#endif
}

/*
 * Function:
 *      bcm_esw_port_stat_set32
 * Purpose:
 *      Set lower 32-bit counter value for specified port statistic
 *      type.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) GPORT ID
 *      stat - (IN) Type of the counter to retrieve.
 *      val - (IN) New counter value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_stat_set32(int unit, bcm_gport_t port,
                        bcm_port_stat_t stat, uint32 val)
{
#if defined(BCM_TRIUMPH2_SUPPORT)
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  uint32           counter_indexes=0;
  bcm_stat_value_t counter_values={0};
#endif

  /* Make sure port module is initialized. */
  PORT_INIT(unit);

#if defined(BCM_PREEMPTION_SUPPORT)
  if (soc_feature(unit, soc_feature_preemption_cnt)) {
    bcm_port_t local_port;
    BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, port, &local_port));
    return bcmi_esw_preemption_counter_set32(unit, local_port,
                                             stat, val);
  }
#endif /* BCM_PREEMPTION_SUPPORT */


  if (!soc_feature(unit,soc_feature_advanced_flex_counter)) {
    BCM_IF_ERROR_RETURN
        (_bcm_esw_port_stat_param_valid(unit, port));
    return _bcm_esw_flex_stat_set32(unit, _bcmFlexStatTypeGport, port,
                           _bcm_esw_port_stat_to_flex_stat(stat), val);
  }
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  if ((stat == bcmPortStatIngressPackets) ||
      (stat == bcmPortStatEgressPackets)) {
      counter_values.packets = val;
  } else {
      /* Ignoring high value */
      COMPILER_64_SET(counter_values.bytes,0,val);
  }
  BCM_IF_ERROR_RETURN(bcm_esw_port_stat_counter_set(
                        unit,port,stat, 1, &counter_indexes, &counter_values));
  return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
#else
    return BCM_E_UNAVAIL;
#endif
}

/*
 * Function:
 *      bcm_esw_port_stat_multi_get
 * Purpose:
 *      Get 64-bit counter value for multiple port statistic types.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) GPORT ID
 *      nstat - (IN) Number of elements in stat array
 *      stat_arr - (IN) Collected statistics descriptors array
 *      value_arr - (OUT) Collected counters values
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_stat_multi_get(int unit, bcm_gport_t port, int nstat,
                            bcm_port_stat_t *stat_arr,
                            uint64 *value_arr)
{
#if defined(BCM_TRIUMPH2_SUPPORT)
    _bcm_flex_stat_t fs_arr[_bcmFlexStatNum]; /* Normalize stats */
    int idx;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  uint32           counter_indexes=0;
  bcm_stat_value_t counter_values={0};
#endif

  /* Make sure port module is initialized. */
  PORT_INIT(unit);

#if defined(BCM_PREEMPTION_SUPPORT)
  if (soc_feature(unit, soc_feature_preemption_cnt)) {
    bcm_port_t local_port;
    BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, port, &local_port));
    return bcmi_esw_preemption_counter_multi_get(unit, 0, local_port, nstat,
                                                 stat_arr, value_arr);
  }
#endif /* BCM_PREEMPTION_SUPPORT */

  if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
    BCM_IF_ERROR_RETURN
        (_bcm_esw_port_stat_param_valid(unit, port));
    BCM_IF_ERROR_RETURN
        (_bcm_port_stat_array_convert(unit, nstat, stat_arr, fs_arr));
    BCM_PORT_VALUE_ARRAY_VALID(unit, nstat, value_arr);

    return _bcm_esw_flex_stat_multi_get(unit, _bcmFlexStatTypeGport, port,
                                        nstat, fs_arr, value_arr);
  }
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  for (idx=0;idx < nstat ; idx ++) {
      BCM_IF_ERROR_RETURN(bcm_esw_port_stat_counter_get(
                             unit, port, stat_arr[idx],
                             1, &counter_indexes, &counter_values));
      if ((stat_arr[idx] == bcmPortStatIngressPackets) ||
          (stat_arr[idx] == bcmPortStatEgressPackets)) {
          COMPILER_64_SET(value_arr[idx],
                          COMPILER_64_HI(counter_values.packets64),
                          COMPILER_64_LO(counter_values.packets64));
      } else {
          COMPILER_64_SET(value_arr[idx],
                          COMPILER_64_HI(counter_values.bytes),
                          COMPILER_64_LO(counter_values.bytes));
      }
  }
  return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
#else
    return BCM_E_UNAVAIL;
#endif
}

/*
 * Function:
 *      bcm_esw_port_stat_multi_get32
 * Purpose:
 *      Get lower 32-bit counter value for multiple port statistic
 *      types.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) GPORT ID
 *      nstat - (IN) Number of elements in stat array
 *      stat_arr - (IN) Collected statistics descriptors array
 *      value_arr - (OUT) Collected counters values
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_stat_multi_get32(int unit, bcm_gport_t port, int nstat,
                              bcm_port_stat_t *stat_arr,
                              uint32 *value_arr)
{
#if defined(BCM_TRIUMPH2_SUPPORT)
    _bcm_flex_stat_t fs_arr[_bcmFlexStatNum]; /* Normalize stats */
    int idx;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  uint32           counter_indexes=0;
  bcm_stat_value_t counter_values={0};
#endif

  /* Make sure port module is initialized. */
  PORT_INIT(unit);

#if defined(BCM_PREEMPTION_SUPPORT)
  if (soc_feature(unit, soc_feature_preemption_cnt)) {
    bcm_port_t local_port;
    BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, port, &local_port));
    return bcmi_esw_preemption_counter_multi_get32(unit, 0, local_port, nstat,
                                                   stat_arr, value_arr);
  }
#endif /* BCM_PREEMPTION_SUPPORT */


  if (!soc_feature(unit,soc_feature_advanced_flex_counter)) {
    BCM_IF_ERROR_RETURN
        (_bcm_esw_port_stat_param_valid(unit, port));
    BCM_IF_ERROR_RETURN
        (_bcm_port_stat_array_convert(unit, nstat, stat_arr, fs_arr));
    BCM_PORT_VALUE_ARRAY_VALID(unit, nstat, value_arr);

    return _bcm_esw_flex_stat_multi_get32(unit, _bcmFlexStatTypeGport, port,
                                          nstat, fs_arr, value_arr);
  }
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  for (idx=0;idx < nstat ; idx ++) {
      BCM_IF_ERROR_RETURN(bcm_esw_port_stat_counter_get(
                             unit, port, stat_arr[idx],
                             1, &counter_indexes, &counter_values));
      if ((stat_arr[idx] == bcmPortStatIngressPackets) ||
          (stat_arr[idx] == bcmPortStatEgressPackets)) {
          value_arr[idx] = counter_values.packets;
      } else {
          value_arr[idx] = COMPILER_64_LO(counter_values.bytes);
      }
  }
  return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
#else
    return BCM_E_UNAVAIL;
#endif
}

/*
 * Function:
 *      bcm_esw_port_stat_multi_set
 * Purpose:
 *      Set 64-bit counter value for multiple port statistic types.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) GPORT ID
 *      nstat - (IN) Number of elements in stat array
 *      stat_arr - (IN) New statistics descriptors array
 *      value_arr - (IN) New counters values
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_stat_multi_set(int unit, bcm_gport_t port, int nstat,
                            bcm_port_stat_t *stat_arr,
                            uint64 *value_arr)
{
#if defined(BCM_TRIUMPH2_SUPPORT)
    _bcm_flex_stat_t fs_arr[_bcmFlexStatNum]; /* Normalize stats */
    int idx;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  uint32           counter_indexes=0;
  bcm_stat_value_t counter_values={0};
#endif

  /* Make sure port module is initialized. */
  PORT_INIT(unit);

#if defined(BCM_PREEMPTION_SUPPORT)
  if (soc_feature(unit, soc_feature_preemption_cnt)) {
    bcm_port_t local_port;
    BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, port, &local_port));
    return bcmi_esw_preemption_counter_multi_set(unit, local_port, nstat,
                                                 stat_arr, value_arr);
  }
#endif /* BCM_PREEMPTION_SUPPORT */

  if (!soc_feature(unit,soc_feature_advanced_flex_counter)) {
    BCM_IF_ERROR_RETURN
        (_bcm_esw_port_stat_param_valid(unit, port));
    BCM_IF_ERROR_RETURN
        (_bcm_port_stat_array_convert(unit, nstat, stat_arr, fs_arr));
    BCM_PORT_VALUE_ARRAY_VALID(unit, nstat, value_arr);

    return _bcm_esw_flex_stat_multi_set(unit, _bcmFlexStatTypeGport, port,
                                          nstat, fs_arr, value_arr);
  }
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  for (idx=0;idx < nstat ; idx ++) {
      if ((stat_arr[idx] == bcmPortStatIngressPackets) ||
          (stat_arr[idx] == bcmPortStatEgressPackets)) {
          counter_values.packets = COMPILER_64_LO(value_arr[idx]);
      } else {
          COMPILER_64_SET(counter_values.bytes,
                          COMPILER_64_HI(value_arr[idx]),
                          COMPILER_64_LO(value_arr[idx]));
      }
      BCM_IF_ERROR_RETURN(bcm_esw_port_stat_counter_set(
                             unit, port, stat_arr[idx],
                             1, &counter_indexes, &counter_values));
  }
  return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
#else
    return BCM_E_UNAVAIL;
#endif
}

/*
 * Function:
 *      bcm_esw_port_stat_multi_set32
 * Purpose:
 *      Set lower 32-bit counter value for multiple port statistic
 *      types.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) GPORT ID
 *      nstat - (IN) Number of elements in stat array
 *      stat_arr - (IN) New statistics descriptors array
 *      value_arr - (IN) New counters values
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_stat_multi_set32(int unit, bcm_gport_t port, int nstat,
                              bcm_port_stat_t *stat_arr,
                              uint32 *value_arr)
{
#if defined(BCM_TRIUMPH2_SUPPORT)
    _bcm_flex_stat_t fs_arr[_bcmFlexStatNum]; /* Normalize stats */
    int idx;
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  uint32           counter_indexes=0;
  bcm_stat_value_t counter_values={0};
#endif

  /* Make sure port module is initialized. */
  PORT_INIT(unit);

#if defined(BCM_PREEMPTION_SUPPORT)
  if (soc_feature(unit, soc_feature_preemption_cnt)) {
    bcm_port_t local_port;
    BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, port, &local_port));
    return bcmi_esw_preemption_counter_multi_set32(unit, local_port, nstat,
                                                   stat_arr, value_arr);
  }
#endif /* BCM_PREEMPTION_SUPPORT */

  if (!soc_feature(unit,soc_feature_advanced_flex_counter)) {
    BCM_IF_ERROR_RETURN
        (_bcm_esw_port_stat_param_valid(unit, port));
    BCM_IF_ERROR_RETURN
        (_bcm_port_stat_array_convert(unit, nstat, stat_arr, fs_arr));
    BCM_PORT_VALUE_ARRAY_VALID(unit, nstat, value_arr);

    return _bcm_esw_flex_stat_multi_set32(unit, _bcmFlexStatTypeGport, port,
                                          nstat, fs_arr, value_arr);
  }
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
  for (idx=0;idx < nstat ; idx ++) {
      if ((stat_arr[idx] == bcmPortStatIngressPackets) ||
          (stat_arr[idx] == bcmPortStatEgressPackets)) {
          counter_values.packets = value_arr[idx];
      } else {
          COMPILER_64_SET(counter_values.bytes,0,value_arr[idx]);
      }
      BCM_IF_ERROR_RETURN(bcm_esw_port_stat_counter_set(
                             unit, port, stat_arr[idx],
                             1, &counter_indexes, &counter_values));
  }
  return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
#else
    return BCM_E_UNAVAIL;
#endif
}

/*
 * Function    : _bcm_gport_dest_t_init
 * Description : Initialize gport_dest structure
 * Parameters  : (IN/OUT)  gport_dest - Structure to initialize
 * Returns     : None
 */

void
_bcm_gport_dest_t_init(_bcm_gport_dest_t *gport_dest)
{
    sal_memset(gport_dest, 0, sizeof (_bcm_gport_dest_t));
}


/*
 * Function    : _bcm_esw_gport_construct
 * Description : Internal function to construct a gport from
 *                given parameters
 * Parameters  : (IN)  unit       - BCM device number
 *               (IN)  gport_dest - Structure that contains destination
 *                                   to encode into a gport
 *               (OUT) gport      - Global port identifier
 * Returns     : BCM_E_XXX
 * Notes       : The modid and port are translated from the
 *               local modid/port space to application space
 */
int
_bcm_esw_gport_construct(int unit, _bcm_gport_dest_t *gport_dest, bcm_gport_t *gport)
{

    bcm_gport_t     l_gport = 0;
    bcm_module_t    mod_out;
    bcm_port_t      port_out;

    if ((NULL == gport_dest) || (NULL == gport) ){
        return BCM_E_PARAM;
    }

    switch (gport_dest->gport_type) {
        case _SHR_GPORT_TYPE_TRUNK:
            SOC_GPORT_TRUNK_SET(l_gport, gport_dest->tgid);
            break;
        case _SHR_GPORT_TYPE_LOCAL_CPU:
            l_gport = BCM_GPORT_LOCAL_CPU;
            break;
        case _SHR_GPORT_TYPE_BLACK_HOLE:
            l_gport = BCM_GPORT_BLACK_HOLE;
            break;
        case _SHR_GPORT_TYPE_LOCAL:
            SOC_GPORT_LOCAL_SET(l_gport, gport_dest->port);
            break;
        case _SHR_GPORT_TYPE_SUBPORT_GROUP:
            SOC_GPORT_SUBPORT_GROUP_SET(l_gport, gport_dest->subport_id);
            break;
        case _SHR_GPORT_TYPE_MPLS_PORT:
            BCM_GPORT_MPLS_PORT_ID_SET(l_gport, gport_dest->mpls_id);
            break;
        case _SHR_GPORT_TYPE_MIM_PORT:
            BCM_GPORT_MIM_PORT_ID_SET(l_gport, gport_dest->mim_id);
            break;
        case _SHR_GPORT_TYPE_WLAN_PORT:
            BCM_GPORT_WLAN_PORT_ID_SET(l_gport, gport_dest->wlan_id);
            break;
        case _SHR_GPORT_TYPE_TRILL_PORT:
            BCM_GPORT_TRILL_PORT_ID_SET(l_gport, gport_dest->trill_id);
            break;
        case _SHR_GPORT_TYPE_NIV_PORT:
            BCM_GPORT_NIV_PORT_ID_SET(l_gport, gport_dest->niv_id);
            break;
        case _SHR_GPORT_TYPE_L2GRE_PORT:
            BCM_GPORT_L2GRE_PORT_ID_SET(l_gport, gport_dest->l2gre_id);
            break;
        case _SHR_GPORT_TYPE_VXLAN_PORT:
            BCM_GPORT_VXLAN_PORT_ID_SET(l_gport, gport_dest->vxlan_id);
            break;
        case _SHR_GPORT_TYPE_FLOW_PORT:
            BCM_GPORT_FLOW_PORT_ID_SET(l_gport, gport_dest->flow_id);
            break;
        case _SHR_GPORT_TYPE_VLAN_PORT:
            BCM_GPORT_VLAN_PORT_ID_SET(l_gport, gport_dest->vlan_vp_id);
            break;
        case _SHR_GPORT_TYPE_EXTENDER_PORT:
            BCM_GPORT_EXTENDER_PORT_ID_SET(l_gport, gport_dest->extender_id);
            break;
        case _SHR_GPORT_TYPE_DEVPORT:
            BCM_GPORT_DEVPORT_SET(l_gport, unit, gport_dest->port);
            break;
        case _SHR_GPORT_TYPE_MODPORT:
            BCM_IF_ERROR_RETURN (
                _bcm_gport_modport_hw2api_map(unit, gport_dest->modid,
                                              gport_dest->port, &mod_out,
                                              &port_out));
            SOC_GPORT_MODPORT_SET(l_gport, mod_out, port_out);
            break;
        default:
            return BCM_E_PARAM;
    }

    *gport = l_gport;
    return BCM_E_NONE;
}

/*
 * Function    : _bcm_esw_gport_resolve
 * Description : Internal function to get modid, port, and trunk_id
 *               from a bcm_gport_t (global port)
 * Parameters  : (IN)  unit      - BCM device number
 *               (IN)  gport     - Global port identifier
 *               (OUT) modid     - Module ID
 *               (OUT) port      - Port number
 *               (OUT) trunk_id  - Trunk ID
 *               (OUT) id        - HW ID
 * Returns     : BCM_E_XXX
 * Notes       : The modid and port are translated from the
 *               application space to local modid/port space if applicable,
 *               on units without modid (Fabric) modid will be -1 and port
 *               will be a local physical port.
 */
int
_bcm_esw_gport_resolve(int unit, bcm_gport_t gport,
                       bcm_module_t *modid, bcm_port_t *port,
                       bcm_trunk_t *trunk_id, int *id)
{
    int             local_id, rv = BCM_E_NONE;
    bcm_module_t    mod_in, local_modid;
    bcm_port_t      port_in, local_port;
    bcm_trunk_t     local_tgid;
#ifdef BCM_KATANA_SUPPORT
    int extended_queue_id = 0;
#endif

    local_modid = -1;
    local_port = -1;
    local_id = -1;
    local_tgid = BCM_TRUNK_INVALID;

    if (BCM_GPORT_IS_TRUNK(gport)) {
        local_tgid = SOC_GPORT_TRUNK_GET(gport);
    } else if (BCM_GPORT_IS_LOCAL_CPU(gport)) {
        rv = bcm_esw_stk_my_modid_get(unit, &local_modid);
        if (BCM_FAILURE(rv) && !SOC_IS_XGS_FABRIC(unit)) {
            return rv;
        }
        local_port = CMIC_PORT(unit);
    } else if (BCM_GPORT_IS_LOCAL(gport)) {
        BCM_IF_ERROR_RETURN
            (bcm_esw_stk_my_modid_get(unit, &local_modid));
        local_port = SOC_GPORT_LOCAL_GET(gport);
        if (soc_feature(unit, soc_feature_sysport_remap)) {
            BCM_XLATE_SYSPORT_P2S(unit, &local_port);
        }
        if (!SOC_PORT_ADDRESSABLE(unit, local_port)) {
            return BCM_E_PORT;
        }
    } else if (BCM_GPORT_IS_DEVPORT(gport)) {
        rv = bcm_esw_stk_my_modid_get(unit, &local_modid);
        if (BCM_FAILURE(rv)) {
            if (!SOC_IS_XGS_FABRIC(unit)) {
                return rv;
            }
        }
        if (unit != SOC_GPORT_DEVPORT_DEVID_GET(gport)) {
            return BCM_E_PORT;
        }
        local_port = SOC_GPORT_DEVPORT_PORT_GET(gport);

        if (!SOC_PORT_ADDRESSABLE(unit, local_port)) {
            return BCM_E_PORT;
        }
    } else if (BCM_GPORT_IS_MODPORT(gport)) {
        mod_in = SOC_GPORT_MODPORT_MODID_GET(gport);
        port_in = SOC_GPORT_MODPORT_PORT_GET(gport);

        if (NUM_MODID(unit) > 1) {
#if defined(BCM_TOMAHAWK_SUPPORT)
            /* Call asymmetric dual modid unmapping function */
            if (soc_feature(unit, soc_feature_asymmetric_dual_modid)) {
                BCM_IF_ERROR_RETURN (
                    _bcm_esw_stk_asymmetric_dual_modmap_map(unit,
                                BCM_STK_MODMAP_GET, &mod_in, &port_in));
            } else
#endif /* BCM_TOMAHAWK_SUPPORT */
            if ((NUM_MODID(unit) > 1) && (port_in > SOC_INFO(unit).modport_max)) {
                mod_in = mod_in + 1;
                port_in = port_in - (SOC_INFO(unit).modport_max + 1);
            }
        }
        PORT_DUALMODID_VALID(unit, port_in);
        rv = _bcm_esw_stk_modmap_map(unit, BCM_STK_MODMAP_SET,
                                    mod_in, port_in, &local_modid, &local_port);

        if (!SOC_MODID_ADDRESSABLE(unit, local_modid)) {
            return BCM_E_BADID;
        }
        if (!SOC_PORT_ADDRESSABLE(unit, local_port)) {
            return BCM_E_PORT;
        }
    } else if (BCM_GPORT_IS_PROXY(gport)) {
        mod_in = BCM_GPORT_PROXY_MODID_GET(gport);
        port_in = BCM_GPORT_PROXY_PORT_GET(gport);
        PORT_DUALMODID_VALID(unit, port_in);
        rv = _bcm_esw_stk_modmap_map(unit, BCM_STK_MODMAP_SET,
                                    mod_in, port_in, &local_modid, &local_port);

        if (!SOC_MODID_ADDRESSABLE(unit, local_modid)) {
            return BCM_E_BADID;
        }
        if (!SOC_PORT_ADDRESSABLE(unit, local_port)) {
            return BCM_E_PORT;
        }
    }
#if defined(BCM_TRIUMPH_SUPPORT) && defined(BCM_MPLS_SUPPORT) && \
    defined(INCLUDE_L3)
    else if (BCM_GPORT_IS_MPLS_PORT(gport)) {
        if (SOC_IS_TR_VL(unit)) {
            rv = _bcm_tr_mpls_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id);
        }
    }
#endif
#if ((defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)) \
     && defined(INCLUDE_L3))
    else if (BCM_GPORT_IS_MIM_PORT(gport)) {
        if (soc_feature(unit, soc_feature_mim)) {
            rv = _bcm_tr2_mim_port_resolve(unit, gport, &local_modid,
                                          &local_port, &local_tgid,
                                          &local_id);
        }
    } else if (BCM_GPORT_IS_WLAN_PORT(gport)) {
        if (soc_feature(unit, soc_feature_wlan)) {
#if defined(BCM_TRIUMPH3_SUPPORT)
            if (SOC_IS_TRIUMPH3(unit)) {
                rv = _bcm_tr3_wlan_port_resolve(unit, gport, &local_modid,
                                               &local_port, &local_tgid,
                                               &local_id);
            } else
#endif /* BCM_TRIUMPH3_SUPPORT */
            {
                rv = _bcm_tr2_wlan_port_resolve(unit, gport, &local_modid,
                                               &local_port, &local_tgid,
                                               &local_id);
            }
        }
    }
#endif /* BCM_TRIUMPH2_SUPPORT && INCLUDE_L3 */
#if defined (BCM_TRIUMPH3_SUPPORT) && defined(INCLUDE_L3)
    else if (BCM_GPORT_IS_L2GRE_PORT(gport)) {
        if (soc_feature(unit, soc_feature_l2gre)) {
            rv = _bcm_tr3_l2gre_port_resolve(unit, gport, -1, &local_modid,
                                          &local_port, &local_tgid,
                                          &local_id);
        }
    }
#endif /* BCM_TRIUMPH3_SUPPORT && INCLUDE_L3 */
#if defined (BCM_TRIDENT2_SUPPORT) && defined(INCLUDE_L3)
    else if (BCM_GPORT_IS_VXLAN_PORT(gport)) {
        if (soc_feature(unit, soc_feature_vxlan)) {
            rv = _bcm_td2_vxlan_port_resolve(unit, gport, -1, &local_modid,
                                          &local_port, &local_tgid,
                                          &local_id);
        }
    }
#endif /* BCM_TRIDENT2_SUPPORT && INCLUDE_L3 */
#if defined (BCM_GREYHOUND2_SUPPORT) && defined(INCLUDE_L3)
    else if (BCM_GPORT_IS_VXLAN_PORT(gport)) {
        if (soc_feature(unit, soc_feature_vxlan_lite)) {
            rv = bcmi_gh2_vxlan_port_resolve(unit, gport, -1, &local_modid,
                                             &local_port, &local_tgid,
                                             &local_id);
        }
    }
#endif /* BCM_GREYHOUND2_SUPPORT && INCLUDE_L3 */
#if defined (BCM_TRIDENT3_SUPPORT) && defined(INCLUDE_L3)
    else if (BCM_GPORT_IS_FLOW_PORT(gport)) {
        if (soc_feature(unit, soc_feature_flex_flow)) {
            rv = _bcm_td3_flow_port_resolve(unit, gport, -1, &local_modid,
                                          &local_port, &local_tgid,
                                          &local_id);
        }
    }
#endif /* BCM_TRIDENT3_SUPPORT && INCLUDE_L3 */
#if defined (BCM_TRIDENT_SUPPORT) && defined(INCLUDE_L3)
    else if (BCM_GPORT_IS_TRILL_PORT(gport)) {
        if (soc_feature(unit, soc_feature_trill)) {
            rv = _bcm_td_trill_port_resolve(unit, gport, -1, &local_modid,
                                          &local_port, &local_tgid,
                                          &local_id);
        }
    }
#endif /* BCM_TRIDENT_SUPPORT && INCLUDE_L3 */
#if defined (BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    else if (BCM_GPORT_IS_SUBPORT_GROUP(gport)) {
        if (SOC_IS_TRX(unit)) {

#if defined (BCM_HGPROXY_COE_SUPPORT)
			if (soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
                soc_feature(unit, soc_feature_channelized_switching)) {
				rv = _bcmi_xgs5_subport_group_resolve(unit, gport, &local_modid,
												   &local_port, &local_tgid,
												   &local_id);
			} else
#endif /* defined (BCM_HGPROXY_COE_SUPPORT) */

#if defined (BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
                rv = bcm_kt2_subport_group_resolve(unit, gport, &local_modid,
                                                   &local_port, &local_tgid,
                                                   &local_id);
            } else
#endif /* defined (BCM_KATANA2_SUPPORT) */
            if (soc_feature(unit, soc_feature_subport_enhanced)) {
#if defined(BCM_TRIUMPH2_SUPPORT) && defined(INCLUDE_L3)
                rv = _bcm_tr2_subport_group_resolve(unit, gport, &local_modid,
                                                    &local_port, &local_tgid,
                                                    &local_id);
#endif /* defined(BCM_TRIUMPH2_SUPPORT) && defined(INCLUDE_L3) */
            } else if (soc_feature(unit, soc_feature_subport)) {
                rv = _bcm_tr_subport_group_resolve(unit, gport, &local_modid,
                                                   &local_port, &local_tgid,
                                                   &local_id);
            }
        }
    } else if (BCM_GPORT_IS_SUBPORT_PORT(gport)) {
        if (SOC_IS_TRX(unit)) {

#if defined (BCM_HGPROXY_COE_SUPPORT)
            if (soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
                soc_feature(unit, soc_feature_channelized_switching)) {
                rv = _bcm_xgs5_subport_port_resolve(unit, gport, &local_modid,
                                                   &local_port, &local_tgid,
                                                   &local_id);
            } else
#endif /* defined (BCM_HGPROXY_COE_SUPPORT) */

#if defined (BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {

                rv = bcm_kt2_subport_port_resolve(unit, gport, &local_modid,
                                                   &local_port, &local_tgid,
                                                   &local_id);
            } else
#endif /* defined (BCM_KATANA2_SUPPORT) */
            if (soc_feature(unit, soc_feature_subport_enhanced)) {
#if defined(BCM_TRIUMPH2_SUPPORT) && defined(INCLUDE_L3)
                rv = _bcm_tr2_subport_port_resolve(unit, gport, &local_modid,
                                                   &local_port, &local_tgid,
                                                   &local_id);
#endif /* defined(BCM_TRIUMPH2_SUPPORT) && defined(INCLUDE_L3) */
            } else if (soc_feature(unit, soc_feature_subport)) {
                rv = _bcm_tr_subport_port_resolve(unit, gport, &local_modid,
                                                  &local_port, &local_tgid,
                                                  &local_id);
            }
        }
    }
#endif /* BCM_TRX_SUPPORT && INCLUDE_L3 */
#ifdef BCM_TRIUMPH_SUPPORT
    else if (BCM_GPORT_IS_SCHEDULER(gport)) {
#if defined (BCM_TOMAHAWK3_SUPPORT)
        if (SOC_IS_TOMAHAWK3(unit)) {
            rv = _bcm_th3_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id, NULL);
        } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
#if defined (BCM_TOMAHAWK_SUPPORT)
        if (SOC_IS_TOMAHAWKX(unit)) {
            rv = _bcm_th_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id, NULL);
        } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_HURRICANE4_SUPPORT
        if (SOC_IS_HURRICANE4(unit)) {
            rv = _bcm_hr4_cosq_port_resolve(unit, gport, &local_modid,
                                            &local_port, &local_tgid,
                                            &local_id, NULL);
        } else
#endif /* BCM_HURRICANE4_SUPPORT */
#ifdef BCM_HELIX5_SUPPORT
        if (SOC_IS_HELIX5(unit)) {
            rv = _bcm_hx5_cosq_port_resolve(unit, gport, &local_modid,
                                            &local_port, &local_tgid,
                                            &local_id, NULL);
        } else
#endif /* BCM_HELIX5_SUPPORT */
#if defined (BCM_MONTEREY_SUPPORT)
        if (SOC_IS_MONTEREY(unit)) {
            rv = _bcm_mn_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id, NULL);
        } else
#endif
#ifdef BCM_FIREBOLT6_SUPPORT
        if (SOC_IS_FIREBOLT6(unit)) {
            rv = _bcm_fb6_cosq_port_resolve(unit, gport, &local_modid,
                                            &local_port, &local_tgid,
                                            &local_id, NULL);
        } else
#endif /* BCM_FIREBOLT6_SUPPORT */
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            rv = _bcm_td3_cosq_port_resolve(unit, gport, &local_modid,
                                            &local_port, &local_tgid,
                                            &local_id, NULL);
        } else
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined (BCM_APACHE_SUPPORT)
        if (SOC_IS_APACHE(unit)) {
            rv = _bcm_ap_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id, NULL);
        } else
#endif
#if defined (BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit)) {
            rv = _bcm_td2_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id, NULL);
        } else
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined (BCM_TRIDENT_SUPPORT)
        if (SOC_IS_TD_TT(unit)) {
            rv = _bcm_td_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id);
        } else
#endif /* BCM_TRIDENT_SUPPORT */
#if defined (BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            rv = _bcm_tr3_cosq_port_resolve(unit, gport, &local_modid,
                                            &local_port, &local_tgid,
                                            &local_id, NULL);
        } else
#endif /* BCM_TRIUMPH3_SUPPORT */
#if defined (BCM_TRIUMPH2_SUPPORT)
        if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
            SOC_IS_VALKYRIE2(unit)) {
            rv = _bcm_tr2_cosq_port_resolve(unit, gport, &local_modid,
                                            &local_port, &local_tgid,
                                            &local_id);
        } else
#endif /* BCM_TRIUMPH2_SUPPORT */
#if defined (BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit)) {
            rv = bcmi_gh2_cosq_port_resolve(unit, gport, &local_modid,
                                            &local_port, &local_tgid,
                                            &local_id);
        } else
#endif /* BCM_GREYHOUND2_SUPPORT */
        if (SOC_IS_TR_VL(unit)) {
            rv = _bcm_tr_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id);
        }
    }
#endif /* BCM_TRIUMPH_SUPPORT */
#ifdef BCM_KATANA_SUPPORT
    else if ((SOC_IS_KATANAX(unit)) &&
             ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) ||
              (BCM_GPORT_IS_UCAST_SUBSCRIBER_QUEUE_GROUP(gport)) ||
              (BCM_GPORT_IS_MCAST_SUBSCRIBER_QUEUE_GROUP(gport)))) {
        if (soc_feature(unit, soc_feature_extended_queueing)) {
#if defined(BCM_KATANA2_SUPPORT)
            if (SOC_IS_KATANA2(unit)) {
                 rv = _bcm_kt2_cosq_port_resolve(unit, gport, &local_modid,
                                       &local_port, &local_tgid,
                                       &local_id, &extended_queue_id);
            } else
#endif
            if (SOC_IS_KATANA(unit)){
                 rv = _bcm_kt_cosq_port_resolve(unit, gport, &local_modid,
                                       &local_port, &local_tgid,
                                       &local_id, &extended_queue_id);
            }
            local_tgid = extended_queue_id;
        }
    }
#endif /* BCM_KATANA_SUPPORT */

#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
    else if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) ||
             BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
#if defined (BCM_TOMAHAWK3_SUPPORT)
        if (SOC_IS_TOMAHAWK3(unit)) {
            rv = _bcm_th3_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id, NULL);
        } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
#if defined (BCM_TOMAHAWK_SUPPORT)
        if (SOC_IS_TOMAHAWKX(unit)) {
            rv = _bcm_th_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id, NULL);
        } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_HURRICANE4_SUPPORT
        if (SOC_IS_HURRICANE4(unit)) {
            rv = _bcm_hr4_cosq_port_resolve(unit, gport, &local_modid,
                                            &local_port, &local_tgid,
                                            &local_id, NULL);
        } else
#endif /* BCM_HURRICANE4_SUPPORT */
#ifdef BCM_HELIX5_SUPPORT
        if (SOC_IS_HELIX5(unit)) {
            rv = _bcm_hx5_cosq_port_resolve(unit, gport, &local_modid,
                                            &local_port, &local_tgid,
                                            &local_id, NULL);
        } else
#endif /* BCM_HELIX5_SUPPORT */
#if defined (BCM_MONTEREY_SUPPORT)
        if (SOC_IS_MONTEREY(unit)) {
            rv = _bcm_mn_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id, NULL);
        } else
#endif

#ifdef BCM_FIREBOLT6_SUPPORT
        if (SOC_IS_FIREBOLT6(unit)) {
            rv = _bcm_fb6_cosq_port_resolve(unit, gport, &local_modid,
                                            &local_port, &local_tgid,
                                            &local_id, NULL);
        } else
#endif /* BCM_FIREBOLT6_SUPPORT */
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit)) {
            rv = _bcm_td3_cosq_port_resolve(unit, gport, &local_modid,
                                            &local_port, &local_tgid,
                                            &local_id, NULL);
        } else
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_APACHE_SUPPORT)
        if (SOC_IS_APACHE(unit)) {
            rv = _bcm_ap_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id, NULL);
        } else
#endif /* BCM_APACHE_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TD2_TT2(unit)) {
            rv = _bcm_td2_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id, NULL);
        } else
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TRIDENT_SUPPORT)
        if (SOC_IS_TD_TT(unit)) {
            rv = _bcm_td_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id);
        } else
#endif /* BCM_TRIDENT_SUPPORT */
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            rv = _bcm_tr3_cosq_port_resolve(unit, gport, &local_modid,
                                           &local_port, &local_tgid,
                                           &local_id, NULL);
        } else
#endif
#if defined (BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit)) {
            rv = bcmi_gh2_cosq_port_resolve(unit, gport, &local_modid,
                                            &local_port, &local_tgid,
                                            &local_id);
        } else
#endif /* BCM_GREYHOUND2_SUPPORT */
        {
            return BCM_E_UNAVAIL;
        }
    }
#endif /* BCM_TRIDENT_SUPPORT || BCM_TRIUMPH3_SUPPORT */
#if defined(BCM_TRIUMPH2_SUPPORT) && defined(INCLUDE_L3)
    else if (BCM_GPORT_IS_VLAN_PORT(gport)) {
        if (soc_feature(unit, soc_feature_vlan_vp)) {
#if defined(BCM_ENDURO_SUPPORT)
            if (SOC_IS_ENDURO(unit)) {
                rv = _bcm_enduro_vlan_port_resolve(unit, gport, &local_modid,
                                          &local_port, &local_tgid,
                                          &local_id);
            } else
#endif /* BCM_ENDURO_SUPPORT */
            {
                rv = _bcm_tr2_vlan_port_resolve(unit, gport, &local_modid,
                                          &local_port, &local_tgid,
                                          &local_id);
            }
        }
    }
#endif /* BCM_TRIUMPH2_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIDENT_SUPPORT) && defined(INCLUDE_L3)
    else if (BCM_GPORT_IS_NIV_PORT(gport)) {
        if (soc_feature(unit, soc_feature_niv)) {
            rv = _bcm_trident_niv_port_resolve(unit, gport, &local_modid,
                    &local_port, &local_tgid,
                    &local_id);
        }
    }
#endif /* BCM_TRIDENT_SUPPORT && INCLUDE_L3 */
#if defined(BCM_TRIUMPH3_SUPPORT) && defined(INCLUDE_L3)
    else if (BCM_GPORT_IS_EXTENDER_PORT(gport)) {
        if (soc_feature(unit, soc_feature_port_extension)) {
            rv = _bcm_tr3_extender_port_resolve(unit, gport, &local_modid,
                    &local_port, &local_tgid,
                    &local_id);
        }
    }
#endif /* BCM_TRIUMPH3_SUPPORT && INCLUDE_L3 */
    else if (BCM_GPORT_IS_BLACK_HOLE(gport)) {
         local_modid = BCM_MODID_INVALID;
         local_tgid = BCM_TRUNK_INVALID;
         local_port = BCM_GPORT_INVALID;
         local_id = -1;
         rv = BCM_E_NONE;
    }
    else {
         /* BCM_GPORT_INVALID should return an error */
         return BCM_E_PORT;
    }
    *modid = local_modid;
    *port = local_port;
    *trunk_id = local_tgid;
    *id = local_id;
    return (rv);
}

/*
 * Function    : _bcm_esw_port_is_local_subport
 * Description : Internal function to check whehter a gport or (mod,port)
 *               is local subport.
 * Parameters  : (IN)  unit      - BCM device number
 *               (IN)  gport     - Global port identifier
 *               (IN)  modid     - Module ID
 *               (IN)  port      - Port number
 *               (OUT) is_local_subport     - True/False
 *               (OUT) phy_port             - physical port of subport
 * Returns     : BCM_E_XXX
 * Note: all gport, modid, port parameters are required.
 */
int
_bcm_esw_port_is_local_subport(int unit, bcm_gport_t gport,
                               bcm_module_t modid, bcm_port_t port,
                               int *is_local_subport, bcm_port_t *phy_port)
{
#if defined(BCM_KATANA2_SUPPORT)
    int pp_port;
    int min_subport = SOC_INFO(unit).pp_port_index_min;
    int max_subport = SOC_INFO(unit).pp_port_index_max;
#endif

    if ((is_local_subport == NULL) || (phy_port == NULL)) {
        return BCM_E_PARAM;
    }

    *is_local_subport = FALSE;

#if defined(BCM_HGPROXY_COE_SUPPORT)
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        soc_feature(unit, soc_feature_channelized_switching)) &&
        BCM_GPORT_IS_SET(gport) &&
        _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, gport)) {

        if(_bcm_xgs5_subport_coe_gport_local(unit, gport)) {
            *is_local_subport = TRUE;
        }

        if (*is_local_subport == FALSE) {
            return BCM_E_PORT;
        }

        BCM_IF_ERROR_RETURN(
            _bcmi_coe_subport_physical_port_get(unit, gport, phy_port));
    } else if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
                soc_feature(unit, soc_feature_channelized_switching)) &&
               _bcm_xgs5_subport_coe_mod_port_local(unit, modid, port)) {
        *is_local_subport = TRUE;
        BCM_IF_ERROR_RETURN(
            _bcmi_coe_subport_mod_port_physical_port_get(
                unit, modid, port, phy_port));
    } else
#endif

#if defined(BCM_KATANA2_SUPPORT)
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        if (BCM_GPORT_IS_SET(gport) &&
            _BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit, gport)) {
            pp_port = BCM_GPORT_SUBPORT_PORT_GET(gport);
            if ((_bcm_kt2_mod_is_coe_mod_check(unit, modid) == BCM_E_NONE) ||
                (soc_feature(unit, soc_feature_general_cascade) &&
                 SOC_PBMP_MEMBER(SOC_INFO(unit).general_pp_port_pbm, pp_port))) {
#if defined BCM_METROLITE_SUPPORT
                if (soc_feature(unit, soc_feature_discontinuous_pp_port)) {
                    if (_SOC_IS_PP_PORT_LINKPHY_SUBTAG(unit, pp_port)) {
                        *is_local_subport = TRUE;
                        *phy_port = pp_port;
                    }
                } else
#endif
                {
                    if ((pp_port >= min_subport) &&
                        (pp_port <= max_subport)) {
                        *is_local_subport = TRUE;
                        *phy_port = pp_port;
                    }
                }
            }
            if (*is_local_subport == FALSE) {
                return BCM_E_PORT;
            }
        }
    } else
#endif
    {
        return BCM_E_NONE;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_port_gport_get_from_modport
 * Purpose:
 *      Get a gport for all port.
 *      For non-COE port, it returns modport gport.
 *      For COE subport, it returns Coe subport gport.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      modid - (IN) Module id.
 *      port  - (IN) Port id.
 * Returns:
 *      gport
 * Notes:
 */
bcm_gport_t
_bcm_esw_port_gport_get_from_modport(int unit, bcm_module_t modid, bcm_port_t port)
{
    bcm_gport_t gport;

#if defined(BCM_HGPROXY_COE_SUPPORT)
    if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
        soc_feature(unit, soc_feature_channelized_switching)) &&
        _bcm_xgs5_subport_coe_mod_port_local(unit, modid, port)) {
        _BCM_SUBPORT_COE_PORT_ID_SET(gport, modid, port);
        _BCM_SUBPORT_COE_PORT_TYPE_SET(gport,_BCM_SUBPORT_COE_TYPE_SUBTAG);
    } else
#endif
    {
        BCM_GPORT_MODPORT_SET(gport, modid, port);
    }

    return gport;
}

/* Check if a given port is a valid controlling port for the Flex-port
   feature.
*/

unsigned
_bcm_esw_valid_flex_port_controlling_port(int unit, bcm_port_t port)
{
    uint16 dev_id;
    uint8  rev_id;

    if (!SOC_PORT_VALID(unit, port))  return (FALSE);

    soc_cm_get_id(unit, &dev_id, &rev_id);

    if (dev_id == BCM56636_DEVICE_ID) {
        /* Device is a BCM56636 */

        /* Only valid controlling ports are 42 and 50
	   (ports 30, 34 and 38 come up in gigE, and
	   therefore are not valid Flex-port controlling ports).
	*/

        if (port != 42 && port != 50)  return (FALSE);
    } else
#if defined(BCM_METROLITE_SUPPORT)
        if (SOC_IS_METROLITE(unit)) {
            if ((port != 1) && (port != 5) && (port != 9)) {
                return (FALSE);
            }
        } else
#endif
#if defined(BCM_SABER2_SUPPORT)
    if (SOC_IS_SABER2(unit)) {
         if ((port != 1) && (port != 5) && (port != 9)
             && (port != 13) && (port != 17) && (port != 21)
             && (port != 25)) {
             return (FALSE);
         }
    } else
#endif
#if defined(BCM_KATANA2_SUPPORT)
     if (SOC_IS_KATANA2(unit)) {
         if ((port != 1) && (port != 5) && (port != 9)
             && (port != 13) && (port != 17) && (port != 21)
             && (port != 25) && (port != 26) && (port != 27)
             && (port != 28)) {
             return (FALSE);
         }
     } else
#endif
     {
        if ((port != 30) && (port != 34) && (port != 38)
  	         && (port != 42) && (port != 46) && (port != 50)) {
             return (FALSE);
	    }
    }
    return (TRUE);
}


/*
 * Function:
 *      bcm_port_subsidiary_ports_get
 * Purpose:
 *      Given a controlling port, this API returns the set of ancillary ports
 *      belonging to the group (port block) that can be configured to operate
 *      either as a single high-speed port or multiple GE ports. If the input
 *      port is not a controlling port, BCM_E_PORT error will be returned.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port
 *      pbmp - (OUT) Ports associated with the hot-swap group
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_subsidiary_ports_get(int unit, bcm_port_t port, bcm_pbmp_t *pbmp)
{
    int rv = BCM_E_UNAVAIL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (!soc_feature(unit, soc_feature_flex_port)) {
        return BCM_E_UNAVAIL;
    }

#if defined(BCM_TRIDENT3_SUPPORT)
    if (SOC_IS_TRIDENT3X(unit)) {
        return (soc_td3_subsidiary_ports_get(unit, port, pbmp));
    }
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (SOC_IS_TOMAHAWKX(unit)) {
        return (soc_th_subsidiary_ports_get(unit, port, pbmp));
    }
#endif
#if defined(BCM_MONTEREY_SUPPORT)
    if (SOC_IS_MONTEREY(unit)) {
        return (soc_monterey_subsidiary_ports_get(unit, port, pbmp));
    }
#endif
#if defined(BCM_APACHE_SUPPORT)
    if (SOC_IS_APACHE(unit)) {
        return (soc_apache_subsidiary_ports_get(unit, port, pbmp));
    }
#endif
#ifdef BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TRIDENT2PLUS(unit)) {
        return(soc_td2p_subsidiary_ports_get(unit, port, pbmp));
    }
#endif

#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TD2_TT2(unit)) {
        soc_info_t *si = &SOC_INFO(unit);
        int i, port_num_lanes_max;
        int phy_port, phy_port_base, port_base, lp;
        bcm_pbmp_t pbm;

        if (!SOC_PORT_VALID(unit, port)) {
            return BCM_E_PORT;
        }
        /* coverity[overrun-local : FALSE] */
        phy_port = si->port_l2p_mapping[port];
        if (phy_port == -1) {
            return BCM_E_PORT;
        }

        phy_port_base = (phy_port & ~0x3) + 1;
        if (phy_port != phy_port_base) {
            return BCM_E_PORT;
        }

        port_base = si->port_p2l_mapping[phy_port_base];

        if (si->port_speed_max[port_base] > 20000) {
            port_num_lanes_max = 4;
        } else if (si->port_speed_max[port_base] > 10000) {
            port_num_lanes_max = 2;
        } else {
            port_num_lanes_max = 1;
        }

        BCM_PBMP_CLEAR(pbm);
        /* Get the subsidiary ports bitmap */
        for (i = 1; i < port_num_lanes_max; i++) {
            lp = si->port_p2l_mapping[phy_port_base + i];
            if (lp != -1
                && BCM_PBMP_MEMBER(PBMP_PORT_ALL(unit), lp)) {
                BCM_PBMP_PORT_ADD(pbm, lp);
            }
        }

        if (BCM_PBMP_IS_NULL(pbm)) { /* No Subsidiary ports */
            return BCM_E_PORT;
        }

        /* Add base port to subsidiary ports bitmap */
        BCM_PBMP_PORT_ADD(pbm, port_base);
        BCM_PBMP_ASSIGN(*pbmp, pbm);

        rv = BCM_E_NONE;
    }
#endif /* BCM_TRIDENT2_SUPPORT */

#if defined(BCM_TRIUMPH3_SUPPORT)
    if (SOC_IS_TRIUMPH3(unit)) {
        soc_info_t *si = &SOC_INFO(unit);
        int i, phy_port, phy_port_base, lp;
        bcm_pbmp_t pbm;

        BCM_PBMP_CLEAR(pbm);

        if ( !(IS_XW_PORT(unit,port) || IS_CL_PORT(unit, port) || IS_XT_PORT(unit,port)) ||
             !_bcm_tr3_port_is_control_port(unit, port) || !soc_tr3_port_is_flex_port(unit, port)) {
            return BCM_E_PORT;
        }
        /* coverity[overrun-local : FALSE] */
        phy_port = si->port_l2p_mapping[port];
        if (phy_port == -1) {
            return BCM_E_PORT;
        }
        phy_port_base = (phy_port & ~0x3) + 1;
        if (phy_port != phy_port_base) {
            return BCM_E_PORT;
        }
        BCM_PBMP_CLEAR(pbm);
        for (i = 0; i < _SOC_TR3_LANES_PER_PHY; i++) {
            /* coverity[overrun-local : FALSE] */
            lp = si->port_p2l_mapping[phy_port_base + i];
            if (lp != -1 &&
                (si->port_speed_max[lp] != 0) &&
                BCM_PBMP_MEMBER(PBMP_PORT_ALL(unit), lp)) {
                BCM_PBMP_PORT_ADD(pbm, lp);
            }
        }


        BCM_PBMP_ASSIGN(*pbmp, pbm);
        return BCM_E_NONE;
    }
#endif /* BCM_TRIUMPH3_SUPPORT */

#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_KATANA2_SUPPORT)
    if (!SOC_IS_ENDURO(unit) && !SOC_IS_HURRICANEX(unit) &&
        !SOC_IS_TD_TT(unit)) {
        int i;

        if (!_bcm_esw_valid_flex_port_controlling_port(unit, port)) {
            return (BCM_E_PORT);
        }

        BCM_PBMP_CLEAR(*pbmp);
        if ((SOC_IS_KATANA2(unit)) && (!SOC_IS_SABER2(unit))) {
            if (port == 25) {
                BCM_PBMP_PORT_ADD(*pbmp, 25);
                for (i = 0; i < 3; i++) {
                    if(SOC_PORT_VALID(unit, 35 + i)) {
                        BCM_PBMP_PORT_ADD(*pbmp, 35 + i);
                    }
                }
                return (BCM_E_NONE);
             } else if (port == 26) {
                 BCM_PBMP_PORT_ADD(*pbmp, 26);
                 for (i = 0; i < 3; i++) {
                      if(SOC_PORT_VALID(unit, 38 + i)) {
                         BCM_PBMP_PORT_ADD(*pbmp, 38 + i);
                      }
                 }
                 return (BCM_E_NONE);
             } else if (port == 27) {
                 BCM_PBMP_PORT_ADD(*pbmp, 27);
                 for (i = 0; i < 3; i++) {
                      if(SOC_PORT_VALID(unit, 32 + i)) {
                         BCM_PBMP_PORT_ADD(*pbmp, 32 + i);
                      }
                 }
                 return (BCM_E_NONE);
             }
        }

        for (i = 0; i < 4; i++) {
            /* coverity[overrun-local : FALSE] */
            if (SOC_PORT_VALID(unit, port + i)) {
                BCM_PBMP_PORT_ADD(*pbmp, port + i);
            }
        }
        rv = BCM_E_NONE;
    }
#endif

    return rv;
}

/*
 * Function:
 *      _bcm_esw_port_e2ecc_hg_pbm_convert
 * Purpose:
 *      Convert Higig port to E2ECC Higig port bitmap.
 * Parameters:
 *      port - (IN) Higig port number.
 *      converted_hg_pbm - (OUT) Converted Higig port bitmap.
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_port_e2ecc_hg_pbm_convert(bcm_port_t port, uint32 *converted_hg_pbm)
{
    int    hg_pbm_index;

    /* In Triumph2, the mapping between HG_PBM[9:0] and physical port number is:
     *
     * HG_PBM index:  |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
     * Physical Port: | 50 | 46 | 42 | 38 | 34 | 30 | 29 | 28 | 27 | 26 |
     */
    switch (port)
    {
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
            hg_pbm_index = port - 26;
            break;
        case 34:
        case 38:
        case 42:
        case 46:
        case 50:
            hg_pbm_index = 5 + (port - 34) / 4;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META("Error: Port %d is an invalid Higig port"), port));
            return BCM_E_PARAM;
    }

    *converted_hg_pbm = (1 << hg_pbm_index);

    return BCM_E_NONE;
}

STATIC int
_bcm_esw_port_drop_status_enable_set(int unit, bcm_port_t port, int enable)
{
    uint32 rval;
    int idx;

#if defined(BCM_MONTEREY_SUPPORT)
    if (SOC_IS_MONTEREY(unit)) {
        return bcm_mn_cosq_drop_status_enable_set(unit, port, enable);
    }
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_APACHE_SUPPORT)
    if (SOC_IS_APACHE(unit)) {
        return bcm_ap_cosq_drop_status_enable_set(unit, port, enable);
    }
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (SOC_IS_TD2_TT2(unit)) {
        return bcm_td2_cosq_drop_status_enable_set(unit, port, enable);
    }
#endif /* BCM_TRIDENT2_SUPPORT */

#if defined(BCM_TRIDENT_SUPPORT)
    if (SOC_IS_TD_TT(unit)) {
        return bcm_td_cosq_drop_status_enable_set(unit, port, enable);
    }
#endif /* BCM_TRIDENT_SUPPORT */

#if defined(BCM_TRIUMPH3_SUPPORT)
    if (SOC_IS_TRIUMPH3(unit)) {
        return bcm_tr3_cosq_drop_status_enable_set(unit, port, enable);
    }
#endif /* BCM_TRIUMPH3_SUPPORT */

#if defined(BCM_KATANA_SUPPORT)
    if (SOC_IS_KATANA(unit)) {
        return bcm_kt_cosq_drop_status_enable_set(unit, port, enable);
    }
#endif /* BCM_KATANA_SUPPORT */
#if defined(BCM_KATANA2_SUPPORT)
    if (SOC_IS_KATANA2(unit)) {
        return bcm_kt2_cosq_drop_status_enable_set(unit, port, enable);
    }
#endif /* BCM_KATANA2_SUPPORT */
#if defined(BCM_HURRICANE3_SUPPORT)
    if (SOC_IS_HURRICANE3(unit)) {
        return bcm_hr3_cosq_drop_status_enable_set(unit, port, enable);
    }
#endif /* BCM_HURRICANE3_SUPPORT */
#if defined(BCM_GREYHOUND2_SUPPORT)
    if (SOC_IS_GREYHOUND2(unit)) {
        return bcmi_gh2_cosq_drop_status_enable_set(unit, port, enable);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    for (idx = 0; idx < 8; idx++) {
        if (SOC_IS_SC_CQ(unit)) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIGr(unit, port, idx, &rval));
            soc_reg_field_set(unit, OP_QUEUE_CONFIGr, &rval,
                              Q_E2E_DS_ENABLEf, enable ? 1 : 0);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIGr(unit, port, idx, rval));
        } else if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
                   SOC_IS_VALKYRIE2(unit)) {
            SOC_IF_ERROR_RETURN
                (READ_OP_QUEUE_CONFIG1_CELLr(unit, port, idx, &rval));
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_CELLr, &rval,
                              Q_E2E_DS_EN_CELLf, enable ? 1 : 0);
            SOC_IF_ERROR_RETURN
                (WRITE_OP_QUEUE_CONFIG1_CELLr(unit, port, idx, rval));

            SOC_IF_ERROR_RETURN
                (READ_OP_QUEUE_CONFIG1_PACKETr(unit, port, idx, &rval));
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_PACKETr, &rval,
                              Q_E2E_DS_EN_PACKETf, enable ? 1 : 0);
            SOC_IF_ERROR_RETURN
                (WRITE_OP_QUEUE_CONFIG1_PACKETr(unit, port, idx, rval));
        }
    }

    SOC_IF_ERROR_RETURN(READ_OP_THR_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, OP_THR_CONFIGr, &rval, EARLY_E2E_SELECTf,
                      enable ? 1 : 0);
    SOC_IF_ERROR_RETURN(WRITE_OP_THR_CONFIGr(unit, rval));

    return BCM_E_NONE;
}

/*
 * Function:
 *     _bcm_esw_port_e2e_tx_enable_set
 * Purpose:
 *      Set E2E Tx Enable
 * Parameters:
 *      unit - (IN) SOC unit number.
 *      port - (IN) Port number.
 *      enable - (IN) Whether to enable or disable
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_port_e2e_tx_enable_set(int unit, bcm_port_t port, int enable)
{
    uint64 rval64;

    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        return bcmi_esw_portctrl_e2e_tx_enable_set(unit, port, enable);
    }

    if (IS_CL_PORT(unit, port)) {
        SOC_IF_ERROR_RETURN(READ_CLMAC_E2E_CTRLr(unit, port, &rval64));
        soc_reg64_field32_set(unit, CLMAC_E2E_CTRLr, &rval64,
                E2E_ENABLEf, enable);
        SOC_IF_ERROR_RETURN(WRITE_CLMAC_E2E_CTRLr(unit, port, rval64));
    } else {
        SOC_IF_ERROR_RETURN(READ_XLMAC_E2E_CTRLr(unit, port, &rval64));
        soc_reg64_field32_set(unit, XLMAC_E2E_CTRLr, &rval64,
                E2E_ENABLEf, enable);
        SOC_IF_ERROR_RETURN(WRITE_XLMAC_E2E_CTRLr(unit, port, rval64));
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_port_e2ecc_tx
 * Purpose:
 *      Configure E2ECC message transmission.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Local port number.
 *      config - (IN) Congestion configuration.
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_port_e2ecc_tx(int unit, bcm_port_t port,
                       bcm_port_congestion_config_t *config)
{
    uint32 regval;
    uint32 hg_pbm, converted_hg_pbm, new_hg_pbm;
    int    value_a, value_b;
    int    time_unit_sel, time_units;
    int    src_modid, src_pid;
    soc_higig_e2ecc_hdr_t e2ecc_hdr;
    int blk, blk_num = -1, bindex = 0;
    if (config->flags & BCM_PORT_CONGESTION_CONFIG_TX) {
        /* If BCM_PORT_CONGESTION_CONFIG_TX flag is set, enable E2ECC transmission. */

        /* Set chip-wide E2ECC enable bit */
        if (SOC_IS_SC_CQ(unit)) {
            SOC_IF_ERROR_RETURN(READ_E2E_HOL_ENr(unit, &regval));
            if (soc_reg_field_get(unit, E2E_HOL_ENr, regval, ENf) == 0) {
                soc_reg_field_set(unit, E2E_HOL_ENr, &regval, ENf, 1);
                SOC_IF_ERROR_RETURN(WRITE_E2E_HOL_ENr(unit, regval));
            }
        } else {
            SOC_IF_ERROR_RETURN(READ_E2ECC_HOL_ENr(unit, &regval));
            if (soc_reg_field_get(unit, E2ECC_HOL_ENr, regval, ENf) == 0) {
                soc_reg_field_set(unit, E2ECC_HOL_ENr, &regval, ENf, 1);
                SOC_IF_ERROR_RETURN(WRITE_E2ECC_HOL_ENr(unit, regval));
            }
        }


        /* In Trident E2E_HOL_ENf is not present. MMY E2ECC_HOL_EN is used */
        /* (Checked with Architecture) */
        if (soc_reg_field_valid(unit, XPORT_CONFIGr, E2E_HOL_ENf)) {
            /* Set per-port E2ECC TX enable bit */
            SOC_IF_ERROR_RETURN(READ_XPORT_CONFIGr(unit, port, &regval));
            if (soc_reg_field_get(unit, XPORT_CONFIGr,
                                  regval, E2E_HOL_ENf) == 0) {
                soc_reg_field_set(unit, XPORT_CONFIGr, &regval,
                                  E2E_HOL_ENf, 1);
                SOC_IF_ERROR_RETURN(WRITE_XPORT_CONFIGr(unit, port, regval));
            }
        }

        if (soc_reg_field_valid(unit, XPORT_MODE_REGr, E2E_HOL_ENf)) {
            /* Set per-port E2ECC TX enable bit */
            SOC_IF_ERROR_RETURN(READ_XPORT_MODE_REGr(unit, port, &regval));
            if (soc_reg_field_get(unit, XPORT_MODE_REGr,
                                  regval, E2E_HOL_ENf) == 0) {
                soc_reg_field_set(unit, XPORT_MODE_REGr, &regval,
                                  E2E_HOL_ENf, 1);
                SOC_IF_ERROR_RETURN(WRITE_XPORT_MODE_REGr(unit, port, regval));
            }
        }

        /* Set per-queue E2ECC enable bits */
        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_drop_status_enable_set(unit, port, TRUE));

        /* Set the Higig port bitmap used to transmit E2ECC messages */
        if (SOC_IS_SC_CQ(unit)) {
            SOC_IF_ERROR_RETURN(READ_E2E_HOL_PBMr(unit, &regval));
            hg_pbm = soc_reg_field_get(unit, E2E_HOL_PBMr, regval, PORT_BITMAPf);

            converted_hg_pbm = 1 << port;

            if (!(hg_pbm & converted_hg_pbm)) {
                new_hg_pbm = hg_pbm | converted_hg_pbm;
                soc_reg_field_set(unit, E2E_HOL_PBMr, &regval, PORT_BITMAPf, new_hg_pbm);
                SOC_IF_ERROR_RETURN(WRITE_E2E_HOL_PBMr(unit, regval));
            }
        } else if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) ||
                   SOC_IS_VALKYRIE2(unit)) {
            SOC_IF_ERROR_RETURN(READ_E2ECC_HOL_PBMr(unit, &regval));
            hg_pbm = soc_reg_field_get(unit, E2ECC_HOL_PBMr, regval, HG_PBMf);

            SOC_IF_ERROR_RETURN(_bcm_esw_port_e2ecc_hg_pbm_convert(port, &converted_hg_pbm));

            if (!(hg_pbm & converted_hg_pbm)) {
                new_hg_pbm = hg_pbm | converted_hg_pbm;
                soc_reg_field_set(unit, E2ECC_HOL_PBMr, &regval, HG_PBMf, new_hg_pbm);
                SOC_IF_ERROR_RETURN(WRITE_E2ECC_HOL_PBMr(unit, regval));
            }
        } else { /* TD_TT, KATANAX, TR3 */
            if (soc_feature(unit, soc_feature_logical_port_num)) {
                blk = SOC_PORT_BLOCK(unit, SOC_INFO(unit).port_l2p_mapping[port]);
                bindex = SOC_PORT_BINDEX(unit, SOC_INFO(unit).port_l2p_mapping[port]);
            } else{
                blk = SOC_PORT_BLOCK(unit, port);
                bindex = SOC_PORT_BINDEX(unit, port);
            }
#if defined(BCM_APACHE_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)
            if (SOC_IS_TRIDENT2X(unit)) {
                blk_num = SOC_INFO(unit).port_serdes[port];
            } else
#endif
            {
                blk_num = SOC_BLOCK_INFO(unit, blk).number;
            }
            /* In TR3 E2ECC is implemented only in blocks CL, XL1 */
            if (!SOC_IS_TRIUMPH3(unit) || (IS_CL_PORT(unit, port) || (blk == 13))) {
                if (SOC_IS_TRIUMPH3(unit)) {
                    if (IS_CL_PORT(unit, port)) {
                        blk_num = (blk_num ?  4 + bindex/4 : bindex/4);
                        bindex = bindex%4;
                    } else {
                        blk_num = 3;
                    }
                }
#if defined(BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit)) {
                    /* In KT2 E2ECC is implemented only in blocks 6..9 */
                    blk_num = (blk_num >= 6) ? (blk_num - 6) : blk_num ;
                }
#endif
                SOC_IF_ERROR_RETURN(READ_E2ECC_TX_ENABLE_BMPr(unit, blk_num,
                                                              &regval));
                if (!(regval & (1 << bindex))) {
                    new_hg_pbm = soc_reg_field_get(unit, E2ECC_TX_ENABLE_BMPr, regval,
                                                   TX_ENABLE_BMPf);
                    /* new_hg_pbm &= ~(1 << bindex); */
                    new_hg_pbm |= (1 << bindex);
                    soc_reg_field_set(unit, E2ECC_TX_ENABLE_BMPr, &regval,
                                      TX_ENABLE_BMPf, new_hg_pbm);
                    SOC_IF_ERROR_RETURN
                        (WRITE_E2ECC_TX_ENABLE_BMPr(unit, blk_num, regval));
                }
            }

#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
            if (SOC_IS_TD2_TT2(unit)) {
                SOC_IF_ERROR_RETURN(_bcm_esw_port_e2e_tx_enable_set(unit, port, 1));

                /* DMVOQ congestion bytes max length is 64 bytes,
                               As a result
                 DMVOQ feature can support upto 64 ports*/
                SOC_IF_ERROR_RETURN(READ_E2ECC_TX_PORTS_NUMr(unit, &regval));
                soc_reg_field_set(unit, E2ECC_TX_PORTS_NUMr, &regval,
                        TX_PORTS_NUMf, BCM_MAX_PORTS_SUPPORT_FOR_DMVOQ);
                SOC_IF_ERROR_RETURN(WRITE_E2ECC_TX_PORTS_NUMr(unit, regval));

                /* By default congestion states of 4 cos values are transmitted
                   inorder to transmit the congestion state for all the
                   8 cos values
                   if num_coq > 8 following configuration is done */
                if (!SOC_IS_TRIUMPH3(unit) && !SOC_IS_MONTEREY(unit) && NUM_COS(unit) >= 8) {
                    uint64 rval64 ;
                    uint64  fval64;
                    COMPILER_64_ZERO(fval64);
                    COMPILER_64_SET(fval64, 0xffffffff, 0xffffffff);
                    soc_reg64_field_set(unit, OOBFC_ENG_PORT_QSEL0_64r ,
                            &rval64,
                            ENG_PORT_QSELf, fval64);
                    SOC_IF_ERROR_RETURN(WRITE_OOBFC_ENG_PORT_QSEL0_64r(unit,
                                rval64));
                }
            }
#endif
#if defined(BCM_HURRICANE3_SUPPORT)
            if (SOC_IS_FIRELIGHT(unit)) {
                /* When in Chassis mode, _soc_firelight_mmu_init_helper_chassis()
                *  would set E2ECC_TX_PORTS_NUM the correct value. Leave it alone
                *  for firelight.
                */
                SOC_IF_ERROR_RETURN(_bcm_esw_port_e2e_tx_enable_set(unit, port, 1));
            } else if (SOC_IS_HURRICANE3(unit) || SOC_IS_GREYHOUND2(unit)) {
                uint32 max_bitmap;
                SOC_IF_ERROR_RETURN(READ_E2ECC_TX_PORTS_NUMr(unit, &regval));
                /* max Congestion bitmap number of E2ECC message */
                if (SOC_IS_HURRICANE3(unit)) {
                    max_bitmap = 36;
                } else { /* GREYHOUND2 */
                    max_bitmap = 64;
                }
                soc_reg_field_set(unit, E2ECC_TX_PORTS_NUMr, &regval,
                        TX_PORTS_NUMf, max_bitmap);
                SOC_IF_ERROR_RETURN(WRITE_E2ECC_TX_PORTS_NUMr(unit, regval));

                SOC_IF_ERROR_RETURN(_bcm_esw_port_e2e_tx_enable_set(unit, port, 1));
            }
#endif

            if (SOC_IS_KATANAX(unit)) {
                SOC_IF_ERROR_RETURN(READ_OP_THR_CONFIGr(unit, &regval));
                soc_reg_field_set(unit, OP_THR_CONFIGr, &regval, E2ECC_HOL_ENf, 1);
                SOC_IF_ERROR_RETURN(WRITE_OP_THR_CONFIGr(unit, regval));
                if (SOC_IS_SABER2(unit)) {
                    SOC_IF_ERROR_RETURN(_bcm_esw_port_e2e_tx_enable_set(unit, port, 1));
                }
            }
        }

        /* Configuring the E2ECC min timer so that during congestion, back-to-back
         * E2ECC messages are generated as fast as hardware allows.
         */
        if (SOC_IS_SC_CQ(unit)) {

            SOC_IF_ERROR_RETURN(READ_E2E_MIN_TX_TIMERr(unit, &regval));
            if (soc_reg_field_get(unit, E2E_MIN_TX_TIMERr, regval, TIMERf) != 0) {
                soc_reg_field_set(unit, E2E_MIN_TX_TIMERr, &regval, TIMERf, 0);
                soc_reg_field_set(unit, E2E_MIN_TX_TIMERr, &regval, LGf, 0);
                SOC_IF_ERROR_RETURN(WRITE_E2E_MIN_TX_TIMERr(unit, regval));
            }
        } else {
            SOC_IF_ERROR_RETURN(READ_E2ECC_MIN_TX_TIMERr(unit, &regval));
            if (soc_reg_field_get(unit, E2ECC_MIN_TX_TIMERr, regval, TIMERf) != 0) {
                soc_reg_field_set(unit, E2ECC_MIN_TX_TIMERr, &regval, TIMERf, 0);
                soc_reg_field_set(unit, E2ECC_MIN_TX_TIMERr, &regval, LGf, 0);
                SOC_IF_ERROR_RETURN(WRITE_E2ECC_MIN_TX_TIMERr(unit, regval));
            }
        }

        /* In the absence of congestion, an E2ECC message is still generated to refresh
         * congestion status when the E2ECC max timer expires. This timer is specified
         * in units of 250ns or 25us, and up to 1023 time units can be specified.
         * The selection of time unit and the number of time units is computed as follows:
         *
         * Let E2ECC message refresh rate = N messages/sec, and N != 0,
         * then A = # of 250ns time units = 1 sec / N / 250ns = 4000000 / N,
         * and B = # of 25us time units = 1 sec / N / 25us = 40000 / N = A / 100.
         *
         * If A < 1, configure the minimum allowed timer value: time unit = 250ns,
         * # of time units = 1.
         *
         * If A is between 1 and 1023, configure the timer as: time unit = 250ns,
         * # of time units = A.
         *
         * If A > 1023 and B <= 1023, configure the timer as: time unit = 25us,
         * # of time units = B.
         *
         * If B > 1023, configure the maximum allowed timer value: time unit = 25us,
         * # of time units = 1023.
         *
         * Note: If N = 0, # of time units will be set to 0, and E2ECC message refresh
         *       is effectively disabled. E2ECC message will be generated only when
         *       there is a change in congestion status.
         */

        if (config->packets_per_sec == 0) {
            time_unit_sel = 0;
            time_units = 0;
        } else {
            value_a = 4000000 / config->packets_per_sec;
            value_b = value_a / 100;
            if (value_a < 1) {
                time_unit_sel = 0;
                time_units = 1;
            } else if (value_a <= 1023) {
                time_unit_sel = 0;
                time_units = value_a;
            } else if ((value_a > 1023) && (value_b <= 1023)) {
                time_unit_sel = 1;
                time_units = value_b;
            } else { /* value_b > 1023 */
                time_unit_sel = 1;
                time_units = 1023;
            }
        }

        if (SOC_IS_SC_CQ(unit)) {
            SOC_IF_ERROR_RETURN(READ_E2E_MAX_TX_TIMERr(unit, &regval));
            soc_reg_field_set(unit, E2E_MAX_TX_TIMERr, &regval, LGf,
                              time_unit_sel);
            soc_reg_field_set(unit, E2E_MAX_TX_TIMERr, &regval, TIMERf,
                              time_units);
            SOC_IF_ERROR_RETURN(WRITE_E2E_MAX_TX_TIMERr(unit, regval));
        } else {
            SOC_IF_ERROR_RETURN(READ_E2ECC_MAX_TX_TIMERr(unit, &regval));
            soc_reg_field_set(unit, E2ECC_MAX_TX_TIMERr, &regval, LGf,
                              time_unit_sel);
            soc_reg_field_set(unit, E2ECC_MAX_TX_TIMERr, &regval, TIMERf,
                              time_units);
            SOC_IF_ERROR_RETURN(WRITE_E2ECC_MAX_TX_TIMERr(unit, regval));
        }

        /* Configure per-port E2ECC message header */
#ifdef BCM_FIRELIGHT_SUPPORT
        if (SOC_IS_FIRELIGHT(unit) && (!IS_HG_PORT(unit, port))) {
            uint64 rval;

            if (!IS_CL_PORT(unit, port) && !IS_XL_PORT(unit, port)) {
                return BCM_E_UNAVAIL;
            }

            if (IS_CL_PORT(unit, port)) {
                SOC_IF_ERROR_RETURN(READ_CLMAC_MODEr(unit, port, &rval));
            } else {
                SOC_IF_ERROR_RETURN(READ_XLMAC_MODEr(unit, port, &rval));
            }
            if (soc_reg64_field32_get(unit, CLMAC_MODEr, rval, HDR_MODEf)
                !=SOC_ENCAP_IEEE) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                             (BSL_META_U(unit,
                          "Error: unit %d port %d is not a Higig port. "
                          "HDR_MODE of XL or CL port should be configured "
                          "with IEEE Ethernet format.\n"),
                          unit, port));
                return BCM_E_UNAVAIL;
            }

            sal_memset(&e2ecc_hdr, 0, sizeof(soc_higig_e2ecc_hdr_t));

            e2ecc_hdr.overlay1.words[0] =
                        (config->dest_mac[0] << 24) |                  /* MAC-DA[47:40] */
                        (config->dest_mac[1] << 16) |                  /* MAC-DA[39:32] */
                        (config->dest_mac[2] << 8) |                   /* MAC-DA[31:24] */
                        (config->dest_mac[3]);                         /* MAC-DA[23:16] */

            e2ecc_hdr.overlay1.words[1] =
                        (config->dest_mac[4] << 24) |                  /* MAC-DA[15:8] */
                        (config->dest_mac[5] << 16) |                  /* MAC-DA[7:0] */
                        (config->src_mac[0] << 8) |                    /* MAC-SA[47:40] */
                        (config->src_mac[1]);                          /* MAC-SA[39:32] */

            e2ecc_hdr.overlay1.words[2] =
                        (config->src_mac[2] << 24) |                   /* MAC-SA[31:24] */
                        (config->src_mac[3] << 16) |                   /* MAC-SA[23:16] */
                        (config->src_mac[4] << 8) |                    /* MAC-SA[15:8] */
                        (config->src_mac[5]);                          /* MAC-SA[7:0] */

            /* SVTAG for E2ECC on ethernet port is fixed to be 0xff0008ff
             * SVTAG Signature = 0xFF
             * MACSEC Error Code = 0x00
             * PRI = 0
             * CPU = 0            ,CPU = 0 should be set for all control packets
             * PKT_TYPE = 2b10    ,control packet
             * RSVD = 0
             * Channel # = 0xFF
             */
            e2ecc_hdr.overlay1.words[3] = 0xff0008ff;
            e2ecc_hdr.overlay1.words[4] =
                ((config->ethertype & 0xFFFF) << 16) |      /* Ethertype[15:0] */
                (config->opcode & 0xFFFF);                  /* Opcode[7:0] */
            e2ecc_hdr.overlay1.words[5] = 0;
            e2ecc_hdr.overlay1.words[6] = 0;
            e2ecc_hdr.overlay1.words[7] = 0;
        } else
#endif /* BCM_FIRELIGHT_SUPPORT */
        {
            if (BCM_GPORT_IS_MODPORT(config->src_port)) {
                src_modid = BCM_GPORT_MODPORT_MODID_GET(config->src_port);
                src_pid = BCM_GPORT_MODPORT_PORT_GET(config->src_port);
            } else {
                LOG_ERROR(BSL_LS_BCM_PORT,
                          (BSL_META_U(unit,
                                      "Error: src_port %d is not of type modid:port.\n"), config->src_port));
                return BCM_E_PARAM;
            }

            sal_memset(&e2ecc_hdr, 0, sizeof(soc_higig_e2ecc_hdr_t));

            e2ecc_hdr.overlay1.words[0] =
                        (SOC_HIGIG_START << 24) |                              /* K.SOP[7:0] */
                        (((1 << 4) | (config->traffic_class & 0x0F)) << 16) |  /* MC and TC[3:0] */
                        (config->multicast_id & 0xFFFF);                       /* MGID[15:0] */

            e2ecc_hdr.overlay1.words[1] =
                        ((src_modid & 0xFF) << 24) |                           /* SRC_MODID[7:0] */
                        ((src_pid & 0xFF) << 16) |                             /* SRC_PID[7:0] */
                        ((config->color & 0x03) << 6);                         /* DP[1:0] */

            /* e2ecc_hdr.overlay1.words[2] is all zeroes. */

            if (config->flags & BCM_PORT_CONGESTION_CONFIG_DESTMOD_FLOW_CONTROL) {
                /* In case of DMVOQ, we are sending opcode as Multicast
                   so that packet is accepted at different modules */
                e2ecc_hdr.overlay1.words[3] =
                    ((config->pri & 0x07) << 29) |   /* VID_HIGH[7:5] */
                    ((config->cfi & 0x01) << 28) |   /* VID_HIGH[4] */
                    ((config->vlan & 0xfff) << 16) | /* VID_HIGH[3:0], VID_LOW[7:0] */
                    ((SOC_HIGIG_OP_MC & 0x07) << 8);  /* OPCODE[2:0] */
            } else {
                e2ecc_hdr.overlay1.words[3] =
                    ((config->pri & 0x07) << 29) |   /* VID_HIGH[7:5] */
                    ((config->cfi & 0x01) << 28) |   /* VID_HIGH[4] */
                    ((config->vlan & 0xfff) << 16) | /* VID_HIGH[3:0], VID_LOW[7:0] */
                    ((SOC_HIGIG_OP_BC & 0x07) << 8);  /* OPCODE[2:0] */
            }

            e2ecc_hdr.overlay1.words[4] =
                        (config->dest_mac[0] << 24) |                          /* MAC-DA[47:40] */
                        (config->dest_mac[1] << 16) |                          /* MAC-DA[39:32] */
                        (config->dest_mac[2] << 8) |                           /* MAC-DA[31:24] */
                        (config->dest_mac[3]);                                 /* MAC-DA[23:16] */

            e2ecc_hdr.overlay1.words[5] =
                        (config->dest_mac[4] << 24) |                          /* MAC-DA[15:8] */
                        (config->dest_mac[5] << 16) |                          /* MAC-DA[7:0] */
                        (config->src_mac[0] << 8) |                            /* MAC-SA[47:40] */
                        (config->src_mac[1]);                                  /* MAC-SA[39:32] */

            e2ecc_hdr.overlay1.words[6] =
                        (config->src_mac[2] << 24) |                           /* MAC-SA[31:24] */
                        (config->src_mac[3] << 16) |                           /* MAC-SA[23:16] */
                        (config->src_mac[4] << 8) |                            /* MAC-SA[15:8] */
                        (config->src_mac[5]);                                  /* MAC-SA[7:0] */

            e2ecc_hdr.overlay1.words[7] =
                        ((config->ethertype & 0xFFFF) << 16) |                 /* Ethertype[15:0] */
                        (config->opcode & 0xFFFF);                             /* Opcode[7:0] */
        }

        BCM_IF_ERROR_RETURN(_bcm_esw_port_e2ecc_hdr_set(unit, port, &e2ecc_hdr));

        /* Enable QE interop mode */
        if (SOC_IS_SC_CQ(unit)) {
            SOC_IF_ERROR_RETURN(READ_GLOBAL_SHARED_FILL_STATE_CONFIGr(unit, &regval));
            if (soc_reg_field_get(unit, GLOBAL_SHARED_FILL_STATE_CONFIGr, regval,
                                  GLOBAL_SHARED_FILL_STATE_ENf) == 0) {
                soc_reg_field_set(unit, GLOBAL_SHARED_FILL_STATE_CONFIGr, &regval,
                                  GLOBAL_SHARED_FILL_STATE_ENf, 1);
                SOC_IF_ERROR_RETURN(WRITE_GLOBAL_SHARED_FILL_STATE_CONFIGr(unit, regval));
            }
        } else if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_VALKYRIE2(unit)) {
            SOC_IF_ERROR_RETURN(READ_QE_INTEROP_CONFIGr(unit, &regval));
            if (soc_reg_field_get(unit, QE_INTEROP_CONFIGr, regval, QE_INTEROP_ENf) == 0) {
                soc_reg_field_set(unit, QE_INTEROP_CONFIGr, &regval, QE_INTEROP_ENf, 1);
                SOC_IF_ERROR_RETURN(WRITE_QE_INTEROP_CONFIGr(unit, regval));
            }
        } else if (SOC_IS_TD2_TT2(unit)) {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit,
                                        INTFO_E2ECC_POOL_STATE_REPORT_ENABLEr,
                                        REG_PORT_ANY, ENf, 1));
        } else if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit)) {
            SOC_IF_ERROR_RETURN(READ_THDO_INTEROP_CONFIGr(unit, &regval));
            if (soc_reg_field_get(unit, THDO_INTEROP_CONFIGr, regval,
                                  GLOBAL_CNG_STATE_REPORT_ENABLEf) == 0) {
                soc_reg_field_set(unit, THDO_INTEROP_CONFIGr, &regval,
                                  GLOBAL_CNG_STATE_REPORT_ENABLEf, 1);
                SOC_IF_ERROR_RETURN(WRITE_THDO_INTEROP_CONFIGr(unit, regval));
            }
        }

    } else {
        /* If BCM_PORT_CONGESTION_CONFIG_TX flag is not set, disable E2ECC transmission. */

        if (soc_reg_field_valid(unit, XPORT_CONFIGr, E2E_HOL_ENf)) {
            /* Clear per-port E2ECC TX enable bit */
            SOC_IF_ERROR_RETURN(READ_XPORT_CONFIGr(unit, port, &regval));
            if (soc_reg_field_get(unit, XPORT_CONFIGr, regval, E2E_HOL_ENf) == 1) {
                soc_reg_field_set(unit, XPORT_CONFIGr, &regval, E2E_HOL_ENf, 0);
                SOC_IF_ERROR_RETURN(WRITE_XPORT_CONFIGr(unit, port, regval));
            }
        }

        if (soc_reg_field_valid(unit, XPORT_MODE_REGr, E2E_HOL_ENf)) {
            /* Clear per-port E2ECC TX enable bit */
            SOC_IF_ERROR_RETURN(READ_XPORT_MODE_REGr(unit, port, &regval));
            if (soc_reg_field_get(unit, XPORT_MODE_REGr, regval, E2E_HOL_ENf) == 1) {
                soc_reg_field_set(unit, XPORT_MODE_REGr, &regval, E2E_HOL_ENf, 0);
                SOC_IF_ERROR_RETURN(WRITE_XPORT_MODE_REGr(unit, port, regval));
            }
        }

        /* Clear per-queue E2ECC enable bits */
        BCM_IF_ERROR_RETURN
            (_bcm_esw_port_drop_status_enable_set(unit, port, FALSE));

        /* Clear the bit corresponding to the given Higig port in the Higig port bitmap
         * used to transmit E2ECC messages
         */
        if (SOC_IS_SC_CQ(unit)) {
            SOC_IF_ERROR_RETURN(READ_E2E_HOL_PBMr(unit, &regval));
            hg_pbm = soc_reg_field_get(unit, E2E_HOL_PBMr, regval, PORT_BITMAPf);

            converted_hg_pbm = 1 << port;

            if (hg_pbm & converted_hg_pbm) {
                new_hg_pbm = hg_pbm & ~converted_hg_pbm;
                soc_reg_field_set(unit, E2E_HOL_PBMr, &regval, PORT_BITMAPf, new_hg_pbm);
                SOC_IF_ERROR_RETURN(WRITE_E2E_HOL_PBMr(unit, regval));
            }
        } else if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit) || SOC_IS_VALKYRIE2(unit)) {
            SOC_IF_ERROR_RETURN(READ_E2ECC_HOL_PBMr(unit, &regval));
            hg_pbm = soc_reg_field_get(unit, E2ECC_HOL_PBMr, regval, HG_PBMf);

            SOC_IF_ERROR_RETURN(_bcm_esw_port_e2ecc_hg_pbm_convert(port, &converted_hg_pbm));

            if (hg_pbm & converted_hg_pbm) {
                new_hg_pbm = hg_pbm & ~converted_hg_pbm;
                soc_reg_field_set(unit, E2ECC_HOL_PBMr, &regval, HG_PBMf, new_hg_pbm);
                SOC_IF_ERROR_RETURN(WRITE_E2ECC_HOL_PBMr(unit, regval));
            }
        } else if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) ||
                   SOC_IS_TRIUMPH3(unit) || SOC_IS_HURRICANE3(unit) ||
                   SOC_IS_GREYHOUND2(unit)) {
            if (soc_feature(unit, soc_feature_logical_port_num)) {
                blk = SOC_PORT_BLOCK(unit, SOC_INFO(unit).port_l2p_mapping[port]);
                bindex = SOC_PORT_BINDEX(unit, SOC_INFO(unit).port_l2p_mapping[port]);
            } else{
                blk = SOC_PORT_BLOCK(unit, port);
                bindex = SOC_PORT_BINDEX(unit, port);
            }
#if defined(BCM_APACHE_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)
           if (SOC_IS_TRIDENT2X(unit)) {
               blk_num = SOC_INFO(unit).port_serdes[port];
            } else
#endif
            {
              blk_num = SOC_BLOCK_INFO(unit, blk).number;
            }
            /* In TR3 E2ECC is implemented only in blocks CL, XL1 */
            if (!SOC_IS_TRIUMPH3(unit) || (IS_CL_PORT(unit, port) || (blk == 13))) {
                if (SOC_IS_TRIUMPH3(unit)) {
                    if (IS_CL_PORT(unit, port)) {
                        blk_num = (blk_num ?  4 + bindex/4 : bindex/4);
                        bindex = bindex%4;
                    } else {
                        blk_num = 3;
                    }
                }
#if defined(BCM_KATANA2_SUPPORT)
                if (SOC_IS_KATANA2(unit)) {
                    /* In KT2 E2ECC is implemented only in blocks 6..9 */
                    blk_num = (blk_num >= 6) ? (blk_num - 6) : blk_num ;
                    if (SOC_IS_SABER2(unit)) {
                        SOC_IF_ERROR_RETURN(_bcm_esw_port_e2e_tx_enable_set(unit, port, 0));
                    }
                }
#endif
                SOC_IF_ERROR_RETURN(READ_E2ECC_TX_ENABLE_BMPr(unit, blk_num,
                                                              &regval));
                if (regval & (1 << bindex)) {
                    new_hg_pbm = soc_reg_field_get(unit, E2ECC_TX_ENABLE_BMPr, regval,
                                                   TX_ENABLE_BMPf);
                    new_hg_pbm &= ~(1 << bindex);
                    soc_reg_field_set(unit, E2ECC_TX_ENABLE_BMPr, &regval,
                                      TX_ENABLE_BMPf, new_hg_pbm);
                    SOC_IF_ERROR_RETURN
                        (WRITE_E2ECC_TX_ENABLE_BMPr(unit, blk_num, regval));
                }
            }

            if (SOC_IS_TD2_TT2(unit) || SOC_IS_HURRICANE3(unit) ||
                SOC_IS_GREYHOUND2(unit)) {
                SOC_IF_ERROR_RETURN(_bcm_esw_port_e2e_tx_enable_set(unit, port, 0));
            }
        }

        /* Clear per-port registers holding the E2ECC message header */
        sal_memset(&e2ecc_hdr, 0, sizeof(soc_higig_e2ecc_hdr_t));
        BCM_IF_ERROR_RETURN(_bcm_esw_port_e2ecc_hdr_set(unit, port, &e2ecc_hdr));
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_port_e2ecc_rx
 * Purpose:
 *      Configure E2ECC message reception.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Local port number.
 *      config - (IN) Congestion configuration.
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_port_e2ecc_rx(int unit, bcm_port_t port,
                       bcm_port_congestion_config_t *config)
{
    uint32 regval;
    uint64 regval64;
    uint32 field_val;

    if (config->flags & BCM_PORT_CONGESTION_CONFIG_RX) {
        /* If BCM_PORT_CONGESTION_CONFIG_RX flag is set, enable E2ECC reception. */

        /* Make sure chip-wide E2ECC reception disable bit is cleared */
        SOC_IF_ERROR_RETURN(READ_ING_CONFIG_64r(unit, &regval64));
        if (soc_reg64_field32_get(unit, ING_CONFIG_64r, regval64,
                                  DISABLE_E2E_HOL_CHECKf) == 1) {
            soc_reg64_field32_set(unit, ING_CONFIG_64r, &regval64,
                                  DISABLE_E2E_HOL_CHECKf, 0);
            SOC_IF_ERROR_RETURN(WRITE_ING_CONFIG_64r(unit, regval64));
        }

        /* Set per-port E2ECC RX enable bit */
        SOC_IF_ERROR_RETURN(READ_IE2E_CONTROLr(unit, port, &regval));
        if (soc_reg_field_get(unit, IE2E_CONTROLr, regval,
                              HOL_ENABLEf) == 0) {
            soc_reg_field_set(unit, IE2E_CONTROLr, &regval, HOL_ENABLEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_IE2E_CONTROLr(unit, port, regval));
        }

        /* Configure E2ECC receive MAC-DA, Length/Type, and Opcode */

        field_val = (config->dest_mac[0] << 8) |    /* MAC-DA[47:40] */
                    (config->dest_mac[1]);          /* MAC-DA[39:32] */
        SOC_IF_ERROR_RETURN(READ_E2E_HOL_RX_DA_MSr(unit, &regval));
        soc_reg_field_set(unit, E2E_HOL_RX_DA_MSr, &regval, DAf, field_val);
        SOC_IF_ERROR_RETURN(WRITE_E2E_HOL_RX_DA_MSr(unit, regval));

        field_val = (config->dest_mac[2] << 24) |    /* MAC-DA[31:24] */
                    (config->dest_mac[3] << 16) |    /* MAC-DA[23:16] */
                    (config->dest_mac[4] << 8) |     /* MAC-DA[15:8] */
                    (config->dest_mac[5]);           /* MAC-DA[7:0] */
        SOC_IF_ERROR_RETURN(READ_E2E_HOL_RX_DA_LSr(unit, &regval));
        soc_reg_field_set(unit, E2E_HOL_RX_DA_LSr, &regval, DAf, field_val);
        SOC_IF_ERROR_RETURN(WRITE_E2E_HOL_RX_DA_LSr(unit, regval));

        SOC_IF_ERROR_RETURN(READ_E2E_HOL_RX_LENGTH_TYPEr(unit, &regval));
        soc_reg_field_set(unit, E2E_HOL_RX_LENGTH_TYPEr, &regval, LENGTH_TYPEf, config->ethertype);
        SOC_IF_ERROR_RETURN(WRITE_E2E_HOL_RX_LENGTH_TYPEr(unit, regval));

        SOC_IF_ERROR_RETURN(READ_E2E_HOL_RX_OPCODEr(unit, &regval));
        soc_reg_field_set(unit, E2E_HOL_RX_OPCODEr, &regval, OPCODEf, config->opcode);
        SOC_IF_ERROR_RETURN(WRITE_E2E_HOL_RX_OPCODEr(unit, regval));

    } else {
        /* If BCM_PORT_CONGESTION_CONFIG_RX flag is not set, disable E2ECC reception. */

        /* Clear per-port E2ECC RX enable bit */
        SOC_IF_ERROR_RETURN(READ_IE2E_CONTROLr(unit, port, &regval));
        if (soc_reg_field_get(unit, IE2E_CONTROLr, regval, HOL_ENABLEf) == 1) {
            soc_reg_field_set(unit, IE2E_CONTROLr, &regval, HOL_ENABLEf, 0);
            SOC_IF_ERROR_RETURN(WRITE_IE2E_CONTROLr(unit, port, regval));
        }
    }

    return BCM_E_NONE;
}

STATIC int
_bcm_tr3_port_hcfc(int unit, bcm_port_t port,
                   bcm_port_congestion_config_t *config)
{
#if defined(BCM_TRIUMPH3_SUPPORT)
    soc_reg_t reg;
    int enable;
    uint32 rval;
    uint64 rval64, fval64, tmp;

    enable = config->flags & BCM_PORT_CONGESTION_CONFIG_TX ? 1 : 0;
    BCM_IF_ERROR_RETURN
        (_bcm_esw_port_drop_status_enable_set(unit, port, enable));

    /* Configure egress status reporting */
    reg = OOBFC_ENG_PORT_EN_64r;
    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, REG_PORT_ANY, 0, &rval64));
    fval64 = soc_reg64_field_get(unit, reg, rval64, ENG_PORT_ENf);
    COMPILER_64_SET(tmp, 0, 1);
    COMPILER_64_SHL(tmp, port);
    COMPILER_64_AND(fval64, tmp);
    SOC_IF_ERROR_RETURN(soc_reg_set(unit, reg, REG_PORT_ANY, 0, rval64));

    SOC_IF_ERROR_RETURN(READ_OOBFC_GCSr(unit, &rval));
    soc_reg_field_set(unit, OOBFC_GCSr, &rval, GCS_ENf, 0);
    SOC_IF_ERROR_RETURN(WRITE_OOBFC_GCSr(unit, rval));

    return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
}


/*
 * Function:
 *      _bcm_esw_port_hcfc_tx
 * Purpose:
 *      configure the port hcfc egress status to enable
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port number
 *      config - (IN) Configuration
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
STATIC int
_bcm_esw_port_hcfc_tx(int unit, bcm_port_t port,
                   bcm_port_congestion_config_t *config)
{
    soc_reg_t reg, reg0, reg1;
    int enable, len;
    uint64 rval64, fval64;
    uint32 fval_hi, fval_lo;

    if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }

    if (SOC_REG_IS_VALID(unit, OOBFC_ENG_PORT_EN0_64r)) {
        reg0 = OOBFC_ENG_PORT_EN0_64r;
        reg1 = OOBFC_ENG_PORT_EN1_64r;
    } else {
        reg0 = OOBFC_ENG_PORT_EN_0_64r;
        reg1 = OOBFC_ENG_PORT_EN_1_64r;
    }
    if (!(SOC_REG_IS_VALID(unit, reg0)) || !(SOC_REG_IS_VALID(unit, reg1))) {
        return BCM_E_PORT;
    }

    /* Configure egress status reporting */
    len = soc_reg_field_length(unit, reg0, ENG_PORT_ENf);
    if (len < 1) {
        return BCM_E_PORT;
    }
    if (port < len) { /* First half of logical ports (not mmu port) */
        reg = reg0;
    } else {          /* Second half of logical ports (not mmu port) */
        reg = reg1;
    }
    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, REG_PORT_ANY, 0, &rval64));
    fval64 = soc_reg64_field_get(unit, reg, rval64, ENG_PORT_ENf);
    fval_hi = COMPILER_64_HI(fval64);
    fval_lo = COMPILER_64_LO(fval64);
    enable = config->flags & BCM_PORT_CONGESTION_CONFIG_TX ? 1 : 0;
    if (enable) {
        if (port < len) {
            if (port < 32) {
                fval_lo |= (1 << port);
            } else {
                /* coverity[large_shift : FALSE] */
                fval_hi |= (1 << (port - 32));
            }
        } else {
            int port_offset = port - len;
            if ( port_offset < 32 ) {
                fval_lo |= (1 << port_offset);
            } else {
                fval_hi |= (1 << (port_offset - 32));
            }
        }
    } else {
        if (port < len) {
            if (port < 32) {
                fval_lo &= ~(1 << port);
            } else {
                /* coverity[large_shift : FALSE] */
                fval_hi &= ~(1 << (port - 32));
            }
        } else {
            int port_offset = port - len;
            if ( port_offset < 32 ) {
                fval_lo &= ~(1 << port_offset);
            } else {
                fval_hi &= ~(1 << (port_offset - 32));
            }
        }
    }
    COMPILER_64_SET(fval64, fval_hi, fval_lo);
    soc_reg64_field_set(unit, reg, &rval64, ENG_PORT_ENf, fval64);
    SOC_IF_ERROR_RETURN(soc_reg_set(unit, reg, REG_PORT_ANY, 0, rval64));

    return BCM_E_NONE;
}

/*
 * Function:
 *      _bcm_esw_port_hcfc_rx
 * Purpose:
 *      configure the port hcfc ingress status to enable
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port number
 *      config - (IN) Configuration
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
STATIC int
_bcm_esw_port_hcfc_rx(int unit, bcm_port_t port,
                   bcm_port_congestion_config_t *config)
{
    soc_reg_t reg, reg0, reg1;
    int enable, len;
    uint64 rval64, fval64;
    uint32 fval_hi, fval_lo;

    if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }

    if (SOC_REG_IS_VALID(unit, OOBFC_ING_PORT_EN0_64r)) {
        reg0 = OOBFC_ING_PORT_EN0_64r;
        reg1 = OOBFC_ING_PORT_EN1_64r;
    } else {
        reg0 = OOBFC_ING_PORT_EN_0_64r;
        reg1 = OOBFC_ING_PORT_EN_1_64r;
    }
    if (!(SOC_REG_IS_VALID(unit, reg0)) || !(SOC_REG_IS_VALID(unit, reg1))) {
        return BCM_E_PORT;
    }

    /* Configure ingress status reporting */
    len = soc_reg_field_length(unit, reg0, ING_PORT_ENf);
    if (len < 1) {
        return BCM_E_PORT;
    }
    if (port < len) { /* First half of logical ports (not mmu port) */
        reg = reg0;
    } else {          /* Second half of logical ports (not mmu port) */
        reg = reg1;
    }
    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, REG_PORT_ANY, 0, &rval64));
    fval64 = soc_reg64_field_get(unit, reg, rval64, ING_PORT_ENf);
    fval_hi = COMPILER_64_HI(fval64);
    fval_lo = COMPILER_64_LO(fval64);

    enable = config->flags & BCM_PORT_CONGESTION_CONFIG_RX ? 1 : 0;
    if (enable) {
        if (port < len) {
            if (port < 32) {
                fval_lo |= (1 << port);
            } else {
                /* coverity[large_shift : FALSE] */
                fval_hi |= (1 << (port - 32));
            }
        } else {
            int port_offset = port - len;
            if ( port_offset < 32 ) {
                fval_lo |= (1 << port_offset);
            } else {
                fval_hi |= (1 << (port_offset - 32));
            }
        }
    } else {
        if (port < len) {
            if (port < 32) {
                fval_lo &= ~(1 << port);
            } else {
                /* coverity[large_shift : FALSE] */
                fval_hi &= ~(1 << (port - 32));
            }
        } else {
            int port_offset = port - len;
            if ( port_offset < 32 ) {
                fval_lo &= ~(1 << port_offset);
            } else {
                fval_hi &= ~(1 << (port_offset - 32));
            }
        }
    }
    COMPILER_64_SET(fval64, fval_hi, fval_lo);
    soc_reg64_field_set(unit, reg, &rval64, ING_PORT_ENf, fval64);
    SOC_IF_ERROR_RETURN(soc_reg_set(unit, reg, REG_PORT_ANY, 0, rval64));

    return BCM_E_NONE;
}


STATIC int
_bcm_esw_port_hcfc(int unit, bcm_port_t port,
                   bcm_port_congestion_config_t *config)
{
    int enable;
    uint32 rval;

    enable = config->flags & BCM_PORT_CONGESTION_CONFIG_TX ? 1 : 0;
    BCM_IF_ERROR_RETURN
        (_bcm_esw_port_drop_status_enable_set(unit, port, enable));

    BCM_IF_ERROR_RETURN(_bcm_esw_port_hcfc_tx(unit, port, config));

    BCM_IF_ERROR_RETURN(_bcm_esw_port_hcfc_rx(unit, port, config));

    SOC_IF_ERROR_RETURN(READ_OOBFC_GCSr(unit, &rval));
    soc_reg_field_set(unit, OOBFC_GCSr, &rval, GCS_ENf, 0);
    SOC_IF_ERROR_RETURN(WRITE_OOBFC_GCSr(unit, rval));

    return BCM_E_NONE;
}

#ifdef BCM_KATANA2_SUPPORT
STATIC int
_bcm_esw_port_coe_e2ecc(int unit, bcm_port_t port,
                       bcm_port_congestion_config_t *config)
{

    uint32 regval = 0;
    int en;
    int e2ecc_strict = -1;
    uint32 field_val;
    int index;
    mmu_intfi_st_trans_tbl_entry_t st_trans_entry;
    uint16      dev_id;
    uint8       rev_id;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    en = config->flags & BCM_PORT_CONGESTION_CONFIG_RX ? 1 : 0;

    if ((config->flags &
         BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_FLEX_MODE)) {
        e2ecc_strict = 0;
    } else if (config->flags &
               BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_STRICT_MODE) {
        e2ecc_strict = 1;
    } else {
        return BCM_E_PARAM;
    }
    if ((rev_id == BCM56450_A0_REV_ID) && (!SOC_IS_SABER2(unit))) {
       if (e2ecc_strict) {
           /* E2ECC STRICT mode only valid for BCM56450_B0 onwards
            */
           return BCM_E_UNAVAIL;
       }
    } else if ((rev_id >= BCM56450_B0_REV_ID) || SOC_IS_SABER2(unit)) {
        /* setting of strict/flex mode is valid only when flow control is
         * enabled
         */
        e2ecc_strict = (en ? e2ecc_strict : 0);
        SOC_IF_ERROR_RETURN(
                   READ_COE_FLOW_CONTROL_CONFIGr (unit, port, &regval));
        /* Enable the Flow control and E2ECC mode
         * 1. When there is enable request
         * 2. When flow control is already enabled
         *    and there is change in E2ECC_mode from
         *    strict to flex or vice versa
         */
        if ((en != soc_reg_field_get(unit, COE_FLOW_CONTROL_CONFIGr,
                  regval, FLOW_CONTROL_FORMATf)) ||
              (en && (soc_reg_field_get(unit, COE_FLOW_CONTROL_CONFIGr,
                  regval, FLOW_CONTROL_FORMATf) == 1) &&
               (e2ecc_strict != soc_reg_field_get(unit, COE_FLOW_CONTROL_CONFIGr,
               regval, E2ECC_MODEf)))) {
            soc_reg_field_set(unit, COE_FLOW_CONTROL_CONFIGr, &regval,
                        FLOW_CONTROL_FORMATf, en);
            soc_reg_field_set(unit, COE_FLOW_CONTROL_CONFIGr, &regval,
                        E2ECC_MODEf, e2ecc_strict);
            SOC_IF_ERROR_RETURN(
              WRITE_COE_FLOW_CONTROL_CONFIGr (unit, port, regval));
        }
    }

    if (en) {
        /* Configure E2ECC-FC receive MAC-DA, Length/Type, and Opcode */
        field_val = (config->dest_mac[0] << 8) |    /* MAC-DA[47:40] */
                    (config->dest_mac[1]);          /* MAC-DA[39:32] */
        SOC_IF_ERROR_RETURN(READ_ING_VOQFC_MACDA_MSr(unit, &regval));
        soc_reg_field_set(unit, ING_VOQFC_MACDA_MSr, &regval, DAf, field_val);
        SOC_IF_ERROR_RETURN(WRITE_ING_VOQFC_MACDA_MSr(unit, regval));

        field_val = (config->dest_mac[2] << 24) |    /* MAC-DA[31:24] */
                    (config->dest_mac[3] << 16) |    /* MAC-DA[23:16] */
                    (config->dest_mac[4] << 8) |     /* MAC-DA[15:8] */
                    (config->dest_mac[5]);           /* MAC-DA[7:0] */

        SOC_IF_ERROR_RETURN(READ_ING_VOQFC_MACDA_LSr(unit, &regval));
        soc_reg_field_set(unit, ING_VOQFC_MACDA_LSr, &regval, DAf, field_val);
        SOC_IF_ERROR_RETURN(WRITE_ING_VOQFC_MACDA_LSr(unit, regval));


        SOC_IF_ERROR_RETURN(READ_ING_VOQFC_IDr(unit, &regval));
        soc_reg_field_set(unit, ING_VOQFC_IDr, &regval,
                          LENGTH_TYPEf, config->ethertype);

        soc_reg_field_set(unit, ING_VOQFC_IDr, &regval,
                           OPCODEf, config->opcode);
        SOC_IF_ERROR_RETURN(WRITE_ING_VOQFC_IDr(unit, regval));

        /*
         * Hardcoding the MMU_INTFI_ST_TRANS_TBL so the
         * congestion data is written as it is
         * in FC_ST_TABLE
         */

        for (index=0 ; index < soc_mem_index_count(unit,
                    MMU_INTFI_ST_TRANS_TBLm); index++) {
            SOC_IF_ERROR_RETURN(READ_MMU_INTFI_ST_TRANS_TBLm(
                        unit, MEM_BLOCK_ALL,index,
                        &st_trans_entry));
            soc_mem_field32_set(unit, MMU_INTFI_ST_TRANS_TBLm,
                    &st_trans_entry, FC_ST_XLATEf,index%256);
            SOC_IF_ERROR_RETURN(WRITE_MMU_INTFI_ST_TRANS_TBLm(
                        unit, MEM_BLOCK_ALL, index,
                        &st_trans_entry));
        }

        /*
         * Hardcoding FC_WIDTH to 3 so that 8 bits are read at time
         */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_CFGr, REG_PORT_ANY,
                                    FC_WIDTHf, 3));
        /*
         * In case of COE E2ECC merger block should be disabled
         */

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_CFGr, REG_PORT_ANY,
                                    MERGE_ENf, 0));
        /*
         * Hardcode the INTFI_MAP_L0/L1/L2_TBL_ADDR,
         * so that state machine reads
         * all the L1,L2,L3 Nodes in a cycle
         */


        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L2_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_ADDR_ENf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L2_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_START_ADDRf, 0));
        if (SOC_IS_SABER2(unit)) {
    #ifdef BCM_METROLITE_SUPPORT
            if (SOC_IS_METROLITE(unit))  {
                SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, INTFI_MAP_L2_TBL_ADDRr, REG_PORT_ANY,
                                        FC_MAP_TBL_END_ADDRf, 0x1f));
            } else
    #endif
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, INTFI_MAP_L2_TBL_ADDRr, REG_PORT_ANY,
                                       FC_MAP_TBL_END_ADDRf, 0x3f));
        } else {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, INTFI_MAP_L2_TBL_ADDRr, REG_PORT_ANY,
                                       FC_MAP_TBL_END_ADDRf, 0xff));
        }
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L1_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_ADDR_ENf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L1_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_START_ADDRf, 0));
        if (SOC_IS_SABER2(unit)) {
    #ifdef BCM_METROLITE_SUPPORT
            if (SOC_IS_METROLITE(unit))  {
                SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, INTFI_MAP_L1_TBL_ADDRr, REG_PORT_ANY,
                                        FC_MAP_TBL_END_ADDRf, 0x7));
            } else
    #endif
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, INTFI_MAP_L1_TBL_ADDRr, REG_PORT_ANY,
                                        FC_MAP_TBL_END_ADDRf, 0xf));
        } else {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, INTFI_MAP_L1_TBL_ADDRr, REG_PORT_ANY,
                                        FC_MAP_TBL_END_ADDRf, 0x3f));
        }
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L0_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_ADDR_ENf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L0_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_START_ADDRf, 0));
        if (SOC_IS_SABER2(unit)) {
    #ifdef BCM_METROLITE_SUPPORT
            if (SOC_IS_METROLITE(unit))  {
                SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, INTFI_MAP_L0_TBL_ADDRr, REG_PORT_ANY,
                                        FC_MAP_TBL_END_ADDRf, 0x3));
            } else
    #endif
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, INTFI_MAP_L0_TBL_ADDRr, REG_PORT_ANY,
                                        FC_MAP_TBL_END_ADDRf, 0x7));
        } else {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, INTFI_MAP_L0_TBL_ADDRr, REG_PORT_ANY,
                                        FC_MAP_TBL_END_ADDRf, 0x1f));
        }

        if (e2ecc_strict == 0) {
            SOC_IF_ERROR_RETURN(READ_IE2E_CONTROLr(unit, port, &regval));
            if (en != soc_reg_field_get(unit, IE2E_CONTROLr, regval,
                                VOQFC_ENABLEf)) {
                soc_reg_field_set(unit, IE2E_CONTROLr, &regval,
                                  VOQFC_ENABLEf, en);
                SOC_IF_ERROR_RETURN(WRITE_IE2E_CONTROLr(unit, port, regval));
            }
        } else {
            SOC_IF_ERROR_RETURN(READ_IE2E_CONTROLr(unit, port, &regval));
            if (soc_reg_field_get(unit, IE2E_CONTROLr, regval,
                                VOQFC_ENABLEf)) {
                soc_reg_field_set(unit, IE2E_CONTROLr, &regval,
                                  VOQFC_ENABLEf, 0);
                SOC_IF_ERROR_RETURN(WRITE_IE2E_CONTROLr(unit, port, regval));
            }
        }
    } else {
        if (e2ecc_strict == 0) {
            SOC_IF_ERROR_RETURN(READ_IE2E_CONTROLr(unit, port, &regval));
            if (soc_reg_field_get(unit, IE2E_CONTROLr, regval,
                                VOQFC_ENABLEf)) {
                soc_reg_field_set(unit, IE2E_CONTROLr, &regval,
                                  VOQFC_ENABLEf, 0);
                SOC_IF_ERROR_RETURN(WRITE_IE2E_CONTROLr(unit, port, regval));
            }
        }
    }

    return BCM_E_NONE;
}
#endif

/*
 * Function:
 *      _bcm_esw_port_dmvoqfc_rx
 * Purpose:
 *      Configure VOQFC message reception.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Local port number.
 *      config - (IN) Congestion configuration.
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_port_dmvoqfc_rx(int unit, bcm_port_t port,
                       bcm_port_congestion_config_t *config)
{
    uint32 regval;
    uint32 field_val;
    int     en, cos_mode;
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_KATANA2_SUPPORT) || \
    defined(BCM_TRIUMPH3_SUPPORT)
    int index;
#endif
#if defined(BCM_TRIDENT2_SUPPORT)
    uint64 rval;
#endif
#if defined(BCM_TRIUMPH3_SUPPORT)
    uint32 rval1;
    mmu_intfi_st_trans_tbl_entry_t st_trans_entry;
#endif

    en = config->flags & BCM_PORT_CONGESTION_CONFIG_RX ? 1 : 0;
    cos_mode = config->flags & BCM_PORT_CONGESTION_CONFIG_RX ? 1 : 0;
    SOC_IF_ERROR_RETURN(READ_IE2E_CONTROLr(unit, port, &regval));
    if (en != soc_reg_field_get(unit, IE2E_CONTROLr, regval,
                                VOQFC_ENABLEf)) {
        soc_reg_field_set(unit, IE2E_CONTROLr, &regval, VOQFC_ENABLEf, en);
        SOC_IF_ERROR_RETURN(WRITE_IE2E_CONTROLr(unit, port, regval));
    }
#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        SOC_IF_ERROR_RETURN(READ_ING_COS_MODE_64r(unit, port, &rval));
        if (cos_mode != soc_reg64_field32_get(unit, ING_COS_MODE_64r, rval,
                    QUEUE_MODEf)) {
            soc_reg64_field32_set(unit, ING_COS_MODE_64r, &rval, QUEUE_MODEf, cos_mode);
            SOC_IF_ERROR_RETURN(WRITE_ING_COS_MODE_64r(unit, port, rval));
        }
        /*
         *  FC_WIDTH is set to 2 so that 4 bits of i
         * congestion data is read on each cycle
         */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_CFGr, REG_PORT_ANY,
                                    FC_WIDTHf, 2));
        /*
         * MERGE_EN is set to 1, to merge the congestion state
         * received from different ports of the same module
         */

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_CFGr, REG_PORT_ANY,
                                    MERGE_ENf, 1));
        /* MODE_SEL is set to 1 to specify the message is of type
         *  DMVOQ
         */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_CFGr, REG_PORT_ANY,
                                    MODE_SELf, 1));
#ifdef BCM_APACHE_SUPPORT
        if (SOC_IS_APACHE(unit)) {
            if (config->flags & BCM_PORT_CONGESTION_CONFIG_DESTMODPORT_FLOW_CONTROL) {
                /*
                * MERGE_EN is set to 0, in case of DPVOQ.
                */

                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, INTFI_CFGr, REG_PORT_ANY,
                                            MERGE_ENf, 0));
                /* MODE_SEL is set to 0 to specify the message is of type
                *  DPVOQ
                */
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, INTFI_CFGr, REG_PORT_ANY,
                                            MODE_SELf, 0));
            }
        }
#endif
        /* DMVOQ congestion bytes max length is 64 bytes,
         * as a result
         * DMVOQ feature can support upto 64 ports
         */

        for (index = 0 ; index < SOC_REG_NUMELS(unit, CONGESTION_STATE_BYTESr)
                ; index++) {
            soc_reg_field_set(unit, CONGESTION_STATE_BYTESr, &regval,
                    DATAf, BCM_MAX_PORTS_SUPPORT_FOR_DMVOQ);
            SOC_IF_ERROR_RETURN(WRITE_CONGESTION_STATE_BYTESr(unit,
                        index, regval));
        }

    } else
#endif
#ifdef BCM_KATANA2_SUPPORT
     if (SOC_IS_KATANA2(unit)) {
        SOC_IF_ERROR_RETURN(READ_ING_COS_MODEr(unit, port, &regval));
        if (cos_mode != soc_reg_field_get(unit, ING_COS_MODEr, regval,
                    COS_MODEf)) {
            soc_reg_field_set(unit, ING_COS_MODEr, &regval, COS_MODEf, cos_mode);
            SOC_IF_ERROR_RETURN(WRITE_ING_COS_MODEr(unit, port, regval));
        }

        /*
         * Hardcoding FC_WIDTH to 3 so that 8 bits are read at time
         */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_CFGr, REG_PORT_ANY,
                                    FC_WIDTHf, 3));
        if (config->flags & BCM_PORT_CONGESTION_CONFIG_DESTMOD_FLOW_CONTROL) {
        /*
         * In case of DMVOQ we need to merge all the congestion bytes
         * of the ports so enabling MERGE_EN
         */

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_CFGr, REG_PORT_ANY,
                                    MERGE_ENf, 1));
        }
        /*
         * Hardcode the INTFI_MAP_L0/L1/L2_TBL_ADDR,
         * so that state machine reads
         * all the L1,L2,L3 Nodes in a cycle
         */

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L2_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_ADDR_ENf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L2_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_START_ADDRf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L2_TBL_ADDRr, REG_PORT_ANY,
                                   FC_MAP_TBL_END_ADDRf,
                                   ((soc_mem_index_count(unit, LLS_L2_PARENTm)) / 16) - 1));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L1_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_ADDR_ENf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L1_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_START_ADDRf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L1_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_END_ADDRf,
                                   ((soc_mem_index_count(unit, LLS_L1_PARENTm)) / 16) - 1 ));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L0_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_ADDR_ENf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L0_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_START_ADDRf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_MAP_L0_TBL_ADDRr, REG_PORT_ANY,
                                    FC_MAP_TBL_END_ADDRf,
                                   ((soc_mem_index_count(unit, LLS_L0_PARENTm)) /
                                    (SOC_IS_METROLITE(unit) ? 32: 16)) - 1));

        /* Though the number of ports supported in KT2 is 41, we're setting the
           max to 64 to support stacked systems. */
        for (index = 0 ; index < SOC_REG_NUMELS(unit, CONGESTION_STATE_BYTESr)
                ; index++) {
            soc_reg_field_set(unit, CONGESTION_STATE_BYTESr, &regval,
                    DATAf, BCM_MAX_PORTS_SUPPORT_FOR_DMVOQ);
            SOC_IF_ERROR_RETURN(WRITE_CONGESTION_STATE_BYTESr(unit,
                        index, regval));
        }

    } else
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        SOC_IF_ERROR_RETURN(READ_ING_COS_MODEr(unit, port, &rval1));
        if (cos_mode != soc_reg_field_get(unit, ING_COS_MODEr, rval1,
                    QUEUE_MODEf)) {
            soc_reg_field_set(unit, ING_COS_MODEr, &rval1, QUEUE_MODEf, cos_mode);
            SOC_IF_ERROR_RETURN(WRITE_ING_COS_MODEr(unit, port, rval1));
        }
        /*
         * Hardcoding the MMU_INTFI_ST_TRANS_TBL so the
         * congestion data is written as it is
         * in FC_ST_TABLE, This we are doing so that
         * congestion data is updated as it is how
         * it recevied
         */

        for (index=0 ; index < soc_mem_index_count(unit,
                    MMU_INTFI_ST_TRANS_TBLm); index++) {
            SOC_IF_ERROR_RETURN(READ_MMU_INTFI_ST_TRANS_TBLm(
                        unit, MEM_BLOCK_ALL,index,
                        &st_trans_entry));
            soc_mem_field32_set(unit, MMU_INTFI_ST_TRANS_TBLm,
                    &st_trans_entry, FC_ST_XLATEf,index%16);
            SOC_IF_ERROR_RETURN(WRITE_MMU_INTFI_ST_TRANS_TBLm(
                        unit, MEM_BLOCK_ALL, index,
                        &st_trans_entry));
        }
        /*
         *  FC_WIDTH is set to 2 so that 4 bits of i
         * congestion data is read on each cycle
         */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_CFGr, REG_PORT_ANY,
                                    FC_WIDTHf, 2));
        /*
         * MERGE_EN is set to 1, to merge the congestion state
         * received from different ports of the same module
         */

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_CFGr, REG_PORT_ANY,
                                    MERGE_ENf, 1));
        /* DMVOQ congestion bytes max length is 64 bytes,
         * as a result
         * DMVOQ feature can support upto 64 ports
         */

        for (index = 0; index < SOC_REG_NUMELS(unit, CONGESTION_STATE_BYTESr)
                ; index++) {
            soc_reg_field_set(unit, CONGESTION_STATE_BYTESr, &regval,
                    DATAf, BCM_MAX_PORTS_SUPPORT_FOR_DMVOQ);
            SOC_IF_ERROR_RETURN(WRITE_CONGESTION_STATE_BYTESr(unit,
                        index, regval));
        }

    } else
#endif
    {
        SOC_IF_ERROR_RETURN(READ_ING_COS_MODEr(unit, port, &regval));
        if (cos_mode != soc_reg_field_get(unit, ING_COS_MODEr, regval,
                    QUEUE_MODEf)) {
            soc_reg_field_set(unit, ING_COS_MODEr, &regval, QUEUE_MODEf, cos_mode);
            SOC_IF_ERROR_RETURN(WRITE_ING_COS_MODEr(unit, port, regval));
        }
    }

    if (en) {
        /* Configure DMVOQFC receive MAC-DA, Length/Type, and Opcode */
        field_val = (config->dest_mac[0] << 8) |    /* MAC-DA[47:40] */
                    (config->dest_mac[1]);          /* MAC-DA[39:32] */
        SOC_IF_ERROR_RETURN(READ_ING_VOQFC_MACDA_MSr(unit, &regval));
        soc_reg_field_set(unit, ING_VOQFC_MACDA_MSr, &regval, DAf, field_val);
        SOC_IF_ERROR_RETURN(WRITE_ING_VOQFC_MACDA_MSr(unit, regval));

        field_val = (config->dest_mac[2] << 24) |    /* MAC-DA[31:24] */
                    (config->dest_mac[3] << 16) |    /* MAC-DA[23:16] */
                    (config->dest_mac[4] << 8) |     /* MAC-DA[15:8] */
                    (config->dest_mac[5]);           /* MAC-DA[7:0] */

        SOC_IF_ERROR_RETURN(READ_ING_VOQFC_MACDA_LSr(unit, &regval));
        soc_reg_field_set(unit, ING_VOQFC_MACDA_LSr, &regval, DAf, field_val);
        SOC_IF_ERROR_RETURN(WRITE_ING_VOQFC_MACDA_LSr(unit, regval));


        SOC_IF_ERROR_RETURN(READ_ING_VOQFC_IDr(unit, &regval));
        soc_reg_field_set(unit, ING_VOQFC_IDr, &regval,
                          LENGTH_TYPEf, config->ethertype);

        soc_reg_field_set(unit, ING_VOQFC_IDr, &regval, OPCODEf, config->opcode);
        SOC_IF_ERROR_RETURN(WRITE_ING_VOQFC_IDr(unit, regval));
    }

    return BCM_E_NONE;
}
/*
 * Function:
 *      _bcm_esw_port_dmvoqfc_tx
 * Purpose:
 *      Configure VOQFC message reception.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Local port number.
 *      config - (IN) Congestion configuration.
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_port_dmvoqfc_tx(int unit, bcm_port_t port,
                       bcm_port_congestion_config_t *config)
{
    /*
     * Trident/Titan VOQFC message generation is same as E2ECC, except for
     * ethertype and opcode.
     */
    if (SOC_IS_TD_TT(unit) || SOC_IS_KATANA2(unit)
            || SOC_IS_TD2_TT2(unit) || SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_e2ecc_tx(unit, port, config));
        return BCM_E_NONE;
    }

    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_port_congestion_config_set
 * Purpose:
 *      Set end-to-end congestion control.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Gport number.
 *      config - (IN) Structure containing the congestion configuration.
 * Returns:
 *      BCM_E_xxx
 */
int
bcm_esw_port_congestion_config_set(int unit, bcm_gport_t port,
                                   bcm_port_congestion_config_t *config)
{
    bcm_port_t local_port;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (soc_feature(unit, soc_feature_e2ecc)) {
        /* Check for parameters */

        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &local_port));

        if (!IS_HG_PORT(unit, local_port)) {
            if(SOC_IS_KATANA2(unit) || SOC_IS_TRIDENT2PLUS(unit) ||
                SOC_IS_APACHE(unit) ) {
               if ((config->flags &
                    BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_STRICT_MODE) ||
                    (config->flags &
                    BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_FLEX_MODE) ||
                    (config->flags &
                     BCM_PORT_CONGESTION_CONFIG_VLAN_PAUSE_COE))
                         {
                    if (!IS_SUBTAG_PORT(unit, local_port)) {
                        LOG_ERROR(BSL_LS_BCM_PORT,
                                  (BSL_META_U(unit,
                                "E2ECC COE is applicable on subports only."
                                "Port %d is not a subport.\n"),
                                local_port));
                        return BCM_E_PORT;
                    }
                } else if ((config->flags &
                            BCM_PORT_CONGESTION_CONFIG_TX) &&
                           (config->flags &
                           BCM_PORT_CONGESTION_CONFIG_DESTMOD_FLOW_CONTROL)) {
                    if ((IS_GE_PORT(unit, local_port)) ||
                        (IS_XE_PORT(unit, local_port)))  {
                        /* Set per-queue E2ECC enable bits */
                        BCM_IF_ERROR_RETURN
                            (_bcm_esw_port_drop_status_enable_set(unit,
                                                       port, TRUE));
                        /* Make sure port module is initialized. */
                        PORT_INIT(unit);

                        /* Lock is needed to modify bcm_port_info */
                        PORT_LOCK(unit);

                        /* Allocate per-port congestion configuration state on demand */
                        if (PORT(unit, local_port).e2ecc_config == NULL) {
                            PORT(unit, local_port).e2ecc_config = sal_alloc(sizeof(bcm_port_congestion_config_t),
                                    "bcm_port_congestion_config");
                            if (PORT(unit, local_port).e2ecc_config == NULL) {
                                LOG_ERROR(BSL_LS_BCM_PORT,
                                        (BSL_META_U(unit,
                                                    "Error: unable to allocate memory for bcm_port_congestion_config.\n")));
                                PORT_UNLOCK(unit);
                                return BCM_E_MEMORY;
                            }
                        }

                        /* Store E2ECC configuration */
                        *(PORT(unit, local_port).e2ecc_config) = *(config);

                        PORT_UNLOCK(unit);
                        return BCM_E_NONE;
                    }
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                               "Applicable on Ge/Xe only "
                               "for enabling dmvoq transmitting only.\n ")));
                    return BCM_E_PARAM;
                } else {
                    if (((SOC_IS_TRIDENT2PLUS(unit)) || SOC_IS_APACHE(unit)) &&
                          (config->flags & BCM_PORT_CONGESTION_CONFIG_HCFC)) {
                        LOG_ERROR(BSL_LS_BCM_PORT,
                             (BSL_META_U(unit,
                          "Error: unit %d port %d is not a Higig port. "
                          "E2ECC messages can only be transmitted to "
                          "or received from Higig ports.\n"),
                          unit, local_port));
                        return BCM_E_PARAM;
                    }
                }
            } else {
#ifdef BCM_FIRELIGHT_SUPPORT
                if (SOC_IS_FIRELIGHT(unit) &&
                    (IS_XL_PORT(unit, local_port) || IS_CL_PORT(unit, local_port)) ) {
                    LOG_DEBUG(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                      "unit %d port %d is not a Higig port. "
                      "E2ECC messages can be transmitted to "
                      "Higig/ethernet(XL/CL) ports.\n"), unit, local_port));
                } else
#endif /* BCM_FIRELIGHT_SUPPORT */
                {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                      "Error: unit %d port %d is not a Higig port. "
                      "E2ECC messages can only be transmitted to or received from "
                      "Higig ports.\n"), unit, local_port));
                    return BCM_E_PARAM;
                }
            }
        }

        if (config == NULL) {
            return BCM_E_PARAM;
        }

        if (!((config->flags & BCM_PORT_CONGESTION_CONFIG_E2ECC) ||
            (config->flags & BCM_PORT_CONGESTION_CONFIG_HCFC) ||
            (config->flags & BCM_PORT_CONGESTION_CONFIG_DESTMOD_FLOW_CONTROL) ||
            (config->flags & BCM_PORT_CONGESTION_CONFIG_DESTMODPORT_FLOW_CONTROL) ||
            (config->flags & BCM_PORT_CONGESTION_CONFIG_MAX_SPLIT4) ||
            (config->flags & BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_STRICT_MODE) ||
            (config->flags & BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_FLEX_MODE)   ||
            (config->flags & BCM_PORT_CONGESTION_CONFIG_VLAN_PAUSE_COE))) {
            return BCM_E_PARAM;
        }

        if (config->packets_per_sec < 0) {
            return BCM_E_PARAM;
        }

        switch (config->flags &
                (BCM_PORT_CONGESTION_CONFIG_E2ECC |
                 BCM_PORT_CONGESTION_CONFIG_HCFC |
                 BCM_PORT_CONGESTION_CONFIG_DESTMOD_FLOW_CONTROL |
                 BCM_PORT_CONGESTION_CONFIG_DESTMODPORT_FLOW_CONTROL |
                 BCM_PORT_CONGESTION_CONFIG_MAX_SPLIT4 |
                 BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_STRICT_MODE |
                 BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_FLEX_MODE   |
                 BCM_PORT_CONGESTION_CONFIG_VLAN_PAUSE_COE)) {
        case BCM_PORT_CONGESTION_CONFIG_E2ECC:
        case BCM_PORT_CONGESTION_CONFIG_MAX_SPLIT4:
            /* Handle E2ECC message transmission */
            BCM_IF_ERROR_RETURN
                (_bcm_esw_port_e2ecc_tx(unit, local_port, config));

            /* Handle E2ECC message reception */
            BCM_IF_ERROR_RETURN
                (_bcm_esw_port_e2ecc_rx(unit, local_port, config));
            break;

        case BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_STRICT_MODE:
        case BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_FLEX_MODE:
        case BCM_PORT_CONGESTION_CONFIG_VLAN_PAUSE_COE:
             /* COE flow control using E2ECC messages
              * KT2 supports E2E-CC message reception on
              * COE ports.
              */
#ifdef BCM_KATANA2_SUPPORT
             if (SOC_IS_KATANA2(unit)) {
                 BCM_IF_ERROR_RETURN
                         (_bcm_esw_port_coe_e2ecc(unit, local_port, config));

             }
#endif

             

             /* COE flow control using E2ECC messages
              * TD2+ supports E2E-CC message reception on
              * COE ports, only in STRICT mode.
              */
#ifdef BCM_TRIDENT2PLUS_SUPPORT
             if (SOC_IS_TRIDENT2PLUS(unit) || SOC_IS_APACHE(unit)) {
                 if (((config->flags &
                    BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_STRICT_MODE) ||
                    (config->flags &
                    BCM_PORT_CONGESTION_CONFIG_VLAN_PAUSE_COE)) &&
                    (config->flags &
                            BCM_PORT_CONGESTION_CONFIG_RX))
                 {
                     BCM_IF_ERROR_RETURN
                          (bcm_td2p_port_coe_e2ecc(unit, local_port, config));
                 } else {
                    return BCM_E_PARAM;
                 }

             }
#endif
       break;

        case BCM_PORT_CONGESTION_CONFIG_HCFC:
            if (SOC_IS_TRIUMPH3(unit)) {
                BCM_IF_ERROR_RETURN(_bcm_tr3_port_hcfc(unit, local_port, config));
            } else {
                BCM_IF_ERROR_RETURN(_bcm_esw_port_hcfc(unit, local_port, config));
            }
            break;

        case BCM_PORT_CONGESTION_CONFIG_DESTMOD_FLOW_CONTROL:
            if ((!SOC_IS_TD_TT(unit)) && (!SOC_IS_KATANA2(unit)) &&
                    (!SOC_IS_TD2_TT2(unit)) && (!SOC_IS_TRIUMPH3(unit))) {
                return BCM_E_PARAM;
            }

            /* Handle VOQFC message reception */
            BCM_IF_ERROR_RETURN
                (_bcm_esw_port_dmvoqfc_rx(unit, local_port, config));

            /* Handle E2ECC message transmission */
            BCM_IF_ERROR_RETURN
                (_bcm_esw_port_dmvoqfc_tx(unit, local_port, config));
            break;
        case BCM_PORT_CONGESTION_CONFIG_DESTMODPORT_FLOW_CONTROL:
            if (!SOC_IS_KATANA2(unit) && !(SOC_IS_APACHE(unit))) {
                return BCM_E_PARAM;
            }

            /* Handle VOQFC message reception */
            BCM_IF_ERROR_RETURN
                (_bcm_esw_port_dmvoqfc_rx(unit, local_port, config));

            /* Handle E2ECC message transmission */
            BCM_IF_ERROR_RETURN
                (_bcm_esw_port_dmvoqfc_tx(unit, local_port, config));
            break;
        default:
            return BCM_E_PARAM;
        }
        /* Make sure port module is initialized. */
        PORT_INIT(unit);

        /* Lock is needed to modify bcm_port_info */
        PORT_LOCK(unit);

        /* Allocate per-port congestion configuration state on demand */
        if (PORT(unit, local_port).e2ecc_config == NULL) {
            PORT(unit, local_port).e2ecc_config = sal_alloc(sizeof(bcm_port_congestion_config_t),
                    "bcm_port_congestion_config");
            if (PORT(unit, local_port).e2ecc_config == NULL) {
                LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "Error: unable to allocate memory for bcm_port_congestion_config.\n")));
                PORT_UNLOCK(unit);
                return BCM_E_MEMORY;
            }
        }

        /* Store E2ECC configuration */
        *(PORT(unit, local_port).e2ecc_config) = *(config);

        PORT_UNLOCK(unit);


        return BCM_E_NONE;
    } else {
        return BCM_E_UNAVAIL;
    }

}

/*
 * Function:
 *      bcm_port_congestion_config_get
 * Purpose:
 *      Get end-to-end congestion control configuration.
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Gport number.
 *      config - (OUT) Structure containing the congestion configuration.
 * Returns:
 *      BCM_E_xxx
 */

int
bcm_esw_port_congestion_config_get(int unit, bcm_gport_t port,
                                   bcm_port_congestion_config_t *config)
{
    bcm_port_t local_port;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (soc_feature(unit, soc_feature_e2ecc)) {
        /* Check for parameters */

        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &local_port));
        if (!IS_HG_PORT(unit, local_port)) {
            if (SOC_IS_KATANA2(unit) || SOC_IS_TRIDENT2PLUS(unit) ||
                SOC_IS_APACHE(unit)) {
                if ((config->flags &
                     BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_STRICT_MODE) ||
                    (config->flags &
                     BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_FLEX_MODE)   ||
                    (config->flags &
                     BCM_PORT_CONGESTION_CONFIG_VLAN_PAUSE_COE)) {
                    if (!IS_SUBTAG_PORT(unit, local_port)) {
                        LOG_ERROR(
                            BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                        "Error: unit %d port %d is not a Higig "
                                        "port or Subtag port. E2ECC messages "
                                        "can be transmitted to or received from "
                                        "Higig ports or can be received on "
                                        "Subtag port.\n"),
                             unit, local_port));
                        return BCM_E_PORT;
                     }
                     if ((SOC_IS_TRIDENT2PLUS(unit)|| SOC_IS_APACHE(unit)) &&
                           ((config->flags &
                             BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_FLEX_MODE))) {
                            return BCM_E_PARAM;

                     } else  if ((SOC_IS_TRIDENT2PLUS(unit)|| SOC_IS_APACHE(unit)) &&
                           ((config->flags &
                             BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_STRICT_MODE) ||
                           (config->flags &
                             BCM_PORT_CONGESTION_CONFIG_VLAN_PAUSE_COE)) &&
                            (config->flags &
                            BCM_PORT_CONGESTION_CONFIG_TX)) {
                            return BCM_E_PARAM;
                     }
                } else if ((config->flags &
                            BCM_PORT_CONGESTION_CONFIG_TX) &&
                           (config->flags &
                            BCM_PORT_CONGESTION_CONFIG_DESTMOD_FLOW_CONTROL)) {
                    if (!(IS_GE_PORT(unit, local_port)) &&
                        !(IS_XE_PORT(unit, local_port)))  {
                        LOG_ERROR(
                            BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                        "Applicable on Ge/Xe only for enabling "
                                        "dmvoq transmitting only.\n ")));
                        return BCM_E_PARAM;
                    }
                } else if ((SOC_IS_TRIDENT2PLUS(unit)|| SOC_IS_APACHE(unit)) &&
                           (config->flags & BCM_PORT_CONGESTION_CONFIG_HCFC)) {
                    LOG_ERROR(
                        BSL_LS_BCM_PORT,
                        (BSL_META_U(unit,
                                    "Error: unit %d port %d is not a Higig port. "
                                    "E2ECC messages can only be transmitted to "
                                    "or received from Higig ports.\n"),
                         unit, local_port));
                       return BCM_E_PARAM;
                }
            } else {
#ifdef BCM_FIRELIGHT_SUPPORT
                if (SOC_IS_FIRELIGHT(unit) &&
                    (IS_XL_PORT(unit, local_port) || IS_CL_PORT(unit, local_port)) ) {
                    LOG_DEBUG(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                              "unit %d port %d is not a Higig port. "
                              "E2ECC messages can be transmitted to "
                              "Higig/ethernet(XL/CL) ports.\n"), unit, local_port));
                } else
#endif /* BCM_FIRELIGHT_SUPPORT */
                {
                    LOG_ERROR(
                        BSL_LS_BCM_PORT,
                            (BSL_META_U(unit,
                                    "Error: unit %d port %d is not a Higig port. "
                                    "E2ECC messages can only be transmitted to "
                                    "or received from Higig ports.\n"),
                         unit, local_port));
                    return BCM_E_PARAM;
                }
            }
        }
        if (config == NULL) {
            return BCM_E_PARAM;
        }

        /* Make sure port module is initialized. */
        PORT_INIT(unit);

        if (PORT(unit, local_port).e2ecc_config == NULL) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "Error: Port %d bcm_port_congestion_config was not set.\n"),
                                  local_port));
            return BCM_E_NOT_FOUND;
        }

        /* Retrieve E2ECC configuration */
        *config = *(PORT(unit, local_port).e2ecc_config);

        return BCM_E_NONE;

    } else {
        return BCM_E_UNAVAIL;
    }
}

/*
 * Function:
 *      bcm_port_match_add
 * Purpose:
 *      Add a match to an existing port
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port or gport
 *      match - (IN) Match criteria
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_match_add(
    int unit,
    bcm_gport_t port,
    bcm_port_match_info_t *match)
{
#if defined(BCM_TRIUMPH_SUPPORT) && defined(INCLUDE_L3)
    int vp=0, rv = BCM_E_NONE;
    bcm_gport_t gp = 0;
#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_MPLS_SUPPORT)
    _bcm_vp_info_t vp_info;
#endif
#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)
    bcm_vxlan_port_t vxlan_port;
    bcm_l2gre_port_t l2gre_port;
#endif
    int existing_updated = 0;
#if defined(BCM_TRIDENT3_SUPPORT)
    bcm_mirror_destination_t mirror_dest;
    uint32 cancun_ver;
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TRX_SUPPORT)
    bcm_vlan_match_info_t vlan_match_info;
#endif
    if (match == NULL) {
        return BCM_E_PARAM;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (BCM_GPORT_IS_MIM_PORT(port)) {
#if defined(BCM_TRIUMPH2_SUPPORT)
        if (!soc_feature(unit, soc_feature_mim)) {
            return BCM_E_UNAVAIL;
        }
        vp = BCM_GPORT_MIM_PORT_ID_GET(port);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMim)) {
            return BCM_E_NOT_FOUND;
        }
        BCM_IF_ERROR_RETURN(_bcm_vp_info_get(unit, vp, &vp_info));
        if (!(vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            BCM_IF_ERROR_RETURN(_bcm_tr2_mim_port_phys_gport_get(unit, vp, &gp));
        }
#endif
    } else if  (BCM_GPORT_IS_MPLS_PORT(port)) {
        if (!soc_feature(unit, soc_feature_mpls)) {
            return BCM_E_UNAVAIL;
        }
        vp = BCM_GPORT_MPLS_PORT_ID_GET(port);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMpls)) {
            return BCM_E_NOT_FOUND;
        }
#if defined(BCM_MPLS_SUPPORT)
        BCM_IF_ERROR_RETURN(_bcm_vp_info_get(unit, vp, &vp_info));
        if ((vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            if (!soc_feature(unit, soc_feature_vp_sharing)) {
                return BCM_E_UNAVAIL;
            }
        } else {
            BCM_IF_ERROR_RETURN(bcm_tr_mpls_port_phys_gport_get(unit, vp, &gp));
        }
#endif
    } else
#if defined(BCM_TRIDENT2_SUPPORT)
    if (BCM_GPORT_IS_TRUNK(port)) {
        if (!soc_feature(unit, soc_feature_vp_lag)) {
            return BCM_E_UNAVAIL;
        }
        BCM_IF_ERROR_RETURN(
            _bcm_esw_trunk_tid_to_vp_lag_vp(unit, BCM_GPORT_TRUNK_GET(port),
                                            &vp));
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeVpLag)) {
            return BCM_E_NOT_FOUND;
        }
        if (match->match != BCM_PORT_MATCH_PORT_EXTENDED_PORT_VID &&
            match->match != BCM_PORT_MATCH_PORT_EXTENDED_PORT_VID_VLAN) {
            return BCM_E_PARAM;
        }
    } else
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (BCM_GPORT_IS_VXLAN_PORT(port)) {
        if (!soc_feature(unit, soc_feature_vxlan)) {
            return BCM_E_UNAVAIL;
        }
        if (match->match == BCM_PORT_MATCH_PORT
            || match->match == BCM_PORT_MATCH_MAC_PORT
            || match->match == BCM_PORT_MATCH_PORT_VLAN_RANGE
            || match->match == BCM_PORT_MATCH_PORT_INNER_VLAN_RANGE
            || match->match == BCM_PORT_MATCH_PORT_VLAN_STACKED_RANGE
            ) {
            vp = BCM_GPORT_VXLAN_PORT_ID_GET(port);
            if (!(_bcm_vp_used_get(unit, vp, _bcmVpTypeVxlan))) {
                return BCM_E_NOT_FOUND;
            }
        } else {
            if (!soc_feature(unit, soc_feature_vp_sharing)) {
                return BCM_E_UNAVAIL;
            }

            vp = BCM_GPORT_VXLAN_PORT_ID_GET(port);
            BCM_IF_ERROR_RETURN(_bcm_vp_info_get(unit, vp, &vp_info));

            if (vp_info.vp_type != _bcmVpTypeVxlan) {
                return BCM_E_PARAM;
            }
            if (!(vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN(_bcm_td2_vxlan_vpn_is_valid(unit, match->vpn));
        }
    } else
#endif
#if defined(BCM_TRIDENT2_SUPPORT)
    if (BCM_GPORT_IS_L2GRE_PORT(port)) {
        if (!soc_feature(unit, soc_feature_l2gre)) {
            return BCM_E_UNAVAIL;
        }
        if (match->match == BCM_PORT_MATCH_PORT) {
            vp = BCM_GPORT_L2GRE_PORT_ID_GET(port);
            if (!(_bcm_vp_used_get(unit, vp, _bcmVpTypeL2Gre))) {
                return BCM_E_NOT_FOUND;
            }
        } else {
            if (!soc_feature(unit, soc_feature_vp_sharing)) {
                return BCM_E_UNAVAIL;
            }

            vp = BCM_GPORT_L2GRE_PORT_ID_GET(port);
            BCM_IF_ERROR_RETURN(_bcm_vp_info_get(unit, vp, &vp_info));

            if (vp_info.vp_type != _bcmVpTypeL2Gre) {
                return BCM_E_PARAM;
            }
            if (!(vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN(_bcm_tr3_l2gre_vpn_is_valid(unit, match->vpn));
        }
    } else
#endif


#if defined(BCM_TRIUMPH2_SUPPORT)
    if (BCM_GPORT_IS_VLAN_PORT(port)) {
        if ((!soc_feature(unit, soc_feature_lltag)) &&
            (!soc_feature(unit, soc_feature_vlan_vp))) {
            return BCM_E_UNAVAIL;
        }
        vp = BCM_GPORT_VLAN_PORT_ID_GET(port);
        if (!(_bcm_vp_used_get(unit, vp, _bcmVpTypeVlan))) {
            return BCM_E_NOT_FOUND;
        }
        BCM_IF_ERROR_RETURN(bcm_tr2_vlan_port_phys_gport_get(unit, vp, &gp));
    } else
#endif
#if defined(BCM_TRIDENT_SUPPORT)
    if (BCM_GPORT_IS_NIV_PORT(port)) {
        if (!soc_feature(unit, soc_feature_niv)) {
            return BCM_E_UNAVAIL;
        }
        vp = BCM_GPORT_NIV_PORT_ID_GET(port);
        if (!(_bcm_vp_used_get(unit, vp, _bcmVpTypeNiv))) {
            return BCM_E_PARAM;
        }
    } else
#endif /* BCM_TRIDENT_SUPPORT */
#if defined(BCM_TRIDENT3_SUPPORT)
    if (BCM_GPORT_IS_MIRROR(port)) {
        if (!soc_feature(unit, soc_feature_mirror_encap_profile)) {
            return BCM_E_UNAVAIL;
        }
        if ((match->match == BCM_PORT_MATCH_PORT_VLAN) ||
            (match->match == BCM_PORT_MATCH_PORT_I2E_CLASS_IFP_TYPE) ||
            (match->match == BCM_PORT_MATCH_PORT_I2E_CLASS)) {

            SOC_IF_ERROR_RETURN(soc_cancun_version_get(unit, &cancun_ver));
            if (SOC_IS_TRIDENT3(unit) &&
                SOC_CANCUN_VERSION_5_2_UNDER_SERIES(cancun_ver)) {
                if ((match->match == BCM_PORT_MATCH_PORT_I2E_CLASS_IFP_TYPE) ||
                    (match->match == BCM_PORT_MATCH_PORT_I2E_CLASS)) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                          "BCM_PORT_MATCH_PORT_I2E_CLASS match criteria \
                           not supported in Cancun 5.1.8 release\n")));
                    return BCM_E_UNAVAIL;
                }
            } else {
                if (match->match == BCM_PORT_MATCH_PORT_VLAN) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                          "BCM_PORT_MATCH_PORT_VLAN match criteria \
                           not supported after Cancun 5.1.8 release\n")));
                    return BCM_E_UNAVAIL;
                }

                /* check if max I2E class_id */
                if (match->match_vlan > _BCM_I2E_CLASS_ID_MAX) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                        (BSL_META_U(unit, " %d exceeds I2E class_id max %d\n"),
                         match->match_vlan,_BCM_I2E_CLASS_ID_MAX));
                    return BCM_E_PARAM;
                }
            }

            bcm_mirror_destination_t_init(&mirror_dest);
            BCM_IF_ERROR_RETURN(bcm_esw_mirror_destination_get(unit, port,
                                &mirror_dest));
            if (mirror_dest.flags & BCM_MIRROR_DEST_FIELD) {
                return BCM_E_PARAM;
            }
        } else {
            return BCM_E_PARAM;
        }
    } else
#endif /* BCM_TRIDENT3_SUPPORT */
    {
        return BCM_E_PORT;
    }

    switch (match->match) {
    case BCM_PORT_MATCH_NONE:
        rv = BCM_E_NONE;
        break;
#if defined(BCM_TRIDENT2_SUPPORT)
    case BCM_PORT_MATCH_PORT:
        if (BCM_GPORT_IS_VXLAN_PORT(port)) {
            bcm_vxlan_port_t_init(&vxlan_port);
            vxlan_port.criteria      = BCM_VXLAN_PORT_MATCH_PORT;
            vxlan_port.vxlan_port_id = port;
            vxlan_port.match_port    = match->port;
            BCM_IF_ERROR_RETURN(
                _bcm_td2_vxlan_match_add(unit, &vxlan_port, vp, 0));
        } else if (BCM_GPORT_IS_L2GRE_PORT(port)) {
            bcm_l2gre_port_t_init(&l2gre_port);
            l2gre_port.criteria       = BCM_L2GRE_PORT_MATCH_PORT;
            l2gre_port.l2gre_port_id   = port;
            l2gre_port.match_port           = match->port;
            BCM_IF_ERROR_RETURN(
                bcm_td2_l2gre_match_add(unit, &l2gre_port, vp, 0));
        } else if (BCM_GPORT_IS_MIM_PORT(port) &&
            (vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            bcm_mim_port_t mim_port;
            bcm_mim_port_t_init(&mim_port);
            mim_port.criteria = BCM_MIM_PORT_MATCH_PORT;
            mim_port.mim_port_id = port;
            mim_port.port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr2_mim_match_add(unit,
                                 &mim_port, vp, match->vpn));
        } else if (BCM_GPORT_IS_MPLS_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT)
            bcm_mpls_port_t mpls_port;
            bcm_mpls_port_t_init(&mpls_port);
            mpls_port.criteria       = BCM_MPLS_PORT_MATCH_PORT;
            mpls_port.mpls_port_id   = port;
            mpls_port.port           = match->port;
            BCM_IF_ERROR_RETURN(
                _bcm_tr_mpls_match_add(unit, &mpls_port, vp, 0, TRUE));
#endif
        } else if (BCM_GPORT_IS_VLAN_PORT(port)) {
            bcm_vlan_port_t vlan_port;
            bcm_vlan_port_t_init(&vlan_port);
            vlan_port.criteria       = BCM_VLAN_PORT_MATCH_PORT;
            vlan_port.port           = match->port;
            BCM_IF_ERROR_RETURN(
                bcm_tr2_vlan_vp_match_add(unit, &vlan_port, vp));

        } else {
            rv = BCM_E_PARAM;
        }
        break;
#endif

    case BCM_PORT_MATCH_PORT_I2E_CLASS:
    case BCM_PORT_MATCH_PORT_I2E_CLASS_IFP_TYPE:
#if defined(BCM_TRIDENT3_SUPPORT)
        if (BCM_GPORT_IS_MIRROR(port)) {
            rv = _bcm_mirror_port_match_add(unit, &mirror_dest, match->port,
                                            match->match_vlan, match->match);
        } else
#endif
        {
            rv = BCM_E_UNAVAIL;
        }
        break;

    case BCM_PORT_MATCH_PORT_VLAN:
#if defined(BCM_TRIDENT3_SUPPORT)
        if (BCM_GPORT_IS_MIRROR(port)) {
            rv = _bcm_mirror_port_match_add(unit, &mirror_dest, match->port,
                                            match->match_vlan, match->match);
            break;
        } else
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (BCM_GPORT_IS_VXLAN_PORT(port)) {
            /* match_info translation to vxlan_port */
            bcm_vxlan_port_t_init(&vxlan_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            vxlan_port.criteria = BCM_VXLAN_PORT_MATCH_PORT_VLAN;
            vxlan_port.match_vlan = match->match_vlan;
            vxlan_port.vxlan_port_id = port;
            vxlan_port.match_port = match->port;

            BCM_IF_ERROR_RETURN(_bcm_td2_vxlan_match_add(unit,
                                            &vxlan_port, vp, match->vpn));
            break;
        } else if (BCM_GPORT_IS_MIM_PORT(port) &&
            (vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            bcm_mim_port_t mim_port;
            bcm_mim_port_t_init(&mim_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            mim_port.criteria = BCM_MIM_PORT_MATCH_PORT_VLAN;
            mim_port.match_vlan = match->match_vlan;
            mim_port.mim_port_id = port;
            mim_port.port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr2_mim_match_add(unit,
                                 &mim_port, vp, match->vpn));
            break;
        } else if (BCM_GPORT_IS_MPLS_PORT(port) &&
            (vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            bcm_mpls_port_t mpls_port;
            bcm_mpls_port_t_init(&mpls_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            mpls_port.criteria = BCM_MPLS_PORT_MATCH_PORT_VLAN;
            mpls_port.match_vlan = match->match_vlan;
            mpls_port.mpls_port_id = port;
            mpls_port.port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr_mpls_match_add(unit,
                                 &mpls_port, vp, match->vpn, TRUE));
            break;
        } else if (BCM_GPORT_IS_L2GRE_PORT(port)) {
            /* match_info translation to L2GRE_port */
            bcm_l2gre_port_t_init(&l2gre_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            l2gre_port.criteria = BCM_L2GRE_PORT_MATCH_PORT_VLAN;
            l2gre_port.match_vlan = match->match_vlan;
            l2gre_port.l2gre_port_id = port;
            l2gre_port.match_port = match->port;
            BCM_IF_ERROR_RETURN(bcm_td2_l2gre_match_add(unit,
                                            &l2gre_port, vp, match->vpn));
            break;
        }
#endif

        /* Add an entry in the VLAN_XLATE table */
        /* Tag actions need to be adjusted by calling the
           bcm_vlan_translate_action_add API for the entry we are creating */
        VLAN_CHK_ID(unit, match->match_vlan);
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }

        rv = _bcm_tr_vlan_translate_vp_add(unit, gp,
                                            bcmVlanTranslateKeyPortOuter,
                                            match->match_vlan,
                                            BCM_VLAN_INVALID,
                                            vp, match->action,
                                            &existing_updated);
        if (BCM_GPORT_IS_MIM_PORT(port)) {
#if defined(BCM_TRIUMPH2_SUPPORT)
           _bcm_tr2_mim_port_match_count_adjust(unit, vp, 1);
#endif
        } else if (BCM_GPORT_IS_MPLS_PORT(port) && !existing_updated) {
#if defined(BCM_MPLS_SUPPORT)
           bcm_tr_mpls_port_match_count_adjust(unit, vp, 1);
#endif
        }
        break;

    case BCM_PORT_MATCH_PORT_INNER_VLAN:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (BCM_GPORT_IS_VXLAN_PORT(port)) {
            bcm_vxlan_port_t_init(&vxlan_port);
            VLAN_CHK_ID(unit, match->match_inner_vlan);
            vxlan_port.criteria = BCM_VXLAN_PORT_MATCH_PORT_INNER_VLAN;
            vxlan_port.match_inner_vlan = match->match_inner_vlan;
            vxlan_port.vxlan_port_id = port;
            vxlan_port.match_port = match->port;

            BCM_IF_ERROR_RETURN(_bcm_td2_vxlan_match_add(unit,
                                            &vxlan_port, vp, match->vpn));
            break;
        } else if (BCM_GPORT_IS_MPLS_PORT(port) &&
            (vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            bcm_mpls_port_t mpls_port;
            bcm_mpls_port_t_init(&mpls_port);
            VLAN_CHK_ID(unit, match->match_inner_vlan);
            mpls_port.criteria = BCM_MPLS_PORT_MATCH_PORT_INNER_VLAN;
            mpls_port.match_inner_vlan = match->match_inner_vlan;
            mpls_port.mpls_port_id = port;
            mpls_port.port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr_mpls_match_add(unit,
                                 &mpls_port, vp, match->vpn, TRUE));
            break;
        } else if (BCM_GPORT_IS_L2GRE_PORT(port)) {
            /* match_info translation to L2GRE_port */
            bcm_l2gre_port_t_init(&l2gre_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            l2gre_port.criteria = BCM_L2GRE_PORT_MATCH_PORT_INNER_VLAN;
            l2gre_port.match_inner_vlan = match->match_inner_vlan;
            l2gre_port.l2gre_port_id = port;
            l2gre_port.match_port = match->port;
            BCM_IF_ERROR_RETURN(bcm_td2_l2gre_match_add(unit,
                                            &l2gre_port, vp, match->vpn));
            break;
        }
#endif
        /* Add an entry in the VLAN_XLATE table */
        /* Tag actions need to be adjusted by calling the
         * bcm_vlan_translate_action_add API for the entry we are creating */
        VLAN_CHK_ID(unit, match->match_inner_vlan);
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }

        rv = _bcm_tr_vlan_translate_vp_add(unit, gp,
                                            bcmVlanTranslateKeyPortInner,
                                            BCM_VLAN_INVALID,
                                            match->match_inner_vlan,
                                            vp, match->action,
                                            &existing_updated);
        break;

    case BCM_PORT_MATCH_PORT_VLAN16:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (BCM_GPORT_IS_VXLAN_PORT(port) &&
            ((match->match_vlan & 0xfff) == BCM_VLAN_NONE)) {
            bcm_vxlan_port_t_init(&vxlan_port);
            vxlan_port.criteria = BCM_VXLAN_PORT_MATCH_VLAN_PRI;
            vxlan_port.match_vlan = match->match_vlan;
            vxlan_port.vxlan_port_id = port;
            vxlan_port.match_port = match->port;

            BCM_IF_ERROR_RETURN(_bcm_td2_vxlan_match_add(unit,
                                            &vxlan_port, vp, match->vpn));
            break;
        } else if (BCM_GPORT_IS_MPLS_PORT(port) &&
            (vp_info.flags & _BCM_VP_INFO_SHARED_PORT) &&
             ((match->match_vlan & 0xfff) == BCM_VLAN_NONE)) {
            bcm_mpls_port_t mpls_port;
            bcm_mpls_port_t_init(&mpls_port);
            mpls_port.criteria = BCM_MPLS_PORT_MATCH_VLAN_PRI;
            mpls_port.match_vlan = match->match_vlan;
            mpls_port.mpls_port_id = port;
            mpls_port.port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr_mpls_match_add(unit,
                                 &mpls_port, vp, match->vpn, TRUE));
            break;
        } else if (BCM_GPORT_IS_L2GRE_PORT(port) &&
            ((match->match_vlan & 0xfff) == BCM_VLAN_NONE)) {
            /* match_info translation to L2GRE_port */
            bcm_l2gre_port_t_init(&l2gre_port);
            l2gre_port.criteria = BCM_L2GRE_PORT_MATCH_VLAN_PRI;
            l2gre_port.match_vlan = match->match_vlan;
            l2gre_port.l2gre_port_id = port;
            l2gre_port.match_port = match->port;
            BCM_IF_ERROR_RETURN(bcm_td2_l2gre_match_add(unit,
                                            &l2gre_port, vp, match->vpn));
            break;
        }
#endif
        /* Add an entry in the VLAN_XLATE table */
        /* Tag actions need to be adjusted by calling the
           bcm_vlan_translate_action_add API for the entry we are creating */
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }

        /* allow 16 bit VLAN id */
        rv = _bcm_tr_vlan_translate_vp_add(unit, gp,
                                            bcmVlanTranslateKeyPortOuterTag,
                                            match->match_vlan,
                                            BCM_VLAN_INVALID,
                                            vp, match->action,
                                            &existing_updated);
        if (BCM_GPORT_IS_MIM_PORT(port)) {
#if defined(BCM_TRIUMPH2_SUPPORT)
           _bcm_tr2_mim_port_match_count_adjust(unit, vp, 1);
#endif
        } else if (BCM_GPORT_IS_MPLS_PORT(port) && !existing_updated) {
#if defined(BCM_MPLS_SUPPORT)
           bcm_tr_mpls_port_match_count_adjust(unit, vp, 1);
#endif
        }
        break;


    case BCM_PORT_MATCH_PORT_VLAN_STACKED:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (BCM_GPORT_IS_VXLAN_PORT(port)) {
            /* match_info translation to vxlan_port */
            bcm_vxlan_port_t_init(&vxlan_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            VLAN_CHK_ID(unit, match->match_inner_vlan);
            vxlan_port.criteria = BCM_VXLAN_PORT_MATCH_PORT_VLAN_STACKED;
            vxlan_port.match_vlan = match->match_vlan;
            vxlan_port.match_inner_vlan = match->match_inner_vlan;
            vxlan_port.vxlan_port_id = port;
            vxlan_port.match_port = match->port;

            BCM_IF_ERROR_RETURN(_bcm_td2_vxlan_match_add(unit,
                                            &vxlan_port, vp, match->vpn));
            break;
        } else if (BCM_GPORT_IS_MIM_PORT(port) &&
            (vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            bcm_mim_port_t mim_port;
            bcm_mim_port_t_init(&mim_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            VLAN_CHK_ID(unit, match->match_inner_vlan);
            mim_port.criteria = BCM_MIM_PORT_MATCH_PORT_VLAN_STACKED;
            mim_port.match_vlan = match->match_vlan;
            mim_port.match_inner_vlan = match->match_inner_vlan;
            mim_port.mim_port_id = port;
            mim_port.port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr2_mim_match_add(unit,
                                 &mim_port, vp, match->vpn));
            break;
        } else if (BCM_GPORT_IS_MPLS_PORT(port) &&
            (vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            bcm_mpls_port_t mpls_port;
            bcm_mpls_port_t_init(&mpls_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            VLAN_CHK_ID(unit, match->match_inner_vlan);
            mpls_port.criteria = BCM_MPLS_PORT_MATCH_PORT_VLAN_STACKED;
            mpls_port.match_vlan = match->match_vlan;
            mpls_port.match_inner_vlan = match->match_inner_vlan;
            mpls_port.mpls_port_id = port;
            mpls_port.port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr_mpls_match_add(unit,
                                 &mpls_port, vp, match->vpn, TRUE));
            break;
        }  else if (BCM_GPORT_IS_L2GRE_PORT(port)) {
            /* match_info translation to L2GRE_port */
            bcm_l2gre_port_t_init(&l2gre_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            VLAN_CHK_ID(unit, match->match_inner_vlan);
            l2gre_port.criteria = BCM_L2GRE_PORT_MATCH_PORT_VLAN_STACKED;
            l2gre_port.match_vlan = match->match_vlan;
            l2gre_port.match_inner_vlan = match->match_inner_vlan;
            l2gre_port.l2gre_port_id = port;
            l2gre_port.match_port = match->port;
            BCM_IF_ERROR_RETURN(bcm_td2_l2gre_match_add(unit,
                                            &l2gre_port, vp, match->vpn));
            break;
        }
#endif

        /* Add an entry in the VLAN_XLATE table */
        /* Tag actions need to be adjusted by calling the
           bcm_vlan_translate_action_add API for the entry we are creating */
        VLAN_CHK_ID(unit, match->match_vlan);
        VLAN_CHK_ID(unit, match->match_inner_vlan);
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }
        rv = _bcm_tr_vlan_translate_vp_add(unit, gp,
                                            bcmVlanTranslateKeyPortDouble,
                                            match->match_vlan,
                                            match->match_inner_vlan,
                                            vp, match->action,
                                            &existing_updated);
        if (BCM_GPORT_IS_MIM_PORT(port)) {
#if defined(BCM_TRIUMPH2_SUPPORT)
        _bcm_tr2_mim_port_match_count_adjust(unit, vp, 1);
#endif
        } else if (BCM_GPORT_IS_MPLS_PORT(port) && !existing_updated) {
#if defined(BCM_MPLS_SUPPORT)
           bcm_tr_mpls_port_match_count_adjust(unit, vp, 1);
#endif
        }
        break;
    case BCM_PORT_MATCH_PORT_VLAN_RANGE:
#if defined(BCM_TRIUMPH2_SUPPORT)
        /* Add entries in the ING_VLAN_RANGE and VLAN_XLATE tables */
        /* Tag actions need to be adjusted by calling the
           bcm_vlan_translate_action_add API for the entry we are creating */
        VLAN_CHK_ID(unit, match->match_vlan);
        VLAN_CHK_ID(unit, match->match_vlan_max);
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }

        rv = _bcm_tr2_vlan_translate_range_vp_add(unit, gp,
                                                  match->match_vlan,
                                                  match->match_vlan_max,
                                                  BCM_VLAN_INVALID,
                                                  BCM_VLAN_INVALID,
                                                  vp, match->action);
        if (BCM_SUCCESS(rv)) {
        if (BCM_GPORT_IS_MIM_PORT(port)) {
            _bcm_tr2_mim_port_match_count_adjust(unit, vp, 1);
        } else if (BCM_GPORT_IS_MPLS_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT)
            bcm_tr_mpls_port_match_count_adjust(unit, vp, 1);
#endif
        } else if (BCM_GPORT_IS_VXLAN_PORT(port)) {
#if defined(BCM_TRIDENT2_SUPPORT)
            bcm_td2_vxlan_port_match_count_adjust(unit, vp, 1);
#endif
        }
        }
#endif
        break;
    case BCM_PORT_MATCH_PORT_INNER_VLAN_RANGE:
#if defined(BCM_TRIUMPH2_SUPPORT)
        if (!soc_feature(unit, soc_feature_inner_vlan_range_check)) {
            return BCM_E_UNAVAIL;
        }
        /* Add entries in the ING_VLAN_RANGE and VLAN_XLATE tables */
        /* Tag actions need to be adjusted by calling the
           bcm_vlan_translate_action_add API for the entry we are creating */
        VLAN_CHK_ID(unit, match->match_inner_vlan);
        VLAN_CHK_ID(unit, match->match_inner_vlan_max);
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }

        rv = _bcm_tr2_vlan_translate_range_vp_add(unit, gp,
                                                  BCM_VLAN_INVALID,
                                                  BCM_VLAN_INVALID,
                                                  match->match_inner_vlan,
                                                  match->match_inner_vlan_max,
                                                  vp, match->action);
        if (BCM_SUCCESS(rv)) {
        if (BCM_GPORT_IS_MIM_PORT(port)) {
            _bcm_tr2_mim_port_match_count_adjust(unit, vp, 1);
        } else if (BCM_GPORT_IS_MPLS_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT)
            bcm_tr_mpls_port_match_count_adjust(unit, vp, 1);
#endif
        }
        }
#endif
        break;
    case BCM_PORT_MATCH_PORT_VLAN_STACKED_RANGE:
#if defined(BCM_TRIUMPH2_SUPPORT)
        if (!soc_feature(unit, soc_feature_inner_vlan_range_check)) {
            return BCM_E_UNAVAIL;
        }
        /* Add entries in the ING_VLAN_RANGE and VLAN_XLATE tables */
        /* Tag actions need to be adjusted by calling the
           bcm_vlan_translate_action_add API for the entry we are creating */
        VLAN_CHK_ID(unit, match->match_vlan);
        VLAN_CHK_ID(unit, match->match_vlan_max);
        VLAN_CHK_ID(unit, match->match_inner_vlan);
        VLAN_CHK_ID(unit, match->match_inner_vlan_max);
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }

        rv = _bcm_tr2_vlan_translate_range_vp_add(unit, gp,
                                                  match->match_vlan,
                                                  match->match_vlan_max,
                                                  match->match_inner_vlan,
                                                  match->match_inner_vlan_max,
                                                  vp, match->action);
        if (BCM_SUCCESS(rv)) {
        if (BCM_GPORT_IS_MIM_PORT(port)) {
            _bcm_tr2_mim_port_match_count_adjust(unit, vp, 1);
        } else if (BCM_GPORT_IS_MPLS_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT)
            bcm_tr_mpls_port_match_count_adjust(unit, vp, 1);
#endif
        }  else if (BCM_GPORT_IS_VXLAN_PORT(port)) {
#if defined(BCM_TRIDENT2_SUPPORT)
            bcm_td2_vxlan_port_match_count_adjust(unit, vp, 1);
#endif
        }
        }
#endif
        break;

#if defined(BCM_TRIUMPH3_SUPPORT)
    case BCM_PORT_MATCH_PORT_EXTENDED_PORT_VID:
    case BCM_PORT_MATCH_PORT_EXTENDED_PORT_VID_VLAN:
        rv = _bcm_esw_extender_port_match_add(unit, match->port,
                                              match->extended_port_vid,
                                              match->match_vlan, vp);
        break;
#endif

#ifdef BCM_TRIUMPH2_SUPPORT
    case BCM_PORT_MATCH_PORT_PON_TUNNEL:
    case BCM_PORT_MATCH_PORT_PON_TUNNEL_VLAN:
    case BCM_PORT_MATCH_PORT_PON_TUNNEL_INNER_VLAN:
        if (!BCM_GPORT_IS_VLAN_PORT(port)) {
            return BCM_E_UNAVAIL;
        }
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            if (match->port != gp) {
                return BCM_E_PORT;
            }
        } else if (BCM_GPORT_IS_LOCAL(match->port)) {
            bcm_module_t modid;
            bcm_trunk_t trunk_id;
            bcm_port_t port_num;
            bcm_gport_t modport;
            int id;

            BCM_IF_ERROR_RETURN (_bcm_esw_gport_resolve(unit,
                                               match->port, &modid, &port_num, &trunk_id, &id));
            if (trunk_id != BCM_TRUNK_INVALID) {
                BCM_GPORT_TRUNK_SET(modport, trunk_id);
            } else {
                BCM_IF_ERROR_RETURN(_bcm_esw_stk_modmap_map(unit,
                                                BCM_STK_MODMAP_GET, modid, port_num, &modid, &port_num));
                BCM_GPORT_MODPORT_SET(modport, modid, port_num);
            }

            if (modport != gp) {
                return BCM_E_PORT;
            }
        }else {
            return BCM_E_PORT;
        }

        VLAN_CHK_ID(unit, match->match_pon_tunnel);
        if (match->match == BCM_PORT_MATCH_PORT_PON_TUNNEL) {
            rv = _bcm_tr_lltag_vlan_translate_vp_add(unit, gp, bcmVlanTranslateKeyPortPonTunnel,
                                              match->match_pon_tunnel,
                                              BCM_VLAN_INVALID,
                                              vp,
                                              match->action);
        } else if (match->match == BCM_PORT_MATCH_PORT_PON_TUNNEL_VLAN) {
            VLAN_CHK_ID(unit, match->match_vlan);
            rv = _bcm_tr_lltag_vlan_translate_vp_add(unit, gp, bcmVlanTranslateKeyPortPonTunnelOuter,
                                              match->match_pon_tunnel,
                                              match->match_vlan,
                                              vp,
                                              match->action);
        } else if (match->match == BCM_PORT_MATCH_PORT_PON_TUNNEL_INNER_VLAN) {
            VLAN_CHK_ID(unit, match->match_inner_vlan);
            rv = _bcm_tr_lltag_vlan_translate_vp_add(unit, gp, bcmVlanTranslateKeyPortPonTunnelInner,
                                              match->match_pon_tunnel,
                                              match->match_inner_vlan,
                                              vp,
                                              match->action);
        }

        if (BCM_FAILURE(rv)) {
            return rv;
        }

        bcm_tr2_vlan_port_match_count_adjust(unit, vp, 1);
        break;
#endif
#if defined(BCM_TRIDENT_SUPPORT)
    case BCM_PORT_MATCH_PORT_NIV_PORT_VIF:
    case BCM_PORT_MATCH_PORT_NIV_PORT_VIF_VLAN:
        rv = _bcm_trident_niv_match_add(unit, match->port,
                                        match->niv_port_vif,
                                        match->match_vlan, vp);
        break;
#endif /* BCM_TRIDENT_SUPPORT */
#if defined(BCM_TRX_SUPPORT)
    case BCM_PORT_MATCH_MAC_PORT:
    case BCM_PORT_MATCH_MAC_PORT_CLASS:
        bcm_vlan_match_info_t_init(&vlan_match_info);
        if (match->match == BCM_PORT_MATCH_MAC_PORT) {
            vlan_match_info.match = BCM_VLAN_MATCH_MAC_PORT;
            vlan_match_info.port = match->port;
        } else if (match->match == BCM_PORT_MATCH_MAC_PORT_CLASS) {
            vlan_match_info.match = BCM_VLAN_MATCH_MAC_PORT_CLASS;
            vlan_match_info.port_class = match->port_class;
        }
        sal_memcpy(vlan_match_info.src_mac,
                match->src_mac, sizeof (bcm_mac_t));
        rv = _bcm_trx_vlan_match_action_add(unit, 0,
                port, &vlan_match_info, match->action);
        break;
#endif
    default:
        rv = BCM_E_PARAM;
        break;
    }
    return rv;
#else
    return BCM_E_UNAVAIL;
#endif
}

/*
 * Function:
 *      bcm_port_match_delete
 * Purpose:
 *      Remove a match from an existing port
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port or gport
 *      match - (IN) Match criteria
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_match_delete(
    int unit,
    bcm_gport_t port,
    bcm_port_match_info_t *match)
{
#if defined(BCM_TRIUMPH_SUPPORT) && defined(INCLUDE_L3)
    int vp=0, rv = BCM_E_NONE;
    bcm_gport_t gp = 0;
#if defined(BCM_TRIUMPH2_SUPPORT) || defined(BCM_MPLS_SUPPORT)
    _bcm_vp_info_t vp_info;
#endif
#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)
    bcm_vxlan_port_t vxlan_port;
    bcm_l2gre_port_t l2gre_port;
#endif
#if defined(BCM_TRIDENT3_SUPPORT)
    bcm_mirror_destination_t mirror_dest;
    uint32 cancun_ver;
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TRX_SUPPORT)
    bcm_vlan_match_info_t vlan_match_info;
#endif

    if (match == NULL) {
        return BCM_E_PARAM;
    }
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (BCM_GPORT_IS_MIM_PORT(port)) {
#if defined(BCM_TRIUMPH2_SUPPORT)
        if (!soc_feature(unit, soc_feature_mim)) {
            return BCM_E_UNAVAIL;
        }
        vp = BCM_GPORT_MIM_PORT_ID_GET(port);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMim)) {
            return BCM_E_NOT_FOUND;
        }
        BCM_IF_ERROR_RETURN(_bcm_vp_info_get(unit, vp, &vp_info));
        if (!(vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            BCM_IF_ERROR_RETURN(_bcm_tr2_mim_port_phys_gport_get(unit, vp, &gp));
        }
#endif
    } else if  (BCM_GPORT_IS_MPLS_PORT(port)) {
        if (!soc_feature(unit, soc_feature_mpls)) {
            return BCM_E_UNAVAIL;
        }
        vp = BCM_GPORT_MPLS_PORT_ID_GET(port);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMpls)) {
            return BCM_E_NOT_FOUND;
        }
#if defined(BCM_MPLS_SUPPORT)
        BCM_IF_ERROR_RETURN(_bcm_vp_info_get(unit, vp, &vp_info));
        if ((vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            if (!soc_feature(unit, soc_feature_vp_sharing)) {
                return BCM_E_UNAVAIL;
            }
        } else {
            BCM_IF_ERROR_RETURN(bcm_tr_mpls_port_phys_gport_get(unit, vp, &gp));
        }
#endif
    } else
#if defined(BCM_TRIDENT2_SUPPORT)
    if (BCM_GPORT_IS_TRUNK(port)) {
        if (!soc_feature(unit, soc_feature_vp_lag)) {
            return BCM_E_UNAVAIL;
        }
        BCM_IF_ERROR_RETURN(
            _bcm_esw_trunk_tid_to_vp_lag_vp(unit, BCM_GPORT_TRUNK_GET(port),
                                            &vp));
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeVpLag)) {
            return BCM_E_NOT_FOUND;
        }
        if (match->match != BCM_PORT_MATCH_PORT_EXTENDED_PORT_VID &&
            match->match != BCM_PORT_MATCH_PORT_EXTENDED_PORT_VID_VLAN) {
            return BCM_E_PARAM;
        }
    } else
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (BCM_GPORT_IS_VXLAN_PORT(port)) {
        if (!soc_feature(unit, soc_feature_vxlan)) {
            return BCM_E_UNAVAIL;
        }
        if (match->match == BCM_PORT_MATCH_PORT
            || match->match == BCM_PORT_MATCH_MAC_PORT
            || match->match == BCM_PORT_MATCH_PORT_VLAN_RANGE
            || match->match == BCM_PORT_MATCH_PORT_INNER_VLAN_RANGE
            || match->match == BCM_PORT_MATCH_PORT_VLAN_STACKED_RANGE
            ) {
            vp = BCM_GPORT_VXLAN_PORT_ID_GET(port);
            if (!(_bcm_vp_used_get(unit, vp, _bcmVpTypeVxlan))) {
                return BCM_E_NOT_FOUND;
            }
        } else {
            if (!soc_feature(unit, soc_feature_vp_sharing)) {
                return BCM_E_UNAVAIL;
            }

            vp = BCM_GPORT_VXLAN_PORT_ID_GET(port);
            BCM_IF_ERROR_RETURN(_bcm_vp_info_get(unit, vp, &vp_info));
            if (vp_info.vp_type != _bcmVpTypeVxlan) {
                return BCM_E_PARAM;
            }
            if (!(vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
                return BCM_E_PARAM;
            }
        }
    } else
#endif
#if defined(BCM_TRIDENT2_SUPPORT)
    if (BCM_GPORT_IS_L2GRE_PORT(port)) {
        if (!soc_feature(unit, soc_feature_l2gre)) {
            return BCM_E_UNAVAIL;
        }
        if (match->match == BCM_PORT_MATCH_PORT) {
            vp = BCM_GPORT_L2GRE_PORT_ID_GET(port);
            if (!(_bcm_vp_used_get(unit, vp, _bcmVpTypeL2Gre))) {
                return BCM_E_NOT_FOUND;
            }
        } else {
            if (!soc_feature(unit, soc_feature_vp_sharing)) {
                return BCM_E_UNAVAIL;
            }

            vp = BCM_GPORT_L2GRE_PORT_ID_GET(port);
            BCM_IF_ERROR_RETURN(_bcm_vp_info_get(unit, vp, &vp_info));

            if (vp_info.vp_type != _bcmVpTypeL2Gre) {
                return BCM_E_PARAM;
            }
            if (!(vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
                return BCM_E_PARAM;
            }
        }
    } else
#endif

#if defined(BCM_TRIUMPH2_SUPPORT)
    if (BCM_GPORT_IS_VLAN_PORT(port)) {
        if ((!soc_feature(unit, soc_feature_lltag)) &&
            (!soc_feature(unit, soc_feature_vlan_vp))) {
            return BCM_E_UNAVAIL;
        }
        vp = BCM_GPORT_VLAN_PORT_ID_GET(port);
        if (!(_bcm_vp_used_get(unit, vp, _bcmVpTypeVlan))) {
            return BCM_E_NOT_FOUND;
        }
        BCM_IF_ERROR_RETURN(bcm_tr2_vlan_port_phys_gport_get(unit, vp, &gp));
    } else
#endif
#if defined(BCM_TRIDENT_SUPPORT)
    if (BCM_GPORT_IS_NIV_PORT(port)) {
        if (!soc_feature(unit, soc_feature_niv)) {
            return BCM_E_UNAVAIL;
        }
        vp = BCM_GPORT_NIV_PORT_ID_GET(port);
        if (!(_bcm_vp_used_get(unit, vp, _bcmVpTypeNiv))) {
            return BCM_E_PARAM;
        }
    } else
#endif /* BCM_TRIDENT_SUPPORT */
#if defined(BCM_TRIDENT3_SUPPORT)
    if (BCM_GPORT_IS_MIRROR(port)) {
        if (!soc_feature(unit, soc_feature_mirror_encap_profile)) {
            return BCM_E_UNAVAIL;
        }
        if ((match->match == BCM_PORT_MATCH_PORT_VLAN) ||
            (match->match == BCM_PORT_MATCH_PORT_I2E_CLASS_IFP_TYPE) ||
            (match->match == BCM_PORT_MATCH_PORT_I2E_CLASS)) {

            SOC_IF_ERROR_RETURN(soc_cancun_version_get(unit, &cancun_ver));
            if (SOC_IS_TRIDENT3(unit) &&
                SOC_CANCUN_VERSION_5_2_UNDER_SERIES(cancun_ver)) {
                if ((match->match == BCM_PORT_MATCH_PORT_I2E_CLASS_IFP_TYPE) ||
                    (match->match == BCM_PORT_MATCH_PORT_I2E_CLASS)) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                          "BCM_PORT_MATCH_PORT_I2E_CLASS match criteria \
                           not supported in Cancun 5.1.8 release\n")));
                    return BCM_E_UNAVAIL;
                }
            } else {
                if (match->match == BCM_PORT_MATCH_PORT_VLAN) {
                    LOG_ERROR(BSL_LS_BCM_PORT,
                              (BSL_META_U(unit,
                          "BCM_PORT_MATCH_PORT_VLAN match criteria \
                           not supported after Cancun 5.1.8 release\n")));
                    return BCM_E_UNAVAIL;
                }
            }

            bcm_mirror_destination_t_init(&mirror_dest);
            BCM_IF_ERROR_RETURN(bcm_esw_mirror_destination_get(unit, port,
                                &mirror_dest));
            if (mirror_dest.flags & BCM_MIRROR_DEST_FIELD) {
                return BCM_E_PARAM;
            }
        } else {
            return BCM_E_PARAM;
        }
    } else
#endif /* BCM_TRIDENT3_SUPPORT */
    {
        return BCM_E_PORT;
    }

    switch (match->match) {
    case BCM_PORT_MATCH_NONE:
        rv = BCM_E_NONE;
        break;
#if defined(BCM_TRIDENT2_SUPPORT)
    case BCM_PORT_MATCH_PORT:
        if (BCM_GPORT_IS_VXLAN_PORT(port)) {
            bcm_vxlan_port_t_init(&vxlan_port);
            vxlan_port.criteria      = BCM_VXLAN_PORT_MATCH_PORT;
            vxlan_port.vxlan_port_id = port;
            vxlan_port.match_port    = match->port;
            BCM_IF_ERROR_RETURN(_bcm_td2_vxlan_match_delete(unit, vp, vxlan_port, 0));
        } else if (BCM_GPORT_IS_MPLS_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT)
            bcm_mpls_port_t mpls_port;
            bcm_mpls_port_t_init(&mpls_port);
            mpls_port.criteria       = BCM_MPLS_PORT_MATCH_PORT;
            mpls_port.mpls_port_id   = port;
            mpls_port.port           = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr_mpls_match_delete(unit, vp, &mpls_port, TRUE));
#endif
        } else if (BCM_GPORT_IS_L2GRE_PORT(port)) {
            bcm_l2gre_port_t_init(&l2gre_port);
            l2gre_port.criteria       = BCM_L2GRE_PORT_MATCH_PORT;
            l2gre_port.l2gre_port_id   = port;
            l2gre_port.match_port           = match->port;
            BCM_IF_ERROR_RETURN(bcm_td2_l2gre_match_delete(unit, vp, &l2gre_port));
        } else if (BCM_GPORT_IS_VLAN_PORT(port)) {
            bcm_vlan_port_t vlan_port;
            bcm_vlan_port_t_init(&vlan_port);
            vlan_port.criteria       = BCM_VLAN_PORT_MATCH_PORT;
            vlan_port.port           = match->port;
            BCM_IF_ERROR_RETURN(
                bcm_tr2_vlan_vp_match_delete(unit, &vlan_port, vp));
        } else {
            rv = BCM_E_PARAM;
        }
        break;
#endif

    case BCM_PORT_MATCH_PORT_I2E_CLASS:
    case BCM_PORT_MATCH_PORT_I2E_CLASS_IFP_TYPE:
#if defined(BCM_TRIDENT3_SUPPORT)
        if (BCM_GPORT_IS_MIRROR(port)) {
            rv = _bcm_mirror_port_match_delete(unit, &mirror_dest, match->port,
                                            match->match_vlan, match->match);
        } else
#endif
        {
            rv = BCM_E_UNAVAIL;
        }
        break;

    case BCM_PORT_MATCH_PORT_VLAN:
#if defined(BCM_TRIDENT3_SUPPORT)
        if (BCM_GPORT_IS_MIRROR(port)) {
            rv = _bcm_mirror_port_match_delete(unit, &mirror_dest, match->port,
                                               match->match_vlan, match->match);
            break;
        } else
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (BCM_GPORT_IS_VXLAN_PORT(port)) {
            /* match_info translation to vxlan_port */
            bcm_vxlan_port_t_init(&vxlan_port);
            vxlan_port.criteria = BCM_VXLAN_PORT_MATCH_PORT_VLAN;
            vxlan_port.match_vlan = match->match_vlan;
            vxlan_port.vxlan_port_id = port;
            vxlan_port.match_port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_td2_vxlan_match_delete(unit, vp, vxlan_port, 0));
            break;
        } else if (BCM_GPORT_IS_MIM_PORT(port) &&
            (vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            bcm_mim_port_t mim_port;
            bcm_mim_port_t_init(&mim_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            mim_port.criteria = BCM_MIM_PORT_MATCH_PORT_VLAN;
            mim_port.match_vlan = match->match_vlan;
            mim_port.mim_port_id = port;
            mim_port.port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr2_mim_match_delete(unit,
                                 vp, mim_port));
            break;
        } else if (BCM_GPORT_IS_MPLS_PORT(port) &&
            (vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            bcm_mpls_port_t mpls_port;
            bcm_mpls_port_t_init(&mpls_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            mpls_port.criteria = BCM_MPLS_PORT_MATCH_PORT_VLAN;
            mpls_port.match_vlan = match->match_vlan;
            mpls_port.mpls_port_id = port;
            mpls_port.port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr_mpls_match_delete(unit,
                                 vp, &mpls_port, 0));
            break;
        } else if (BCM_GPORT_IS_L2GRE_PORT(port)) {
            /* match_info translation to L2GRE_port */
            bcm_l2gre_port_t_init(&l2gre_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            l2gre_port.criteria = BCM_L2GRE_PORT_MATCH_PORT_VLAN;
            l2gre_port.match_vlan = match->match_vlan;
            l2gre_port.l2gre_port_id = port;
            l2gre_port.match_port = match->port;
            BCM_IF_ERROR_RETURN(bcm_td2_l2gre_match_delete(unit,vp,
                                            &l2gre_port));
            break;
        }
#endif

        /* Add an entry in the VLAN_XLATE table */
        /* Tag actions need to be adjusted by calling the
           bcm_vlan_translate_action_add API for the entry we are creating */
        VLAN_CHK_ID(unit, match->match_vlan);
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }
        rv = _bcm_tr_vlan_translate_vp_delete(unit, gp,
                                               bcmVlanTranslateKeyPortOuter,
                                               match->match_vlan,
                                               BCM_VLAN_INVALID,
                                               vp);

        if (BCM_GPORT_IS_MIM_PORT(port)) {
#if defined(BCM_TRIUMPH2_SUPPORT)
           _bcm_tr2_mim_port_match_count_adjust(unit, vp, -1);
#endif
        } else if (BCM_GPORT_IS_MPLS_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT)
           bcm_tr_mpls_port_match_count_adjust(unit, vp, -1);
#endif
        }
        break;

    case BCM_PORT_MATCH_PORT_INNER_VLAN:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (BCM_GPORT_IS_VXLAN_PORT(port)) {
            bcm_vxlan_port_t_init(&vxlan_port);
            VLAN_CHK_ID(unit, match->match_inner_vlan);
            vxlan_port.criteria = BCM_VXLAN_PORT_MATCH_PORT_INNER_VLAN;
            vxlan_port.match_inner_vlan = match->match_inner_vlan;
            vxlan_port.vxlan_port_id = port;
            vxlan_port.match_port = match->port;

            BCM_IF_ERROR_RETURN(_bcm_td2_vxlan_match_delete(unit, vp, vxlan_port, 0));
            break;
        } else if (BCM_GPORT_IS_MPLS_PORT(port) &&
            (vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            bcm_mpls_port_t mpls_port;
            bcm_mpls_port_t_init(&mpls_port);
            VLAN_CHK_ID(unit, match->match_inner_vlan);
            mpls_port.criteria = BCM_MPLS_PORT_MATCH_PORT_INNER_VLAN;
            mpls_port.match_inner_vlan = match->match_inner_vlan;
            mpls_port.mpls_port_id = port;
            mpls_port.port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr_mpls_match_delete(unit,
                                 vp, &mpls_port, 0));
            break;
        } else if (BCM_GPORT_IS_L2GRE_PORT(port)) {
            /* match_info translation to L2GRE_port */
            bcm_l2gre_port_t_init(&l2gre_port);
            VLAN_CHK_ID(unit, match->match_inner_vlan);
            l2gre_port.criteria = BCM_L2GRE_PORT_MATCH_PORT_INNER_VLAN;
            l2gre_port.match_inner_vlan = match->match_inner_vlan;
            l2gre_port.l2gre_port_id = port;
            l2gre_port.match_port = match->port;
            BCM_IF_ERROR_RETURN(bcm_td2_l2gre_match_delete(unit, vp,
                                            &l2gre_port));
            break;
        }
#endif
        /* Add an entry in the VLAN_XLATE table */
        /* Tag actions need to be adjusted by calling the
         * bcm_vlan_translate_action_add API for the entry we are creating */
        VLAN_CHK_ID(unit, match->match_inner_vlan);
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }

        rv = _bcm_tr_vlan_translate_vp_delete(unit, gp,
                                               bcmVlanTranslateKeyPortInner,
                                               BCM_VLAN_INVALID,
                                               match->match_inner_vlan,
                                               vp);
        break;

    case BCM_PORT_MATCH_PORT_VLAN16:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (BCM_GPORT_IS_VXLAN_PORT(port) &&
            ((match->match_vlan & 0xfff) == BCM_VLAN_NONE)) {
            bcm_vxlan_port_t_init(&vxlan_port);
            vxlan_port.criteria = BCM_VXLAN_PORT_MATCH_VLAN_PRI;
            vxlan_port.match_vlan = match->match_vlan;
            vxlan_port.vxlan_port_id = port;
            vxlan_port.match_port = match->port;

            BCM_IF_ERROR_RETURN(_bcm_td2_vxlan_match_delete(unit, vp, vxlan_port, 0));
            break;
        } else if (BCM_GPORT_IS_MPLS_PORT(port) &&
            (vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            bcm_mpls_port_t mpls_port;
            bcm_mpls_port_t_init(&mpls_port);
            mpls_port.criteria = BCM_MPLS_PORT_MATCH_VLAN_PRI;
            mpls_port.match_vlan = match->match_vlan;
            mpls_port.mpls_port_id = port;
            mpls_port.port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr_mpls_match_delete(unit,
                                 vp, &mpls_port, 0));
            break;
        }  else if (BCM_GPORT_IS_L2GRE_PORT(port) &&
            ((match->match_vlan & 0xfff) == BCM_VLAN_NONE)) {
            /* match_info translation to L2GRE_port */
            bcm_l2gre_port_t_init(&l2gre_port);
            l2gre_port.criteria = BCM_L2GRE_PORT_MATCH_VLAN_PRI;
            l2gre_port.match_vlan = match->match_vlan;
            l2gre_port.l2gre_port_id = port;
            l2gre_port.match_port = match->port;
            BCM_IF_ERROR_RETURN(bcm_td2_l2gre_match_delete(unit, vp,
                                            &l2gre_port));
            break;
        }
#endif
        /* Add an entry in the VLAN_XLATE table */
        /* Tag actions need to be adjusted by calling the
           bcm_vlan_translate_action_add API for the entry we are creating */
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }
        /* allow 16 bit VLAN id */
        rv = _bcm_tr_vlan_translate_vp_delete(unit, gp,
                                               bcmVlanTranslateKeyPortOuterTag,
                                               match->match_vlan,
                                               BCM_VLAN_INVALID,
                                               vp);

        if (BCM_GPORT_IS_MIM_PORT(port)) {
#if defined(BCM_TRIUMPH2_SUPPORT)
           _bcm_tr2_mim_port_match_count_adjust(unit, vp, -1);
#endif
        } else if (BCM_GPORT_IS_MPLS_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT)
           bcm_tr_mpls_port_match_count_adjust(unit, vp, -1);
#endif
        }
        break;
    case BCM_PORT_MATCH_PORT_VLAN_STACKED:
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        if (BCM_GPORT_IS_VXLAN_PORT(port)) {
            /* match_info translation to vxlan_port */
            bcm_vxlan_port_t_init(&vxlan_port);
            vxlan_port.criteria = BCM_VXLAN_PORT_MATCH_PORT_VLAN_STACKED;
            vxlan_port.match_vlan = match->match_vlan;
            vxlan_port.match_inner_vlan = match->match_inner_vlan;
            vxlan_port.vxlan_port_id = port;
            vxlan_port.match_port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_td2_vxlan_match_delete(unit, vp, vxlan_port, 0));
            break;
        } else if (BCM_GPORT_IS_MIM_PORT(port) &&
            (vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            bcm_mim_port_t mim_port;
            bcm_mim_port_t_init(&mim_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            VLAN_CHK_ID(unit, match->match_inner_vlan);
            mim_port.criteria = BCM_MIM_PORT_MATCH_PORT_VLAN_STACKED;
            mim_port.match_vlan = match->match_vlan;
            mim_port.match_inner_vlan = match->match_inner_vlan;
            mim_port.mim_port_id = port;
            mim_port.port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr2_mim_match_delete(unit,
                                 vp, mim_port));
            break;
        } else if (BCM_GPORT_IS_MPLS_PORT(port) &&
            (vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            bcm_mpls_port_t mpls_port;
            bcm_mpls_port_t_init(&mpls_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            VLAN_CHK_ID(unit, match->match_inner_vlan);
            mpls_port.criteria = BCM_MPLS_PORT_MATCH_PORT_VLAN_STACKED;
            mpls_port.match_vlan = match->match_vlan;
            mpls_port.match_inner_vlan = match->match_inner_vlan;
            mpls_port.mpls_port_id = port;
            mpls_port.port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_tr_mpls_match_delete(unit,
                                 vp, &mpls_port, 0));
            break;
        }else if (BCM_GPORT_IS_L2GRE_PORT(port)) {
            /* match_info translation to L2GRE_port */
            bcm_l2gre_port_t_init(&l2gre_port);
            l2gre_port.criteria = BCM_L2GRE_PORT_MATCH_PORT_VLAN_STACKED;
            l2gre_port.match_vlan = match->match_vlan;
            l2gre_port.match_inner_vlan = match->match_inner_vlan;
            l2gre_port.l2gre_port_id = port;
            l2gre_port.match_port = match->port;
            BCM_IF_ERROR_RETURN(bcm_td2_l2gre_match_delete(unit, vp,
                                            &l2gre_port));
            break;
        }
#endif
        /* Add an entry in the VLAN_XLATE table */
        /* Tag actions need to be adjusted by calling the
           bcm_vlan_translate_action_add API for the entry we are creating */
        VLAN_CHK_ID(unit, match->match_vlan);
        VLAN_CHK_ID(unit, match->match_inner_vlan);
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }
        rv = _bcm_tr_vlan_translate_vp_delete(unit, gp,
                                               bcmVlanTranslateKeyPortDouble,
                                               match->match_vlan,
                                               match->match_inner_vlan,
                                               vp);

        if (BCM_GPORT_IS_MIM_PORT(port)) {
#if defined(BCM_TRIUMPH2_SUPPORT)
           _bcm_tr2_mim_port_match_count_adjust(unit, vp, -1);
#endif
        } else if (BCM_GPORT_IS_MPLS_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT)
           bcm_tr_mpls_port_match_count_adjust(unit, vp, -1);
#endif
        }
        break;
    case BCM_PORT_MATCH_PORT_VLAN_RANGE:
#if defined(BCM_TRIUMPH2_SUPPORT)
        /* Add entries in the ING_VLAN_RANGE and VLAN_XLATE tables */
        /* Tag actions need to be adjusted by calling the
           bcm_vlan_translate_action_add API for the entry we are creating */
        VLAN_CHK_ID(unit, match->match_vlan);
        VLAN_CHK_ID(unit, match->match_vlan_max);
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }
        rv = _bcm_tr2_vlan_translate_range_vp_delete(unit, gp,
                                                     match->match_vlan,
                                                     match->match_vlan_max,
                                                     BCM_VLAN_INVALID,
                                                     BCM_VLAN_INVALID,
                                                     vp);
        if (BCM_GPORT_IS_MIM_PORT(port)) {
            _bcm_tr2_mim_port_match_count_adjust(unit, vp, -1);
        } else if (BCM_GPORT_IS_MPLS_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT)
            bcm_tr_mpls_port_match_count_adjust(unit, vp, -1);
#endif
        } else if (BCM_GPORT_IS_VXLAN_PORT(port)) {
#if defined(BCM_TRIDENT2_SUPPORT)
            bcm_td2_vxlan_port_match_count_adjust(unit, vp, -1);
#endif
        }
#endif
        break;
    case BCM_PORT_MATCH_PORT_INNER_VLAN_RANGE:
#if defined(BCM_TRIUMPH2_SUPPORT)
        if (!soc_feature(unit, soc_feature_inner_vlan_range_check)) {
            return BCM_E_UNAVAIL;
        }
        /* Add entries in the ING_VLAN_RANGE and VLAN_XLATE tables */
        /* Tag actions need to be adjusted by calling the
           bcm_vlan_translate_action_add API for the entry we are creating */
        VLAN_CHK_ID(unit, match->match_inner_vlan);
        VLAN_CHK_ID(unit, match->match_inner_vlan_max);
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }
        rv = _bcm_tr2_vlan_translate_range_vp_delete(unit, gp,
                                                     BCM_VLAN_INVALID,
                                                     BCM_VLAN_INVALID,
                                                     match->match_inner_vlan,
                                                     match->match_inner_vlan_max,
                                                     vp);
        if (BCM_GPORT_IS_MIM_PORT(port)) {
            _bcm_tr2_mim_port_match_count_adjust(unit, vp, -1);
        } else if (BCM_GPORT_IS_MPLS_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT)
            bcm_tr_mpls_port_match_count_adjust(unit, vp, -1);
#endif
        }
#endif
        break;
    case BCM_PORT_MATCH_PORT_VLAN_STACKED_RANGE:
#if defined(BCM_TRIUMPH2_SUPPORT)
        if (!soc_feature(unit, soc_feature_inner_vlan_range_check)) {
            return BCM_E_UNAVAIL;
        }
        /* Add entries in the ING_VLAN_RANGE and VLAN_XLATE tables */
        /* Tag actions need to be adjusted by calling the
           bcm_vlan_translate_action_add API for the entry we are creating */
        VLAN_CHK_ID(unit, match->match_vlan);
        VLAN_CHK_ID(unit, match->match_vlan_max);
        VLAN_CHK_ID(unit, match->match_inner_vlan);
        VLAN_CHK_ID(unit, match->match_inner_vlan_max);
        if (BCM_GPORT_IS_MODPORT(match->port) ||
            BCM_GPORT_IS_TRUNK(match->port)) {
            /* Use the port from bcm_port_match_info_t instead of the physical
               port from the VP */
            gp = match->port;
        }
        rv = _bcm_tr2_vlan_translate_range_vp_delete(unit, gp,
                                                     match->match_vlan,
                                                     match->match_vlan_max,
                                                     match->match_inner_vlan,
                                                     match->match_inner_vlan_max,
                                                     vp);
        if (BCM_GPORT_IS_MIM_PORT(port)) {
            _bcm_tr2_mim_port_match_count_adjust(unit, vp, -1);
        } else if (BCM_GPORT_IS_MPLS_PORT(port)) {
#if defined(BCM_MPLS_SUPPORT)
            bcm_tr_mpls_port_match_count_adjust(unit, vp, -1);
#endif
        } else if (BCM_GPORT_IS_VXLAN_PORT(port)) {
#if defined(BCM_TRIDENT2_SUPPORT)
            bcm_td2_vxlan_port_match_count_adjust(unit, vp, -1);
#endif
        }
#endif
        break;

#if defined(BCM_TRIUMPH3_SUPPORT)
    case BCM_PORT_MATCH_PORT_EXTENDED_PORT_VID:
    case BCM_PORT_MATCH_PORT_EXTENDED_PORT_VID_VLAN:
        rv = _bcm_esw_extender_port_match_delete(unit, match->port,
                                                 match->extended_port_vid,
                                                 match->match_vlan, vp);
        break;
#endif
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    case BCM_PORT_MATCH_PORT_PCP_VLAN:
        if (BCM_GPORT_IS_VXLAN_PORT(port)) {
            /* match_info translation to vxlan_port */
            bcm_vxlan_port_t_init(&vxlan_port);
            VLAN_CHK_ID(unit, match->match_vlan);
            if ((match->match_vlan & 0x0fff) != 0) {
                return BCM_E_UNAVAIL;
            }
            vxlan_port.criteria = BCM_VXLAN_PORT_MATCH_VLAN_PRI;
            vxlan_port.match_vlan = (match->match_vlan & 0xf000);
            vxlan_port.vxlan_port_id = port;
            vxlan_port.match_port = match->port;
            BCM_IF_ERROR_RETURN(_bcm_td2_vxlan_match_delete(unit, vp, vxlan_port, 0));
            break;
        } else {
            rv = BCM_E_PARAM;
        }
        break;
#endif
#ifdef BCM_TRIUMPH2_SUPPORT
        case BCM_PORT_MATCH_PORT_PON_TUNNEL:
        case BCM_PORT_MATCH_PORT_PON_TUNNEL_VLAN:
        case BCM_PORT_MATCH_PORT_PON_TUNNEL_INNER_VLAN:
            if (!BCM_GPORT_IS_VLAN_PORT(port)) {
                return BCM_E_UNAVAIL;
            }
            if (match->port != gp) {
                return BCM_E_PORT;
            }

            VLAN_CHK_ID(unit, match->match_pon_tunnel);
            if (match->match == BCM_PORT_MATCH_PORT_PON_TUNNEL) {
                rv = _bcm_tr_lltag_vlan_translate_vp_delete(unit, gp, bcmVlanTranslateKeyPortPonTunnel,
                                                  match->match_pon_tunnel,
                                                  BCM_VLAN_INVALID,
                                                  vp);
            } else if (match->match == BCM_PORT_MATCH_PORT_PON_TUNNEL_VLAN) {
                VLAN_CHK_ID(unit, match->match_vlan);
                rv = _bcm_tr_lltag_vlan_translate_vp_delete(unit, gp, bcmVlanTranslateKeyPortPonTunnelOuter,
                                                  match->match_pon_tunnel,
                                                  match->match_vlan,
                                                  vp);
            } else if (match->match == BCM_PORT_MATCH_PORT_PON_TUNNEL_INNER_VLAN) {
                VLAN_CHK_ID(unit, match->match_pon_tunnel);
                rv = _bcm_tr_lltag_vlan_translate_vp_delete(unit, gp, bcmVlanTranslateKeyPortPonTunnelInner,
                                                  match->match_pon_tunnel,
                                                  match->match_inner_vlan,
                                                  vp);
            }

            if (BCM_FAILURE(rv)) {
                return rv;
            }

            bcm_tr2_vlan_port_match_count_adjust(unit, vp, -1);
            break;
#endif
#if defined(BCM_TRIDENT_SUPPORT)
    case BCM_PORT_MATCH_PORT_NIV_PORT_VIF:
    case BCM_PORT_MATCH_PORT_NIV_PORT_VIF_VLAN:
        rv = _bcm_trident_niv_match_delete(unit, match->port,
                                           match->niv_port_vif,
                                           match->match_vlan, NULL);
    break;
#endif /* BCM_TRIDENT_SUPPORT */
#if defined(BCM_TRX_SUPPORT)
    case BCM_PORT_MATCH_MAC_PORT:
    case BCM_PORT_MATCH_MAC_PORT_CLASS:
        bcm_vlan_match_info_t_init(&vlan_match_info);
        if (match->match == BCM_PORT_MATCH_MAC_PORT) {
            vlan_match_info.match = BCM_VLAN_MATCH_MAC_PORT;
            vlan_match_info.port = match->port;
        } else if (match->match == BCM_PORT_MATCH_MAC_PORT_CLASS) {
            vlan_match_info.match = BCM_VLAN_MATCH_MAC_PORT_CLASS;
            vlan_match_info.port_class = match->port_class;
        }
        sal_memcpy(vlan_match_info.src_mac,
                match->src_mac, sizeof (bcm_mac_t));
        rv = _bcm_trx_vlan_match_action_delete(unit,
                port, &vlan_match_info);
        break;
#endif
    default:
        rv = BCM_E_PARAM;
        break;
    }
    return rv;
#else
    return BCM_E_UNAVAIL;
#endif
}

/*
 * Function:
 *      bcm_port_match_replace
 * Purpose:
 *      Replace an old match with a new one for an existing port
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port or gport
 *      old_match - (IN) Old match criteria
 *      new_match - (IN) New match criteria
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_match_replace(
    int unit,
    bcm_gport_t port,
    bcm_port_match_info_t *old_match,
    bcm_port_match_info_t *new_match)
{
#if defined(BCM_TRIUMPH_SUPPORT) && defined(INCLUDE_L3)
    int rv = BCM_E_NONE;
    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    rv = bcm_esw_port_match_delete(unit, port, old_match);
    if (BCM_SUCCESS(rv)) {
        rv = bcm_esw_port_match_add(unit, port, new_match);
    }
    return rv;
#else
    return BCM_E_UNAVAIL;
#endif
}

extern void
_bcm_trx_vlan_range_profile_entry_get(int unit, bcm_vlan_t *min_vlan,
                                     bcm_vlan_t *max_vlan, uint32 index);

int _bcm_esw_port_vp_gport_check(bcm_gport_t port,
    int vp)
{
    int matched = 0;
    if (BCM_GPORT_IS_MIM_PORT(port)) {
            if (vp == BCM_GPORT_MIM_PORT_ID_GET(port)) {
                matched = 1;
            }
        } else if (BCM_GPORT_IS_MPLS_PORT(port)) {
            if (vp == BCM_GPORT_MPLS_PORT_ID_GET(port)) {
                matched = 1;
            }
        }
#if defined(BCM_TRIDENT2_SUPPORT)
        else if (BCM_GPORT_IS_VXLAN_PORT(port)) {
            if (vp == BCM_GPORT_VXLAN_PORT_ID_GET(port)) {
                matched = 1;
            }
        }
#endif
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
        else if (BCM_GPORT_IS_L2GRE_PORT(port)) {
            if (vp == BCM_GPORT_L2GRE_PORT_ID_GET(port)) {
                matched = 1;
            }
        }
#endif
#if defined(BCM_TRIUMPH2_SUPPORT)
        else if(BCM_GPORT_IS_VLAN_PORT(port)) {
            if (vp == BCM_GPORT_VLAN_PORT_ID_GET(port)) {
                matched = 1;
            }
        }
#endif
    return matched;
}
/*
 * Function:
 *      bcm_port_match_multi_get
 * Purpose:
 *      Get all the matches for an existing port
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port or gport
 *      size - (IN) Number of elements in match array
 *      match_array - (OUT) Match array
 *      count - (OUT) Match count
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_match_multi_get(
    int unit,
    bcm_gport_t port,
    int size,
    bcm_port_match_info_t *match_array,
    int *count)
{
#if defined(BCM_TRIUMPH2_SUPPORT) && defined(INCLUDE_L3)
    int id, vp, prof_idx, i, j, index_min, index_max, ctr, rv = BCM_E_NONE;
    int stm_idx = 0;
    int key_type_value = 0, key_type = 0;
    uint32 matched;
    uint8 *vlan_xlate_buf = NULL; /* VLAN_XLATE DMA buffer */
    uint8 *source_trunk_map_buf = NULL; /* SOURCE_TRUNK_MAP DMA buffer */
    source_trunk_map_table_entry_t *source_trunk_map;
    bcm_gport_t gp;
    bcm_vlan_t min_vlan[8], max_vlan[8];
    bcm_module_t mod_out, mod_in;
    bcm_port_t port_out, port_in;
    bcm_trunk_t trunk_id;
    int mpls_action;
    soc_mem_t mem;
#if defined(BCM_TRIUMPH3_SUPPORT)
    vlan_xlate_entry_t vent;
#endif
    bcm_vlan_action_set_t *action;
    int profile_idx;
    void *entry;

    bcm_trunk_member_t *member_array = NULL;

    /* Parameter checks */
    if ((size < 0) || (count == NULL)) {
        return BCM_E_PARAM;
    }
    if ((size > 0) && (match_array == NULL)) {
        return BCM_E_PARAM;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (BCM_GPORT_IS_MIM_PORT(port)) {
        if (!soc_feature(unit, soc_feature_mim)) {
            return BCM_E_UNAVAIL;
        }
        vp = BCM_GPORT_MIM_PORT_ID_GET(port);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMim)) {
            return BCM_E_NOT_FOUND;
        }
        BCM_IF_ERROR_RETURN(_bcm_tr2_mim_port_phys_gport_get(unit, vp, &gp));
    } else if  (BCM_GPORT_IS_MPLS_PORT(port)) {
        if (!soc_feature(unit, soc_feature_mpls)) {
            return BCM_E_UNAVAIL;
        }
        vp = BCM_GPORT_MPLS_PORT_ID_GET(port);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeMpls)) {
            return BCM_E_NOT_FOUND;
        }
#if defined(BCM_MPLS_SUPPORT)
        BCM_IF_ERROR_RETURN(bcm_tr_mpls_port_phys_gport_get(unit, vp, &gp));
#endif

    } else
#if defined(BCM_TRIDENT2_SUPPORT)
    if (BCM_GPORT_IS_TRUNK(port)) {
        if (!soc_feature(unit, soc_feature_vp_lag)) {
            return BCM_E_UNAVAIL;
        }
        return _bcm_esw_trunk_match_multi_get(unit, BCM_GPORT_TRUNK_GET(port),
                                              size, match_array, count);
    } else
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (BCM_GPORT_IS_VXLAN_PORT(port)) {

        vp = BCM_GPORT_VXLAN_PORT_ID_GET(port);
        if (!(_bcm_vp_used_get(unit, vp, _bcmVpTypeVxlan))) {
            return BCM_E_NOT_FOUND;
        }

        BCM_GPORT_VXLAN_PORT_ID_SET(gp,vp);
    } else
#endif
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
    if (BCM_GPORT_IS_L2GRE_PORT(port)) {
        _bcm_vp_info_t vp_info;

        if (!soc_feature(unit, soc_feature_vp_sharing)) {
            return BCM_E_UNAVAIL;
        }
        vp = BCM_GPORT_L2GRE_PORT_ID_GET(port);

        BCM_IF_ERROR_RETURN(_bcm_vp_info_get(unit, vp, &vp_info));
        if (!(vp_info.flags & _BCM_VP_INFO_SHARED_PORT)) {
            return BCM_E_NOT_FOUND;
        }

        BCM_GPORT_L2GRE_PORT_ID_SET(gp,vp);
    } else
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
#if defined(BCM_TRIUMPH2_SUPPORT)
    if (BCM_GPORT_IS_VLAN_PORT(port)) {
        if (!soc_feature(unit, soc_feature_lltag)) {
            return BCM_E_UNAVAIL;
        }
        vp = BCM_GPORT_VLAN_PORT_ID_GET(port);
        if (!_bcm_vp_used_get(unit, vp, _bcmVpTypeVlan)) {
            return BCM_E_NOT_FOUND;
        }
        BCM_IF_ERROR_RETURN(bcm_tr2_vlan_port_phys_gport_get(unit, vp, &gp));
    } else
#endif
#if defined(BCM_TRIDENT_SUPPORT)
    if (BCM_GPORT_IS_NIV_PORT(port)) {
        if (!soc_feature(unit, soc_feature_niv)) {
            return BCM_E_UNAVAIL;
        }
        return _bcm_td_port_vif_match_multi_get(unit, port,
                                                size, match_array, count);
    } else
#endif /* BCM_TRIDENT_SUPPORT */
#if defined(BCM_TRIDENT3_SUPPORT)
    if (BCM_GPORT_IS_MIRROR(port)) {
        if (!soc_feature(unit, soc_feature_mirror_encap_profile)) {
            return BCM_E_UNAVAIL;
        }
        return _bcm_mirror_port_match_multi_get(unit, port, size, match_array,
                                                count);
    } else
#endif /* BCM_TRIDENT3_SUPPORT */
    {
        return BCM_E_PORT;
    }

    rv = _bcm_esw_gport_resolve(unit, gp, &mod_out, &port_out, &trunk_id, &id);
    if (BCM_FAILURE(rv)) {
        goto cleanup;
    }
#if defined(BCM_TRIUMPH3_SUPPORT)
    if (SOC_IS_TRIUMPH3(unit)) {
        mem = VLAN_XLATE_EXTDm;
    } else
#endif
#if defined(BCM_TRIDENT3_SUPPORT)
    if (SOC_MEM_IS_VALID(unit, VLAN_XLATE_1_DOUBLEm)) {
        mem = VLAN_XLATE_1_DOUBLEm;
    } else
#endif
    {
        mem = VLAN_XLATEm;
    }

    /* DMA the relevant tables for traversal */
    vlan_xlate_buf = soc_cm_salloc(unit, SOC_MEM_TABLE_BYTES(unit, mem),
                              "VLAN_XLATE buffer");
    if (NULL == vlan_xlate_buf) {
        rv = BCM_E_MEMORY;
        goto cleanup;
    }

    index_min = soc_mem_index_min(unit, mem);
    index_max = soc_mem_index_max(unit, mem);
    if ((rv = soc_mem_read_range(unit, mem, MEM_BLOCK_ANY,
                                 index_min, index_max,
                                 vlan_xlate_buf)) < 0 ) {
        goto cleanup;
    }
    source_trunk_map_buf = soc_cm_salloc(unit, SOC_MEM_TABLE_BYTES
                                 (unit, SOURCE_TRUNK_MAP_TABLEm),
                                 "SOURCE_TRUNK_MAP_TABLE buffer");
    if (NULL == source_trunk_map_buf) {
        rv = BCM_E_MEMORY;
        goto cleanup;
    }
    index_min = soc_mem_index_min(unit, SOURCE_TRUNK_MAP_TABLEm);
    index_max = soc_mem_index_max(unit, SOURCE_TRUNK_MAP_TABLEm);
    if ((rv = soc_mem_read_range(unit, SOURCE_TRUNK_MAP_TABLEm, MEM_BLOCK_ANY,
                                 index_min, index_max,
                                 source_trunk_map_buf)) < 0 ) {
        goto cleanup;
    }

    ctr = 0;
    /* Get all VLAN_XLATE matches */
    index_min = soc_mem_index_min(unit, mem);
    index_max = soc_mem_index_max(unit, mem);
    for (i = index_min; i <= index_max; i++) {
        if ((size != 0) && (size <= ctr)) {
            break;
        }
        if (SOC_IS_TRIUMPH3(unit)) {
            mem = VLAN_XLATE_EXTDm;
        }
        entry = soc_mem_table_idx_to_pointer
                (unit, mem, void *, vlan_xlate_buf, i);
#if defined(BCM_TRIUMPH3_SUPPORT)
        if (SOC_IS_TRIUMPH3(unit)) {
            int key_type;

            /* double wide entry should always start at double wide boundary */
            key_type = soc_mem_field32_get(unit, mem, entry, KEY_TYPE_0f);

            /* if key type is odd number, then it is double wide entry */
            if (!(key_type & 1)) {
                continue;
            }
            mpls_action = soc_mem_field32_get(unit, mem, entry, MPLS_ACTIONf);
            vp = soc_mem_field32_get(unit, mem, entry, SOURCE_VPf);
            sal_memset(&vent, 0, sizeof(vent));
            rv = _bcm_tr3_vxlate_extd2vxlate(unit, (vlan_xlate_extd_entry_t *)entry, &vent, 0);
            if (rv != BCM_E_NONE) {
                goto cleanup;
            }
            entry = &vent;
            mem = VLAN_XLATEm;
        } else
#endif  /* BCM_TRIUMPH3_SUPPORT */
        {
            mpls_action = soc_mem_field32_get(unit, mem, entry, MPLS_ACTIONf);
            vp = soc_mem_field32_get(unit, mem, entry, SOURCE_VPf);
        }

#if defined(BCM_TRIDENT3_SUPPORT)
        if (SOC_MEM_IS_VALID(unit, VLAN_XLATE_1_DOUBLEm)) {
            if (soc_mem_field32_get(unit, mem, entry, BASE_VALID_0f) != 3) {
                continue;
            }
            if (soc_mem_field32_get(unit, mem, entry, BASE_VALID_1f) != 7) {
                continue;
            }
        }
#endif

        if (SOC_MEM_FIELD_VALID(unit, mem, VALIDf)) {
            if (soc_mem_field32_get(unit, mem, entry, VALIDf) == 0) {
                continue;
            }
        }

        if (!(mpls_action & 0x1)) {
            continue; /* Entry is not for an SVP */
        }

        key_type_value = (int)soc_mem_field32_get(unit, mem, entry, KEY_TYPEf);

        rv = _bcm_esw_vlan_xlate_key_type_get(unit,key_type_value,&key_type);
        if (rv != BCM_E_NONE) {
            goto cleanup;
        }

        matched = _bcm_esw_port_vp_gport_check(port, vp);

        if (matched) {
            soc_field_t field;
            int port_count;
            int tid;
            int gport_id;
            int outer_vlan_range_found = 0, inner_vlan_range_found = 0;
            ctr++;
            if (size >= ctr) {
                switch (key_type) {
                case VLXLT_HASH_KEY_TYPE_OVID:
                    match_array->match = BCM_PORT_MATCH_PORT_VLAN;
                    match_array->match_vlan =
                        soc_mem_field32_get(unit, mem, entry, XLATE__OVIDf);
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
                    if (SOC_MEM_FIELD_VALID(unit, mem, VFIf)) {
                        if (soc_feature(unit, soc_feature_vfi_zero_invalid) &&
                            (soc_mem_field32_get(unit, mem, entry, XLATE__VFIf)) == 0) {
                            match_array->vpn = 0;
                        } else {
                            _BCM_VXLAN_VPN_SET(match_array->vpn, _BCM_VPN_TYPE_VFI,
                                soc_mem_field32_get(unit, mem, entry, XLATE__VFIf));
                        }
                    } else {
                        match_array->vpn = 0;
                    }
#endif
                    /* Check if this match is a VLAN range match */
                    if (BCM_TRUNK_INVALID != trunk_id) {
                        rv = bcm_esw_trunk_get(unit, trunk_id, NULL, 0, NULL,
                                               &port_count);
                        if (BCM_FAILURE(rv)) {
                            goto cleanup;
                        }

                        member_array = sal_alloc(sizeof(bcm_trunk_member_t) * port_count,
                                "trunk member array");
                        if (member_array == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }
                        sal_memset(member_array, 0, sizeof(bcm_trunk_member_t) * port_count);

                        rv = bcm_esw_trunk_get(unit, trunk_id, NULL, port_count,
                                member_array, &port_count);
                        if (BCM_FAILURE(rv)) {
                            goto cleanup;
                        }

                        rv = _bcm_esw_gport_resolve(unit, member_array[0].gport,
                                &mod_out, &port_out, &tid, &gport_id);
                        if (BCM_FAILURE(rv)) {
                            goto cleanup;
                        }

                    }
                    rv = _bcm_esw_src_mod_port_table_index_get(
                                unit, mod_out, port_out, &stm_idx);
                    if (BCM_FAILURE(rv)) {
                        goto cleanup;
                    }

                    source_trunk_map = soc_mem_table_idx_to_pointer
                                          (unit, SOURCE_TRUNK_MAP_TABLEm,
                                           source_trunk_map_table_entry_t *,
                                           source_trunk_map_buf, stm_idx);
                    if (SOC_MEM_FIELD_VALID(unit, SOURCE_TRUNK_MAP_TABLEm,
                        OUTER_VLAN_RANGE_IDXf)) {
                        field = OUTER_VLAN_RANGE_IDXf;
                    } else {
                        field = VLAN_RANGE_IDXf;
                    }
                    prof_idx = soc_SOURCE_TRUNK_MAP_TABLEm_field32_get(unit,
                                         source_trunk_map, field);
                    _bcm_trx_vlan_range_profile_entry_get(unit, min_vlan,
                                                        max_vlan, prof_idx);
                    for (j = 0; j < 8; j++) {
                        if (min_vlan[j] == match_array->match_vlan) {
                            match_array->match_vlan_max = max_vlan[j];
                            match_array->match =
                                       BCM_PORT_MATCH_PORT_VLAN_RANGE;
                            break; /* Found a VLAN range match */
                        }
                    }
                    if (j == 8) {
                        match_array->match = BCM_PORT_MATCH_PORT_VLAN;
                    }
                    if (soc_mem_field32_get(unit, mem, entry, XLATE__Tf)) {
                        trunk_id = soc_mem_field32_get(unit, mem, entry, XLATE__TGIDf);
                        BCM_GPORT_TRUNK_SET(gp, trunk_id);
                    } else {
                        mod_in = soc_mem_field32_get(unit, mem, entry, XLATE__MODULE_IDf);
                        port_in = soc_mem_field32_get(unit, mem, entry, XLATE__PORT_NUMf);

                        rv = _bcm_esw_stk_modmap_map(unit, BCM_STK_MODMAP_GET,
                                        mod_in, port_in, &mod_out, &port_out);
                        BCM_GPORT_MODPORT_SET(gp, mod_out, port_out);
                    }
                    match_array->port = gp;
                    match_array++;
                    break;
                case VLXLT_HASH_KEY_TYPE_IVID:
                    match_array->match = BCM_PORT_MATCH_PORT_INNER_VLAN;
                    match_array->match_inner_vlan =
                        soc_mem_field32_get(unit, mem, entry, XLATE__IVIDf);

#if defined(BCM_TRIDENT2PLUS_SUPPORT)
                    if (SOC_MEM_FIELD_VALID(unit, mem, VFIf)) {
                        if (soc_feature(unit, soc_feature_vfi_zero_invalid) &&
                            (soc_mem_field32_get(unit, mem, entry, XLATE__VFIf) == 0)) {

                            match_array->vpn = 0;
                        } else {
                            _BCM_VXLAN_VPN_SET(match_array->vpn, _BCM_VPN_TYPE_VFI,
                                soc_mem_field32_get(unit, mem, entry, XLATE__VFIf));

                        }
                    } else {
                        match_array->vpn = 0;
                    }
#endif
                    /* Check if this match is a VLAN range match */
                    if (BCM_TRUNK_INVALID != trunk_id) {
                        rv = bcm_esw_trunk_get(unit, trunk_id, NULL, 0, NULL,
                                               &port_count);
                        if (BCM_FAILURE(rv)) {
                            goto cleanup;
                        }

                        member_array = sal_alloc(sizeof(bcm_trunk_member_t) * port_count,
                                "trunk member array");
                        if (member_array == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }
                        sal_memset(member_array, 0, sizeof(bcm_trunk_member_t) * port_count);

                        rv = bcm_esw_trunk_get(unit, trunk_id, NULL, port_count,
                                member_array, &port_count);
                        if (BCM_FAILURE(rv)) {
                            goto cleanup;
                        }

                        rv = _bcm_esw_gport_resolve(unit, member_array[0].gport,
                                &mod_out, &port_out, &tid, &gport_id);
                        if (BCM_FAILURE(rv)) {
                            goto cleanup;
                        }

                    }

                    if (SOC_MEM_FIELD_VALID(unit, SOURCE_TRUNK_MAP_TABLEm,
                        INNER_VLAN_RANGE_IDXf)) {
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_HURRICANE3_SUPPORT)
                        if (soc_feature(unit, soc_feature_src_modid_base_index)) {
                            int is_local;
                            bcm_module_t modid = mod_out;

                            rv = _bcm_esw_stk_modmap_map(
                                    unit, BCM_STK_MODMAP_SET, modid, -1,
                                    &mod_out, NULL);
                            if (BCM_SUCCESS(rv)) {
                                rv = _bcm_esw_modid_is_local(unit, mod_out,
                                                             &is_local);
                            }
                            if (BCM_SUCCESS(rv)) {
                                rv = _bcm_esw_src_modid_base_index_get(
                                        unit, modid, is_local, &stm_idx);
                            }
                            if (BCM_FAILURE(rv)) {
                                goto cleanup;
                            }
                            stm_idx += port_out;
                        } else
#endif /* BCM_TRIDENT_SUPPORT || BCM_HURRICANE3_SUPPORT */
                        {
                            stm_idx = (mod_out * (SOC_PORT_ADDR_MAX(unit) + 1))
                                       + port_out;
                        }
                        source_trunk_map =
                            soc_mem_table_idx_to_pointer(unit, SOURCE_TRUNK_MAP_TABLEm,
                                                         source_trunk_map_table_entry_t *,
                                                         source_trunk_map_buf,
                                                         stm_idx);
                        field = INNER_VLAN_RANGE_IDXf;
                        prof_idx = soc_SOURCE_TRUNK_MAP_TABLEm_field32_get(unit,
                                             source_trunk_map, field);
                        _bcm_trx_vlan_range_profile_entry_get(unit, min_vlan,
                                                            max_vlan, prof_idx);
                        for (j = 0; j < 8; j++) {
                            if (min_vlan[j] == match_array->match_inner_vlan) {
                                match_array->match_inner_vlan_max = max_vlan[j];
                                match_array->match =
                                           BCM_PORT_MATCH_PORT_INNER_VLAN_RANGE;
                                break; /* Found a VLAN range match */
                            }
                        }
                    }
                    if (soc_mem_field32_get(unit, mem, entry, XLATE__Tf)) {
                        trunk_id = soc_mem_field32_get(unit, mem, entry, XLATE__TGIDf);
                        BCM_GPORT_TRUNK_SET(gp, trunk_id);
                    } else {
                        mod_in = soc_mem_field32_get(unit, mem, entry, XLATE__MODULE_IDf);
                        port_in = soc_mem_field32_get(unit, mem, entry, XLATE__PORT_NUMf);

                        rv = _bcm_esw_stk_modmap_map(unit, BCM_STK_MODMAP_GET,
                                        mod_in, port_in, &mod_out, &port_out);
                        BCM_GPORT_MODPORT_SET(gp, mod_out, port_out);
                    }
                    match_array->port = gp;
                    match_array++;
                    break;
                case VLXLT_HASH_KEY_TYPE_PRI_CFI:
                    match_array->match = BCM_PORT_MATCH_PORT_VLAN16;
                    match_array->match_vlan =
                        soc_mem_field32_get(unit, mem, entry, OTAGf);
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
                    if (SOC_MEM_FIELD_VALID(unit, mem, VFIf)) {
                        if (soc_feature(unit, soc_feature_vfi_zero_invalid) &&
                            (soc_mem_field32_get(unit, mem, entry, VFIf) == 0)) {
                            match_array->vpn = 0;
                        } else {
                            _BCM_VXLAN_VPN_SET(match_array->vpn, _BCM_VPN_TYPE_VFI,
                                soc_mem_field32_get(unit, mem, entry, VFIf));
                        }
                    } else {
                        match_array->vpn = 0;
                    }
#endif
                    if (soc_mem_field32_get(unit, mem, entry, Tf)) {
                        trunk_id = soc_mem_field32_get(unit, mem, entry, TGIDf);
                        BCM_GPORT_TRUNK_SET(gp, trunk_id);
                    } else {
                        mod_in = soc_mem_field32_get(unit, mem, entry, MODULE_IDf);
                        port_in = soc_mem_field32_get(unit, mem, entry, PORT_NUMf);

                        rv = _bcm_esw_stk_modmap_map(unit, BCM_STK_MODMAP_GET,
                                        mod_in, port_in, &mod_out, &port_out);
                        BCM_GPORT_MODPORT_SET(gp, mod_out, port_out);
                    }
                    match_array->port = gp;
                    match_array++;
                    break;
                case VLXLT_HASH_KEY_TYPE_IVID_OVID:
                    match_array->match = BCM_PORT_MATCH_PORT_VLAN_STACKED;
                    match_array->match_vlan =
                        soc_mem_field32_get(unit, mem, entry, OVIDf);
                    match_array->match_inner_vlan =
                        soc_mem_field32_get(unit, mem, entry, IVIDf);
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
                    if (SOC_MEM_FIELD_VALID(unit, mem, VFIf)) {
                        if (soc_feature(unit, soc_feature_vfi_zero_invalid) &&
                            (soc_mem_field32_get(unit, mem, entry, VFIf) == 0)) {
                            match_array->vpn = 0;
                        } else {
                            _BCM_VXLAN_VPN_SET(match_array->vpn, _BCM_VPN_TYPE_VFI,
                                soc_mem_field32_get(unit, mem, entry, VFIf));
                        }
                    } else {
                        match_array->vpn = 0;
                    }
#endif

                    /* Check if this match is a VLAN range match */
                    if (BCM_TRUNK_INVALID != trunk_id) {
                        rv = bcm_esw_trunk_get(unit, trunk_id, NULL, 0, NULL,
                                               &port_count);
                        if (BCM_FAILURE(rv)) {
                            goto cleanup;
                        }

                        member_array = sal_alloc(sizeof(bcm_trunk_member_t) * port_count,
                                "trunk member array");
                        if (member_array == NULL) {
                            rv = BCM_E_MEMORY;
                            goto cleanup;
                        }
                        sal_memset(member_array, 0, sizeof(bcm_trunk_member_t) * port_count);

                        rv = bcm_esw_trunk_get(unit, trunk_id, NULL, port_count,
                                member_array, &port_count);
                        if (BCM_FAILURE(rv)) {
                            goto cleanup;
                        }

                        rv = _bcm_esw_gport_resolve(unit, member_array[0].gport,
                                &mod_out, &port_out, &tid, &gport_id);
                        if (BCM_FAILURE(rv)) {
                            goto cleanup;
                        }

                    }
                    if (SOC_MEM_FIELD_VALID(unit, SOURCE_TRUNK_MAP_TABLEm,
                        OUTER_VLAN_RANGE_IDXf)) {
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_HURRICANE3_SUPPORT)
                        if (soc_feature(unit, soc_feature_src_modid_base_index)) {
                            int is_local;
                            bcm_module_t modid = mod_out;

                            rv = _bcm_esw_stk_modmap_map(
                                    unit, BCM_STK_MODMAP_SET, modid, -1,
                                    &mod_out, NULL);
                            if (BCM_SUCCESS(rv)) {
                                rv = _bcm_esw_modid_is_local(unit, mod_out,
                                                             &is_local);
                            }
                            if (BCM_SUCCESS(rv)) {
                                rv = _bcm_esw_src_modid_base_index_get(
                                        unit, modid, is_local, &stm_idx);
                            }
                            if (BCM_FAILURE(rv)) {
                                goto cleanup;
                            }
                            stm_idx += port_out;
                        } else
#endif /* BCM_TRIDENT_SUPPORT || BCM_HURRICANE3_SUPPORT */
                        {
                            stm_idx = (mod_out * (SOC_PORT_ADDR_MAX(unit) + 1))
                                       + port_out;
                        }
                        source_trunk_map =
                            soc_mem_table_idx_to_pointer(unit, SOURCE_TRUNK_MAP_TABLEm,
                                                         source_trunk_map_table_entry_t *,
                                                         source_trunk_map_buf,
                                                         stm_idx);
                        field = OUTER_VLAN_RANGE_IDXf;
                        prof_idx = soc_SOURCE_TRUNK_MAP_TABLEm_field32_get(unit,
                                             source_trunk_map, field);
                        _bcm_trx_vlan_range_profile_entry_get(unit, min_vlan,
                                                            max_vlan, prof_idx);
                        for (j = 0; j < 8; j++) {
                            if (min_vlan[j] == match_array->match_vlan) {
                                match_array->match_vlan_max = max_vlan[j];
                                outer_vlan_range_found = 1;
                                break; /* Found a VLAN range match */
                            }
                        }
                    }

                    if (SOC_MEM_FIELD_VALID(unit, SOURCE_TRUNK_MAP_TABLEm,
                        INNER_VLAN_RANGE_IDXf)) {
#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_HURRICANE3_SUPPORT)
                        if (soc_feature(unit, soc_feature_src_modid_base_index)) {
                            int is_local;
                            bcm_module_t modid = mod_out;

                            rv = _bcm_esw_stk_modmap_map(
                                    unit, BCM_STK_MODMAP_SET, modid, -1,
                                    &mod_out, NULL);
                            if (BCM_SUCCESS(rv)) {
                                rv = _bcm_esw_modid_is_local(unit, mod_out,
                                                             &is_local);
                            }
                            if (BCM_SUCCESS(rv)) {
                                rv = _bcm_esw_src_modid_base_index_get(
                                        unit, modid, is_local, &stm_idx);
                            }
                            if (BCM_FAILURE(rv)) {
                                goto cleanup;
                            }
                            stm_idx += port_out;
                        } else
#endif /* BCM_TRIDENT_SUPPORT || BCM_HURRICANE3_SUPPORT */
                        {
                            stm_idx = (mod_out * (SOC_PORT_ADDR_MAX(unit) + 1))
                                       + port_out;
                        }
                        source_trunk_map =
                            soc_mem_table_idx_to_pointer(unit, SOURCE_TRUNK_MAP_TABLEm,
                                                         source_trunk_map_table_entry_t *,
                                                         source_trunk_map_buf,
                                                         stm_idx);
                        field = INNER_VLAN_RANGE_IDXf;
                        prof_idx = soc_SOURCE_TRUNK_MAP_TABLEm_field32_get(unit,
                                             source_trunk_map, field);
                        _bcm_trx_vlan_range_profile_entry_get(unit, min_vlan,
                                                            max_vlan, prof_idx);
                        for (j = 0; j < 8; j++) {
                            if (min_vlan[j] == match_array->match_inner_vlan) {
                                match_array->match_inner_vlan_max = max_vlan[j];
                                inner_vlan_range_found = 1;
                                break; /* Found a VLAN range match */
                            }
                        }
                    }
                    if (inner_vlan_range_found && outer_vlan_range_found) {
                        match_array->match = BCM_PORT_MATCH_PORT_VLAN_STACKED_RANGE;
                    }

                    if (soc_mem_field32_get(unit, mem, entry, Tf)) {
                        trunk_id = soc_mem_field32_get(unit, mem, entry, TGIDf);
                        BCM_GPORT_TRUNK_SET(gp, trunk_id);
                    } else {
                        mod_in = soc_mem_field32_get(unit, mem, entry, MODULE_IDf);
                        port_in = soc_mem_field32_get(unit, mem, entry, PORT_NUMf);

                        rv = _bcm_esw_stk_modmap_map(unit, BCM_STK_MODMAP_GET,
                                        mod_in, port_in, &mod_out, &port_out);
                        BCM_GPORT_MODPORT_SET(gp, mod_out, port_out);
                    }
                    match_array->port = gp;
                    match_array++;
                    break;
#if defined (BCM_TRIUMPH2_SUPPORT)
                case VLXLT_HASH_KEY_TYPE_LLVID:
                case VLXLT_HASH_KEY_TYPE_LLVID_OVID:
                case VLXLT_HASK_KEY_TYPE_LLVID_IVID:
                    if (key_type == VLXLT_HASH_KEY_TYPE_LLVID) {
                        match_array->match = BCM_PORT_MATCH_PORT_PON_TUNNEL;
                    } else if (key_type == VLXLT_HASH_KEY_TYPE_LLVID_OVID) {
                        match_array->match = BCM_PORT_MATCH_PORT_PON_TUNNEL_VLAN;
                    } else {
                        match_array->match = BCM_PORT_MATCH_PORT_PON_TUNNEL_INNER_VLAN;
                    }

                    match_array->match_pon_tunnel =
                        soc_mem_field32_get(unit, mem, entry, LLTAG__LLVIDf);
                    match_array->match_inner_vlan =
                        soc_mem_field32_get(unit, mem, entry, LLTAG__IVIDf);
                    match_array->match_vlan =
                        soc_mem_field32_get(unit, mem, entry, LLTAG__OVIDf);

                    if (soc_mem_field32_get(unit, mem, entry, Tf)) {
                        trunk_id = soc_mem_field32_get(unit, mem, entry, TGIDf);
                        BCM_GPORT_TRUNK_SET(gp, trunk_id);
                    } else {
                        mod_in = soc_mem_field32_get(unit, mem, entry, MODULE_IDf);
                        port_in = soc_mem_field32_get(unit, mem, entry, PORT_NUMf);

                        rv = _bcm_esw_stk_modmap_map(unit, BCM_STK_MODMAP_GET,
                                        mod_in, port_in, &mod_out, &port_out);
                        BCM_GPORT_MODPORT_SET(gp, mod_out, port_out);
                    }

                    if (match_array->action != NULL) {
                        action = match_array->action;
                        action->new_outer_vlan =
                            soc_mem_field32_get(unit, mem, entry, NEW_OVIDf);
                        action->new_inner_vlan =
                            soc_mem_field32_get(unit, mem, entry, NEW_IVIDf);
                        if (soc_feature(unit, soc_feature_vlan_pri_cfi_action)) {
                            action->priority =
                                    soc_mem_field32_get(unit, mem, entry, NEW_OPRIf);
                            action->new_outer_cfi =
                                    soc_mem_field32_get(unit, mem, entry, NEW_OCFIf);
                            action->new_inner_pkt_prio =
                                    soc_mem_field32_get(unit, mem, entry, NEW_IPRIf);
                            action->new_inner_cfi =
                                    soc_mem_field32_get(unit, mem, entry, NEW_ICFIf);
                        }
                        profile_idx = soc_mem_field32_get(unit, mem, entry, TAG_ACTION_PROFILE_PTRf);
                        _bcm_trx_vlan_action_profile_entry_get(unit, action, profile_idx);
                    }
                    match_array->port = gp;
                    match_array++;
                    break;
#endif
                default:
                    break;
                }
            }
        }
    }

#if defined(BCM_TRX_SUPPORT)
    /* Get the list from VLAN_MACm */
    if (BCM_SUCCESS(rv)) {
        rv = _bcm_vlan_match_action_multi_get(unit,
                port, size, match_array, ctr, &ctr);
    }
#endif

    *count = ctr;

cleanup:
    if (vlan_xlate_buf) {
        soc_cm_sfree(unit, vlan_xlate_buf);
    }
    if (source_trunk_map_buf) {
        soc_cm_sfree(unit, source_trunk_map_buf);
    }
    if (member_array) {
        sal_free(member_array);
    }
    return rv;
#else
    return BCM_E_UNAVAIL;
#endif
}

/*
 * Function:
 *      bcm_port_match_set
 * Purpose:
 *      Assign a set of matches to an existing port
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port or gport
 *      size - (IN) Number of elements in match array
 *      match_array - (IN) Match array
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_match_set(
    int unit,
    bcm_gport_t port,
    int size,
    bcm_port_match_info_t *match_array)
{
#if defined(BCM_TRIUMPH_SUPPORT) && defined(INCLUDE_L3)
    int i, rv = BCM_E_NONE;
    if ((size <= 0) || (match_array == NULL)) {
        return BCM_E_PARAM;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Add every single match */
    for (i = 0; i < size; i++) {
        rv = bcm_esw_port_match_add(unit, port, match_array + i);
        if (BCM_FAILURE(rv)) {
            return rv;
        }
    }
    return rv;
#else
    return BCM_E_UNAVAIL;
#endif
}

/*
 * Function:
 *      bcm_port_match_delete_all
 * Purpose:
 *      Delete all matches for an existing port
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port or gport
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_match_delete_all(
    int unit,
    bcm_gport_t port)
{
#if defined(BCM_TRIUMPH_SUPPORT) && defined(INCLUDE_L3)
    int i, size, count, rv = BCM_E_NONE;
    bcm_port_match_info_t *match_array = NULL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* First get number of entries */
    rv = bcm_esw_port_match_multi_get(unit, port, 0, match_array, &count);
    if (BCM_FAILURE(rv) || (count == 0)) {
        return rv;
    }
    match_array = sal_alloc(sizeof(bcm_port_match_info_t) * count,
                            "match_array");
    if (match_array == NULL) {
        return BCM_E_MEMORY;
    }
    sal_memset(match_array, 0, sizeof(bcm_port_match_info_t) * count);

    /* Get all matches */
    size = count;
    rv = bcm_esw_port_match_multi_get(unit, port, size, match_array, &count);
    if (BCM_FAILURE(rv)) {
        sal_free(match_array);
        return rv;
    }

    /* Delete every single match */
    for (i = 0; i < count; i++) {
        rv = bcm_esw_port_match_delete(unit, port, match_array + i);
        if (BCM_FAILURE(rv)) {
            sal_free(match_array);
            return rv;
        }
    }
    sal_free(match_array);
    return rv;
#else
    return BCM_E_UNAVAIL;
#endif
}

int
bcmi_esw_port_eee_cfg_get(int unit, bcm_port_t port, int *value)
{
#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_TRIDENT_SUPPORT) || \
    defined(BCM_HAWKEYE_SUPPORT) || defined(BCM_SHADOW_SUPPORT) || \
    defined(BCM_HURRICANE2_SUPPORT)
    if ((port < 0) || (port >= SOC_MAX_NUM_PORTS)) {
        return BCM_E_PORT;
    }

    *value = eee_cfg[unit][port];

    return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
}



/*
 * Function:
 *      bcm_esw_port_timesync_config_get
 * Purpose:
 *      Delete all matches for an existing port
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port
 *      conf - (IN) Configuration
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */

int
bcm_esw_port_timesync_config_get(int unit, bcm_port_t port, int array_size,
                                  bcm_port_timesync_config_t *config_array,
                                  int *array_count)
{
    int rv;
    int is_remote_port = FALSE;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_IS_TRIDENT3X(unit) && BCM_GPORT_IS_PROXY(port)) {
        if (bcm_esw_port_local_get(unit, port, &port) != BCM_E_NONE) {
            /* the port is remote mod port */
            is_remote_port = TRUE;
        }
    }

    if (!is_remote_port) {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    }

    COMPILER_REFERENCE(array_size);
    COMPILER_REFERENCE(config_array);
    COMPILER_REFERENCE(array_count);

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT) || \
    defined(BCM_TIMESYNC_V3_SUPPORT)|| defined(BCM_SABER2_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT)
    /*
     * Internal timesync function handles port lock and retrieves
     * timesync config profiles
     */
    if ((soc_feature(unit, soc_feature_timesync_v3) || SOC_IS_TRIUMPH3(unit) ||
         SOC_IS_KATANAX(unit)|| SOC_IS_TD2_TT2(unit) || SOC_IS_SABER2(unit) ||
         SOC_IS_APACHE(unit)) &&
        (soc_feature(unit,soc_feature_timesync_support))) {
        rv = _bcm_esw_port_timesync_config_get(unit, port, array_size,
                                           config_array, array_count, is_remote_port);
    } else
#endif /* defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT) ||
          defined(BCM_TIMESYNC_V3_SUPPORT) || defined(BCM_SABER2_SUPPORT) */
    {
        rv = BCM_E_UNAVAIL;
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_timesync_config_set
 * Purpose:
 *      Set Timesync Configuration profiles for the port
 * Parameters:
 *      unit            - (IN) bcm device
 *      port            - (IN) port
 *      config_count    - (IN)Count of timesync profile
 *      *config_array   - (IN/OUT) Pointer to array of timesync profiles
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_timesync_config_set(int unit, bcm_port_t port, int config_count,
                                  bcm_port_timesync_config_t *config_array)
{
    int rv;
    int is_remote_port = FALSE;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_IS_TRIDENT3X(unit) && BCM_GPORT_IS_PROXY(port)) {
        if (bcm_esw_port_local_get(unit, port, &port) != BCM_E_NONE) {
            int cnt;
            bcm_port_timesync_config_t *ts_config;
            is_remote_port = TRUE;
            for (cnt = 0; cnt < config_count; cnt++)
            {
                ts_config = (bcm_port_timesync_config_t*) (config_array + cnt);
                /* the params can't be configured on remote logical port */
                if (ts_config->flags & BCM_PORT_TIMESYNC_ONE_STEP_TIMESTAMP ||
                    ts_config->flags & BCM_PORT_TIMESYNC_TWO_STEP_TIMESTAMP ||
                    ts_config->flags & BCM_PORT_TIMESYNC_TIMESTAMP_CFUPDATE_ALL ||
                    ts_config->pkt_drop & BCM_PORT_TIMESYNC_PKT_INVALID) {
                    return BCM_E_PORT;
                }
            }
        }
    }

    if (!is_remote_port) {
        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    }

    COMPILER_REFERENCE(config_count);
    COMPILER_REFERENCE(config_array);

#if defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT) || \
    defined(BCM_TIMESYNC_V3_SUPPORT) || defined(BCM_SABER2_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT)
    /*
     * Internal timesync function handles port lock and adds
     * timesync config profiles
     */
    if ((soc_feature(unit, soc_feature_timesync_v3) || SOC_IS_TRIUMPH3(unit) ||
         SOC_IS_KATANAX(unit)|| SOC_IS_TD2_TT2(unit) || SOC_IS_SABER2(unit) ||
         SOC_IS_APACHE(unit)) &&
        (soc_feature(unit,soc_feature_timesync_support))) {
        rv = _bcm_esw_port_timesync_config_set(unit, port, config_count,
                                           config_array, is_remote_port);
    } else
#endif /* defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_KATANA_SUPPORT) ||
          defined(BCM_TIMESYNC_V3_SUPPORT) || defined(BCM_SABER2_SUPPORT) */
    {
        rv = BCM_E_UNAVAIL;
    }

    return rv;
}

/*
 * Function:
 *     bcm_esw_port_timesync_tx_timestamp_and_seqid_get
 * Purpose:
 *    Retrives two-step PTP timestamp and seqid from MAC FIFO after packet TX
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port
 *      conf - (IN) Configuration
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */

int
bcm_esw_port_timesync_tx_info_get(int unit, bcm_port_t port,
                                  bcm_port_timesync_tx_info_t *tx_info)
{
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#if defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_HURRICANE3_SUPPORT) \
    || defined(BCM_TOMAHAWK2_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT) \
    || defined(BCM_SABER2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) \
    || defined(BCM_TRIUMPH3_SUPPORT) || defined(BCM_FIRELIGHT_SUPPORT) \
    || defined(BCM_GREYHOUND_SUPPORT)
    /*
     * Internal timesync function handles port lock and retrieves
     * timesync config profiles
     */
    if (((SOC_IS_TD2_TT2(unit)) || SOC_IS_HURRICANE3(unit) || SOC_IS_SABER2(unit) || SOC_IS_TRIDENT2(unit) ||
        SOC_IS_TRIUMPH3(unit) || SOC_IS_FIRELIGHT(unit) || SOC_IS_GREYHOUND(unit)) &&
        (soc_feature(unit,soc_feature_timesync_support))) {
        if (SOC_USE_PORTCTRL(unit)) {
            rv = _bcm_esw_port_timesync_tx_info_get(unit, port, tx_info);
        } else {
            soc_port_timesync_tx_info_t info;
            sal_memset(&info, 0, sizeof(soc_port_timesync_tx_info_t));

            PORT_LOCK(unit)
            rv = MAC_TIMESYNC_TX_INFO_GET(PORT(unit, port).p_mac, unit, port, &info);
            PORT_UNLOCK(unit);
            COMPILER_64_SET(tx_info->timestamp, info.timestamps_in_fifo_hi, info.timestamps_in_fifo);
            tx_info->sequence_id = info.sequence_id;
        }
    } else
#endif /* defined(BCM_TRIDENT2PLUS_SUPPORT) || defined(BCM_HURRICANE3_SUPPORT)
          || defined(BCM_TOMAHAWK2_SUPPORT) */
    {
        rv = BCM_E_UNAVAIL;
    }

    return rv;
}

/*
 * Function:
 *     bcm_esw_port_timestamp_adjust_get
 * Purpose:
 *     get OSTS,TSTS timestamp adjust based on current speed
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port
 *      ts_adjust - (OUT) configuration for tsts,osts timestamp adjustment.
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_timestamp_adjust_get(int unit, bcm_port_t port,
                                  bcm_port_timestamp_adjust_t *ts_adjust)
{
        int rv;

        /* Make sure port module is initialized. */
        PORT_INIT(unit);

        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef PORTMOD_SUPPORT
        if (SOC_PORT_USE_PORTCTRL(unit, port)) {
            PORT_LOCK(unit);
            rv = bcmi_esw_portctrl_timestamp_adjust_get(unit, port, ts_adjust);
            PORT_UNLOCK(unit);
        } else
#endif /* PORTMOD_SUPPORT */
        {
            rv = BCM_E_UNAVAIL;
        }

        return rv;

}

/*
 * Function:
 *     bcm_esw_port_timestamp_adjust_set
 * Purpose:
 *     set OSTS,TSTS timestamp adjust based on speed
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port.
 *      ts_adjust - (IN) configuration for tsts,osts timestamp adjust.
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_timestamp_adjust_set(int unit, bcm_port_t port,
                                  bcm_port_timestamp_adjust_t *ts_adjust)
{
        int rv;
        /* Make sure port module is initialized. */
        PORT_INIT(unit);

        BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef PORTMOD_SUPPORT
        if (SOC_PORT_USE_PORTCTRL(unit, port)) {
            PORT_LOCK(unit);
            rv = bcmi_esw_portctrl_timestamp_adjust_set(unit, port, ts_adjust);
            PORT_UNLOCK(unit);
        } else
#endif /* PORTMOD_SUPPORT */
        {
            rv = BCM_E_UNAVAIL;
        }

        return rv;

}

/*
 * Function:
 *      bcm_esw_port_phy_timesync_config_set
 * Purpose:
 *      Delete all matches for an existing port
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port
 *      conf - (IN) Configuration
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_phy_timesync_config_set(int unit, bcm_port_t port,
                                     bcm_port_phy_timesync_config_t *conf)
{
    int rv;
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef PORTMOD_SUPPORT
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        PORT_LOCK(unit);
        rv = soc_portctrl_phy_timesync_config_set(unit, port,
             (soc_port_phy_timesync_config_t *)conf);
        PORT_UNLOCK(unit);
    } else
#endif /* PORTMOD_SUPPORT */
    {
        PORT_LOCK(unit);
        rv = soc_port_phy_timesync_config_set(unit, port,
             (soc_port_phy_timesync_config_t *)conf);
        PORT_UNLOCK(unit);
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_phy_timesync_config_get
 * Purpose:
 *      Delete all matches for an existing port
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port
 *      conf - (OUT) Configuration
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_phy_timesync_config_get(int unit, bcm_port_t port,
                                     bcm_port_phy_timesync_config_t *conf)
{
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef PORTMOD_SUPPORT
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        PORT_LOCK(unit);
        rv = soc_portctrl_phy_timesync_config_get(unit, port,
             (soc_port_phy_timesync_config_t *)conf);
        PORT_UNLOCK(unit);
    } else
#endif /* PORTMOD_SUPPORT */
    {
        PORT_LOCK(unit);
        rv = soc_port_phy_timesync_config_get(unit, port,
             (soc_port_phy_timesync_config_t *)conf);
        PORT_UNLOCK(unit);
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_control_phy_timesync_set
 * Purpose:
 *      Delete all matches for an existing port
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port
 *      type - (IN) Operation
 *      value- (IN) Arg to operation
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_control_phy_timesync_set(int unit, bcm_port_t port,
                                      bcm_port_control_phy_timesync_t type,
                                      uint64 value)
{
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef PORTMOD_SUPPORT
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        PORT_LOCK(unit);
        rv = soc_portctrl_control_phy_timesync_set(unit, port, type, value);
        PORT_UNLOCK(unit);
    } else
#endif /* PORTMOD_SUPPORT */
    {
        PORT_LOCK(unit);
        rv = soc_port_control_phy_timesync_set(unit, port, type, value);
        PORT_UNLOCK(unit);
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_control_phy_timesync_get
 * Purpose:
 *      Delete all matches for an existing port
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port
 *      type - (IN) Operation
 *      value- (OUT) Pointer to arg for operation
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_control_phy_timesync_get(int unit, bcm_port_t port,
                                      bcm_port_control_phy_timesync_t type,
                                      uint64 *value)
{
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef PORTMOD_SUPPORT
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        PORT_LOCK(unit);
        rv = soc_portctrl_control_phy_timesync_get(unit, port, type, value);
        PORT_UNLOCK(unit);
    } else
#endif /* PORTMOD_SUPPORT */
    {
        PORT_LOCK(unit);
        rv = soc_port_control_phy_timesync_get(unit, port, type, value);
        PORT_UNLOCK(unit);
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_phy_timesync_enhanced_capture_get
 * Purpose:
 *      Delete all matches for an existing port
 * Parameters:
 *      unit - (IN) Unit number.
 *      port - (IN) Port
 *      value - (OUT) Configuration
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_port_phy_timesync_enhanced_capture_get(int unit, bcm_port_t port,
                                     bcm_port_phy_timesync_enhanced_capture_t *value)
{
    int rv;
    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    PORT_LOCK(unit);
    rv = soc_port_phy_timesync_enhanced_capture_get(unit, port,
                                          (soc_port_phy_timesync_enhanced_capture_t *)value);
    PORT_UNLOCK(unit);

    return rv;
}

/* bcm_port_config_phy_oam_set */
int bcm_esw_port_config_phy_oam_set(int unit, bcm_port_t port,
                                    bcm_port_config_phy_oam_t *conf){
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef PORTMOD_SUPPORT
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        rv = BCM_E_UNAVAIL;
    } else
#endif /* PORTMOD_SUPPORT */
    {

        PORT_LOCK(unit);
        rv = soc_port_config_phy_oam_set(unit, port,
                                         (soc_port_config_phy_oam_t *)conf);
        PORT_UNLOCK(unit);
    }

    return rv;
}

/* bcm_port_config_phy_oam_get */
int bcm_esw_port_config_phy_oam_get(int unit, bcm_port_t port,
                                    bcm_port_config_phy_oam_t *conf){
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef PORTMOD_SUPPORT
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        rv = BCM_E_UNAVAIL;
    } else
#endif /* PORTMOD_SUPPORT */
    {
        PORT_LOCK(unit);
        rv = soc_port_config_phy_oam_get(unit, port,
                                         (soc_port_config_phy_oam_t *)conf);
        PORT_UNLOCK(unit);
    }

    return rv;
}

/* bcm_port_control_phy_oam_set */
int bcm_esw_port_control_phy_oam_set(int unit, bcm_port_t port,
                                     bcm_port_control_phy_oam_t type,
                                     uint64 value){
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef PORTMOD_SUPPORT
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        rv = BCM_E_UNAVAIL;
    } else
#endif /* PORTMOD_SUPPORT */
    {
        PORT_LOCK(unit);
        rv = soc_port_control_phy_oam_set(unit, port,type, value);
        PORT_UNLOCK(unit);
    }

    return rv;
}

/* bcm_port_control_phy_oam_get */
int bcm_esw_port_control_phy_oam_get(int unit, bcm_port_t port,
                                     bcm_port_control_phy_oam_t type,
                                     uint64 *value){
    int rv;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#ifdef PORTMOD_SUPPORT
    if (SOC_PORT_USE_PORTCTRL(unit, port)) {
        rv = BCM_E_UNAVAIL;
    } else
#endif /* PORTMOD_SUPPORT */
    {
        PORT_LOCK(unit);
        rv = soc_port_control_phy_oam_get(unit, port,type, value);
        PORT_UNLOCK(unit);
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_tpid_get_all
 * Purpose:
 *      Get a list of tpids and associated color selections for a given port
 * Parameters:
 *      unit  - (IN) Unit number.
 *      port  - (IN) Port
 *      size  - (IN) number of elements of the next two array parameters
 *tpid_array  - (OUT) buffer array to hold a list of retrieved tpids
 *color_array - (OUT) buffer array to hold a list of retrieved color selections
 *      count - (OUT) actual number of tpids retrieved.
 * Returns:
 *      BCM_E_xxx
 */
int
bcm_esw_port_tpid_get_all(int unit, bcm_port_t port,
     int size,            /* number of elements of the arrays */
     uint16 *tpid_array,  /* buffer array to hold a list of retrieved tpids */
     int    *color_array, /* buffer array to hold a list of retrieved colors */
     int    *count)       /* actual number of tpids retrieved. */
{
    int rv = BCM_E_UNAVAIL;
    bcm_module_t mod_out;
    bcm_port_t port_out;
    bcm_trunk_t tgid_out;
    int id_out;
    int is_local = 0;

    /* safety check */
    if (size < 0 || count == NULL) {
        return BCM_E_PARAM;
    }
    if ((size > 0) && (tpid_array == NULL || color_array == NULL)) {
        return BCM_E_PARAM;
    }

    *count = 0;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    if (BCM_GPORT_IS_SET(port)) {
        /* Handle virtual ports separetly */
        if (BCM_GPORT_IS_MPLS_PORT(port) ||
            BCM_GPORT_IS_MIM_PORT(port) ||
            BCM_GPORT_IS_TRILL_PORT(port) ||
            BCM_GPORT_IS_VXLAN_PORT(port) ||
            BCM_GPORT_IS_FLOW_PORT(port) ||
            BCM_GPORT_IS_VLAN_PORT(port)) {

            if (soc_feature(unit, soc_feature_vlan_ctrl)) {
#if defined(BCM_TRX_SUPPORT)
                PORT_LOCK(unit);
                rv = _bcm_trx_vp_tpid_get_all(unit, port, size,
                         tpid_array, color_array,count);
                PORT_UNLOCK(unit);
#endif
            }
            return rv;
        } else {
            BCM_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, port,
                        &mod_out, &port_out, &tgid_out, &id_out));
            if ((-1 != tgid_out) || (-1 != id_out)) {
                return BCM_E_PARAM;
            }

            BCM_IF_ERROR_RETURN
                (_bcm_esw_modid_is_local(unit, mod_out, &is_local));
            if (!is_local) {
                return BCM_E_PORT;
            } else {
                BCM_IF_ERROR_RETURN(
                        bcm_esw_port_local_get(unit, port, &port));
            }
        }

    } else if (!SOC_PORT_VALID(unit, port)) {
        return BCM_E_PORT;
    }

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT) \
    || defined(BCM_RAVEN_SUPPORT)
    if (soc_feature(unit, soc_feature_vlan_ctrl)) {
        PORT_LOCK(unit);
        rv = _bcm_fb2_port_tpid_get_all(unit, port, size,tpid_array,
                                color_array, count);
        PORT_UNLOCK(unit);
    }
#endif
    return (rv);
}
void bcm_esw_kt2_port_lock(int unit)
{
    PORT_LOCK(unit);
}
void bcm_esw_kt2_port_unlock(int unit)
{
    PORT_UNLOCK(unit);
}

#ifdef BCM_WARM_BOOT_SUPPORT
int
_bcm_port_cleanup(int unit)
{
#if defined(BCM_FIREBOLT_SUPPORT)
    if (SOC_IS_FB_FX_HX(unit)) {
        bcm_port_t port;

        for (port = 0; port < SOC_MAX_NUM_PORTS; port++) {
            if (PORT(unit, port).p_vd_pbvl != NULL) {
                sal_free(PORT(unit, port).p_vd_pbvl);
                PORT(unit, port).p_vd_pbvl = NULL;
            }

            if (PORT(unit, port).e2ecc_config != NULL) {
                sal_free(PORT(unit, port).e2ecc_config);
                PORT(unit, port).e2ecc_config = NULL;
            }
        }

        if (bcm_port_info[unit] != NULL) {
            sal_free(bcm_port_info[unit]);
            bcm_port_info[unit] = NULL;
        }
    }
#endif /* BCM_FIREBOLT_SUPPORT */

    return BCM_E_NONE;
}
#endif /* BCM_WARM_BOOT_SUPPORT */

#ifndef BCM_SW_STATE_DUMP_DISABLE
/*
 * Function:
 *     _bcm_port_sw_dump
 * Purpose:
 *     Displays port information maintained by software.
 * Parameters:
 *     unit - Device unit number
 * Returns:
 *     None
 * Note:
 *    Skip following structure fields: p_phy, p_mac
 */
void
_bcm_port_sw_dump(int unit)
{
    _bcm_port_info_t *info;
    int              i, j;
    int              idxmax, entries, max_num_ports = 0;
    bcm_port_t       port;
    bcm_pbmp_t       all_pbmp;

    info = bcm_port_info[unit];
    idxmax = soc_mem_index_max(unit, VLAN_PROTOCOLm) + 1;
    entries = (idxmax + (_BCM_PORT_VD_PBVL_ESIZE -  1)) / _BCM_PORT_VD_PBVL_ESIZE;

    max_num_ports = SOC_MAX_NUM_PORTS;

    SOC_PBMP_CLEAR(all_pbmp);
    SOC_PBMP_ASSIGN(all_pbmp, PBMP_ALL(unit));

#ifdef BCM_KATANA2_SUPPORT
    if (soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe)) {
        _bcm_kt2_subport_pbmp_update (unit, &all_pbmp);
        if (SOC_INFO(unit).linkphy_enabled ||
            SOC_INFO(unit).subtag_enabled) {
            max_num_ports = SOC_MAX_NUM_PP_PORTS;
        }
    }
#endif


    LOG_CLI((BSL_META_U(unit,
                        "\nSW Information Port - Unit %d\n"), unit));

    if (info != NULL) {
        for (i = 0; i < max_num_ports; i++) {
            LOG_CLI((BSL_META_U(unit,
                                "       Port %2d : "), i));
            LOG_CLI((BSL_META_U(unit,
                                "     MAC driver - %s\n"),
                     ((SOC_PORT_VALID(unit, i)) && (info[i].p_mac != NULL)) ?
                     (info[i].p_mac)->drv_name : "none"));
            LOG_CLI((BSL_META_U(unit,
                                "     Untagged priority - %d\n"),
                     info[i].p_ut_prio));
            LOG_CLI((BSL_META_U(unit,
                                "     Double-tag mode - ")));
            if (0 != info[i].dtag_mode) {
                if (0 != (info[i].dtag_mode &
                          BCM_PORT_DTAG_MODE_INTERNAL)) {
                    LOG_CLI((BSL_META_U(unit,
                                        " Internal")));
                }
                if (0 != (info[i].dtag_mode &
                          BCM_PORT_DTAG_MODE_EXTERNAL)) {
                    LOG_CLI((BSL_META_U(unit,
                                        " External")));
                }
                if (0 != (info[i].dtag_mode &
                          BCM_PORT_DTAG_ADD_EXTERNAL_TAG)) {
                    LOG_CLI((BSL_META_U(unit,
                                        " AddTag")));
                }
                if (0 != (info[i].dtag_mode &
                          BCM_PORT_DTAG_REMOVE_EXTERNAL_TAG)) {
                    LOG_CLI((BSL_META_U(unit,
                                        " RemoveTag")));
                }
            } else {
                LOG_CLI((BSL_META_U(unit,
                                    " None")));
            }
            LOG_CLI((BSL_META_U(unit,
                                "\n")));
            LOG_CLI((BSL_META_U(unit,
                                "     VLAN_PROTOCOL_DATA index - %d\n"),
                     info[i].vlan_prot_ptr));
            LOG_CLI((BSL_META_U(unit,
                                "     Number of VPs - %d\n"),
                     info[i].vp_count));
        }

        LOG_CLI((BSL_META_U(unit,
                            "\n")));

        LOG_CLI((BSL_META_U(unit,
                            "     Protocol based VLAN - \n")));
        LOG_CLI((BSL_META_U(unit,
                            "       Total Entries : %d\n"), entries));

        PBMP_ITER(all_pbmp, port) {
            LOG_CLI((BSL_META_U(unit,
                                "       Port %2d : "), port));
            if (info[port].p_vd_pbvl == NULL) {
                LOG_CLI((BSL_META_U(unit,
                                    "\n")));
                continue;
            }

            for (j = 0; j < entries; j++) {
                if ((j > 0) && !(j % 10)) {
                    LOG_CLI((BSL_META_U(unit,
                                        "\n                 ")));
                }
                LOG_CLI((BSL_META_U(unit,
                                    " 0x%2.2x"), info[port].p_vd_pbvl[j]));
            }
            LOG_CLI((BSL_META_U(unit,
                                "\n")));
        }

        if (soc_feature(unit, soc_feature_e2ecc)) {
            bcm_port_congestion_config_t *e2ep;

            LOG_CLI((BSL_META_U(unit,
                                "\n")));
            LOG_CLI((BSL_META_U(unit,
                                "     E2E Congestion Control - \n")));
            PBMP_ALL_ITER(unit, port) {
                e2ep = info[port].e2ecc_config;
                if (NULL == e2ep) {
                   continue;
                }

                if ((0 == (e2ep->flags & (BCM_PORT_CONGESTION_CONFIG_E2ECC |
                        BCM_PORT_CONGESTION_CONFIG_DESTMOD_FLOW_CONTROL |
                        BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_FLEX_MODE  |
                        BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_STRICT_MODE)))) {
                    continue;
                }

                LOG_CLI((BSL_META_U(unit,
                                    "\n       Port : %d\n"), port));
                if ((e2ep->flags &
                     BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_FLEX_MODE) ||
                    (e2ep->flags &
                     BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_STRICT_MODE)) {
                    LOG_CLI((BSL_META_U(unit,
                          "         E2ECC COE Flags:  %s %s \n"),
                          (e2ep->flags &
                           BCM_PORT_CONGESTION_CONFIG_RX) ?
                                        "RX" : "",
                          ((e2ep->flags &
                            BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_FLEX_MODE) ?
                                       "FLEX mode":
                          (e2ep->flags &
                           BCM_PORT_CONGESTION_CONFIG_E2ECC_COE_STRICT_MODE) ?
                                        "STRICT mode" : ""))) ;
                } else {
                    LOG_CLI((BSL_META_U(unit,
                                    "         Flags : %s %s %s\n"),
                            (e2ep->flags & BCM_PORT_CONGESTION_CONFIG_E2ECC) ?
                            "E2ECC" : "DestMod Flow control",
                            (e2ep->flags & BCM_PORT_CONGESTION_CONFIG_TX) ?
                            "TX" : "",
                            (e2ep->flags & BCM_PORT_CONGESTION_CONFIG_RX) ?
                            "RX" : ""));
                }

                if (e2ep->flags & BCM_PORT_CONGESTION_CONFIG_TX) {
                    LOG_CLI((BSL_META_U(unit,
                                        "         Port bits : 0x%02x\n"),
                             e2ep->port_bits));
                    LOG_CLI((BSL_META_U(unit,
                                        "         Packets/sec : %d\n"),
                             e2ep->packets_per_sec));
                    LOG_CLI((BSL_META_U(unit,
                                        "         Source gport : 0x%08x\n"),
                             e2ep->src_port));
                    LOG_CLI((BSL_META_U(unit,
                                        "         Multicast ID : 0x%04x\n"),
                             e2ep->multicast_id));
                    LOG_CLI((BSL_META_U(unit,
                                        "         Traffic class : %d\n"),
                             e2ep->traffic_class));
                    LOG_CLI((BSL_META_U(unit,
                                        "         Color : %d\n"),
                             e2ep->color));
                    LOG_CLI((BSL_META_U(unit,
                                        "         Source MAC : 0x%02x%02x%02x%02x%02x%02x\n"),
                             e2ep->src_mac[0], e2ep->src_mac[1],
                             e2ep->src_mac[2], e2ep->src_mac[3],
                             e2ep->src_mac[4], e2ep->src_mac[5]));
                }

                LOG_CLI((BSL_META_U(unit,
                                    "         Destination MAC : "
                                    "0x%02x%02x%02x%02x%02x%02x\n"),
                         e2ep->dest_mac[0], e2ep->dest_mac[1],
                         e2ep->dest_mac[2], e2ep->dest_mac[3],
                         e2ep->dest_mac[4], e2ep->dest_mac[5]));
                LOG_CLI((BSL_META_U(unit,
                                    "         Ethertype : 0x%04x\n"),
                         e2ep->ethertype));
                LOG_CLI((BSL_META_U(unit,
                                    "         Opcode : 0x%04x\n"),
                         e2ep->opcode));
            }
        }

#ifdef BCM_TRIUMPH2_SUPPORT
        if (soc_feature(unit, soc_feature_src_modid_blk_profile)) {

            LOG_CLI((BSL_META_U(unit,
                                "\n")));
            LOG_CLI((BSL_META_U(unit,
                                "     Source Modid Egress Blocking Profiles - \n")));
            PBMP_ITER(all_pbmp, port) {
                if (-1 == PORT_SRC_MOD_EGR_PROF_PTR(unit, port)) {
                    continue;
                }
                LOG_CLI((BSL_META_U(unit,
                                    "       Port %2d : "), port));
                LOG_CLI((BSL_META_U(unit,
                                    "Profile index %d\n"),
                         PORT_SRC_MOD_EGR_PROF_PTR(unit, port)));
            }
            /* Display those entries with reference count > 0 */
            if (PORT_SRC_MOD_EGR_PROFILE(unit) != NULL) {
                int     i;
                int     num_entries;
                int     ref_count;
                int     entries_per_set;
                int     modid_count;
                uint32  index;
                pbmp_t  sme_pbmp;
                src_modid_egress_entry_t *entry_p;
                char    sme_pfm[SOC_PBMP_FMT_LEN];

                num_entries = soc_mem_index_count(unit,
                      PORT_SRC_MOD_EGR_PROFILE(unit)->tables[0].mem);
                LOG_CLI((BSL_META_U(unit,
                                    "  Source Modid Egress Profile\n")));
                LOG_CLI((BSL_META_U(unit,
                                    "      Number of entries: %d\n"), num_entries));
                LOG_CLI((BSL_META_U(unit,
                                    "      Index RefCount EntriesPerSet - "
                         "PortBlockMaskBitmap\n")));

                modid_count = SOC_MODID_MAX(unit) + 1;
                for (index = 0; index < num_entries; index += modid_count) {
                    if (SOC_FAILURE(soc_profile_mem_ref_count_get(unit,
                                        PORT_SRC_MOD_EGR_PROFILE(unit),
                                                 index, &ref_count))) {
                        break;
                    }

                    if (ref_count <= 0) {
                        continue;
                    }

                    for (i = 0; i < modid_count; i++) {
                        entries_per_set =
                            PORT_SRC_MOD_EGR_PROFILE(unit)->tables[0].\
                            entries[index+i].entries_per_set;
                        entry_p = SOC_PROFILE_MEM_ENTRY(unit,
                                      PORT_SRC_MOD_EGR_PROFILE(unit),
                                      src_modid_egress_entry_t *,
                                                        index + i);
                        soc_mem_pbmp_field_get(unit, SRC_MODID_EGRESSm,
                                               entry_p,
                                               PORT_BLOCK_MASK_BITMAPf,
                                               &sme_pbmp);

                        if (BCM_PBMP_NOT_NULL(sme_pbmp)) {
                            LOG_CLI((BSL_META_U(unit,
                                                "     %5d %8d %13d    "),
                                     index + i, ref_count,
                                     entries_per_set));
                            LOG_CLI((BSL_META_U(unit,
                                                "%s\n"),
                                     SOC_PBMP_FMT(sme_pbmp, sme_pfm)));
                        }
                    }
                }
            }
        }
#endif /* BCM_TRIUMPH2_SUPPORT */
    }

    LOG_CLI((BSL_META_U(unit,
                        "\n")));

    return;
}
#endif /* BCM_SW_STATE_DUMP_DISABLE */


/*
 * Function:
 *      _bcm_esw_port_gport_phyn_validate
 * Purpose:
 *      Validate PHY specific gport
 * Parameters:
 *      unit       -  (IN)  Unit number.
 *      port       -  (IN)  Port number.
 *      local_port -  (OUT) Local Port number.
 *      phyn       -  (OUT) Phy number
 *      phy_lane   -  (OUT) Lane number
 *      sys_side   -  (OUT) System side(1)or line side(0).
 * Returns:
 *      BCM_E_XXX
 */

int
_bcm_esw_port_gport_phyn_validate(int unit, bcm_port_t port,
                                  bcm_port_t *local_port, int *phyn,
                                  int *phy_lane, int *sys_side)
{
    /* Validate input arguments */
    if (local_port == NULL || phy_lane == NULL ||
        phyn == NULL || sys_side == NULL) {
       return BCM_E_PARAM;
    }

    if (BCM_PHY_GPORT_IS_PHYN(port)) {
        *local_port = BCM_PHY_GPORT_PHYN_PORT_PORT_GET(port);
        *phyn = BCM_PHY_GPORT_PHYN_PORT_PHYN_GET(port);
        *phy_lane = -1;
    } else if(BCM_PHY_GPORT_IS_PHYN_LANE(port)) {
        *local_port = BCM_PHY_GPORT_PHYN_LANE_PORT_PORT_GET(port);
        *phyn = BCM_PHY_GPORT_PHYN_LANE_PORT_PHYN_GET(port);
        *phy_lane = BCM_PHY_GPORT_PHYN_LANE_PORT_LANE_GET(port);
    } else if(BCM_PHY_GPORT_IS_PHYN_SYS_SIDE(port)) {
        *local_port = BCM_PHY_GPORT_PHYN_SYS_SIDE_PORT_PORT_GET(port);
        *phyn = BCM_PHY_GPORT_PHYN_SYS_SIDE_PORT_PHYN_GET(port);
        *sys_side = TRUE;
        *phy_lane = -1;
    } else if(BCM_PHY_GPORT_IS_PHYN_SYS_SIDE_LANE(port)) {
        *local_port = BCM_PHY_GPORT_PHYN_SYS_SIDE_LANE_PORT_PORT_GET(port);
        *phyn = BCM_PHY_GPORT_PHYN_SYS_SIDE_LANE_PORT_PHYN_GET(port);
        *phy_lane = BCM_PHY_GPORT_PHYN_SYS_SIDE_LANE_PORT_LANE_GET(port);
        *sys_side = TRUE;
    } else if (BCM_PHY_GPORT_IS_LANE(port)) {
        *local_port = BCM_PHY_GPORT_LANE_PORT_PORT_GET(port);
        *phy_lane = BCM_PHY_GPORT_LANE_PORT_LANE_GET(port);
    } else {
        *local_port = -1;
        return BCM_E_NONE;
    }

    if (!SOC_PORT_VALID(unit, *local_port)) {
       return BCM_E_PORT;
    }

    return BCM_E_NONE;
}

/**
 * Function:
 *      _bcm_esw_link_force_for_disabled_loopback_port
 * Purpose:
 *      Force linkscan's current link status on for a disabled port
 *      which is configured to MAC loopback.
 * Parameters:
 *      unit - (IN) Unit number.
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
_bcm_esw_link_force_for_disabled_loopback_port(int unit)
{
    bcm_port_t port;
    int loopback;
    int enable;
    bcm_pbmp_t pbmp;

    SOC_PBMP_ASSIGN(pbmp, PBMP_E_ALL(unit));
#if defined(BCM_SABER2_SUPPORT)
    if(SOC_IS_SABER2(unit)){
        /*
         * During warmboot init, the oamp port is not removed
         * from ethernet bitmaps till sat is initialized.
         * So manually removing it here.
         */
        int oamp_enable;
        (void)bcm_sb2_sat_oamp_enable_get(unit, &oamp_enable);
        /* Skip OAMP port for saber2 device */
        if(oamp_enable) {
            SOC_PBMP_PORT_REMOVE(pbmp,
                    _BCM_SB2_SAT_OAMP_PHY_PORT_NUMBER);
        }
    }
#endif

    PBMP_ITER(pbmp,port) {
        BCM_IF_ERROR_RETURN(
            bcm_esw_port_loopback_get(unit, port, &loopback));
        BCM_IF_ERROR_RETURN(
            bcm_esw_port_enable_get(unit, port, &enable));
        if ((loopback == BCM_PORT_LOOPBACK_MAC) && (enable == FALSE)) {
            BCM_IF_ERROR_RETURN
                (_bcm_esw_link_force(unit, 0 /*flags*/, port, TRUE, TRUE));
        }
    }

    return BCM_E_NONE;
}

#ifdef BCM_MAVERICK2_SUPPORT
/**
 * Function:
 *      _bcm_esw_mv2_asf_init
 * Purpose:
 *      Initialize ASF subsystem and configure all the applicable ports
 *      to the specified forwarding mode
 * Parameters:
 *      unit - (IN) Unit number.
 *      mode - (IN) forwarding mode
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_mv2_asf_init(
    int                 unit,
    soc_mv2_asf_mode_e  asf_mode)
{
    bcm_port_t port;
    int        speed;
    soc_info_t *si;

    if (!(si = &SOC_INFO(unit))) {
        return BCM_E_INTERNAL;
    }

    BCM_IF_ERROR_RETURN(soc_mv2_asf_init_start(unit));

    PBMP_ALL_ITER(unit, port) {
        if (IS_CPU_PORT(unit, port) || IS_LB_PORT(unit, port)) {
            continue;
        }
        speed = si->port_init_speed[port];
        if (speed == 0) {
            BCM_IF_ERROR_RETURN(
                bcm_esw_port_speed_get(unit, port, &speed));
        }
        BCM_IF_ERROR_RETURN(
            soc_mv2_port_asf_init(unit, port, speed, asf_mode));
    }
    BCM_IF_ERROR_RETURN(soc_mv2_asf_init_done(unit));

    return BCM_E_NONE;
}

STATIC int
_bcm_esw_mv2_port_asf_mode_set(
    int         unit,
    bcm_port_t  port,
    int         mode)
{
    int rv = BCM_E_NONE, speed;
    soc_info_t *si;
    int txp = 0, rxp = 0;
    pbmp_t *pause_bmp;

    if (!(si = &SOC_INFO(unit))) {
        return SOC_E_INTERNAL;
    }

    pause_bmp = soc_mv2_port_asf_pause_bpmp_get(unit);
    if (pause_bmp == NULL) {
        return BCM_E_INTERNAL;
    }

    /* Update Pause for ASF mode */
    if (_SOC_MV2_ASF_MODE_SAF != mode) {
        /* Disable rx pause for cut through */
        BCM_IF_ERROR_RETURN
            (bcm_esw_port_pause_get(unit, port, &txp, &rxp));

        if (rxp) {
            SOC_PBMP_PORT_ADD((*pause_bmp), port);
        }
        BCM_IF_ERROR_RETURN
            (bcm_esw_port_pause_set(unit, port, txp, 0));

    }

    speed = si->port_init_speed[port];
    if (speed == 0) {
        BCM_IF_ERROR_RETURN(bcm_esw_port_speed_get(unit, port, &speed));
    }
    PORT_LOCK(unit);
    rv = soc_mv2_port_asf_mode_set(unit, port, speed, mode);
    PORT_UNLOCK(unit);

    /* Update Pause for ASF mode */
    if (((rv != SOC_E_NONE) && (_SOC_MV2_ASF_MODE_SAF != mode)) ||
        ((rv == SOC_E_NONE) && (_SOC_MV2_ASF_MODE_SAF == mode))) {
        /* restore pause */
        if (SOC_PBMP_MEMBER((*pause_bmp), port)) {
            BCM_IF_ERROR_RETURN
                (bcm_esw_port_pause_get(unit, port, &txp, &rxp));
            BCM_IF_ERROR_RETURN
                (bcm_esw_port_pause_set(unit, port, txp, 1));
            SOC_PBMP_PORT_REMOVE((*pause_bmp), port);
        }
    }

    return rv;
}
#endif

#ifdef BCM_TRIDENT3_SUPPORT
/**
 * Function:
 *      _bcm_esw_td3_asf_init
 * Purpose:
 *      Initialize ASF subsystem and configure all the applicable ports
 *      to the specified forwarding mode
 * Parameters:
 *      unit - (IN) Unit number.
 *      mode - (IN) forwarding mode
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_td3_asf_init(
    int                 unit,
    soc_td3_asf_mode_e  asf_mode)
{
    bcm_port_t port;
    int        speed;
    soc_info_t *si;

    if (!(si = &SOC_INFO(unit))) {
        return BCM_E_INTERNAL;
    }

    BCM_IF_ERROR_RETURN(soc_td3_asf_init_start(unit));

    PBMP_ALL_ITER(unit, port) {
        if (IS_CPU_PORT(unit, port) || IS_LB_PORT(unit, port)) {
            continue;
        }
        speed = si->port_init_speed[port];
        if (speed == 0) {
            BCM_IF_ERROR_RETURN(
                bcm_esw_port_speed_get(unit, port, &speed));
        }
        BCM_IF_ERROR_RETURN(
            soc_td3_port_asf_init(unit, port, speed, asf_mode));
    }
    BCM_IF_ERROR_RETURN(soc_td3_asf_init_done(unit));

    return BCM_E_NONE;
}

STATIC int
_bcm_esw_td3_port_asf_mode_set(
    int         unit,
    bcm_port_t  port,
    int         mode)
{
    int rv = BCM_E_NONE, speed;
    soc_info_t *si;
    int txp = 0, rxp = 0;
    pbmp_t *pause_bmp;

    if (!(si = &SOC_INFO(unit))) {
        return SOC_E_INTERNAL;
    }

    pause_bmp = soc_td3_port_asf_pause_bpmp_get(unit);
    if (pause_bmp == NULL) {
        return BCM_E_INTERNAL;
    }

    /* Update Pause for ASF mode */
    if (_SOC_TD3_ASF_MODE_SAF != mode) {
        /* Disable rx pause for cut through */
        BCM_IF_ERROR_RETURN
            (bcm_esw_port_pause_get(unit, port, &txp, &rxp));

        if (rxp) {
            SOC_PBMP_PORT_ADD((*pause_bmp), port);
        }
        BCM_IF_ERROR_RETURN
            (bcm_esw_port_pause_set(unit, port, txp, 0));

    }

    speed = si->port_init_speed[port];
    if (speed == 0) {
        BCM_IF_ERROR_RETURN(bcm_esw_port_speed_get(unit, port, &speed));
    }
    PORT_LOCK(unit);
    rv = soc_td3_port_asf_mode_set(unit, port, speed, mode);
    PORT_UNLOCK(unit);

    /* Update Pause for ASF mode */
    if (((rv != SOC_E_NONE) && (_SOC_TD3_ASF_MODE_SAF != mode)) ||
        ((rv == SOC_E_NONE) && (_SOC_TD3_ASF_MODE_SAF == mode))) {
        /* restore pause */
        if (SOC_PBMP_MEMBER((*pause_bmp), port)) {
            BCM_IF_ERROR_RETURN
                (bcm_esw_port_pause_get(unit, port, &txp, &rxp));
            BCM_IF_ERROR_RETURN
                (bcm_esw_port_pause_set(unit, port, txp, 1));
            SOC_PBMP_PORT_REMOVE((*pause_bmp), port);
        }
    }

    return rv;
}
#endif

#if defined(BCM_TOMAHAWK_SUPPORT)
/* ASF (Cut-thru Forwarding) */

/**
 * Function:
 *      _bcm_esw_asf_init
 * Purpose:
 *      Initialize ASF subsystem and configure all the applicable ports
 *      to the specified forwarding mode
 * Parameters:
 *      unit - (IN) Unit number.
 *      mode - (IN) forwarding mode
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_asf_init(
    int                 unit,
    soc_th_asf_mode_e   asf_mode)
{
    bcm_port_t port;
    int        speed;
    soc_info_t *si;

    if (!(si = &SOC_INFO(unit))) {
        return SOC_E_INTERNAL;
    }

    if (!soc_feature(unit, soc_feature_asf_multimode)) {
        return BCM_E_UNAVAIL;
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        /* WB recovery happens in _bcm_esw_port_wb_recover context */
        return BCM_E_NONE;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

#ifdef BCM_TOMAHAWK3_SUPPORT
    if (SOC_IS_TOMAHAWK3(unit)) {
        return soc_th3_asf_init(unit);
    } else
#endif
    {
        BCM_IF_ERROR_RETURN(soc_th_asf_init_start(unit));

        PBMP_ALL_ITER(unit, port) {
            if (IS_CPU_PORT(unit, port) || IS_LB_PORT(unit, port)) {
                continue;
            }
            speed = si->port_init_speed[port];
            BCM_IF_ERROR_RETURN(
                soc_th_port_asf_init(unit, port, speed, asf_mode));
        }
        BCM_IF_ERROR_RETURN(soc_th_asf_init_done(unit));
    }

    return BCM_E_NONE;
}

/**
 * Function:
 *      _bcm_esw_asf_deinit
 * Purpose:
 *      Deinitialize ASF subsystem and release ASF internal structures
 * Parameters:
 *      unit - (IN) Unit number.
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_asf_deinit(int unit)
{
#ifdef BCM_TRIDENT3_SUPPORT
    if (SOC_IS_TRIDENT3X(unit)) {
        return soc_td3_asf_deinit(unit);
    } else
#endif
#ifdef BCM_TOMAHAWK3_SUPPORT
    if (SOC_IS_TOMAHAWK3(unit)) {
        return soc_th3_asf_deinit(unit);
    } else
#endif
    {
        if (SOC_IS_TOMAHAWKX(unit)) {
            return soc_th_asf_deinit(unit);
        }
    }

    return BCM_E_NONE;
}

#ifdef BCM_WARM_BOOT_SUPPORT
/**
 * Function:
 *      bcm_esw_asf_wb_memsz_get
 * Purpose:
 *      Returns the WB Memory requirement from ASF subsystem
 * Parameters:
 *      unit - (IN) Unit number
 *      mem_sz - (OUT) WB Memory required in bytes
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_asf_wb_memsz_get(
    int               unit,
    OUT uint32* const mem_sz,
    uint16            scache_ver)
{
    int rv;

    if (soc_feature(unit, soc_feature_asf_multimode)) {
#ifdef  BCM_MAVERICK2_SUPPORT
        if (SOC_IS_MAVERICK2(unit)) {
            rv = soc_mv2_asf_wb_memsz_get(unit, mem_sz, scache_ver);
        } else
#endif
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit) && !SOC_IS_MAVERICK2(unit)) {
            rv = soc_td3_asf_wb_memsz_get(unit, mem_sz, scache_ver);
        } else
#endif
#ifdef BCM_TOMAHAWK3_SUPPORT
        if (SOC_IS_TOMAHAWK3(unit)) {
            rv = soc_th3_asf_wb_memsz_get(unit, mem_sz, scache_ver);
        } else
#endif
        if (SOC_IS_TOMAHAWKX(unit)) {
            rv = soc_th_asf_wb_memsz_get(unit, mem_sz, scache_ver);
        } else {
            *mem_sz = 0;
            rv = BCM_E_NONE;
        }
    } else {
        *mem_sz = 0;
        rv = BCM_E_NONE;
    }

    return rv;
}

/**
 * Function:
 *      _bcm_esw_asf_wb_sync
 * Purpose:
 *      ASF Warmboot Sync
 * Parameters:
 *      unit - (IN) Unit number
 *      wb_data - (IN/OUT) ptr to ASF WB data area
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_asf_wb_sync(
    int    unit,
    IN_OUT uint8* wb_data)
{
    int rv;

    if (soc_feature(unit, soc_feature_asf_multimode)) {
#ifdef  BCM_MAVERICK2_SUPPORT
        if (SOC_IS_MAVERICK2(unit)) {
            rv = soc_mv2_asf_wb_sync(unit, wb_data);
        } else
#endif
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit) && !SOC_IS_MAVERICK2(unit)) {
            rv = soc_td3_asf_wb_sync(unit, wb_data);
        } else
#endif
#ifdef BCM_TOMAHAWK3_SUPPORT
        if (SOC_IS_TOMAHAWK3(unit)) {
            rv = soc_th3_asf_wb_sync(unit, wb_data);
        } else
#endif

        if (SOC_IS_TOMAHAWKX(unit)) {
            rv = soc_th_asf_wb_sync(unit, wb_data);
        } else {
            rv = BCM_E_NONE;
        }
    } else {
        rv = BCM_E_NONE;
    }

    return rv;
}

/**
 * Function:
 *      _bcm_esw_asf_wb_recover
 * Purpose:
 *      ASF Warmboot Recovery
 * Parameters:
 *      unit - (IN) Unit number
 *      wb_data - (IN) pointer to ASF WB data area
 * Returns:
 *      BCM_E_xxx
 */
STATIC int
_bcm_esw_asf_wb_recover(
    int          unit,
    uint8* const wb_data,
    uint16       scache_ver)
{
    int rv;

    if (soc_feature(unit, soc_feature_asf_multimode)) {
#ifdef  BCM_MAVERICK2_SUPPORT
        if (SOC_IS_MAVERICK2(unit)) {
            rv = soc_mv2_asf_wb_recover(unit, wb_data, scache_ver);
        } else
#endif
#ifdef BCM_TRIDENT3_SUPPORT
        if (SOC_IS_TRIDENT3X(unit) && !SOC_IS_MAVERICK2(unit)) {
            rv = soc_td3_asf_wb_recover(unit, wb_data, scache_ver);
        } else
#endif
#ifdef BCM_TOMAHAWK3_SUPPORT
        if (SOC_IS_TOMAHAWK3(unit)) {
            rv = soc_th3_asf_wb_recover(unit, wb_data, scache_ver);
        } else
#endif

        if (SOC_IS_TOMAHAWKX(unit)) {
            rv = soc_th_asf_wb_recover(unit, wb_data, scache_ver);
        } else {
            rv = BCM_E_NONE;
        }
    } else {
        rv = BCM_E_NONE;
    }

    return rv;
}
#endif /* BCM_WARMBOOT_SUPPORT */

/**
 * Function:
 *      bcm_esw_port_asf_mode_get
 * Purpose:
 *      Returns the forwarding mode configured on the specified port
 * Parameters:
 *      unit - (IN)  Unit number
 *      port - (IN)  Logical port
 *      mode - (OUT) SAF/ASF mode configured on the port
 *              0=SAF, 1=ASF(Same Speed), 2=ASF(Slow to Fast)
 *              3=ASF (Fast to Slow)
 * Returns:
 *      BCM_E_xxx
 */
int
bcm_esw_port_asf_mode_get(
    int              unit,
    bcm_port_t       port,
    OUT int* const   mode)
{
    int rv = BCM_E_UNAVAIL, speed;
    soc_info_t *si;

    if (!(si = &SOC_INFO(unit))) {
        return SOC_E_INTERNAL;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    if (!soc_feature(unit, soc_feature_asf_multimode)) {
        return BCM_E_UNAVAIL;
    }
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));
    speed = si->port_init_speed[port];

    PORT_LOCK(unit);
#ifdef BCM_MAVERICK2_SUPPORT
    if (SOC_IS_MAVERICK2(unit)) {
        rv = soc_mv2_port_asf_mode_get(unit, port, speed,
               (soc_mv2_asf_mode_e *) mode );
    } else
#endif
#ifdef BCM_TRIDENT3_SUPPORT
    if (SOC_IS_TRIDENT3X(unit)) {
        rv = soc_td3_port_asf_mode_get(unit, port, speed,
                                       (soc_td3_asf_mode_e *) mode);
    } else
#endif

#ifdef BCM_TOMAHAWK3_SUPPORT
    if (SOC_IS_TOMAHAWK3(unit)) {
        rv = soc_th3_port_asf_mode_get(unit, port, speed,
                                          (soc_th3_asf_mode_t *) mode);
    } else
#endif
    if (SOC_IS_TOMAHAWKX(unit)) {
        rv = soc_th_port_asf_mode_get(unit, port, speed,
                                      (soc_th_asf_mode_e *) mode);
    }
    PORT_UNLOCK(unit);

    return rv;
}

/**
 * Function:
 *      bcm_esw_port_asf_mode_set
 * Purpose:
 *      Configure specified SAF/ASF mode on the given port
 * Parameters:
 *      unit - (IN) Unit number
 *      port - (IN) Logical port
 *      mode - (IN) Forwarding mode to be configured on the port
 *              0=SAF, 1=ASF(Same Speed), 2=ASF(Slow to Fast)
 *              3=ASF (Fast to Slow)
 * Returns:
 *      BCM_E_xxx
 */
int
bcm_esw_port_asf_mode_set(
    int          unit,
    bcm_port_t   port,
    int          mode)
{
    int rv = BCM_E_UNAVAIL, speed = 0;
    soc_info_t *si;
#if defined(BCM_TOMAHAWK2_SUPPORT)
    int txp = 0, rxp = 0;
    pbmp_t *pause_bmp = NULL;
#endif /* BCM_TOMAHAWK2_SUPPORT */

    if (!(si = &SOC_INFO(unit))) {
        return SOC_E_INTERNAL;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    if (!soc_feature(unit, soc_feature_asf_multimode)) {
        return BCM_E_UNAVAIL;
    }
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

#if defined(BCM_TOMAHAWK2_SUPPORT)
    /* Update Pause for ASF mode */
    if (SOC_IS_TOMAHAWK2(unit)) {
        pause_bmp = soc_th_port_asf_pause_bpmp_get(unit);
        if (pause_bmp == NULL) {
            return BCM_E_INTERNAL;
        }

        if (_SOC_TH_ASF_MODE_SAF != mode) {
            /* Disable rx pause for cut through */
            BCM_IF_ERROR_RETURN
                (bcm_esw_port_pause_get(unit, port, &txp, &rxp));

            if (rxp) {
                SOC_PBMP_PORT_ADD((*pause_bmp), port);
            }
            BCM_IF_ERROR_RETURN
                (bcm_esw_port_pause_set(unit, port, txp, 0));
        }
    }
#endif /* BCM_TOMAHAWK2_SUPPORT */

#ifdef BCM_MAVERICK2_SUPPORT
    if (SOC_IS_MAVERICK2(unit)) {
        rv = _bcm_esw_mv2_port_asf_mode_set(unit, port, mode);
    } else
#endif
#ifdef BCM_TRIDENT3_SUPPORT
    if (SOC_IS_TRIDENT3X(unit)) {
        rv = _bcm_esw_td3_port_asf_mode_set(unit, port, mode);
    } else
#endif
#ifdef BCM_TOMAHAWK3_SUPPORT
    if(SOC_IS_TOMAHAWK3(unit)) {
        if (mode >= 2) {
            return BCM_E_PARAM;
        }
        speed = si->port_init_speed[port];
        PORT_LOCK(unit);
        rv = soc_th3_port_asf_mode_set(unit, port, speed, mode);
        PORT_UNLOCK(unit);
    } else
#endif
    {
        speed = si->port_init_speed[port];
        PORT_LOCK(unit);
        rv = soc_th_port_asf_mode_set(unit, port, speed, mode);
        PORT_UNLOCK(unit);
    }

#if defined(BCM_TOMAHAWK2_SUPPORT)
    /* Update Pause for ASF mode */
    if (SOC_IS_TOMAHAWK2(unit)) {
      if (_SOC_TH_ASF_MODE_SAF == mode) { /* SAF */
            /* restore pause */
            if (SOC_PBMP_MEMBER((*pause_bmp), port)) {
                BCM_IF_ERROR_RETURN
                    (bcm_esw_port_pause_get(unit, port, &txp, &rxp));
                BCM_IF_ERROR_RETURN
                    (bcm_esw_port_pause_set(unit, port, txp, 1));
                SOC_PBMP_PORT_REMOVE((*pause_bmp), port);
            }
        }
    }
#endif /* BCM_TOMAHAWK2_SUPPORT */

    return rv;
}

/**
 * Function:
 *      bcm_esw_asf_diag
 * Purpose:
 *      Dump all ASF configurations specific to the unit
 * Parameters:
 *      unit - (IN) Unit number
 * Returns:
 *      BCM_E_xxx
 */
int
bcm_esw_asf_diag(int unit)
{
    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    if (!soc_feature(unit, soc_feature_asf_multimode)) {
        return BCM_E_UNAVAIL;
    }

#ifdef BCM_MAVERICK2_SUPPORT
    if (SOC_IS_MAVERICK2(unit)) {
        return soc_mv2_asf_config_dump(unit);
    } else
#endif
#ifdef BCM_TRIDENT3_SUPPORT
    if (SOC_IS_TRIDENT3X(unit)) {
        return soc_td3_asf_config_dump(unit);
    } else
#endif
#ifdef BCM_TOMAHAWK3_SUPPORT
    if(SOC_IS_TOMAHAWK3(unit)) {
        return soc_th3_asf_config_dump(unit);
    } else
#endif
    if (SOC_IS_TOMAHAWKX(unit)) {
        return soc_th_asf_config_dump(unit);
    }

    return BCM_E_UNAVAIL;
}

/**
 * Function:
 *      bcm_esw_port_asf_show
 * Purpose:
 *      Display formatted ASF information for a port
 * Parameters:
 *      unit - (IN) Unit number
 *      port - (IN) Logical port
 * Returns:
 *      BCM_E_xxx
 */
int
bcm_esw_port_asf_show(
    int          unit,
    bcm_port_t   port)
{
    int speed;
    soc_info_t *si;

    if (!(si = &SOC_INFO(unit))) {
        return SOC_E_INTERNAL;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    if (!soc_feature(unit, soc_feature_asf_multimode)) {
        return BCM_E_UNAVAIL;
    }
    if(!SOC_IS_TOMAHAWK3(unit)) {
    
        BCM_IF_ERROR_RETURN(bcm_esw_port_speed_get(unit, port, &speed));
    } else {
        speed = si->port_init_speed[port];
    }
#ifdef BCM_MAVERICK2_SUPPORT
    if (SOC_IS_MAVERICK2(unit)) {
        return soc_mv2_port_asf_show(unit, port, speed);
    } else
#endif
#ifdef BCM_TRIDENT3_SUPPORT
    if (SOC_IS_TRIDENT3X(unit)) {
        return soc_td3_port_asf_show(unit, port, speed);
    } else
#endif
#ifdef BCM_TOMAHAWK3_SUPPORT
    if(SOC_IS_TOMAHAWK3(unit)) {
        return soc_th3_port_asf_show(unit, port, speed);
    } else
#endif
    if (SOC_IS_TOMAHAWKX(unit)) {
        return soc_th_port_asf_show(unit, port, speed);
    }

    return BCM_E_UNAVAIL;
}

/**
 * Function:
 *      bcm_esw_port_asf_diag
 * Purpose:
 *      Dump all related ASF configurations for the given port
 * Parameters:
 *      unit - (IN) Unit number
 *      port - (IN) Logical port
 * Returns:
 *      BCM_E_xxx
 */
int
bcm_esw_port_asf_diag(
    int          unit,
    bcm_port_t   port)
{
    int speed;
    soc_info_t *si;

    if (!(si = &SOC_INFO(unit))) {
        return SOC_E_INTERNAL;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);
    if (!soc_feature(unit, soc_feature_asf_multimode)) {
        return BCM_E_UNAVAIL;
    }
    if(!SOC_IS_TOMAHAWK3(unit)) {
    
        BCM_IF_ERROR_RETURN(bcm_esw_port_speed_get(unit, port, &speed));
    } else {
        speed = si->port_init_speed[port];
    }
#ifdef BCM_MAVERICK2_SUPPORT
    if (SOC_IS_MAVERICK2(unit)) {
        return soc_mv2_port_asf_config_dump(unit, port, speed);
    } else
#endif
#ifdef BCM_TRIDENT3_SUPPORT
    if (SOC_IS_TRIDENT3X(unit)) {
        return soc_td3_port_asf_config_dump(unit, port, speed);
    } else
#endif
#ifdef BCM_TOMAHAWK3_SUPPORT
    if (SOC_IS_TOMAHAWK3(unit)) {
        return soc_th3_port_asf_config_dump(unit, port, speed);
    } else
#endif
    if (SOC_IS_TOMAHAWKX(unit)) {
        return soc_th_port_asf_config_dump(unit, port, speed);
    }

    return BCM_E_UNAVAIL;
}
#endif /* BCM_TOMAHAWK_SUPPORT */

/**
 * Function :
 *      _bcm_esw_port_sw_info_display
 * Purpose:
 *      To display status of port related software structures
 * Parameters:
 *      unit - (IN) Unit number
 *      port - (IN) Port number
 * Returns :
 *      BCM_E_xxxx
 * Note:
 *      Implementation currently limited to KATANA2 and SABER2 ONLY
 */
int
_bcm_esw_port_sw_info_display(int unit, bcm_port_t port)
{
#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_ml_port_sw_info_display(unit, port));
    } else
#endif
#ifdef BCM_SABER2_SUPPORT
    if (SOC_IS_SABER2(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_sb2_port_sw_info_display(unit, port));
    } else
#endif
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_kt2_port_sw_info_display(unit, port));
    } else
#endif
    {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit,
                          "_bcm_esw_port_sw_info_display \
                          implementation not implemented\n")));
        return SOC_E_UNIT;
    }

    return BCM_E_NONE;
}

/**
 * Function :
 *      _bcm_esw_port_hw_info_display
 * Purpose:
 *     To display status of port related harware registers.
 * Parameters:
 *     unit - (IN) Unit number.
 *     port - (IN) Port number
 * Returns:
 *     BCM_E_xxxx
 * Notes:
 *      Implementation currently limited to KATANA2 and SABER2 ONLY
 */
int
_bcm_esw_port_hw_info_display(int unit, bcm_port_t port)
{
#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_ml_port_hw_info_display(unit, port));
    } else
#endif
#ifdef BCM_SABER2_SUPPORT
    if (SOC_IS_SABER2(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_sb2_port_hw_info_display(unit, port));
    } else
#endif
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
    BCM_IF_ERROR_RETURN(_bcm_kt2_port_hw_info_display(unit, port));
    } else
#endif
    {
        LOG_ERROR(BSL_LS_BCM_PORT,
                  (BSL_META_U(unit,
                          "_bcm_esw_port_hw_info_display \
                          implementation not implemented\n")));
        return SOC_E_UNIT;
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcmi_esw_port_resource_portmod_support_check
 * Purpose:
 *      - Validates if all ports in resource array are supported by portmod
 * Parameters:
 *      unit     - (IN) Unit number.
 *      nport    - (IN) Number of logical port.
 *      resource - (IN) Port resource configuration.
 * Returns:
 *      BCM_E_XXX
 */
 int
 bcmi_esw_port_resource_portmod_support_check(int unit,
                                              int nport,
                                              bcm_port_resource_t *res)
 {
#if defined(BCM_XGS5_SWITCH_PORT_SUPPORT) && \
    defined(BCM_MIXED_LEGACY_AND_PORTMOD_SUPPORT)
     int idx, port;
     int rv = BCM_E_NONE;

     if (soc_feature(unit, soc_feature_mixed_legacy_and_portmod)) {
         if ((nport < 0) || (nport > SOC_MAX_NUM_PORTS)) {
             return BCM_E_PARAM;
         }

         if (res == NULL) {
             return BCM_E_PARAM;
         }

         for (idx = 0; idx < nport; idx++) {
             rv = bcmi_xgs5_port_addressable_local_get(unit, res[idx].port,
                                                       &port);
             if (BCM_SUCCESS(rv)) {
                 if (SOC_IS_HURRICANE4(unit) && IS_EGPHY_PORT(unit, port)) {
                     return BCM_E_PARAM;
                 }
             }
         }
     }
#endif
     return BCM_E_NONE;
 }

/*
 * Function:
 *      bcm_esw_port_resource_set
 * Purpose:
 *      Modify the following port resources:
 *      - Logical to physical port mapping
 *      - Speed
 *      - Number of PHY lanes
 *      - Encapsulation mode
 * Parameters:
 *      unit     - (IN) Unit number.
 *      port     - (IN) Logical port.
 *      resource - (IN) Port resource configuration.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_resource_set(int unit,
                          bcm_gport_t port, bcm_port_resource_t *resource)
{
    int rv = BCM_E_UNAVAIL;

    PORT_INIT(unit);

    PORT_LOCK(unit);

    if (BCM_ESW_PORT_DRV(unit)!= NULL) {
        if (BCM_ESW_PORT_DRV(unit)->resource_set != NULL) {
            rv = bcmi_esw_port_resource_portmod_support_check(unit,
                                                              1, resource);
            if (BCM_SUCCESS(rv)) {
                rv = BCM_ESW_PORT_DRV(unit)->resource_set(unit, port, resource);
            }
        }
    }

    if (BCM_SUCCESS(rv) && (BCM_ESW_PORT_DRV(unit)->resource_status_update != NULL)) {
        BCM_ESW_PORT_DRV(unit)->resource_status_update(unit, 1, resource);
    }

    PORT_UNLOCK(unit);

    return rv;
}


/*
 * Function:
 *      bcm_esw_port_resource_get
 * Purpose:
 *      Get the port resource configuration for the specified logical port.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      port      - (IN) Logical port.
 *      resource  - (OUT) Returns port resource information.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_resource_get(int unit,
                          bcm_gport_t port, bcm_port_resource_t *resource)
{
    int rv = BCM_E_UNAVAIL;

    PORT_INIT(unit);

    PORT_LOCK(unit);

    if (BCM_ESW_PORT_DRV(unit)!= NULL) {
        if (BCM_ESW_PORT_DRV(unit)->resource_get != NULL) {
            rv = BCM_ESW_PORT_DRV(unit)->resource_get(unit, port, resource);
        }
    }

    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_resource_multi_set
 * Purpose:
 *      Modify the following port resources:
 *      - Logical to physical port mapping
 *      - Speedu
 *      - Number of PHY lanes
 *      - Encapsulation mode
 * Parameters:
 *      unit     - (IN) Unit number.
 *      nport    - (IN) Number of elements in array resource.
 *      resource - (IN) Port resource configuration array.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_resource_multi_set(int unit,
                                int nport, bcm_port_resource_t *resource)
{
    int rv = BCM_E_UNAVAIL;

    PORT_INIT(unit);

    PORT_LOCK(unit);

    if (BCM_ESW_PORT_DRV(unit)!= NULL) {
        if (BCM_ESW_PORT_DRV(unit)->resource_multi_set != NULL) {
            rv = bcmi_esw_port_resource_portmod_support_check(unit,
                                                              nport, resource);
            if (BCM_SUCCESS(rv)) {
                rv = BCM_ESW_PORT_DRV(unit)->resource_multi_set(unit, nport,
                                                                resource);
            }
        }
    }

    if (BCM_SUCCESS(rv) && (BCM_ESW_PORT_DRV(unit)->resource_status_update != NULL)) {
        BCM_ESW_PORT_DRV(unit)->resource_status_update(unit, nport, resource);
    }

    PORT_UNLOCK(unit);

    return rv;
}
/*
 * Function:
 *      bcm_esw_port_resource_speed_config_validate
 * Purpose:
 *      Validate the resource configuration
 * Parameters:
 *      unit      - (IN) Unit number.
 *      resource  - (IN) Port resource information.
 *      pbmp      - (OUT) Returns the affected sister ports
 * Returns:
 *      BCM_E_NONE - Config is honred without affecting sister ports
 *      BCM_E_PARAM - Config will affect sister ports in pbmp
 */
int
bcm_esw_port_resource_speed_config_validate(int unit,
                           bcm_port_resource_t *resource, bcm_pbmp_t *pbmp)
{
    int rv = BCM_E_UNAVAIL;

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Call Port Control module */
    if (SOC_USE_PORTCTRL(unit)) {
        BCM_IF_ERROR_RETURN
            (bcmi_esw_port_resource_portmod_support_check(unit,
                                                          1, resource));
        rv = bcmi_esw_portctrl_resource_speed_config_validate(unit,
                                                            resource, pbmp);
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_resource_speed_get
 * Purpose:
 *      Get the speed port resource configuration for the specified logical
 *      port.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      port      - (IN) Logical port.
 *      resource  - (OUT) Returns port resource information.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_resource_speed_get(int unit,
                          bcm_gport_t port, bcm_port_resource_t *resource)
{
    int rv = BCM_E_UNAVAIL;

    rv = bcm_esw_port_resource_get(unit, port, resource);

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_resource_speed_set
 * Purpose:
 *      Modify the following port resources:
 *      - Speed
 *      Note: The parameter for this function will be used to derive the
 *            associated physical port
 * Parameters:
 *      unit     - (IN) Unit number.
 *      gport    - (IN) Logical Port.
 *      resource - (IN) Port resource configuration array.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_resource_speed_set(int unit,
                                bcm_gport_t port, bcm_port_resource_t *resource)
{
    int rv = BCM_E_UNAVAIL;
    int lport;

    if (NULL == resource) {
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &lport));

    /* Use the passed in logical port to be consistent with port_speed_set */
    resource->port = lport;

    rv = bcm_esw_port_resource_speed_multi_set(unit, 1, resource);

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_resource_speed_multi_set
 * Purpose:
 *      Modify the following port resources:
 *      - Speed
 * Parameters:
 *      unit     - (IN) Unit number.
 *      nport    - (IN) Number of elements in array resource.
 *      resource - (IN) Port resource configuration array.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_resource_speed_multi_set(int unit,
                                int nport, bcm_port_resource_t *resource)
{
    int i, max_speed;
    pbmp_t pbm;
    int *enable;
    int rv = BCM_E_UNAVAIL;


    PORT_INIT(unit);

    /* Do this check because we don't want to allocate 4 billion ints
     * if there's bad input
     */
    if ((nport < 0) || (nport > SOC_MAX_NUM_PORTS)) {
        return BCM_E_PARAM;
    }

    if (resource == NULL) {
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN
        (bcmi_esw_port_resource_portmod_support_check(unit,
                                                      nport, resource));

    enable = sal_alloc(nport * sizeof(int), "port enable array");
    if (NULL == enable) {
        return BCM_E_MEMORY;
    }

    /* Iterate through each entry and do some sanity checks */
    for (i = 0; i < nport; i++) {
        rv = (_bcm_esw_port_gport_validate(unit,
                    resource[i].port, &resource[i].port));
        if(!BCM_SUCCESS(rv)) {
            goto speed_multi_cleanup;
        }

        rv = (bcm_esw_port_speed_max(unit,resource[i].port, &max_speed));
        if(!BCM_SUCCESS(rv)) {
            goto speed_multi_cleanup;
        }


        if ((resource[i].speed < 0) || (resource[i].speed > max_speed)) {
            if ((resource[i].speed > max_speed) &&
                !soc_feature(unit, soc_feature_flexport_based_speed_set))
            rv = BCM_E_PARAM;
            if(!BCM_SUCCESS(rv)) {
                goto speed_multi_cleanup;
            }
        }

        /*
         * When performing flexport based speed changes, disable port
         * first prior to affecting speed change, but keep track of whether
         * the port was enabled
         */
        if (soc_feature(unit, soc_feature_flexport_based_speed_set) &&
            !SOC_PBMP_MEMBER(PBMP_MANAGEMENT(unit), resource[i].port) &&
            !SOC_PORT_USE_PORTCTRL(unit, resource[i].port)) {
            rv = (bcm_esw_port_enable_get(unit,
                                        resource[i].port, &enable[i]));
            if(!BCM_SUCCESS(rv)) {
                goto speed_multi_cleanup;
            }

            if (TRUE == enable[i]) {
                rv = (bcm_esw_port_enable_set(unit, resource[i].port, FALSE));
                if(!BCM_SUCCESS(rv)) {
                    goto speed_multi_cleanup;
                }

            }
        }

    }
    PORT_LOCK(unit);
    rv = bcmi_esw_portctrl_speed_multi_set(unit, nport, resource);
    PORT_UNLOCK(unit);
    if(!BCM_SUCCESS(rv)) {
        goto speed_multi_cleanup;
    }

    for (i = 0; i < nport; i++) {
        /*
         * Restore port's enable state based on what was read prior
         * to setting speed
         */
        if (soc_feature(unit, soc_feature_flexport_based_speed_set) &&
            !SOC_PBMP_MEMBER(PBMP_MANAGEMENT(unit), resource[i].port) &&
            !SOC_PORT_USE_PORTCTRL(unit, resource[i].port)) {
            if (TRUE == enable[i]) {
                rv = bcm_esw_port_enable_set(unit, resource[i].port, TRUE);
                if(!BCM_SUCCESS(rv)) {
                    goto speed_multi_cleanup;
                }
            }
        }

        if (BCM_SUCCESS(rv) && !SAL_BOOT_SIMULATION) {
            SOC_PBMP_CLEAR(pbm);
            SOC_PBMP_PORT_ADD(pbm, resource[i].port);
            (void)bcm_esw_link_change(unit, pbm);
        }

        rv = _bcm_esw_port_link_delay_update(unit, resource[i].port,
                                                resource[i].speed);
        if(!BCM_SUCCESS(rv)) {
            goto speed_multi_cleanup;
        }
    }


speed_multi_cleanup:
    if (NULL != enable) {
        sal_free(enable);
    }

    return rv;
}
/*
 * Function:
 *      bcm_esw_port_resource_traverse
 * Purpose:
 *      Iterates over the port resource configurations on a given
 *      unit and calls user-provided callback for every entry.
 * Parameters:
 *      unit       - (IN) Unit number.
 *      trav_fn    - (IN) Callback function to execute.
 *      user_data  - (IN) Pointer to any user data.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_resource_traverse(int unit,
                               bcm_port_resource_traverse_cb trav_fn,
                               void *user_data)
{
    int rv = BCM_E_UNAVAIL;

    PORT_INIT(unit);

    PORT_LOCK(unit);

    if (BCM_ESW_PORT_DRV(unit)!= NULL) {
        if (BCM_ESW_PORT_DRV(unit)->resource_traverse != NULL) {
            rv = BCM_ESW_PORT_DRV(unit)->resource_traverse(unit, trav_fn,
                                                           user_data);
        }
    }

    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_priority_group_mapping_set
 * Purpose:
 *      Assign a Priority Group for the input priority.
 * Parameters:
 *      unit       - (IN) device id.
 *      gport     - (IN) generic port.
 *      prio       - (IN) input priority.
 *      priority_group  - (IN) priority group ID that the input priority mapped to.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_priority_group_mapping_set(int unit, bcm_gport_t gport, int prio, int priority_group)
{
    int rv = BCM_E_UNAVAIL;

    PORT_INIT(unit);
    if (soc_feature(unit, soc_feature_priority_flow_control)) {
#ifdef BCM_SABER2_SUPPORT
        if (SOC_IS_SABER2(unit)) {
            return (bcm_kt2_port_priority_group_mapping_set(unit, gport, prio, priority_group));
        }
#endif
#if defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_gh_style_pfc_config)) {
            return (bcm_gh_port_priority_group_mapping_set(unit, gport, prio, priority_group));
        }
#endif /* BCM_GREYHOUND_SUPPORT */
#if defined(BCM_TRIDENT3_SUPPORT)
        if (SOC_IS_TRIDENT3X(unit)) {
            return (bcm_td3_port_priority_group_mapping_set(unit, gport, prio,
                                                            priority_group));
        }
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TRIDENT2(unit) || SOC_IS_TRIDENT2PLUS(unit) ||
            SOC_IS_TITAN2X(unit)) {
            return (bcm_td2_port_priority_group_mapping_set(unit, gport, prio,
                                                            priority_group));
        }
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TOMAHAWK3_SUPPORT)
        if (SOC_IS_TOMAHAWK3(unit)) {
            return BCM_E_UNAVAIL;
        }
#endif /* BCM_TOMAHAWK3_SUPPORT */
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (SOC_IS_TOMAHAWKX(unit)) {
            return (bcm_th_port_priority_group_mapping_set(unit, gport, prio,
                                                            priority_group));
        }
#endif /* BCM_TOMAHAWK_SUPPORT */
#if defined(BCM_APACHE_SUPPORT)
        if (SOC_IS_APACHE(unit)){
            return (bcm_ap_port_priority_group_mapping_set(unit, gport, prio,
                                                            priority_group));
        }
#endif
    }
    return rv;
}

/*
 * Function:
 *      bcm_esw_port_priority_group_mapping_get
 * Purpose:
 *      Get the assigned Priority Group ID of the input priority.
 * Parameters:
 *      unit       - (IN) device id.
 *      gport     - (IN) generic port.
 *      prio       - (IN) input priority.
 *      priority_group  - (OUT) priority group ID that the input priority mapped to.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_priority_group_mapping_get(int unit, bcm_gport_t gport, int prio, int *priority_group)
{
    int rv = BCM_E_UNAVAIL;

    PORT_INIT(unit);
    if (soc_feature(unit, soc_feature_priority_flow_control)) {
#ifdef BCM_SABER2_SUPPORT
        if (SOC_IS_SABER2(unit)) {
            return (bcm_kt2_port_priority_group_mapping_get(unit, gport, prio, priority_group));
        }
#endif

#if defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_gh_style_pfc_config)) {
            return (bcm_gh_port_priority_group_mapping_get(unit, gport, prio, priority_group));
        }
#endif /* BCM_GREYHOUND_SUPPORT */
#if defined(BCM_TRIDENT3_SUPPORT)
        if (SOC_IS_TRIDENT3X(unit)) {
            return (bcm_td3_port_priority_group_mapping_get(unit, gport, prio,
                                                            priority_group));
        }
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT)
        if (SOC_IS_TRIDENT2(unit) || SOC_IS_TRIDENT2PLUS(unit) ||
            SOC_IS_TITAN2X(unit)) {
            return (bcm_td2_port_priority_group_mapping_get(unit, gport, prio,
                                                            priority_group));
        }
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TOMAHAWK3_SUPPORT)
        if (SOC_IS_TOMAHAWK3(unit)) {
            return BCM_E_UNAVAIL;
        }
#endif /* BCM_TOMAHAWK3_SUPPORT */
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (SOC_IS_TOMAHAWKX(unit)) {
            return (bcm_th_port_priority_group_mapping_get(unit, gport, prio,
                                                            priority_group));
        }
#endif /* BCM_TOMAHAWK_SUPPORT */
#if defined(BCM_APACHE_SUPPORT)
        if (SOC_IS_APACHE(unit)) {
            return (bcm_ap_port_priority_group_mapping_get(unit, gport, prio,
                                                            priority_group));
        }
#endif
    }
    return rv;
}

/*
 * Function:
 *      bcm_esw_port_priority_group_config_set
 * Purpose:
 *      Set the port priority group configuration.
 * Parameters:
 *      unit       - (IN) device id.
 *      gport     - (IN) generic port.
 *      priority_group - (IN) priority group id.
 *      prigrp_config  - (IN) structure describes port priority group configuration.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_priority_group_config_set(int unit, bcm_gport_t gport, int priority_group, bcm_port_priority_group_config_t *prigrp_config)
{
    int rv = BCM_E_UNAVAIL;

    PORT_INIT(unit);
    if (soc_feature(unit, soc_feature_priority_flow_control)) {
#if defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_gh_style_pfc_config)) {
            return (bcm_gh_port_priority_group_config_set(unit, gport, priority_group, prigrp_config));
        }
#endif /* BCM_GREYHOUND_SUPPORT */
#if defined(BCM_TRIDENT3_SUPPORT)
        if (SOC_IS_TRIDENT3X(unit)) {
            return (bcm_td3_port_priority_group_config_set(unit, gport,
                        priority_group, prigrp_config));
        }
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_MONTEREY_SUPPORT)
        if (SOC_IS_TRIDENT2(unit) || SOC_IS_TRIDENT2PLUS(unit) ||
            SOC_IS_TITAN2X(unit) || SOC_IS_MONTEREY(unit) ||
            SOC_IS_APACHE(unit)) {
            if (SOC_PORT_USE_PORTCTRL(unit, gport)) {
                return bcmi_esw_portctrl_priority_group_config_set(unit, gport,
                        priority_group, prigrp_config);
            }
            return (bcm_td2_port_priority_group_config_set(unit, gport,
                        priority_group, prigrp_config));
        }
#endif /* BCM_TRIDENT2_SUPPORT */
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (SOC_IS_TOMAHAWKX(unit) && !SOC_IS_TOMAHAWK3(unit)) {
            return (bcm_th_port_priority_group_config_set(unit, gport,
                        priority_group, prigrp_config));
        }
#endif /* BCM_TOMAHAWK_SUPPORT */

#if defined(BCM_TOMAHAWK3_SUPPORT)
        if(SOC_IS_TOMAHAWK3(unit)) {
            return (bcm_th3_port_priority_group_config_set(unit, gport,
                        priority_group, prigrp_config));
        }
#endif

    }
    return rv;
}

/*
 * Function:
 *      bcm_esw_port_priority_group_config_get
 * Purpose:
 *      Get the port priority group configuration.
 * Parameters:
 *      unit       - (IN) device id.
 *      gport     - (IN) generic port.
 *      priority_group - (IN) priority group id.
 *      prigrp_config  - (OUT) structure describes port priority group configuration.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_port_priority_group_config_get(int unit, bcm_gport_t gport, int priority_group, bcm_port_priority_group_config_t *prigrp_config)
{
    int rv = BCM_E_UNAVAIL;

    PORT_INIT(unit);
    if (soc_feature(unit, soc_feature_priority_flow_control)) {
#if defined(BCM_GREYHOUND_SUPPORT)
        if (soc_feature(unit, soc_feature_gh_style_pfc_config)) {
            return (bcm_gh_port_priority_group_config_get(unit, gport, priority_group, prigrp_config));
        }
#endif /* BCM_GREYHOUND_SUPPORT */
#if defined(BCM_TRIDENT3_SUPPORT)
        if (SOC_IS_TRIDENT3X(unit)) {
            return (bcm_td3_port_priority_group_config_get(unit, gport,
                        priority_group, prigrp_config));
        }
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_MONTEREY_SUPPORT)
        if (SOC_IS_TRIDENT2(unit) || SOC_IS_TRIDENT2PLUS(unit) ||
            SOC_IS_TITAN2X(unit) || SOC_IS_MONTEREY(unit) ||
            SOC_IS_APACHE(unit)) {
            return (bcm_td2_port_priority_group_config_get(unit, gport,
                        priority_group, prigrp_config));
        }
#endif /* BCM_TRIDENT2_SUPPORT */

#if defined(BCM_TOMAHAWK3_SUPPORT)
        if (SOC_IS_TOMAHAWK3(unit)) {
            return (bcm_th3_port_priority_group_config_get(unit, gport,
                        priority_group, prigrp_config));
        }
#endif /* BCM_TOMAHAWK3_SUPPORT */

#if defined(BCM_TOMAHAWK_SUPPORT)
        if (SOC_IS_TOMAHAWKX(unit)) {
            return (bcm_th_port_priority_group_config_get(unit, gport,
                        priority_group, prigrp_config));
        }
#endif /* BCM_TOMAHAWK_SUPPORT */

    }
    return rv;
}

/*
 * Function:
 *      bcm_esw_port_redirect_config_t_init
 * Purpose:
 *      Initialize the redirection config structure
 * Parameters:
 *      redirect_config  - (IN) Pointer to the redirection config structure
 * Returns:
 *      None
 */
void bcm_esw_port_redirect_config_t_init(
                    bcm_port_redirect_config_t *redirect_config)
{
    return;
}

/*
 * Function:
 *      bcm_esw_port_redirect_set
 * Purpose:
 *      Configure the redirection data
 * Parameters:
 *      unit             - (IN) device id.
 *      port             - (IN) Port number.
 *      redirect_config  - (IN) Pointer to the redirection config structure
 * Returns:
 *      None
 */
int
bcm_esw_port_redirect_config_set(int unit, int port,
                                 bcm_port_redirect_config_t *redirect_config)
{
    int rv = BCM_E_UNAVAIL;

    PORT_INIT(unit);

    PORT_LOCK(unit);

    if (BCM_ESW_PORT_DRV(unit)!= NULL) {
        if (BCM_ESW_PORT_DRV(unit)->port_redirect_set != NULL) {
            rv = BCM_ESW_PORT_DRV(unit)->port_redirect_set(unit, port,
                                                            redirect_config);
        }
    }

    PORT_UNLOCK(unit);

    return rv;
}


/*
 * Function:
 *      bcm_esw_port_redirect_get
 * Purpose:
 *      Configure the redirection data
 * Parameters:
 *      unit             - (IN) device id.
 *      port             - (IN) Port number.
 *      redirect_config  - (IN) Pointer to the redirection config structure
 * Returns:
 *      None
 */
int
bcm_esw_port_redirect_config_get(int unit, int port,
                                 bcm_port_redirect_config_t *redirect_config)
{
    int rv = BCM_E_UNAVAIL;

    PORT_INIT(unit);

    PORT_LOCK(unit);

    if (BCM_ESW_PORT_DRV(unit)!= NULL) {
        if (BCM_ESW_PORT_DRV(unit)->port_redirect_get != NULL) {
            rv = BCM_ESW_PORT_DRV(unit)->port_redirect_get(unit, port,
                                                            redirect_config);
        }
    }

    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function    : _bcm_esw_glp_bits_pos
 * Description : Internal function to get modid, port, and trunk_id
 *               from a glp
 * Parameters  : (IN)  unit          - BCM device number
 *               (OUT) trunk_pos     - Trunk ID position
 *               (OUT) max_modid     - Max module ID bits
 *               (OUT) modid_pos     - Module ID position
 *               (OUT) max_port      - Max port addr bits
 * Returns     : BCM_E_XXX
 * Notes       : The trunkid, modid and port are used for 16 bits {T, MODID[7:0], PORT[7:0]},
 *               get qualifiers for GLP related fields in FP_TCAM
 */
static int
_bcm_esw_glp_bits_pos(int unit,
                      uint8 *trunk_pos, uint8 *max_modid,
                      uint8 *modid_pos, uint8 *max_port)
{
    if ((NULL == trunk_pos) || (NULL == max_modid) || (NULL == modid_pos) ||
        (NULL == max_port)) {
        return BCM_E_PARAM;
    }

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_KATANA2_SUPPORT)  || \
    defined(BCM_TITAN_SUPPORT)  || defined(BCM_TRIDENT_SUPPORT)  || \
    defined(BCM_TITAN2_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT) || \
    defined(BCM_HELIX4_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_SABER2_SUPPORT) || defined(BCM_TRIDENT2PLUS_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
    if(SOC_IS_KATANA(unit) || SOC_IS_KATANA2(unit)  ||
            SOC_IS_TITAN(unit)  || SOC_IS_TRIDENT(unit)  ||
            SOC_IS_TITAN2(unit) || SOC_IS_TRIDENT2(unit) ||
            SOC_IS_HELIX4(unit) || SOC_IS_TRIUMPH3(unit) ||
            SOC_IS_SABER2(unit) || SOC_IS_TRIDENT2PLUS(unit) ||
            SOC_IS_APACHE(unit) || SOC_IS_GREYHOUND2(unit)) {
        *trunk_pos = 15;
        *max_modid = 0xff;
        *modid_pos = 7;
        *max_port  = 0x7f;
    } else
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (SOC_IS_TOMAHAWKX(unit)) {
            *trunk_pos = 16;
            *max_modid = 0xff;
            *modid_pos = 8;
            *max_port  = 0xff;
        } else
#endif
#if defined(BCM_CONQUEROR_SUPPORT) || defined(BCM_SCORPION_SUPPORT) || \
    defined(BCM_SHADOW_SUPPORT)
            if (SOC_IS_CONQUEROR(unit) || SOC_IS_SCORPION(unit) ||
                SOC_IS_SHADOW(unit)) {
                *trunk_pos = 14;
                *max_modid = 0xff;
                *modid_pos = 6;
                *max_port  = 0x3f;
            } else
#endif
#if defined(BCM_RAPTOR_SUPPORT) || defined(BCM_RAVEN_SUPPORT) || \
            defined(BCM_HAWKEYE_SUPPORT)
            if (SOC_IS_RAPTOR(unit) || SOC_IS_RAVEN(unit) || SOC_IS_HAWKEYE(unit)) {
                *trunk_pos = 0;
                *max_modid = 0x0;
                *modid_pos = 6;
                *max_port  = 0x3f;
            } else
#endif
            {
                *trunk_pos = 13;
                *max_modid = 0x7f;
                *modid_pos = 6;
                *max_port  = 0x3f;
            }

    return BCM_E_NONE;
}

/*
 * Function    : _bcm_esw_glp_construct
 * Description : Internal function to set GLP port
 *               from modid, port, and trunk_id
 * Parameters  : (IN)  unit      - BCM device number
 *               (IN)  modid     - Module ID
 *               (IN)  port      - Port number
 *               (IN)  trunk_id  - Trunk ID
 *               (OUT) glp       - is trunk + modid + port num
 * Returns     : BCM_E_XXX
 * Notes       : The trunkid, modid and port are used for 16 bits {T, MODID[7:0], PORT[7:0]},
 *               set qualifiers for GLP related fields in FP_TCAM
 */
int
_bcm_esw_glp_construct(int unit, bcm_trunk_t trunk_id,
                       bcm_module_t modid, bcm_port_t port,
                       bcm_gport_t *glp)
{
    uint8 trunk_pos = 0;
    uint8 max_modid = 0;
    uint8 modid_pos = 0;
    uint8 max_port  = 0;

    if (NULL == glp) {
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN
        (_bcm_esw_glp_bits_pos(unit,
                       &trunk_pos, &max_modid,
                       &modid_pos, &max_port));

    if (trunk_id != BCM_TRUNK_INVALID) {
        *glp = ((1 << trunk_pos) | trunk_id);
    } else {
        *glp = (((modid & max_modid) << modid_pos) |
                   (port & max_port));
    }

    return BCM_E_NONE;
}

/*
 * Function    : _bcm_esw_glp_resolve
 * Description : Internal function to get modid, port, and trunk_id
 *               from a glp
 * Parameters  : (IN)  unit      - BCM device number
 *               (IN)  glp       - trunk + modid + port num
 *               (OUT) modid     - Module ID
 *               (OUT) port      - Port number
 *               (OUT) trunk_id  - Trunk ID
 * Returns     : BCM_E_XXX
 * Notes       : The trunkid, modid and port are used for 16 bits {T, MODID[7:0], PORT[7:0]},
 *               get qualifiers for GLP related fields in FP_TCAM
 */
int
_bcm_esw_glp_resolve(int unit, bcm_trunk_t *trunk_id,
                     bcm_module_t *modid, bcm_port_t *port,
                     bcm_gport_t glp)
{
    uint8 trunk_pos = 0;
    uint8 max_modid = 0;
    uint8 modid_pos = 0;
    uint8 max_port  = 0;

    if ((NULL == trunk_id) || (NULL == modid) || (NULL == port)){
        return BCM_E_PARAM;
    }

    BCM_IF_ERROR_RETURN
        (_bcm_esw_glp_bits_pos(unit,
                       &trunk_pos, &max_modid,
                       &modid_pos, &max_port));

    if (glp & (1 << trunk_pos)) {
        *trunk_id = (glp & ~(1 << trunk_pos));
    } else {
        *port = (glp & max_port);
        *modid = ((glp >> modid_pos) & max_modid);
    }

    return BCM_E_NONE;
}

/*
 * Function    : _bcm_esw_gport_to_glp
 * Description : Internal function to set GLP port from gport
 * Parameters  : (IN)  unit      - BCM device number
 *               (IN)  gport     - trunk + modid + port num
 *               (OUT) glp       - trunk + modid + port num
 * Returns     : BCM_E_XXX
 * Notes       : The glport as Eg: 16 bits {T, MODID[7:0], PORT[7:0]},
 *               get qualifiers for GLP related fields in FP_TCAM
 */
int
_bcm_esw_gport_to_glp(int unit, bcm_gport_t gport, bcm_gport_t *glp)
{
    bcm_trunk_t  trunk_id;
    bcm_module_t mod_id;
    bcm_port_t   port;
    int          local_id;

    if (BCM_GPORT_IS_SET(gport)) {
        SOC_IF_ERROR_RETURN(_bcm_esw_gport_resolve(unit, gport, &mod_id,
                    &port, &trunk_id, &local_id));

        BCM_IF_ERROR_RETURN
            (_bcm_esw_glp_construct(unit,
                                    trunk_id, mod_id,
                                    port, glp));
        return BCM_E_NONE;
    }

    return BCM_E_PARAM;
}

/*
 * Function:
 *      bcmi_esw_port_eee_cfg_get
 * Purpose:
 *      Set the eee_cfg value for given port.
 * Parameters:
 *      unit     - (IN) Unit number.
 *      port     - (IN) Logical port, BCM format.
 *      value    - (IN) Value to set.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcmi_esw_port_eee_cfg_set(int unit, bcm_port_t port, int value)
{
#if defined(BCM_HURRICANE_SUPPORT) || defined(BCM_TRIDENT_SUPPORT) || \
    defined(BCM_HAWKEYE_SUPPORT) || defined(BCM_SHADOW_SUPPORT) || \
    defined(BCM_HURRICANE2_SUPPORT)
    if ((port < 0) || (port >= SOC_MAX_NUM_PORTS)) {
        return BCM_E_PORT;
    }

    eee_cfg[unit][port] = value;

    return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
}


/*
 * Function:
 *      bcmi_esw_port_egr_prof_ptr_set
 * Purpose:
 *      Set the port_src_mod_egr_prof_ptr value for given port.
 * Parameters:
 *      unit          - (IN) Unit number.
 *      port          - (IN) Logical port, BCM format.
 *      egr_prof_ptr  - (IN) Value to set.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcmi_esw_port_egr_prof_ptr_set(int unit, bcm_port_t port, int value)
{
#ifdef BCM_TRIUMPH2_SUPPORT
    if ((port < 0) || (port >= SOC_MAX_NUM_PORTS)) {
        return BCM_E_PORT;
    }

    PORT_SRC_MOD_EGR_PROF_PTR(unit, port) = value;

    return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif /* BCM_TRIUMPH2_SUPPORT */
}


/*
 * Function:
 *      bcmi_port_force_lb_set
 * Purpose:
 *      Force port into internal loopback accroding to bond options.
 * Parameters:
 *      unit          - (IN) Unit number.
 *      port          - (IN) Logical port, BCM format.
 *      egr_prof_ptr  - (IN) Value to set.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcmi_port_force_lb_set(int unit)
{
    int rv = BCM_E_UNAVAIL;

    PORT_INIT(unit);

    PORT_LOCK(unit);

    if (BCM_ESW_PORT_DRV(unit)!= NULL) {
        if (BCM_ESW_PORT_DRV(unit)->force_lb_set != NULL) {
            rv = BCM_ESW_PORT_DRV(unit)->force_lb_set(unit);
        }
    }

    PORT_UNLOCK(unit);

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_preemption_control_set
 * Purpose:
 *      Set various configurations for Preemption.
 * Parameters:
 *      unit         - (IN) Unit number.
 *      gport        - (IN) gport id
 *      type         - (IN) preemption control type defined in bcm_port_preempt_control_t
 *      arg          - (IN) the preemption control value
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_preemption_control_set(int unit, bcm_gport_t gport,
                                    bcm_port_preempt_control_t type,
                                    uint32 arg)
{
    PORT_INIT(unit);

#if defined(BCM_PREEMPTION_SUPPORT)
    if (soc_feature(unit, soc_feature_preemption)) {
        bcm_port_t local_port;
        uint32 preempt_support;
#ifdef BCM_MONTEREY_SUPPORT
        int link = BCM_PORT_LINK_STATUS_DOWN;
#endif

        BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, gport, &local_port));
        if(!SOC_PBMP_MEMBER(PBMP_E_ALL(unit), local_port)) {
            /* hg port does not support preemption */
            BCM_IF_ERROR_RETURN(BCM_E_UNAVAIL);
        }
#ifdef BCM_MONTEREY_SUPPORT
        if (SOC_IS_MONTEREY(unit)) {
            if ((type == bcmPortPreemptControlVerifyTime) ||
                (type == bcmPortPreemptControlVerifyAttempts) ||
                (type == bcmPortPreemptControlVerifyEnable)) {
                return BCM_E_UNAVAIL;
            }
            if (type == bcmPortPreemptControlPreemptionSupport) {
                /* Intentionally supreesing return type to avoid unrelated error */
                (void)_bcm_esw_link_get(unit, local_port, &link);
                if (!arg && (link == BCM_PORT_LINK_STATUS_UP)) {
                    return BCM_E_CONFIG;
                }
            }
        }
#endif /* BCM_MONTEREY_SUPPORT */
        PORT_LOCK(unit);
        switch (type) {
            /*  only need set mac-related */
            case bcmPortPreemptControlEnableTx:
            case bcmPortPreemptControlVerifyEnable:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_capability_get(unit,
                                                       local_port,
                                                       &preempt_support));
                if (0 == preempt_support) {
                    /* need to enable preempt ability on this port first */
                    _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(BCM_E_PARAM);
                }
            /* fall-through */
            case bcmPortPreemptControlVerifyTime:
            case bcmPortPreemptControlVerifyAttempts:
            case bcmPortPreemptControlNonFinalFragSizeRx:
            case bcmPortPreemptControlFinalFragSizeRx:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_mac_config_set(unit,
                                                       local_port,
                                                       type, arg));
                break;
            /* only need setup chip-related */
            case bcmPortPreemptControlNonFinalFragSizeTx:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_frag_config_tx_set(unit,
                                                           local_port, 0,
                                                           arg));
                break;
            case bcmPortPreemptControlFinalFragSizeTx:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_frag_config_tx_set(unit,
                                                           local_port, 1,
                                                           arg));
                break;
            case bcmPortPreemptControlHoldReqCntMode:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_hold_request_mode_set(unit,
                                                              local_port,
                                                              arg));
                break;
            case bcmPortPreemptControlQueueBitmap:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_queue_bitmap_set(unit,
                                                         local_port,
                                                         arg));
                break;
            case bcmPortPreemptControlPreemptionSupport:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_capability_set(unit,
                                                       local_port,
                                                       arg));
                break;
            default:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(BCM_E_PARAM);

        }
        PORT_UNLOCK(unit);
        return BCM_E_NONE;
    } else
#endif /* BCM_PREEMPTION_SUPPORT */
    {
        return BCM_E_UNAVAIL;
    }
}


/*
 * Function:
 *      bcmi_esw_port_mac_type_get
 * Purpose:
 *      Get mactype for a given logical port
 * Parameters:
 *      unit         - (IN) Unit number.
 *      lport        - (IN) logical port
 *      type         - (OUT) mac type defined in bcmi_port_mac_type_t
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcmi_esw_port_mac_type_get(int unit, bcm_port_t lport,
                               bcmi_port_mac_type_t *type) {
#if defined(BCM_GREYHOUND2_SUPPORT)
    if(SOC_IS_GREYHOUND2(unit)) {
        return bcmi_gh2_port_mac_type_get(unit, lport, type);
    } else
#endif /* BCM_GREYHOUND2_SUPPORT */
    {
        if (NULL == type) {
            return SOC_E_PARAM;
        }
        *type = bcmiPortMacTypePortmode;
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_port_preemption_control_get
 * Purpose:
 *      Get various configurations for Preemption.
 * Parameters:
 *      unit         - (IN) Unit number.
 *      gport        - (IN) gport id
 *      type         - (IN) preemption control type defined in bcm_port_preempt_control_t
 *      arg          - (OUT) the preemption control value
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_port_preemption_control_get(int unit, bcm_gport_t gport,
                                    bcm_port_preempt_control_t type,
                                    uint32 *arg)
{
    PORT_INIT(unit);

#if defined(BCM_PREEMPTION_SUPPORT)
    if (soc_feature(unit, soc_feature_preemption)) {
        bcm_port_t local_port;

        BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, gport, &local_port));
        if(!SOC_PBMP_MEMBER(PBMP_E_ALL(unit), local_port)) {
            /* hg port does not support preemption */
            BCM_IF_ERROR_RETURN(BCM_E_UNAVAIL);
        }
#ifdef BCM_MONTEREY_SUPPORT
        if (SOC_IS_MONTEREY(unit)) {
            if ((type == bcmPortPreemptControlVerifyTime) ||
                (type == bcmPortPreemptControlVerifyAttempts) ||
                (type == bcmPortPreemptControlVerifyEnable)) {
                return BCM_E_UNAVAIL;
            }
        }
#endif /* BCM_MONTEREY_SUPPORT */
        PORT_LOCK(unit);
        switch (type) {
            /*  mac-related */
            case bcmPortPreemptControlEnableTx:
            case bcmPortPreemptControlVerifyEnable:
            case bcmPortPreemptControlVerifyTime:
            case bcmPortPreemptControlVerifyAttempts:
            case bcmPortPreemptControlNonFinalFragSizeRx:
            case bcmPortPreemptControlFinalFragSizeRx:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_mac_config_get(unit,
                                                       local_port,
                                                       type, arg));
                break;
            /* chip-related */
            case bcmPortPreemptControlNonFinalFragSizeTx:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_frag_config_tx_get(unit,
                                                           local_port, 0,
                                                           arg));
                break;
            case bcmPortPreemptControlFinalFragSizeTx:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_frag_config_tx_get(unit,
                                                           local_port, 1,
                                                           arg));
                break;
            case bcmPortPreemptControlHoldReqCntMode:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_hold_request_mode_get(unit,
                                                              local_port,
                                                              arg));
                break;
            case bcmPortPreemptControlQueueBitmap:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_queue_bitmap_get(unit,
                                                         local_port,
                                                         arg));
                break;
            case bcmPortPreemptControlPreemptionSupport:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_capability_get(unit,
                                                       local_port,
                                                       arg));
                break;
            default:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(BCM_E_PARAM);

        }
        PORT_UNLOCK(unit);
        return BCM_E_NONE;
    } else
#endif /* BCM_PREEMPTION_SUPPORT */
    {
        return BCM_E_UNAVAIL;
    }
}


/*
 * Function:
 *      bcm_esw_port_preemption_status_get
 * Purpose:
 *      Get the specified preemption status.
 * Parameters:
 *      unit         - (IN) Unit number.
 *      gport        - (IN) gport id
 *      type         - (IN) preemption status type defined in bcm_port_preempt_status_t
 *      status       - (OUT) the preemption status
 *                           For bcmPortPreemptStatusTx type, the status value
 *                           defined in bcm_port_preempt_status_tx_t.
 *                           For bcmPortPreemptStatusVerify type, the status value
 *                           defined in bcm_port_preempt_status_verify_t.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_port_preemption_status_get(int unit, bcm_gport_t gport,
                                       bcm_port_preempt_status_t type,
                                       uint32 *status)
{
    PORT_INIT(unit);

#if defined(BCM_PREEMPTION_SUPPORT)
    if (soc_feature(unit, soc_feature_preemption)) {
        bcm_port_t local_port;
        BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, gport, &local_port));
        PORT_LOCK(unit);
        switch (type) {
            case bcmPortPreemptStatusTx:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_status_tx_get(unit, local_port,
                                                      status));
                break;
            case bcmPortPreemptStatusVerify:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(
                    bcmi_esw_preemption_status_verify_get(unit, local_port,
                                                          status));
                break;
            default:
                _BCM_PORT_IF_ERROR_RETURN_WITH_UNLOCK(BCM_E_PARAM);
        }
        PORT_UNLOCK(unit);
        return BCM_E_NONE;
    } else
#endif /* BCM_PREEMPTION_SUPPORT */
    {
        return BCM_E_UNAVAIL;
    }
}

/*
 * Description:
 *      Enable and configure the remote module to apply E2EFC mechanism.
 *      Or disable it.
 * Parameter:
 *      unit           - (IN) unit number
 *      remote_module  - (IN) remote module id
 *      mode           - (IN) selected mode
 *      enable         - (IN) enable or disable selection
 *      e2efc_rmod_cfg - (IN) structure containing the configuration.
 *                       Ignored when enable = 0.
 */
int
bcm_esw_port_e2efc_remote_module_enable_set(
    int unit,
    bcm_module_t remote_module,
    bcm_port_e2efc_mode_t mode,
    int enable,
    bcm_port_e2efc_remote_module_config_t *e2efc_rmod_cfg)
{
    if (e2efc_rmod_cfg == NULL) {
        return BCM_E_UNAVAIL;
    }

    if (soc_feature(unit, soc_feature_e2efc)) {
#if defined(BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit)) {
            return bcmi_gh2_port_e2efc_remote_module_enable_set(unit,
                                remote_module, mode, enable, e2efc_rmod_cfg);
        }
#endif /* BCM_GREYHOUND2_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            return bcmi_kt2_port_e2efc_remote_module_enable_set(unit,
                                remote_module, mode, enable, e2efc_rmod_cfg);
        }
#endif /* BCM_KATANA2_SUPPORT */
    }

    return BCM_E_UNAVAIL;
}

/*
 * Description:
 *      Get the enable mode and configuration of the remote module that
 *      applies E2EFC mechanism.
 * Parameter:
 *      unit           - (IN) unit number
 *      remote_module  - (IN) remote module id
 *      mode           - (IN) selected mode
 *      enable         - (OUT) enable or disable selection
 *      e2efc_rmod_cfg - (OUT) structure containing the configuration.
 *                       Only valid if the remote module is enabled.
 */
int
bcm_esw_port_e2efc_remote_module_enable_get(
    int unit,
    bcm_module_t remote_module,
    bcm_port_e2efc_mode_t mode,
    int *enable,
    bcm_port_e2efc_remote_module_config_t *e2efc_rmod_cfg)
{

    if (e2efc_rmod_cfg == NULL || enable == NULL) {
        return BCM_E_UNAVAIL;
    }

    if (soc_feature(unit, soc_feature_e2efc)) {
#if defined(BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit)) {
            return bcmi_gh2_port_e2efc_remote_module_enable_get(unit,
                                remote_module, mode, enable, e2efc_rmod_cfg);
        }
#endif /* BCM_GREYHOUND2_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            return bcmi_kt2_port_e2efc_remote_module_enable_get(unit,
                                remote_module, mode, enable, e2efc_rmod_cfg);
        }
#endif /* BCM_KATANA2_SUPPORT */
    }

    return BCM_E_UNAVAIL;
}

/*
 * Description:
 *      Traverse enabled remote modules that apply E2EFC mechanism.
 * Parameter:
 *      unit      - (IN) unit number
 *      cb        - (IN) call back function to execute
 *      user_data - (IN) pointer to user data
*/
int
bcm_esw_port_e2efc_remote_module_traverse(
    int unit,
    bcm_port_e2efc_remote_module_traverse_cb cb,
    void *user_data)
{
    if ( user_data == NULL || cb == NULL) {
        return BCM_E_PARAM;
    }

    if (soc_feature(unit, soc_feature_e2efc)) {
#if defined(BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit)) {
            return bcmi_gh2_port_e2efc_remote_module_traverse(unit, cb,
                                                              user_data);
        }
#endif /* BCM_GREYHOUND2_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            return bcmi_kt2_port_e2efc_remote_module_traverse(unit, cb,
                                                              user_data);
        }
#endif /* BCM_KATANA2_SUPPORT */
    }
    return BCM_E_UNAVAIL;
}

/*
 * Description:
 *      Add remote module-port and set configuration.
 *      Return a handle id for the bcm_port_e2efc_remote_port_xxx APIs.
 *      The API of remote module-port configuration is only for E2EFC
 *      transmission.
 * Parameter:
 *      unit            - (IN) unit number
 *      e2efc_rport_cfg - (IN) structure containing the configuration
 *      rport_handle_id - (OUT) remote port handle id, to be used for the rest
 *                        of bcm_port_e2efc_remote_port_xxx APIs
 */
int
bcm_esw_port_e2efc_remote_port_add(
    int unit,
    bcm_port_e2efc_remote_port_config_t *e2efc_rport_cfg,
    int *rport_handle_id)
{
    if (e2efc_rport_cfg == NULL || rport_handle_id == NULL) {
        return BCM_E_UNAVAIL;
    }
    if (soc_feature(unit, soc_feature_e2efc)) {
#if defined(BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit)) {
            return bcmi_gh2_port_e2efc_remote_port_add(unit, e2efc_rport_cfg,
                                                       rport_handle_id);
        }
#endif /* BCM_GREYHOUND2_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            return bcmi_kt2_port_e2efc_remote_port_add(unit, e2efc_rport_cfg,
                                                       rport_handle_id);
        }
#endif /* BCM_KATANA2_SUPPORT */
    }
    return BCM_E_UNAVAIL;
}

/*
 * Description:
 *      Set (modify) configuration of the remote port.
 * Parameter:
 *      unit            - (IN) unit number
 *      rport_handle_id - (IN) remote port handle id
 *      e2efc_rport_cfg - (IN) structure containing the configuration
 */
int
bcm_esw_port_e2efc_remote_port_set(
    int unit,
    int rport_handle_id,
    bcm_port_e2efc_remote_port_config_t *e2efc_rport_cfg)
{
    if (e2efc_rport_cfg == NULL) {
        return BCM_E_UNAVAIL;
    }
    if (soc_feature(unit, soc_feature_e2efc)) {
#if defined(BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit)) {
            return bcmi_gh2_port_e2efc_remote_port_set(unit, rport_handle_id,
                                                       e2efc_rport_cfg);
        }
#endif /* BCM_GREYHOUND2_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            return bcmi_kt2_port_e2efc_remote_port_set(unit, rport_handle_id,
                                                       e2efc_rport_cfg);
        }
#endif /* BCM_KATANA2_SUPPORT */
    }
    return BCM_E_UNAVAIL;
}

/*
 * Description:
 *      Get configuration of the remote port.
 *      Return the remote module, remote port and configuration of the
 *      handle id.
 * Parameter:
 *      unit            - (IN) unit number
 *      rport_handle_id - (IN) remote port handle id
 *      e2efc_rport_cfg - (OUT) structure containing the configuration
 */
int
bcm_esw_port_e2efc_remote_port_get(
    int unit,
    int rport_handle_id,
    bcm_port_e2efc_remote_port_config_t *e2efc_rport_cfg)
{
    if (e2efc_rport_cfg == NULL) {
        return BCM_E_UNAVAIL;
    }
    if (soc_feature(unit, soc_feature_e2efc)) {
#if defined(BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit)) {
            return bcmi_gh2_port_e2efc_remote_port_get(unit, rport_handle_id,
                                                       e2efc_rport_cfg);
        }
#endif /* BCM_GREYHOUND2_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            return bcmi_kt2_port_e2efc_remote_port_get(unit, rport_handle_id,
                                                       e2efc_rport_cfg);
        }
#endif /* BCM_KATANA2_SUPPORT */
    }
    return BCM_E_UNAVAIL;
}

/*
 * Description:
 *      Delete remote port.
 * Parameter:
 *      unit            - (IN) unit number
 *      rport_handle_id - (IN) remote port handle id
 */
int
bcm_esw_port_e2efc_remote_port_delete(
    int unit,
    int rport_handle_id)
{

    if (soc_feature(unit, soc_feature_e2efc)) {
#if defined(BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit)) {
            return bcmi_gh2_port_e2efc_remote_port_delete(unit,
                                                          rport_handle_id);
        }
#endif /* BCM_GREYHOUND2_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            return bcmi_kt2_port_e2efc_remote_port_delete(unit,
                                                          rport_handle_id);
        }
#endif /* BCM_KATANA2_SUPPORT */
    }
    return BCM_E_UNAVAIL;
}

/*
 * Description:
 *      Traverse remote ports.
 * Parameter:
 *      unit      - (IN) unit number
 *      cb        - (IN) call back function to execute
 *      user_data - (IN) pointer to user data
 */
int
bcm_esw_port_e2efc_remote_port_traverse(
    int unit,
    bcm_port_e2efc_remote_port_traverse_cb cb,
    void *user_data)
{
    if ( user_data == NULL || cb == NULL) {
        return BCM_E_PARAM;
    }

    if (soc_feature(unit, soc_feature_e2efc)) {
#if defined(BCM_GREYHOUND2_SUPPORT)
        if (SOC_IS_GREYHOUND2(unit)) {
            return bcmi_gh2_port_e2efc_remote_port_traverse(unit, cb,
                                                            user_data);
        }
#endif /* BCM_GREYHOUND2_SUPPORT */

#if defined(BCM_KATANA2_SUPPORT)
        if (SOC_IS_KATANA2(unit)) {
            return bcmi_kt2_port_e2efc_remote_port_traverse(unit, cb,
                                                            user_data);
        }
#endif /* BCM_KATANA2_SUPPORT */
    }
    return BCM_E_UNAVAIL;
}

#ifdef SW_AUTONEG_SUPPORT
/*
 * Function    : _bcm_esw_port_notify_link_down_evt
 * Description : Notify Link_Down event to SW AN SM.
 * Parameters  : (IN) unit      - BCM device number
 *               (IN) port       - Port number
 * Returns     : BCM_E_XXX
 */
int
_bcm_esw_port_notify_link_down_evt(int unit, bcm_port_t port)
{
    int    an_mode = 0;
    int    an_enabled = 0;
    int    rv = BCM_E_NONE;

    if (soc_feature(unit, soc_feature_sw_autoneg)) {
        /* if the link is down notify the SW AN thread
         * to restart AN if AN is enabled for the port
         */
        an_mode = soc_property_port_get(unit, port,
                          spn_PHY_AN_C73, an_mode);

        /* phy_an_c73 value of 3 indicated MSA AN mode */
        if ((an_mode == SW_AN_MODE_CL73_MSA) ||
            (an_mode == SW_AN_MODE_MSA_ONLY)) {


            rv = bcm_esw_port_autoneg_get(unit, port , &an_enabled);
            if (BCM_FAILURE(rv)) {
                LOG_WARN(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                                     "u=%d p=%d AUTONEG GET FALSE rv=%d\n"),
                          unit, port, rv));
                return rv;
            }

            if (an_enabled) {
                /* notify the SW AN thread of link down event */
                rv = bcm_sw_an_post_event(unit, port, BCM_PORT_SW_AN_EVENT_AN_LINK_DOWN);
            }

            if (BCM_FAILURE(rv)) {
                LOG_WARN(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                                     "u=%d p=%d SW AN POST EVENT FAILED rv=%d\n"),
                          unit, port, rv));
            }
        }
    }
    return BCM_E_NONE;
}
#endif


/*
 * Function:
 *      bcm_esw_port_phy_tx_set
 * Purpose:
 *      Set port phy tx properties
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      tx   - tx properties
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */
int
bcm_esw_port_phy_tx_set(int unit, bcm_port_t port, bcm_port_phy_tx_t *tx) {
    int rv = BCM_E_UNAVAIL;

    if (NULL == tx) {
        return BCM_E_PARAM;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_IS_TOMAHAWK3(unit)) {
        /* Call Port Control module */
        if (SOC_PORT_USE_PORTCTRL(unit, port)) {
            rv = bcmi_esw_portctrl_phy_tx_set(unit, port, tx);
        }
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_phy_tx_get
 * Purpose:
 *      Get port phy tx properties
 * Parameters:
 *      unit - StrataSwitch Unit #.
 *      port - StrataSwitch port #.
 *      tx   - tx properties
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */
int
bcm_esw_port_phy_tx_get(int unit, bcm_port_t port, bcm_port_phy_tx_t *tx) {
    int rv = BCM_E_UNAVAIL;

    if (NULL == tx) {
        return BCM_E_PARAM;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_IS_TOMAHAWK3(unit)) {
        /* Call Port Control module */
        if (SOC_PORT_USE_PORTCTRL(unit, port)) {
            rv = bcmi_esw_portctrl_phy_tx_get(unit, port, tx);
        }
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_rlm_config_set
 * Purpose:
 *      Set port rlm config properties
 * Parameters:
 *      unit       - (IN) StrataSwitch Unit #.
 *      port       - (IN) StrataSwitch port #.
 *      rlm_config - (IN) rlm properties
 *      enable     - (IN) enable or disable rlm
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */
int
bcm_esw_port_rlm_config_set(int unit, bcm_port_t port,
                            bcm_port_rlm_config_t *rlm_config, int enable) {
    int rv = BCM_E_UNAVAIL;
    int port_enabled = 0;
    int link;

    if (NULL == rlm_config) {
        return BCM_E_PARAM;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Check for valid port */
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (!enable) {
        /* need to disable the port first if disable RLM */
        rv = bcm_esw_port_enable_set(unit, port, 0);
    } else {
        /*next check if the port is enabled */
        rv = bcm_esw_port_enable_get(unit, port, &port_enabled);
        if (!port_enabled) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "port %d is not enabled \n"), port));
            return BCM_E_CONFIG;
        }

        /* check link status */
        SOC_IF_ERROR_RETURN
            (bcm_esw_port_link_status_get(unit, port, &link));
        if (FALSE == link) {
            LOG_ERROR(BSL_LS_BCM_PORT,
                      (BSL_META_U(unit,
                                  "port %d link is not up \n"), port));
            return BCM_E_CONFIG;
        }
    }

    if (SOC_IS_TOMAHAWK3(unit)) {
        /* Call Port Control module */
        if (SOC_USE_PORTCTRL(unit)) {
            rv = bcmi_esw_portctrl_rlm_config_set(unit,
                                 port,
                                 rlm_config,
                                 enable);
        }
    }

    if (!enable) {
        /* need to re-enable the port after RLM is disabled */
        rv = bcm_esw_port_enable_set(unit, port, 1);
    }

    return rv;
}

/*
 * Function:
 *      bcm_esw_port_rlm_config_get
 * Purpose:
 *      Get port phy tx properties
 * Parameters:
 *      unit       - (IN) StrataSwitch Unit #.
 *      port       - (IN) StrataSwitch port #.
 *      rlm_config - (OUT) rlm config properties
 *      enable     - (OUT) enable/disable
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */
int
bcm_esw_port_rlm_config_get(int unit, bcm_port_t port,
                            bcm_port_rlm_config_t *rlm_config, int *enable) {
    int rv = BCM_E_UNAVAIL;

    if (NULL == rlm_config) {
        return BCM_E_PARAM;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Check for valid port */
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (SOC_IS_TOMAHAWK3(unit)) {
        /* Call Port Control module */
        if (SOC_USE_PORTCTRL(unit)) {
            rv = bcmi_esw_portctrl_rlm_config_get(unit,
                                 port,
                                 rlm_config,
                                 enable);
        }
    }

    return rv;
}
/*
 * Function:
 *      bcm_esw_port_rlm_status_get
 * Purpose:
 *      Get port rlm status
 * Parameters:
 *      unit       - (IN) StrataSwitch Unit #.
 *      port       - (IN) StrataSwitch port #.
 *      rlm_status - (OUT) rlm config properties
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */
int
bcm_esw_port_rlm_status_get(int unit, bcm_port_t port,
                            bcm_port_rlm_status_t *rlm_status) {
    int rv = BCM_E_UNAVAIL;

    if (NULL == rlm_status) {
        return BCM_E_PARAM;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    /* Check for valid port */
    BCM_IF_ERROR_RETURN(_bcm_esw_port_gport_validate(unit, port, &port));

    if (SOC_IS_TOMAHAWK3(unit)) {
        /* Call Port Control module */
        if (SOC_USE_PORTCTRL(unit)) {
            rv = bcmi_esw_portctrl_rlm_status_get(unit,
                                 port,
                                 rlm_status);
        }
    }

    return rv;
}

/*
 * bcm_port_txpi_rxcdr_clk_get
 *
 * @brief get both tx/rx clocks in Hz.
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  txpi_clk        - tx pi clk in Hz
 * @param [out]  rxcdr_clk       - rx cdr clk in Hz
 */
int bcm_esw_port_txpi_rxcdr_clk_get(int unit, bcm_port_t port,
                                uint32* txpi_clk, uint32* rxcdr_clk)
{
    int rv = BCM_E_UNAVAIL;
#if (defined(BCM_MONTEREY_SUPPORT) & defined(INCLUDE_GDPLL)) ||\
     defined(BCM_FIRELIGHT_SUPPORT) || defined(BCM_FIREBOLT6_SUPPORT)
    if (SOC_IS_MONTEREY(unit) || SOC_IS_FIRELIGHT(unit) || SOC_IS_FIREBOLT6(unit)) {
        if (SOC_USE_PORTCTRL(unit)) {
            rv = portmod_port_txpi_rxcdr_clk_get(unit, port, txpi_clk, rxcdr_clk);
        }
    }
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_port_post_ber_proj_get
 * Purpose:
 *      Get the BER histogram and post-FEC estimation values
 * Parameters:
 *      unit       - (IN) StrataSwitch Unit #.
 *      port       - (IN) StrataSwitch port #.
 *      ber_proj   - (IN) BER Projection parameters
 *      max_errnct - (IN) size of errcnt_array[]
 *      errcnt_array  - (OUT) errcnt_array[] for storing post-FEC estimation values
 *      actual_errcnt - (OUT) actual number of errcnt in errcnt_array[]
 * Returns:
 *      BCM_E_NONE
 *      BCM_E_XXX
 */
int
bcm_esw_port_post_ber_proj_get(int unit, bcm_port_t port,
                               bcm_port_ber_proj_params_t *ber_proj,
                               int max_errcnt,
                               bcm_port_ber_proj_analyzer_errcnt_t *errcnt_array,
                               int *actual_errcnt) {
    int rv = BCM_E_UNAVAIL;

    if ((ber_proj == NULL) || (errcnt_array == NULL)) {
        return BCM_E_PARAM;
    }

    /* Make sure port module is initialized. */
    PORT_INIT(unit);

    if (SOC_IS_TOMAHAWK3(unit)) {
        /* Call Port Control module */
        if (SOC_USE_PORTCTRL(unit)) {
            rv = bcmi_esw_portctrl_post_ber_proj_get(unit, port,
                ber_proj, max_errcnt, errcnt_array, actual_errcnt);
        }
    }

    return rv;
}

int
bcm_esw_port_get(int unit, bcm_port_t port, uint32 *flags,
                 bcm_port_interface_info_t *interface_info,
                 bcm_port_mapping_info_t *mapping_info)
{
#if defined(BCM_TRIDENT2_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
    int mcq, ucq;
    pbmp_t pbmp = PBMP_ALL(unit);

    if (SOC_IS_TRIDENT2(unit) || SOC_IS_TOMAHAWK(unit)) {
        if (!_SHR_PBMP_MEMBER((pbmp), (port))) {
            return BCM_E_PARAM;
        }
        if (interface_info == NULL || mapping_info == NULL) {
            return BCM_E_PARAM;
        }
        sal_memset(interface_info, 0, sizeof(bcm_port_interface_info_t));
        sal_memset(mapping_info, 0, sizeof(bcm_port_mapping_info_t));

        /* phy_pbmp, interface_id, channel, core, base_q_pair, num_priorities,
         * pp_port, base_hr and num_sch_priorities, are used for Dune switch.
         */
        interface_info->phy_port = SOC_INFO(unit).port_l2p_mapping[port];
        BCM_IF_ERROR_RETURN(bcm_esw_port_interface_get(unit, port,
                                                       &interface_info->interface));
        interface_info->num_lanes = SOC_INFO(unit).port_num_lanes[port];
        mapping_info->tm_port = SOC_INFO(unit).port_p2m_mapping[interface_info->phy_port];
        interface_info->max_speed = SOC_INFO(unit).port_speed_max[port];
        mcq = SOC_INFO(unit).port_cosq_base[port];
        ucq = SOC_INFO(unit).port_uc_cosq_base[port];
#ifdef BCM_TRIDENT2_SUPPORT
        if (SOC_IS_TRIDENT2(unit) || SOC_IS_TITAN2(unit)) {
            mapping_info->base_mc_queue = soc_td2_logical_qnum_hw_qnum(unit, port, mcq, 0);
            mapping_info->base_uc_queue = soc_td2_logical_qnum_hw_qnum(unit, port, ucq, 1);
        } else
#endif
        if (SOC_IS_TOMAHAWK(unit)) {
            mapping_info->base_mc_queue = mcq;
            mapping_info->base_uc_queue = ucq;
        }
        mapping_info->num_mc_queue = SOC_INFO(unit).port_num_cosq[port];
        mapping_info->num_uc_queue = SOC_INFO(unit).port_num_uc_cosq[port];

        return BCM_E_NONE;
    }
    return BCM_E_UNAVAIL;
#else
    return BCM_E_UNAVAIL;
#endif
}
