/* 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * Module: Field Processor APIs
 *
 * Purpose:
 *     API for Field Processor (FP) for XGS3 family and later.
 */
/**/
#include <shared/bsl.h>
#include <soc/drv.h>
#include <soc/scache.h>
#include <soc/cmic.h>
#include <soc/field.h>
#include <shared/pbmp.h>
#include <bcm/field.h>
#include <bcm/error.h>
#include <bcm/mirror.h>
#include <bcm/subport.h>
#include <bcm/link.h>
#include <bcm_int/esw/link.h>
#include <bcm/l3.h>
#include <bcm_int/esw/l3.h>

#if defined(BCM_FIREBOLT_SUPPORT)
#include <bcm_int/esw/firebolt.h>
#endif

#if defined(BCM_RAPTOR_SUPPORT)
#include <bcm_int/esw/raptor.h>
#endif

#if defined(BCM_TRX_SUPPORT)
#include <bcm_int/esw/trx.h>
#endif

#if defined(BCM_TRIUMPH_SUPPORT)
#include <bcm_int/esw/triumph.h>
#endif

#if defined(BCM_HGPROXY_COE_SUPPORT)
#include <bcm_int/esw/xgs5.h>
#endif /* BCM_HGPROXY_COE_SUPPORT */

#include <bcm_int/esw/policer.h>
#include <bcm_int/esw/field.h>
#include <bcm_int/esw/range.h>
#include <bcm_int/esw/triumph2.h>
#include <bcm_int/esw/triumph3.h>
#include <bcm_int/esw/trident.h>
#include <bcm_int/esw/katana.h>
#include <bcm_int/esw/trident2.h>
#include <bcm_int/esw/tomahawk.h>
#include <bcm_int/esw/tomahawk2.h>
#include <bcm_int/esw/tomahawk3.h>
#include <bcm_int/common/multicast.h>

#if defined(BCM_ENDURO_SUPPORT)
#include <bcm_int/esw/enduro.h>
#endif

#if defined(BCM_HURRICANE_SUPPORT)
#include <bcm_int/esw/hurricane.h>
#endif

#if defined(BCM_HURRICANE2_SUPPORT)
#include <bcm_int/esw/hurricane2.h>
#endif

#if defined(BCM_KATANA2_SUPPORT)
#include <bcm_int/esw/katana2.h>
#endif /* BCM_KATANA2_SUPPORT */

#if defined(BCM_SABER2_SUPPORT)
#include <bcm_int/esw/saber2.h>
#endif /* BCM_SABER2_SUPPORT */

#include <bcm_int/esw/scorpion.h>
#include <bcm_int/esw/trunk.h>
#include <bcm_int/esw/mirror.h>
#include <bcm_int/esw/stack.h>
#include <bcm_int/esw/port.h>
#include <bcm_int/control.h>
#include <bcm_int/esw/virtual.h>
#include <bcm_int/esw_dispatch.h>
#include <bcm_int/esw/ecn.h>


#if defined(BCM_ESW_SUPPORT) 
#include <bcm_int/esw/flex_ctr.h>
#include <bcm_int/esw/xgs4.h>
#endif

#ifdef BCM_GREYHOUND_SUPPORT
#include <bcm_int/esw/greyhound.h>
#endif /* BCM_GREYHOUND_SUPPORT */
#ifdef BCM_HURRICANE3_SUPPORT
#include <bcm_int/esw/hurricane3.h>
#include <bcm_int/esw/flowcnt.h>
#endif /* BCM_HURRICANE3_SUPPORT */
#ifdef BCM_GREYHOUND2_SUPPORT
#include <bcm_int/esw/greyhound2.h>
#endif /* BCM_GREYHOUND2_SUPPORT */
#if defined(INCLUDE_REGEX)
#include <bcm_int/esw/bregex.h>
#endif
#include <bcm_int/esw/udf.h>
#include <bcm_int/esw/udf_common.h>
#ifdef BCM_HELIX5_SUPPORT
#include <bcm_int/esw/helix5.h>
#endif /* BCM_HELIX5_SUPPORT */

#ifdef BCM_TRIDENT3_SUPPORT
#include <soc/esw/cancun.h>
#endif /* BCM_TRIDENT3_SUPPORT */
#ifdef BCM_FIREBOLT6_SUPPORT
#include <bcm_int/esw/firebolt6.h>
#endif /* BCM_FIREBOLT6_SUPPORT */

#if defined(BCM_ESW_SUPPORT)
#ifdef BCM_FIELD_SUPPORT 

#define SAL_ALLOC_T(t, n)  ((t *) sal_alloc((n) * sizeof(t), " ")) /* <HP/> */

#define BCM_POLICER_XGS_NOSUPPORT_FLAGS (BCM_POLICER_DROP_RED | \
                                         BCM_POLICER_MACRO    | \
                                         BCM_POLICER_EGRESS   | \
                                         BCM_POLICER_REPLACE_SHARED)
/* used to store the modport type used for qualifiers SrcGPort and DstGPort */
#define _BCM_GPORT_TYPE_MOD_PORT 100
extern int
_field_policers_hw_free_old(int unit, _field_entry_t *f_ent);
extern int
_bcm_field_entry_copy_id(int unit,
                            bcm_field_entry_t src_entry,
                            bcm_field_entry_t dst_entry,
                            uint32 flags);
extern int
_field_tcam_policy_install(int unit, bcm_field_entry_t entry);
extern int
_bcm_esw_field_group_dump(int unit, bcm_field_group_t group, int stage);

/*
 * Macro:
 *     FIELD_IS_INIT (internal)
 * Purpose:
 *     Check that the unit is valid and confirm that the field functions
 *     are initialized.
 * Parameters:
 *     unit - BCM device number
 * Notes:
 *     Results in return(BCM_E_UNIT), return(BCM_E_UNAVAIL), or
 *     return(BCM_E_INIT) if fails.
 */
#define FIELD_IS_INIT(unit)                                      \
    if (!soc_feature(unit, soc_feature_field)) {                 \
        return (BCM_E_UNAVAIL);                                  \
    }                                                            \
    if (_field_control[unit] == NULL) {                          \
        LOG_ERROR(BSL_LS_BCM_FP, \
                  (BSL_META("FP(unit %d) Error: not initialized\n"), \
                   unit));   \
        return (BCM_E_INIT);                                     \
    }
    
/*
 * Local function prototypes
 */
#ifdef BROADCOM_DEBUG
extern char *_field_qual_name(bcm_field_qualify_t qid);
extern char *_field_group_mode_name(uint32 group_flags);
extern char* _field_stage_name(_field_stage_t *stage_fc);
#endif /* BROADCOM_DEBUG */

/*
 * Field control data, one per device.
 */
extern _field_control_t         *_field_control[BCM_MAX_NUM_UNITS];

/* Sw WorkAround for EgressPortsAdd Action */
extern uint8                        _field_egr_ports_recovery_lock[BCM_MAX_NUM_UNITS];
extern _field_egr_ports_recovery_t  *_field_egr_ports_recovery[BCM_MAX_NUM_UNITS];


int
bcm_esw_field_group_flush(int unit, bcm_field_group_t group)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function: bcm_field_entry_enable_set
 *
 * Purpose:
 *     Enable/Disable an entry from the hardware tables.
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - Entry to be enabled/disabled
 *     enable_flag - Flag to enable or disable
 *
 * Returns:
 *     BCM_E_XXX
 *
 * Notes:
 *     This does not destroy the entry, nor deallocate any related resources;
 *     it only enables/disables a rule from hardware table using VALIDf of the
 *     corresponding hardware entry. To deallocate the memory used by the entry
 *     call bcm_field_entry_destroy.
 */
int
bcm_esw_field_entry_enable_set(int unit, bcm_field_entry_t entry, int enable_flag)
{
    _field_control_t    *fc;         /* Field control structure. */
    _field_entry_t      *f_ent;      /* Field entry pointer.     */
    _field_stage_t      *stage_fc;   /* Stage field control.            */
    _field_group_t      *fg;         /* Field group structure.          */
    uint32              tcam_entry[SOC_MAX_MEM_FIELD_WORDS];
    int                 rv;          /* Operation return status. */
    int                 tcam_idx;
    soc_mem_t           mem = INVALIDm;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: bcm_field_entry_enable_set ("
                          "entry=%d, enable=%d)\n"), unit, entry, enable_flag));

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    if (!(f_ent->flags & _FP_ENTRY_INSTALLED)) {
        FP_UNLOCK(unit);
        return (BCM_E_PARAM);
    }

    fg = f_ent->group;

    /* External stage entries are always enabled */
    if (_BCM_FIELD_STAGE_EXTERNAL == fg->stage_id) {
        /*
         * For external stage, there is no support in the hardware to enable
         * or disable the installed entry. It is always enabled.
         * So, error is returned when trying to disable the entry and
         * set the enable flag when trying to enable the entry.
         */

        if (enable_flag == 0) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: bcm_esw_field_entry_enable_set"
                                   " Entry %d Disabling entry not supported for"
                                   " external stage\n"), unit, entry));
            FP_UNLOCK(unit);
            return (BCM_E_PARAM);
        }

        f_ent->flags |= _FP_ENTRY_ENABLED; 
        FP_UNLOCK(unit);
        return (BCM_E_NONE);
    }

    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
    	FP_UNLOCK(unit);
        return rv;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            rv = fc->functions.fp_entry_enable(unit, f_ent, enable_flag);
            FP_UNLOCK(unit);
            return rv;
        }
#endif /* BCM_TOMAHAWK_SUPPORT */

    if (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) {
        mem = FP_TCAMm;
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT) 
    } else if (soc_feature(unit, soc_feature_field_multi_stage)) {
        if (_BCM_FIELD_STAGE_LOOKUP  == stage_fc->stage_id) {
            mem = VFP_TCAMm;
        } else if (_BCM_FIELD_STAGE_EGRESS  == stage_fc->stage_id) {
            mem = EFP_TCAMm;
        } else {
            FP_UNLOCK(unit);
            return (BCM_E_INTERNAL);
        }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    } else {
        FP_UNLOCK(unit);
        return BCM_E_INTERNAL;
    }

    /* Get tcam indexes for installed entry. */
    rv = _bcm_field_entry_tcam_idx_get(unit, f_ent,
                                       &tcam_idx);

    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = soc_mem_read(unit, mem, MEM_BLOCK_ANY, tcam_idx, tcam_entry);
    if (SOC_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Set the VALIDf bits appropriately */
    if (enable_flag) {
        soc_mem_field32_set(unit, mem, tcam_entry, VALIDf, 3);
    } else {
        soc_mem_field32_set(unit, mem, tcam_entry, VALIDf, 2);
    }

    /* Write back the TCAM entry */
    rv = soc_mem_write(unit, mem, MEM_BLOCK_ALL, tcam_idx, tcam_entry);
    if (SOC_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    if (enable_flag) {
       f_ent->flags |= _FP_ENTRY_ENABLED; 
    }
    else {
        f_ent->flags &= ~_FP_ENTRY_ENABLED;
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    SOC_CONTROL_LOCK(unit);
    SOC_CONTROL(unit)->scache_dirty = 1;
    SOC_CONTROL_UNLOCK(unit);
#endif

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_field_entry_enable_get
 *
 * Purpose:
 *     Get the Enable or Disable status of a field Entry.
 *
 * Parameters:
 *     unit - (IN)BCM device number
 *     entry - (IN)Entry to be checked for Enabled status
 *     enable_flag - (OUT)Status(Enable/Disable) of the given entry
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_entry_enable_get(int unit, bcm_field_entry_t entry, int *enable_flag)
{
    _field_entry_t      *f_ent;      /* Field entry pointer.     */
    int                 rv;          /* Operation return status. */

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: bcm_field_entry_enable_get ("
                          "entry=%d)\n"), unit, entry));

    rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

    if (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id) {
        return (BCM_E_UNAVAIL);
    }

    if (!(f_ent->flags & _FP_ENTRY_INSTALLED)) {
        return (BCM_E_PARAM);
    }

    *enable_flag = (f_ent->flags & _FP_ENTRY_ENABLED) ? 1 : 0;
    return (BCM_E_NONE);
}


/*
 * Function: bcm_esw_field_init
 *
 * Purpose:
 *    Initialize field module.
 *
 * Parameters:
 *     unit - (IN) BCM device number
 *
 * Returns:
 *     BCM_E_UNIT    - Invalid BCM unit number.
 *     BCM_E_UNAVAIL - Field Processor not on device.
 *     BCM_E_MEMORY  - Allocation failure
 *     BCM_E_XXX     - Error code from bcm_XX_field_init()
 *     BCM_E_NONE    - Success
 */
int
bcm_esw_field_init(int unit)
{
    int  rv = BCM_E_NONE;
    FP_LOCK(unit);
    rv = _bcm_esw_field_init(unit);
    FP_UNLOCK(unit);
    return rv;
}

/*
 * Function: bcm_esw_field_stage_qset_get
 * Purpose:
 *     To list the qualifiers supported for a given stage
 * Parameters:
 *     unit - (IN) bcm device
 *     stage - (IN) stage for which the supported qset is requested
 *     presel - (IN) to return qualifiers supported for that presel stage.
 *                   0 - return stage qlist
 *                   1 - return qlist of presel for that stage
 *     qset - (OUT) Pointer to a qualifier set.
 *
 * Returns:
 *     BCM_E_NONE: If the aggregation group monitor creation is success.
 *     BCM_E_PARAM: If a wrong parameters are passed.
 *     BCM_E_UNAVAIL: if the sent stage is not supported.
 *     BCM_E_INTERNAL: if any internal error is encountered.
 */
int
bcm_esw_field_stage_qset_get(int unit, bcm_field_stage_t stage,
                          uint8 presel, bcm_field_qset_t *qset) {
    int                    rv;      /* Operation return status.    */
    _field_stage_t         *stage_fc;
    _field_stage_id_t stage_id;

    rv = BCM_E_NONE;

    /* Input parameters check. */
    if (qset == NULL) {
        return (BCM_E_PARAM);
    }

    if (presel == 1) {
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (!((soc_feature(unit, soc_feature_field_multi_pipe_support)) &&
            (soc_feature(unit, soc_feature_field_preselector_support)) &&
            ((stage == bcmFieldStageIngress) ||
             (stage == bcmFieldStageIngressExactMatch) ||
             (stage == bcmFieldStageIngressFlowtracker)))) {
            return BCM_E_PARAM;
        }
#else
        return BCM_E_PARAM;
#endif
    }

    switch (stage) {
        case bcmFieldStageIngress:
            stage_id = _BCM_FIELD_STAGE_INGRESS;
            break;
        case bcmFieldStageEgress:
            stage_id = _BCM_FIELD_STAGE_EGRESS;
            break;
        case bcmFieldStageExternal:
            stage_id = _BCM_FIELD_STAGE_EXTERNAL;
            break;
        case bcmFieldStageIngressExactMatch:
            stage_id = _BCM_FIELD_STAGE_EXACTMATCH;
            break;
        case bcmFieldStageIngressFlowtracker:
            stage_id = _BCM_FIELD_STAGE_FLOWTRACKER;
            break;
        case bcmFieldStageLookup:
            stage_id = _BCM_FIELD_STAGE_LOOKUP;
            break;
        case bcmFieldStageClass:
            stage_id = _BCM_FIELD_STAGE_CLASS;
            break;
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
        case bcmFieldStageAggregateMmuFlowtracker:
            stage_id = _BCM_FIELD_STAGE_AMFTFP;
            break;
        case bcmFieldStageAggregateEgressFlowtracker:
            stage_id = _BCM_FIELD_STAGE_AEFTFP;
            break;
#endif
        default:
            return BCM_E_PARAM;
    }
    FP_LOCK(unit);
    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    if (presel == 0) {
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (stage_id == _BCM_FIELD_STAGE_CLASS) {
             BCM_FIELD_QSET_INIT(*qset);
             BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyStageClass);
             BCM_FIELD_QSET_ADD(*qset,
                                bcmFieldQualifyStageClassExactMatch);
             BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyEtherType);
             BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyTtl);
             BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyTos);
             BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyIpProtocol);
             BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyTcpControl);

             BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyVrf);

             if (SOC_IS_TOMAHAWK3(unit)) {
                 BCM_FIELD_QSET_ADD(*qset,
                                    bcmFieldQualifyIpTunnelTtl);
             } else {
                 BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyL4SrcPort);
                 BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyL4DstPort);
                 BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifySrcIp);
                 BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifySrcIp6);
                 BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyDstIp);
                 BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyDstIp6);
                 BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyFcoeOxID);
                 BCM_FIELD_QSET_ADD(*qset, bcmFieldQualifyFcoeRxID);
                 BCM_FIELD_QSET_ADD(*qset,
                                    bcmFieldQualifyFibreChanSrcId);
                 BCM_FIELD_QSET_ADD(*qset,
                                    bcmFieldQualifyFibreChanDstId);
             }
        } else {
            *qset = stage_fc->_field_supported_qset;
        }
#else
        *qset = stage_fc->_field_supported_qset;
#endif
    } else
#if defined(BCM_TOMAHAWK_SUPPORT)
         if (presel == 1) {
             *qset = stage_fc->presel_qset;
         } else
#endif
    {
        FP_UNLOCK(unit);
        return BCM_E_PARAM;
    }
    FP_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_group_traverse
 * Purpose:
 *      Traverse all the fp groups in the system, calling a specified
 *      callback for each one
 * Parameters:
 *      unit - (IN) Unit number.
 *      callback - (IN) A pointer to the callback function to call for each fp group
 *      user_data - (IN) Pointer to user data to supply in the callback
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int 
bcm_esw_field_group_traverse(int unit, bcm_field_group_traverse_cb callback,
                             void *user_data)
{
    bcm_field_group_t *grp_arr;/* Field group pointers.    */ 
    _field_control_t *fc;      /* Field control structure. */
    _field_group_t *fg;        /* Field group structure.   */
    int group_count;           /* Number of fp groups.     */
    int mem_sz;                /* Allocated memory size.   */
    int idx;                   /* Group array iterator.    */
    int rv = BCM_E_NONE;       /* Operation return status. */

    /* Input parameters check. */
    if (NULL == callback) {
        return (BCM_E_PARAM);
    }

    /* Field control structure. */
     
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /* Count fp groups. */
    fg = fc->groups;
    group_count = 0;
    while (fg != NULL) {
        if (!((soc_feature(unit, soc_feature_sw_mmu_flush_rqe_operation)) &&
            (fg->gid == _FP_INTERNAL_RESERVED_EM_ID))) {
            group_count++;
        }
        fg = fg->next;
    }

    if (0 == group_count) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* 
     * API can not use field contol groups linked list, 
     * since group might be destroyed in callback.  
     */
    mem_sz = group_count * sizeof(bcm_field_group_t);
    grp_arr = NULL;
    _FP_XGS3_ALLOC(grp_arr, mem_sz, "FP groups array");
    if (NULL == grp_arr) {
        FP_UNLOCK(unit);
        return (BCM_E_MEMORY);
    }

    /* Programm fp group ids into allocated array. */
    fg = fc->groups;
    idx = 0;
    while (fg != NULL) {
        if (!((soc_feature(unit, soc_feature_sw_mmu_flush_rqe_operation)) &&
            (fg->gid == _FP_INTERNAL_RESERVED_EM_ID))) {
             grp_arr[idx] = fg->gid;
             idx++;
        }
        fg = fg->next;
    }

    /* Call user callback. */
    for (idx = 0; idx < group_count; idx++) {
        rv = (*callback)(unit, grp_arr[idx], user_data);
        if (BCM_FAILURE(rv)) {
            break;
        }
    }
    FP_UNLOCK(unit);
    sal_free(grp_arr);
    return (rv);
}

/*
 * Function: bcm_esw_field_detach
 *
 * Purpose:
 *     Free resources associated with field module
 *
 * Parameters:
 *     unit - BCM device number
 *
 * Returns:
 *     BCM_E_INIT - BCM Unit not initialized.
 *     BCM_E_XXX  - Error code from bcm_field_group_destroy() or
 *                  bcm_field_entry_destroy_all().
 *     BCM_E_NONE - Success
 */

int
bcm_esw_field_detach(int unit)
{
    int  rv = BCM_E_NONE;
    FP_LOCK(unit);
    rv = _bcm_esw_field_detach(unit);
    FP_UNLOCK(unit);
    return rv;
}

/*
 * Function: bcm_esw_field_control_get
 *
 * Purpose:
 *     Get control status info.
 *
 * Parameters:
 *     unit     - (IN)  BCM device number.
 *     control  - (IN)  Control element to get.
 *     status   - (OUT) Status of field element.
 *
 * Returns:
 *     BCM_E_INIT    - BCM unit not initialized
 *     BCM_E_PARAM   - *state pointing to NULL
 *     BCM_E_NONE    - Success
 */
int
bcm_esw_field_control_get(int unit, bcm_field_control_t control, uint32 *state)
{
    _field_control_t    *fc;             /* Field control structure.      */
    int                 rv = BCM_E_NONE; /* Operation return status.      */
    
    if (state == NULL) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    if (NULL != fc->functions.fp_control_get) {
       rv = fc->functions.fp_control_get(unit, fc, control, state);
    }

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_control_set
 *
 * Purpose:
 *     Set control status.
 *
 * Parameters:
 *     unit     - (IN) BCM device number.
 *     control  - (IN) Control element to set.
 *     state    - (IN) State (0/1).
 *
 * Returns:
 *     BCM_E_NONE    - Success
 *     BCM_E_INIT    - BCM unit not initialized
 *     BCM_E_PARAM   - Flag state not valid on device
 */
int
bcm_esw_field_control_set(int unit, bcm_field_control_t control, uint32 state)
{
    _field_control_t    *fc;              /* Field control structure.   */
    int                 rv = BCM_E_NONE;  /* Operation return status.   */

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    if (NULL != fc->functions.fp_control_set) {
       rv = fc->functions.fp_control_set(unit, fc, control, state);
    }

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_field_stage_slice_count_get
 *
 * Purpose:
 *     Return the number os slices in a given stage
 *
 * Parameters:
 *     unit       - (IN)  BCM device number
 *     stage_id   - (IN)  Stage ID
 *     slice_count- (OUT) number of slices in a given stage
 *
 * Returns:
 *     BCM_E_NONE    - Success
 *     BCM_E_CONFIG  - error in configuration
 *     BCM_E_PARAM   - invalid parameter
 */

int
bcm_esw_field_stage_slice_count_get(
    int unit,
    bcm_field_stage_t stage_id,
    int *slice_count) {

#if defined(BCM_TOMAHAWK_SUPPORT)
    int  rv;        /* Operation return status.   */
    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        return BCM_E_UNAVAIL;
    }
    FP_LOCK(unit);
    rv = _bcm_field_stage_slice_count_get(unit,
                                         stage_id,
                                         slice_count);
    FP_UNLOCK(unit);
    return rv;
#else
    return (BCM_E_UNAVAIL);
#endif /* BCM_TOMAHAWK_SUPPORT */
}

/*
 * Function: bcm_esw_field_stage_slice_info_get
 *
 * Purpose:
 *     Return the details of the stage and entries
 *     count of the given slice for the given portbitmap
 *
 * Parameters:
 *     unit       - (IN) BCM device number
 *     stage_id   - (IN) Stage ID
 *     pbmp       - (IN) Port bitmap of the pipe
 *                       for which the details are required
 *     slice_no   - (IN) slice no to retrieve the info
 *     slice_info - (OUT) Slice information
 *
 * Returns:
 *     BCM_E_NONE    - Success
 *     BCM_E_CONFIG  - error in configuration
 *     BCM_E_PARAM   - invalid parameter
 */

int
bcm_esw_field_stage_slice_info_get(
    int unit,
    bcm_field_stage_t stage_id,
    bcm_pbmp_t pbmp,
    int slice_no,
    bcm_field_stage_slice_info_t *slice_info) {

#if defined(BCM_TOMAHAWK_SUPPORT)
    int  rv;        /* Operation return status.   */
    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        return BCM_E_UNAVAIL;
    }
    FP_LOCK(unit);
    rv = _bcm_field_stage_slice_info_get(unit,
                                         stage_id,
                                         pbmp,
                                         slice_no,
                                         slice_info);
    FP_UNLOCK(unit);
    return rv;
#else
    return (BCM_E_UNAVAIL);
#endif /* BCM_TOMAHAWK_SUPPORT */
}

/* Section: Group Management */

/*
 * Function: bcm_esw_field_group_create
 *
 * Purpose:
 *     Create a field group based on the field group selector flags.
 *
 * Parameters:
 *     unit - BCM device number.
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *     group - (OUT) New field group ID
 *
 * Returns:
 *     BCM_E_INIT     - BCM unit not initialized
 *     BCM_E_PARAM    - pri out of range (0-15 for FB & ER) or group == NULL
 *     BCM_E_RESOURCE - no select codes will satisfy qualifier set
 *     BCM_E_NONE     - Success
 *
 * Notes:
 *      Allocates a hardware slice at the requested priority or better.
 *      Higher numerical value for priority has better priority for
 *      conflict resolution when there is a search hit on multiple slices.
 */
int
bcm_esw_field_group_create(int unit,
                           bcm_field_qset_t qset,
                           int pri,
                           bcm_field_group_t *group)
{
    int                rv;      /* Operation return status. */

    
    FP_LOCK(unit);

    /* qset and pri are validated in bcm_field_group_create_mode_id(). */
    rv = _bcm_field_group_id_generate(unit, group);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = bcm_esw_field_group_create_mode_id(unit, qset, pri,
                                            bcmFieldGroupModeDefault, *group);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_group_create_id
 *     
 * Purpose:
 *     Create a field group based on the field group selector flags
 *     with a requested ID
 *
 * Parameters:
 *     unit - BCM device number.
 *     port - Port number
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    group - Requested field group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - No unused group/slices left
 *     BCM_E_PARAM     - priority out of range (0-15 for FB & ER)
 *     BCM_E_EXISTS    - group with that id already exists on this unit.
 *     BCM_E_MEMORY    - Group memory allocation failure
 *     BCM_E_NONE      - Success
 */

int
bcm_esw_field_group_create_id(int unit,
                              bcm_field_qset_t qset,
                              int pri,
                              bcm_field_group_t group)
{
    int                rv;      /* Operation return status. */
    
    FP_LOCK(unit);

    /* coverity[result_independent_of_operands : FALSE] */
    if (soc_feature(unit, soc_feature_th3_style_fp)) {
        if (group >= (_FP_INTERNAL_RESERVED_ID_MIN)) {
           LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                      "FP(unit %d) Error: This Group ID is reserved"
                      " for internal use\n"),
                      unit));
            FP_UNLOCK(unit);
            return (BCM_E_PARAM);
        }
    }

    /* Qset, pri and mode are validated in bcm_field_group_create_mode_id(). */
    rv = bcm_esw_field_group_create_mode_id(unit, qset, pri,
                                            bcmFieldGroupModeDefault, group);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_group_create_mode
 *     
 * Purpose:
 *
 * Parameters:
 *     unit - BCM device number.
 *     port - Port number
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - (OUT) New field group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - No select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_create_mode(int unit,
                                bcm_field_qset_t qset,
                                int pri,
                                bcm_field_group_mode_t mode,
                                bcm_field_group_t *group)
{
    int                rv;      /* Operation return status. */

    
    FP_LOCK(unit);

    /* Qset, pri and mode are validated in bcm_field_group_create_mode_id(). */
    rv = _bcm_field_group_id_generate(unit, group);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }
    rv = bcm_esw_field_group_create_mode_id(unit, qset, pri, mode, *group);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_group_create_mode_id
 *     
 * Purpose:
 *     Create a group with both a mode (single, double, etc.) and a Group ID.
 *
 * Parameters:
 *     unit - BCM device number.
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - Requested field group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_create_mode_id(int unit,
                                   bcm_field_qset_t qset,
                                   int pri,
                                   bcm_field_group_mode_t mode,
                                   bcm_field_group_t group)
{
    bcm_pbmp_t         all_pbmp;   /* Group port bitmap.           */
    int                rv;         /* Operation return status.     */

    /* Read device port configuration. */ 
    BCM_PBMP_CLEAR(all_pbmp);
    BCM_IF_ERROR_RETURN(_bcm_field_valid_pbmp_get(unit, &all_pbmp));

    FP_LOCK(unit);

    rv =  bcm_esw_field_group_ports_create_mode_id(unit, all_pbmp, qset, 
                                                   pri, mode, group);
    FP_UNLOCK(unit);

    return (rv);
}

/*
 * Function: bcm_esw_field_group_expansion_enable_set
 *
 * Purpose:
 *     Enable or Disable Auto expansion of extries for a group
 *
 * Parameters:
 *     unit - BCM device number.
 *     group - Requested field group ID
 *     enable - enable/disable auto expansion of group
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_UNAVAIL   - feature not available
 *     BCM_E_NONE      - Success
 */

int
bcm_esw_field_group_expansion_enable_set(int unit,
                                         bcm_field_group_t group,
                                         int enable)
{
    _field_group_t      *fg;           /* Field group structure.      */
    _field_stage_t      *stage_fc;     /* Field stage control.        */
    int                 rv;            /* Operation return status.    */
    int                 virtual_priority = FALSE;/* Virtual priority support flag.*/


    
    FP_LOCK(unit);

    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (fg->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if ((fg->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER) ||
        (fg->stage_id == _BCM_FIELD_STAGE_AMFTFP) ||
        (fg->stage_id == _BCM_FIELD_STAGE_AEFTFP)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if(BCM_FAILURE(rv)) {
    	FP_UNLOCK(unit);
    	return (rv);
    }

    _field_virtual_priority_support(unit, stage_fc, &virtual_priority);

    if (virtual_priority == FALSE) {
        FP_UNLOCK(unit);
        return BCM_E_UNAVAIL;
    }

    if (!(stage_fc->flags & _FP_STAGE_AUTO_EXPANSION)) {
       FP_UNLOCK(unit);
       return (BCM_E_UNAVAIL);
    }

    if (enable) {
        fg->flags |= _FP_GROUP_SELECT_AUTO_EXPANSION;
    } else {
        fg->flags &= ~_FP_GROUP_SELECT_AUTO_EXPANSION;
    }

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function: bcm_esw_field_group_expansion_enable_get
 *
 * Purpose:
 *     Get Auto expansion status for the group.
 *
 * Parameters:
 *     unit - BCM device number.
 *     group - Requested field group ID
 *     enable - [OUT] enable/disable status of the group
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_UNAVAIL   - feature not available
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_expansion_enable_get(int unit,
                                         bcm_field_group_t group,
                                         int *enable)
{
    _field_group_t      *fg;           /* Field group structure.      */
    int                 rv;            /* Operation return status.    */
    _field_stage_t      *stage_fc;     /* Field stage control.        */
    int                 virtual_priority = FALSE;/* Virtual priority support flag.*/


    if (enable == NULL) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (fg->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if ((fg->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER) ||
        (fg->stage_id == _BCM_FIELD_STAGE_AMFTFP) ||
        (fg->stage_id == _BCM_FIELD_STAGE_AEFTFP)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if(BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    _field_virtual_priority_support(unit, stage_fc, &virtual_priority);

    if (virtual_priority == FALSE) {
        FP_UNLOCK(unit);
        return BCM_E_UNAVAIL;
    }

    if (fg->flags & _FP_GROUP_SELECT_AUTO_EXPANSION) {
        *enable = TRUE;
    } else {
        *enable = FALSE;
    }

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function: bcm_esw_field_group_port_create_mode
 *     
 * Purpose:
 *     Create a group with both a mode (single, double, etc.) and a single
 *     port.
 *
 * Parameters:
 *     unit - BCM device number.
 *     port - Port number where group is defined
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - (OUT) field Group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_port_create_mode(int unit, bcm_port_t port,
                                     bcm_field_qset_t qset, int pri,
                                     bcm_field_group_mode_t mode,
                                     bcm_field_group_t *group)
{
    int                rv;      /* Operation return status. */

#ifdef BCM_TOMAHAWK_SUPPORT
    /*
     * Validation for IFP stage in TH.
     * TH IFP: Port based Group/Logical Table ID lookup is based on
     * Pre-Selection Qualifiers and APIs,Not supported in VFP and EFP also
     * hence return BCM_E_UNAVAIL.
     */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            return (BCM_E_UNAVAIL);
        }
#endif /* !BCM_TOMAHAWK_SUPPORT */

    
    FP_LOCK(unit);

    /* Check if QSET has flowtracker stage. */
    if (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyStageIngressFlowtracker)) {
        FP_UNLOCK(unit);
        return BCM_E_UNAVAIL;
    }

    /* qset and pri are validated in bcm_field_group_port_create_mode_id(). */
    rv = _bcm_field_group_id_generate(unit, group);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = bcm_esw_field_group_port_create_mode_id(unit, port, qset, 
                                                 pri, mode, *group);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_group_port_create_mode_id
 *     
 * Purpose:
 *     Create a group with a mode (single, double, etc.), a single port,
 *     and a Group ID.
 *
 * Parameters:
 *     unit - BCM device number.
 *     port - Port number where group is defined
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - Requested field group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_port_create_mode_id(int unit, bcm_port_t port,
                                        bcm_field_qset_t qset, int pri,
                                        bcm_field_group_mode_t mode,
                                        bcm_field_group_t group)
{
    bcm_pbmp_t         pbmp;    /* Group port bitmap.       */
    int                rv;      /* Operation return status. */
    bcm_port_t         local_port; /* Local port to handle gport as input */

#ifdef BCM_TOMAHAWK_SUPPORT
    /*
     * Validation for IFP stage in TH.
     * TH IFP: Port based Group/Logical Table ID lookup is based on
     * Pre-Selection Qualifiers and APIs, Not supported in 
     * VFP and EFP also. hence return BCM_E_UNAVAIL.
     */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            return (BCM_E_UNAVAIL);
        }
#endif /* !BCM_TOMAHAWK_SUPPORT */

    /* Check if QSET has flowtracker stage. */
    if (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyStageIngressFlowtracker)) {
        FP_UNLOCK(unit);
        return BCM_E_UNAVAIL;
    }

    BCM_PBMP_CLEAR(pbmp);
    if (BCM_GPORT_IS_SET(port)) {
        BCM_IF_ERROR_RETURN(bcm_esw_port_local_get(unit, port, &local_port));
    } else {
        local_port = port;
    }
    BCM_PBMP_PORT_SET(pbmp, local_port);

    
    FP_LOCK(unit);

    rv = bcm_esw_field_group_ports_create_mode_id(unit, pbmp, qset, 
                                                  pri, mode, group);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_group_ports_create_mode
 *     
 * Purpose:
 *     Create a group with both a mode (single, double, etc.) and a port bitmap.
 *
 * Parameters:
 *     unit - BCM device number.
 *     pbmp - Ports where group is defined
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - (OUT) field Group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_ports_create_mode(int unit, bcm_pbmp_t pbmp,
                                      bcm_field_qset_t qset, int pri,
                                      bcm_field_group_mode_t mode,
                                      bcm_field_group_t *group)
{
    int                rv;      /* Operation return status. */
    FP_LOCK(unit);

    /* Check if QSET has flowtracker stage. */
    if (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyStageIngressFlowtracker)) {
        FP_UNLOCK(unit);
        return BCM_E_UNAVAIL;
    }

    /* qset and pri are validated in bcm_field_group_ports_create_mode_id(). */
    rv = _bcm_field_group_id_generate(unit, group);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = bcm_esw_field_group_ports_create_mode_id(unit, pbmp, qset, 
                                                  pri, mode, *group);
    FP_UNLOCK(unit);
    return (rv);
}

/* Function: bcm_esw_field_group_wlan_create_mode
 *     
 * Purpose:
 *     Create a wlan field group with a mode (single, double, etc.).
 *
 * Parameters:
 *     unit - BCM device number.
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - (OUT) field Group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_wlan_create_mode(int unit, bcm_field_qset_t qset, int pri,
                                     bcm_field_group_mode_t mode,
                                     bcm_field_group_t *group)
{
    int                rv;      /* Operation return status. */

    if(SOC_IS_TD2_TT2(unit) || SOC_IS_TOMAHAWKX(unit)) {
       return BCM_E_UNAVAIL;
    }	

    FP_LOCK(unit);

    /* Check if QSET has flowtracker stage. */
    if (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyStageIngressFlowtracker)) {
        FP_UNLOCK(unit);
        return BCM_E_UNAVAIL;
    }

    /* qset and pri are validated in bcm_field_group_ports_create_mode_id(). */
    rv = _bcm_field_group_id_generate(unit, group);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = bcm_esw_field_group_wlan_create_mode_id(unit, qset, pri, mode, *group);
    FP_UNLOCK(unit);
    return (rv);
}

/* Function: bcm_esw_field_group_wlan_create_mode_id
 *     
 * Purpose:
 *     Create a wlan field group with a mode (single, double, etc.).
 *
 * Parameters:
 *     unit - BCM device number.
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - (OUT) field Group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_wlan_create_mode_id(int unit, bcm_field_qset_t qset, int pri,
                                        bcm_field_group_mode_t mode,
                                        bcm_field_group_t group)
{
    _field_group_add_fsm_t fsm;     /* Group creation state machine. */
    int                    rv;      /* Operation return status.      */
    bcm_pbmp_t             all_pbmp;

    if(SOC_IS_TD2_TT2(unit) || SOC_IS_TOMAHAWKX(unit))
       return BCM_E_UNAVAIL;

    /* Check if QSET has flowtracker stage. */
    if (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyStageIngressFlowtracker)) {
        return BCM_E_UNAVAIL;
    }

    /* Read device port configuration. */ 
    BCM_PBMP_CLEAR(all_pbmp);
    BCM_IF_ERROR_RETURN(_bcm_field_valid_pbmp_get(unit, &all_pbmp));
    
    FP_LOCK(unit);

    /* Initialize group creation tracking structure. */
    sal_memset(&fsm, 0, sizeof(_field_group_add_fsm_t));
    fsm.fsm_state = _BCM_FP_GROUP_ADD_STATE_START;
    fsm.priority  = pri;
    fsm.group_id  = group;
    BCM_PBMP_ASSIGN(fsm.pbmp, all_pbmp);
    fsm.qset      = qset;
    fsm.mode      = mode;
    fsm.flags     = _BCM_FP_GROUP_ADD_WLAN;
    fsm.action_res_id     = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;

    /*  Add FP group. */
    rv = _bcm_field_group_add(unit, &fsm);

    FP_UNLOCK(unit);
    return (rv);
}

/* Function: bcm_esw_field_hints_create 
 *
 * Purpose:
 *    Generate a hint id. 
 * Parameters:
 *     unit    - (IN)  BCM device number.
 *     hint_id - (OUT) Pointer to hint_id
 * Returns:
 *     BCM_E_XXXX.
 */
int bcm_esw_field_hints_create(int unit,
                           bcm_field_hintid_t *hint_id)
{
    int rv = BCM_E_NONE;           /* Return Value */
    _field_control_t       *fc;    /* Field control structure.*/

    /* Check if Hints can be supported */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (!(soc_feature(unit, soc_feature_field_multi_pipe_support)))
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
        if (soc_feature(unit, soc_feature_field_ingress_two_slice_types) == 0) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,"AutoExpansion hints supported only for"
                                " devices that support two slice types\r\n")));
            return BCM_E_UNAVAIL;
        }
    }

    /* Input parameters check. */
    if (NULL == hint_id) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _field_hints_id_alloc (unit, hint_id);
    if (BCM_SUCCESS(rv)) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP(unit %d) hint id allocated %d\r\n"),
                                                            unit,*hint_id));
        _FP_HINTID_BMP_ADD(fc->hintid_bmp, *hint_id);
    }

    FP_UNLOCK(unit);
    return rv;
}

/* Function: bcm_esw_field_hints_add
 *
 * Purpose:
 *     Associate hint to hint id.
 * Parameters:
 *     unit    - (IN) BCM device number.
 *     hint_id - (IN) Hint id to which the hint should be associated
 *     hint    - (IN) bcm_field_hint_t structure
 * Returns:
 *     BCM_E_XXXX.
 */
int bcm_esw_field_hints_add(int unit,
                        bcm_field_hintid_t hint_id,
                        bcm_field_hint_t *hint)
{
    int                rv = BCM_E_NONE; /* Return Value */
    _field_control_t  *fc;              /* Field control structure. */

    /* Check if Hints can be supported */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (!(soc_feature(unit, soc_feature_field_multi_pipe_support)))
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
        if (soc_feature(unit, soc_feature_field_ingress_two_slice_types) == 0) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "AutoExpansion hints supported only"
                                " for devices that support two slice types\r\n")));
            return BCM_E_UNAVAIL;
        }
    }

    /* Input parameters check. */
    if ((hint == NULL) || (hint_id >= _FP_HINT_ID_MAX)) {
        return BCM_E_PARAM;
    }

    if((hint->hint_type == bcmFieldHintTypeCompression) ||
       (hint->hint_type == bcmFieldHintTypeExtraction) ||
       (hint->hint_type == bcmFieldHintTypeExactMatch) ) {
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (!(soc_feature(unit, soc_feature_field_multi_pipe_support)))
#endif /* BCM_TOMAHAWK_SUPPORT */
        {
            return BCM_E_UNAVAIL;
        }
    }

    /* Check if hint id created */
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    if (_FP_HINTID_BMP_TEST((fc->hintid_bmp), hint_id) == 0) {
        FP_UNLOCK(unit);
        return BCM_E_NOT_FOUND;
    }


    rv = _bcm_field_hints_add (unit, hint_id, hint);
    FP_UNLOCK(unit);

    return rv;
}

/* Function: bcm_esw_field_hints_get
 *
 * Purpose:
 *    Return complte hint structure after passing partial structure
 * Parameters:
 *     unit    - (IN) BCM device number.
 *     hint_id - (IN) Hint id to which the hint should be associated
 *     hint    - (INOUT) bcm_field_hint_t structure
 * Returns:
 *      BCM_E_XXXX.
 */
int bcm_esw_field_hints_get(int unit,
                        bcm_field_hintid_t hint_id,
                        bcm_field_hint_t *hint)
{
    int                  rv = BCM_E_NONE; /* Return Value */
    _field_control_t    *fc;              /* Field control structure. */

    /* Input parameters check. */
    if ((hint == NULL) || (hint_id >= _FP_HINT_ID_MAX)) {
        return BCM_E_PARAM;
    }

    /* Check if hint id created */
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    if (_FP_HINTID_BMP_TEST((fc->hintid_bmp), hint_id) == 0) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP(unit %d) Hint id %d"
                            " not created\r\n"), unit, hint_id));
        FP_UNLOCK(unit);
        return BCM_E_NOT_FOUND;
    }

    rv = _bcm_field_hints_get (unit, hint_id, hint);

    FP_UNLOCK(unit);
    return rv;
}

/* Function: bcm_esw_field_hints_delete
 *
 * Purpose:
 *     Delete bcm_field_hint_t structure from a hint_id 
 * Parameters:
 *     unit    - (IN) BCM device number.
 *     hint_id - (IN) Hint id to which the hint should be associated
 *     hint    - (IN) bcm_field_hint_t structure
 * Returns:
 *     BCM_E_XXXX.
 */
int bcm_esw_field_hints_delete (int unit,
                           bcm_field_hintid_t hint_id,
                           bcm_field_hint_t *hint)
{
    int                  rv = BCM_E_NONE; /* Return Value. */
    _field_control_t    *fc;              /* Field control structure. */

    /* Check if Hints can be supported */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (!(soc_feature(unit, soc_feature_field_multi_pipe_support)))
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
        if (soc_feature(unit, soc_feature_field_ingress_two_slice_types) == 0) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "AutoExpansion hints supported only for"
                                " devices that support two slice types\r\n")));
            return BCM_E_UNAVAIL;
        }
    }

    /* Input parameters check. */
    if ((hint == NULL) || (hint_id >= _FP_HINT_ID_MAX)) {
        return BCM_E_PARAM;
    }

    /* Check if hint id created */
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    if (_FP_HINTID_BMP_TEST((fc->hintid_bmp), hint_id) == 0) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP (unit %d) HintId %d not created\r\n"),
                                                               unit, hint_id));
        FP_UNLOCK(unit);
        return BCM_E_NOT_FOUND;
    }

    rv = _bcm_field_hints_delete (unit, hint_id, hint);

    FP_UNLOCK(unit);
    return rv;
}

/* Function: bcm_esw_field_hints_delete_all
 *
 * Purpose:
 *    Delete all the bcm_field_hint_t structures from a hint_id 
 * Parameters:
 *     unit -    (IN) BCM device number.
 *     hint_id - (IN) Hint id to which the hint should be associated.
 * Returns:
 *     BCM_E_XXXX.
 */
int bcm_esw_field_hints_delete_all(int unit,
                               bcm_field_hintid_t hint_id)
{
    int                  rv = BCM_E_NONE; /* Return Value. */
    _field_control_t    *fc;              /* Field control structure. */

    /* Check if Hints can be supported */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (!(soc_feature(unit, soc_feature_field_multi_pipe_support)))
#endif /* BCM_TOMAHAWK_SUPPORT */ 
    {
        if (soc_feature(unit, soc_feature_field_ingress_two_slice_types) == 0) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "AutoExpansion hints supported only "
                                "for devices that support two slice types\r\n")));
            return BCM_E_UNAVAIL;
        }
    }

    /* Input parameters check. */
    if (hint_id >= _FP_HINT_ID_MAX) {
        return BCM_E_PARAM;
    }

    /* Check if hint id created */
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    if (_FP_HINTID_BMP_TEST((fc->hintid_bmp), hint_id) == 0) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP (unit %d) HintId %d not created\r\n"),
                                                              unit, hint_id));
        FP_UNLOCK(unit);
        return BCM_E_NOT_FOUND;
    }

    rv = _bcm_field_hints_delete_all (unit, hint_id);

    FP_UNLOCK(unit);
    return rv;
}

/* Function: bcm_esw_field_hints_destroy
 *
 * Purpose:
 *    Delete all the bcm_field_hint_t structures from a hint_id
 * Parameters:
 *     unit - BCM device number.
 *     hint_id - (IN) Hint id to which the hint should be associated.
 * Returns:
 *     BCM_E_XXXX.
 */
int bcm_esw_field_hints_destroy(int unit,
                            bcm_field_hintid_t hint_id)
{
    int                    rv = BCM_E_NONE; /* Return Value */
    _field_control_t      *fc;    /* Field control structure.*/

    /* Check if Hints can be supported */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (!(soc_feature(unit, soc_feature_field_multi_pipe_support)))
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
        if (soc_feature(unit, soc_feature_field_ingress_two_slice_types) == 0) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                    (BSL_META_U(unit, "AutoExpansion hints supported only for"
                                " devices that support two slice types\r\n")));
            return BCM_E_UNAVAIL;
        }
    }

    /* Input parameters check. */
    if (hint_id >= _FP_HINT_ID_MAX) {
        return BCM_E_PARAM;
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = bcm_esw_field_hints_delete_all (unit, hint_id);
    if ((rv == BCM_E_NONE) || (rv == BCM_E_NOT_FOUND)) {
        _FP_HINTID_BMP_REMOVE(fc->hintid_bmp, hint_id);
        LOG_DEBUG(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP (unit %d) Hint Id %d destroyed\r\n"),
                                                              unit, hint_id));
        rv = BCM_E_NONE;
    }

    FP_UNLOCK(unit);
    return rv;
}

/* Function: bcm_esw_field_group_config_create
 *
 * Purpose:
 *     Create a group with a mode (single, double, etc.), a port bitmap,
 *     group size and a Group ID.
 * Parameters:
 *     unit - BCM device number.
 *     group_config - Group create attributes namely:
 *          flags       - (IN) Bits indicate which parameters have been
 *                             passed to API and should be used during group
 *                             creation.
 *          qset        - (IN) Field qualifier set
 *          priority    - (IN) Priority within allowable range,
 *                             or BCM_FIELD_GROUP_PRIO_ANY to automatically
 *                             assign a priority; each priority value may be
 *                             used only once
 *          mode        - (IN) Group mode (single, double, triple or Auto-wide)
 *          ports       - (IN) Ports where group is defined
 *          group       - (IN/OUT) Requested Group ID. If Group ID is not set,
 *                              then API allocates and returns the created
 *                              Group ID.
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_config_create(int unit,
                                  bcm_field_group_config_t *group_config)
{
    int                    rv;      /* Operation return status.      */

    FP_LOCK(unit);
    rv = _bcm_esw_field_group_config_create(unit, group_config, 0);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_groups_ports_create_mode_id
 *     
 * Purpose:
 *     Create a group with a mode (single, double, etc.), a port bitmap, and
 *     a Group ID. In practice, the other group creation APIs call this one.
 *     This confirms that the required slice resources are available and
 *     calculates the sets of select codes needed to satisfy the Qset. It also
 *     creates the necessary internal data structures to manage the group.
 *
 * Parameters:
 *     unit - BCM device number.
 *     pbmp - Ports where group is defined
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - Requested Group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_ports_create_mode_id(int unit, bcm_pbmp_t pbmp,
                                         bcm_field_qset_t qset, int pri,
                                         bcm_field_group_mode_t mode,
                                         bcm_field_group_t group)
{
    _field_group_add_fsm_t *fsm;     /* Group creation state machine. */
    _field_control_t       *fc;     /* Field control structure.      */
    int                    rv = 0;      /* Operation return status.      */
    bcm_pbmp_t             valid_pbm, temp_pbm;
#if defined(BCM_TOMAHAWK_SUPPORT)
    bcm_field_group_config_t *gc;    /* Group configuration structure. */
    bcm_pbmp_t all_pbmp;             /* Hold valid pbm supported */
#endif /* BCM_TOMAHAWK_SUPPORT */

    fsm = NULL;

    if (BCM_PBMP_IS_NULL(pbmp)) {
        return BCM_E_PARAM;
    }

    rv = _bcm_field_valid_pbmp_get(unit, &valid_pbm);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

    /* Validate data */
    BCM_PBMP_ASSIGN(temp_pbm, valid_pbm);
    BCM_PBMP_AND(temp_pbm, pbmp);

    if (BCM_PBMP_NEQ(temp_pbm, pbmp)) {
        return BCM_E_PARAM;
    }

#ifdef BCM_TOMAHAWK_SUPPORT
    /*
     * Validation for IFP stage in TH.
     * TH IFP: Port based Group/Logical Table ID lookup is based on
     * Pre-Selection Qualifiers and APIs, hence return BCM_E_UNAVAIL.
     */
    gc = NULL;

    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            /* Get device port configuration. */
            BCM_IF_ERROR_RETURN(_bcm_field_valid_pbmp_get(unit, &all_pbmp)); 
            /*
             * Validate input port bitmap value and confirm it includes all
             * ports for TH IFP stage else return unavailable support error.
             */
            if (BCM_PBMP_NEQ(pbmp, all_pbmp)) {
                rv = BCM_E_UNAVAIL;
                goto bcm_error;
            }
        }
#endif /* BCM_TOMAHAWK_SUPPORT */

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        goto bcm_error;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* If device supports per-pipe FP configuration, */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        /* Clear group configuration structure. */
        _FP_XGS3_ALLOC(gc, sizeof(bcm_field_group_config_t),
                       "Group config info ");
        bcm_field_group_config_t_init(gc);

        /* Initialize group configuration parameters. */
        gc->priority = pri;
        gc->group = group;
        gc->ports = pbmp;
        gc->qset = qset;
        gc->mode = mode;
        gc->flags |= (BCM_FIELD_GROUP_CREATE_WITH_ID |
                        BCM_FIELD_GROUP_CREATE_WITH_MODE);

        /* Call Flexible Key Extraction programming function for TH IFP. */
        rv = fc->functions.fp_group_add(unit, 0, gc);
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
        /* Initialize group creation tracking structure. */
        _FP_XGS3_ALLOC(fsm, sizeof(_field_group_add_fsm_t),
                       "Group fsm info ");

        fsm->fsm_state = _BCM_FP_GROUP_ADD_STATE_START;
        fsm->priority  = pri;
        fsm->group_id  = group;
        fsm->pbmp      = pbmp;
        fsm->qset      = qset;
        fsm->mode      = mode;
        fsm->action_res_id     = BCM_FIELD_GROUP_ACTION_RES_ID_DEFAULT;

        /*  Add FP group. */
        rv = _bcm_field_group_add(unit, fsm);
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    SOC_CONTROL_LOCK(unit);
    SOC_CONTROL(unit)->scache_dirty = 1;
    SOC_CONTROL_UNLOCK(unit);
#endif

    FP_UNLOCK(unit);

bcm_error:
#ifdef BCM_TOMAHAWK_SUPPORT
    if (gc != NULL) {
        sal_free(gc);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
    if (fsm != NULL) {
        sal_free(fsm);
    }
    return (rv);
}

int 
bcm_esw_field_group_action_set(int               unit, 
                               bcm_field_group_t group, 
                               bcm_field_aset_t  aset
                               )
{
    int              errcode = BCM_E_NONE;
    _field_group_t   *fg;
    unsigned         action;

    
    FP_LOCK(unit);

    if (BCM_FAILURE(errcode = _field_group_get(unit, group, &fg))) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: group=%d not found \n"),
                   unit, group));
        goto cleanup;
    }

#if defined(BCM_TOMAHAWK_SUPPORT) /* BCM_TOMAHAWK_SUPPORT */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)
        && ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
            (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id))) {
        /* Get TH IFP group's status. */
        errcode = _bcm_field_th_group_status_calc(unit, fg);
    } else if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
               (fg->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        errcode = BCM_E_UNAVAIL;
        goto cleanup;
    } else
#endif /* !BCM_TOMAHAWK_SUPPORT */
#if defined(BCM_FLOWTRACKER_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_support)
        && (_BCM_FIELD_STAGE_FLOWTRACKER == fg->stage_id)) {
        errcode = BCM_E_NONE;
    } else
#endif /* !BCM_FLOWTRACKER_SUPPORT */
#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)
        && ((_BCM_FIELD_STAGE_AMFTFP == fg->stage_id) ||
            (_BCM_FIELD_STAGE_AEFTFP == fg->stage_id))) {
        errcode = BCM_E_NONE;
    } else
#endif /* !BCM_FLOWTRACEKR_V3_SUPPORT */
    {
        errcode = _bcm_field_group_status_calc(unit, fg);
    }

    if (BCM_FAILURE(errcode)) {
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit,
            "FP(unit %d) Error: group=%d status calc failed.\n"), unit, group));
        goto cleanup;
    }

#if defined(BCM_TRIDENT3_SUPPORT)
        if(soc_feature(unit, soc_feature_ifp_action_profiling)) {
            if (fg->stage_id == _BCM_FIELD_STAGE_INGRESS) {
                errcode = _field_td3_field_group_aset_update(unit, fg, &aset);
                goto cleanup;
            }
        }
#endif
#if defined(BCM_FLOWTRACKER_SUPPORT)
        if (soc_feature(unit, soc_feature_field_flowtracker_support)) {
            if (fg->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER) {
                errcode = _bcm_field_hx5_ft_group_aset_update(unit, fg, &aset);
                goto cleanup;
            }
        }
#endif

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
        if ((fg->stage_id == _BCM_FIELD_STAGE_AMFTFP) ||
            (fg->stage_id == _BCM_FIELD_STAGE_AEFTFP)) {
            errcode = _bcm_field_hx5_ft_group_aset_update(unit, fg, &aset);
            goto cleanup;
        }
    }
#endif

    if (fg->group_status.entries_free != fg->group_status.entries_total) {
        /* Some entries defined in group => error */

        errcode = BCM_E_CONFIG;
        goto cleanup;
    }
    
    /* Check all actions are supported */
    
    for (action = 0; action < bcmFieldActionCount; ++action) {
        if (!SHR_BITGET(aset.w, action)) {
            continue;
        }
        
        if (!_field_stage_action_support_check(unit, fg, action)) {
            errcode = BCM_E_UNAVAIL;
            goto cleanup;
        }
    }

    /* Assign aset to group */
#if defined(BCM_TOMAHAWK_SUPPORT) /* BCM_TOMAHAWK_SUPPORT */
    sal_memcpy(&(fg->aset.w), &(aset.w), (sizeof(SHR_BITDCL) *
        (_SHR_BITDCLSIZE(bcmFieldActionCount))));
    sal_memcpy(&(fg->aset.actions_width), &(aset.actions_width),
        (sizeof(bcm_field_action_width_t) * _BCM_FIELD_MAX_ACTIONS_PER_DB));
#else
    sal_memcpy(&fg->aset, &aset, sizeof(bcm_field_aset_t));
#endif

    /* Install aset in hardware */

    errcode = _field_aset_install(unit, fg);

 cleanup:
    FP_UNLOCK(unit);
    return (errcode);
}


int 
bcm_esw_field_group_action_get(int               unit, 
                               bcm_field_group_t group, 
                               bcm_field_aset_t  *aset
                               )
{
    int              errcode;
    _field_group_t   *fg;

    
    FP_LOCK(unit);

    errcode = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(errcode)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: group=%d not found \n"),
                   unit, group));
        FP_UNLOCK(unit);
        return (errcode);
    }

    /* Assign aset to group */
#if defined(BCM_TOMAHAWK_SUPPORT) /* BCM_TOMAHAWK_SUPPORT */
    sal_memcpy(aset->w, &(fg->aset.w), (sizeof(SHR_BITDCL) *
        (_SHR_BITDCLSIZE(bcmFieldActionCount))));
    sal_memcpy(aset->actions_width, &(fg->aset.actions_width),
        (sizeof(bcm_field_action_width_t) * _BCM_FIELD_MAX_ACTIONS_PER_DB));
#else
    sal_memcpy(aset, &fg->aset, sizeof(bcm_field_aset_t));
#endif

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}


/*
 * Function: bcm_esw_field_group_mode_get
 *
 * Purpose:
 *     Return the mode of a Group ID. This is its single, double or triple-wide
 *     state. Mode specified the number of slices allocated to the group.
 *
 * Parameters:
 *     unit  - (IN) BCM device number.
 *     group - (IN) Field group ID.
 *     mode  - (OUT) single, double, triple or auto mode.
 *     
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_NOT_FOUND - Group ID not found for in this unit
 *     BCM_E_PARAM     - mode pointing to NULL
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_mode_get(int unit,
                             bcm_field_group_t group,
                             bcm_field_group_mode_t *mode)
{
    _field_group_t    *fg;     /* Field group info.       */
    int                rv;     /* Operation return value. */             
    _field_stage_t    *stage_fc; /* stage info */

    if (mode == NULL) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: mode=>NULL\n"),
                   unit));
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: group=%d not found \n"),
                   unit, group));
        FP_UNLOCK(unit);
        return (BCM_E_NOT_FOUND);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (fg->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    rv = _bcm_esw_field_group_mode_get(fg->flags, mode);

    /* Retreive Stage Control. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined (BCM_TOMAHAWK3_SUPPORT) || defined (BCM_HELIX5_SUPPORT)
    if ((soc_feature(unit, soc_feature_ifp_no_narrow_mode_support)
        || soc_feature(unit, soc_feature_hx5_style_ifp_no_narrow_mode_support)) &&
         (*mode == bcmFieldGroupModeIntraSliceDouble) &&
         (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {
         *mode = bcmFieldGroupModeSingle;
    }
#endif

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     _bcm_field_qset_validate
 *
 * Purpose:
 *     validate the qset to be added to existing group.
 *
 * Parameters:
 *     unit         - (IN)BCM device number.
 *     groupStage   - (IN)Pipeline stage id of existing group
 *     qset_p       - (IN) qualifiers set to be added.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
_bcm_field_qset_validate(int unit, _field_stage_id_t group_stage,
                         bcm_field_qset_t *qset_p) {
    int stage_count = 0;   /* Check that only 1 stage specified in qset */
    _field_stage_id_t stage = group_stage; /*stage in the qset */

    if (NULL == qset_p) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    /* Set stage based on qualifiers set. */
    if (soc_feature(unit, soc_feature_field_multi_stage)) {
        if(BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageIngress)) {
            stage  = _BCM_FIELD_STAGE_INGRESS;
            stage_count++;
        }
        if(BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageEgress)) {
            stage  = _BCM_FIELD_STAGE_EGRESS;
            stage_count++;
        }

        if(BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageLookup)) {
            stage  = _BCM_FIELD_STAGE_LOOKUP;
            stage_count++;
        }
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */

    if (BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageExternal)) {
        stage  = _BCM_FIELD_STAGE_EXTERNAL;
        stage_count++;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageClass)) {
        stage  = _BCM_FIELD_STAGE_CLASS;
        stage_count++;
    }
    if (BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageClassExactMatch)) {
        stage  = _BCM_FIELD_STAGE_CLASS;
        stage_count++;
    }
    if (BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageIngressExactMatch)) {
        stage  = _BCM_FIELD_STAGE_EXACTMATCH;
        stage_count++;
    }
#if defined (BCM_FLOWTRACKER_SUPPORT)
    if (BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageIngressFlowtracker)) {
        stage = _BCM_FIELD_STAGE_FLOWTRACKER;
        stage_count++;
    }
#endif
#if defined (BCM_FLOWTRACKER_V3_SUPPORT)
    if (BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageAggregateMmuFlowtracker)) {
        stage = _BCM_FIELD_STAGE_AMFTFP;
        stage_count++;
    }
    if (BCM_FIELD_QSET_TEST(*qset_p, bcmFieldQualifyStageAggregateEgressFlowtracker)) {
        stage = _BCM_FIELD_STAGE_AEFTFP;
        stage_count++;
    }
#endif

#endif /* BCM_TOMAHAWK_SUPPORT */

    if (stage_count == 0) {
        return (BCM_E_NONE);
    }

    if (stage_count > 1) {
        LOG_ERROR(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                  "FP(unit %d) Error: More than one pipeline stage"
                  " was specified.\n"), unit));
        return (BCM_E_PARAM);
    }

    if (stage != group_stage) {
        LOG_ERROR(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                  "FP(unit %d) Error: Stage in given qset is not "
                  "same as exisiting group stage.\n"), unit));
        return (BCM_E_PARAM);
    }

    return (BCM_E_NONE);
}

/*
 * Function: bcm_esw_field_group_set
 *    
 * Purpose:
 *     Update a previously created field group based on the field
 *     group selector flags
 *     
 * Parameters:
 *     unit  - BCM device number
 *     group - Field group ID
 *     qset  - Field qualifier set
 *     
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_NOT_FOUND - Group ID not found for in this unit
 *     BCM_E_RESOURCE  - No select code can satisfy qualifier set
 *     BCM_E_NONE      - Success
 *     
 * Notes:
 *     If no entry exist that use this group then updates are always
 *     permitted.
 *     If entries exist that use this group then updates are permitted
 *     only if it can be satisfied with the current selection of
 *     (fpf0, fpf1, fpf2, fpf3) field selector encodings.
 */
int
bcm_esw_field_group_set(int unit,
                        bcm_field_group_t group,
                        bcm_field_qset_t qset)
{
    bcm_field_qset_t        sel_qset[_FP_MAX_ENTRY_WIDTH];
    bcm_field_qset_t        qset_full, qset_old;
    _field_control_t        *fc;    
    _field_group_t          *fg;
    _field_stage_t          *stage_fc;            
    int                     re_create;
    bcm_field_group_mode_t  mode = bcmFieldGroupModeAuto;
    int                     priority;
    int                     idx;
    int                     rv;
    int                     virtual_priority = FALSE;/* Virtual priority support flag.*/
    bcm_field_group_config_t group_config;
    uint32 max_udf_chunks = 0;
    int indx = 0;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb:BEGIN bcm_field_group_set(group=%d)\n"),
               unit, group));

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (fg->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    rv = _bcm_field_qset_validate(unit, fg->stage_id, &qset);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    _field_virtual_priority_support(unit, stage_fc, &virtual_priority);

    /* If no entries have been added to group try requested qset.  */
    if ((0 == fg->group_status.entry_count) &&
        (stage_fc->stage_id != _BCM_FIELD_STAGE_EXTERNAL)) {

        LOG_VERBOSE(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP: bcm_field_group_set() with no entries\n")));

        /* Remember the group's current Qset, mode, and Priority (base slice/ user priority). */
        qset_old = fg->qset;
        if (virtual_priority) {
            priority = fg->priority;
        } else {
            priority = fg->slices[0].slice_number;
        }

        rv = _bcm_esw_field_group_mode_get(fg->flags, &mode);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
#if defined (BCM_TOMAHAWK3_SUPPORT) || defined (BCM_HELIX5_SUPPORT)
        if ((soc_feature(unit, soc_feature_ifp_no_narrow_mode_support) ||
             soc_feature(unit, soc_feature_hx5_style_ifp_no_narrow_mode_support)) &&
            (mode == bcmFieldGroupModeIntraSliceDouble) &&
            (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {
             mode = bcmFieldGroupModeSingle;
        }
#endif

        bcm_field_group_config_t_init(&group_config);
        /* OR new qset */
        BCM_FIELD_QSET_INIT(group_config.qset);
        _BCM_FIELD_QSET_OR(group_config.qset, qset, _bcmFieldQualifyCount);
        _BCM_FIELD_QSET_OR(group_config.qset, qset_old, _bcmFieldQualifyCount);

        max_udf_chunks = _SHR_BITDCLSIZE(BCM_FIELD_USER_NUM_UDFS);
        for ( indx=0; indx < max_udf_chunks; indx++) {
           group_config.qset.udf_map[indx] |=  qset.udf_map[indx];
           group_config.qset.udf_map[indx] |=  qset_old.udf_map[indx];
        }

        /* Set Priority and mode */
        group_config.priority = priority;
        group_config.flags |= BCM_FIELD_GROUP_CREATE_WITH_MODE;
        group_config.mode = mode;

        group_config.flags |= BCM_FIELD_GROUP_CREATE_WITH_ID;
        group_config.group = group;
        /* Copy Group PBMP to group config structure */
        BCM_PBMP_ASSIGN(group_config.ports, fg->pbmp);
        /*
         * Set PORT Based flag by default.
         * New group should have the ports present in the old group structure.
         */
        group_config.flags |= BCM_FIELD_GROUP_CREATE_WITH_PORT;

#if defined(BCM_TOMAHAWK_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            if ((stage_fc->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER) ||
                    (stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
                    (stage_fc->stage_id == _BCM_FIELD_STAGE_EXACTMATCH)) {
                /* Add presels */
                for (idx = 0; idx < _FP_PRESEL_ENTRIES_MAX_PER_GROUP; idx++) {
                    if (fg->presel_ent_arr[idx] != NULL) {
                        BCM_FIELD_PRESEL_ADD(group_config.preselset,
                                fg->presel_ent_arr[idx]->presel_id);
                        group_config.flags |= BCM_FIELD_GROUP_CREATE_WITH_PRESELSET;
                    }
                }
                for (idx = 0 ; idx < bcmFieldActionCount; idx++) {
                    if (BCM_FIELD_ASET_TEST(fg->aset, idx)) {
                        BCM_FIELD_ASET_ADD(group_config.aset, idx);
                    }
                }
            }
        }
#endif
#if defined(BCM_FIREBOLT6_SUPPORT)
        if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {
            if ((stage_fc->stage_id == _BCM_FIELD_STAGE_AMFTFP) ||
                    (stage_fc->stage_id == _BCM_FIELD_STAGE_AEFTFP)) {

                for (idx = 0 ; idx < bcmFieldActionCount; idx++) {
                    if (BCM_FIELD_ASET_TEST(fg->aset, idx)) {
                        BCM_FIELD_ASET_ADD(group_config.aset, idx);
                    }
                }
            }
        }
#endif

        /* Set hintId, action_res_id */
        group_config.hintid = fg->hintid;
        group_config.action_res_id = fg->action_res_id;
        /* Destroy the old group. */
        rv = bcm_esw_field_group_destroy(unit, group);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        /* Try to re-create the group with the requested Qset. */
        rv = bcm_esw_field_group_config_create(unit, &group_config);
        /* On failure, re-create the old group. */
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: new Qset won't work on group=%d.\n"),
                       unit, group));
            BCM_FIELD_QSET_INIT(group_config.qset);
            _BCM_FIELD_QSET_OR(group_config.qset, qset_old, _bcmFieldQualifyCount);
            re_create = bcm_esw_field_group_config_create(unit, &group_config);
            if (BCM_FAILURE(re_create)) { /* Should never fail. */
                rv = BCM_E_INTERNAL;
            }
        }
        FP_UNLOCK(unit);
        return rv;
    }

#ifdef BCM_TOMAHAWK_SUPPORT
    /*
     * TH IFP HW TCAM key generation and extractor selector values are specific to a
     * Group's QSET and determined dynamically during group creation.
     * There are no pre-defined qualifiers to field selector/extractor mapping
     * in HW. To modify an existing Group's QSET, entry count must be zero in TH
     * IFP group.
     */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        if(stage_fc->stage_id == _BCM_FIELD_STAGE_INGRESS) {
            rv = _bcm_field_th_group_update(unit, group, &qset);
            FP_UNLOCK(unit);
            return rv;
#if defined (BCM_FLOWTRACKER_SUPPORT)
        } else if (stage_fc->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER) {
            rv = _bcm_field_hx5_ft_group_update(unit, group, &qset);
            FP_UNLOCK(unit);
            return rv;
#endif
        }
    }
#endif /* !BCM_TOMAHAWK_SUPPORT */

    /*Expand qset with Internal qualifiers*/
    qset_old = fg->qset;
    fg->qset = qset;
    rv = _field_group_qset_update(unit, fg);
    if (BCM_FAILURE(rv)) {
        fg->qset = qset_old;
        FP_UNLOCK(unit);
        return rv;
    }
    qset = fg->qset;
    fg->qset = qset_old;


    /*
     * Handle cases where entries have been previously set in group.
     */

    /* Initialize local slice Qsets. */
    BCM_FIELD_QSET_INIT(qset_full);
    for (idx = 0; idx < _FP_MAX_ENTRY_WIDTH; idx++) {
        BCM_FIELD_QSET_INIT(sel_qset[idx]);


        rv = fc->functions.fp_selcode_to_qset(unit, stage_fc, fg,
                                              idx, &sel_qset[idx]);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        _field_qset_union(&sel_qset[idx], &qset_full, &qset_full);
    }

    /* If the requested Qset is supported by the current select codes, 
     * change the group's qset.
     */

    /* qset_full represents total Qset that current select codes support.
     * If the requested Qset is a subset of the full Qset, then the current
     * select codes will work. */
    if (_field_qset_is_subset(&qset, &qset_full)) {

        /* Increment the use-counts of any new UDFs. */
        _field_udf_usecount_update(fc->udf, &fg->qset, &qset);

        _field_qset_union(&fg->qset, &qset, &fg->qset);
        LOG_VERBOSE(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP: Current select codes satisify new Qset\n")));

        /* Regenerate the qualifier info lists */
        rv= fc->functions.fp_qual_list_get(unit, stage_fc, fg);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }

        FP_UNLOCK(unit);
        return (BCM_E_NONE);
    }

    if (stage_fc->stage_id == _BCM_FIELD_STAGE_EXTERNAL) {
        FP_UNLOCK(unit);
        return (BCM_E_RESOURCE);
    }

    /* 
     * Otherwise, use the current fg->sel_codes as a baseline. Try to
     * change any "don't care" FPFx settings to get the requested qset.
     */
    if (stage_fc->stage_id == _BCM_FIELD_STAGE_EGRESS) {
        /* EFP previous selcodes will be reset in _field_selcode_assign */
        rv = _bcm_field_selcode_get(unit, stage_fc, &qset, fg);
    } else {
        rv = _field_selcode_assign(unit, qset, 0, fg);
    }
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /* Increment the use-counts of any new UDFs. */
    _field_udf_usecount_update(fc->udf, &fg->qset, &qset);

    _field_qset_union(&fg->qset, &qset, &fg->qset);

    /* Regenerate the qualifier info lists */
    rv= fc->functions.fp_qual_list_get(unit, stage_fc, fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /* Write the new select codes to hardware. */
    rv = fc->functions.fp_group_install(unit, fg);

#ifdef BCM_WARM_BOOT_SUPPORT
    SOC_CONTROL_LOCK(unit);
    SOC_CONTROL(unit)->scache_dirty = 1;
    SOC_CONTROL_UNLOCK(unit);
#endif

    FP_UNLOCK(unit);
    return rv;
}

/*
 * Function: bcm_esw_field_group_get
 *    
 * Purpose:
 *     Get the qualifier set for a previously created field group
 *     
 * Parameters:
 *     unit  - BCM device number
 *     port  - Port number
 *     group - Field group ID
 *     qset  - (OUT) Field qualifier set
 *     
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized.
 *     BCM_E_NOT_FOUND - Group ID not found in this unit
 *     BCM_E_PARAM     - qset is NULL
 *     BCM_E_NONE      - Success
 */

int
bcm_esw_field_group_get(int unit,
                        bcm_field_group_t group,
                        bcm_field_qset_t *qset)
{
    _field_group_t         *fg;     /* Field group structure.      */
    int                    rv;      /* Operation return status.    */

    /* Input parameters check. */
    if (qset == NULL) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_group_get(unit, group, &fg);
    if (BCM_SUCCESS(rv)) {
        *qset = fg->qset;
    }

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_group_destroy
 *    
 * Purpose:
 *     Delete a field group
 *     
 * Parameters:
 *     unit - BCM device number
 *     port - Port number
 *     group - Field group
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_NOT_FOUND - Group ID not found in unit
 *     BCM_E_BUSY      - Entries not destroyed yet
 *     BCM_E_NONE      - Success
 *
 * Notes:
 *      All entries that uses this group should have been destroyed
 *      before calling this routine.
 *      Operation will fail if entries exist that uses this template
 */
int
bcm_esw_field_group_destroy(int unit, bcm_field_group_t group)
{
    _field_stage_t      *stage_fc; /* Stage field control structure.  */
    _field_group_t      *fg;      /* Group structure to free up       */ 
    int                 rv;       /* Operation return status.         */
    int                 virtual_priority = FALSE;/* Virtual priority support flag.*/

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: bcm_field_group_destroy(group=%d)\n"),
               unit, group));

    /* Find and validate field control. */
    
    FP_LOCK(unit);

    /* Search the field control for the Group ID. */
    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: Group=%d not found in device.\n"),
                   unit, group));
        return (rv);
    }
  
    /* okay, go ahead and free the group */

    /* Entries must be freed first (see note above). */
    if (0 != fg->group_status.entry_count) {
        FP_UNLOCK(unit);
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: entries still in group=%d.\n"),
                   unit, group));
        return (BCM_E_BUSY);
    }

    /* Get stage control for virtual map update. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: Get stage (%d) control failed (%d).\n"), 
                   unit, fg->stage_id, rv));
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)
        && ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
            (_BCM_FIELD_STAGE_CLASS == fg->stage_id) ||
            (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id) ||
            (_BCM_FIELD_STAGE_FLOWTRACKER == fg->stage_id))) {
        rv = _bcm_field_th_group_deinit(unit, fg);
    } else 
#endif /* !BCM_TOMAHAWK_SUPPORT */
    {
        if (!(fg->flags & _FP_GROUP_CONFIG_VALIDATE)) {
            _field_virtual_priority_support(unit, stage_fc, &virtual_priority);
            if ((virtual_priority) &&
                BCM_PBMP_EQ(fg->pbmp, fg->slices[0].pbmp)) {
                /*
                 * If this is the only group in the slice 
                 * flush group slices from virtual map.  
                 */
                rv = _field_group_vmap_delete(unit, stage_fc, fg, TRUE);
            }
        }
        _field_group_deinit(unit, fg);
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    SOC_CONTROL_LOCK(unit);
    SOC_CONTROL(unit)->scache_dirty = 1;
    SOC_CONTROL_UNLOCK(unit);
#endif

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function: bcm_esw_field_group_compress
 *
 * Purpose:
 *     Compress filed group entries, 
 *     in order to free slices used by the group.
 * Paramters:
 *     unit  - (IN) BCM device number
 *     group - (IN) Field group ID
 * Returns:
 *     BCM_E_XXX
 */

int
bcm_esw_field_group_compress(int unit, bcm_field_group_t group)
{
    _field_stage_t    *stage_fc;  /* Field group structure.   */
    _field_group_t          *fg;  /* Field group structure.   */
    int                      rv;  /* Operation return status. */

    /* Lock the module. */
    
    FP_LOCK(unit);

    /* Get group control structure. */
    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Get stage control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        if (fg->stage_id == _BCM_FIELD_STAGE_CLASS) {
           FP_UNLOCK(unit);
           return (BCM_E_UNAVAIL);
        }

        if ((fg->stage_id == _BCM_FIELD_STAGE_AMFTFP) ||
            (fg->stage_id == _BCM_FIELD_STAGE_AEFTFP) ||
            (fg->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER)) {
            FP_UNLOCK(unit);
            return (BCM_E_UNAVAIL);
        }

        if (fg->stage_id == _BCM_FIELD_STAGE_INGRESS) {
           rv = _bcm_field_th_group_compress(unit, fg, stage_fc);
           FP_UNLOCK(unit);
           return rv;
        }  
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    rv = _field_group_compress(unit, fg, stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    SOC_CONTROL_LOCK(unit);
    SOC_CONTROL(unit)->scache_dirty = 1;
    SOC_CONTROL_UNLOCK(unit);
#endif

   FP_UNLOCK(unit);
   return (rv);
}

/*
 * Function: bcm_esw_field_group_priority_set
 *
 * Purpose:
 *    Set field group priority. 
 * Paramters:
 *     unit     - (IN) BCM device number
 *     group    - (IN) Field group ID
 *     priority - (IN) Assigned group priority.
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_group_priority_set(int unit, bcm_field_group_t group,
                                 int priority)
{
    _field_group_t   *fg;      /* Field group structure.   */
    _field_stage_t   *stage_fc;/* Field stage control.     */
    int              rv;       /* Operation return status. */
    int                 virtual_priority = FALSE;/* Virtual priority support flag.*/

    /* Lock the module. */
    
    FP_LOCK(unit);

    /* Get group control structure. */
    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (fg->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_support) &&
            (fg->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER)) {
        FP_UNLOCK(unit);
        LOG_INFO(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP(unit %d) Error: Field Group Priority"
                            " not supported at this stage.\n"), unit));
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_FLOWTRACKER_SUPPORT */

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support) &&
           ((fg->stage_id == _BCM_FIELD_STAGE_AMFTFP) ||
            (fg->stage_id == _BCM_FIELD_STAGE_AEFTFP))) {
        FP_UNLOCK(unit);
        LOG_INFO(BSL_LS_BCM_FP,
                (BSL_META_U(unit, "FP(unit %d) Error: Field Group Priority"
                            " not supported at this stage.\n"), unit));
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_FLOWTRACKER_V3_SUPPORT */

    /* Get stage control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    _field_virtual_priority_support(unit, stage_fc, &virtual_priority);

    if (virtual_priority == FALSE) {
        FP_UNLOCK(unit);
        return BCM_E_UNAVAIL;
    }

#ifdef BCM_TOMAHAWK_SUPPORT
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)
        && ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
            (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id))) {
        rv = _bcm_field_th_group_lt_prio_update(unit, fg, priority);
    } else
#endif /* !BCM_TOMAHAWK_SUPPORT */
    {
        /* Remove the group from virtual map . */
        rv = _field_group_vmap_delete(unit, stage_fc, fg, FALSE);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

        /* Assingn group priority. */
        fg->priority = priority;

        /* Reinstall group virtual map . */
        rv = _field_group_vmap_add(unit, stage_fc, fg);
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    SOC_CONTROL_LOCK(unit);
    SOC_CONTROL(unit)->scache_dirty = 1;
    SOC_CONTROL_UNLOCK(unit);
#endif

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_group_priority_get
 *
 * Purpose:
 *    Get field group priority. 
 * Paramters:
 *     unit     - (IN) BCM device number
 *     group    - (IN) Field group ID
 *     priority - (OUT) Assigned group priority.
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_group_priority_get(int unit, bcm_field_group_t group, 
                                 int *priority)
{
    _field_group_t      *fg;      /* Field group structure.   */
    int                  rv;      /* Operation return status. */
    _field_stage_t      *stage_fc;     /* Field stage control */
    int                 virtual_priority = FALSE;/* Virtual priority support flag.*/

    /* Lock the module. */
    
    FP_LOCK(unit);

    /* Get group control structure. */
    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (fg->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if(BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    _field_virtual_priority_support(unit, stage_fc, &virtual_priority);

    if (virtual_priority == FALSE) {
        FP_UNLOCK(unit);
        return BCM_E_UNAVAIL;
    }

    *priority = fg->priority;

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}


/*
 * Function: bcm_esw_field_group_status_get
 *
 * Purpose:
 *     Get the number of used and available entries, counters, and
 *     meters for a field group.
 *
 * Paramters:
 *     unit - BCM device number
 *     group - Field group ID
 *     status - (OUT) Status structure
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit has not been intialized
 *     BCM_E_NOT_FOUND - Group ID not found on unit.
 *     BCM_E_PARAM     - *status is NULL
 *     BCM_E_NONE      - Success
 */

int
bcm_esw_field_group_status_get(int unit,
                               bcm_field_group_t group,
                               bcm_field_group_status_t *status)
{
    _field_group_t      *fg;
    int                  rv;

    if (status == NULL) {
        return (BCM_E_PARAM);
    }

    /* Lock the module. */
    
    FP_LOCK(unit);

    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT) /* BCM_TOMAHAWK_SUPPORT */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)
        && ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
            (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id))) {
        /* Get TH IFP group's status. */
        rv = _bcm_field_th_group_status_calc(unit, fg);
    } else if (soc_feature(unit, soc_feature_field_multi_pipe_support)
           && (_BCM_FIELD_STAGE_CLASS == fg->stage_id)) {
        /* Do nothing. for class group status calc
         * It's updated in runtime directly. */
         rv = BCM_E_NONE;
    } else
#endif /* !BCM_TOMAHAWK_SUPPORT */
    {
        /* Update the numbers of free entries, meters and counters. */
        rv = _bcm_field_group_status_calc(unit, fg);
    }


    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    *status = fg->group_status;
    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function: bcm_esw_field_group_enable_set
 *    
 * Purpose:
 *     Enable/disable packet lookup on a group.
 *
 * Parameters:
 *     unit   - BCM device number
 *     enable - lookup enable!=0/disable==0 state of group
 *     group  - Field group ID
 *
 * Returns:
 *     BCM_E_NONE      - Success
 *     BCM_E_UNAVAIL   - BCM device does not have enable/disable feature
 *
 * Note:
 *     As a slice may have multiple groups, we just disable the entries
 *         of the particular group.
 */
int
bcm_esw_field_group_enable_set(int unit, bcm_field_group_t group, int enable)
{
    _field_group_t *fg;       /* Field group control structure. */
    _field_stage_t *stage_fc; /* Stage field control structure. */
    int rv;                   /* Operation return status.       */

    /* Get field control structure. */
    
    FP_LOCK(unit);

    /* Get field group descriptor. */
    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (fg->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Get field stage control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }
    
    /* Check slice enable feature support. */
    if (0 == (stage_fc->flags & _FP_STAGE_SLICE_ENABLE)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) ||
         (_BCM_FIELD_STAGE_EXACTMATCH == stage_fc->stage_id))) {
        rv =  _bcm_field_th_group_enable_set(unit, group, enable);
        FP_UNLOCK(unit);
        return rv;
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Enable/disable primary slice. */
    rv = _field_fb_entries_enable_set(unit, fg, &fg->slices[0],enable);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* If needed, enable/disable secondary slice. */
    if (!(fg->flags & _FP_GROUP_SPAN_SINGLE_SLICE)) {
        rv = _field_fb_entries_enable_set(unit, fg, &fg->slices[1], enable);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    /* If needed, enable/disable tertiary slice. */
    if (fg->flags & _FP_GROUP_SPAN_TRIPLE_SLICE) {
        rv = _field_fb_entries_enable_set(unit, fg, &fg->slices[2], enable);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    if (enable) {
        fg->flags |= _FP_GROUP_LOOKUP_ENABLED; 
    } else {
        fg->flags &= ~_FP_GROUP_LOOKUP_ENABLED; 
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function: bcm_esw_field_group_enable_get
 *    
 * Purpose:
 *     Get the lookup enable/disable state of a group
 *
 * Parameters:
 *     unit   - BCM device number
 *     group  - Field group ID
 *     enable - (OUT) lookup enable/disable state of group
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_group_enable_get(int unit, bcm_field_group_t group, int *enable)
{
    _field_group_t *fg;       /* Field group control structure. */
    int rv;                   /* Operation return status.       */

    if (NULL == enable) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_group_get(unit, group, &fg);
    if (BCM_SUCCESS(rv)) {
        *enable = (fg->flags & _FP_GROUP_LOOKUP_ENABLED) ? TRUE : FALSE;
    }

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *  bcm_esw_field_group_default_entry_set
 * Purpose:
 *  Set or Clear provided entry as default to a group.
 * Parameters:
 *  unit   - (IN) BCM device number
 *  group  - (IN) Field group ID
 *  entry  - (IN) Field Entry ID
 *  enable - (IN) Enable/Disable flag
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_group_default_entry_set(int unit, bcm_field_group_t group,
                                      bcm_field_entry_t entry,
                                      int enable)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    FP_LOCK(unit);
    rv = _bcm_field_group_default_entry_set(unit, group, entry, enable);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return (rv);
}

/*
 * Function:
 *  bcm_esw_field_group_default_entry_get
 * Purpose:
 *  Get the default entry id associated to a group.
 * Parameters:
 *  unit   - (IN)  BCM device number
 *  group  - (IN)  Field group ID
 *  entry  - (OUT) Default Entry ID
 * Returns:
 *  BCM_E_XXX
 */
int
bcm_esw_field_group_default_entry_get(int unit, bcm_field_group_t group,
                                      bcm_field_entry_t *entry)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    FP_LOCK(unit);
    rv = _bcm_field_group_default_entry_get(unit, group, entry);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return (rv);
}

/* Section: Range Checking */

/*
 * Function: bcm_esw_field_range_create_id
 *    
 * Purpose:
 *     Allocate a range checker and set its parameters.
 *
 * Parameters:
 *     unit   - (IN) BCM device number.
 *     range  - (IN) Range check ID to use.
 *     flags  - (IN) One or more of BCM_FIELD_RANGE_* flags.
 *     min    - (IN) Lower bounds of range to be checked, inclusive.
 *     max    - (IN) Upper bounds of range to be checked, inclusive.
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized.
 *     BCM_E_EXISTS    - Range ID already in use.
 *     BCM_E_RESOURCE  - Hardware range checkers all in use.
 *     BCM_E_NONE      - Success.
 *     BCM_E_XXX
 */

int
bcm_esw_field_range_create_id(int unit,
                              bcm_field_range_t range,
                              uint32 flags,
                              bcm_l4_port_t min,
                              bcm_l4_port_t max)
{
    int                 rv = BCM_E_UNAVAIL; /* Operation return value. */

#if defined(BCM_FIREBOLT_SUPPORT)
    _field_stage_t      *stage_fc;      /* Stage field control info.*/
    _field_range_t      *fr;            /* Field range info.        */  
    int                 idx_max;        /* Loop termination index.  */
    int                 hw_index  = -1; /* Free/matching rang index.*/
    soc_mem_t           mem;            /* Range check memory.      */
    _field_stage_id_t   stage_id;       /* Pipeline stage id.       */
    SHR_BITDCL          *range_bmap;    /* Used indexes map.        */
    uint32              max_field_val;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: BEGIN bcm_esw_field_range_create_id(range=%d, "), 
               unit, range));
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "flags=%#08x, min=%#x, max=%#x)\n"),
               flags, min, max));
 
    /* Range type sanity check. */
    BCM_IF_ERROR_RETURN(_field_range_flags_check(unit, flags));

    if (flags & BCM_FIELD_RANGE_EXTERNAL) {
        mem = ESM_RANGE_CHECKm;
        stage_id = _BCM_FIELD_STAGE_EXTERNAL;
    } else {
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_pipe_support) && RANGE_CTRL(unit)) {
            if (RANGE_CTRL(unit)->range_used_by_module == RANGE_USED_BY_RANGE_MODULE) {
                LOG_CLI((BSL_META("Range resource is used by Range module. \n")));
                return BCM_E_UNAVAIL;
            }
            mem = IFP_RANGE_CHECKm;
        } else 
#endif
        {
            mem = FP_RANGE_CHECKm;
        }

        stage_id = _BCM_FIELD_STAGE_INGRESS;

    }

    if (!SOC_MEM_IS_VALID(unit, mem)) {
        return BCM_E_UNAVAIL;
    }

    max_field_val = (1 << soc_mem_field_length(unit, mem, LOWER_BOUNDSf)) - 1 ;

    if (min > max_field_val) {
        return (BCM_E_PARAM);
    }

    max_field_val = (1 << soc_mem_field_length(unit, mem, UPPER_BOUNDSf)) - 1 ;

    if (max > max_field_val) {
        return (BCM_E_PARAM);
    }

    idx_max = soc_mem_index_max(unit, mem);  
    range_bmap = NULL;
    _FP_XGS3_ALLOC(range_bmap, SHR_BITALLOCSIZE(idx_max + 1), "FP valid ranges");
    if (NULL == range_bmap) {
        return (BCM_E_MEMORY);
    }

    FP_LOCK(unit);

    rv = _field_stage_control_get(unit, stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        sal_free(range_bmap);
        return (rv);
    }

    if (flags & BCM_FIELD_RANGE_REPLACE) {
        rv = _bcm_field_modify_range_checker(unit, stage_id, range, flags,
                min, max);
        FP_UNLOCK(unit);
        sal_free(range_bmap);
        return (rv);
    }

    /* Search existing ranges */
    for (fr = stage_fc->ranges; fr != NULL; fr = fr->next) {
        if (fr->rid == range) {
            FP_UNLOCK(unit);
            sal_free(range_bmap);
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: range_id=%d already exists.\n"),
                       unit, range));
            return (BCM_E_EXISTS);
        }

        /* Build maps of hardware in-use indexes. */
        if (fr->style == _FP_RANGE_STYLE_FIREBOLT) {
            SHR_BITSET(range_bmap, fr->hw_index);
        }

        /* Found an exisiting match so use it. */
        if (flags == fr->flags && min == fr->min && max == fr->max) {
            hw_index = fr->hw_index;
        }
    }

    /* If no match found, allocate a new hardware index. */
    if (hw_index < 0) {
        hw_index = soc_mem_index_min(unit, mem);
        for (; hw_index <= idx_max; hw_index++) {
            /* Found an unused FB style range checker */
            if (0 == SHR_BITGET(range_bmap, hw_index)) {
                break;
            }
        }

        /* No hardware indexes left. */
        if (hw_index == (idx_max + 1)) {
            FP_UNLOCK(unit);
            sal_free(range_bmap);
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: No hardware range checkers left.\n"),
                       unit));
            return (BCM_E_RESOURCE);
        }
    }

    /* Create a new range entry for the list */
    if ((fr = sal_alloc(sizeof (*fr), "fp_range")) == NULL) {
        FP_UNLOCK(unit);
        sal_free(range_bmap);
        return (BCM_E_MEMORY);
    }

    fr->flags    = flags;
    fr->rid      = range;
    fr->min      = min;
    fr->max      = max;
    fr->hw_index = hw_index;
    fr->style    = _FP_RANGE_STYLE_FIREBOLT;

    /* Try to program hardware */
#if defined(BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit)) {
        rv = _bcm_field_trx_range_check_set(unit, hw_index, 
                                            flags, 1, min, max);
    } else 
#endif /* BCM_TRX_SUPPORT */
    {
        rv = _field_fb_er_range_check_set(unit, hw_index, flags, 1, min, max);
    }

    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        sal_free(range_bmap);
        sal_free(fr);
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: Device specific range check problem.\n"),
                   unit));
        return rv;
    }

    /* Add to list of range checkers. */

    {
        _field_range_t *p, **pp;

        /* List must be kept in acending order of hw_index -- is assumed by scache save
           and restore functions.
        */

        for (pp = &stage_fc->ranges; (p = *pp) && fr->hw_index > p->hw_index; pp = &p->next);

        (*pp = fr)->next = p;
    }

    FP_UNLOCK(unit);
    sal_free(range_bmap);

#endif /* BCM_FIREBOLT_SUPPORT */
    return (rv);
}

/*
 * Function: bcm_esw_field_range_group_create_id
 *    
 * Purpose:
 *     Allocate an interface group range checker and set its parameters.
 *
 * Parameters:
 *     unit   - (IN) BCM device number.
 *     range  - (IN) Range check ID to use.
 *     flags  - (IN) One or more of BCM_FIELD_RANGE_* flags.
 *     min    - (IN) Lower bounds of range to be checked, inclusive.
 *     max    - (IN) Upper bounds of range to be checked, inclusive.
 *     group  - (IN) L3 interface group number.
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_EXISTS    - Range ID already in use
 *     BCM_E_RESOURCE  - Hardware range checkers all in use
 *     BCM_E_PARAM     - Invalid L3 interface group number
 *     BCM_E_NONE      - Success
 *     BCM_E_XXX
 */
int
bcm_esw_field_range_group_create_id(int unit,
                                    bcm_field_range_t range,
                                    uint32 flags,
                                    bcm_l4_port_t min,
                                    bcm_l4_port_t max,
                                    bcm_if_group_t group)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function: bcm_esw_field_range_create
 *    
 * Purpose:
 *     Allocate a range checker and set its parameters.
 *
 * Parameters:
 *     unit   - BCM device number
 *     range  - (OUT) Range check ID, will not be zero
 *     flags  - One or more of BCM_FIELD_RANGE_* flags
 *     min    - Lower bounds of range to be checked, inclusive
 *     max    - Upper bounds of range to be checked, inclusive
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_NONE      - Success
 *     BCM_E_XXX
 */

int
bcm_esw_field_range_create(int unit,
                           bcm_field_range_t *range,
                           uint32 flags,
                           bcm_l4_port_t min,
                           bcm_l4_port_t max)
{
    int rv;                   /* Operation return status.       */

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb:BEGIN bcm_esw_field_range_create( range->%p"), 
               unit, range));
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "flags=%#08x, min=%#x, max=%#x)\n"),
               flags, min, max));

    

    /* Range type sanity check. */
    BCM_IF_ERROR_RETURN(_field_range_flags_check(unit, flags));

    FP_LOCK(unit);

    rv = _field_range_create(unit, range, flags, min, max, -1);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_range_group_create
 *    
 * Purpose:
 *     Allocate a range checker and set its parameters.
 *
 * Parameters:
 *     unit   - BCM device number
 *     range  - (OUT) Range check ID, will not be zero
 *     flags  - One or more of BCM_FIELD_RANGE_* flags
 *     min    - Lower bounds of range to be checked, inclusive
 *     max    - Upper bounds of range to be checked, inclusive
 *     group  - L3 interface group number
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_PARAM     - Invalid L3 interface group number
 *     BCM_E_NONE      - Success
 *     BCM_E_XXX
 */

int
bcm_esw_field_range_group_create(int unit,
                                 bcm_field_range_t *range,
                                 uint32 flags,
                                 bcm_l4_port_t min,
                                 bcm_l4_port_t max,
                                 bcm_if_group_t group)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function: bcm_esw_field_range_get
 *    
 * Purpose:
 *     Get the TCP/UDP port for a range
 *
 * Parameters:
 *     unit  - (IN)  BCM device number.
 *     range - (IN)  Range check ID.
 *     flags - (OUT) Current range checker flags
 *     min   - (OUT) Lower bounds of range to be checked
 *     max   - (OUT) Upper bounds of range to be checked
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_NOT_FOUND - Invalid range ID
 *     BCM_E_NONE      - Success
 *     BCM_E_XXX
 */

int
bcm_esw_field_range_get(int unit,
                        bcm_field_range_t range,
                        uint32 *flags,
                        bcm_l4_port_t *min,
                        bcm_l4_port_t *max)
{
    _field_stage_t      *stage_fc; /* Stage FP control info.   */
    _field_range_t      *fr;       /* Field range info.        */   
    int                 rv;        /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    for (fr = stage_fc->ranges; fr != NULL; fr = fr->next) {
        if (fr->rid == range) {
            break;
        }
    }

    if (fr == NULL) {
        /* Check if it is present in the External */
        rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_EXTERNAL, 
                                      &stage_fc);
        if (rv != BCM_E_NONE) {
            FP_UNLOCK(unit);
            return (BCM_E_NOT_FOUND);
        }
        for (fr = stage_fc->ranges; fr != NULL; fr = fr->next) {
            if (fr->rid == range) {
                break;
            }
        }
        if (fr == NULL) {
            FP_UNLOCK(unit);
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: range=%d not found.\n"),
                       unit, range));
            return (BCM_E_NOT_FOUND);
        }
    }

    if (flags != NULL) {
        *flags = fr->flags;
    }

    if (min != NULL) {
        *min = fr->min;
    }

    if (max != NULL) {
        *max = fr->max;
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function: bcm_esw_field_range_destroy
 *
 * Purpose:
 *     Deallocate a range
 *
 * Parameters:
 *     unit  - BCM device number
 *     range  - Range check ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_NOT_FOUND - Invalid range ID
 *     BCM_E_NONE      - Success
 *     BCM_E_XXX
 */

int
bcm_esw_field_range_destroy(int unit,
                            bcm_field_range_t range)
{
    _field_stage_t      *stage_fc;
    _field_range_t      *fr, *fr2, *fr_prev; 
    int                 use_count;
    int                 rv;

    
    FP_LOCK(unit);

#if defined (BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)
         && RANGE_CTRL(unit) &&
         (RANGE_CTRL(unit)->range_used_by_module ==
          RANGE_USED_BY_RANGE_MODULE)) {
        LOG_CLI((BSL_META("Range resource is used by Range module. \n")));
        FP_UNLOCK(unit);
        return BCM_E_UNAVAIL;
    }
#endif

    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS,  &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Find matching entry */
    fr_prev = NULL;
    for (fr = stage_fc->ranges; fr != NULL; fr = fr->next) {
        if (fr->rid == range) {
            break;
        }
        fr_prev = fr;
    }

    if (fr == NULL) {
        /* Check if it is present in the External */
        rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_EXTERNAL, 
                                      &stage_fc);
        if (rv != BCM_E_NONE) {
            FP_UNLOCK(unit);
            return (BCM_E_NOT_FOUND);
        }
        fr_prev = NULL;
        for (fr = stage_fc->ranges; fr != NULL; fr = fr->next) {
            if (fr->rid == range) {
                break;
            }
            fr_prev = fr;
        }
        if (fr == NULL) {
            FP_UNLOCK(unit);
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: range=%d not found in.\n"),
                       unit, range));
            return (BCM_E_NOT_FOUND);
        }
    }

    {
        /* See how many entries are using the same hardware index */
        use_count = 0;

        for (fr2 = stage_fc->ranges; fr2 != NULL; fr2 = fr2->next) {
            if (fr2->hw_index == fr->hw_index && fr->style == fr2->style) {
                use_count++;
            }
        }

        /* Clear from hardware if this is the only use */
        assert(use_count > 0);

        if (use_count == 1) {
            rv = BCM_E_UNAVAIL;

#if defined(BCM_TRX_SUPPORT)
            if (SOC_IS_TRX(unit)) {
                rv = _bcm_field_trx_range_check_set(unit, fr->hw_index,
                                                    (fr->flags & BCM_FIELD_RANGE_EXTERNAL),
                                                    0, 0, 0);
            } else 
#endif /* BCM_TRX_SUPPORT */
#if defined(BCM_FIREBOLT_SUPPORT)
                if (SOC_IS_FBX(unit)) {
                    rv = _field_fb_er_range_check_set(unit, fr->hw_index, 
                                                      0, 0, 0, 0);
                }
#endif /* BCM_FIREBOLT_SUPPORT */

            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return rv;
            }
        }
    }

    /* Remove from list and free */
    if (fr_prev == NULL) {
        stage_fc->ranges = fr->next;
    } else {
        fr_prev->next = fr->next;
    }

    FP_UNLOCK(unit);
    sal_free(fr);
    return (BCM_E_NONE);
}

/*
 * Section: Field Entries
 */

/*
 * Function: bcm_esw_field_entry_create
 *
 * Purpose:
 *     Create a blank entry based on a group. Automatically generate an entry
 *     ID.
 *
 * Parameters:
 *     unit  - BCM device number
 *     group - Field group ID
 *     entry - (OUT) New entry
 *
 * Returns:
 *     BCM_E_INIT        BCM unit not initialized
 *     BCM_E_NOT_FOUND   group not found in unit
 *     BCM_E_PARAM       *entry was NULL
 *     BCM_E_RESOURCE    No unused entries available
 *     BCM_E_XXX         Error from bcm_field_entry_create_id
 *
 * See Also:
 * bcm_field_entry_create_id
 */

int
bcm_esw_field_entry_create(int unit, bcm_field_group_t group,
                           bcm_field_entry_t *entry)
{
    _field_control_t    *fc;           /* Field control structure.    */
    _field_group_t      *fg;           /* Field group structure.      */
    _field_entry_t      *f_ent;        /* Field entry pointer.        */ 
    int                 rv;            /* Operation return status.    */

    if (entry == NULL) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: entry == NULL.\n"),
                   unit));
        return (BCM_E_PARAM);
    }
    
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* When MaxGroupSizeHardLimit is set and limit is reached
     * return BCM_E_FULL */
    if (fg->flags & _FP_GROUP_MAX_SIZE_HARD_LIMIT) {
        if (fg->max_group_size -
                (fg->group_status.entry_count) <= 0) {
            FP_UNLOCK(unit);
            return BCM_E_FULL;
        }
    }

    /* Generate an entry ID.  */
    fc->last_allocated_eid++;
    while (BCM_SUCCESS(_field_entry_get(unit, fc->last_allocated_eid, 
                                        _FP_ENTRY_PRIMARY, &f_ent))) {
        fc->last_allocated_eid++;
        if (_FP_ID_MAX == fc->last_allocated_eid) {
            fc->last_allocated_eid = _FP_ID_BASE;
        }
    }

    *entry = fc->last_allocated_eid;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
       (fg->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        rv = _bcm_field_th_class_entry_create(unit, group, *entry);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    rv = _field_entry_create_id(unit, group, *entry);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_entry_create_id
 *
 * Purpose:
 *     Create a blank entry group based on a group;
 *     allows selection of a specific slot in a slice
 *
 * Parameters:
 *     unit -  (IN) BCM device number.
 *     group - (IN) Field group ID.
 *     entry - (IN) Requested entry ID; must be in the range prio_min through
 *             prio_max as returned by bcm_field_group_status_get().
 * Returns:
 *     BCM_E_INIT      - unit not initialized
 *     BCM_E_EXISTS    - Entry ID already in use
 *     BCM_E_NOT_FOUND - Group ID not found in unit
 *     BCM_E_MEMORY    - allocation failure
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_entry_create_id(int unit,
                              bcm_field_group_t group,
                              bcm_field_entry_t entry)
{
    int                 rv;

     /* Check if Entry ID is not internal reserved ID */

    /* coverity[result_independent_of_operands : FALSE] */
    if ((entry >= (_FP_INTERNAL_RESERVED_ID_MIN))
       && (entry <= _FP_INTERNAL_RESERVED_ID_MAX)) {
       LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                  "FP(unit %d) Error: This Entry ID is reserved"
                  " for internal use\n"),
                  unit));
        return (BCM_E_PARAM);
    }


    FP_LOCK(unit);

    rv = _bcm_field_entry_create_id(unit, group, entry);

    FP_UNLOCK(unit);

    return (rv);
}

/*
 * Function: bcm_esw_field_entry_multi_get
 *
 * Purpose:
 *     Gets an array of a group's entry IDs
 *
 * Parameters:
 *     unit -  (IN) BCM device number.
 *     group - (IN) Field group ID.
 *     entry_size - (IN) Maximum number of entries to return.  Set to 0
 *                       to get the number of entries available
 *     entry_array - (OUT) Pointer to a buffer to fill with the array of
 *                         entry IDs.  Ignored if entry_size is 0
 *     entry_count - (OUT) Returns the number of entries returned in the
 *                         array, or if entry_size was 0, the number of
 *                         entries available

 * Returns:
 *     BCM_E_INIT      - unit not initialized
 *     BCM_E_NOT_FOUND - Group ID not found in unit
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_entry_multi_get(int unit, bcm_field_group_t group,
    int entry_size, bcm_field_entry_t *entry_array, int *entry_count)
{
        int entry_index;
    _field_group_t *fg_p;
    int rv;

    FP_LOCK(unit);

    rv = _field_group_get(unit, group, &fg_p);

    if (BCM_SUCCESS(rv))
    {
        if (entry_count == NULL) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: entry_count == NULL.\n"),
                       unit));
            FP_UNLOCK(unit); 
            return (BCM_E_PARAM);
        }

        if (entry_size == 0)
        {
            *entry_count = fg_p->group_status.entry_count;
        }
        else
        {
            if (entry_array == NULL) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "FP(unit %d) Error: entry_array == NULL.\n"),
                           unit));
                FP_UNLOCK(unit); 
                return (BCM_E_PARAM);
            }
            if (entry_size > fg_p->group_status.entry_count)
            {
                entry_size = fg_p->group_status.entry_count;
            }

            for (entry_index = 0;
                entry_index < entry_size; ++entry_index)
            {
                *entry_array = (fg_p->entry_arr[entry_index])->eid;

                ++entry_array;
            }

            *entry_count = entry_size;
        }
    }

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_entry_destroy
 *
 * Purpose:
 *     Deallocate the memory used to track an entry. This does not remove the
 *     entry from hardware if it has been installed. In order to remove an
 *     entry from hardware, call bcm_field_entry_remove() prior to calling this
 *     API.
 *
 * Parameters:
 *     unit  - BCM device number
 *     entry - Entry ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_NOT_FOUND - Entry ID not found
 *     BCM_E_XXX       - From bcm_field_counter_destroy() or
 *                       bcm_field_meter_destroy()
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_entry_destroy(int unit, bcm_field_entry_t entry)
{
        _field_entry_t      *f_ent;
        _field_control_t    *fc; 
        _field_stage_t      *stage_fc;      /* Stage field control structure. */
        _field_group_t      *fg;         /* Field group structure.          */
        int                 rv;

        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }

        rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
        if (BCM_FAILURE(rv)) {
           FP_UNLOCK(unit);
           return (rv);
        }

        /* Cleanup the entry if the entry has backed up earlier */
        if (NULL != f_ent->ent_copy) {
            rv = _bcm_field_entry_cleanup(unit, entry);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }
        }

#if defined(BCM_TOMAHAWK_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
                (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
            rv = _bcm_field_th_class_entry_destroy(unit, f_ent);
            FP_UNLOCK(unit);
            return (rv);
        }
#endif /* BCM_TOMAHAWK_SUPPORT */

    fg = f_ent->group;
    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Remove entry from hw before destroying sw image. */
    if (f_ent->flags & _FP_ENTRY_INSTALLED) {
        rv = bcm_esw_field_entry_remove(unit, entry);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return(rv);
        }
    }

#ifdef BCM_FIREBOLT6_SUPPORT
    if (soc_feature(unit, soc_feature_field_aacl_compression)) {
        if (f_ent->group->flags & _FP_GROUP_COMPRESSED) {
            BCM_IF_ERROR_RETURN(_bcm_field_fb6_compress_entry_destroy(unit, f_ent));
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return(rv);
            }
        }
    }
#endif

    /* Destroy entry policers */
    rv = bcm_esw_field_entry_policer_detach_all(unit, entry);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return(rv);
    }

    /* Destroy entry stats */
    if (f_ent->statistic.flags & _FP_ENTRY_STAT_VALID) {
        rv = fc->functions.fp_entry_stat_detach(unit,
                             f_ent, f_ent->statistic.sid);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return(rv);
        }
    }

#if defined BCM_TRIDENT2PLUS_SUPPORT
    if (SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit)) {
        if (f_ent->statistic.flags & _FP_ENTRY_EXTENDED_STAT_VALID) {
            rv = fc->functions.fp_entry_stat_detach(unit,
                    f_ent, f_ent->statistic.extended_sid);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return(rv);
            }
        }
    }
#endif

    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit)) {
            /* Clear EntryId from _entry_egr_ports_recovery database*/
            _bcm_trx_field_egr_ports_recovery_entry_remove (unit, entry);
        }
#endif
    }

        /* Destroy entry sw images. */
    rv = _field_entry_phys_destroy(unit, f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return(rv);
    }
    f_ent = NULL;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id) ||
         (_BCM_FIELD_STAGE_EXACTMATCH == stage_fc->stage_id) ||
         (_BCM_FIELD_STAGE_FLOWTRACKER == stage_fc->stage_id))) {
       rv = _bcm_field_th_group_free_unused_slices(unit, stage_fc, fg);
    } else 
#endif /* BCM_TOMAHAWK_SUPPORT */
    { 
       rv = _field_group_free_unused_slices(unit, stage_fc, fg);
    }
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return(rv);
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    SOC_CONTROL_LOCK(unit);
    SOC_CONTROL(unit)->scache_dirty = 1;
    SOC_CONTROL_UNLOCK(unit);
#endif

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function: bcm_esw_field_entry_destroy_all
 *
 * Purpose:
 *     Destroy all entries on a unit. It iterates over all slices in a unit.
 *     For each slice, If entries exist, it calls bcm_field_entry_destroy()
 *     using the Entry ID.
 *
 * Parameters:
 *     unit - (IN) BCM device number.
 *
 * Returns:
 *     BCM_E_XXX       - Error from bcm_field_entry_destroy().
 *     BCM_E_INIT      - BCM unit not initialized.
 *     BCM_E_NONE      - Success.
 */
int
bcm_esw_field_entry_destroy_all(int unit)
{
    _field_control_t    *fc;         /* Field control structure. */
    _field_group_t      *fg;         /* Field group info.        */
    _field_stage_t      *stage_fc;   /* Stage field control info.*/
    int                 rv;          /* Operation return status. */

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: bcm_field_entry_destroy_all()\n"),
               unit));
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    fg = fc->groups;
    if (NULL == fg) {
        FP_UNLOCK(unit);
        return (BCM_E_NONE);
    }  

    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Scan unit's groups freeing each entry list. */
    for (; fg != NULL; fg = fg->next) {
        /* EM COS SW WAR for TH3 */
#if defined(BCM_TOMAHAWK3_SUPPORT)
        if((soc_feature(unit, soc_feature_sw_mmu_flush_rqe_operation)) &&
           (!(SOC_WARM_BOOT(unit)))) {
            if (fg->gid == _FP_INTERNAL_RESERVED_EM_ID) {
                continue;
            }
        }
#endif /* BCM_TOMAHAWK3_SUPPORT */
        /* Destroy all entries in the group. */
        while(fg->group_status.entry_count) {
            rv =  bcm_esw_field_entry_destroy(unit, (fg->entry_arr[0])->eid);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }
        }
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function: _bcm_field_entry_copy
 *
 * Purpose:
 *     Create a copy of an existing entry. The new entry will be a member of
 *     the same group as the source entry.
 *
 * Parameters:
 *     unit      - BCM device number
 *     src_entry - Entry to copy
 *     dst_entry - (OUT) New entry
 *     flags     - Flags to control entry copy
 *
 * Returns:
 *     BCM_E_INIT        BCM Unit not initialized
 *     BCM_E_NOT_FOUND   Source entry not found
 *     BCM_E_INTERNAL    No group exists for source entry ID.
 *     BCM_E_PARAM       dst_entry pointing to NULL
 *     BCM_E_RESOURCE    No destination entry available
 *     BCM_E_XXX         Error from bcm_field_entry_copy_id()
 */
int
_bcm_field_entry_copy(int unit,
                      bcm_field_entry_t src_entry,
                      bcm_field_entry_t *dst_entry,
                      uint32 flags)
{
    _field_entry_t      *f_ent_src;
    _field_entry_t      *f_ent;
    int                 rv;

    if (dst_entry == NULL) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: dst_entry == NULL\n"),
                   unit));
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_entry_get(unit, src_entry, _FP_ENTRY_PRIMARY, &f_ent_src);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Generate a destination Entry ID.  */
    *dst_entry = src_entry + 1;
    while (BCM_SUCCESS
           (_field_entry_get(unit, *dst_entry, _FP_ENTRY_PRIMARY, &f_ent))) {
        *dst_entry += 1;
        if (_FP_ID_MAX == *dst_entry) {
            *dst_entry = _FP_ID_BASE;
        }

    }

    /* Check if Entry ID is not internal reserved ID */

    /* coverity[result_independent_of_operands : FALSE] */
    if ((*dst_entry >= (_FP_INTERNAL_RESERVED_ID_MIN))
       && (*dst_entry <= _FP_INTERNAL_RESERVED_ID_MAX)) {
       LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                  "FP(unit %d) Error: This Entry ID is reserved"
                  " for internal use\n"),
                  unit));
        FP_UNLOCK(unit);
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_copy_id(unit, src_entry, *dst_entry, flags);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_entry_copy
 *
 * Purpose:
 *     Create a copy of an existing entry. The new entry will be a member of
 *     the same group as the source entry.
 *
 * Parameters:
 *     unit      - BCM device number
 *     src_entry - Entry to copy
 *     dst_entry - (OUT) New entry
 *     flags     - flags to control entry copy
 *                 0 : stats(if attached)will be copied
 *                 BCM_FIELD_ENTRY_COPY_WITHOUT_STATS : Stats are not copied
 * Returns:
 *     BCM_E_INIT        BCM Unit not initialized
 *     BCM_E_NOT_FOUND   Source entry not found
 *     BCM_E_INTERNAL    No group exists for source entry ID.
 *     BCM_E_PARAM       dst_entry pointing to NULL
 *     BCM_E_RESOURCE    No destination entry available
 *     BCM_E_XXX         Error from bcm_field_entry_copy_id()
 */
int
bcm_esw_field_entry_config_copy(int unit,
                         bcm_field_entry_t src_entry,
                         bcm_field_entry_t *dst_entry,
                         uint32 flags)
{
    return _bcm_field_entry_copy(unit,src_entry, dst_entry, flags);
}
/*
 * Function: bcm_esw_field_entry_copy
 *
 * Purpose:
 *     Create a copy of an existing entry. The new entry will be a member of
 *     the same group as the source entry.
 *
 * Parameters:
 *     unit      - BCM device number
 *     src_entry - Entry to copy
 *     dst_entry - (OUT) New entry
 *
 * Returns:
 *     BCM_E_INIT        BCM Unit not initialized
 *     BCM_E_NOT_FOUND   Source entry not found
 *     BCM_E_INTERNAL    No group exists for source entry ID.
 *     BCM_E_PARAM       dst_entry pointing to NULL
 *     BCM_E_RESOURCE    No destination entry available
 *     BCM_E_XXX         Error from bcm_field_entry_copy_id()
 */
int
bcm_esw_field_entry_copy(int unit,
                         bcm_field_entry_t src_entry,
                         bcm_field_entry_t *dst_entry)
{
    return _bcm_field_entry_copy(unit,src_entry, dst_entry, 0);
}

/*
 * Function: bcm_esw_field_entry_copy_id
 *
 * Purpose:
 *     Create a copy of an existing entry with a requested ID
 *
 * Parameters:
 *     unit      - BCM device number
 *     src_entry - Source entry to copy
 *     dst_entry - Destination entry for copy
 *
 * Returns:
 *     BCM_E_INIT      - BCM Unit not initialized
 *     BCM_E_NOT_FOUND - Source Entry ID not found
 *     BCM_E_XXX       - Error code from bcm_field_entry_create_id()
 *     BCM_E_NONE      - Success
 */

int
bcm_esw_field_entry_copy_id(int unit,
                            bcm_field_entry_t src_entry,
                            bcm_field_entry_t dst_entry)
{
    int                 rv;

    /* Check if Entry ID is not internal reserved ID */

    /* coverity[result_independent_of_operands : FALSE] */
    if ((dst_entry >= (_FP_INTERNAL_RESERVED_ID_MIN))
       && (dst_entry <= _FP_INTERNAL_RESERVED_ID_MAX)) {
       LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                  "FP(unit %d) Error: This Entry ID is reserved"
                  " for internal use\n"),
                  unit));
        return (BCM_E_PARAM);
    }
    /* flags 0 is passed s that stats (if any attached) are copied */
    rv = _bcm_field_entry_copy_id(unit, src_entry, dst_entry, 0);
    return rv;
}

/*
 * Function: bcm_esw_field_entry_install
 *
 * Purpose:
 *     Install a entry into the hardware tables.
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - Entry to install
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_NOT_FOUND - Entry ID not found on unit.
 *     BCM_E_XXX       - Error from _field_XX_tcam_policy_install()
 *     BCM_E_NONE      - Success
 *
 * Notes:
 *     Qualifications should be made and actions should be added
 *     prior to installing the entry.
 */
int
bcm_esw_field_entry_install(int unit, bcm_field_entry_t entry)
{
    return bcm_esw_field_entry_reinstall(unit, entry);
}

/*
 * Function:
 *
 * Purpose:
 *     Re-install a entry into the hardware tables.
 *
 * Parameters:
 *     unit  - (IN) BCM device number
 *     entry - (IN) Entry to install
 *
 * Returns:
 *     BCM_E_XXX   
 */
int
bcm_esw_field_entry_reinstall(int unit, bcm_field_entry_t entry)
{
    _field_entry_t      *f_ent; /* Field entry structure.   */
    int                 rv;     /* Operation return status. */
    int                 dirty = 0;  /* Field entry dirty flag.  */
    int                 action_dirty = 0;  /* Field entry action dirty flag. */

    
    FP_LOCK(unit);

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

#ifdef BCM_FIREBOLT6_SUPPORT
    if (soc_feature(unit, soc_feature_field_aacl_compression)) {
        if (f_ent->group->flags & _FP_GROUP_COMPRESSED) {
            rv = _bcm_field_fb6_compress_entry_install(unit, f_ent);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }
        }
    }
#endif

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        rv = _bcm_field_th_class_entry_install(unit, entry);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check if only action has been modifed for this entry. */
    rv = _field_entry_action_dirty(unit, f_ent, &action_dirty);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Check if any parameter has been modified for this entry. */
    rv = _field_entry_dirty(unit, f_ent, &dirty);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH)) {
        /* entry is dirty or action is dirty 
         * exact match should call install function always.
         */
        if (action_dirty || dirty) {
            dirty = TRUE;
            action_dirty = FALSE;
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    if (action_dirty) {
         /* Write Policy table for this entry. */
         rv = _field_tcam_policy_reinstall(unit, entry);
    } else if (dirty) {
        /* Write TCAM and Policy table for this entry.*/
        rv = _field_tcam_policy_install(unit, entry);
    } else {
        rv = BCM_E_NONE;
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    SOC_CONTROL_LOCK(unit);
    SOC_CONTROL(unit)->scache_dirty = 1;
    SOC_CONTROL_UNLOCK(unit);
#endif
    /* This is to cleanup the meter entry setthat were to be released that
     * are being moved to backup(old) state by calling bcm_policer_set api
     */
    if ( f_ent->flags & _FP_ENTRY_METER_MODIFIED) {
      rv = _field_policers_hw_free_old(unit, f_ent);
    }

    FP_UNLOCK(unit);
    return rv;
}


/*
 * Function: bcm_esw_field_entry_remove
 *
 * Purpose:
 *     Remove an entry from the hardware tables.
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - Entry to remove
 *
 * Returns:
 *     BCM_E_XXX
 *
 * Notes:
 *     This does not destroy the entry; it only uninstalls it from
 *     any hardware tables. To deallocate the memory used by the entry call
 *     bcm_field_entry_destroy.
 */
int
bcm_esw_field_entry_remove(int unit, bcm_field_entry_t entry)
{
    _field_control_t    *fc;         /* Field control structure. */
    int                 rv;          /* Operation return status. */

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv =  _field_entry_remove(unit, fc, entry);

#ifdef BCM_WARM_BOOT_SUPPORT
    SOC_CONTROL_LOCK(unit);
    SOC_CONTROL(unit)->scache_dirty = 1;
    SOC_CONTROL_UNLOCK(unit);
#endif

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_group_install
 *
 * Purpose:
 *     Install all of a group's entries into the hardware tables.
 *
 * Parameters:
 *     unit - BCM device number
 *     group - Group to install
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_NOT_FOUND - Group ID not found on unit.
 *     BCM_E_XXX       - Error from bcm_esw_field_entry_install()
 *     BCM_E_NONE      - Success
 */

int
bcm_esw_field_group_install(int unit, bcm_field_group_t group)
{
    _field_group_t *fg_p;
    int entry_index;
    int rv;

    
    FP_LOCK(unit);

    rv = _field_group_get(unit, group, &fg_p);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (fg_p->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    for (entry_index = 0;
        entry_index < fg_p->group_status.entry_count;
        ++entry_index)
    {
	rv = bcm_esw_field_entry_install(unit,
		fg_p->entry_arr[entry_index]->eid);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    FP_UNLOCK(unit);

    return BCM_E_NONE;
}

/*
 * Function: bcm_esw_field_group_remove
 *
 * Purpose:
 *     Remove all of a group's entries from the hardware tables.
 *
 * Parameters:
 *     unit - BCM device number
 *     group - Group to install
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_NOT_FOUND - Group ID not found on unit.
 *     BCM_E_XXX       - Error from _field_entry_remove()
 *     BCM_E_NONE      - Success
 */

int
bcm_esw_field_group_remove(int unit, bcm_field_group_t group)
{
    _field_control_t *fc;
    _field_group_t *fg_p;
    int entry_index;
        int rv = BCM_E_NONE;

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _field_group_get(unit, group, &fg_p);
    if (BCM_FAILURE(rv))
    {
        FP_UNLOCK(unit);
        return (rv);
    }

    for (entry_index = 0;
        entry_index < fg_p->group_status.entry_count;
        ++entry_index)
    {
        rv = _field_entry_remove(unit, fc,
                        fg_p->entry_arr[entry_index]->eid);
        if (BCM_FAILURE(rv))
        {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    FP_UNLOCK(unit);

    return (rv);
}

/*
 * Function: bcm_esw_field_entry_prio_get
 *
 * Purpose:
 *     Gets the priority within the group of the entry.
 *
 * Parameters:
 *     unit   - BCM device number
 *     entry  - Field entry to operate on
 *     prio   - (OUT) priority of entry
 *
 * Returns:
 *     BCM_E_NONE       - Success
 *     BCM_E_PARAM      - prio pointing to NULL
 *     BCM_E_NOT_FOUND  - Entry ID not found on unit
 */
int
bcm_esw_field_entry_prio_get(int unit, bcm_field_entry_t entry, int *prio)
{
    _field_entry_t      *f_ent;
    int                 rv;          /* Operation return status. */

    if (prio == NULL) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: prio==NULL\n"),
                   unit));
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) && 
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
        rv = _bcm_field_presel_entry_prio_get(unit, entry, prio);
        FP_UNLOCK(unit);
        return rv;
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* Priority cannot be fetched for exact match entries. */
    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
        rv = BCM_E_UNAVAIL;
        FP_UNLOCK(unit);
        return (rv);
    }
    /* Priority get for class entries. */
    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS) {
        rv = _bcm_field_th_class_entry_prio_get(unit, f_ent);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    *prio = f_ent->prio;

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_entry_prio_set
 *
 * Purpose:
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - Field entry to operate on
 *
 * Returns:
 *     BCM_E_NONE       Success
 *
 * Notes: 
 *     The earlier checks guarantee that there is a free slot somewhere
 *     i.e. in one of the alloted slices for the group.
 */
int
bcm_esw_field_entry_prio_set(int unit, bcm_field_entry_t entry, int prio)
{
    int rv;

    if (prio < BCM_FIELD_ENTRY_PRIO_LOWEST) {
        return BCM_E_PARAM;
    }

    
    FP_LOCK(unit);

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) && 
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
        rv = _bcm_field_presel_entry_prio_set(unit, entry, prio);
        FP_UNLOCK(unit);
        return rv;
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    rv = _field_entry_prio_set(unit, entry, prio);

    FP_UNLOCK(unit);
    return (rv);
}
/* Section: Field Qualifiers  */

/*
 * Function: bcm_esw_field_qualify_clear
 *
 * Purpose:
 *     Reset all field qualifications from a filter entry.
 *     Memory is allocated for the entry TCAM Key and Mask.
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - Field entry to operate on
 *
 * Returns:
 *     BCM_E_INIT       BCM Unit not initialized.
 *     BCM_E_NOT_FOUND  Entry ID not found in unit.
 *     BCM_E_NONE       Success
 */
int
bcm_esw_field_qualify_clear(int unit,
                            bcm_field_entry_t entry)
{
    int               parts_count = 0;  /* Tcam entry parts count. */
    _field_entry_t    *f_ent;       /* Field entry pointer.    */
    _field_group_t    *fg;          /* Field group pointer.    */
    int               idx;          /* Entry parts iterator.   */
    int               rv;           /* Operation return status.*/

    
    FP_LOCK(unit);

    rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    fg = f_ent->group;
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (fg->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        rv = _bcm_field_th_class_qualify_clear(unit, entry);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Get number of entry parts we have to read. */
    rv = _bcm_field_entry_tcam_parts_count (unit, fg->stage_id,
                                            fg->flags, &parts_count);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv); 
    }

    for (idx = 0; idx < parts_count; idx++) {
        /* Free allocated portion of sw tcam image. */
        _bcm_field_qual_tcam_key_mask_free(unit, f_ent + idx);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

        /* Reset sw tcam image. */
        sal_memset(&f_ent[idx].tcam, 0, sizeof(_field_tcam_t));

        /* Get tcam key and mask. */
        rv = _bcm_field_qual_tcam_key_mask_get(unit, f_ent + idx);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv); 
        }

        /* Reset tcam key and mask. */
        sal_memset(f_ent[idx].tcam.key, 0, f_ent[idx].tcam.key_size);
        sal_memset(f_ent[idx].tcam.mask, 0, f_ent[idx].tcam.key_size);

        if ((fg->stage_id == _BCM_FIELD_STAGE_INGRESS) && 
            SOC_MEM_FIELD_VALID(unit, FP_TCAMm, F4f)) {
            f_ent[idx].tcam.f4 = 0;
            f_ent[idx].tcam.f4_mask = 0;
        }

        if (f_ent[idx].extra_tcam.key != NULL)
        {
            sal_memset(f_ent[idx].extra_tcam.key, 0,
                f_ent[idx].extra_tcam.key_size);

            sal_memset(f_ent[idx].extra_tcam.mask, 0,
                f_ent[idx].extra_tcam.key_size);
        }

        if (f_ent[idx].key_match_tcam.key != NULL)
        {
            sal_memset(f_ent[idx].key_match_tcam.key, 0,
                f_ent[idx].key_match_tcam.key_size);

            sal_memset(f_ent[idx].key_match_tcam.mask, 0,
                f_ent[idx].key_match_tcam.key_size);
        }

        f_ent[idx].efp_key_match_type = _FP_ENTRY_TYPE_1; 

        /* Reset IPBM if aplicable */
#if defined(BCM_RAPTOR_SUPPORT) || defined (BCM_TRX_SUPPORT)
        if ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) && 
            ((soc_feature(unit, soc_feature_field_ingress_ipbm))
              || (soc_feature(unit, soc_feature_field_multi_pipe_support)))) {
            BCM_PBMP_CLEAR(f_ent[idx].pbmp.data);
            BCM_PBMP_CLEAR(f_ent[idx].pbmp.mask);
        }
#endif

        /* Initialize entry qualifiers based on group flags. */
        rv = _field_entry_qualifiers_init(unit, f_ent);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv); 
        }

        /* Mark entry for reinstall. */
        f_ent[idx].flags &= ~_FP_ENTRY_QUAL_PORT_TYPE_TRUNK;
        f_ent[idx].flags |= _FP_ENTRY_DIRTY;
        if (f_ent[idx].flags & _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY) {
            /* resetting POLICY_TABLE_DIRTY flag
               as it needs change in FP_TCAM and install*/
            f_ent[idx].flags &= ~_FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
        }
    }
    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualifier_delete
 * Purpose:
 *      Remove match criteria from a field processor entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      qual_id - (IN) BCM field qualifier id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *   The assumption is that all qualifiers are less then 128 bit.
 */
int 
bcm_esw_field_qualifier_delete(int unit, bcm_field_entry_t entry, 
                               bcm_field_qualify_t qual_id)
{
    _bcm_field_qual_offset_t *q_offset;/* Qualifier offset in tcam. */
    _bcm_field_qual_data_t    q_data;  /* Qualifier match data.     */ 
    _bcm_field_qual_data_t    q_mask;  /* Qualifier match mask.     */
    _field_entry_t            *f_ent;  /* Field entry structure.    */
    int                       rv;      /* Operation return status.  */

    sal_memset(q_data, 0, sizeof(_bcm_field_qual_data_t));
    sal_memset(q_mask, 0, sizeof(_bcm_field_qual_data_t));

    
    FP_LOCK(unit);

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);

        if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
           /* Error fetching entry */
           FP_UNLOCK(unit);
           return (rv);
        }

        if (rv == BCM_E_NONE) { /*Stage is Ingress or ExactMatch*/
           rv = _bcm_field_th_qualifier_delete(unit, entry, qual_id);
           FP_UNLOCK(unit);
           return (rv);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual_id, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (_BCM_FIELD_STAGE_CLASS == f_ent->group->stage_id)) {
        rv = _bcm_field_th_class_qualify_set(unit, entry, qual_id,
                                                q_data, q_mask);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    switch(qual_id) {
#if defined(BCM_RAPTOR_SUPPORT) || defined(BCM_TRX_SUPPORT)
        case bcmFieldQualifyInPort:
        case bcmFieldQualifyInPorts:
            BCM_PBMP_CLEAR(f_ent->pbmp.data);
            BCM_PBMP_CLEAR(f_ent->pbmp.mask);
            break;
#endif /* BCM_RAPTOR_SUPPORT || BCM_TRX_SUPPORT */
#if defined(BCM_FIREBOLT2_SUPPORT)
        case bcmFieldQualifyDrop:
            f_ent->tcam.drop      = 0;
            f_ent->tcam.drop_mask = 0;
            break;
#endif /* BCM_FIREBOLT2_SUPPORT */
        case bcmFieldQualifyHiGig:
            f_ent->tcam.higig      = 0;
            f_ent->tcam.higig_mask = 0;
            break;
        case bcmFieldQualifyIpType:
            f_ent->tcam.ip_type = bcmFieldIpTypeAny;
            break;
        default:
            break;
    }

    /* Get entry qualifier offset in tcam. */
    rv = _field_qual_offset_get(unit, f_ent, qual_id, &q_offset);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Reset qualifier data and mask in the tcam. */
    rv = _bcm_field_qual_value_set(unit, q_offset, f_ent, 
                                   q_data, q_mask);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }
#if defined(BCM_TRIDENT_SUPPORT)
    if (SOC_IS_TD_TT(unit) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS)) {

        uint8 idx;
        for (idx = 1; idx < _FP_MAX_ENTRY_TYPES; idx++) {
            /* Get entry qualifier offset in tcam. */
            rv = _field_qual_offset_get_by_entry_type(unit, f_ent,
                                                 qual_id, idx, &q_offset);
            if (BCM_FAILURE(rv) && (rv != BCM_E_NOT_FOUND)) {
                FP_UNLOCK(unit);
                return (rv);
            } else if(BCM_SUCCESS(rv)) {

                /* Reset qualifier data and mask in the tcam. */
                /* COVERITY 
                 * 
                 *This flow takes care of the  Out-of-bounds access issue  
                 * for data and mask.
                 */
                /* coverity[callee_ptr_arith : FALSE] */
                rv = _bcm_field_qual_value_set_by_entry_type(unit,
                                                             q_offset,
                                                             f_ent,
                                                             q_data,
                                                             q_mask,
                                                             idx);
                if (BCM_FAILURE(rv)) {
                    FP_UNLOCK(unit);
                    return (rv);
                } 
            } else {
                rv = BCM_E_NONE;     
            } 
        }

        /* When qualifier is deleted from the field entry */
        if (_FP_ENTRY_TYPE_0 == f_ent->efp_key_match_type) {
            rv = _field_efp_key_match_type_set_on_qual_delete(unit, entry);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }
        }   
    }
#endif

#if defined(BCM_TRIUMPH2_SUPPORT)
    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) {
       int ingress_entity = 0;

       switch (qual_id) {
           case bcmFieldQualifySrcMplsGport:
           case bcmFieldQualifySrcMplsGports:
           case bcmFieldQualifySrcNivGport:
           case bcmFieldQualifySrcNivGports:
           case bcmFieldQualifySrcMimGport:
           case bcmFieldQualifySrcMimGports:
           case bcmFieldQualifySrcWlanGport:
           case bcmFieldQualifySrcWlanGports:
           case bcmFieldQualifySrcVxlanGport:
           case bcmFieldQualifySrcVxlanGports:
           case bcmFieldQualifySrcVlanGport:
           case bcmFieldQualifySrcVlanGports:
           case bcmFieldQualifySrcGport:
           case bcmFieldQualifySrcGports:
               ingress_entity = 1;
               break;
           default:
               break;
       }

       if (ingress_entity) {
          /* Reset Internal qualifier SVP valid bit */
          if (BCM_FIELD_QSET_TEST(f_ent->group->qset,
                                  _bcmFieldQualifySvpValid)) {
             rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 0, 0);
             if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
             }
          }
       }
    }
#endif

#if defined(BCM_APACHE_SUPPORT)
    rv = _bcm_field_apache_qualify_OamDropReason_delete(unit, entry, qual_id);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }
#endif
    f_ent->flags &= ~_FP_ENTRY_QUAL_PORT_TYPE_TRUNK;
    f_ent->flags |= _FP_ENTRY_DIRTY;
    if (f_ent->flags & _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY) {
        /* resetting POLICY_TABLE_DIRTY flag 
           as it needs change in FP_TCAM and install*/
        f_ent->flags &= ~_FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
    }

    FP_UNLOCK(unit);
#if defined(BCM_TRX_SUPPORT)
    if ((qual_id == bcmFieldQualifyRangeCheck) &&
            BCM_FIELD_QSET_TEST(f_ent->group->qset,
                _bcmFieldQualifyRangeCheckBits24_31)) {
        rv = bcm_esw_field_qualifier_delete(unit, entry,
                _bcmFieldQualifyRangeCheckBits24_31);
    }
#endif
    return rv; 
}


/*
 * Function: bcm_esw_field_qualify_XXX (class of routines)
 *
 * Purpose:
 *     Add a field qualification to a filter entry.
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - Field entry to operate on
 *     data - Data to qualify with (type varies)
 *     mask - Mask to qualify with (type is same as for data)
 *
 * Returns:
 *     BCM_E_INIT       BCM Unit not initialized.
 *     BCM_E_NOT_FOUND  Entry ID not found in unit.
 *     BCM_E_XXX        Other errors
 */

int
bcm_esw_field_qualify_InPort(int unit, bcm_field_entry_t entry,
                             bcm_port_t data, bcm_port_t mask)
{
    _field_entry_t   *f_ent;
    int              rv = BCM_E_NONE;
    bcm_port_t       port = data;
#if defined(BCM_RAPTOR_SUPPORT) || defined (BCM_TRX_SUPPORT)
    bcm_pbmp_t       lb_pbm;
    _field_group_t   *fg = NULL;
#endif
#if defined(BCM_KATANA2_SUPPORT)
        bcm_trunk_t tid;
        int id, mod;
#endif

    if (BCM_GPORT_IS_SET(data)) {

#if defined(BCM_HGPROXY_COE_SUPPORT)
        if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
            (soc_feature(unit, soc_feature_channelized_switching))) &&
            _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT (unit, data)) {
            rv = _bcmi_coe_subport_physical_port_get(unit, data, &port);
        }  else
#endif

#if defined(BCM_KATANA2_SUPPORT)
        if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT(unit, data)) {
            BCM_IF_ERROR_RETURN(
                _bcm_esw_gport_resolve(unit, data, &mod, &port, &tid, &id));
            rv = _bcm_kt2_modport_to_pp_port_get(unit, mod, port, &port);
        }  else
#endif
        {
            rv = _field_qualifier_gport_resolve(unit, data, mask,
                                               &port, NULL, NULL);
        }
        BCM_IF_ERROR_RETURN(rv);
    }

    if ((!SOC_PORT_VALID(unit, port)) || IS_LB_PORT(unit, port)) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _bcm_field_entry_qual_get(unit, entry, bcmFieldQualifyInPort, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_RAPTOR_SUPPORT) || defined (BCM_TRX_SUPPORT)
    fg = f_ent->group;
    if ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) && 
        (soc_feature(unit, soc_feature_field_ingress_ipbm))) {
        bcm_pbmp_t pbmp_data, pbmp_mask;

        /* pbmp_mask: All 1's
         * pbmp_data: Qualify *only* on the port requested 
         *     Raptor, Triumph does not have a separate field to 
         *     qualify on InPort  So need to use the IPBM 
         *     Also the "bcm_port_t mask" is assumed to be 1. */

        rv = _bcm_field_valid_pbmp_get(unit, &pbmp_mask);
        BCM_IF_ERROR_RETURN(rv);

        BCM_PBMP_CLEAR(pbmp_data);
        BCM_PBMP_PORT_SET(pbmp_data, port);
        BCM_PBMP_ASSIGN(f_ent->pbmp.data, pbmp_data);
        BCM_PBMP_ASSIGN(f_ent->pbmp.mask, pbmp_mask);

        /* Add loopback port to ipbm mask to avoid false ingress port match */
        BCM_PBMP_CLEAR(lb_pbm);
        BCM_PBMP_OR(lb_pbm, PBMP_LB(unit));
        if (BCM_PBMP_NOT_NULL(lb_pbm)) {
            BCM_PBMP_OR(f_ent->pbmp.mask, PBMP_LB(unit));
        }
#if defined(INCLUDE_XFLOW_MACSEC)
        /* Add MACSEC Port to IPBM mask to avoid match on MACSEC port */
        if (soc_feature(unit, soc_feature_xflow_macsec)) {
            bcm_pbmp_t       macsec_pbm;
            BCM_PBMP_CLEAR(macsec_pbm);
            BCM_PBMP_OR(macsec_pbm, PBMP_MACSEC_ALL(unit));
            if (BCM_PBMP_NOT_NULL(macsec_pbm)) {
                BCM_PBMP_OR(f_ent->pbmp.mask, PBMP_MACSEC_ALL(unit));
            }
        }
#endif
        f_ent->flags |= _FP_ENTRY_DIRTY;
        f_ent->flags &= ~(_FP_ENTRY_POLICY_TABLE_ONLY_DIRTY);

        FP_UNLOCK(unit);
        return (BCM_E_NONE);
    }
#endif /* BCM_RAPTOR_SUPPORT || BCM_TRX_SUPPORT */

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInPort, port, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_OutPort(int unit, bcm_field_entry_t entry,
                             bcm_port_t data, bcm_port_t mask)
{
    int              rv = BCM_E_NONE, mod = 0;
    bcm_port_t       port = data;

#if defined(BCM_KATANA2_SUPPORT)
    bcm_trunk_t tid;
    int id;
#endif

    if (BCM_GPORT_IS_SET(data)) {
#if defined(BCM_HGPROXY_COE_SUPPORT)
        if ((soc_feature(unit, soc_feature_hgproxy_subtag_coe) ||
            (soc_feature(unit, soc_feature_channelized_switching))) &&
            _BCM_COE_GPORT_IS_SUBTAG_SUBPORT_PORT(unit, data)) {
            rv = _bcmi_coe_subport_physical_port_get(unit, data, &port);
        }  else
#endif

#if defined(BCM_KATANA2_SUPPORT)

        if (_BCM_KT2_GPORT_IS_LINKPHY_OR_SUBTAG_SUBPORT_GPORT (unit, data)) {
            BCM_IF_ERROR_RETURN(
                _bcm_esw_gport_resolve(unit, data, &mod, &port, &tid, &id));
            rv = _bcm_kt2_modport_to_pp_port_get(unit, mod, port, &port);
        }  else
#endif
        {
            rv = _field_qualifier_gport_resolve(unit, data, mask, 
                                                &port, &mod, NULL);
        }
        BCM_IF_ERROR_RETURN(rv);
    }
    if (0 == SOC_PORT_VALID(unit, port)) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOutPort, port, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InPorts(int unit, bcm_field_entry_t entry,
                              bcm_pbmp_t data, bcm_pbmp_t mask)
{
    int              rv;           /* OPerational Status. */
    _field_control_t *fc;          /* Field Control Operational Structure. */

    if (soc_feature(unit, soc_feature_ifp_no_inports_support)) {
        return (BCM_E_UNAVAIL);
    }
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }
    rv = fc->functions.fp_qualify_inports(unit, entry, 
                                          bcmFieldQualifyInPorts,
                                          data, mask);
    FP_UNLOCK(unit);
    return (rv);

}

int
bcm_esw_field_qualify_OutPorts(int unit, bcm_field_entry_t entry,
                               bcm_pbmp_t data, bcm_pbmp_t mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOutPorts,
                          SOC_PBMP_WORD_GET(data, 0),
                          SOC_PBMP_WORD_GET(mask, 0));
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_Drop(int unit, bcm_field_entry_t entry,
                           uint8 data, uint8 mask)
{
    int              rv;
    
    FP_LOCK(unit);

#ifdef BCM_FIREBOLT2_SUPPORT
    /* 
     * FB2 has Drop at two places:
     *     one is FIXED (always used), and the other based on selectors. 
     * The one based on selector is thus redundant!!!
     */
    if (SOC_IS_FIREBOLT2(unit)) {
        _field_entry_t      *f_ent;
        _field_group_t      *fg;

        rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

        /* Confirm that Drop is in group's Qset. */
        fg = f_ent->group;
        if (!BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyDrop)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: Drop not in entry=%d Qset.\n"),
                       unit, entry));
            FP_UNLOCK(unit);
            return (BCM_E_PARAM);
        }

        /* Add data & mask to entry. */
        f_ent->tcam.drop      = data;
        f_ent->tcam.drop_mask = mask;

        FP_UNLOCK(unit);
        return (BCM_E_NONE);
    }
#endif /* BCM_FIREBOLT2_SUPPORT */    

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDrop,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_SrcPort(int unit, bcm_field_entry_t entry,
                              bcm_module_t data_modid,
                              bcm_module_t mask_modid,
                              bcm_port_t   data_port,
                              bcm_port_t   mask_port)
{
    int              rv;       /* Operation return status. */
    bcm_gport_t gport, gport_mask; /*temp gport and mask */

    if (BCM_GPORT_IS_SET(data_port)) {
        rv = _field_qualifier_gport_resolve(unit, data_port, mask_port, 
                                            &data_port, &data_modid, NULL);
        BCM_IF_ERROR_RETURN(rv);
    } else {
        if ((NUM_MODID(unit) > 1) && (SOC_IS_TR_VL(unit)) ) {
            BCM_GPORT_MODPORT_SET(gport, data_modid, data_port);
            gport_mask = BCM_FIELD_EXACT_MATCH_MASK;
            rv = _field_qualifier_gport_resolve(unit, gport, gport_mask,
                                        &data_port, &data_modid, NULL);
                BCM_IF_ERROR_RETURN(rv);
        }
    }
    FP_LOCK(unit);

    rv = _field_qualify_Port(unit, entry, data_modid, mask_modid,
                             data_port, mask_port, bcmFieldQualifySrcPort);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_SrcTrunk(int unit, bcm_field_entry_t entry,
                              bcm_trunk_t data, bcm_trunk_t mask)
{
    _field_control_t *fc;      /* Field control structure. */
    int              rv;       /* Operation return status. */

    if (BCM_GPORT_IS_SET(data)) {
        rv = _field_qualifier_gport_resolve(unit, data, mask, 
                                           NULL, NULL, &data);
        BCM_IF_ERROR_RETURN(rv);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = fc->functions.fp_qualify_trunk(unit, entry, 
                                        bcmFieldQualifySrcTrunk, 
                                        data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_SrcTrunkMemberGport(int unit,
        bcm_field_entry_t entry ,bcm_gport_t port)
{
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_MODPORT(port)) {
        return (BCM_E_PARAM);
    }

    data  = BCM_GPORT_MODPORT_PORT_GET(port);
    data |= ((BCM_GPORT_MODPORT_MODID_GET(port)) << _FP_PORT_BITWIDTH(unit));
    mask = BCM_FIELD_EXACT_MATCH_MASK;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifySrcTrunkMemberGport, 
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);

}

int
bcm_esw_field_qualify_DstPort(int unit, bcm_field_entry_t entry,
                              bcm_module_t data_modid,
                              bcm_module_t mask_modid,
                              bcm_port_t   data_port,
                              bcm_port_t   mask_port)
{
    int              rv;       /* Operation return status. */
    bcm_gport_t gport, gport_mask; /*temp gport and mask */
#ifdef BCM_APACHE_SUPPORT
    _field_entry_t   *f_ent;   /* Field Entry Structure.   */
#endif

    if (BCM_GPORT_IS_SET(data_port)) {
#ifdef BCM_APACHE_SUPPORT
       
       FP_LOCK(unit);
       /* Search the entry by eid. */
       rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
       if (BCM_FAILURE(rv)) {
           FP_UNLOCK(unit);
           return rv;
       }

       if (SOC_IS_APACHE(unit) &&
               (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
           /* DVP gport is not allowed in EFP */
           if (!(BCM_GPORT_IS_MODPORT(data_port) ||
                       BCM_GPORT_IS_LOCAL(data_port))) {
               rv = BCM_E_PARAM;
           }
       }
       FP_UNLOCK(unit);
       BCM_IF_ERROR_RETURN(rv);
#endif

       rv = _field_qualifier_gport_resolve(unit, data_port, mask_port, 
                                           &data_port, &data_modid, NULL);
       BCM_IF_ERROR_RETURN(rv);
       mask_modid = BCM_FIELD_EXACT_MATCH_MASK;
    } else {
        if ((NUM_MODID(unit) > 1) && (SOC_IS_TR_VL(unit)) ) {
            BCM_GPORT_MODPORT_SET(gport, data_modid, data_port);
            gport_mask = BCM_FIELD_EXACT_MATCH_MASK;
            rv = _field_qualifier_gport_resolve(unit, gport, gport_mask,
                                        &data_port, &data_modid, NULL);
            BCM_IF_ERROR_RETURN(rv);
        }
    }
    
    FP_LOCK(unit);

    rv = _field_qualify_Port(unit, entry, data_modid, mask_modid,
                             data_port, mask_port, bcmFieldQualifyDstPort);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_DstTrunk(int unit, bcm_field_entry_t entry,
                               bcm_trunk_t data, bcm_trunk_t mask)
{
    _field_control_t *fc;      /* Field control structure. */
    int              rv;       /* Operation return status. */

    if (BCM_GPORT_IS_SET(data)) {
       rv = _field_qualifier_gport_resolve(unit, data, mask, 
                                           NULL, NULL, &data);
       BCM_IF_ERROR_RETURN(rv);
    }
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = fc->functions.fp_qualify_trunk(unit, entry, 
                                        bcmFieldQualifyDstTrunk, 
                                        data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_L4SrcPort(int unit, bcm_field_entry_t entry,
                                bcm_l4_port_t data, bcm_l4_port_t mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyL4SrcPort,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_L4DstPort(int unit, bcm_field_entry_t entry,
                                bcm_l4_port_t data, bcm_l4_port_t mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyL4DstPort,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InnerL4SrcPort(int unit, bcm_field_entry_t entry,
                                bcm_l4_port_t data, bcm_l4_port_t mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerL4SrcPort,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InnerL4DstPort(int unit, bcm_field_entry_t entry,
                                bcm_l4_port_t data, bcm_l4_port_t mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerL4DstPort,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlanId
 * Purpose:
 *       Set match criteria for bcmFieildQualifyOuterVlanId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    int              rv;       /* Operation return status. */

    /* Validate VLAN ID data, should not be more than 12-bits */
    if (data & ~(0xfff)) {
       return BCM_E_PARAM; 
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOuterVlanId, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlanPri
 * Purpose:
 *       Set match criteria for bcmFieildQualifyOuterVlanPri
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int              rv;       /* Operation return status. */

    /* Validate VLAN Priority data, should not be more than 3-bits */
    if (data & ~(0x7)) {
       return BCM_E_PARAM; 
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOuterVlanPri, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlanCfi
 * Purpose:
 *       Set match criteria for bcmFieildQualifyOuterVlanCfi
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int              rv;       /* Operation return status. */

    /* Validate VLAN CFI data, should not be more than 1-bit */
    if (data & ~(0x1)) {
       return BCM_E_PARAM; 
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOuterVlanCfi, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlanId
 * Purpose:
 *       Set match criteria for bcmFieildQualifyInnerVlanId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    int              rv;       /* Operation return status. */

    /* Validate VLAN ID data, should not be more than 12-bits */
    if (data & ~(0xfff)) {
       return BCM_E_PARAM; 
    }
    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerVlanId, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_ForwardingVlanId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyForwardingVlanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ForwardingVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    int              rv;       /* Operation return status. */
    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyForwardingVlanId, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_Vpn
 * Purpose:
 *      Set match criteria for bcmFieildQualifyVpn
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Vpn(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vpn_t data, 
    bcm_vpn_t mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyVpn, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlanPri
 * Purpose:
 *       Set match criteria for bcmFieildQualifyInnerVlanPri
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int              rv;       /* Operation return status. */

    /* Validate VLAN Priority data, should not be more than 3-bits */
    if (data & ~(0x7)) {
       return BCM_E_PARAM; 
    }
    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerVlanPri, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlanCfi
 * Purpose:
 *       Set match criteria for bcmFieildQualifyInnerVlanCfi
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int              rv;       /* Operation return status. */

    /* Validate VLAN CFI data, should not be more than 1-bit */
    if (data & ~(0x1)) {
       return BCM_E_PARAM; 
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerVlanCfi, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyOuterVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                            bcmFieldQualifyOuterVlanId,
                                            data, mask);
}


/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlanPri_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyOuterVlanPri
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyOuterVlanPri,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlanCfi_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyOuterVlanCfi_get
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyOuterVlanCfi,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyInnerVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                            bcmFieldQualifyInnerVlanId,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_ForwardingVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyForwardingVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ForwardingVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                            bcmFieldQualifyForwardingVlanId,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_Vpn_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyVpn
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Vpn_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vpn_t *data, 
    bcm_vpn_t *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                            bcmFieldQualifyVpn,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlanPri_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyInnerVlanPri
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyInnerVlanPri,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlanCfi_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyInnerVlanCfi_get
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyInnerVlanCfi,
                                            data, mask);
}

int
bcm_esw_field_qualify_OuterVlan(int unit, bcm_field_entry_t entry,
                                bcm_vlan_t data, bcm_vlan_t mask)
{

    int rv;                          /* Operation return status. */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
        
        if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
            /* Error fetching entry */
            return (rv); 
        }
    
        if (rv == BCM_E_NONE) { /*Stage is Ingress*/ 

            
            FP_LOCK(unit);

            rv = _field_qualify32(unit, entry, bcmFieldQualifyOuterVlan,
                                  data, mask);
            FP_UNLOCK(unit);
            return (rv);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
     
    rv = bcm_esw_field_qualify_OuterVlanId(unit, entry, 
                                           (data & 0xfff), 
                                           (mask & 0xfff));
    BCM_IF_ERROR_RETURN(rv);

    rv = bcm_esw_field_qualify_OuterVlanCfi(unit, entry, 
                                            ((data >> 12) & 0x1),
                                            ((mask >> 12) & 0x1));
    BCM_IF_ERROR_RETURN(rv);

    rv = bcm_esw_field_qualify_OuterVlanPri(unit, entry,
                                            (data >> 13),
                                            (mask >> 13));
    return (rv);
}

int
bcm_esw_field_qualify_InnerVlan(int unit, bcm_field_entry_t entry,
                                bcm_vlan_t data, bcm_vlan_t mask)
{
    int rv;                       /* Operation return status. */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
        
        if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
            /*Error fetching entry*/
            return (rv); 
        }
    
        if (rv == BCM_E_NONE) { /*Stage is Ingress*/ 

            FP_LOCK(unit);

            rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerVlan,
                                  data, mask);
            FP_UNLOCK(unit);
            return (rv);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
 
    rv = bcm_esw_field_qualify_InnerVlanId(unit, entry, 
                                           (data & 0xfff), 
                                           (mask & 0xfff));
    BCM_IF_ERROR_RETURN(rv);

    rv = bcm_esw_field_qualify_InnerVlanCfi(unit, entry, 
                                            ((data >> 12) & 0x1),
                                            ((mask >> 12) & 0x1));
    BCM_IF_ERROR_RETURN(rv);

    rv = bcm_esw_field_qualify_InnerVlanPri(unit, entry,
                                            (data >> 13),
                                            (mask >> 13));
    return (rv);
}

int
bcm_esw_field_qualify_EtherType(int unit, bcm_field_entry_t entry,
                                uint16 data, uint16 mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyEtherType,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_IpProtocol(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIpProtocol,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* bcm_field_qualify_DosAttack */
int 
bcm_esw_field_qualify_DosAttack(int unit, bcm_field_entry_t entry, 
                                uint8 data, uint8 mask) 
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDosAttack,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* bcm_field_qualify_IpmcStarGroupHit */
int 
bcm_esw_field_qualify_IpmcStarGroupHit(int unit, bcm_field_entry_t entry, 
                                       uint8 data, uint8 mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIpmcStarGroupHit,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* bcm_field_qualify_MyStationHit */
int 
bcm_esw_field_qualify_MyStationHit(int unit, bcm_field_entry_t entry, 
                                       uint8 data, uint8 mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMyStationHit,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2PayloadFirstEightBytes
 * Purpose:
 *      Add match criteria for bcmFieildQualifyL2PayloadFirstEightBytes
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data1 - (IN) Qualifier first four bytes of matched data.
 *      data2 - (IN) Qualifier last four bytes of matched data.
 *      mask1 - (IN) Qualifier first four bytes of matched mask.
 *      mask2 - (IN) Qualifier last four bytes of matched mask.
 *
 * Note: Values passed in data1 and data2 should be in actual packet data 
 *       format order.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2PayloadFirstEightBytes(int unit,
                                               bcm_field_entry_t entry, 
                                               uint32 data1, uint32 data2,
                                               uint32 mask1, uint32 mask2)
{
    int                 rv;

    FP_LOCK(unit);

    rv = _field_qualify_L2PayloadFirstEightBytes(unit, entry,
            bcmFieldQualifyL2PayloadFirstEightBytes, data1, data2,
            mask1, mask2);

    FP_UNLOCK(unit);
    return (rv);
}
/*
 * Function:
 *     bcm_esw_field_qualify_L2PayLoad
 * Purpose:
 *     Add match criteria for bcmFieildQualifyL2PayLoad
 *     qualifier from the field entry.
 * Parameters:
 *     unit  - (IN) Unit number.
 *     entry - (IN) BCM field entry id.
 *     count - (IN) Number of bytes to qualify from the start of L2 Payload .
 *     data  - (IN) Qualifier matched data.
 *     mask  - (IN) Qualifier matched mask.
 * Returns:
 *     BCM_E_XXX
 * Notes: Number of bytes can be qualified in L2 Payload may vary from chip to chip and
 *        may differ b/w (Vlan/Ingress/Egress) Field Processors of same chip.If user 
 *        passes count more than supported, API will return BCM_E_PARAM.If count is less
 *        than the supported, API will add trailing zeros.
 */
int
bcm_esw_field_qualify_L2PayLoad(int unit,
                                bcm_field_entry_t entry,
                                uint32 count, 
                                const uint8 *data, 
                                const uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;                 /* Operation return status. */
#if defined(BCM_TOMAHAWK_SUPPORT)
    uint8  shift;                           /* Shift input by 'x'.      */
    uint8  r_idx;                           /* Local data index.        */
    uint16 width, part_width;                /* Width of the qualifier.  */
    uint16 byte;                            /* Loop iterator.           */
    uint32 ref_data[_FP_QUAL_DATA_WORDS];   /* HW match data.           */
    uint32 ref_mask[_FP_QUAL_DATA_WORDS];   /* HW match mask.           */
    _field_entry_t   *f_ent;                /* Field Entry Structure.   */
    _bcm_field_qual_offset_t *q_offset;     /* Qualfier Offset.         */
    _bcm_field_qual_offset_t qual_offset;   /* Qualfier Offset for IFP/EM*/
    bcm_field_qualify_t qual;               /* Qualifier Id.            */
    int r_offset;                           /* Identify the data index. */ 
    int entry_parts, part_ct;               /* Number of parts		*/

    LOG_DEBUG(BSL_LS_BCM_FP,            
              (BSL_META_U(unit,
                          "bcm_esw_field_qualify_L2PayLoad\n")));

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return BCM_E_PARAM;
    }

    

    FP_LOCK(unit);

    qual = bcmFieldQualifyL2PayLoad;
    /* Get field entry part that contains qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    if BCM_FAILURE(rv) {
       FP_UNLOCK(unit);
       return rv;
    }

    width = 0;
    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) {
    /* Get qualifier offsets in the tcam. */
        rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
        if BCM_FAILURE(rv) {
           FP_UNLOCK(unit);
           return rv;
        }
        width = q_offset->width[0] + q_offset->width[1] + q_offset->width[2];
    }
    else {
        /* Retrieve group entry parts */
        rv = _bcm_field_th_entry_tcam_parts_count(unit, f_ent->group->flags,
                                              &entry_parts);
            if BCM_FAILURE(rv) {
               FP_UNLOCK(unit);
               return rv;
            }
        for (part_ct = 0; part_ct < entry_parts; part_ct++) {
            /* Initialize qual_offset to NULL */
            sal_memset(&qual_offset, 0x0, sizeof(qual_offset));
            part_width=0;
            /* Retrieve the Qualifier offsets for the particular entry part */  
            rv = _bcm_field_th_qual_part_offset_get(unit, f_ent, part_ct,
                                               qual, &qual_offset);
            if (rv == BCM_E_NOT_FOUND) {
                continue;
            } else if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return rv;
            }
           /* Combined width of a qualifier for a given part */
           _BCM_FIELD_QUAL_MULTI_OFFSET_WIDTH(&qual_offset, part_width);
	   width = width + part_width;
	}
    }
    if (width < (count * 8)) {
        FP_UNLOCK(unit);
        return BCM_E_PARAM;
    }

    sal_memset(&ref_data, 0, sizeof(ref_data));
    sal_memset(&ref_mask, 0, sizeof(ref_mask));

    r_idx = width / 32;
    r_offset = width % 32;

    if (!r_offset) {
        r_idx -= 1;
        shift = 24; 
    }
    else {
        shift = 24 - r_offset;
    }

    for (byte = 0; byte < count; byte++) {
        ref_data[r_idx] |= data[byte] << shift;
        ref_mask[r_idx] |= mask[byte] << shift;
        if (shift < 8) {
            shift = 24;
            r_idx--;
        }
        else {
            shift -= 8;
        }
    }

    /* Program data/mask pair to tcam buffer. */
    /*
     * COVERITY 
     * 
     *This flow takes care of the  Out-of-bounds access issue  
     * for ref_data and ref_mask.
     */
    /* coverity[callee_ptr_arith : FALSE] */
    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) {
        rv = _field_efp_qualify32(unit, entry, qual, ref_data, ref_mask);
            if BCM_FAILURE(rv) {
               FP_UNLOCK(unit);
               return rv;
            }
    }
    else {
    /* stage is Ingress/ExactMatch */
        rv = _bcm_field_th_qualify_set(unit, entry, qual,
                             ref_data, ref_mask, _FP_QUALIFIER_ADD);
    }

    f_ent->flags |= _FP_ENTRY_DIRTY;

    FP_UNLOCK(unit);
#endif
    return (rv);
}
/*
 * Function:
 *     bcm_esw_field_qualify_L2PayLoad_get
 * Purpose:
 *     Get match criteria for bcmFieildQualifyL2PayLoad
 *     qualifier from the field entry.
 * Parameters:
 *     unit  - (IN) Unit number.
 *     entry - (IN) BCM field entry id.
 *     count - (IN) Number of bytes to qualify from the start of L2 Payload .
 *     data  - (OUT) Qualifier matched data.
 *     mask  - (OUT) Qualifier matched mask.
 * Returns:
 *     BCM_E_XXX
 * Notes: Number of bytes can be qualified in L2 Payload may vary from chip to chip and
 *        may differ b/w (Vlan/Ingress/Egress) Field Processors of same chip.If user 
 *        passes count more than supported, API will return BCM_E_PARAM.If count is less
 *        than the supported, API will add trailing zeros.
 */
int
bcm_esw_field_qualify_L2PayLoad_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint32 count, 
                                    uint8 *data, 
                                    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;                 /* Operation return status */
#if defined(BCM_TOMAHAWK_SUPPORT)
    uint8                       r_idx;      /* Local data index.        */
    uint8                       r_offset;   /* Identify the data index. */
    uint8                       shift;      /* Shift hw data by 'x'.    */
    uint16               width, part_width; /* Width of the qualifier.  */
    uint16                      byte;       /* Loop iterator.           */
    uint32 ref_data[_FP_QUAL_DATA_WORDS];   /* HW match data.           */
    uint32 ref_mask[_FP_QUAL_DATA_WORDS];   /* HW match mask.           */
    _field_entry_t              *f_ent;     /* Field Entry Structure.   */
    _bcm_field_qual_offset_t    *q_offset;  /* Qualfier Offset.         */
    _bcm_field_qual_offset_t    qual_offset;  /* Qualfier Offset.         */
    bcm_field_qualify_t         qual;       /* Qualifier Id.            */
   int entry_parts,part_ct;

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return BCM_E_PARAM;
    }

    

    FP_LOCK(unit);

    qual = bcmFieldQualifyL2PayLoad;
    /* Get field entry part that contains qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, qual, &f_ent);
    if BCM_FAILURE(rv) {
       FP_UNLOCK(unit);
       return rv;
    }

    /* Get qualifier offsets in the tcam. */
    rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
    if BCM_FAILURE(rv) {
       FP_UNLOCK(unit);
       return rv;
    }

    width = 0;
    if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) {
    /* Get qualifier offsets in the tcam. */
        rv = _field_qual_offset_get(unit, f_ent, qual, &q_offset);
        if BCM_FAILURE(rv) {
           FP_UNLOCK(unit);
           return rv;
        }
        width = q_offset->width[0] + q_offset->width[1] + q_offset->width[2];
    }
    else {
        /* Retrieve group entry parts */
        rv = _bcm_field_th_entry_tcam_parts_count(unit, f_ent->group->flags,
                                              &entry_parts);
        if BCM_FAILURE(rv) {
           FP_UNLOCK(unit);
           return rv;
        }
        for (part_ct = 0; part_ct < entry_parts; part_ct++) {
            /* Initialize qual_offset to NULL */
            sal_memset(&qual_offset, 0x0, sizeof(qual_offset));
            part_width=0;
            /* Retrieve the Qualifier offsets for the particular entry part */  
            rv = _bcm_field_th_qual_part_offset_get(unit, f_ent, part_ct,
                                               qual, &qual_offset);
            if (rv == BCM_E_NOT_FOUND) {
                continue;
            } else if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return rv;
            }
           /* Combined width of a qualifier for a given part */
           _BCM_FIELD_QUAL_MULTI_OFFSET_WIDTH(&qual_offset, part_width);
	   width = width + part_width;
	}
    }
    if (width < (count * 8)) {
        FP_UNLOCK(unit);
        return BCM_E_PARAM;
    }


    sal_memset(&ref_data, 0, sizeof(ref_data));
    sal_memset(&ref_mask, 0, sizeof(ref_mask));

    if(f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_qual_value_get(unit, q_offset, f_ent, ref_data,
                                       ref_mask);
    } else {
        rv = _bcm_field_th_entry_qualifier_key_get(unit, entry, qual,
                                                  ref_data, ref_mask);
    }
    
    r_idx = width / 32;
    r_offset = width % 32; 

    if (!r_offset) { 
        r_idx -= 1;
        shift = 24;
    }
    else { 
        shift = 24 - r_offset;
    }

    for (byte = 0; byte < count; byte++) {
        data[byte] = (uint8)(ref_data[r_idx] >> shift);
        mask[byte] = (uint8)(ref_mask[r_idx] >> shift);
        if (shift < 8) {
            shift = 24;
            r_idx--;
        }
        else {
            shift -= 8;
        }
    }

    FP_UNLOCK(unit);
#endif
    return (rv);
}

/* bcm_field_qualify_L3DestRouteHit */
int 
bcm_esw_field_qualify_L3DestRouteHit(int unit, bcm_field_entry_t entry, 
                                     uint8 data, uint8 mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyL3DestRouteHit,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* bcm_field_qualify_L3DestHostHit */
int 
bcm_esw_field_qualify_L3DestHostHit(int unit, bcm_field_entry_t entry, 
                                    uint8 data, uint8 mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyL3DestHostHit,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* bcm_field_qualify_L3SrcHostHit */
int 
bcm_esw_field_qualify_L3SrcHostHit(int unit, bcm_field_entry_t entry, 
                                   uint8 data, uint8 mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyL3SrcHostHit,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* bcm_field_qualify_L2CacheHit */
int 
bcm_esw_field_qualify_L2CacheHit(int unit, bcm_field_entry_t entry, 
                                  uint8 data, uint8 mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyL2CacheHit,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* bcm_field_qualify_L2StationMove */
int 
bcm_esw_field_qualify_L2StationMove(int unit, bcm_field_entry_t entry, 
                                    uint8 data, uint8 mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyL2StationMove,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* bcm_field_qualify_L2DestHit */
int 
bcm_esw_field_qualify_L2DestHit(int unit, bcm_field_entry_t entry, 
                                uint8 data, uint8 mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyL2DestHit,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* bcm_field_qualify_L2SrcStatic */
int 
bcm_esw_field_qualify_L2SrcStatic(int unit, bcm_field_entry_t entry, 
                                  uint8 data, uint8 mask) 
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyL2SrcStatic,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* bcm_field_qualify_L2SrcHit */
int 
bcm_esw_field_qualify_L2SrcHit(int unit, bcm_field_entry_t entry, 
                               uint8 data, uint8 mask) 
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyL2SrcHit,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* bcm_field_qualify_IngressStpState */
int 
bcm_esw_field_qualify_IngressStpState(int unit,bcm_field_entry_t entry, 
                                      uint8 data, uint8 mask) 
{
    int              value;
    int              rv;

    switch (data) {
      case BCM_STG_STP_DISABLE:
          value = 0; 
          break;
      case BCM_STG_STP_BLOCK:
          value = 1; 
          break;
      case BCM_STG_STP_LEARN:
          value = 2; 
          break;
      case BCM_STG_STP_FORWARD:
          value = 3; 
          break;
      default:
          return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIngressStpState,
                            value, 0x3);
    FP_UNLOCK(unit);
    return (rv);
} 

/* bcm_field_qualify_ForwardingVlanValid */
int 
bcm_esw_field_qualify_ForwardingVlanValid(int unit, bcm_field_entry_t entry, 
                                          uint8 data, uint8 mask) 
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyForwardingVlanValid,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcVirtualPortValid
 *      Set match criteria for bcmFieldQualifySrcVirtualPortValid
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcVirtualPortValid(int unit, bcm_field_entry_t entry,
                                          uint8 data, uint8 mask) 
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifySrcVirtualPortValid,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstL3EgressNextHops
 *      Set match criteria for bcmFieldQualifyDstL3EgressNextHops
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Match consecutive Next Hop Index values
 *      mask    -   (IN) Next Hop Index mask value
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstL3EgressNextHops(int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */
#if defined(INCLUDE_L3)
    _field_control_t *fc;
    uint32 max_nexthop_index = 0;

    /* Check if L3 feature is supported on the device */
    if (!soc_feature(unit, soc_feature_l3)) {
        return (rv);
    }

    /*  Make sure module was initialized. */
    if (!BCM_XGS3_L3_INITIALIZED(unit)) {
        return (rv);
    }

    max_nexthop_index = (BCM_XGS3_L3_NH_TBL_SIZE(unit) - 1);

    /* Check if mask is greater than possible table index value */
    if ((mask != BCM_FIELD_EXACT_MATCH_MASK) && (mask > max_nexthop_index)) {
        return (BCM_E_PARAM);
    }

    /* Check if data is greater than possible table index value */
    if (data > max_nexthop_index) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Invoke driver function for multi pipe devices.
     */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);

        if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
            /*Error fetching entry*/
            FP_UNLOCK(unit);
            return (rv);
        }

        if (rv == BCM_E_NONE) { /*Stage is Ingress*/ 
            rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstL3EgressNextHops,
                                          data, mask, 0);
            FP_UNLOCK(unit);
            return (rv);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* set destination type in data and mask */
    rv = _field_dest_type_qualify(unit, entry,
                                  bcmFieldQualifyDstL3EgressNextHops, 
                                  &data, &mask, _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstL3EgressNextHops,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return (rv);

}

/*
 * Function:
 *      bcm_esw_field_qualify_VlanTranslationHit/
 * Purpose:
 *      Set match criteria for bcmFieildQualifyVlanTranslationHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_VlanTranslationHit(int unit, bcm_field_entry_t entry, 
                                         uint8 data, uint8 mask) 
{
    int              rv;
    int (*func)(int, bcm_field_entry_t, uint8 *, uint8 *) =
                                     _field_qualify_VlanTranslationHit;

#ifdef BCM_TRIDENT2_SUPPORT
    _field_entry_t *f_ent = NULL;
#endif

    FP_LOCK(unit);

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            func = _bcm_field_th_qualify_VlanTranslationHit;
    } else
#endif
#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }

        if (SOC_IS_TD2_TT2(unit)
                && (_BCM_FIELD_STAGE_EGRESS != f_ent->group->stage_id)) {
            func = _bcm_field_td2_qualify_VlanTranslationHit;
        }
    }
#endif

    rv = (*func)(unit, entry, &data, &mask);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyVlanTranslationHit,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_IpInfo(int unit, bcm_field_entry_t entry,
                             uint32 data, uint32 mask)   
{
#ifdef BCM_TRX_SUPPORT
    _field_entry_t      *f_ent;
#endif /* BCM_TRX_SUPPORT */
    int                 rv;
    const uint32        data_max = BCM_FIELD_IP_HDR_OFFSET_ZERO |
                                   BCM_FIELD_IP_HDR_FLAGS_MF |
                                   BCM_FIELD_IP_CHECKSUM_OK;

    /* Range check data and mask values. */
    if (data > data_max || mask > data_max) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: IpInfo data=%#x or mask=%#x out of range (0-%d)."),
                   unit, data, mask, data_max));
        return (BCM_E_PARAM);
    }

#ifdef BCM_TRX_SUPPORT
    /* For VFP on TRX devices and for ingress and Exact match stage
     * on TD2 and TH family devices, the checksum is 1-bit field and
       for all other devices, IpInfo field is 3 bit
     */
    BCM_IF_ERROR_RETURN(_field_entry_get(unit,
                                         entry,
                                         _FP_ENTRY_PRIMARY,
                                         &f_ent));
    if ( ((SOC_IS_TRX(unit) &&
          (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id)) ||
         ((SOC_IS_TD2_TT2(unit) &&
           ((_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) ||
            (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id)) ))) ){
        /* On Trident2 IP_INFO field is devided into two parts
         * IP_FRAG_INFO(2bits) and IP_CHECKSUM_OK(1bit). IP_FRAG_INFO
         * can be qualified using bcmFieldQualifyIpFrag and IP_CHECKSUM_OK
         * can be qualified using bcmFieldQualifyIpInfo.
         */
        if (data & ~BCM_FIELD_IP_CHECKSUM_OK ||
            mask != BCM_FIELD_IP_CHECKSUM_OK) {
                return BCM_E_PARAM;
        }
        data = (data & BCM_FIELD_IP_CHECKSUM_OK) ? 1 : 0;
        mask = 1;
    } else
#endif /* BCM_TRX_SUPPORT */

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAPTOR_SUPPORT) || defined(BCM_TRX_SUPPORT)
    if (SOC_IS_FIREBOLT2(unit) || SOC_IS_RAVEN(unit) || SOC_IS_TRX(unit) || SOC_IS_HAWKEYE(unit)) {
        if (mask & BCM_FIELD_IP_HDR_FLAGS_MF) {
            /* In FB2 More fragments bit replaced with whole packet bit. */
            data = ((data & BCM_FIELD_IP_HDR_OFFSET_ZERO) | 
                (data & BCM_FIELD_IP_CHECKSUM_OK) | 
                (data ^ BCM_FIELD_IP_HDR_FLAGS_MF));
        }
    }
#endif /* BCM_FIREBOLT_SUPPORT || BCM_RAPTOR_SUPPORT || BCM_TRX_SUPPORT */


    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIpInfo,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_PacketRes(int unit, bcm_field_entry_t entry,
                                uint32 data, uint32 mask) 
{
    const uint32     data_max = BCM_FIELD_PKT_RES_LAST;
    int              rv;
    _field_control_t *fc = NULL; 

    /* Range check data and mask values. */
    if (data > data_max) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                  "FP(unit %d) Error: PacketRes data=%#x out of range (0-%d)."),
                   unit, data, data_max));
        return (BCM_E_PARAM);
    }

    /* Check for valid data mask combinations */
    if ((mask != data) && (!((mask & 0x3f) == 0x3f))) {
         return (BCM_E_PARAM);
    }

    FP_LOCK(unit);

    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    if (NULL == fc->functions.fp_qualify_packet_res) {
        FP_UNLOCK(unit);
        return BCM_E_CONFIG;
    }

    rv = fc->functions.fp_qualify_packet_res(unit, entry, &data, &mask);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }
    
    /* convert encoding 0x0 of mask to value 0x1 */
    if(data == 0 && mask == 0) {
       mask = 1;
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyPacketRes,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_SrcIp(int unit, bcm_field_entry_t entry,
                            bcm_ip_t data, bcm_ip_t mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifySrcIp, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_DstIp(int unit, bcm_field_entry_t entry,
                            bcm_ip_t data, bcm_ip_t mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstIp, data, mask);

    FP_UNLOCK(unit);
    return(rv);
}

int
bcm_esw_field_qualify_DSCP(int unit, bcm_field_entry_t entry,
                           uint8 data, uint8 mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDSCP, data, mask);

    FP_UNLOCK(unit);
    return(rv);
}

int
bcm_esw_field_qualify_Tos(int unit, bcm_field_entry_t entry,
                           uint8 data, uint8 mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyTos, data, mask);

    FP_UNLOCK(unit);
    return(rv);
}

int
bcm_esw_field_qualify_IpFlags(int unit, bcm_field_entry_t entry,
                              uint8 data, uint8 mask)
{
    int              rv;
    const uint8      data_max = BCM_FIELD_IPFLAGS_MASK & ~BCM_FIELD_IPFLAGS_RF;


    /* Reserved flag bit (RFC791) is unused. */
    data &= ~BCM_FIELD_IPFLAGS_RF;
    mask &= ~BCM_FIELD_IPFLAGS_RF;

    /* Range check data and mask values. */
    if (data > data_max) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: IpFlags data=%#x out of range (0-%d)."),
                   unit, data, data_max));
        return (BCM_E_PARAM);
    }


    
    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, bcmFieldQualifyIpFlags,
                          data, mask);
    FP_UNLOCK(unit);
    return(rv);
}

int
bcm_esw_field_qualify_TcpControl(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
{
    int              rv;
    uint8      data_max = BCM_FIELD_TCPCONTROL_MASK;
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_entry_t *f_ent = NULL;
#endif

    
    FP_LOCK(unit);

#if defined(BCM_TOMAHAWK_SUPPORT)
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);

    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* In Tomahawk 8bit TCP flag is not supported for VFP stage */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
            (f_ent->group->stage_id != _BCM_FIELD_STAGE_LOOKUP)) {
        data_max |= (BCM_FIELD_TCPCONTROL_R40 | BCM_FIELD_TCPCONTROL_R80);
    }
#endif

    /* Range check data and mask values. */
    if (data > data_max) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: TcpControl data=%#x or mask=%#x out of range (0-%d)."),
                   unit, data, mask, data_max));
        FP_UNLOCK(unit);
        return (BCM_E_PARAM);
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyTcpControl,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_Ttl(int unit, bcm_field_entry_t entry,
                          uint8 data, uint8 mask)
{
    int              rv;

    
    FP_LOCK(unit);

#if defined(BCM_FIREBOLT2_SUPPORT)
    if (SOC_IS_FIREBOLT2(unit)) {
        rv =  _bcm_field_fb2_qualify_ttl(unit, entry, data, mask);     
    } else 
#endif /* BCM_FIREBOLT2_SUPPORT */
        
#if defined(BCM_RAPTOR_SUPPORT)
    if (SOC_IS_RAVEN(unit) || SOC_IS_HAWKEYE(unit)) {
        rv =  _bcm_field_raven_qualify_ttl(unit, entry, data, mask);     
    } else 
#endif /* BCM_RAPTOR_SUPPORT */
    {
        rv = _field_qualify32(unit, entry, bcmFieldQualifyTtl, data, mask);
    }
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_qualify_RangeCheck
 *
 * Purpose:
 *     Add a field qualification to a filter entry.
 *
 * Parameters:
 *     unit   - BCM device number
 *     entry  - Field entry to operate on
 *     range  - Range ID to add entry
 *     invert -
 *
 * Returns:
 *     BCM_E_XXX 
 */
int
bcm_esw_field_qualify_RangeCheck(int unit, bcm_field_entry_t entry,
                                 bcm_field_range_t range, int invert)
{
    _bcm_field_qual_offset_t *q_offset;
    _field_range_t         *fr;
    _field_entry_t         *f_ent;
    _field_stage_t         *stage_fc;
    _bcm_field_qual_data_t  data;
    _bcm_field_qual_data_t  mask;
#if defined(BCM_TRX_SUPPORT)
    _bcm_field_qual_offset_t *q_offset1;
    _field_entry_t         *f_ent1;
    _bcm_field_qual_data_t   data1;
    _bcm_field_qual_data_t   mask1;
#endif
    int                     rv;
    int                     hw_index = -1;

    
    FP_LOCK(unit);

    /* Get field entry part that contains qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, bcmFieldQualifyRangeCheck, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    if (NULL == f_ent->group) {
        FP_UNLOCK(unit);
        return (BCM_E_INTERNAL);
    }

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#ifdef BCM_TOMAHAWK_SUPPORT
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)
           && RANGE_CTRL(unit) &&
       (RANGE_CTRL(unit)->range_used_by_module == RANGE_USED_BY_RANGE_MODULE)) {
        rv = bcmi_xgs5_range_validate_field_stage_oper_mode (unit, stage_fc->oper_mode);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

        rv = bcmi_xgs5_range_validate_field_group_instance (unit, range, f_ent->group->instance); 
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

        rv = bcmi_xgs5_range_get_hw_index(unit, range, &hw_index);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    } else {
#endif
    /* Find range hw entry index. */
    for (fr = stage_fc->ranges; fr != NULL; fr = fr->next) {
        if (fr->rid == range) {
            hw_index = fr->hw_index;
            break;
        }
    }
    if (hw_index < 0) {
        FP_UNLOCK(unit);
        return (BCM_E_NOT_FOUND);
    }
#if defined BCM_TOMAHAWK_SUPPORT
    }
#endif

#if defined(BCM_TRX_SUPPORT) 
    /* Range checkers is partially overlaid over 
       interface class selector on trx devices. */
    if (SOC_IS_TRX(unit) &&
        (!soc_feature(unit, soc_feature_field_multi_pipe_support)) &&
            (hw_index > _FP_TRX_RANGE_CHECKER_LOWER_MAX)) {
        if (!BCM_FIELD_QSET_TEST(f_ent->group->qset, _bcmFieldQualifyRangeCheckBits24_31)) {
            FP_UNLOCK(unit);
            return (BCM_E_RESOURCE);
        } else {
            rv = _bcm_trx_range_checker_selcodes_update(unit, entry);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }
        }
    }
#endif /* BCM_TRX_SUPPORT */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* Read qualifier match value and mask. */
       rv = _field_entry_qualifier_key_get(unit, entry,
                                           bcmFieldQualifyRangeCheck,
                                           data, mask);
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
       /* Get qualifier offsets in the tcam. */
       rv = _field_qual_offset_get(unit, f_ent, bcmFieldQualifyRangeCheck,
                                &q_offset);
       if (BCM_FAILURE(rv)) {
           FP_UNLOCK(unit);
           return (rv);
       }

       /* Read qualifier match value and mask. */
       rv = _bcm_field_qual_value_get(unit, q_offset, f_ent, 
                                   data, mask);

#if defined(BCM_TRX_SUPPORT)
        if (BCM_SUCCESS(rv) && SOC_IS_TRX(unit) &&
                BCM_FIELD_QSET_TEST(f_ent->group->qset,
                    _bcmFieldQualifyRangeCheckBits24_31)) {
            /* Get field entry part that contains qualifier. */
            rv = _bcm_field_entry_qual_get(unit, entry,
                    _bcmFieldQualifyRangeCheckBits24_31, &f_ent1);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return rv;
            }

            /* Get qualifier offsets in the tcam. */
            rv = _field_qual_offset_get(unit, f_ent1, _bcmFieldQualifyRangeCheckBits24_31,
                    &q_offset1);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }

            /* Read qualifier match value and mask. */
            rv = _bcm_field_qual_value_get(unit, q_offset1, f_ent1,
                    data1, mask1);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }
            data[0] |= ((data1[0] & 0xff) << 24);
            mask[0] |= ((mask1[0] & 0xff) << 24);
        }
#endif
    }

    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    if (invert < 0) {
        SHR_BITCLR(mask, hw_index);
    } else {
        SHR_BITSET(mask, hw_index);
        if (invert) {
            SHR_BITCLR(data, hw_index);
        } else {
            SHR_BITSET(data, hw_index);
        }
    }
#if defined(BCM_TRX_SUPPORT)
    data1[0] = data[0];
    mask1[0] = mask[0];
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* coverity[callee_ptr_arith : FALSE] */
       rv = _bcm_field_th_qualify_set(unit, entry, bcmFieldQualifyRangeCheck,
                                      data, mask, _FP_QUALIFIER_ADD);
       FP_UNLOCK(unit);
       return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    rv = _bcm_field_qual_value_set(unit, q_offset, f_ent, data, mask);
#if defined(BCM_TRX_SUPPORT)
    if (BCM_SUCCESS(rv) && SOC_IS_TRX(unit) &&
            BCM_FIELD_QSET_TEST(f_ent->group->qset,
                _bcmFieldQualifyRangeCheckBits24_31)) {
        /* upper 8 bits to data */
        data1[0] = (data1[0] >> 24) & 0xff;
        mask1[0] = (mask1[0] >> 24) & 0xff;

        rv = _bcm_field_qual_value_set(unit, q_offset1, f_ent1, data1, mask1);
    }
#endif

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_SrcIp6(int unit, bcm_field_entry_t entry,
                             bcm_ip6_t data, bcm_ip6_t mask)
{
    int                 rv;

    FP_LOCK(unit);

    rv = _field_qualify_ip6(unit, entry, bcmFieldQualifySrcIp6, 
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_DstIp6(int unit, bcm_field_entry_t entry,
                             bcm_ip6_t data, bcm_ip6_t mask)
{
    int                 rv;

    FP_LOCK(unit);

    rv = _field_qualify_ip6(unit, entry, bcmFieldQualifyDstIp6, 
                            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_SrcIp6High(int unit, bcm_field_entry_t entry,
                                 bcm_ip6_t data, bcm_ip6_t mask)
{
    int                 rv;
    
    FP_LOCK(unit);

    rv = _field_qualify_ip6(unit, entry, bcmFieldQualifySrcIp6High,
                            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_DstIp6High(int unit, bcm_field_entry_t entry,
                                 bcm_ip6_t data, bcm_ip6_t mask)
{
    int                 rv;

    
    FP_LOCK(unit);

    rv = _field_qualify_ip6(unit, entry, bcmFieldQualifyDstIp6High,
                            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_SrcIp6Low(int unit, bcm_field_entry_t entry,
                                 bcm_ip6_t data, bcm_ip6_t mask)
{
    int                 rv;

    
    FP_LOCK(unit);

    rv = _field_qualify_ip6(unit, entry, bcmFieldQualifySrcIp6Low,
                            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_DstIp6Low(int unit, bcm_field_entry_t entry,
                                 bcm_ip6_t data, bcm_ip6_t mask)
{
    int                 rv;

    
    FP_LOCK(unit);

    rv = _field_qualify_ip6(unit, entry, bcmFieldQualifyDstIp6Low,
                            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_Ip6NextHeader(int unit, bcm_field_entry_t entry,
                                    uint8 data, uint8 mask)
{
    int                 rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIp6NextHeader,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InnerIp6NextHeader(int unit, bcm_field_entry_t entry,
                                         uint8 data, uint8 mask)
{
    int                 rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerIp6NextHeader,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}


int
bcm_esw_field_qualify_InnerIp6FlowLabel(int unit, bcm_field_entry_t entry,
                                   uint32 data, uint32 mask)
{
    const uint32        data_max = (1 << 20) - 1;
    int                 rv;

    /* Range check data and mask values. */
    if (data > data_max) {
        return (BCM_E_PARAM);
    }
 
    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerIp6FlowLabel,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_Ip6TrafficClass(int unit, bcm_field_entry_t entry,
                                      uint8 data, uint8 mask)
{
    int                 rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIp6TrafficClass,
                            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_Ip6FlowLabel(int unit, bcm_field_entry_t entry,
                                   uint32 data, uint32 mask)
{
    const uint32        data_max = (1 << 20) - 1;
    int                 rv;

    /* Range check data and mask values. */
    if (data > data_max) {
        return (BCM_E_PARAM);
    }
 
    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIp6FlowLabel,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_Ip6HopLimit(int unit, bcm_field_entry_t entry,
                                  uint8 data, uint8 mask)
{
    int                 rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIp6HopLimit,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);

}

int
bcm_esw_field_qualify_InnerIp6HopLimit(int unit, bcm_field_entry_t entry,
                                  uint8 data, uint8 mask)
{
    int                 rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerIp6HopLimit,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_SrcMac(int unit, bcm_field_entry_t entry,
                             bcm_mac_t data, bcm_mac_t mask)
{
    int                      rv;

    
    FP_LOCK(unit);

    rv = _field_qualify_macaddr(unit, entry, bcmFieldQualifySrcMac,
                                data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_DstMac(int unit, bcm_field_entry_t entry,
                             bcm_mac_t data, bcm_mac_t mask)
{
    int                      rv;

    
    FP_LOCK(unit);

    rv = _field_qualify_macaddr(unit, entry, bcmFieldQualifyDstMac,
                                data, mask);
    FP_UNLOCK(unit);
    return (rv);

}

/*
 * Function:
 *      bcm_esw_field_qualify_Loopback
 * Purpose:
 *      Add loopback field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data - (IN) Data to qualify with.
 *      mask - (IN) Mask to qualify with.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Loopback(int unit, 
                           bcm_field_entry_t entry, 
                           uint8 data, 
                           uint8 mask)
{
    int              rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyLoopback, 
                          (data ?  0x1 : 0), (mask ? 0x1 : 0));

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_LoopbackType
 * Purpose:
 *      Add loopback type field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      loopback_type - (IN) Loopback type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_LoopbackType(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_field_LoopbackType_t loopback_type)
{
    int               rv;   /* Operation return status. */
    uint32            data; /* HW data match criteria.  */
    uint32            mask; /* HW data mask.            */

#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
#if defined(BCM_TOMAHAWK_SUPPORT)
        _field_entry_t *f_ent = NULL;  /* Field entry structure.   */
        

#if defined(BCM_TRIDENT3_SUPPORT)
        if (soc_feature(unit, soc_feature_td3_style_fp)) {
            BCM_IF_ERROR_RETURN(_bcm_field_td3_qualify_LoopbackType(loopback_type,
                                                                    &data,
                                                                    &mask));
        }
#endif /* BCM_TRIDENT3_SUPPORT */

#if defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
            BCM_IF_ERROR_RETURN (_bcm_field_th3_qualify_LoopbackType(loopback_type,
                                                                    &data,
                                                                    &mask));
        }
#endif /* BCM_TOMAHAWK3_SUPPORT */ 
 
        /* LoopbackType encodings are different for Tomahawk EFP. For 
           Tomahawk IFP and Preselection TD2 encodings are to be used. 
           Fetch the field entry only if the entry is not a presel entry
           and check for the stage to redirect to appropriate API. */
        if (soc_feature(unit, soc_feature_field_preselector_support) &&
            (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == FALSE)) {
            /* Get field entry part that contains the qualifier. */
            rv = _bcm_field_entry_qual_get(unit, entry, bcmFieldQualifyLoopbackType, &f_ent);
            BCM_IF_ERROR_RETURN(rv);
        
            if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) {
#if defined(BCM_TOMAHAWK3_SUPPORT)
                if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
                     BCM_IF_ERROR_RETURN (_bcm_field_th3_qualify_LoopbackType(loopback_type,
                                                                             &data,
                                                                             &mask));
                } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
                {
                    /*Loopback Type encoding in Tomahawk Egress is different from TD2.*/
                    BCM_IF_ERROR_RETURN(_bcm_field_th_qualify_LoopbackType(unit,
                                                loopback_type, &data, &mask));
                }
            }
            else {
#if defined(BCM_TRIDENT3_SUPPORT)
                 if (soc_feature(unit, soc_feature_td3_style_fp)) {
                    BCM_IF_ERROR_RETURN(_bcm_field_td3_qualify_LoopbackType(loopback_type,
                                                                            &data,
                                                                            &mask));
                 } else
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TOMAHAWK3_SUPPORT)
                 if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
                     BCM_IF_ERROR_RETURN (_bcm_field_th3_qualify_LoopbackType(loopback_type,
                                                                             &data,
                                                                             &mask));
                 } else
#endif /* BCM_TOMAHAWK3_SUPPORT */ 
                 {
                BCM_IF_ERROR_RETURN(_bcm_field_td2_qualify_LoopbackType(unit,
                            loopback_type, &data, &mask));
            }
        }
        }
        else
#endif /* BCM_TOMAHAWK_SUPPORT */
        {
#if defined(BCM_TRIDENT3_SUPPORT)
            if (soc_feature(unit, soc_feature_td3_style_fp)) {
                BCM_IF_ERROR_RETURN(_bcm_field_td3_qualify_LoopbackType(loopback_type,
                                                                        &data,
                                                                        &mask));
            } else
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TOMAHAWK3_SUPPORT)
            if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
                BCM_IF_ERROR_RETURN (_bcm_field_th3_qualify_LoopbackType(loopback_type,
                                                                        &data,
                                                                        &mask));
            } else
#endif /* BCM_TOMAHAWK3_SUPPORT */
            {
                BCM_IF_ERROR_RETURN(_bcm_field_td2_qualify_LoopbackType(unit,
                                                                loopback_type,
                                                                &data, &mask));
            }
        }
    } else
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_LoopbackType(loopback_type,
                                                                &data,
                                                                &mask
                                                                )
                            );
    } else
#endif
#ifdef BCM_TRIDENT_SUPPORT
    if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit)) {
        switch (loopback_type) {
            case bcmFieldLoopbackTypeAny:
                data = 0x8;
                mask = 0x8;
                break;
            case bcmFieldLoopbackTypeMim:
                data = 0xb;
                mask = 0xf;
                break;
            case bcmFieldLoopbackTypeTrillNetwork:
                data = 0xc;
                mask = 0xf;
                break;
            case bcmFieldLoopbackTypeTrillAccess:
                data = 0xd;
                mask = 0xf;
                break;
#ifdef BCM_KATANA2_SUPPORT
            case bcmFieldLoopbackTypeMirror:
                if (SOC_IS_KATANA2(unit)) {
                    data = 0x9;
                    mask = 0xf;
                } else {
                    return (BCM_E_PARAM);
                }
                break;
            case bcmFieldLoopbackTypeRedirect:
                if (SOC_IS_KATANA2(unit)) {
                    data = 0xa;
                    mask = 0xf;
                } else {
                    return (BCM_E_PARAM);
                }
                break;
#endif /* BCM_KATANA2_SUPPORT */
            default:
                return (BCM_E_PARAM);
        }
    } else
#endif /* BCM_TRIDENT_SUPPORT */
    {
        switch (loopback_type) { 
            case bcmFieldLoopbackTypeAny:
                data = 0x8;
                mask = 0x8;
                break;
            case bcmFieldLoopbackTypeMirror:
                data = 0xe;
                mask = 0xf;
                break;
            case bcmFieldLoopbackTypeWlan:
                data = 0xc;
                mask = 0xf;
                break;
            case bcmFieldLoopbackTypeMim:
                data = 0xb;
                mask = 0xf;
                break;
            case bcmFieldLoopbackTypeRedirect:
                data = 0x9;
                mask = 0xf;
                break;
            default:
                return (BCM_E_PARAM);
        }
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyLoopbackType, 
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_TunnelType
 * Purpose:
 *      Add tunnel type field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      tunnel_type - (IN) Data to qualify with.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TunnelType(int unit, 
                             bcm_field_entry_t entry, 
                             bcm_field_TunnelType_t tunnel_type)
{
    int               rv;   /* Operation return status. */
    uint32            data; /* HW data match criteria.  */
    uint32            mask; /* HW data mask.            */

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        BCM_IF_ERROR_RETURN(_bcm_field_td3_qualify_TunnelType(unit, tunnel_type,
                                                              &data,
                                                              &mask));
    } else
#endif
#if defined(BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        BCM_IF_ERROR_RETURN(_bcm_field_th3_qualify_TunnelType(tunnel_type,
                                                              &data,
                                                              &mask));
    } else
#endif
#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_td2_qualify_TunnelType(tunnel_type,
                                                              &data,
                                                              &mask
                                                              )
                            );
    } else
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_TunnelType(tunnel_type,
                                                              &data,
                                                              &mask
                                                              )
                            );
    } else
#endif
        {
            switch (tunnel_type) { 
            case bcmFieldTunnelTypeAny:
                data = 0x0;
                mask = 0x0;
                break;
            case bcmFieldTunnelTypeNone:
                data = 0x0;
                mask = 0xf;
                break;
            case bcmFieldTunnelTypeIp:
                data = 0x1;
                mask = 0xf;
                break;
            case bcmFieldTunnelTypeMpls:
                data = 0x2;
                mask = 0xf;
                break;
            case bcmFieldTunnelTypeMim:
                data = 0x3;
                mask = 0xf;
                break;
            case bcmFieldTunnelTypeWlanWtpToAc:
                data = 0x4;
                mask = 0xf;
                break;
            case bcmFieldTunnelTypeWlanAcToAc:
                data = 0x5;
                mask = 0xf;
                break;
            case bcmFieldTunnelTypeAutoMulticast:
                data = 0x6;
                mask = 0xf;
                break;
            case bcmFieldTunnelTypeTrill:
                data = 0x7;
                mask = 0xf;
                break;
            default:
                return (BCM_E_PARAM);
            }
        }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyTunnelType, 
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_DstL3Egress
 * Purpose:
 *     Add a destination egress object field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      if_id - (IN) Egress object id. 
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstL3Egress(int unit, 
                                  bcm_field_entry_t entry, 
                                  bcm_if_t if_id)
{
    int rv = BCM_E_UNAVAIL;   /* Operation return status. */
#if defined(INCLUDE_L3)
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    uint32 flags;           /* L3 forwarding flags      */
    int nh_ecmp_id;         /* Next hop/Ecmp group id.  */

    /* Get next hop id. */
    rv = bcm_xgs3_l3_egress_id_parse(unit, if_id, &flags, &nh_ecmp_id);
    BCM_IF_ERROR_RETURN(rv);

    if (flags & BCM_L3_MULTIPATH) {
        return (BCM_E_UNAVAIL);
    }

    data = nh_ecmp_id;
    mask = (BCM_FIELD_EXACT_MATCH_MASK);
    /*
     * Invoke driver function for multi pipe devices.
     */
    
#if defined(BCM_TOMAHAWK_SUPPORT)

    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
        if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
            /*Error fetching entry*/
            return (rv); 
        }
    
        if (rv == BCM_E_NONE) { /*Stage is Ingress*/ 
            FP_LOCK(unit);
            rv = _field_control_get(unit, &fc);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return rv;
            }
            rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstL3Egress,
                                          data, mask, 0);
            FP_UNLOCK(unit);
            return (rv);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    BCM_IF_ERROR_RETURN(_field_dest_type_qualify(unit,
                        entry, bcmFieldQualifyDstL3Egress, &data, &mask,
                        _bcmFieldDestTypeNone));

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstL3Egress, 
                          data, mask);

    FP_UNLOCK(unit);
#endif /* INCLUDE_L3 */
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_DstMulticastGroup
 * Purpose:
 *     Add a destination multicast group field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      group - (IN) Multicast group id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstMulticastGroup(int unit, 
                                        bcm_field_entry_t entry, 
                                        bcm_multicast_t group)
{
    _field_control_t *fc;   /* Field control structure. */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */
    _bcm_field_DestType_t ipmc_grp_type = _bcmFieldDestTypeNone; 
                                          /* IPMC group type. */

    /* Input parameters check. */
    if (0 == _BCM_MULTICAST_IS_SET(group)) {
        return (BCM_E_PARAM);
    }

    data  = _BCM_MULTICAST_ID_GET(group); 
    mask = (BCM_FIELD_EXACT_MATCH_MASK);

    if ( (_BCM_MULTICAST_IS_L3(group)) || (_BCM_MULTICAST_IS_VPLS(group)) ) {
        ipmc_grp_type = _bcmFieldDestTypeL3mc;
    } else if ( _BCM_MULTICAST_IS_L2(group)) {
        ipmc_grp_type = _bcmFieldDestTypeL2mc;
    } else {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_field_dest_type_qualify(unit, entry,
                        bcmFieldQualifyDstMulticastGroup, &data, &mask, 
                        ipmc_grp_type));

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstMulticastGroup,
                                          data, mask, 0);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstMulticastGroup, 
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcMplsGport
 * Purpose:
 *      Add source mpls port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      mpls_port_id - (IN) Mpls virtual port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcMplsGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t mpls_port_id)
{
    _field_control_t *fc;   /* Field control structure. */
    _field_group_t *fg;     /* Field group structure    */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */
    int ingress_entity = 0; /* Ingress entity or source entity */
    int i;

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_MPLS_PORT(mpls_port_id)) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

    /* Get the source virtual port value */
    data  = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id); 

    /* Include all bits for Mask value */
    mask = BCM_FIELD_EXACT_MATCH_MASK;

    

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Invoke driver function for multi pipe devices.
     */
#if defined(BCM_TOMAHAWK_SUPPORT)

    if (soc_feature(unit, soc_feature_field_multi_pipe_support) && 
        ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
         (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id))) {
        rv = fc->functions.fp_qualify_svp(unit, entry,
                                          bcmFieldQualifySrcMplsGport,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check which configuration of SrcMplsGport is in use */
    for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
        if (fg->sel_codes[i].ingress_entity_sel ==
                _bcmFieldFwdEntityMplsGport) {
            ingress_entity = 1;
            break;
        }
    }

    if (ingress_entity) {
        /* Internal qualifier to set SVP valid bit in Fixed field */
        rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 1, 1);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    /* Qualify Mpls Source Virtual Port */
    /* In Stage Lookup bcmFieldQualifySrcMplsGport = 20 bits 
       S_FIELD = 16 bits S_TYPE_SEL = 3 bits SVP_VALID = 1 bits
       S_TYPE_SEL = 0 and SVP_VALID = 1 implies S_FIELD = svp 
       ==> data = svp_valid|s_type_sel|s_field
     */
    rv = _field_qualify_source_virtual_port(unit, entry,
            bcmFieldQualifySrcMplsGport, data, mask, ingress_entity);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_DstMplsGport
 * Purpose:
 *      Add destination mpls port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      mpls_port_id - (IN)  Mpls virtual port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstMplsGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t mpls_port_id)
{
    _field_control_t *fc;   /* Field control structure. */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */
    _field_entry_t *f_ent;  /* Field entry structure.   */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_MPLS_PORT(mpls_port_id)) {
        return (BCM_E_PARAM);
    }

    data  = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id); 
    mask = (BCM_FIELD_EXACT_MATCH_MASK);

    
    
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
        bcmFieldQualifyDstMplsGport, &f_ent));

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Invoke driver function for multi pipe supported devices.
     */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        _BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) {
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstMplsGport,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */


    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /* 
         * LSB is DVP valid bit.
         * Shift DVP value by 1-bit,
         */
        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;
    } else {
        /* Qualify the destination type qualifier */
        rv = _field_dest_type_qualify(unit, entry,
                                     bcmFieldQualifyDstMplsGport, &data, &mask, 
                                     _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstMplsGport,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_SrcNivGport
 * Purpose:
 *      Add source niv port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      niv_port_id - (IN) Niv virtual port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcNivGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t niv_port_id)
{
    _field_control_t *fc;   /* Field control structure. */
    _field_group_t *fg;     /* Field group structure    */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */
    int ingress_entity = 0; /* Ingress entity or source entity */
    int i;

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_NIV_PORT(niv_port_id)) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

    /* Get the source virtual port value */
    data  = BCM_GPORT_NIV_PORT_ID_GET(niv_port_id); 
    /* Include all bits for Mask value */
    mask = BCM_FIELD_EXACT_MATCH_MASK;

    

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Invoke driver function for multi pipe supported devices.
     */
#if defined(BCM_TOMAHAWK_SUPPORT)

    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
         (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id))) {
        rv = fc->functions.fp_qualify_svp(unit, entry,
                                          bcmFieldQualifySrcNivGport,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check which configuration of SrcNivGport is in use */
    for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
        if (fg->sel_codes[i].ingress_entity_sel ==
                _bcmFieldFwdEntityNivGport) {
            ingress_entity = 1;
            break;
        }
    }

    if (ingress_entity) {
        /* Internal qualifier to set SVP valid bit in Fixed field */
        rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 1, 1);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    /* Qualify Niv Source Virtual Port */
    /* In Stage Lookup bcmFieldQualifySrcNivGport = 20 bits 
       S_FIELD = 16 bits S_TYPE_SEL = 3 bits SVP_VALID = 1 bits
       S_TYPE_SEL = 0 and SVP_VALID = 1 implies S_FIELD = svp 
       ==> data = svp_valid|s_type_sel|s_field
     */
    rv = _field_qualify_source_virtual_port(unit, entry,
            bcmFieldQualifySrcNivGport, data, mask, ingress_entity);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_DstNivGport
 * Purpose:
 *      Add destination niv port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      niv_port_id - (IN)  Niv virtual port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstNivGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t niv_port_id)
{
    _field_control_t *fc;   /* Field control structure. */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */
    _field_entry_t *f_ent;  /* Field entry structure.   */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_NIV_PORT(niv_port_id)) {
        return (BCM_E_PARAM);
    }

    data  = BCM_GPORT_NIV_PORT_ID_GET(niv_port_id); 
    mask = (BCM_FIELD_EXACT_MATCH_MASK);

    

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
                         bcmFieldQualifyDstNivGport, &f_ent));

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Invoke driver function for multi pipe supported devices.
     */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id)) {
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstNivGport,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /* 
         * LSB is DVP valid bit.
         * Shift DVP value by 1-bit,
         */
        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;
    } else {
        /* Qualify the destination type qualifier */
        rv = _field_dest_type_qualify(unit, entry,
                                      bcmFieldQualifyDstNivGport, &data, &mask,
                                      _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstNivGport,
                          data, mask);
    
    FP_UNLOCK(unit);

    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_SrcModPortGport
 * Purpose:
 *      Set match criteria for bcmFieildQualifySrcModPortGport
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcModPortGport(int unit, 
                                      bcm_field_entry_t entry, 
                                      bcm_gport_t port)
{
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_MODPORT(port)) {
        return (BCM_E_PARAM);
    }

    data  = BCM_GPORT_MODPORT_PORT_GET(port);
    data |= ((BCM_GPORT_MODPORT_MODID_GET(port)) << _FP_PORT_BITWIDTH(unit));
    mask = BCM_FIELD_EXACT_MATCH_MASK;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifySrcModPortGport, 
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcModuleGport
 * Purpose:
 *      Set match criteria for bcmFieildQualifySrcModuleGport
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcModuleGport(int unit, 
                                      bcm_field_entry_t entry, 
                                      bcm_gport_t port)
{
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_MODPORT(port)) {
        return (BCM_E_PARAM);
    }

    data = BCM_GPORT_MODPORT_MODID_GET(port);
    mask = BCM_FIELD_EXACT_MATCH_MASK;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifySrcModuleGport, 
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcMimGport
 * Purpose:
 *      Add source mac in mac port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      mim_port_id - (IN) Mim virtual port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcMimGport(int unit, 
                              bcm_field_entry_t entry, 
                              bcm_gport_t mim_port_id)
{
    _field_control_t *fc;   /* Field control structure. */
    _field_group_t *fg;     /* Field group structure    */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */
    int ingress_entity = 0; /* Ingress entity or source entity */
    int i;

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_MIM_PORT(mim_port_id)) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

    /* Get the source virtual port value */
    data  = BCM_GPORT_MIM_PORT_ID_GET(mim_port_id);
    /* Include all bits for Mask value */
    mask = BCM_FIELD_EXACT_MATCH_MASK;

    

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    /*
     * Invoke driver function for multi pipe supported devices.
     */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
         (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id))) {
        rv = fc->functions.fp_qualify_svp(unit, entry,
                                          bcmFieldQualifySrcMimGport,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check which configuration of SrcMimGport is in use */
    /* <HP>
       Check this for TR3; fields widths have changed.
       Similar logic for other SrcGport quals?
       </HP> */

    for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
        if (fg->sel_codes[i].ingress_entity_sel ==
                _bcmFieldFwdEntityMimGport) {
            ingress_entity = 1;
            break;
        }
    }

    if (ingress_entity) {
        /* Internal qualifier to set SVP valid bit in Fixed field */
        rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 1, 1);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }
    
    /* Qualify MiM Source Virtual Port */
    /* In Stage Lookup bcmFieldQualifySrcMimGport = 20 bits 
       S_FIELD = 16 bits S_TYPE_SEL = 3 bits SVP_VALID = 1 bits
       S_TYPE_SEL = 0 and SVP_VALID = 1 implies S_FIELD = svp 
       ==> data = svp_valid|s_type_sel|s_field
     */
    rv = _field_qualify_source_virtual_port(unit, entry,
            bcmFieldQualifySrcMimGport, data, mask, ingress_entity);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_DstMimGport
 * Purpose:
 *      Add destination mac in mac port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      mim_port_id - (IN) Mim virtual port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstMimGport(int unit, 
                              bcm_field_entry_t entry, 
                              bcm_gport_t mim_port_id)
{
    _field_control_t *fc;   /* Field control structure. */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */
    _field_entry_t *f_ent;  /* Field entry structure.   */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_MIM_PORT(mim_port_id)) {
        return (BCM_E_PARAM);
    }

    data  = BCM_GPORT_MIM_PORT_ID_GET(mim_port_id); 
    mask = (BCM_FIELD_EXACT_MATCH_MASK);

    
    
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
            bcmFieldQualifyDstMimGport, &f_ent));

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Invoke driver function for multi pipe supported devices.
     */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        _BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) {
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstMimGport,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */


    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /* 
         * LSB is DVP valid bit.
         * Shift DVP value by 1-bit,
         */
        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;
    } else {
        /* Qualify the destination type qualifier */
        rv = _field_dest_type_qualify(unit, entry,
                                      bcmFieldQualifyDstMimGport, &data, &mask, 
                                      _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstMimGport, 
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}



/*
 * Function:
 *      bcm_esw_field_qualify_SrcWlanGport
 * Purpose:
 *      Add source wlan port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      wlan_port_id - (IN) Wlan virtual port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcWlanGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t wlan_port_id)
{
    _field_control_t *fc;   /* Field control structure. */
    _field_group_t *fg;     /* Field group structure    */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */
    int ingress_entity = 0; /* Ingress entity or source entity */
    int i;

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_WLAN_PORT(wlan_port_id)) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

    data  = BCM_GPORT_WLAN_PORT_ID_GET(wlan_port_id);

    /* Include all bits for Mask value */
    mask = BCM_FIELD_EXACT_MATCH_MASK;

    

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    /*
     * Invoke driver function for multi pipe supported devices.
     */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
         (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id))) {
        rv = fc->functions.fp_qualify_svp(unit, entry,
                                          bcmFieldQualifySrcWlanGport,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check which configuration of SrcWlanGport is in use */
    for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
        if (fg->sel_codes[i].ingress_entity_sel ==
                _bcmFieldFwdEntityWlanGport) {
            ingress_entity = 1;
            break;
        }
    }

    if (ingress_entity) {
        /* Internal qualifier to set SVP valid bit in Fixed field */
        rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 1, 1);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    /* Qualify Wlan Source Virtual Port */
    /* In Stage Lookup bcmFieldQualifySrcWlanGport = 20 bits 
       S_FIELD = 16 bits S_TYPE_SEL = 3 bits SVP_VALID = 1 bits
       S_TYPE_SEL = 0 and SVP_VALID = 1 implies S_FIELD = svp 
       ==> data = svp_valid|s_type_sel|s_field
     */
    rv = _field_qualify_source_virtual_port(unit, entry,
            bcmFieldQualifySrcWlanGport, data, mask, ingress_entity);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstWlanGport
 * Purpose:
 *      Add destination wlan port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      wlan_port_id - (IN) Wlan virtual port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstWlanGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t wlan_port_id)
{
    _field_control_t *fc;   /* Field control structure. */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */
    _field_entry_t *f_ent;  /* Field entry structure.   */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_WLAN_PORT(wlan_port_id)) {
        return (BCM_E_PARAM);
    }

    data  = BCM_GPORT_WLAN_PORT_ID_GET(wlan_port_id); 
    mask = (BCM_FIELD_EXACT_MATCH_MASK);

    

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
            bcmFieldQualifyDstWlanGport, &f_ent));

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Invoke driver function for multi pipe supported devices.
     */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
        if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
            /*Error fetching entry*/
            FP_UNLOCK(unit);
            return (rv); 
        }
    
        if (rv == BCM_E_NONE) { /*Stage is Ingress*/ 
            rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstWlanGport,
                                          data, mask, 1);
            FP_UNLOCK(unit);
            return (rv);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /*
         * LSB is DVP valid bit.
         * Shift DVP value by 1-bit,
         */
        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;
    } else {
        /* Qualify the destination type qualifier */
        rv = _field_dest_type_qualify(unit, entry,
                                      bcmFieldQualifyDstWlanGport, &data,
                                      &mask, _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }
 
    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstWlanGport, 
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: 
 *      bcm_esw_field_qualify_SrcVxlanGport
 * Purpose:
 *      Add source vxlan port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      vxlan_port_id - (IN) vxlan virtual port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int
bcm_esw_field_qualify_SrcVxlanGport(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_gport_t vxlan_port_id)
{
    _field_control_t *fc;   /* Field control structure. */
    _field_group_t *fg;     /* Field group structure    */
    _field_entry_t *f_ent = NULL;  /* Field entry structure.   */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */
    int ingress_entity = 0; /* Ingress entity or source entity */
    int i;

    /* Input parameters check. */
    if ((0 == BCM_GPORT_IS_VXLAN_PORT(vxlan_port_id)) &&
        (0 == BCM_GPORT_IS_FLOW_PORT(vxlan_port_id))) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
            bcmFieldQualifySrcVxlanGport, &f_ent));
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)

    if (soc_feature(unit, soc_feature_flex_flow)
        && BCM_GPORT_IS_FLOW_PORT(vxlan_port_id)) {
        data  = BCM_GPORT_FLOW_PORT_ID_GET(vxlan_port_id);
        f_ent->svp_type = _bcmVpTypeFlow;
    } else {
        data  = BCM_GPORT_VXLAN_PORT_ID_GET(vxlan_port_id);
        f_ent->svp_type = _bcmVpTypeVxlan;
    }
#else
    data  = BCM_GPORT_FLOW_PORT_ID_GET(vxlan_port_id);
#endif

    /* Include all bits for Mask value */
    mask = BCM_FIELD_EXACT_MATCH_MASK;

    

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    /*
     * Invoke driver function for multi pipe supported devices.
     */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
         (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id))) {
        rv = fc->functions.fp_qualify_svp(unit, entry,
                                          bcmFieldQualifySrcVxlanGport,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check which configuration of SrcVxlanGport is in use */
    for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
        if (fg->sel_codes[i].ingress_entity_sel ==
                _bcmFieldFwdEntityVxlanGport) {
            ingress_entity = 1;
            break;
        }
    }

    if (ingress_entity) {
        /* Internal qualifier to set SVP valid bit in Fixed field */
        rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 1, 1);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    /* Qualify Vxlan Source Virtual Port */
    /* In Stage Lookup bcmFieldQualifySrcVxlanGport = 20 bits 
       S_FIELD = 16 bits S_TYPE_SEL = 3 bits SVP_VALID = 1 bits
       S_TYPE_SEL = 0 and SVP_VALID = 1 implies S_FIELD = svp 
       ==> data = svp_valid|s_type_sel|s_field
     */
    rv = _field_qualify_source_virtual_port(unit, entry,
            bcmFieldQualifySrcVxlanGport, data, mask, ingress_entity);

    FP_UNLOCK(unit);
    return (rv);

}

/*
 * Function:
 *      bcm_esw_field_qualify_DstVxlanGport
 * Purpose:
 *      Add destination vxlan port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      vxlan_port_id - (IN) Vxlan virtual port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int
bcm_esw_field_qualify_DstVxlanGport(int unit,
                               bcm_field_entry_t entry,
                               bcm_gport_t vxlan_port_id)
{
    _field_control_t *fc = NULL;   /* Field control structure. */
    uint32 data = 0 ;              /* HW data match criteria.  */
    uint32 mask = 0;               /* HW data mask.            */
    int rv = BCM_E_UNAVAIL;        /* Operation return status. */
    _field_entry_t *f_ent = NULL;  /* Field entry structure.   */

    /* Input parameters check. */
    if ((0 == BCM_GPORT_IS_VXLAN_PORT(vxlan_port_id)) &&
        (0 == BCM_GPORT_IS_FLOW_PORT(vxlan_port_id))) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
            bcmFieldQualifyDstVxlanGport, &f_ent));

    mask = (BCM_FIELD_EXACT_MATCH_MASK);

#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    if (soc_feature(unit, soc_feature_flex_flow)
        && BCM_GPORT_IS_FLOW_PORT(vxlan_port_id)) {
        data  = BCM_GPORT_FLOW_PORT_ID_GET(vxlan_port_id);
        f_ent->dvp_type = _bcmVpTypeFlow;
    } else {
        data  = BCM_GPORT_VXLAN_PORT_ID_GET(vxlan_port_id);
        f_ent->dvp_type = _bcmVpTypeVxlan;
    }
#else
    data  = BCM_GPORT_VXLAN_PORT_ID_GET(vxlan_port_id);
#endif
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Invoke driver function for multi pipe supported devices.
     */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        _BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) {
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstVxlanGport,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
#if defined(BCM_TRIDENT3_SUPPORT)
        /* For Trident3 devices, the dvp_valid field is set
         * _field_efp_qualify function based on the tcam key
         * selected with dvp selector
         */
        if (!soc_feature(unit, soc_feature_td3_style_fp)) {
            /*
             * LSB is DVP valid bit.
             * Shift DVP value by 1-bit,
             */
            data <<= 1;

            /* Set DVP Valid bit. */
            data |= 1;
        }
#else
        /*
         * LSB is DVP valid bit.
         * Shift DVP value by 1-bit,
         */
        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;
#endif /* BCM_TRIDENT3_SUPPORT */
    } else {
        /* Qualify the destination type qualifier */
        rv = _field_dest_type_qualify(unit, entry,
                                      bcmFieldQualifyDstVxlanGport, &data, 
                                      &mask, _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstVxlanGport,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

 
/*
 * Function:
 *      bcm_esw_field_qualify_SrcVlanGport
 * Purpose:
 *      Add source vlan port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      vlan_port_id - (IN) Vlan virtual port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcVlanGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t vlan_port_id)
{
    _field_control_t *fc;   /* Field control structure. */
    _field_group_t *fg;     /* Field group structure    */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */
    int ingress_entity = 0; /* Ingress entity or source entity */
    int i;

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_VLAN_PORT(vlan_port_id)) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

    /* Get the source virtual port value */
    data  = BCM_GPORT_VLAN_PORT_ID_GET(vlan_port_id);

    /* Include all bits for Mask value */
    mask = BCM_FIELD_EXACT_MATCH_MASK;

    

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    /*
     * Invoke driver function for multi pipe supported devices.
     */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
        
        if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
            /*Error fetching entry*/
            FP_UNLOCK(unit);
            return (rv); 
        }
    
        if (rv == BCM_E_NONE) { /*Stage is Ingress*/ 
            rv = fc->functions.fp_qualify_svp(unit, entry,
                                          bcmFieldQualifySrcVlanGport,
                                          data, mask, 1);
            FP_UNLOCK(unit);
            return (rv);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check which configuration of SrcVlanGport is in use */
    for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
        if (fg->sel_codes[i].ingress_entity_sel ==
                _bcmFieldFwdEntityVlanGport) {
            ingress_entity = 1;
            break;
        }
    }

    if (ingress_entity) {
        /* Internal qualifier to set SVP valid bit in Fixed field */
        rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 1, 1);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    /* Qualify Vlan Source Virtual Port */
    /* In Stage Lookup bcmFieldQualifySrcVlanGport = 20 bits
       S_FIELD = 16 bits S_TYPE_SEL = 3 bits SVP_VALID = 1 bits
       S_TYPE_SEL = 0 and SVP_VALID = 1 implies S_FIELD = svp
       ==> data = svp_valid|s_type_sel|s_field
     */
    rv = _field_qualify_source_virtual_port(unit, entry,
            bcmFieldQualifySrcVlanGport, data, mask, ingress_entity);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_DstVlanGport
 * Purpose:
 *      Add destination vlan port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      vlan_port_id - (IN)  Vlan virtual port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstVlanGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t vlan_port_id)
{
    _field_control_t *fc;   /* Field control structure. */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */
    _field_entry_t *f_ent;  /* Field entry structure.   */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_VLAN_PORT(vlan_port_id)) {
        return (BCM_E_PARAM);
    }

    data  = BCM_GPORT_VLAN_PORT_ID_GET(vlan_port_id);
    mask = (BCM_FIELD_EXACT_MATCH_MASK);

    


    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
                bcmFieldQualifyDstVlanGport, &f_ent));

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Invoke driver function for multi pipe supported devices.
     */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        _BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) {
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstVlanGport,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /*
         * LSB is DVP valid bit.
         * Shift DVP value by 1-bit,
         */
        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;
    } else {
        /* Qualify the destination type qualifier */
        rv = _field_dest_type_qualify(unit, entry,
                                      bcmFieldQualifyDstVlanGport, &data, &mask, 
                                      _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstVlanGport,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}
 
 

/*
 * Function: 
 *     bcm_esw_field_qualify_SrcClassL3
 * Purpose:
 *     Add Source L2 Class qualification data and mask to an entry.
 * Parameters:
 *     unit            - (IN) BCM unit number
 *     entry           - (IN) Entry ID
 *     data            - (IN) Source lookup class id. 
 *     mask            - (IN) Source lookup class mask. 
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_SrcClassL3(int unit, bcm_field_entry_t entry,
                                     uint32 data, uint32 mask)
{
    int                    rv;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
              (_bcm_field_th_qualify_class(unit, entry,
                                           bcmFieldQualifySrcClassL3,
                                           &data, &mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifySrcClassL3,
                                          &data,
                                          &mask
                                          )
            );
    } else
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class(unit,
                                                         entry,
                                                         bcmFieldQualifySrcClassL3,
                                                         &data,
                                                         &mask
                                                         )
                            );
    } else
#endif
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifySrcClassL3,
                                          &data,
                                          &mask
                                          ));
    } else
#endif /* BCM_KATANA2_SUPPORT */
        {
            /* Input parameters check. */
            if (data > SOC_ADDR_CLASS_MAX(unit)) {
                return (BCM_E_PARAM);
            }
        }
    
    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifySrcClassL3, 
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: 
 *     bcm_esw_field_qualify_SrcClassField
 * Purpose:
 *     Add Source Field Class qualification data and mask to an entry.
 * Parameters:
 *     unit            - (IN) BCM unit number
 *     entry           - (IN) Entry ID
 *     data            - (IN) Source lookup class id. 
 *     mask            - (IN) Source lookup class mask. 
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_SrcClassField(int unit, bcm_field_entry_t entry,
                                    uint32 data, uint32 mask)
{
    int                    rv;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class(unit, entry,
                                       bcmFieldQualifySrcClassField,
                                       &data, &mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifySrcClassField,
                                          &data,
                                          &mask
                                          )
            );
    } else
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class(unit,
                                                         entry,
                                                         bcmFieldQualifySrcClassField,
                                                         &data,
                                                         &mask
                                                         )
                            );
    } else
#endif    
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifySrcClassField,
                                          &data,
                                          &mask
                                          ));
    } else
#endif /* BCM_KATANA2_SUPPORT */
        {
            /* Input parameters check. */
            if (data > SOC_ADDR_CLASS_MAX(unit)) {
                return (BCM_E_PARAM);
            }
        }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifySrcClassField, 
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function: 
 *     bcm_esw_field_qualify_SrcClassL2
 * Purpose:
 *     Add Source Lookup Class qualification data and mask to an entry.
 * Parameters:
 *     unit            - (IN) BCM unit number
 *     entry           - (IN) Entry ID
 *     data            - (IN) Source lookup class id. 
 *     mask            - (IN) Source lookup class mask. 
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_SrcClassL2(int unit, bcm_field_entry_t entry,
                                     uint32 data, uint32 mask)
{
    int                    rv;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class(unit, entry,
                                       bcmFieldQualifySrcClassL2,
                                       &data, &mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifySrcClassL2,
                                          &data,
                                          &mask
                                          )
            );
    } else
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class(unit,
                                                         entry,
                                                         bcmFieldQualifySrcClassL2,
                                                         &data,
                                                         &mask
                                                         )
                            );
    } else
#endif
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifySrcClassL2,
                                          &data,
                                          &mask
                                          ));
    } else
#endif /* BCM_KATANA2_SUPPORT */
         {
            /* Input parameters check. */
            if (data > SOC_ADDR_CLASS_MAX(unit)) {
                return (BCM_E_PARAM);
            }
        }
    
    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifySrcClassL2, 
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function: 
 *     bcm_esw_field_qualify_DstClassL3
 * Purpose:
 *     Add Source L2 Class qualification data and mask to an entry.
 * Parameters:
 *     unit            - (IN) BCM unit number
 *     entry           - (IN) Entry ID
 *     data            - (IN) Source lookup class id. 
 *     mask            - (IN) Source lookup class mask. 
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_DstClassL3(int unit, bcm_field_entry_t entry,
                                     uint32 data, uint32 mask)
{
    int                    rv;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class(unit, entry,
                                       bcmFieldQualifyDstClassL3,
                                       &data, &mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyDstClassL3,
                                          &data,
                                          &mask
                                          )
            );
    } else
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class(unit,
                                                         entry,
                                                         bcmFieldQualifyDstClassL3,
                                                         &data,
                                                         &mask
                                                         )
                            );
    } else
#endif
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyDstClassL3,
                                          &data,
                                          &mask
                                          ));
    } else
#endif /* BCM_KATANA2_SUPPORT */
        {
            /* Input parameters check. */
            if (data > SOC_ADDR_CLASS_MAX(unit)) {
                return (BCM_E_PARAM);
            }
        }
    
    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstClassL3, 
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: 
 *     bcm_esw_field_qualify_DstClassField
 * Purpose:
 *     Add Source Field Class qualification data and mask to an entry.
 * Parameters:
 *     unit            - (IN) BCM unit number
 *     entry           - (IN) Entry ID
 *     data            - (IN) Source lookup class id. 
 *     mask            - (IN) Source lookup class mask. 
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_DstClassField(int unit, bcm_field_entry_t entry,
                                    uint32 data, uint32 mask)
{
    int                    rv;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class(unit, entry,
                                       bcmFieldQualifyDstClassField,
                                       &data, &mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyDstClassField,
                                          &data,
                                          &mask
                                          )
            );
    } else
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class(unit,
                                                         entry,
                                                         bcmFieldQualifyDstClassField,
                                                         &data,
                                                         &mask
                                                         )
                            );
    } else
#endif
 #ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyDstClassField,
                                          &data,
                                          &mask
                                          ));
    } else
#endif /* BCM_KATANA2_SUPPORT */
        {
            /* Input parameters check. */
            if (data > SOC_ADDR_CLASS_MAX(unit)) {
                return (BCM_E_PARAM);
            }
        }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstClassField, 
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function: 
 *     bcm_esw_field_qualify_DstClassL2
 * Purpose:
 *     Add Source Lookup Class qualification data and mask to an entry.
 * Parameters:
 *     unit            - (IN) BCM unit number
 *     entry           - (IN) Entry ID
 *     data            - (IN) Source lookup class id. 
 *     mask            - (IN) Source lookup class mask. 
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_DstClassL2(int unit, bcm_field_entry_t entry,
                                     uint32 data, uint32 mask)
{
    int                    rv;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class(unit, entry,
                                       bcmFieldQualifyDstClassL2,
                                       &data, &mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyDstClassL2,
                                          &data,
                                          &mask
                                          )
            );
    } else
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class(unit,
                                                         entry,
                                                         bcmFieldQualifyDstClassL2,
                                                         &data,
                                                         &mask
                                                         )
                            );
    } else
#endif
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyDstClassL2,
                                          &data,
                                          &mask
                                          ));
    } else
#endif /* BCM_KATANA2_SUPPORT */

        {
            /* Input parameters check. */
            if (data > SOC_ADDR_CLASS_MAX(unit)) {
                return (BCM_E_PARAM);
            }
        }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstClassL2, 
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function: bcm_esw_field_qualify_InnerIpType
 *
 * Purpose:
 *     Add qualification data to an entry for IP Type.
 *
 * Parameters:
 *     unit     - BCM unit number
 *     entry    - Entry ID
 *     type     - Ip type
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_InnerIpType(int unit, bcm_field_entry_t entry,
                             bcm_field_IpType_t type)
{
    _field_entry_t      *f_ent;
    _field_control_t    *fc;
    int                 rv;

    if (type >= bcmFieldIpTypeCount) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);

    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = fc->functions.fp_qualify_ip_type(unit, entry, type, 
                                          bcmFieldQualifyInnerIpType);
    
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_qualify_ForwardingType
 *
 * Purpose:
 *     Add qualification data to an entry for IP Type.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number.
 *     entry    - (IN) Entry ID.
 *     type     - (IN) Forwarding type.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_ForwardingType(int unit, bcm_field_entry_t entry,
                                     bcm_field_ForwardingType_t type)
{
    _field_stage_id_t stage_id;
    int               rv;       /* Operation return structure. */
    uint32            data = 0; /* HW qualifier value.         */
    uint32            mask = 0; /* HW qualifier mask.          */

    if (type >= bcmFieldForwardingTypeCount) {
        return (BCM_E_PARAM);
    }

    

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) && 
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
        stage_id = _BCM_FIELD_STAGE_INGRESS;
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
       _field_entry_t *f_ent;

       /* Retrieve Field entry structure. */
       BCM_IF_ERROR_RETURN(_field_entry_get(unit, entry,
                               _FP_ENTRY_PRIMARY, &f_ent));

       stage_id = f_ent->group->stage_id;
    }

    switch (stage_id) {
    case _BCM_FIELD_STAGE_INGRESS:
    case _BCM_FIELD_STAGE_EXACTMATCH:
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
#if defined(BCM_TRIDENT3_SUPPORT)
            if (soc_feature(unit, soc_feature_td3_style_fp)) {
               BCM_IF_ERROR_RETURN
                    (_bcm_field_td3_forwardingType_set(unit, stage_id, entry, type,
                                               &data, &mask));
            } else
#endif
#if defined(BCM_TOMAHAWK3_SUPPORT)
            if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
               BCM_IF_ERROR_RETURN
                    (_bcm_field_th3_forwardingType_set(unit, stage_id, entry, type,
                                               &data, &mask));
            } else
#endif
            {
           BCM_IF_ERROR_RETURN
             (_bcm_field_th_forwardingType_set(unit, stage_id, entry, type,
                                               &data, &mask));
            }
        } else
#endif /* BCM_TOMAHAWK_SUPPORT */
        {
          switch (type) {
            case bcmFieldForwardingTypeAny:
                data = 0;
                mask = 0;
                break;
            case bcmFieldForwardingTypeL2:
                data = 0;
                mask = 6;
                break;
            case bcmFieldForwardingTypeL2Independent:
                data = 0;
                mask = 7;
                break;
            case bcmFieldForwardingTypeL2Shared:
                data = 1;
                mask = 7;
                break;
            case bcmFieldForwardingTypeL2Vpn:
                data = 2;
                mask = 7;
                break;
            case bcmFieldForwardingTypeL2VpnDirect:
                data = 3;
                mask = 7;
                break;
            case bcmFieldForwardingTypeL3Direct:
                data = 4;
                mask = 7;
                break;
            case bcmFieldForwardingTypeL3:
                data = 5;
                mask = 7;
                break;
            case bcmFieldForwardingTypeMpls:
                data = 7;
                mask = 7;
                break;
            default:
               return (BCM_E_PARAM);
          }
        }
        break;

    case _BCM_FIELD_STAGE_EXTERNAL:
        /* N.B. Currently only supported on Triumph2 */

        switch (type) {
        case bcmFieldForwardingTypeAny:
            data = 0;
            mask = 0;
            break;
        case bcmFieldForwardingTypeL2:
            data = 0;
            mask = 1;
#ifdef BCM_TRIUMPH3_SUPPORT
            if (SOC_IS_TRIUMPH3(unit)) {
                mask = 0x3;
            }
#endif
            break;
        case bcmFieldForwardingTypeL2Vpn:
            data = 1;
            mask = 1;
#ifdef BCM_TRIUMPH3_SUPPORT
            if (SOC_IS_TRIUMPH3(unit)) {
                mask = 0x3;
            }
#endif
            break;
#ifdef BCM_TRIUMPH3_SUPPORT
        case bcmFieldForwardingTypeL3:
            if (SOC_IS_TRIUMPH3(unit)) {
                data = 0x2;
                mask = 0x3;
            } else {
                return (BCM_E_PARAM);
            }
            break;
#endif
        default:
            return (BCM_E_PARAM);
        }

        break;

    case _BCM_FIELD_STAGE_EGRESS:

#ifdef BCM_TRIUMPH3_SUPPORT
        /* Currently supported for some devices. For other devices, the default
         * case hits and BCM_E_INTERNAL is returned
         */
        if ((SOC_IS_KATANA2(unit)) || (SOC_IS_TRIUMPH3(unit)) ||
            (SOC_IS_TD2_TT2(unit))) {
            switch (type) {
                case bcmFieldForwardingTypeAny:
                    data = 0;
                    mask = 0;
                    break;
                case bcmFieldForwardingTypeL2Independent:
                    data = 1;
                    mask = 3;
                    break;
                case bcmFieldForwardingTypeL2Vpn:
                    data = 2;
                    mask = 3;
                    break;
                case bcmFieldForwardingTypeL3:
                    data = 3;
                    mask = 3;
                    break;
                default:
                    return (BCM_E_PARAM);
            }

            break;
        }
#endif
        return (BCM_E_INTERNAL);

#if defined(BCM_FLOWTRACKER_SUPPORT)
    case _BCM_FIELD_STAGE_FLOWTRACKER:
        if (soc_feature(unit, soc_feature_field_flowtracker_support)) {
            switch(type) {
                case bcmFieldForwardingTypeAny:
                    data = 0;
                    mask = 0;
                    break;
                case bcmFieldForwardingTypeL2Independent:
                    data = 0;
                    mask = 3;
                    break;
                case bcmFieldForwardingTypeL2Vpn:
                    data = 1;
                    mask = 3;
                    break;
                default:
                    return (BCM_E_PARAM);
            }
            break;
        }
#endif
    default:
        return (BCM_E_INTERNAL);
    }

    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyForwardingType, 
                          data, mask);

    FP_UNLOCK(unit);

    return (rv);
}

/*
 * Function: bcm_esw_field_qualify_IpType
 *
 * Purpose:
 *     Add qualification data to an entry for IP Type.
 *
 * Parameters:
 *     unit     - BCM unit number
 *     entry    - Entry ID
 *     type     - Ip type
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_IpType(int unit, bcm_field_entry_t entry,
                             bcm_field_IpType_t type)
{
    _field_control_t    *fc;
    int                 rv;

    if (type >= bcmFieldIpTypeCount) {
        return (BCM_E_PARAM);
    }
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if ((soc_feature(unit, soc_feature_field_multi_pipe_support) &&
         soc_feature(unit, soc_feature_field_preselector_support) &&
         (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == FALSE)) ||
        (!(soc_feature(unit, soc_feature_field_multi_pipe_support))))
#endif
    {
       _field_entry_t      *f_ent = NULL;  /* Field entry structure.   */
       _field_group_t      *f_grp = NULL;  /* Field group structure.   */

       rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
       if (BCM_FAILURE(rv)){
          FP_UNLOCK(unit);
          return (rv);
       }
       f_grp = f_ent->group;
       if (BCM_FIELD_QSET_TEST(f_grp->qset, bcmFieldQualifyIp4) &&
                (0 ==BCM_FIELD_QSET_TEST(f_grp->qset, bcmFieldQualifyIp6) )) {
            if ((type >= bcmFieldIpTypeIpv6NoExtHdr) && (type <= bcmFieldIpTypeIpv6)) {
                 /* Qset is set with Ip4*/
                 FP_UNLOCK(unit);
                 return (BCM_E_PARAM);
            }
        } else if (BCM_FIELD_QSET_TEST(f_grp->qset, bcmFieldQualifyIp6) &&
                 (0 == BCM_FIELD_QSET_TEST(f_grp->qset, bcmFieldQualifyIp4))) {
            if ((type >= bcmFieldIpTypeIpv4NoOpts) && (type <= bcmFieldIpTypeIpv4Any)) {
                 /* Qset is set with Ip6*/
                 FP_UNLOCK(unit);
                 return (BCM_E_PARAM);
            }
       }
    }
    rv = fc->functions.fp_qualify_ip_type(unit, entry, type,
                                          bcmFieldQualifyIpType);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_qualify_L2Format
 *
 * Purpose:
 *     Add qualification data to an entry for L2 Format.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number.
 *     entry    - (IN) Entry id.
 *     type     - (IN) Ehternet frame type.
 *
 * Returns:
 *     BCM_E_XXX 
 */
int
bcm_esw_field_qualify_L2Format(int unit, bcm_field_entry_t entry,
                               bcm_field_L2Format_t type)
{
    uint32              data;    /* L2 format encoding.      */
    uint32              mask;    /* L2 format mask.          */
    int                 rv;      /* Operation return status. */

    if (type >= bcmFieldL2FormatCount) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    switch (type) {
      case bcmFieldL2FormatAny:
          data = 0x0;
          mask = 0x0;
          break; 
      case bcmFieldL2FormatEthII:
          data = 0x0;
          mask = 0x3;
          break;
      case bcmFieldL2FormatSnap:
          if ((soc_feature(unit, soc_feature_td3_style_fp)) &&
              !soc_feature(unit, soc_feature_snap)) {
              FP_UNLOCK(unit);
              return BCM_E_PARAM;
          }
          data = 0x1;
          mask = 0x3;
          break;
      case bcmFieldL2FormatLlc:
      case bcmFieldL2Format802dot3:
          data = 0x2;
          mask = 0x3;
          break;
      default:
          FP_UNLOCK(unit);
          LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: %d not supported\n"),
                     unit, type));
          return (BCM_E_UNAVAIL);
    }
    rv = _field_qualify32(unit, entry, bcmFieldQualifyL2Format, data, mask);
    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function: bcm_esw_field_qualify_VlanFormat
 *
 * Purpose:
 *     Add qualification data to an entry for Vlan Tag Format.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number.
 *     entry    - (IN) Entry ID.
 *     data     - (IN) Outer & Inner tag presence info.
 *     mask     - (IN) Data mask.
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_VlanFormat(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
{
    int                 rv;      /* Operation return status. */

    
    FP_LOCK(unit);
    rv = _field_qualify_VlanFormat(unit, entry, bcmFieldQualifyVlanFormat,
                                   data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function: bcm_esw_field_qualify_MHOpcode
 *
 * Purpose:
 *     Add qualification data to an entry for mh opcode. 
 *
 * Parameters:
 *     unit     - (IN) BCM unit number.
 *     entry    - (IN) Entry ID.
 *     data     - (IN) Outer & Inner tag presence info.
 *     mask     - (IN) Data mask.
 * Returns:
 *     BCM_E_XXX     
 */
int
bcm_esw_field_qualify_MHOpcode(int unit, bcm_field_entry_t entry,
                               uint8 data, uint8 mask)
{
    int                 rv;      /* Operation return status. */

    if (data > BCM_FIELD_MHOPCODE_IPMULTICAST) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: data=%d too large.\n"),
                   unit, data));
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMHOpcode, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_Decap
 * Purpose:
 *     Set DECAP qualification data to an entry.
 * Parameters:
 *     unit  - (IN) Unit number.
 *     entry - (IN) BCM field entry id.
 *     decap - (IN) Decap type to qualify on
 * Returns:
 *     BCM_E_NONE   - Success
 *     BCM_E_PARAM  - invalid decap value
 */
int
bcm_esw_field_qualify_Decap(int unit, bcm_field_entry_t entry,
                            bcm_field_decap_t decap)
{
    int rv = BCM_E_UNAVAIL;
#ifdef BCM_GREYHOUND2_SUPPORT
    uint32 data = 0;  /* HW data match criteria */
    uint32 mask = 0;  /* HW data mask */

    if (soc_feature(unit, soc_feature_vxlan_lite_riot)) {
        /* Range check decap value */
        if ((decap < bcmFieldDecapNone) ||
            (decap >= bcmFieldDecapCount)) {
            return BCM_E_PARAM;
        }

        /* Check for valid decap value */
        switch (decap) {
            case bcmFieldDecapNone:
                data = 0x0;
                mask = 0x1;
                break;
            case bcmFieldDecapVxlan:
                data = 0x1;
                mask = 0x1;
                break;
            default:
                return BCM_E_PARAM;
        }

        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyDecap,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceClassMplsLookup1_get
 *
 * Purpose:
 *    To get qualified inputs on Class identifier derived from MPLS label 1 entry Lookup
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_InterfaceClassMplsLookup1_get(
                        int unit,
                        bcm_field_entry_t entry_id,
                        uint16 *data,
                        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint16_get(unit,
                                                   entry_id, 
                                                   bcmFieldQualifyInterfaceClassMplsLookup1,
                                                   data,
                                                   mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceClassMplsLookup2_get
 *
 * Purpose:
 *    To get qualified inputs on Class identifier derived from MPLS label 2 entry Lookup
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_InterfaceClassMplsLookup2_get(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint16_get(unit,
                                                   entry_id,
                                                   bcmFieldQualifyInterfaceClassMplsLookup2,
                                                   data,
                                                   mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceClassMplsLookup3_get
 *
 * Purpose:
 *    To get qualified inputs on Class identifier derived from MPLS label 3 entry Lookup
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_InterfaceClassMplsLookup3_get(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceClassL3Tunnel_get
 *
 * Purpose:
 *    To get qualified inputs on Class identifier derived from L3 Tunnel
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_InterfaceClassL3Tunnel_get(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint16_get(unit,
                                                   entry_id,
                                                   bcmFieldQualifyInterfaceClassL3Tunnel,
                                                   data,
                                                   mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceClassMplsLookup1
 *
 * Purpose:
 *    To qualify on Class identifier derived from MPLS label 1 entry Lookup
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_InterfaceClassMplsLookup1(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        if (data >> 12) {
            return (BCM_E_PARAM);
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit,
                              entry_id,
                              bcmFieldQualifyInterfaceClassMplsLookup1,
                              data,
                              mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceClassMplsLookup2
 *
 * Purpose:
 *    To qualify on Class identifier derived from MPLS label 2 entry Lookup
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_InterfaceClassMplsLookup2(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        if (data >> 12) {
            return (BCM_E_PARAM);
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit,
                              entry_id,
                              bcmFieldQualifyInterfaceClassMplsLookup2,
                              data,
                              mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceClassMplsLookup3
 *
 * Purpose:
 *    To qualify on Class identifier derived from MPLS label 3 entry Lookup
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_InterfaceClassMplsLookup3(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}
/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceClassL3Tunnel
 *
 * Purpose:
 *    To qualify on Class identifier derived from L3 Tunnel
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_InterfaceClassL3Tunnel(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        if (data >> 12) {
            return (BCM_E_PARAM);
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit,
                              entry_id,
                              bcmFieldQualifyInterfaceClassL3Tunnel,
                              data,
                              mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}


/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerGroupId
 *
 * Purpose:
 *    Qualifies on Flow group id assigned(bcmFieldActionFlowtrackerGroupId)
 *    by FlowTracker based Field Processor Stage
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerGroupId(
               int unit,
               bcm_field_entry_t entry_id,
               int data,
               int mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        if (data >> 16) {
            return BCM_E_PARAM;
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry_id,
                              bcmFieldQualifyFlowtrackerGroupId,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return (rv);
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerGroupId_get
 *
 * Purpose:
 *    To get qualified inputs on Flow group id assigned(bcmFieldActionFlowtrackerGroupId)
 *    by FlowTracker based Field Processor Stage
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerGroupId_get(
               int unit,
               bcm_field_entry_t entry_id,
               int *data,
               int *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry_id,
                                               bcmFieldQualifyFlowtrackerGroupId,
                                               (uint32 *)data, (uint32 *)mask);
    }
#endif

    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerClassId
 *
 * Purpose:
 *    Qualifies on Classifier ID from Flowtracker group
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerClassId(
               int unit,
               bcm_field_entry_t entry_id,
               int data,
               int mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        if (data >> 16) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry_id,
                              bcmFieldQualifyFlowtrackerClassId,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return (rv);
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerClassId_get
 *
 * Purpose:
 *    To get qualified inputs on Classifier ID from Flowtracker group
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerClassId_get(
               int unit,
               bcm_field_entry_t entry_id,
               int *data,
               int *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry_id,
                                               bcmFieldQualifyFlowtrackerClassId,
                                               (uint32 *)data, (uint32 *)mask);
    }
#endif

    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerGroupValid
 *
 * Purpose:
 *    Qualifies on event Flowtracker group valid or not
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerGroupValid(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        if (data >> 1) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: data=%d too large.\n"),
                       unit, data));
            return BCM_E_PARAM;
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry_id,
                              bcmFieldQualifyFlowtrackerGroupValid,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerGroupValid_get
 *
 * Purpose:
 *    To get qualified inputs on event Flowtracker group valid or not
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerGroupValid_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                                 bcmFieldQualifyFlowtrackerGroupValid,
                                 data, mask);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerDisabled
 *
 * Purpose:
 *    Qualifies on event whether Flowtracker flow tracking is disabled.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerDisabled(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        if (data >> 1) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: data=%d too large.\n"),
                       unit, data));
            return BCM_E_PARAM;
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry_id,
                              bcmFieldQualifyFlowtrackerDisabled,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerDisabled_get
 *
 * Purpose:
 *    To get qualified inputs on event whether Flowtracker flow tracking is disabled.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerDisabled_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                                 bcmFieldQualifyFlowtrackerDisabled,
                                 data, mask);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerMeteringExceeded
 *
 * Purpose:
 *    Qualifies on event whether Flowtracker metering is exceeded.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerMeteringExceeded(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        if (data >> 1) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: data=%d too large.\n"),
                       unit, data));
            return BCM_E_PARAM;
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry_id,
                              bcmFieldQualifyFlowtrackerMeteringExceeded,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerMeteringExceeded_get
 *
 * Purpose:
 *    To get qualified inputs on event whether Flowtracker metering is exceeded.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerMeteringExceeded_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                                bcmFieldQualifyFlowtrackerMeteringExceeded,
                                data, mask);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerCollectorCopy
 *
 * Purpose:
 *    Qualifies on the event whether initial or sample copied to collector
 *    happened by Flowtracker
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerCollectorCopy(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        if (data >> 1) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: data=%d too large.\n"),
                       unit, data));
            return BCM_E_PARAM;
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry_id,
                              bcmFieldQualifyFlowtrackerCollectorCopy,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerCollectorCopy_get
 *
 * Purpose:
 *    To get qualified inputs on the event whether initial or sample copied to collector
 *    happened by Flowtracker
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerCollectorCopy_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                                 bcmFieldQualifyFlowtrackerCollectorCopy,
                                 data, mask);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerFlowTableFull
 *
 * Purpose:
 *    Qualifies on the Flowtracker event whether the flow table is full.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerFlowTableFull(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        if (data >> 1) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: data=%d too large.\n"),
                       unit, data));
            return BCM_E_PARAM;
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry_id,
                              bcmFieldQualifyFlowtrackerFlowTableFull,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerFlowTableFull_get
 *
 * Purpose:
 *    To get qualified inputs on the Flowtracker event whether the flow table is full.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerFlowTableFull_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                                 bcmFieldQualifyFlowtrackerFlowTableFull,
                                 data, mask);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerGroupFlowExceeded
 *
 * Purpose:
 *    Qualifies on the event whether flow limit for Flowtracker is exceeded.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerGroupFlowExceeded(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        if (data >> 1) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: data=%d too large.\n"),
                       unit, data));
            return BCM_E_PARAM;
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry_id,
                              bcmFieldQualifyFlowtrackerGroupFlowExceeded,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerGroupFlowExceeded_get
 *
 * Purpose:
 *    To get qualified inputs on the event whether flow limit for Flowtracker is exceeded.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerGroupFlowExceeded_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                                 bcmFieldQualifyFlowtrackerGroupFlowExceeded,
                                 data, mask);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerExportQueueFull
 *
 * Purpose:
 *    Qualifies on the event whether Flowtracker export queue is full.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerExportQueueFull(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        if (data >> 1) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: data=%d too large.\n"),
                       unit, data));
            return BCM_E_PARAM;
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry_id,
                              bcmFieldQualifyFlowtrackerExportQueueFull,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_FlowtrackerExportQueueFull_get
 *
 * Purpose:
 *    To get qualified inputs on the event whether Flowtracker export queue is full.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FlowtrackerExportQueueFull_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                                 bcmFieldQualifyFlowtrackerExportQueueFull,
                                 data, mask);
    }
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MacSecTagPresent
 *
 * Purpose:
 *    To qualify the MACSEC tagged packets
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */

int
bcm_esw_field_qualify_MacSecTagPresent(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_MONTEREY_SUPPORT) && defined(INCLUDE_XFLOW_MACSEC)

    if (data >> 1) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: data=%d too large.\n"),
                   unit, data));
        return BCM_E_PARAM;
    }

    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry_id, bcmFieldQualifyMacSecTagPresent, data, mask);

    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MacSecTagPresent_get
 *
 * Purpose:
 *    To get the qualified inputs on the MACSEC tagged packets
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_MacSecTagPresent_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_MONTEREY_SUPPORT) && defined(INCLUDE_XFLOW_MACSEC)

    if ((NULL == data) || (NULL == mask)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: NULL pointer passed as parameter.\n"),
                   unit));
        return BCM_E_PARAM;
    }
    
    rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                             bcmFieldQualifyMacSecTagPresent,
                             data, mask);
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MacSecTag
 *
 * Purpose:
 *    To qualify on the SecTag field in MACSEC tagged packets
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_MacSecTag(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_MONTEREY_SUPPORT) && defined(INCLUDE_XFLOW_MACSEC)
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry_id, bcmFieldQualifyMacSecTag, data, mask);

    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MacSecTag_get
 *
 * Purpose:
 *    To get the qualified inputs on SecTag field in MACSEC tagged packets
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_MacSecTag_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_MONTEREY_SUPPORT) && defined(INCLUDE_XFLOW_MACSEC)

    if ((NULL == data) || (NULL == mask)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: NULL pointer passed as parameter.\n"),
                   unit));
        return BCM_E_PARAM;
    }
    
    rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                             bcmFieldQualifyMacSecTag,
                             data, mask);
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MacSecDstMacRangeHit
 *
 * Purpose:
 *    To qualify the hit on Destination MAC addresses range
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_MacSecDstMacRangeHit(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if (defined(BCM_MONTEREY_SUPPORT) || (defined(BCM_HURRICANE4_SUPPORT)) && defined(INCLUDE_XFLOW_MACSEC)) || (defined(BCM_CHANNELIZED_SWITCHING_SUPPORT))

    if (data >> 1) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: data=%d too large.\n"),
                   unit, data));
        return BCM_E_PARAM;
    }

    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry_id, bcmFieldQualifyMacSecDstMacRangeHit, data, mask);

    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MacSecDstMacRangeHit_get
 *
 * Purpose:
 *     To get the qualified inputs on the Destination MAC addresses range hit 
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_MacSecDstMacRangeHit_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if (defined(BCM_MONTEREY_SUPPORT) || (defined(BCM_HURRICANE4_SUPPORT)) && defined(INCLUDE_XFLOW_MACSEC)) || (defined(BCM_CHANNELIZED_SWITCHING_SUPPORT))

    if ((NULL == data) || (NULL == mask)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: NULL pointer passed as parameter.\n"),
                   unit));
        return BCM_E_PARAM;
    }
    
    rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                             bcmFieldQualifyMacSecDstMacRangeHit,
                             data, mask);
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_macsec_DstMacRange_set
 *
 * Purpose:
 *    Configures lower and upper limits to be used by qualifier bcmFieldQualifyMacSecDstMacRangeHit
 *
 * Parameters:
 *    unit              BCM device number
 *    lower_limit       Floor value of Destination Mac Address range
 *    upper_limit       Ceil value of Destination Mac Address range
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 */
int
bcm_esw_field_macsec_DstMacRange_set(
               int unit,
               bcm_mac_t lower_limit,
               bcm_mac_t upper_limit)
{
    int    rv = BCM_E_UNAVAIL;

#if (defined(BCM_MONTEREY_SUPPORT) || (defined(BCM_HURRICANE4_SUPPORT)) && defined(INCLUDE_XFLOW_MACSEC)) || (defined(BCM_CHANNELIZED_SWITCHING_SUPPORT))
    uint64 lower_mac, upper_mac;
    macsec_da_range_entry_t buf;
    mac_da_range_check_entry_t buf1;

    COMPILER_64_ZERO(lower_mac);
    COMPILER_64_ZERO(upper_mac);

    SAL_MAC_ADDR_TO_UINT64(lower_limit, lower_mac);
    SAL_MAC_ADDR_TO_UINT64(upper_limit, upper_mac);
    if (COMPILER_64_GE(lower_mac, upper_mac)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: lower limit MAC address is greater than"
                              " upper limit MAC address.\n"),
                   unit));
        return BCM_E_PARAM;
    }
    if(SOC_MEM_IS_VALID (unit, MACSEC_DA_RANGEm)) {
        soc_mem_mac_addr_set(unit, MACSEC_DA_RANGEm, &buf, LOWERf, lower_limit);
        soc_mem_mac_addr_set(unit, MACSEC_DA_RANGEm, &buf, UPPERf, upper_limit);
        rv = soc_mem_write(unit, MACSEC_DA_RANGEm, SOC_BLOCK_ALL, 0, &buf);
    } else if (SOC_MEM_IS_VALID (unit, MAC_DA_RANGE_CHECKm)) {
        soc_mem_mac_addr_set(unit, MAC_DA_RANGE_CHECKm, &buf1, LOWER_BOUNDSf, lower_limit);
        soc_mem_mac_addr_set(unit, MAC_DA_RANGE_CHECKm, &buf1, UPPER_BOUNDSf, upper_limit);
        rv = soc_mem_write(unit, MAC_DA_RANGE_CHECKm, SOC_BLOCK_ALL, 0, &buf1);
    }

#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_macsec_DstMacRange_get
 *
 * Purpose:
 *    To get the configured lower and upper limits to be used by qualifier bcmFieldQualifyMacSecDstMacRangeHit
 *
 * Parameters:
 *    unit              BCM device number
 *    lower_limit       Floor value of Destination Mac Address range
 *    upper_limit       Ceil value of Destination Mac Address range
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 */
int
bcm_esw_field_macsec_DstMacRange_get(
               int unit,
               bcm_mac_t *lower_limit,
               bcm_mac_t *upper_limit)
{
    int    rv = BCM_E_UNAVAIL;

#if (defined(BCM_MONTEREY_SUPPORT) || (defined(BCM_HURRICANE4_SUPPORT)) && defined(INCLUDE_XFLOW_MACSEC)) || (defined(BCM_CHANNELIZED_SWITCHING_SUPPORT))
    macsec_da_range_entry_t buf;
    mac_da_range_check_entry_t buf1;

    if ((NULL == lower_limit) || (NULL == upper_limit)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: NULL pointer passed as parameter.\n"),
                   unit));
        return BCM_E_PARAM;
    }
    if(SOC_MEM_IS_VALID (unit, MACSEC_DA_RANGEm)) {
        rv = soc_mem_read(unit, MACSEC_DA_RANGEm, SOC_BLOCK_ALL, 0, &buf);
        BCM_IF_ERROR_RETURN(rv);

        soc_mem_mac_addr_get(unit, MACSEC_DA_RANGEm, &buf, UPPERf, *upper_limit);
        soc_mem_mac_addr_get(unit, MACSEC_DA_RANGEm, &buf, LOWERf, *lower_limit);
    } else if(SOC_MEM_IS_VALID (unit, MAC_DA_RANGE_CHECKm)) {
         rv = soc_mem_read(unit, MAC_DA_RANGE_CHECKm, SOC_BLOCK_ALL, 0, &buf1);
        BCM_IF_ERROR_RETURN(rv);

        soc_mem_mac_addr_get(unit, MAC_DA_RANGE_CHECKm, &buf1, UPPER_BOUNDSf, *upper_limit);
        soc_mem_mac_addr_get(unit, MAC_DA_RANGE_CHECKm, &buf1, LOWER_BOUNDSf, *lower_limit);
   }
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_FromMacSecPort
 *
 * Purpose:
 *   To qualify on packet forwarded through the internal MACSEC port
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FromMacSecPort(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_MONTEREY_SUPPORT) && defined(INCLUDE_XFLOW_MACSEC)

    if (data >> 1) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: data=%d too large.\n"),
                   unit, data));
        return BCM_E_PARAM;
    }

    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry_id, bcmFieldQualifyFromMacSecPort, data, mask);

    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_FromMacSecPort_get
 *
 * Purpose:
 *   To get the qualified inputs on packet forwarded through the internal MACSEC port
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_FromMacSecPort_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_MONTEREY_SUPPORT) && defined(INCLUDE_XFLOW_MACSEC)

    if ((NULL == data) || (NULL == mask)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: NULL pointer passed as parameter.\n"),
                   unit));
        return BCM_E_PARAM;
    }
    
    rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                             bcmFieldQualifyFromMacSecPort,
                             data, mask);
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MacsecControlPkt
 *
 * Purpose:
 *   Qualifies on the MACSEC control packets
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_MacSecControlPkt(
               int unit,
               bcm_field_entry_t entry_id,
               bcm_field_macsec_encrypt_decrypt_pkt_t data)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HURRICANE4_SUPPORT) && defined(INCLUDE_XFLOW_MACSEC) && defined(CANCUN_SUPPORT)
    soc_cancun_ceh_field_info_t ceh_info1;
    soc_cancun_ceh_field_info_t ceh_info2;
    int    rv1 = BCM_E_UNAVAIL;
    int    rv2 = BCM_E_UNAVAIL;

    if (soc_feature(unit, soc_feature_cancun)) {
        /* HR4 only qualifying control packets */
        if (data != bcmFieldMacSecEncryptDecryptPktControl) {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: data=%d too large.\n"),
                     unit, data));
            return BCM_E_PARAM;
        }

        rv1 = soc_cancun_ceh_obj_field_get(unit, "EXTRACTION_CTRL_ID",
                "MACSEC_ENCRYPT_RX_ADD_SVTAG_FOR_CONTROL_PKT", &ceh_info1);
        rv2 = soc_cancun_ceh_obj_field_get(unit, "EXTRACTION_CTRL_ID",
                "MACSEC_ENCRYPT_RX_ADD_SVTAG_FOR_CONTROL_PKT_MASK", &ceh_info2);
        if (SOC_FAILURE(rv1) || SOC_FAILURE(rv2)) {
            return BCM_E_UNAVAIL;
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry_id, bcmFieldQualifyMacSecControlPkt, ceh_info1.value, ceh_info2.value);

        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MacSecControlPkt_get
 *
 * Purpose:
 *   To get the qualified inputs on the MACSEC control packet
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_MacSecControlPkt_get(
               int unit,
               bcm_field_entry_t entry_id,
               bcm_field_macsec_encrypt_decrypt_pkt_t *data)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_HURRICANE4_SUPPORT) && defined(INCLUDE_XFLOW_MACSEC) && defined(CANCUN_SUPPORT)
    uint8 mask;
    uint8 temp_data;
    soc_cancun_ceh_field_info_t ceh_info1;
    soc_cancun_ceh_field_info_t ceh_info2;
    int    rv1 = BCM_E_UNAVAIL;
    int    rv2 = BCM_E_UNAVAIL;

    if (soc_feature(unit, soc_feature_cancun)) {
        if (NULL == data) {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: NULL pointer passed as parameter.\n"),
                     unit));
            return BCM_E_PARAM;
        }
        rv1 = soc_cancun_ceh_obj_field_get(unit, "EXTRACTION_CTRL_ID",
                "MACSEC_ENCRYPT_RX_ADD_SVTAG_FOR_CONTROL_PKT", &ceh_info1);
        rv2 = soc_cancun_ceh_obj_field_get(unit, "EXTRACTION_CTRL_ID",
                "MACSEC_ENCRYPT_RX_ADD_SVTAG_FOR_CONTROL_PKT_MASK", &ceh_info2);
        if (SOC_FAILURE(rv1) || SOC_FAILURE(rv2)) {
            return BCM_E_UNAVAIL;
        }

        rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                bcmFieldQualifyMacSecControlPkt,
                &temp_data, &mask);
        if ((temp_data == ceh_info1.value) && (ceh_info2.value == mask)) {
            *data = bcmFieldMacSecEncryptDecryptPktControl;
        }
    }

#endif
    return rv;
}


/*
 * Function:
 *     bcm_esw_field_qualify_MacSecFlow
 *
 * Purpose:
 *   Qualifies on the MACSEC packet flow
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_MacSecFlow(
               int unit,
               bcm_field_entry_t entry_id,
               bcm_field_macsec_flow_t data)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(INCLUDE_XFLOW_MACSEC)
#if defined(BCM_MONTEREY_SUPPORT) || defined(BCM_HURRICANE4_SUPPORT)
    if (soc_feature(unit, soc_feature_xflow_macsec_svtag)) {
        if ((data != bcmFieldMacSecFlowForEncrypt) && (data != bcmFieldMacSecFlowForDecrypt)
            && (data != bcmFieldMacSecFlowAfterEncrypt) && (data != bcmFieldMacSecFlowAfterDecrypt)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: data=%d too large.\n"),
                       unit, data));
            return BCM_E_PARAM;
        }
#if defined(BCM_HURRICANE4_SUPPORT)
        return _bcm_hr4_field_qualify_MacSecFlow(unit, entry_id, data, 0xff);
#endif
    } else {
        if (data >= bcmFieldMacSecFlowAfterEncrypt) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: data=%d too large.\n"),
                       unit, data));
            return BCM_E_PARAM;
        }
    }

    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry_id, bcmFieldQualifyMacSecFlow, data, BCM_FIELD_EXACT_MATCH_MASK);

    FP_UNLOCK(unit);
#endif
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MacSecFlow_get
 *
 * Purpose:
 *   To get the qualified inputs on the MACSEC packet flow
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_MacSecFlow_get(
               int unit,
               bcm_field_entry_t entry_id,
               bcm_field_macsec_flow_t *data)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(INCLUDE_XFLOW_MACSEC)
#if defined(BCM_MONTEREY_SUPPORT) || defined(BCM_HURRICANE4_SUPPORT)
    uint32  mask;

    if (NULL == data) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: NULL pointer passed as parameter.\n"),
                   unit));
        return BCM_E_PARAM;
    }
    
    rv =  _bcm_field_entry_qualifier_uint32_get(unit, entry_id,
                             bcmFieldQualifyMacSecFlow,
                             data, &mask);
#if defined(BCM_HURRICANE4_SUPPORT)
    if (soc_feature(unit, soc_feature_xflow_macsec_svtag)) {
        rv = _bcm_hr4_field_qualify_MacSecFlow_get(unit, entry_id, data, &mask);
    }
#endif
#endif
#endif
    return rv;
}

/* To Qualify on C-Bit field available in MACSEC SECTAG. */
int bcm_esw_field_qualify_MacSecSecTagCbit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;
#if (defined(INCLUDE_XFLOW_MACSEC) && defined(BCM_HURRICANE4_SUPPORT)) || (defined(BCM_CHANNELIZED_SWITCHING_SUPPORT))

    if (soc_feature(unit, soc_feature_xflow_macsec_svtag)
        || soc_feature(unit, soc_feature_channelized_switching)) {
        if((data > 1) || (mask > 1)) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit,
                              entry,
                              bcmFieldQualifyMacSecSecTagCbit,
                              data,
                              mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/* To get the qualified inputs on C-Bit field available in MACSEC SECTAG. */
int bcm_esw_field_qualify_MacSecSecTagCbit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;
#if (defined(INCLUDE_XFLOW_MACSEC) && defined(BCM_HURRICANE4_SUPPORT)) || (defined(BCM_CHANNELIZED_SWITCHING_SUPPORT))

    if (soc_feature(unit, soc_feature_xflow_macsec_svtag)
        || soc_feature(unit, soc_feature_channelized_switching)) {
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit,
                                                   entry, 
                                                   bcmFieldQualifyMacSecSecTagCbit,
                                                   data,
                                                   mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/* To Qualify on E-Bit field available in MACSEC SECTAG. */
int bcm_esw_field_qualify_MacSecSecTagEbit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;
#if (defined(INCLUDE_XFLOW_MACSEC) && defined(BCM_HURRICANE4_SUPPORT)) || (defined(BCM_CHANNELIZED_SWITCHING_SUPPORT))

    if (soc_feature(unit, soc_feature_xflow_macsec_svtag)
        || soc_feature(unit, soc_feature_channelized_switching)) {
        if((data > 1) || (mask > 1)) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit,
                              entry,
                              bcmFieldQualifyMacSecSecTagEbit,
                              data,
                              mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/* To get the qualified inputs on C-Bit field available in MACSEC SECTAG. */
int bcm_esw_field_qualify_MacSecSecTagEbit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;
#if (defined(INCLUDE_XFLOW_MACSEC) && defined(BCM_HURRICANE4_SUPPORT)) || (defined(BCM_CHANNELIZED_SWITCHING_SUPPORT))

    if (soc_feature(unit, soc_feature_xflow_macsec_svtag)
        || soc_feature(unit, soc_feature_channelized_switching)) {
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit,
                                                   entry, 
                                                   bcmFieldQualifyMacSecSecTagEbit,
                                                   data,
                                                   mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_RoeFrameType
 *
 * Purpose:
 * Qualifies on Roe frame type set in MPLS entry for a MPLS packet or based on
 * UDP port number for an IP tunnel packet.
 * Roe frame types are defined by bcm_field_roe_frame_type_t.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_RoeFrameType(int unit,
                                   bcm_field_entry_t entry_id,
                                   bcm_field_roe_frame_type_t data)
{
    int    rv = BCM_E_UNAVAIL;
#if defined(BCM_MONTEREY_SUPPORT)
    uint32 q_data, q_mask;

    if (data >= bcmFieldRoeFrameTypeCount) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: data=%d too large.\n"),
                   unit, data));
        return BCM_E_PARAM;
    }

    switch (data) {
    case bcmFieldRoeFrameTypeNone:
        q_data = 0;
        break;
    case bcmFieldRoeFrameTypeRoe:
        q_data = 2;
        break;
    case bcmFieldRoeFrameTypeCustom:
        q_data = 1;
        break;
    default :
        return BCM_E_PARAM;
    }

    q_mask = 3;

    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry_id, bcmFieldQualifyRoeFrameType,
                          q_data, q_mask);

    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_RoeFrameType_get
 *
 * Purpose:
 *   To get the qualified inputs on the Roe frame type
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_RoeFrameType_get(int unit, bcm_field_entry_t entry_id,
                                   bcm_field_roe_frame_type_t *data)
{
    int    rv = BCM_E_UNAVAIL;
#if defined(BCM_MONTEREY_SUPPORT)
    uint8  q_data = 0, q_mask = 0;

    if (NULL == data) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: NULL pointer passed as parameter.\n"),
                   unit));
        return BCM_E_PARAM;
    }

    rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                                               bcmFieldQualifyRoeFrameType,
                                               &q_data, &q_mask);
    if (BCM_SUCCESS(rv)) {
        if (q_data == 0 && q_mask == 0) {
            return BCM_E_UNAVAIL;
        }

        switch (q_data & q_mask) {
        case 0:
            *data = bcmFieldRoeFrameTypeNone;
            break;
        case 1:
            *data = bcmFieldRoeFrameTypeCustom;
            break;
        case 2:
            *data = bcmFieldRoeFrameTypeRoe;
            break;
        default :
            return BCM_E_INTERNAL;
        }
    }
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstHiGig
 * Purpose:
 *      Qualify on HiGig destination packets.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstHiGig(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstHiGig,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstHiGig_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstHiGig
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstHiGig_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyDstHiGig,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigProxy
 * Purpose:
 *      Qualify on HiGig lookedup packets.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_HiGigProxy(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigProxy,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}
/*
 * Function:
 *      bcm_esw_field_qualify_HiGigProxy_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyHiGigProxy
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_HiGigProxy_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyHiGigProxy,
                                            data, mask);
}
/*
 * Function:
 *     bcm_field_qualify_HiGig
 *
 * Purpose:
 *     Set a HiGig packet qualification on an entry.
 *
 * Parameters:
 *     unit     - BCM unit number
 *     entry    - Entry ID
 *     data     - HiGig packet != 0, non-HiGig packet = 0
 *     mask     - don't care = 0
 *
 * Returns:
 *     BCM_E_NONE   - Success
 *     BCM_E_PARAM  - bcmFieldQualifyHiGig not in group's Qset
 */
int
bcm_esw_field_qualify_HiGig(int unit, bcm_field_entry_t entry,
                            uint8 data, uint8 mask)
{
    int rv = BCM_E_UNAVAIL;   /* Operation return status. */
    _field_entry_t   *f_ent;  /* Field entry structure.   */
    _field_group_t   *fg;     /* Field group structure.   */

    
    FP_LOCK(unit);

    if (SOC_IS_TRX(unit)) {
        /* In Triumph, Higig is part of FIXED field of TCAM */
        rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGig,
                              data ? 1 : 0, mask ? 1 : 0);
    } else if (SOC_IS_FBX(unit)) {
        rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

        if (f_ent->group->stage_id == _BCM_FIELD_STAGE_LOOKUP) {
            /* FB2 Stage Lookup Higig qualifier is part of the F3. */
            rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGig,
                    data ? 1 : 0, mask ? 1 : 0);
        } else {
            /* Confirm that HiGig is in group's Qset. */
            fg = f_ent->group;
            if (0 == BCM_FIELD_QSET_TEST(fg->qset, bcmFieldQualifyHiGig)) {
                FP_UNLOCK(unit);
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "FP(unit %d) Error: HiGig not in entry=%d Qset.\n"),
                           unit, entry));
                return (BCM_E_PARAM);
            }

            /* Add data & mask to entry. */
            f_ent->tcam.higig      = data;
            f_ent->tcam.higig_mask = mask;
        }
    }
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceClassPort
 *
 * Purpose:
 *     Set a Port interface class id packet qualification on an entry.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number
 *     entry    - (IN) Entry ID
 *     data     - (IN) Interface Class id.
 *     mask     - (IN) Interface Class mask. 
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_InterfaceClassPort(int unit, bcm_field_entry_t entry,
                                         uint32 data, uint32 mask)
{

    int rv;                 /* Operation return status. */

    if (data  > SOC_INTF_CLASS_MAX(unit)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: data=%#x out-of-range\n"),
                   unit, data));
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInterfaceClassPort,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceClassVPort
 *
 * Purpose:
 *     Set a Port interface class id packet qualification on an entry.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number
 *     entry    - (IN) Entry ID
 *     data     - (IN) Interface Class id.
 *     mask     - (IN) Interface Class mask.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_InterfaceClassVPort(int unit, bcm_field_entry_t entry,
                                         uint32 data, uint32 mask)
{

    int rv;                 /* Operation return status. */


    if (data  > SOC_INTF_CLASS_MAX(unit)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: data=%#x out-of-range\n"),
                   unit, data));
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInterfaceClassVPort,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}




/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceClassL2
 *
 * Purpose:
 *     Set a Port interface class id packet qualification on an entry.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number
 *     entry    - (IN) Entry ID
 *     data     - (IN) Interface Class id.
 *     mask     - (IN) Interface Class mask. 
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_InterfaceClassL2(int unit, bcm_field_entry_t entry,
                                         uint32 data, uint32 mask)
{
    int rv;                 /* Operation return status. */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class(unit, entry,
                                       bcmFieldQualifyInterfaceClassL2,
                                       &data, &mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyInterfaceClassL2,
                                          &data,
                                          &mask
                                          )
            );
    } else
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class(unit,
                                                         entry,
                                                         bcmFieldQualifyInterfaceClassL2,
                                                         &data,
                                                         &mask
                                                         )
                            );
    } else 
#endif    
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyInterfaceClassL2,
                                          &data,
                                          &mask
                                          ));
    } else {
#endif /* BCM_KATANA2_SUPPORT */
        if (data  > SOC_INTF_CLASS_MAX(unit)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: data=%#x out-of-range\n"),
                       unit, data));
            return (BCM_E_PARAM);
        }
#ifdef BCM_KATANA2_SUPPORT
    }
#endif

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInterfaceClassL2,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceClassL3
 *
 * Purpose:
 *     Set a L3 interface class id packet qualification on an entry.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number
 *     entry    - (IN) Entry ID
 *     data     - (IN) Interface Class id.
 *     mask     - (IN) Interface Class mask. 
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_InterfaceClassL3(int unit, bcm_field_entry_t entry,
                                       uint32 data, uint32 mask)
{
    int rv;                 /* Operation return status. */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class(unit, entry,
                                       bcmFieldQualifyInterfaceClassL3,
                                       &data, &mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyInterfaceClassL3,
                                          &data,
                                          &mask
                                          )
            );
    } else
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class(unit,
                                                         entry,
                                                         bcmFieldQualifyInterfaceClassL3,
                                                         &data,
                                                         &mask
                                                         )
                            );
    } else
#endif    
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyInterfaceClassL3,
                                          &data,
                                          &mask
                                          ));
    } else {
#endif /* BCM_KATANA2_SUPPORT */
        if (data  > SOC_INTF_CLASS_MAX(unit)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "FP(unit %d) Error: data=%#x out-of-range\n"),
                       unit, data));
            return (BCM_E_PARAM);
        }
#ifdef BCM_KATANA2_SUPPORT
    }
#endif

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInterfaceClassL3,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

int 
bcm_esw_field_qualify_TcpSequenceZero(int unit, bcm_field_entry_t entry,
                            uint32 flag)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_TcpHeaderSize(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

/* Function: 
 *       bcm_field_qualify_InnerIpProtocolCommon
 * Description:
 *       Qualify common L3 protocol ID.
 * Parameters: 
 *   unit     (IN) BCM device number
 *   entry    (IN) Field entry to qualify
 *   protocol (IN) Protocol name to qualify
 * Returns: 
 *   BCM_E_XXX
 */
int
bcm_esw_field_qualify_InnerIpProtocolCommon(int unit, bcm_field_entry_t entry,
                                       bcm_field_IpProtocolCommon_t protocol)
{
    int      rv;            /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify_IpProtocolCommon(unit, entry, 
                                         bcmFieldQualifyInnerIpProtocolCommon, 
                                         protocol);
    FP_UNLOCK(unit);
    return (rv);
}


/* Function: 
 *           bcm_field_qualify_IpProtocolCommon
 * Description: 
 *           Qualify common L3 protocol ID
 * Parameters: 
 *   unit     (IN) BCM device number
 *   entry    (IN) Field entry to qualify
 *   protocol (IN) Protocol name to qualify
 * Returns: 
 *   BCM_E_XXX
 */
int
bcm_esw_field_qualify_IpProtocolCommon(int unit, bcm_field_entry_t entry,
                                       bcm_field_IpProtocolCommon_t protocol)
{
    int      rv;            /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify_IpProtocolCommon(unit, entry, bcmFieldQualifyIpProtocolCommon, protocol);

    FP_UNLOCK(unit);
    return (rv);
}

/* Function    : bcm_field_qualify_Snap
 * Description : qualify SNAP headers.
 * Parameters  : (IN) unit     BCM device number
 *               (IN) entry    Field entry to qualify
 *               (IN) data     SNAP fields to qualify
 *               (IN) mask     SNAP mask to qualify
 * Returns     : BCM_E_XXX
 */
int
bcm_esw_field_qualify_Snap(int unit, bcm_field_entry_t entry,
                           bcm_field_snap_header_t data, 
                           bcm_field_snap_header_t mask)
{
    _field_entry_t           *f_ent;
    _bcm_field_qual_offset_t *q_offset;
    uint32                   ref_data[_FP_QUAL_DATA_WORDS];
    uint32                   ref_mask[_FP_QUAL_DATA_WORDS];
    int                      rv; 


    ref_data[1] = (data.org_code & 0x00ff0000) >> 16;
    ref_data[0] = (data.org_code & 0x0000ffff) << 16 | data.type;

    ref_mask[1] = (mask.org_code & 0x00ff0000) >> 16;
    ref_mask[0] = (mask.org_code & 0x0000ffff) << 16 | mask.type;


    
    FP_LOCK(unit);


    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, bcmFieldQualifySnap, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    /* If device supports per-pipe FP configuration, */
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
         (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
        /* coverity[callee_ptr_arith : FALSE] */
        rv = (_bcm_field_th_qualify_set(unit, entry, bcmFieldQualifySnap,
                                        ref_data, ref_mask,
                                        _FP_QUALIFIER_ADD));
        FP_UNLOCK(unit);
        return (rv);
    }
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        rv =  (_bcm_field_th_class_qualify_set(unit, entry, bcmFieldQualifySnap,
                                               ref_data, ref_mask));
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Get qualifier offsets in the tcam. */
    rv = _field_qual_offset_get(unit, f_ent, bcmFieldQualifySnap, &q_offset);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Program data/mask pair to tcam buffer. */
    /* coverity[callee_ptr_arith : FALSE] */
    rv = _bcm_field_qual_value_set(unit, q_offset, f_ent, 
                                   ref_data, ref_mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* Function    : bcm_field_qualify_Llc
 * Description : qualify LLC headers.
 * Parameters  : (IN) unit     BCM device number
 *               (IN) entry    Field entry to qualify
 *               (IN) data     LLC fields to qualify
 *               (IN) mask     LLC mask to qualify
 * Returns     : BCM_E_XXX
 */
int
bcm_esw_field_qualify_Llc(int unit, bcm_field_entry_t entry,
                          bcm_field_llc_header_t data, 
                          bcm_field_llc_header_t mask)
{
    uint32              ref_data;
    uint32              ref_mask;
    int                 rv; 

    
    FP_LOCK(unit);

    ref_data = (data.dsap << 16) | (data.ssap << 8) | \
               data.control; 
    ref_mask = (mask.dsap << 16) | (mask.ssap << 8) | \
               mask.control; 
    rv = _field_qualify32(unit, entry, bcmFieldQualifyLlc,
                          ref_data, ref_mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* Function    : bcm_field_qualify_InnerTpid
 * Description : qualify outer/inner Tpid
 * Parameters  : (IN) unit   BCM driver unit
 *               (IN) entry  Field entry to qualify
 *               (IN) tpid   TPID to qualify
 * Returns     : BCM_E_XXX
 */
int
bcm_esw_field_qualify_InnerTpid(int unit, bcm_field_entry_t entry,
                                uint16 tpid)
{
    int     rv = BCM_E_UNAVAIL; 
#if defined(BCM_FIREBOLT2_SUPPORT) || defined (BCM_TRX_SUPPORT)
    uint32  mask;
    uint32  data;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        BCM_IF_ERROR_RETURN(_bcm_field_td3_tpid_hw_encode(unit, tpid, 0, &data));
    } else
#endif
    {
    if (SOC_IS_FIREBOLT2(unit) || SOC_IS_TRX(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tpid_hw_encode(unit, tpid, &data));
        } else {
            return rv;
        }
    }
        mask = 0x03;
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerTpid, data, mask);
        FP_UNLOCK(unit);
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    return (rv);
}

/* Function    : bcm_field_qualify_OuterTpid
 * Description : qualify outer Tpid
 * Parameters  : (IN) unit   BCM driver unit
 *               (IN) entry  Field entry to qualify
 *               (IN) tpid   TPID to qualify
 * Returns     : BCM_E_XXX
 */
int
bcm_esw_field_qualify_OuterTpid(int unit, bcm_field_entry_t entry,
                                uint16 tpid)
{
    int     rv = BCM_E_UNAVAIL; 
#if defined(BCM_FIREBOLT2_SUPPORT) || defined (BCM_TRX_SUPPORT)
    uint32  mask;
    uint32  data;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        BCM_IF_ERROR_RETURN(_bcm_field_td3_tpid_hw_encode(unit, tpid, 1, &data));
    } else
#endif
    {
    if (SOC_IS_FIREBOLT2(unit) || SOC_IS_TRX(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tpid_hw_encode(unit, tpid, &data));
        } else {
            return rv;
        }
    }
        mask = 0x03;
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyOuterTpid, data, mask);
        FP_UNLOCK(unit);
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */
    return (rv);
}

/* Function    : bcm_esw_field_qualify_L3Routable
 * Description : qualify on the L3 Routable bit.
 * Parameters  : (IN) unit   BCM device number
 *               (IN) entry  Field entry to qualify
 *               (IN) data   Single bit
 *               (IN) mask   Single bit mask
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_L3Routable(int unit, bcm_field_entry_t entry,
                                  uint8 data, uint8 mask)
{
    int rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyL3Routable, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/* Function    : bcm_esw_field_qualify_IpFrag
 * Description : qualify on Ip Frag Info.
 * Parameters  : (IN) unit       BCM device number
 *               (IN) entry      Field entry to qualify
 *               (IN) frag_info  bcm_field_IpFrag_t to qualify
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_IpFrag(int unit, bcm_field_entry_t entry,
                                  bcm_field_IpFrag_t frag_info)
{
    int             rv = BCM_E_UNAVAIL;
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT) \
    || defined(BCM_RAPTOR_SUPPORT)

    
    FP_LOCK(unit);

    if (SOC_IS_FIREBOLT2(unit) || SOC_IS_TRX(unit) || 
        SOC_IS_RAVEN(unit) || SOC_IS_HAWKEYE(unit)) {
        rv = _field_qualify_IpFrag(unit, entry, bcmFieldQualifyIpFrag, frag_info);
    }
    FP_UNLOCK(unit);
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT || BCM_RAPTOR_SUPPORT */
    return (rv);
}

/* Function    : bcm_esw_field_qualify_Vrf
 * Description : qualify on the VRF id.
 * Parameters  : (IN) unit   BCM device number
 *               (IN) entry  Field entry to qualify
 *               (IN) data   Vrf id. 
 *               (IN) mask   Vrf mask.
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_Vrf(int unit, bcm_field_entry_t entry,
                              uint32 data, uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyVrf, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/* Function    : bcm_esw_field_qualify_L3Ingress
 * Description : qualify on the L3 ingress interface.
 * Parameters  : (IN) unit   BCM device number
 *               (IN) entry  Field entry to qualify
 *               (IN) data   L3 ingress id. 
 *               (IN) mask   L3 ingress mask.
 * Returns     : BCM_E_XXX
 */

int bcm_esw_field_qualify_L3Ingress(int unit, bcm_field_entry_t entry,
    uint32 data, uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyL3Ingress, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/* Function    : bcm_esw_field_qualify_L4Ports
 * Description : qualify on the 4 bytes after L3 header.
 * Parameters  : (IN) unit   BCM device number
 *               (IN) entry  Field entry to qualify
 *               (IN) data   0/1 4 bytes after L3 header are present. 
 *               (IN) mask   data mask.
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_L4Ports(int unit, bcm_field_entry_t entry,
                                  uint8 data, uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

    
    FP_LOCK(unit);

#if defined(BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit)) {
        rv = _field_qualify32(unit, entry, bcmFieldQualifyL4Ports, data, mask);
    }
#endif  /* BCM_TRX_SUPPORT */
    FP_UNLOCK(unit);
    return (rv);
}

/* Function    : bcm_esw_field_qualify_MirrorCopy
 * Description : qualify on the mirrored packets only.
 * Parameters  : (IN) unit   BCM device number
 *               (IN) entry  Field entry to qualify
 *               (IN) data   0/1 Not Mirrored/Mirrored packets. 
 *               (IN) mask   data mask.
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_MirrorCopy(int unit, bcm_field_entry_t entry,
                                  uint8 data, uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMirrorCopy, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/* Function    : bcm_esw_field_qualify_TunnelTerminated
 * Description : qualify on the tunnel terminated packets only.
 * Parameters  : (IN) unit   BCM device number
 *               (IN) entry  Field entry to qualify
 *               (IN) data   0/1 Not Tunneled/Tunnel Terminated packets. 
 *               (IN) mask   data mask.
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_TunnelTerminated(int unit, bcm_field_entry_t entry,
                                           uint8 data, uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyTunnelTerminated,
                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/* Function    : bcm_esw_field_qualify_MplsTerminated
 * Description : qualify on the mpls terminated packets only.
 * Parameters  : (IN) unit   BCM device number
 *               (IN) entry  Field entry to qualify
 *               (IN) data   0/1 Not mpls terminated/mpls Terminated packets. 
 *               (IN) mask   data mask.
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_MplsTerminated(int unit, bcm_field_entry_t entry,
                                           uint8 data, uint8 mask)
{
    int rv = BCM_E_UNAVAIL; /* Operation return status  */
#if defined(BCM_TRIUMPH2_SUPPORT) /* BCM_TRIUMPH2_SUPPORT */
    _field_group_t *fg;     /* Field group structure    */
    int i;
#endif /* !BCM_TRIUMPH2_SUPPORT */

    
    FP_LOCK(unit);
#if defined(BCM_TRIUMPH_SUPPORT)
    if (SOC_IS_TR_VL(unit)) {
#if defined(BCM_TRIUMPH2_SUPPORT) /* BCM_TRIUMPH2_SUPPORT */
        if (SOC_IS_TRIUMPH2(unit) || SOC_IS_APOLLO(unit)
            || SOC_IS_VALKYRIE2(unit) || SOC_IS_KATANAX(unit)) {
	    rv = _bcm_field_entry_group_find(unit, entry, &fg);
	    if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
	    }
            for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
                if (fg->sel_codes[i].loopback_type_sel 
                        == (int8) bcmFieldTunnelTypeMpls) {
                    if (1 == data && 1 == mask) {
                        data = (uint8) bcmFieldTunnelTypeMpls;
                        mask = (BCM_FIELD_EXACT_MATCH_MASK);
                    }
                    break;
                }
            }
        }
#endif /* !BCM_TRIUMPH2_SUPPORT */
        rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsTerminated,
                              data, mask);
    }
#endif  /* BCM_TRIUMPH_SUPPORT*/
    FP_UNLOCK(unit);
    return (rv);
}

/* Function    : bcm_esw_field_qualify_ExtensionHeaderType
 * Description : Qualify on Next Header Field in First Extension Header.
 * Parameters  : (IN) unit   BCM device number
 *               (IN) entry  Field entry to qualify
 *               (IN) data   Extension Header - Next Header byte.
 *               (IN) mask   Next Header byte mask.
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_ExtensionHeaderType(int unit, 
                                              bcm_field_entry_t entry,
                                              uint8 data, uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

    
    FP_LOCK(unit);

#if defined (BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit)) {
        rv = _field_qualify32(unit, entry, bcmFieldQualifyExtensionHeaderType,
                              data, mask);
    }
#endif 
    FP_UNLOCK(unit);
    return (rv);
}

/* Function    : bcm_esw_field_qualify_ExtensionHeaderSubCode
 * Description : Qualify on First byte after extentsion header length field.
 * Parameters  : (IN) unit   BCM device number
 *               (IN) entry  Field entry to qualify
 *               (IN) data   Extension Header byte after header length field.
 *               (IN) mask   Byte mask.
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_ExtensionHeaderSubCode(int unit, 
                                                 bcm_field_entry_t entry,
                                                 uint8 data, uint8 mask)
{
    int rv = BCM_E_UNAVAIL;
    
    FP_LOCK(unit);

#if defined (BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit)) {
        rv =  _field_qualify32(unit, entry,
                               bcmFieldQualifyExtensionHeaderSubCode,
                               data, mask);
    }
#endif 
    FP_UNLOCK(unit);
    return (rv);
}

/* Function    : bcm_esw_field_qualify_ExtensionHeader2Type
 * Description : Qualify on Next Header Field in Second Extension Header.
 * Parameters  : (IN) unit   BCM device number
 *               (IN) entry  Field entry to qualify
 *               (IN) data   Extension Header - Next Header byte.
 *               (IN) mask   Next Header byte mask.
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_ExtensionHeader2Type(int unit, 
                                              bcm_field_entry_t entry,
                                              uint8 data, uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

    
    FP_LOCK(unit);

#if defined (BCM_TRIDENT_SUPPORT)
    if (SOC_IS_TD_TT(unit) || SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit)) {
        rv = _field_qualify32(unit, entry, bcmFieldQualifyExtensionHeader2Type,
                              data, mask);
    }
#endif  /* BCM_TRIDENT_SUPPORT */

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InnerSrcIp(int unit, bcm_field_entry_t entry,
                            bcm_ip_t data, bcm_ip_t mask)
{
    int              rv;
    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerSrcIp, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InnerDstIp(int unit, bcm_field_entry_t entry,
                            bcm_ip_t data, bcm_ip_t mask)
{
    int rv; 
    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerDstIp, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InnerSrcIp6(int unit, bcm_field_entry_t entry,
                             bcm_ip6_t data, bcm_ip6_t mask)
{
    int rv; 

    
    FP_LOCK(unit);

    rv = _field_qualify_ip6(unit, entry, bcmFieldQualifyInnerSrcIp6, 
                            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InnerDstIp6(int unit, bcm_field_entry_t entry,
                             bcm_ip6_t data, bcm_ip6_t mask)
{
    int rv; 

    
    FP_LOCK(unit);

    rv = _field_qualify_ip6(unit, entry, bcmFieldQualifyInnerDstIp6, 
                            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InnerSrcIp6High(int unit, bcm_field_entry_t entry,
                                 bcm_ip6_t data, bcm_ip6_t mask)
{
    int                 rv;

    
    FP_LOCK(unit);

    rv = _field_qualify_ip6(unit, entry, bcmFieldQualifyInnerSrcIp6High,
                            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InnerDstIp6High(int unit, bcm_field_entry_t entry,
                                 bcm_ip6_t data, bcm_ip6_t mask)
{
    int                 rv;

    
    FP_LOCK(unit);

    rv = _field_qualify_ip6(unit, entry, bcmFieldQualifyInnerDstIp6High,
                                data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InnerTos(int unit, bcm_field_entry_t entry,
                           uint8 data, uint8 mask)
{
    int rv; 

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerTos, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InnerDSCP(int unit, bcm_field_entry_t entry,
                           uint8 data, uint8 mask)
{
    int rv; 

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerDSCP, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InnerIpProtocol(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
{
    int rv; 

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerIpProtocol, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int bcm_esw_field_qualify_InnerIpFrag(int unit, bcm_field_entry_t entry,
                                  bcm_field_IpFrag_t frag_info)
{
    int             rv = BCM_E_UNAVAIL;
#if  defined(BCM_TRX_SUPPORT) 
    
    FP_LOCK(unit);

    if (SOC_IS_TRX(unit)) {
        rv = _field_qualify_IpFrag(unit, entry, 
                                   bcmFieldQualifyInnerIpFrag,
                                   frag_info);
    }
    FP_UNLOCK(unit);
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_InnerTtl(int unit, bcm_field_entry_t entry,
                          uint8 data, uint8 mask)
{
    int rv; 

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerTtl, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TranslatedVlanFormat
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTranslatedVlanFormat
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TranslatedVlanFormat( int unit, bcm_field_entry_t entry, 
                                           uint8 data, uint8 mask)
{
    int                 rv;      /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify_VlanFormat(unit, entry,
                                   bcmFieldQualifyTranslatedVlanFormat,
                                   data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IntPriority
 * Purpose:
 *      Set match criteria for bcmFieildQualifyIntPriority
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IntPriority(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv; 

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIntPriority, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_Color
 * Purpose:
 *      Set match criteria for bcmFieildQualifyColor
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      color - (IN) Qualifier match color.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Color(int unit, bcm_field_entry_t entry, 
                            uint8 color)
{
    uint8 data;           /* Qualifier data.          */
    int rv;               /* Operation return status. */
    uint8 mask = 0x3;     /* Qualifier mask.          */

    switch (color) {
      case BCM_FIELD_COLOR_GREEN:
          data = 0;
          break;
      case BCM_FIELD_COLOR_RED:
          data = 1;
          break;
      case BCM_FIELD_COLOR_YELLOW:
          data = 3;
          break;
      default:
          return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyColor, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanOuter
 * Purpose:
 *      Add Fibre Channel outer header type field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (IN) Data to qualify with.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_FibreChanOuter(int unit, 
                             bcm_field_entry_t entry, 
                             bcm_field_FibreChan_t fibre_chan_type)
{
    int               rv;   /* Operation return status. */
    uint32            data; /* HW data match criteria.  */
    uint32            mask; /* HW data mask.            */


    switch (fibre_chan_type) { 
      case bcmFieldFibreChanAny:
          data = 0x0;
          mask = 0x0;
          break;
      case bcmFieldFibreChan:
          data = 0x1;
          mask = 0x7;
          break;
      case bcmFieldFibreChanEncap:
          data = 0x3;
          mask = 0x7;
          break;
      case bcmFieldFibreChanVirtual:
          data = 0x2;
          mask = 0x7;
          break;
      case bcmFieldFibreChanRouted:
          data = 0x4;
          mask = 0x7;
          break;
      default:
          return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanOuter, 
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanInner
 * Purpose:
 *      Add Fibre Channel inner header type field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (IN) Data to qualify with.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_FibreChanInner(int unit, 
                             bcm_field_entry_t entry, 
                             bcm_field_FibreChan_t fibre_chan_type)
{
    int               rv;   /* Operation return status. */
    uint32            data; /* HW data match criteria.  */
    uint32            mask; /* HW data mask.            */

    switch (fibre_chan_type) { 
      case bcmFieldFibreChanAny:
          data = 0x0;
          mask = 0x0;
          break;
      case bcmFieldFibreChan:
          data = 0x1;
          mask = 0x7;
          break;
      case bcmFieldFibreChanEncap:
          data = 0x3;
          mask = 0x7;
          break;
      case bcmFieldFibreChanVirtual:
          data = 0x2;
          mask = 0x7;
          break;
      case bcmFieldFibreChanRouted:
          data = 0x4;
          mask = 0x7;
          break;
      default:
          return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanInner, 
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_VnTag
 * Purpose:
 *      Add NIV VN tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VnTag(int unit, bcm_field_entry_t entry,
                            uint32 data, uint32 mask)
{
    return (_bcm_esw_field_qualify_aux_tag(unit,
                                           entry,
                                           bcmFieldQualifyVnTag,
                                           data,
                                           mask
                                           )
            );
}

/*
 * Function:
 *  bcm_esw_field_qualify_ETag
 * Purpose:
 *  Add E tag field qualification to a field entry.
 * Parameters:
 *  unit  - (IN) Unit number.
 *  entry - (IN) Field entry id.
 *  data  - (IN) Qualifier match data.
 *  mask  - (IN) Qualifier match mask.
 * Returns:
 *  BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ETag(int unit, bcm_field_entry_t entry,
                                    uint64 data, uint64 mask)
{
    uint32 edata = 0;   /* ETag Data */
    uint32 emask = 0;   /* ETag Mask */

    /* As per Arch currently only 32 bit ETag is presented
     * to FP */
    COMPILER_64_TO_32_LO(edata, data);
    COMPILER_64_TO_32_LO(emask, mask);

    return (_bcm_esw_field_qualify_aux_tag(unit, entry,
                                           bcmFieldQualifyETag,
                                           edata, emask));
}

/*
 * Function:
 *      bcm_esw_field_qualify_SubportPktTag
 * Purpose:
 *      Add LLTAG tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SubportPktTag(int unit, bcm_field_entry_t entry,
                            uint16 data, uint16 mask)
{
    return (_bcm_esw_field_qualify_aux_tag(unit,
                                           entry,
                                           bcmFieldQualifySubportPktTag,
                                           data,
                                           mask
                                           )
            );
}

/*
 * Function:
 *      bcm_esw_field_qualify_CnTag
 * Purpose:
 *      Add CN tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_CnTag(int unit, bcm_field_entry_t entry,
                            uint32 data, uint32 mask)
{
    return (_bcm_esw_field_qualify_aux_tag(unit,
                                           entry,
                                           bcmFieldQualifyCnTag,
                                           data,
                                           mask
                                           )
            );
}

/*
 * Function:
 *      bcm_esw_field_qualify_FabricQueueTag
 * Purpose:
 *      Add Fabric Queue tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FabricQueueTag(int unit, bcm_field_entry_t entry,
                                     uint32 data, uint32 mask)
{
    return (_bcm_esw_field_qualify_aux_tag(unit,
                                           entry,
                                           bcmFieldQualifyFabricQueueTag,
                                           data,
                                           mask
                                           )
            );
}

/*
 * Function:
 *      bcm_esw_field_qualify_IcmpTypeCode
 * Purpose:
 *      Set match criteria for bcmFieildQualifyIcmpTypeCode
 *                     qualifier to the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IcmpTypeCode(int unit, bcm_field_entry_t entry,
                                         uint16 data,uint16 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIcmpTypeCode,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FlowId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFlowId
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int 
bcm_esw_field_qualify_FlowId(int unit, bcm_field_entry_t entry,
                 uint16 data, uint16 mask)
{
    return BCM_E_UNAVAIL; 
}
/*
 * Function:
 *      bcm_esw_field_qualify_InVPort
 * Purpose:
 *      Set match criteria for bcmFieildQualifyInVPort
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int 
bcm_esw_field_qualify_InVPort(int unit, bcm_field_entry_t entry,
                 uint8 data, uint8 mask)
{
    return BCM_E_UNAVAIL; 
}
/*
 * Function:
 *      bcm_esw_field_qualify_OutVPort
 * Purpose:
 *      Set match criteria for bcmFieildQualifyOutVPort
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int 
bcm_esw_field_qualify_OutVPort(int unit, bcm_field_entry_t entry,
                 uint8 data, uint8 mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_FlowId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFlowId
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_FlowId_get(int unit, bcm_field_entry_t entry,
                 uint16 *data, uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_InVPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInVPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InVPort_get(int unit, bcm_field_entry_t entry,
                 uint8 *data, uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OutVPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyOutVPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OutVPort_get(int unit, bcm_field_entry_t entry,
                 uint8 *data, uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IntCongestionNotification
 * Purpose:
 *      Set match criteria for IntCongestionNotification
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int 
bcm_esw_field_qualify_IntCongestionNotification(int unit, 
    bcm_field_entry_t entry, uint8 data, uint8 mask)
{
#if defined(BCM_GREYHOUND_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
    int              rv = BCM_E_UNAVAIL;       /* Operation return status. */

    if (soc_feature(unit, soc_feature_ecn_wred)) {

        if ((data > _BCM_ECN_INT_CN_VALUE_MAX) ||
            (mask > _BCM_ECN_INT_CN_VALUE_MAX)) {
            return BCM_E_PARAM;
        }
        
        
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, 
                    bcmFieldQualifyIntCongestionNotification,
                    data, mask);

        FP_UNLOCK(unit);
    }
    return (rv);
#else /* !BCM_GREYHOUND_SUPPORT */
    return BCM_E_UNAVAIL;
#endif /* BCM_GREYHOUND_SUPPORT */
}

/*
 * Function:
 *      bcm_esw_field_qualify_IntCongestionNotification_get
 * Purpose:
 *      Get match criteria for IntCongestionNotification
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int 
bcm_esw_field_qualify_IntCongestionNotification_get(int unit, 
    bcm_field_entry_t entry, uint8 *data, uint8 *mask)
{
#if defined(BCM_GREYHOUND_SUPPORT) || defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_ecn_wred)) {
        /* Read qualifier match value and mask. */
        return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                           bcmFieldQualifyIntCongestionNotification,
                           data, mask);
    }
#endif /* BCM_GREYHOUND_SUPPORT */    

    return BCM_E_UNAVAIL;
}


/*  Section: Field Actions  */

/*
 * Function: bcm_esw_field_action_add
 *
 * Purpose:
 *     Add action performed when entry rule is matched for a packet
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - entry ID
 *     action - Action to perform (bcmFieldActionXXX)
 *     param0 - Action parameter (use 0 if not required)
 *     param1 - Action parameter (use 0 if not required)
 *
 * Returns:
 *     BCM_E_XXX
 */

int
bcm_esw_field_action_add(int unit,
                         bcm_field_entry_t entry,
                         bcm_field_action_t action,
                         uint32 param0,
                         uint32 param1)
{
    _field_control_t    *fc;           /* Field control structure. */
    _field_action_t     *fa = NULL;    /* Field action descriptor. */
    int                 rv;            /* Operation return status. */
#if defined (BCM_TOMAHAWK_SUPPORT)
    uint8 copyToCpu_manipulate_flg = 0;
    int   matched_rule = -1;
#endif /* BCM_TOMAHAWK_SUPPORT */

#ifdef BROADCOM_DEBUG
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: bcm_field_action_add(entry=%d, action=%s, "
                          "p0=%d, p1=%d)\n"), unit, entry,
               _field_action_name(action), param0, param1));
#endif

    if ((SOC_PORT_ADDR_MAX(unit) > 31)
        && ((action == bcmFieldActionRedirectPbmp)
            || (action == bcmFieldActionEgressMask)
            || (action == bcmFieldActionEgressPortsAdd)
            || (action == bcmFieldActionRedirectBcastPbmp))) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: Use bcm_field_action_ports_add api.\n"),
                   unit));
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    /*
     * Translate the CopyToCpu Action to an 'Egress Mirror' action.
     */
    if (SOC_INFO(unit).th_ctc_replace_enabled) {
       _field_entry_t      *f_ent;
 
       /*
        *  Mirror Ingress and Color Based CopyToCpu Actions are not
        *  supported in this mode.
        */
       if ((action == bcmFieldActionMirrorIngress) ||
           (action == bcmFieldActionRpCopyToCpu) ||
           (action == bcmFieldActionYpCopyToCpu) ||
           (action == bcmFieldActionGpCopyToCpu)) {
            return BCM_E_UNAVAIL;
       }

       BCM_IF_ERROR_RETURN(_field_entry_get(unit, entry,
                           _FP_ENTRY_PRIMARY, &f_ent));

       if ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
           (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH)) {

           /* Conflicting checks for MirrorEgress and CopyToCpu */
           for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
              if ((fa->action == bcmFieldActionMirrorEgress) &&
                  !(fa->flags & _FP_ACTION_DIRTY)) {
                 if ((action == bcmFieldActionCopyToCpu) ||
                     (action == bcmFieldActionMirrorEgress)) {
                     LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                     "Action CopyToCpu/MirrorEgress not applicable,"
                     " MirrorEgress is already configured.\n\r")));
                     return BCM_E_PARAM;
                 }
              }
           }
           if (action == bcmFieldActionCopyToCpu) {
              int modid;
              int cpu_port = 0;

              BCM_IF_ERROR_RETURN(bcm_esw_stk_my_modid_get(unit, &modid));
             
              BCM_PBMP_ITER(PBMP_CMIC(unit), cpu_port) {
                 if (param0 != 0) {
                    matched_rule = param1;
                 }
                 action = bcmFieldActionMirrorEgress;
                 param0 = modid;
                 param1 = cpu_port;
                 copyToCpu_manipulate_flg = 1;
                 break;
              }
           }
       }

       if (f_ent->group->stage_id == _BCM_FIELD_STAGE_LOOKUP) {
           /* Conflicting checks for SrcClassField and CopyToCpu */
           for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
              if ((fa->action == bcmFieldActionClassSourceSet) ||
                  (fa->action == bcmFieldActionCopyToCpu)) {
                 if ((action == bcmFieldActionCopyToCpu) ||
                     (action == bcmFieldActionClassSourceSet)) {
                     LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit,
                     "Action CopyToCpu/SrcClassField not applicable,"
                     " SrcClassField/CopyToCpu is already configured.\n\r")));
                     return BCM_E_PARAM;
                 }
              }
           }
       }  
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Adapt action parameters */
    rv = _field_params_api_to_hw_adapt(unit, action, &param0, &param1);
    BCM_IF_ERROR_RETURN(rv);

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    fa = NULL;

    /* 
     * Allocate the action descriptor, param2 to param5 are not valid here.
     */
    rv = _field_action_alloc(unit, action, param0, param1, 0, 0, 0, 0, &fa);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: failure in _field_action_alloc()\n"),
                   unit));
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Add action to entry actions list.
     */
    rv = _field_action_add(unit, fc, entry, fa);
    FP_UNLOCK(unit);
    if (BCM_FAILURE(rv)) {
        sal_free(fa);
        return rv;
    }

#if defined (BCM_TOMAHAWK_SUPPORT)
    if (copyToCpu_manipulate_flg == 1) {
        fa->flags |= _BCM_FIELD_ACTION_CTC_MANIPULATE_FLAG;
        if (matched_rule != -1) {
           fa->param[2] = 1;
           fa->param[3] = matched_rule;
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_class_size_get
 * Purpose:
 *      Retrieve the class size for qualifier provided.
 * Parameters:
 *      unit - (IN) Unit number.
 *      qual - (IN) Field Qualifier.
 *      class_size - (OUT) Class Size.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      Class Size returned is in bits.
 */
int
bcm_esw_field_class_size_get(int unit,
                             bcm_field_qualify_t qual,
                             uint16 *class_size)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;       /* Field control structure. */
    

    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_class_size_get(unit, qual, class_size);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_action_class_add
 * Purpose:
 *      Add an action to a field class entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry Id.
 *      class_info - (IN) Field Class Info.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_action_class_add(
        int unit,
        bcm_field_entry_t entry,
        bcm_field_class_info_t *class_info)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    

    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            FP_LOCK(unit);
            rv = (_bcm_field_th_class_action_set(unit, entry, class_info));
            FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_action_class_get
 * Purpose:
 *      Retrieve the parameters for an action previously added to a
 *      field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry Id.
 *      class_info - (INOUT) Field Class Info.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_action_class_get(
        int unit,
        bcm_field_entry_t entry,
        bcm_field_class_info_t *class_info)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    

    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        FP_LOCK(unit);
        rv = (_bcm_field_th_class_action_get(unit, entry, class_info));
        FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_action_mac_add
 * Purpose:
 *      Add an action to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry Id.
 *      action - (IN) Field action id.
 *      mac - (IN) Field action parameter.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_action_mac_add(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    bcm_mac_t mac)
{
    uint32  param[_FP_ACTION_PARAM_SZ];     

    if ((action != bcmFieldActionSrcMacNew) &&
        (action != bcmFieldActionDstMacNew) &&
        (action != bcmFieldActionReplaceDstMac) &&
        (action != bcmFieldActionReplaceSrcMac) ) {
        return (BCM_E_PARAM);
    }

    SAL_MAC_ADDR_TO_UINT32(mac, param);

    return bcm_esw_field_action_add(unit, entry, action,
                                    param[0],param[1]);
}

/*
 * Function:
 *      bcm_esw_field_sat_macsa_add
 * Purpose:
 *      Add a mac sa and class id entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      mac -  (IN) Src Mac.
 *      class_id - (IN) Class id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_sat_macsa_add(
    int unit,
    bcm_mac_t mac,
    uint32 class_id)
{
   int rv = BCM_E_UNAVAIL;
#if defined (BCM_APACHE_SUPPORT)
   
   if (soc_feature(unit, soc_feature_fp_based_sat)) {
       FP_LOCK(unit);
       rv = _bcm_field_apache_sat_macsa_add(unit, mac, class_id);
       FP_UNLOCK(unit);
   }
#endif
   return rv;
}

/*
 * Function:
 *      bcm_esw_field_sat_macsa_get
 * Purpose:
 *      Get class id corresponding to mac sa entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      mac -  (IN) Src Mac.
 *      class_id - (OUT) Class id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_sat_macsa_get(
    int unit,
    bcm_mac_t mac,
    uint32 *class_id)
{
   int rv = BCM_E_UNAVAIL;
#if defined (BCM_APACHE_SUPPORT)
   int index;
   
   if (soc_feature(unit, soc_feature_fp_based_sat)) {
       FP_LOCK(unit);
       rv = _bcm_field_apache_sat_macsa_get(unit, mac, class_id, &index);
       FP_UNLOCK(unit);
   }
#endif
   return rv;
}

/*
 * Function:
 *      bcm_esw_field_sat_macsa_delete
 * Purpose:
 *      Delete mac sa and class id entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      mac -  (IN) Src Mac.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_sat_macsa_delete(
    int unit,
    bcm_mac_t mac)
{
   int rv = BCM_E_UNAVAIL;
#if defined (BCM_APACHE_SUPPORT)
   
   if (soc_feature(unit, soc_feature_fp_based_sat)) {
       FP_LOCK(unit);
       rv = _bcm_field_apache_sat_macsa_delete(unit, mac);
       FP_UNLOCK(unit);
   }
#endif
   return rv;
}

/*
 * Function:
 *      bcm_esw_field_sat_macsa_delete_all
 * Purpose:
 *      Delete all mac sa and class id entries.
 * Parameters:
 *      unit - (IN) Unit number.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_sat_macsa_delete_all(int unit)
{
   int rv = BCM_E_UNAVAIL;
#if defined (BCM_APACHE_SUPPORT)
   
   if (soc_feature(unit, soc_feature_fp_based_sat)) {
       FP_LOCK(unit);
       rv = _bcm_field_apache_sat_macsa_delete_all(unit);
       FP_UNLOCK(unit);
   }
#endif
   return rv;
}

/*
 * Function: bcm_esw_field_action_ports_add
 *
 * Purpose:
 *     Add PBMP related actions, when entry rule is matched for a packet
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - entry ID
 *     action - bcmFieldActionRedirectPbmp or
 *              bcmFieldActionEgressMask or
 *              bcmFieldActionEgressPortsAdd or
 *              bcmFieldActionRedirectBcastPbmp
 *     pbmp - Port Bitmap for the action
 *
 * Returns:
 *     BCM_E_INIT      - BCM Unit not initialized
 *     BCM_E_NOT_FOUND - Entry ID not found
 *     BCM_E_MEMORY    - Allocation failure
 *     BCM_E_PARAM     - Incorrect action parameter
 *     BCM_E_NONE      - Success
 */

int
bcm_esw_field_action_ports_add(int unit,
                               bcm_field_entry_t entry,
                               bcm_field_action_t action,
                               bcm_pbmp_t pbmp)
{
    uint32  param[_FP_ACTION_PARAM_SZ];     
    int rv = 0;
    int i;
    bcm_pbmp_t valid_pbmp;
    int port = -1;
    int link_status = -1;

    if ((action != bcmFieldActionRedirectPbmp) && 
        (action != bcmFieldActionEgressMask) &&
        (action != bcmFieldActionEgressPortsAdd) &&
        (action != bcmFieldActionRedirectBcastPbmp)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: Incorrect action parameter\n"),
                   unit));
        return (BCM_E_PARAM);
    }

    BCM_PBMP_CLEAR(valid_pbmp);
    sal_memset(&param, 0, sizeof(param));

    if ((soc_feature(unit, soc_feature_epc_linkflap_recover))
            && action == bcmFieldActionEgressPortsAdd) {
        BCM_PBMP_ITER(pbmp, port) {
            rv = _bcm_esw_link_get (unit,port,&link_status);
            if (rv == BCM_E_NONE) {
                if (link_status == BCM_PORT_LINK_STATUS_UP) {
                    BCM_PBMP_PORT_ADD (valid_pbmp,port);
                }
            }
        }
    } else {
       rv = _bcm_field_valid_pbmp_get(unit, &valid_pbmp);
       BCM_IF_ERROR_RETURN(rv);

       if (soc_feature(unit, soc_feature_vxlan_decoupled_mode)
           && (bcmFieldActionEgressMask == action)) {
           BCM_PBMP_OR(valid_pbmp, PBMP_LB(unit));
       }

       BCM_PBMP_AND(valid_pbmp, pbmp);
       if (BCM_PBMP_NEQ(valid_pbmp, pbmp)) {
          return BCM_E_PARAM;
       }

       BCM_PBMP_ASSIGN(valid_pbmp, pbmp);
    }

    for (i = 0; (i < _FP_ACTION_PARAM_SZ) && (i < SOC_PBMP_WORD_MAX) ; i++) {
        param[i] = SOC_PBMP_WORD_GET(valid_pbmp, i);
    }
    rv = _bcm_field_action_ports_add(unit, entry, action,
            param[0], param[1], param[2], param[3], param[4], param[5]);

    /* When _field_egr_ports_recovery_lock is set to zero, it implies
     * that the EgressPortsAdd bitmap is updated by the user. Hence
     * the EgressPortsAdd Recovery Database should be updated.
     */
    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit)) {
            if ((action == bcmFieldActionEgressPortsAdd) &&
                    (_field_egr_ports_recovery_lock[unit] == 0) &&
                    (rv == BCM_E_NONE)) {
                _bcm_trx_field_egr_ports_recovery_add (unit, entry, pbmp);
            }
        }
#endif
    }
    return rv;
}

/*
 * Function: bcm_esw_field_action_get
 *
 * Purpose:
 *     Get parameters associated with an entry action
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - Entry ID
 *     action - Action to perform (bcmFieldActionXXX)
 *     param0 - (OUT) Action parameter
 *     param1 - (OUT) Action parameter
 *
 * Returns:
 *     BCM_E_INIT      - BCM Unit not initialized
 *     BCM_E_NOT_FOUND - Entry ID not found
 *     BCM_E_NOT_FOUND - No matching Action for entry
 *     BCM_E_PARAM     - paramX is NULL
 *     BCM_E_NONE      - Success
 */

int
bcm_esw_field_action_get(int unit,
                         bcm_field_entry_t entry,
                         bcm_field_action_t action,
                         uint32 *param0,
                         uint32 *param1)
{
    _field_entry_t      *f_ent;
    _field_action_t     *fa = NULL;
    uint8               idx;
    int                 rv;
    int                 parts_count = 0;
#if defined(BCM_TOMAHAWK_SUPPORT)
    int                 copyTocpu_revert_flg = 0;
#endif /* BCM_TOMAHAWK_SUPPORT */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) && 
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
       return _bcm_field_presel_action_get
                    (unit, entry, action, param0, param1);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Input parameters check. */
    if ((NULL == param0) || (NULL == param1)) {
       return (BCM_E_PARAM);
    }

    /* Lock the module. */
    
    FP_LOCK(unit);

    rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
               (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        parts_count = 1;
    } else
#endif
    {
        rv = _bcm_field_entry_tcam_parts_count (unit, f_ent->group->stage_id,
                                           f_ent->group->flags, &parts_count);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    if (bcmFieldActionColorIndependent == action) {
        *param0 = (f_ent->flags & _FP_ENTRY_COLOR_INDEPENDENT) ? 1 : 0;
        *param1 = 0;
        /* Unlock the module. */
        FP_UNLOCK(unit);
        return (BCM_E_NONE);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if ((SOC_INFO(unit).th_ctc_replace_enabled) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
         (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH)) &&
        (action == bcmFieldActionCopyToCpu)) {
        action = bcmFieldActionMirrorEgress;
        copyTocpu_revert_flg = 1;
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Find matching action in the entry */
    for (idx = 0; idx < parts_count; idx++) {
        fa = f_ent[idx].actions;
        while (fa != NULL) {
        if (fa->action == action) {
                /* if match found, jump out of searching loop */
                goto action_found;
            }
            fa = fa->next;
        }
    }

action_found:
    if (fa == NULL) {
        FP_UNLOCK(unit);
        LOG_VERBOSE(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: action not in entry=%d\n"),
                     unit, entry));
        return (BCM_E_NOT_FOUND);
    }

#ifdef BCM_APACHE_SUPPORT
    /* Configured not using
       bcm_field_action_copytocpu_config_set API */
    if ((bcmFieldActionCopyToCpu == action) &&
            SOC_IS_APACHE(unit) &&
            soc_feature(unit, soc_feature_ep_redirect_v2) &&
            (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) &&
            (fa->param[2])) {
        FP_UNLOCK(unit);
        LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: action configured using"
                            " bcm_field_action_copytocpu_config_set in entry=%d\n"),
                 unit, entry));
        return (BCM_E_CONFIG);
    }
    /* Configured not using
       bcm_field_action_redirect_config_set API */
    if ((bcmFieldActionRedirect == action) &&
            SOC_IS_APACHE(unit) &&
            soc_feature(unit, soc_feature_ep_redirect_v2) &&
            (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS) &&
            (fa->param[2])) {
        FP_UNLOCK(unit);
        LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: action configured using"
                            " bcm_field_action_redirect_config_set in entry=%d\n"),
                 unit, entry));
        return (BCM_E_CONFIG);
    }
#endif

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (copyTocpu_revert_flg == 1) {
        *param0 = fa->param[2];
        *param1 = fa->param[3];
        FP_UNLOCK(unit);
        return BCM_E_NONE;
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    *param0 = fa->param[0];
    *param1 = fa->param[1];

    /* Unlock the module. */
    FP_UNLOCK(unit);

    /* Adapt action parameters */
    rv = _field_params_hw_to_api_adapt(unit, action, param0, param1);
    return (rv);
}

/*
 * Function: bcm_esw_field_action_ports_get
 *
 * Purpose:
 *     Get parameters associated with port related entry actions
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - Entry ID
 *     action - Action
 *     pbmp - (OUT) Action parameter
 *
 * Returns:
 *     BCM_E_INIT      - BCM Unit not initialized
 *     BCM_E_NOT_FOUND - Entry ID not found
 *     BCM_E_NOT_FOUND - No matching Action for entry
 *     BCM_E_PARAM     - incorrect action OR pbmp is NULL
 *     BCM_E_NONE      - Success
 */

int
bcm_esw_field_action_ports_get(int unit,
                               bcm_field_entry_t entry,
                               bcm_field_action_t action,
                               bcm_pbmp_t *pbmp)
{

    uint32 param[_FP_ACTION_PARAM_SZ];
    int    i;
    int    rv;

    /* Input parameter check. */
    if (NULL == pbmp) {
        return (BCM_E_PARAM);
    }

    if ((action != bcmFieldActionRedirectPbmp) && 
        (action != bcmFieldActionEgressMask) &&
        (action != bcmFieldActionRedirectBcastPbmp) &&
        (action != bcmFieldActionEgressPortsAdd)) {
        return (BCM_E_PARAM);
    }


    sal_memset(param, 0, sizeof(param));

    /* Extract action information from field entry. */
    rv = _bcm_field_action_ports_get(unit, entry,
            action, param, param + 1, param + 2, param + 3,
            param + 4, param + 5);
    BCM_IF_ERROR_RETURN(rv);

    BCM_PBMP_CLEAR(*pbmp);
    /* When API is called externally, return pbmp from the
     * Egress Port Bitmap Recovery
     */
    if (soc_feature(unit, soc_feature_epc_linkflap_recover)) {
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit)) {
            if ((action == bcmFieldActionEgressPortsAdd) &&
                    (_field_egr_ports_recovery_lock[unit] == 0)) {
                _bcm_trx_field_egr_ports_recovery_entry_pbmp_get (unit, entry, pbmp);
                return (BCM_E_NONE);
            }
        }
#endif
    }

    for (i = 0; (i < _FP_ACTION_PARAM_SZ) && (i < SOC_PBMP_WORD_MAX); i++) {
        SOC_PBMP_WORD_SET(*pbmp, i, param[i]);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_action_mac_get
 * Purpose:
 *      Retrieve the parameters for an action previously added to a
 *      field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry Id.
 *      action - (IN) Field action id.
 *      mac - (IN) Field action argument.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_action_mac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    bcm_mac_t *mac)
{
    uint32 param[_FP_ACTION_PARAM_SZ];     
    int    rv;

    /* Input parameter check. */
    if (NULL == mac) {
        return (BCM_E_PARAM);
    }

    if ((action != bcmFieldActionSrcMacNew) && 
        (action != bcmFieldActionDstMacNew) &&
        (action != bcmFieldActionReplaceDstMac) &&
        (action != bcmFieldActionReplaceSrcMac) ) {

        return (BCM_E_PARAM);
    }
    
    /* Extract action information from field entry. */
    rv = bcm_esw_field_action_get(unit, entry, action, 
                                  param, param + 1);
    BCM_IF_ERROR_RETURN(rv);

    SAL_MAC_ADDR_FROM_UINT32((*mac), param);
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_field_action_delete
 * Purpose:
 *      Delete an action from a field entry.
 * Parameters:
 *      unit   - (IN) BCM device number
 *      entry  - (IN) Entry ID
 *      action - (IN) Action to remove (bcmFieldActionXXX)
 *      param0 - (IN) Action parameter (use 0 if not required)
 *      param1 - (IN) Action parameter (use 0 if not required)
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_action_delete(int unit, bcm_field_entry_t entry, 
                        bcm_field_action_t action, 
                        uint32 param0, uint32 param1)
{
    int rv;                /* Operation return status. */

    if (action < 0 || bcmFieldActionCount <= action) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: unknown action=%d\n"),
                   unit, action));
        return (BCM_E_PARAM);
    }

    
#if defined(BCM_TOMAHAWK_SUPPORT) 
     /*
      * Manuplate EgressMirror to CopyToCpu Action for CTC WAR.
      */
     if ((SOC_INFO(unit).th_ctc_replace_enabled) &&
          (action == bcmFieldActionCopyToCpu)) {
         _field_entry_t      *f_ent;

         BCM_IF_ERROR_RETURN(_field_entry_get(unit, entry,
                              _FP_ENTRY_PRIMARY, &f_ent));
         if ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
             (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH)) {
            action = bcmFieldActionMirrorEgress;
         }
     }
#endif /* BCM_TOMOHAWK_SUPPORT */

    /* Adapt action parameters */
    rv = _field_params_api_to_hw_adapt(unit, action, &param0, &param1);
    BCM_IF_ERROR_RETURN(rv);

    FP_LOCK(unit);

    rv = _field_action_delete(unit, entry, action, param0, param1);

    FP_UNLOCK(unit);
    return rv;
}




/*
 * Function: bcm_esw_field_action_remove
 *
 * Purpose:
 *     Remove an action performed when entry rule is matched for a packet.
 *
 * Parameters:
 *     unit   - BCM device number
 *     entry  - Entry ID
 *     action - Action to remove (bcmFieldActionXXX)
 *
 * Returns:
 *     BCM_E_INIT      - BCM Unit not initialized
 *     BCM_E_NOT_FOUND - Entry ID not found
 *     BCM_E_NOT_FOUND - No matching Action for entry
 *     BCM_E_PARAM     - Action out of valid range.
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_action_remove(int unit,
                            bcm_field_entry_t entry,
                            bcm_field_action_t action)
{
    int rv;                /* Operation return status. */

    
    FP_LOCK(unit);

    if (soc_feature(unit, soc_feature_epc_linkflap_recover)){
#if defined(BCM_TRX_SUPPORT)
        if (SOC_IS_TRX(unit)) {
            if ((action == bcmFieldActionEgressPortsAdd) &&
                    (_field_egr_ports_recovery_lock[unit] == 0)) {
                /* Clear EntryId from _entry_egr_ports_recovery database*/
                _bcm_trx_field_egr_ports_recovery_entry_remove (unit, entry);
            }
        }
#endif
    }

    rv = bcm_esw_field_action_delete(unit, entry, action, 
                                     (uint32)_FP_INVALID_INDEX, 
                                     (uint32)_FP_INVALID_INDEX);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_action_remove_all
 *
 * Purpose:
 *     Remove all actions from an entry rule.
 *
 * Parameters:
 *     unit - BCM device number
 *     entry - Entry ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM Unit not initialized
 *     BCM_E_NOT_FOUND - Entry ID not found
 *     BCM_E_NONE      - Success
 */

int
bcm_esw_field_action_remove_all(int unit,
                                bcm_field_entry_t entry)
{
    _field_entry_t      *f_ent;
    _field_action_t     *fa;
    int                  rv = BCM_E_NONE;      /* Operation return status.  */

    /* Get field control structure. */
    
    FP_LOCK(unit);

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }


    /* start at the head of the actions list and burn them up */
    fa = f_ent->actions;
    /* No action is present */
    if (fa == NULL) {
        FP_UNLOCK(unit);
        return rv;
    }

    while (fa != NULL) {
        rv = _field_action_delete(unit, entry, fa->action, 
                                  fa->param[0], fa->param[1]);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

        /* 
         * Action might be removed from the entry actions
         * list only if entry was not installed.
         * Otherwise clean up will happen during reinstall.
         */
        fa = (f_ent->flags & _FP_ENTRY_INSTALLED) ? \
            fa->next : f_ent->actions;
    }

    f_ent->flags |= _FP_ENTRY_DIRTY;

    FP_UNLOCK(unit);
    return (rv);
}

/* Section: Field Statistics */

/*
 * Function: 
 *    bcm_esw_field_stat_create
 *
 * Description:
 *       Create statistics collection entity.
 * Parameters:
 *      unit     - (IN) BCM device number.
 *      group    - (IN) Field group id. 
 *      nstat    - (IN) Number of elements in stat array.
 *      stat_arr - (IN) Collected statistics descriptors array.
 *      stat_id  - (OUT) Statistics entity id.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_stat_create(int unit, bcm_field_group_t group, int nstat, 
                          bcm_field_stat_t *stat_arr, int *stat_id) 
{
    int                  rv;      /* Operation return status.  */

    /* Get field control structure. */
    
    FP_LOCK(unit);

    rv = _field_stat_create(unit, group, nstat, stat_arr, 0, stat_id);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: 
 *    bcm_esw_field_stat_create_id
 *
 * Description:
 *       Create statistics collection entity with specified ID.
 * Parameters:
 *      unit     - (IN) BCM device number.
 *      group    - (IN) Field group id. 
 *      nstat    - (IN) Number of elements in stat array.
 *      stat_arr - (IN) Collected statistics descriptors array.
 *      stat_id  - (IN) Statistics entity id.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_stat_create_id(int unit, bcm_field_group_t group, int nstat, 
                          bcm_field_stat_t *stat_arr, int stat_id) 
{
    int                  rv;      /* Operation return status.  */
    int                  stat_id_local = stat_id; /* Stats ID value */

    /* Check if Stat ID is in software supported range */
    if ((stat_id < _FP_ID_BASE) || (stat_id > _FP_ID_MAX)) {
        return (BCM_E_PARAM);
    }
    /* Get field control structure. */
    
    FP_LOCK(unit);

    rv = _field_stat_create(unit, group, nstat, stat_arr,
            _FP_STAT_CREATE_ID, &stat_id_local);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_stat_attach
 * Description:
 *      Attach counters entries to a field group 
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      group            - (IN) Field group statistics entity will be
 *                              Associated with in the future 
 *      Stat_counter_id  - (IN) Stat Counter ID.
 *      Stat_id          - (OUT) Statistics entity ID.
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */

int
bcm_esw_field_stat_attach(int unit, bcm_field_group_t field_group, 
                          uint32 stat_counter_id, uint32 *stat_id)
{
    _field_stat_t                *f_st=NULL;    /* Field statistics entity.  */
    int                          rv=0;          /* Operation return status.  */
    bcm_stat_group_mode_t        group_mode= bcmStatGroupModeSingle;            
    bcm_field_stat_t             field_stat[2]={bcmFieldStatBytes,              
                                             bcmFieldStatPackets};
    int                          nstat=2;
    uint32                       stat_flag=_FP_STAT_INTERNAL_FLEX_COUNTER;

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    bcm_stat_flex_direction_t    direction=bcmStatFlexDirectionIngress;
    bcm_stat_flex_mode_t         offset_mode=0;
#endif
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_HURRICANE3_SUPPORT)
    uint32                       pool_number=0;
    uint32                       base_index=0;
    bcm_stat_object_t            object=bcmStatObjectIngPort;
    uint32                       total_counters=1;
#endif
#if defined(BCM_TOMAHAWK_SUPPORT)
   _field_group_t *fg = NULL;  /* Group Operational Structure. */
#endif


#if defined(BCM_TOMAHAWK_SUPPORT)
   BCM_IF_ERROR_RETURN(_field_group_get(unit, field_group, &fg));
   if (((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) ||
        (_BCM_FIELD_STAGE_LOOKUP == fg->stage_id) ||
        (_BCM_FIELD_STAGE_EXACTMATCH == fg->stage_id)) &&
        (soc_feature(unit, soc_feature_advanced_flex_counter)) &&
        (soc_feature(unit, soc_feature_field_multi_pipe_support))) {
        return _bcm_field_th_stat_attach(unit, field_group, stat_counter_id, stat_id);
   }
#endif

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if ((_BCM_FIELD_STAGE_FLOWTRACKER == fg->stage_id) ||
        (_BCM_FIELD_STAGE_AMFTFP == fg->stage_id) ||
        (_BCM_FIELD_STAGE_AEFTFP == fg->stage_id)) {
        return (BCM_E_UNAVAIL);
    }
#endif

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
    if (soc_feature(unit,soc_feature_advanced_flex_counter)) {
        _bcm_esw_stat_get_counter_id_info(
                  unit,
                  stat_counter_id,
                  &group_mode,&object,&offset_mode,&pool_number,&base_index);

        BCM_IF_ERROR_RETURN(_bcm_esw_stat_validate_object(unit,object,&direction));
        BCM_IF_ERROR_RETURN(_bcm_esw_stat_validate_group(unit,group_mode));

        if (object != bcmStatObjectIngPolicy &&
                object != bcmStatObjectIngEXTPolicy) {
#if defined(BCM_TRIDENT3_SUPPORT)
            /* StageEgress is supported only for TD3 */
            if (soc_feature(unit, soc_feature_td3_style_fp)) {
               if (object != bcmStatObjectEgrFieldStageEgress) {
                    LOG_VERBOSE(BSL_LS_BCM_FP,
                            (BSL_META_U(unit, "Retrieved object need to be"
                                     " bcmStatObjectIngPolicy or"
                                     " bcmStatObjectIngEXTPolicy or"
                                     " bcmStatObjectEgrFieldStageEgress\n\r")));
                    return BCM_E_PARAM;
               }
            } else
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TRIDENT2PLUS_SUPPORT)
            /* StageIngress,StageEgress is supported only for TD2PLUS */
            if (SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit)) {
                if ((object != bcmStatObjectIngFieldStageIngress) &&
                        (object != bcmStatObjectEgrFieldStageEgress)) {
                    LOG_VERBOSE(BSL_LS_BCM_FP,
                            (BSL_META_U(unit, "Retrieved object need to be"
                                        " bcmStatObjectIngPolicy or"
                                        " bcmStatObjectIngEXTPolicy or"
                                        " bcmStatObjectEgrFieldStageEgress or"
                                        " bcmStatObjectIngFieldStageIngress\n")));
                    return BCM_E_PARAM;
                }
            } else
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
            {
                LOG_VERBOSE(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "Retrieved object need to be bcmStatObjectIngPolicy or"
                                    "bcmStatObjectIngEXTPolicy\n")));
                return BCM_E_PARAM;
            }
        }

        rv = _bcm_esw_stat_total_counters_get(unit,
                    stat_counter_id, &total_counters);
        if (BCM_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "Unable to retrieve number of counters based on flex stat id\n")));
            return rv;
        }
    }
#endif
#if defined(BCM_HURRICANE3_SUPPORT)
    if (soc_feature(unit,soc_feature_flowcnt)) {
        uint32  profile_group=0;

        _bcm_esw_flowcnt_counter_id_get(stat_counter_id,
            &group_mode, &object, &profile_group, 
            &pool_number, &base_index);
        BCM_IF_ERROR_RETURN(
            _bcm_esw_flowcnt_total_counters_get(unit,
                    stat_counter_id, &total_counters));

        /* Assign default counter mode is packet count */
        field_stat[0] = bcmFieldStatPackets;
        nstat = 1;
        stat_flag = _FP_STAT_FLOWCNT_CNTR;
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    
    FP_LOCK(unit);

#if defined BCM_TRIDENT2PLUS_SUPPORT
    /* StageIngress is supported only for TD2PLUS */
    if ((SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit) ||
         soc_feature(unit, soc_feature_td3_style_fp)) &&
        ((object == bcmStatObjectIngFieldStageIngress) ||
         (object == bcmStatObjectEgrFieldStageEgress))) {
        stat_flag = _FP_STAT_FLEX_CNTR;
        }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
        rv = _field_stat_create( unit, field_group, nstat, field_stat,
                stat_flag,(int *)stat_id);

    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = _bcm_field_stat_get(unit, *stat_id, &f_st);
    if(BCM_FAILURE(rv)) {
       FP_UNLOCK(unit);
       bcm_esw_field_stat_destroy(unit,*stat_id);
       return rv;
    }
    FP_UNLOCK(unit);
    f_st->flex_mode = stat_counter_id;

    /* Update STAT group mode. */
    if (soc_feature(unit,soc_feature_advanced_flex_counter)) {     
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
       f_st->hw_mode = offset_mode;      /* Advanced Flex stat mode */
       f_st->pool_index = pool_number;
       f_st->hw_index = base_index;
       f_st->hw_entry_count = total_counters;
       f_st->hw_flags |= _FP_STAT_CREATED_BY_FLEX_MODULE;
#else
       f_st->hw_mode = group_mode;      /* Advanced Flex stat mode */
#endif
    } else
#if defined(BCM_HURRICANE3_SUPPORT)        
    if (soc_feature(unit,soc_feature_flowcnt)) {
        f_st->hw_mode = group_mode;
        f_st->pool_index = pool_number;
        f_st->hw_index = base_index;
        f_st->hw_entry_count = total_counters;
    } else
#endif
    {
       f_st->hw_mode = 1;               /* VFP Flex counters use mode 1 */  
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_stat_detach
 * Description:
 *      Detach counters entries to a field group. 
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      Stat_id          - (IN) Statistics entity ID.
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes: It might be deprecated soon.
 */

int
bcm_esw_field_stat_detach(int unit, uint32 stat_id)
{
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_HURRICANE3_SUPPORT)
    _field_stat_t     *f_st=NULL;       /* Field statatistics entity.    */
    _field_group_t    *group_p=NULL;    /* Group info. */
    int               entry_index=0;

    if (!soc_feature(unit,soc_feature_advanced_flex_counter) &&
        !soc_feature(unit,soc_feature_flowcnt)) {
         return BCM_E_UNAVAIL;
    }

    BCM_IF_ERROR_RETURN(_bcm_field_stat_get(unit, stat_id, &f_st));
    BCM_IF_ERROR_RETURN(_field_group_get(unit,f_st->gid,&group_p));
    for (entry_index = 0;
         entry_index < group_p->group_status.entry_count;
         entry_index++) {
         BCM_IF_ERROR_RETURN(bcm_esw_field_entry_stat_detach(
                             unit,group_p->entry_arr[entry_index]->eid,
                             stat_id));
    }
    return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
}


/*
 * Function:
 *      bcm_esw_field_stat_counter_get
 * Description:
 *      Get counter statistic values for a field entity
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      Stat_id          - (IN) Statistics entity ID.
 *      stat             - (IN) Type of the counter to retrieve
 *                              I.e. ingress/egress byte/packet)
 *      num_entries      - (IN) Number of counter Entries
 *      counter_indexes  - (IN) Pointer to Counter indexes entries
 *      counter_values   - (OUT) Pointer to counter values
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_stat_counter_get(int unit, uint32 stat_id, bcm_field_stat_t stat, 
                               uint32 num_entries, uint32 *counter_indexes, 
                               bcm_stat_value_t *counter_values)
{

    return _bcm_esw_field_stat_counter_get(unit, 0, stat_id, stat, num_entries,
                                         counter_indexes, counter_values);
   
}

/*
 * Function:
 *      bcm_esw_field_stat_counter_sync_get
 * Description:
 *      Get counter statistic values fori a field entity
 *      sw accumulated counters synced with hw count.
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      Stat_id          - (IN) Statistics entity ID.
 *      stat             - (IN) Type of the counter to retrieve
 *                              I.e. ingress/egress byte/packet)
 *      num_entries      - (IN) Number of counter Entries
 *      counter_indexes  - (IN) Pointer to Counter indexes entries
 *      counter_values   - (OUT) Pointer to counter values
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_stat_counter_sync_get(int unit, uint32 stat_id, 
                               bcm_field_stat_t stat, 
                               uint32 num_entries, uint32 *counter_indexes, 
                               bcm_stat_value_t *counter_values)
{

    return _bcm_esw_field_stat_counter_get(unit, 1, stat_id, stat, num_entries,
                                         counter_indexes, counter_values);
   
}

/*
 * Function:
 *      bcm_esw_field_stat_counter_set
 * Description:
 *      Set counter statistic values for a field entity 
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      Stat_id          - (IN) Statistics entity ID.
 *      stat             - (IN) Type of the counter to retrieve
 *                              I.e. ingress/egress byte/packet)
 *      num_entries      - (IN) Number of counter Entries
 *      counter_indexes  - (IN) Pointer to Counter indexes entries
 *      counter_values   - (IN) Pointer to counter values
 *
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_stat_counter_set(int unit, uint32 stat_id, bcm_field_stat_t stat, 
                               uint32 num_entries, uint32 *counter_indexes, 
                               bcm_stat_value_t *counter_values)
{
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_HURRICANE3_SUPPORT)
    _field_stat_t                   *f_st=NULL; /* Field statistics entity.  */
    uint32                          index_count=0;
    uint32                          byte_flag=0;

    if (!soc_feature(unit, soc_feature_advanced_flex_counter) &&
        !soc_feature(unit, soc_feature_flowcnt)) {
         return BCM_E_UNAVAIL;
    }

    if (stat == bcmFieldStatPackets ||
        stat == bcmFieldStatGreenPackets ||
        stat == bcmFieldStatYellowPackets ||
        stat == bcmFieldStatRedPackets ||
        stat == bcmFieldStatNotGreenPackets ||
        stat == bcmFieldStatNotYellowPackets ||
        stat == bcmFieldStatNotRedPackets) {
        byte_flag=0;
    } else {
        byte_flag=1;
    }

    
    BCM_IF_ERROR_RETURN(_bcm_field_stat_get(unit, stat_id, &f_st));
    if (f_st->flex_mode == 0) {
        LOG_VERBOSE(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "Entry not attached \n")));
        return BCM_E_PARAM;
    }

    if (NULL == counter_values || NULL == counter_indexes) {
        return BCM_E_PARAM;
    }

    for (index_count=0; index_count < num_entries ; index_count++) {
#if defined(BCM_HURRICANE3_SUPPORT)        
        if (soc_feature(unit, soc_feature_flowcnt)) {
            BCM_IF_ERROR_RETURN(_bcm_esw_flowcnt_counter_raw_set(
                             unit, f_st->flex_mode, byte_flag,
                             counter_indexes[index_count],
                             &counter_values[index_count]));
            /* update the stat mode */
            if (byte_flag == 1) {
                f_st->stat_arr[index_count] = bcmFieldStatBytes;
            } else {
                f_st->stat_arr[index_count] = bcmFieldStatPackets;
            }
            
        }
#endif /* BCM_HURRICANE3_SUPPORT */         
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)        
        if (soc_feature(unit, soc_feature_advanced_flex_counter)) { 
            BCM_IF_ERROR_RETURN(_bcm_esw_stat_counter_raw_set(
                             unit, f_st->flex_mode, byte_flag,
                             counter_indexes[index_count],
                             &counter_values[index_count]));
        }
#endif /*  BCM_KATANA_SUPPORT || BCM_TRIUMPH3_SUPPORT */
    } 

    return BCM_E_NONE;
#else
    return BCM_E_UNAVAIL;
#endif
}

/*
 * Function:
 *      bcm_esw_field_stat_id_get
 * Description:
 *      Get stat counter id associated with given gpo
 *
 * Parameters:
 *      unit             - (IN) unit number
 *      group            - (IN) Field group 
 *      Stat_id          - (IN) Statistics entity ID.
 *      Stat_counter_id  - (OUT) Stat Counter ID
 * Return Value:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_stat_id_get(int               unit,
                              bcm_field_group_t group,
                              uint32            stat_id, 
                              uint32            *stat_counter_id)
{
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT)
   _field_group_t      *fg=NULL;       /* Group structure to free up       */
   bcm_field_entry_t   *entry_array=NULL;
   int                 max_entry_count=0;
   int                 entry_index=0;
   int                 entry_count=0;
   uint32              local_stat_id=0;
   _field_stat_t       *f_st=NULL;    /* Field statistics entity.  */
   int                 rv;


   
   BCM_IF_ERROR_RETURN(_field_group_get(unit, group, &fg));
   BCM_IF_ERROR_RETURN(bcm_esw_field_entry_multi_get(
                       unit,group,0,NULL,&max_entry_count));
   if (max_entry_count == 0) {
       return BCM_E_NOT_FOUND;
   }
   if ((entry_array = sal_alloc(max_entry_count*sizeof (bcm_field_entry_t),
                               "Entry Array")) == NULL) {
        LOG_CLI((BSL_META_U(unit,
                            "Couldn't allocate memoryentry_count=%d"),
                 entry_count));
        return BCM_E_MEMORY;
   }
   if ((rv=bcm_esw_field_entry_multi_get(unit,group,max_entry_count,
                                    entry_array,&entry_count)) != BCM_E_NONE) {
        sal_free(entry_array);
        return rv;
   }
   for (entry_index=0;entry_index < entry_count ; entry_index++) {

        rv = bcm_esw_field_entry_stat_get(unit,
                                        entry_array[entry_index],
                                        (int *)&local_stat_id);

        /* Stats are not attached to this entry , So skip it. */
        if (BCM_E_NOT_FOUND == rv) {
            continue;
        }

        if (BCM_E_NONE != rv)         
        {
            sal_free(entry_array);
            return rv;
        }

        if ((rv=_bcm_field_stat_get(unit,local_stat_id,&f_st)) != BCM_E_NONE) {
             sal_free(entry_array);
             return rv;
        }

        if (local_stat_id == stat_id ) {
            *stat_counter_id=f_st->flex_mode;
            sal_free(entry_array);
            return BCM_E_NONE;
        }
   }
   sal_free(entry_array);
   return BCM_E_PARAM;
#else
    return BCM_E_UNAVAIL;
#endif
}

/*
 * Function: 
 *    bcm_esw_field_stat_destroy
 *
 * Description:
 *       Destroy statistics collection entity.
 * Parameters:
 *      unit     - (IN) BCM device number.
 *      stat_id  - (IN) Statistics entity id.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_stat_destroy(int unit, int stat_id)
{
    int                  rv;      /* Operation return status.  */

    /* Get field control structure. */
    
    FP_LOCK(unit);

    rv = _field_stat_destroy(unit, stat_id);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: 
 *     bcm_esw_field_stat_size
 *
 * Description:
 *      Get number of different statistics associated with statistics
 *      collection entity.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      stat_id   - (IN) Statistics entity id.
 *      stat_size - (OUT) Number of collercted statistics
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_stat_size(int unit, int stat_id, int *stat_size)
{
    _field_stat_t       *f_st;    /* Field statistics entity.  */
    int                  rv;      /* Operation return status.  */

    /* Input parameters check */
    if (NULL == stat_size) {
        return (BCM_E_PARAM);
    }

    /* Get field control structure. */
    
    FP_LOCK(unit);

    rv = _bcm_field_stat_get(unit, stat_id, &f_st);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    *stat_size = f_st->nstat; 

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: 
 *     bcm_esw_field_stat_config_get
 *
 * Description:
 *      Get enabled statistics for specific collection entity.
 * Parameters:
 *      unit     - (IN) BCM device number.
 *      stat_id  - (IN) Statistics entity id.
 *      nstat    - (IN) Number of elements in stat array.
 *      stat_arr - (OUT) Collected statistics descriptors array.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_stat_config_get(int unit, int stat_id, int nstat, 
                              bcm_field_stat_t *stat_arr)
{
    _field_stat_t       *f_st;     /* Field statistics entity.   */
    int                 stat_count;/* Number of elements to fill.*/
    int                 rv;        /* Operation return status.   */

    /* Input parameters check. */
    if ((NULL == stat_arr) || (nstat <= 0) || (nstat > _bcmFieldStatCount)) {
        return (BCM_E_PARAM);
    }

    /* Get field control structure. */
    
    FP_LOCK(unit);

    rv = _bcm_field_stat_get(unit, stat_id, &f_st);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }


    /* Initialize application provided array. */
    sal_memset(stat_arr, 0, (nstat * sizeof(bcm_field_stat_t)));

    /* Number of items to copy. */
    stat_count = (nstat > f_st->nstat) ? f_st->nstat : nstat;

    sal_memcpy(stat_arr, f_st->stat_arr, 
               (stat_count * sizeof(bcm_field_stat_t)));

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: 
 *      bcm_esw_field_stat_set
 *
 * Description:
 *      Set 64 bit counter value for specific statistic type.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      stat_id   - (IN) Statistics entity id.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (OUT) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_stat_set(int unit, int stat_id, bcm_field_stat_t stat, 
                       uint64 value)
{
    _field_stat_t       *f_st;     /* Field statistics entity.   */
    int                 rv;        /* Operation return status.   */

    /* Get field control structure. */
    
    FP_LOCK(unit);

    /* Get statistics entity descriptor. */
    rv = _bcm_field_stat_get(unit, stat_id, &f_st);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Write specific counter only if statistics entity was installed. */
    if (_FP_INVALID_INDEX == f_st->hw_index) {
        if (COMPILER_64_IS_ZERO(value)) {
            rv = BCM_E_NONE;
        } else {
            rv = BCM_E_UNAVAIL;
        }
    } else {
        rv = _field_stat_value_set(unit, f_st, stat, value);
    }

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: 
 *      bcm_esw_field_stat_set32
 *
 * Description:
 *      Set lower 32 bit counter value for specific statistic type.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      stat_id   - (IN) Statistics entity id.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (OUT) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_stat_set32(int unit, int stat_id, 
                         bcm_field_stat_t stat, uint32 value)
{
    uint64 val64;

    COMPILER_64_SET(val64, 0, value);
    return bcm_esw_field_stat_set (unit, stat_id, stat, val64);
}

/*
 * Function: 
 *      bcm_esw_field_stat_all_set
 *
 * Description:
 *      Set 64 bit counter values for all statistic types.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      stat_id   - (IN) Statistics entity id.
 *      nstat     - (IN) Number of elements in stat array.
 *      stat_arr  - (IN) Collected statistics descriptors array.
 *      value_arr - (OUT) Collected counters values.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_stat_all_set(int unit, int stat_id, uint64 value)
{
    _field_stat_t       *f_st;     /* Field statistics entity.    */
    int                 idx;       /* Statistics iteration index. */
    int                 rv;        /* Operation return status.    */

    /* Get field control structure. */
    
    FP_LOCK(unit);

    rv = _bcm_field_stat_get(unit, stat_id, &f_st);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Read individual statistics. */
    for (idx = 0; idx < f_st->nstat; idx++) {
        rv = bcm_esw_field_stat_set(unit, stat_id, f_st->stat_arr[idx], value);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: 
 *      bcm_esw_field_stat_all_set32
 *
 * Description:
 *      Set 64 bit counter values for all statistic types.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      stat_id   - (IN) Statistics entity id.
 *      nstat     - (IN) Number of elements in stat array.
 *      stat_arr  - (IN) Collected statistics descriptors array.
 *      value_arr - (OUT) Collected counters values.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_stat_all_set32(int unit, int stat_id, uint32 value)
{
    uint64              val64;     /* 64 bit value. */

    COMPILER_64_SET(val64, 0, value);
    return bcm_esw_field_stat_all_set(unit, stat_id, val64);
}


/*
 * Function: 
 *      _bcm_esw_field_stat_get
 *
 * Description:
 *      Get 64 bit counter value for specific statistic type.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      stat_id   - (IN) Statistics entity id.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (OUT) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_stat_get(int unit, int stat_id, bcm_field_stat_t stat,
                        uint64 *value)
{
    return _bcm_esw_field_stat_get(unit, 0, stat_id, stat, value);

}


/*
 * Function: 
 *      bcm_esw_field_stat_sync_get
 *
 * Description:
 *      Get 64 bit counter value for specific statistic type.
 *      sw accumulated counters synced with hw count.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      stat_id   - (IN) Statistics entity id.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (OUT) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_stat_sync_get(int unit, int stat_id, bcm_field_stat_t stat,
                        uint64 *value)
{

    return _bcm_esw_field_stat_get(unit, 1, stat_id, stat, value);

}

/*
 * Function: 
 *      bcm_esw_field_stat_get32
 *
 * Description:
 *      Get lower 32 bit counter value for specific statistic type.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      stat_id   - (IN) Statistics entity id.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (OUT) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_stat_get32(int unit, int stat_id, 
                         bcm_field_stat_t stat, uint32 *value)
{
    uint64 val64;            /* 64 bit counter value.    */
    int rv;                  /* Operation return status. */

    /* Input parameters check. */
    if (NULL == value) {
        return (BCM_E_PARAM);
    }

    /* Read 64 bit counter value. */
    rv = bcm_esw_field_stat_get (unit, stat_id, stat, &val64);
    if (BCM_SUCCESS(rv)) {
        *value = COMPILER_64_LO(val64);
    } 
    return rv;
}

/*
 * Function: 
 *      bcm_esw_field_stat_sync_get32
 *
 * Description:
 *      Get lower 32 bit counter value for specific statistic type.
 *      sw accumulated counters synced with hw count.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      stat_id   - (IN) Statistics entity id.
 *      stat      - (IN) Collected statistics descriptor.
 *      value     - (OUT) Collected counters value.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_stat_sync_get32(int unit, int stat_id, bcm_field_stat_t stat,
                        uint32 *value)
{

    return _bcm_esw_field_stat_get32(unit, 1, stat_id, stat, value);

}

/*
 * Function: 
 *      bcm_esw_field_stat_multi_get
 *
 * Description:
 *      Get 64 bit counter values for multiple statistic types.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      stat_id   - (IN) Statistics entity id.
 *      nstat     - (IN) Number of elements in stat array.
 *      stat_arr  - (IN) Collected statistics descriptors array.
 *      value_arr - (OUT) Collected counters values.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_stat_multi_get(int unit, int stat_id, int nstat, 
                             bcm_field_stat_t *stat_arr, uint64 *value_arr)
{
    int                 rv;        /* Operation return status.    */
    int                 idx;       /* Statistics iteration index. */

    /* Input parameters check. */
    for (idx = 0; idx < nstat; idx++) {
        if ((NULL == stat_arr + idx) ||
            (NULL == value_arr + idx)) {
       /* 
        * COVERITY 
        * 
        * This conditin may not hit.
        * It is kept intentionally as a defensive check. 
        */
        /* coverity[dead_error_line] */
            return (BCM_E_PARAM);
        }
    }

    /* Get field control structure. */
    
    FP_LOCK(unit);

    /* Read individual statistics. */
    for (idx = 0; idx < nstat; idx++) {
        rv = bcm_esw_field_stat_get(unit, stat_id, stat_arr[idx], 
                                    value_arr + idx);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function: 
 *      bcm_esw_field_stat_multi_get32
 *
 * Description:
 *      Get lower 32 bit counter values for multiple statistic types.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      stat_id   - (IN) Statistics entity id.
 *      nstat     - (IN) Number of elements in stat array.
 *      stat_arr  - (IN) Collected statistics descriptors array.
 *      value_arr - (OUT) Collected counters values.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_stat_multi_get32(int unit, int stat_id, int nstat, 
                               bcm_field_stat_t *stat_arr, 
                               uint32 *value_arr)
{
    uint64              value;     /* 64 bit counter value.       */
    int                 rv;        /* Operation return status.    */
    int                 idx;       /* Statistics iteration index. */

    /* Input parameters check. */
    for (idx = 0; idx < nstat; idx++) {
        if ((NULL == stat_arr + idx) ||
            (NULL == value_arr + idx)) {
       /* 
        * COVERITY 
        * 
        * This conditin may not hit.
        * It is kept intentionally as a defensive check. 
        */
        /* coverity[dead_error_line] */
            return (BCM_E_PARAM);
        }
    }

    /* Get field control structure. */
    
    FP_LOCK(unit);

    /* Read individual statistics. */
    for (idx = 0; idx < nstat; idx++) {
        rv = bcm_esw_field_stat_get(unit, stat_id, stat_arr[idx], &value);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
        value_arr[idx] = COMPILER_64_LO(value);
    }

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function: 
 *      bcm_esw_field_entry_stat_attach
 *
 * Description:
 *       Attach statistics entity to Field Processor entry.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      entry     - (IN) Field entry id. 
 *      stat_id   - (IN) Statistics entity id.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_entry_stat_attach(int unit, bcm_field_entry_t entry, 
                                int stat_id)
{
    _field_entry_t      *f_ent;   /* Internal entry descriptor.       */
    _field_control_t    *fc;      /* Field control structure.  */
    int                  rv;      /* Operation return status.  */
#if defined(BCM_TOMAHAWK_SUPPORT)
    int action_size = 0;          /* Field Action Size.        */
#endif 

    /* Get field control structure. */
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /* Get entry description structure. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
              (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }

    if (f_ent->flags & _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT) {
        rv = _field_th_em_entry_action_size_get(unit, f_ent,
                                                &action_size, NULL);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
        
        if (action_size > EM_DEFAULT_POLICY_ACTION_DATA_SIZE) {
            FP_UNLOCK(unit);
            return (BCM_E_RESOURCE);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Attach statistics entity to the entry. */
    rv = _field_entry_stat_attach(unit, f_ent, stat_id);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_entry_stat_extended_attach
 *
 * Description:
 *       Attach statistics with stat action entity to Field Processor entry.
 * Parameters:
 *      unit        - (IN) BCM device number.
 *      entry       - (IN) Field entry id.
 *      stat_id     - (IN) Statistics entity id.
 *      stat_action - (IN) Statistics Action. 
 *                         Applicable stat actions are
 *                         bcmFieldStatActionIncrement
 *                         bcmFieldStatActionIncrementCancel
 *                         bcmFieldStatActionSample
 * Returns:
 *      BCM_E_XXX
 */
int bcm_esw_field_entry_stat_extended_attach(int unit,
                                           bcm_field_entry_t entry,
                                           int stat_id,
                                           bcm_field_stat_action_t stat_action) 
{
    int                  rv = BCM_E_UNAVAIL; /* Operation return status.  */
#if defined (BCM_TRIDENT2PLUS_SUPPORT) || defined (BCM_TRIDENT3_SUPPORT) || \
    defined (BCM_KATANA2_SUPPORT)
    _field_entry_t      *f_ent = NULL;       /* Internal entry descriptor.*/

    if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
        return rv;
    }

    if (SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit) ||
            soc_feature(unit, soc_feature_td3_style_fp) ||
             (soc_feature(unit,soc_feature_flex_stat_compaction_support))) {
        /* Get field control structure. */

        FP_LOCK(unit);

        /* Get entry description structure. */
        rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

#if defined (BCM_TRIDENT2PLUS_SUPPORT) || defined (BCM_TRIDENT3_SUPPORT)
        /* Attach statistics with action entity to the entry. */
        if (SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit) ||
                soc_feature(unit, soc_feature_td3_style_fp)) {
            rv = _bcm_field_td2plus_entry_stat_extended_attach (unit, f_ent,
                    stat_id, stat_action);
        } else
#endif
        {
#if defined (BCM_KATANA2_SUPPORT)
            if (soc_feature(unit,soc_feature_flex_stat_compaction_support)) {
                rv = _bcm_field_kt2_entry_stat_extended_attach (unit, f_ent,
                        stat_id, stat_action);
            }
#endif
        }
        FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

    return (rv);
}

/*
 * Function: 
 *      bcm_esw_field_entry_stat_detach
 *
 * Description:
 *       Detach statistics entity to Field Processor entry.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      entry     - (IN) Field entry id. 
 *      stat_id   - (IN) Statistics entity id.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_entry_stat_detach(int unit, bcm_field_entry_t entry,
                                int stat_id)
{
    _field_entry_t      *f_ent;   /* Field entry structure.    */
    _field_control_t    *fc;      /* Field control structure.  */
    int                  rv;      /* Operation return status.  */

    /* Get field control structure. */
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    rv =  fc->functions.fp_entry_stat_detach(unit, f_ent, stat_id);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: 
 *      bcm_esw_field_entry_stat_get
 *
 * Description:
 *      Get statistics entity attached to Field Processor entry.  
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      entry     - (IN) Field entry id. 
 *      stat_id   - (IN) Statistics entity id.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_entry_stat_get(int unit, bcm_field_entry_t entry, int *stat_id)
{
    _field_entry_t      *f_ent;    /* Field entry structure.     */
    int                 rv;        /* Operation return status.   */

    /* Input parameters check. */
    if (NULL == stat_id) {
        return (BCM_E_PARAM);
    }

    /* Get field control structure. */
    
    FP_LOCK(unit);

    /* Get field processor entry structure. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_AMFTFP) ||
         (f_ent->group->stage_id == _BCM_FIELD_STAGE_AEFTFP))) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif

    if (f_ent->statistic.flags & _FP_ENTRY_STAT_VALID) {
        *stat_id = f_ent->statistic.sid; 
    } else {
        rv = BCM_E_NOT_FOUND;
    }

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_entry_stat_extended_get
 *
 * Description:
 *      Get statistics with stat action entity attached
 *      to Field Processor entry.
 * Parameters:
 *      unit      - (IN) BCM device number.
 *      entry     - (IN) Field entry id.
 *      stat_id   - (IN) Statistics entity id.
 *      stat_action - (IN) Statistics Action.
 * Returns:
 *      BCM_E_XXX
 */
int bcm_esw_field_entry_stat_extended_get(int unit,
                                          bcm_field_entry_t entry,
                                          int *stat_id,
                                          bcm_field_stat_action_t *stat_action)
{
    int                 rv = BCM_E_UNAVAIL; /* Operation return status.   */
#if defined (BCM_TRIDENT2PLUS_SUPPORT) || defined (BCM_KATANA2_SUPPORT)
    _field_entry_t      *f_ent = NULL;      /* Field entry structure.     */

    if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
        return rv;
    }

    if (SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit) ||
            soc_feature(unit, soc_feature_td3_style_fp) ||
             (soc_feature(unit,soc_feature_flex_stat_compaction_support))) {
        /* Input parameters check. */
        if ((NULL == stat_id) || (stat_action == NULL)) {
            return (BCM_E_PARAM);
        }

        /* Get field control structure. */

        FP_LOCK(unit);

        /* Get field processor entry structure. */
        rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

#if defined (BCM_TRIDENT2PLUS_SUPPORT)
        if (SOC_IS_TD2P_TT2P(unit) || SOC_IS_APACHE(unit) ||
                soc_feature(unit, soc_feature_td3_style_fp)) {
            rv = _bcm_field_td2plus_entry_stat_extended_get (unit, f_ent,
                    stat_id, stat_action);
        } else
#endif
        {
#if defined (BCM_KATANA2_SUPPORT)
            rv = _bcm_field_kt2_entry_stat_extended_get (unit, f_ent,
                    stat_id, stat_action);
#endif
        }
        FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_oam_stat_action_add
 * Description:
 *      Add Oam Stat action to Field Processor entry.
 * Parameters:
 *      unit            - (IN) BCM device number.
 *      entry           - (IN) Field entry id.
 *      oam_stat_action - (IN) Oam Stat Action Structure.
 *                             Applicable stat actions are
 *                             bcmFieldStatActionNone
 *                             bcmFieldStatActionIncrementCancel
 *                             bcmFieldStatActionSample
 * Returns:
 *      BCM_E_XXX
 */
int bcm_esw_field_oam_stat_action_add(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_stat_action_t *oam_stat_action)
{
    int rv =  BCM_E_UNAVAIL;
    if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
        return rv;
    }
    if (oam_stat_action == NULL) {
        return BCM_E_PARAM;
    }

    if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
        return rv;
    }
    
    FP_LOCK(unit);

#if defined BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_fp_based_oam)) {
        rv = _bcm_field_oam_stat_action_add (unit, entry, oam_stat_action);
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_oam_stat_action_delete
 * Description:
 *      Delete Oam Stat action from Field Processor entry.
 * Parameters:
 *      unit            - (IN) BCM device number.
 *      entry           - (IN) Field entry id.
 *      oam_stat_action - (IN) Oam Stat Action Structure.
 * Returns:
 *      BCM_E_XXX
 */
int bcm_esw_field_oam_stat_action_delete(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_stat_action_t *oam_stat_action)
{
    int rv =  BCM_E_UNAVAIL;
    if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
        return rv;
    }
    if (oam_stat_action == NULL) {
        return BCM_E_PARAM;
    }

    if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
        return rv;
    }
    
    FP_LOCK(unit);

#if defined BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_fp_based_oam)) {
        rv = _bcm_field_oam_stat_action_delete (unit, entry, oam_stat_action);
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_oam_stat_action_delete_all
 * Description:
 *     Remove all Oam Stat action from Field Processor entry.
 * Parameters:
 *      unit            - (IN) BCM device number.
 *      entry           - (IN) Field entry id.
 * Returns:
 *      BCM_E_XXX
 */
int bcm_esw_field_oam_stat_action_delete_all(
    int unit,
    bcm_field_entry_t entry)
{
    int rv =  BCM_E_UNAVAIL;

    if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
        return rv;
    }
    
    FP_LOCK(unit);

#if defined BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_fp_based_oam)) {
        rv = _bcm_field_oam_stat_action_delete_all (unit, entry);
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_oam_stat_action_get
 * Description:
 *     Get Oam Stat action from Field Processor entry.
 * Parameters:
 *      unit            - (IN) BCM device number.
 *      entry           - (IN) Field entry id.
 *      oam_stat_action - (INOUT) Oam Stat Action Structure.
 * Returns:
 *      BCM_E_XXX
 */
int bcm_esw_field_oam_stat_action_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_stat_action_t *oam_stat_action)
{
    int rv =  BCM_E_UNAVAIL;

    if (oam_stat_action == NULL) {
        return BCM_E_PARAM;
    }

    if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
        return rv;
    }
    
    FP_LOCK(unit);

#if defined BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_fp_based_oam)) {
        rv = _bcm_field_oam_stat_action_get (unit, entry, oam_stat_action);
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_oam_stat_action_get_all
 * Description:
 *     Get all Oam Stat action from Field Processor entry.
 * Parameters:
 *      unit            - (IN) BCM device number.
 *      entry           - (IN) Field entry id.
 *      oam_stat_max    - (IN) Max number of Oam Stat actions.
 *      oam_stat_action - (IN) Oam Stat Action Structure.
 *      oam_stat_count  - (INOUT) Number of oam stats configured.
 * Returns:
 *      BCM_E_XXX
 */
int bcm_esw_field_oam_stat_action_get_all(
    int unit,
    bcm_field_entry_t entry,
    int oam_stat_max,
    bcm_field_oam_stat_action_t *oam_stat_action,
    int *oam_stat_count)
{
    int rv =  BCM_E_UNAVAIL;

    if (!soc_feature(unit, soc_feature_advanced_flex_counter)) {
        return rv;
    }
    
    FP_LOCK(unit);

#if defined BCM_TRIDENT2PLUS_SUPPORT
    if (soc_feature(unit, soc_feature_fp_based_oam)) {
        rv = _bcm_field_oam_stat_action_get_all (unit, entry, oam_stat_max,
                oam_stat_action, oam_stat_count);
    }
#endif /* BCM_TRIDENT2PLUS_SUPPORT */

    FP_UNLOCK(unit);
    return (rv);
}


/* Section Field Policers. */
/*
 * Function:
 *      bcm_esw_policer_init
 * Purpose:
 *      Initialize policer module.
 * Parameters:
 *      unit - (IN) Unit number.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_policer_init(int unit)
{
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
    if (SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit) ||
        SOC_IS_APACHE(unit) || SOC_IS_GREYHOUND2(unit)) {
        if (soc_feature(unit, soc_feature_global_meter)) {
            return(bcm_esw_global_meter_init(unit));
        }
    } 
#endif
    return (BCM_E_NONE);
}
/*
 * Function:
 *      bcm_policer_get
 * Purpose:
 *      Get the config settings for a policer entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      policer_id - (IN) Policer ID.
 *      pol_cfg - (OUT) Policer configuration.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_policer_get(int unit, bcm_policer_t policer_id, 
                    bcm_policer_config_t *pol_cfg)
{
    _field_policer_t    *f_pl;   /* Internal policer descriptor. */
    int                 rv;      /* Operation return status.     */
    int is_global_policer;

    /* Input parameters check. */
    if (NULL == pol_cfg) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(
        _bcm_esw_is_global_policer(unit, policer_id, &is_global_policer));
    if (TRUE == is_global_policer) {
        rv = _bcm_esw_global_meter_policer_get(unit, policer_id, pol_cfg);
        return (rv);
    }

    FP_LOCK(unit);

    rv = _bcm_field_policer_get(unit, policer_id, &f_pl);
    if (BCM_SUCCESS(rv)) {
        sal_memcpy(pol_cfg, &f_pl->cfg, sizeof(bcm_policer_config_t));
    }

    

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_policer_packet_counter_get32
 * Purpose:
 *      Get the packet count for a policer entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      policer_id - (IN) Policer ID.
 *      count - (OUT) Policer packet count
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_policer_packet_counter_get32(int unit, bcm_policer_t policer_id,
                    uint32 *count)
{
    _field_control_t    *fc;     /* Field control structure.     */
    _field_policer_t    *f_pl;   /* Internal policer descriptor. */
    int                 rv = BCM_E_UNAVAIL;      /* Operation return status.     */

    /* Input parameters check. */
    if (NULL == count) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _bcm_field_policer_get(unit, policer_id, &f_pl);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = BCM_E_UNAVAIL;

    /* Read current policer counters from hw. */
    if(fc->functions.fp_policer_packet_counter_get32) {
        rv = fc->functions.fp_policer_packet_counter_get32(unit,
                                                f_pl, count);
    }

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_policer_packet_reset_counter_get32
 * Purpose:
 *      Set the packet count for a policer entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      policer_id - (IN) Policer ID.
 *      count - (IN) Policer packet count
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_policer_packet_reset_counter_get32(int unit, bcm_policer_t policer_id,
                    uint32 *count)
{
    _field_control_t    *fc;     /* Field control structure.     */
    _field_policer_t    *f_pl;   /* Internal policer descriptor. */
    int                 rv = BCM_E_UNAVAIL;      /* Operation return status.     */


    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _bcm_field_policer_get(unit, policer_id, &f_pl);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = BCM_E_UNAVAIL;

    /* Set current policer counters */
    if(fc->functions.fp_policer_packet_reset_counter_get32) {
        rv = fc->functions.fp_policer_packet_reset_counter_get32(unit,
                                                  f_pl, count);
    }

    FP_UNLOCK(unit);
    return (rv);
}

int _bcm_update_hw_meter_entry(int unit, _field_control_t *fc,
                                _field_policer_t *f_pl) {

    int            rv;      /* Operation return status.        */
    _field_group_t *fg;     /* Field group info.               */
    _field_entry_t *f_ent;  /* Internal entry descriptor.      */
    _field_entry_policer_t *f_ent_pl;
    int tmp = 0;            /* Temporary iterator.             */
    int eid;                /* Entry ID.                       */
    int idx;                /* Policers levels iterator.       */
    int entry_found = 0;
    /* Set policer "dirty" flags. */
    rv = _field_policer_hw_flags_set(unit, f_pl, 0);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }

    if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
        f_pl->hw_flags &= ~_FP_POLICER_COMMITTED_DIRTY;
    } else if (_FP_POLICER_COMMITTED_HW_METER(f_pl)) {
        f_pl->hw_flags &= ~_FP_POLICER_PEAK_DIRTY;
    }

    /*
     * get the entry for which this policer is attached
     */
    fg = fc->groups;
    if (NULL == fg) {
        return (BCM_E_INTERNAL);
    }
    /*
    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        return (rv);
    }    */
    entry_found = 0;
    for (fg = fc->groups; fg != NULL; fg = fg->next) {
        tmp = 0;
        /*
         * Check for all entries where this entry was associated
         */
        while (tmp < fg->group_status.entry_count) {
            eid = (fg->entry_arr[tmp])->eid;

            /* Get entry description structure. */
            rv = _field_entry_get(unit, eid, _FP_ENTRY_PRIMARY, &f_ent);
            if (BCM_FAILURE(rv)) {
                 return (rv);
            }

            for (idx = 0; idx < _FP_POLICER_LEVEL_COUNT; idx++) {
                f_ent_pl = f_ent->policer + idx;
                if (f_ent_pl->pid == f_pl->pid) {
                    entry_found = 1;
                    break;
                }
            }
            if (entry_found == 1) {
                break;
            }
            tmp++;
        }
        if (entry_found == 1) {
            break;
        }
    }
    if (entry_found) {
        BCM_IF_ERROR_RETURN(fc->functions.fp_policer_install(unit, f_ent, f_pl));
    } else {
        return BCM_E_INTERNAL;
    }
    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_policer_set
 * Purpose:
 *      Set the config settings for a policer entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      policer_id - (IN) Policer ID.
 *      pol_cfg - (IN) Policer configuration.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_policer_set(int unit, bcm_policer_t policer_id, 
                    bcm_policer_config_t *pol_cfg)
{
    _field_control_t    *fc;     /* Field control structure.        */
    _field_policer_t    *f_pl;   /* Internal policer descriptor.    */
    int                 rv;      /* Operation return status.        */
    _field_group_t *fg;          /* Field group info.               */
    _field_stage_t *stage_fc;    /* Stage field control info.       */
    _field_entry_t *f_ent;       /* Internal entry descriptor.      */
    _field_entry_policer_t *f_ent_pl;
                                 /* Field entry policer structure.  */
    int idx;                     /* Policers levels iterator.       */
    int eid;                     /* Entry ID.                       */
    int tmp = 0;                 /* Temporary iterator.             */
    int is_global_policer;       /* globa meter policer ID Check.   */
    int set_entry_flag;
    int is_config_changed = 0;
    /* Input parameters check. */
    if (NULL == pol_cfg) {
        return (BCM_E_PARAM);
    }

    /* Reject unsupported flags */
    if (pol_cfg->flags & BCM_POLICER_XGS_NOSUPPORT_FLAGS) {
        return (BCM_E_PARAM);
    }

    if (bcmPolicerModeCommitted == pol_cfg->mode
        && (pol_cfg->pkbits_sec || pol_cfg->pkbits_burst)) {
        return (BCM_E_PARAM);
    }

    if (pol_cfg->flags & BCM_POLICER_MODE_PACKETS) {
        if (!soc_feature(unit, soc_feature_field_packet_based_metering)) {
            return (BCM_E_UNAVAIL);
        }
    }

    if ((pol_cfg->flags & BCM_POLICER_AS_PACKET_COUNTER) &&
        (!SOC_IS_KATANA2(unit))) {
            return (BCM_E_UNAVAIL);
    }

    if ((pol_cfg->flags & BCM_POLICER_AS_PACKET_COUNTER) &&
        (pol_cfg->flags & BCM_POLICER_MODE_BYTES)) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(
        _bcm_esw_is_global_policer(unit, policer_id, &is_global_policer));
    if (TRUE == is_global_policer) {
        rv = _bcm_esw_global_meter_policer_set(unit, policer_id, pol_cfg);
        return (rv);
    }
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _bcm_field_policer_get(unit, policer_id, &f_pl);
    if (BCM_FAILURE(rv)) {
        /* Policer does not exist. */
        FP_UNLOCK(unit);
        return (rv);
    }

    set_entry_flag = 0;
    /* if hardware index is null means thatthe policer is either
     * not installed or is in modified state.
     * check if old backup data of policer cfg exists and is same as
     * newly provided policer config, then reset the policer cfg
     * to old cfg
     */
    if (_FP_INVALID_INDEX == f_pl->hw_index) {
        /* check if old cfg is same as data provided
         * if same, then copy the old cfg to current config and reset the entry flag
         * if not same, copy the given cfg to current cfg and set the entry flag
         */
        if ((sal_memcmp(&f_pl->old_cfg, pol_cfg,
             sizeof(bcm_policer_config_t)) == 0)) {
            /* copy the old cfg to given cfg and reset the entry flag*/
            set_entry_flag = 0;
            sal_memcpy(&f_pl->cfg, &f_pl->old_cfg,
                       sizeof(bcm_policer_config_t));
            f_pl->hw_flags = f_pl->old_hw_flags;
            f_pl->old_hw_flags = 0;
#ifdef    BCM_TRIUMPH3_SUPPORT
            f_pl->logical_pool_index = f_pl->old_logical_pool_index;
            f_pl->old_logical_pool_index = _FP_INVALID_INDEX;
#endif
            f_pl->old_mode = 0;
            f_pl->pool_index = f_pl->old_pool_index;
            f_pl->old_pool_index = _FP_INVALID_INDEX;
            f_pl->level = f_pl->old_level;
            f_pl->old_level = 0;
            f_pl->hw_index = f_pl->old_hw_index;
            f_pl->old_hw_index = _FP_INVALID_INDEX;
            f_pl->sw_ref_count = f_pl->old_sw_ref_count;
            f_pl->old_sw_ref_count = 0;
            f_pl->hw_ref_count = f_pl->old_hw_ref_count;
            f_pl->old_hw_ref_count = 0;
            sal_memset(&f_pl->old_cfg, 0x00, sizeof(bcm_policer_config_t));

        } else {
            /* copy the given cfg to current cfg and set the entry flag */
            sal_memcpy(&f_pl->cfg, pol_cfg, sizeof(bcm_policer_config_t));
            /* if policer is not installed, dont set the entry flag */
            if ((f_pl->hw_flags & _FP_POLICER_DIRTY) != _FP_POLICER_DIRTY) {
                set_entry_flag = 1;
            }
            /*set the hw index to invalid so that it reallocates the meter*/
            f_pl->hw_index = -1;
        }
    } else {
        /*if the mode changes is usch that there is no change in meter entries
         * then entry install or meter re-allocation is not required.
         */
        if ((_FP_POLICER_IS_FLOW_MODE(f_pl) &&
            pol_cfg->mode == bcmPolicerModeCommitted) ||
            ((!_FP_POLICER_IS_FLOW_MODE(f_pl)) &&
            (pol_cfg->mode != bcmPolicerModeCommitted))) {
            if ((f_pl->cfg.flags != pol_cfg->flags) ||
                ((f_pl->cfg.mode) != pol_cfg->mode)) {
                is_config_changed = 1;
            }

            sal_memcpy(&f_pl->cfg, pol_cfg, sizeof(bcm_policer_config_t));
            rv = _bcm_update_hw_meter_entry(unit, fc, f_pl);
            if ((is_config_changed != 1) || BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }
        }
        /* reallocate the meter only if there is a change in mode
         * and not when only the flags are modified
         */
        if (is_config_changed != 1) {
            set_entry_flag = 1;
            f_pl->old_mode = f_pl->cfg.mode;
            f_pl->old_hw_flags = f_pl->hw_flags;
#ifdef    BCM_TRIUMPH3_SUPPORT
            f_pl->old_logical_pool_index = f_pl->logical_pool_index;
#endif
            f_pl->old_pool_index = f_pl->pool_index;
            f_pl->old_level = f_pl->level;
            f_pl->old_hw_index = f_pl->hw_index;
            f_pl->old_sw_ref_count = f_pl->sw_ref_count;
            f_pl->old_hw_ref_count = f_pl->hw_ref_count;
            sal_memcpy(&f_pl->old_cfg, &f_pl->cfg,
                sizeof(bcm_policer_config_t));
            sal_memcpy(&f_pl->cfg, pol_cfg, sizeof(bcm_policer_config_t));
            /*set the hw indes to invalid so that it reallocates the meter*/
            f_pl->hw_index = -1;
        }
    }


    /* Set policer "dirty" flags. */
    rv = _field_policer_hw_flags_set(unit, f_pl, 0);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    if (_FP_INVALID_INDEX != f_pl->hw_index) {
        if (_FP_POLICER_EXCESS_HW_METER(f_pl)) {
            f_pl->hw_flags &= ~_FP_POLICER_COMMITTED_DIRTY;
        } else if (_FP_POLICER_COMMITTED_HW_METER(f_pl)) {
            f_pl->hw_flags &= ~_FP_POLICER_PEAK_DIRTY;
        }
    }

    /*
     * Check if any entries has this policer attached and
     * set the dirty flag for the entry
     */
    fg = fc->groups;
    if (NULL == fg) {
        FP_UNLOCK(unit);
        return (BCM_E_NONE);
    }

    rv = _field_stage_control_get(unit, fg->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    for (fg = fc->groups; fg != NULL; fg = fg->next) {
        tmp = 0;
        /*
         * Check for all entries where this entry was associated
         */
        while (tmp < fg->group_status.entry_count) {
            eid = (fg->entry_arr[tmp])->eid;

            /* Get entry description structure. */
            rv = _field_entry_get(unit, eid, _FP_ENTRY_PRIMARY, &f_ent);
            if (BCM_FAILURE(rv)) {
                 FP_UNLOCK(unit);
                 return (rv);
            }
            for (idx = 0; idx < _FP_POLICER_LEVEL_COUNT; idx++) {
                f_ent_pl = f_ent->policer + idx;
                if (f_ent_pl->pid == policer_id) {
                    if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
                        f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
                    } 
                    f_ent->flags |=  _FP_ENTRY_DIRTY;
                    if (set_entry_flag) {
                        f_ent->flags |=  _FP_ENTRY_METER_MODIFIED;
                    } else {
                        f_ent->flags &=  ~_FP_ENTRY_METER_MODIFIED;
                    }
                }
            }
            tmp++;
        }
    }

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_field_entry_policer_attach
 * Purpose:
 *      Attach a policer to a field entry.
 * Parameters:
 *      unit       - (IN) Unit number.
 *      entry_id   - (IN) Field entry ID.
 *      level      - (IN) Policer level.
 *      policer_id - (IN) Policer ID.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_entry_policer_attach(int unit, bcm_field_entry_t entry_id, 
                                   int level, bcm_policer_t policer_id)
{
    _field_entry_policer_t *f_ent_pl; /* Field entry policer structure.*/
    _field_policer_t       *f_pl;     /* Internal policer descriptor.  */
    _field_entry_t         *f_ent;    /* Internal entry descriptor.    */
    _field_stage_id_t      stage_id;  /* Pipeline stage id.            */
    int                    idx;       /* Entry policers iterator.      */
    int                    rv;        /* Operation return status.      */
    _field_stage_t         *stage_fc; /* Field stage control structure.*/
    _field_meter_pool_t    *f_mp;     /* Meter pool descriptor.        */
    _field_control_t       *fc;       /* Field control structure.        */
    _field_group_t         *group;    /* Field group structure         */
    _field_slice_t         *slice;    /* Slice iteration count.        */
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
    vfp_policy_table_entry_t vfp_entry;
#endif
#ifdef BCM_TOMAHAWK_SUPPORT
    int action_size = 0;
#endif
    int is_global_policer;

    /* Input parameters check. */
    if ((level >= _FP_POLICER_LEVEL_COUNT) || (level < 0)) {
        return (BCM_E_PARAM);
    }

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /* Get entry description structure. */
    rv = _field_entry_get(unit, entry_id, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Get entry pipeline stage id. */
    stage_id = f_ent->group->stage_id;

    if (!soc_feature(unit, soc_feature_field_egress_metering)) {
        /*
         * If Egress metering is not supported, then return
         * UNAVAIL if the group is in egress mode
         */
        if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
            FP_UNLOCK(unit);
            return BCM_E_UNAVAIL;
        }
    }

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_AMFTFP) ||
         (f_ent->group->stage_id == _BCM_FIELD_STAGE_AEFTFP))) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        if (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS) {
            FP_UNLOCK(unit);
            return (BCM_E_UNAVAIL);
        }
        if (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH) {
            if (!(f_ent->flags & _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT)) {
                if (!(BCM_FIELD_ASET_TEST(f_ent->group->aset,
                                          bcmFieldActionPolicerGroup))) {
                    LOG_ERROR(BSL_LS_BCM_FP,
                       (BSL_META_U(unit,
                        "FP(unit %d) - Exact Match Entry"
                        " Group %d created without action"
                        " bcmFieldActionPolicerGroup.\n"),
                          unit, f_ent->group->gid));
                    FP_UNLOCK(unit);
                    return (BCM_E_CONFIG);
                }
            }
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /*
     * if an entry's corresponding group is auto expanded, then
     * then an entry cannot be attached if global pools is
     * not supported on that stage
     */
    group = f_ent->group;
    /* Get meter pool stage control. */
    rv = _field_stage_control_get (unit, stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = _bcm_esw_is_global_policer(unit, policer_id, &is_global_policer);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /* Donot attach the policers if _FP_STAGE_AUTOEXPAND_WITH_POLICER is
     * enabled and group is egress and group is auto expanded */
    if (!(stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS) &&
        !(is_global_policer) &&
         (group->flags & _FP_GROUP_SELECT_AUTO_EXPANSION)) {
        slice = &group->slices[0];
        if (!((fc->flags &_FP_AUTOEXPAND_WITH_POLICER) &&
              (_BCM_FIELD_STAGE_EGRESS == group->stage_id))) {
            if (slice->next != NULL) {
                FP_UNLOCK(unit);
                return BCM_E_CONFIG;
            }
        }
    }

#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
    if (SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit)
        || SOC_IS_APACHE(unit) || SOC_IS_GREYHOUND2(unit)) {
        if ((_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id)
            || (SOC_IS_TRIUMPH3(unit)
                && (_BCM_FIELD_STAGE_EXTERNAL == f_ent->group->stage_id))) {
            rv = _bcm_esw_add_policer_to_table(unit, policer_id,
                                               VFP_POLICY_TABLEm, 0,
                                               &vfp_entry);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }
            if (f_ent->global_meter_policer.pid > 0) {
                _bcm_esw_policer_decrement_ref_count
                    (unit, f_ent->global_meter_policer.pid);
            }
            f_ent->global_meter_policer.pid = policer_id;
            f_ent->global_meter_policer.flags = level;
            /* 
             * If qualifiers have not been modified for this entry,
             * set Policy table only dirty flag.
             */
            if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
                f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
            }
            /* Entry must be reinstalled for policer to take effect. */
            f_ent->flags  |= _FP_ENTRY_DIRTY;
            FP_UNLOCK(unit);
            return (BCM_E_NONE);
        }
    }
#endif /* BCM_KATANA_SUPPORT || BCM_TRIUMPH3_SUPPORT ||
          BCM_APACHE_SUPPORT || BCM_GREYHOUND2_SUPPORT */
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT)
    /* Make sure stage has meters. */ 
    if (_BCM_FIELD_STAGE_LOOKUP == stage_id) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT */

    /* Check if another  policer already attached at this level. */
    f_ent_pl = f_ent->policer + level;
    if (f_ent_pl->flags & _FP_POLICER_VALID) {
        FP_UNLOCK(unit);
        return (BCM_E_EXISTS);
    }

    /* Check if another policer is in detach state at this level */
    if ((f_ent_pl->flags & _FP_POLICER_DETACH) &&
            (f_ent_pl->pid != policer_id)) {
        FP_UNLOCK(unit);
        return (BCM_E_EXISTS);
    }

    /* Check if policer already attached to another level in the entry. */
    for (idx = 0; idx < _FP_POLICER_LEVEL_COUNT; idx++) {
        f_ent_pl = f_ent->policer + idx;
        if (f_ent_pl->pid == policer_id) {
            if (idx == level) {
                f_ent_pl->flags = _FP_POLICER_VALID;
            }
            FP_UNLOCK(unit);
            return (idx == level) ? (BCM_E_NONE) : (BCM_E_PARAM);
        }
    }

    /* Get policer description structure. */
    rv = _bcm_field_policer_get(unit, policer_id, &f_pl);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    if ((f_pl->cfg.flags & BCM_POLICER_AS_PACKET_COUNTER) &&
        (_BCM_FIELD_STAGE_EGRESS != f_ent->group->stage_id)) {
        return (BCM_E_UNAVAIL);
    }
    /* Check that policer can be shared. */
    if (f_pl->sw_ref_count > 1) {
        /* Policer sharing is restricted to a single stage. */
        if (stage_id != f_pl->stage_id) {
            FP_UNLOCK(unit);
            return (BCM_E_PARAM);
        }

        /* Policer sharing is restricted to a single level. */
        if (level != f_pl->level) {
            FP_UNLOCK(unit);
            return (BCM_E_PARAM);
        }

        /* cannot attach the policers if _FP_STAGE_AUTOEXPAND_WITH_POLICER is
         * set and the policer is already attached to another entry */
        if ((fc->flags &_FP_AUTOEXPAND_WITH_POLICER) &&
              (_BCM_FIELD_STAGE_EGRESS == group->stage_id)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                           "Cannot attach policer for eid = %d as it cannot be shared.\n"),
                           f_ent->eid));
                FP_UNLOCK(unit);
                return (BCM_E_CONFIG);
        }
        /* 
         * When FP stage supports meters per-slice, then policers cannot be attached
         * to entries created on a difference physical slice.
         */
        if (!(stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS)
            && (_FP_INVALID_INDEX != f_pl->hw_index)) {
            if ((!(f_ent->flags & _FP_ENTRY_POLICER_IN_SECONDARY_SLICE)
                   && f_ent->fs->slice_number != f_pl->pool_index)
                || ((f_ent->flags & _FP_ENTRY_POLICER_IN_SECONDARY_SLICE)
                     && f_ent->fs->slice_number + 1 != f_pl->pool_index)) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                           "FP(unit %d) - Cannot attach policer for eid = %d\n"),
                           unit, f_ent->eid));
                FP_UNLOCK(unit);
                return (BCM_E_CONFIG);
            }
        }

        if ((!(_FP_POLICER_GROUP_SHARE_ENABLE & fc->flags)) && 
            (_BCM_FIELD_STAGE_INGRESS == stage_fc->stage_id)) {
            if ((0 == level) && (_FP_INVALID_INDEX != f_pl->pool_index)
                && (stage_fc->flags & _FP_STAGE_GLOBAL_METER_POOLS)) {
                /* 
                 * Entry's primary slice_number must match Policer
                 * meter pool slice_id value for Level0 policer.
                 */
#if defined(BCM_TRIUMPH3_SUPPORT)
                if (SOC_IS_TRIUMPH3(unit) &&
                    (fc->ingress_logical_policer_pools_mode !=
                                  bcmFieldIngressLogicalPolicerPools8x1024)) {
                    f_mp = stage_fc->logical_meter_pool
                              [f_pl->logical_pool_index];
                } else
#endif
                {
                    f_mp = stage_fc->meter_pool
                              [f_ent->group->instance][f_pl->pool_index];
                }
                if (f_ent->group->slices->slice_number != f_mp->slice_id) {
                    FP_UNLOCK(unit);
                    return (BCM_E_PARAM);
                }
            }
        }
    }

    /* Check policer mode support. */
    rv = _field_policer_mode_support(unit, f_ent, level, f_pl);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (f_ent->flags & _FP_ENTRY_EXACT_MATCH_GROUP_DEFAULT) {
        rv = _field_th_em_entry_action_size_get(unit, f_ent,
                                                &action_size, NULL);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
        if (action_size > EM_DEFAULT_POLICY_ACTION_DATA_SIZE) {
            FP_UNLOCK(unit);
            return (BCM_E_RESOURCE);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Increment policer reference counter. */
    f_pl->sw_ref_count++;

    /* Set policer stage. */
    f_pl->stage_id = stage_id;

    /* Set policer attachment level. */
    f_pl->level = level;

    /* Attach policer to an entry. */
    f_ent_pl = f_ent->policer + level;
    f_ent_pl->flags |= _FP_POLICER_VALID;
    f_ent_pl->pid    = policer_id;

    /* 
     * If qualifiers have not been modified for this entry,
     * set Policy table only dirty flag.
     */
    if (0 == (f_ent->flags & _FP_ENTRY_DIRTY)) {
        f_ent->flags |= _FP_ENTRY_POLICY_TABLE_ONLY_DIRTY;
    }
    /* Entry must be reinstalled for policer to take effect. */
    f_ent->flags  |= _FP_ENTRY_DIRTY;

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_field_entry_policer_detach
 * Purpose:
 *      Detach a policer from a field entry.
 * Parameters:
 *      unit     - (IN) Unit number.
 *      entry_id - (IN) Field entry ID.
 *      level    - (IN) Policer level.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_entry_policer_detach(int unit, bcm_field_entry_t entry_id, 
                                   int level)
{
    _field_entry_t         *f_ent;    /* Internal entry descriptor.    */
    int                     rv;       /* Operation return status.      */

    /* Input parameters check. */
    if ((level >= _FP_POLICER_LEVEL_COUNT) || (level < 0)) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    /* Get entry description structure. */
    rv = _field_entry_get(unit, entry_id, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    rv = _field_entry_policer_detach(unit, f_ent, level);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_field_entry_policer_detach_all
 * Purpose:
 *      Detach all policers from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry_id - (IN) Field entry ID.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_entry_policer_detach_all(int unit, bcm_field_entry_t entry_id)
{
    int       idx;                /* Entry policers iterator. */
    int       rv = BCM_E_NONE;    /* Operation return status. */

    /* Detach all the policers attached to an entry. */
    for (idx = 0; idx < _FP_POLICER_LEVEL_COUNT; idx++) {
        rv =  bcm_esw_field_entry_policer_detach(unit, entry_id, idx);
        if (BCM_E_EMPTY == rv) {
            /* No policer at this level. */
            rv = BCM_E_NONE;
        } else if (BCM_FAILURE(rv)) {
            break;
        }
    }
    return (rv);
}

/*
 * Function:
 *      bcm_field_entry_policer_get
 * Purpose:
 *      Get the policer(s) attached to a field entry.
 * Parameters:
 *      unit       - (IN) Unit number.
 *      entry_id   - (IN) Field entry ID.
 *      level      - (IN) Policer level.
 *      policer_id - (OUT) Policer ID.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_entry_policer_get(int unit, bcm_field_entry_t entry_id, 
                                int level, bcm_policer_t *policer_id)
{
    _field_entry_policer_t *f_ent_pl;/* Field entry policer structure.*/
    _field_entry_t         *f_ent;   /* Internal entry descriptor.    */
    int                    rv;       /* Operation return status.      */

    /* Input parameters check. */
    if ((level >= _FP_POLICER_LEVEL_COUNT) || (level < 0)) {
        return (BCM_E_PARAM);
    }

    if (NULL == policer_id) {
        return (BCM_E_PARAM);
    }

    FP_LOCK(unit);

    /* Get entry description structure. */
    rv = _field_entry_get(unit, entry_id, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }
#if defined(BCM_FLOWTRACKER_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_FLOWTRACKER)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_AMFTFP) ||
         (f_ent->group->stage_id == _BCM_FIELD_STAGE_AEFTFP))) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_CLASS)) {
        FP_UNLOCK(unit);
        return (BCM_E_UNAVAIL);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
    if (SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit)
        || SOC_IS_APACHE(unit) || SOC_IS_GREYHOUND2(unit)) {
        if (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id) {
            if (f_ent->global_meter_policer.pid) {
                *policer_id = f_ent->global_meter_policer.pid;
                FP_UNLOCK(unit);
                return (rv);
            } 
            rv = (BCM_E_NOT_FOUND);
        }
    }
#endif /* BCM_KATANA_SUPPORT || BCM_TRIUMPH3_SUPPORT ||
          BCM_APACHE_SUPPORT || BCM_GREYHOUND2_SUPPORT */
#if defined(BCM_TRIUMPH3_SUPPORT)
    if (SOC_IS_TRIUMPH3(unit)) {
        if (_BCM_FIELD_STAGE_EXTERNAL == f_ent->group->stage_id) {
            if (f_ent->global_meter_policer.pid) {
                *policer_id = f_ent->global_meter_policer.pid;
                FP_UNLOCK(unit);
                return (rv);
            } 
            rv = (BCM_E_NOT_FOUND);
        }
    }
#endif

    f_ent_pl = f_ent->policer + level;
    /* Make sure policer attached to the entry. */
    if (0 == (f_ent_pl->flags & _FP_POLICER_VALID)) {
        rv = (BCM_E_NOT_FOUND);
    } else {
        *policer_id = f_ent_pl->pid;
    }

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_policer_create
 * Purpose:
 *      Create a policer entry.
 * Parameters:
 *      unit    - (IN) BCM device number.
 *      pol_cfg - (IN) Policer configuration.
 *      policer_id - (OUT) Policer ID.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_policer_create(int unit, bcm_policer_config_t *pol_cfg, 
                       bcm_policer_t *policer_id)
{
    int                 rv;                /* Operation return status. */

    /* Input parameters check. */
    if (NULL == policer_id) {
        return (BCM_E_PARAM);
    }
    
    /* Reject unsupported flags. */
    if (pol_cfg->flags & BCM_POLICER_XGS_NOSUPPORT_FLAGS) {
        return (BCM_E_PARAM);
    }
    if ((pol_cfg->flags & BCM_POLICER_WITH_ID) &&
        ((*policer_id < 0) || (*policer_id >= _FP_ID_MAX))){
       return (BCM_E_PARAM);
    }
    if (bcmPolicerModeCommitted == pol_cfg->mode
        && (pol_cfg->pkbits_sec || pol_cfg->pkbits_burst)) {
        return (BCM_E_PARAM);
    }

    if (pol_cfg->flags & BCM_POLICER_MODE_PACKETS) {
        if (!soc_feature(unit, soc_feature_field_packet_based_metering)) {
            return (BCM_E_UNAVAIL);
        }
    }

    if ((pol_cfg->flags & BCM_POLICER_AS_PACKET_COUNTER) &&
        (!SOC_IS_KATANA2(unit))) {
            return (BCM_E_UNAVAIL);
    }

    if ((pol_cfg->flags & BCM_POLICER_AS_PACKET_COUNTER) &&
        (pol_cfg->flags & BCM_POLICER_MODE_BYTES)) {
        return (BCM_E_PARAM);
    }

    /* Overwrite the mode to Flow mode when policer is used as packet counter */
    if (pol_cfg->flags & BCM_POLICER_AS_PACKET_COUNTER) {
        pol_cfg->mode = bcmPolicerModeCommitted;
        pol_cfg->flags |=  BCM_POLICER_MODE_PACKETS;
        pol_cfg->ckbits_sec = 0;
        pol_cfg->ckbits_burst = 0;
        pol_cfg->bucket_width = 30;
        pol_cfg->token_gran = 250;
        pol_cfg->bucket_init_val = 0xFFF << 16;
        pol_cfg->bucket_rollover_val = 0x20000052;
    }

    if (pol_cfg->flags & BCM_POLICER_REGEX) {
#if defined(INCLUDE_REGEX) && defined(BCM_TRIUMPH3_SUPPORT)
        if (soc_feature(unit, soc_feature_regex)) { 
            return  _bcm_esw_regex_policer_create(unit, pol_cfg, policer_id);
        }
#else
        return BCM_E_UNAVAIL;
#endif
    }

    FP_LOCK(unit);

    rv = _field_policer_create(unit, pol_cfg, 0, policer_id);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_policer_destroy
 * Purpose:
 *      Destroy a policer entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      policer_id - (IN) Policer ID.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_policer_destroy(int unit, bcm_policer_t policer_id)
{
    int               rv;       /* Operation return status. */
    int is_global_policer; /* Globa meter policer ID Check. */

#if defined(INCLUDE_REGEX) && defined(BCM_TRIUMPH3_SUPPORT)
    if ((soc_feature(unit, soc_feature_regex)) && (BCM_POLICER_IS_REGEX_METER(policer_id)))  { 
        return  _bcm_esw_regex_policer_destroy(unit, policer_id);
    }
#endif

    BCM_IF_ERROR_RETURN(
        _bcm_esw_is_global_policer(unit, policer_id, &is_global_policer));
    if (TRUE == is_global_policer) {
        rv = _bcm_esw_global_meter_policer_destroy(unit, policer_id);
        return (rv);
    }

    FP_LOCK(unit);
    rv = _field_policer_destroy(unit, policer_id);
    FP_UNLOCK(unit);

    return (rv);
}

/*
 * Function:
 *      bcm_policer_destroy_all
 * Purpose:
 *      Destroy all policer entries.
 * Parameters:
 *      unit - (IN) Unit number.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_policer_destroy_all(int unit)
{
    _field_control_t *fc;              /* Field control structure.     */
    int              idx;              /* Policer hash iteration index.*/
    int              rv = BCM_E_NONE;  /* Operation return status.     */

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /* Iterate over all hash buckets. */
    for (idx = 0; idx < _FP_HASH_SZ(fc); idx++) {
        /* Destroy entries in each bucket. */
        while (NULL != fc->policer_hash[idx]) {
            rv = _field_policer_destroy2(unit, fc, fc->policer_hash[idx]);
            if (BCM_FAILURE(rv)) {
                break;
            }
        }
        if (BCM_FAILURE(rv)) {
            break;
        }
    }
    FP_UNLOCK(unit);
    BCM_IF_ERROR_RETURN(rv);
    
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
    if (SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit) ||
        SOC_IS_APACHE(unit) || SOC_IS_GREYHOUND2(unit)) {
        /* In case warmboot shutdown is going on, there is no need to
         * delete all policers here. It is taken care in
         * _bcm_esw_global_meter_cleanup() call */
        if (soc_feature(unit, soc_feature_global_meter) &&
                        !(SOC_WARM_BOOT(unit))) {
            rv = _bcm_esw_global_meter_policer_destroy_all(unit);
            if (BCM_FAILURE(rv)) {
                rv = bcm_esw_global_meter_init(unit);
            }
        }
    }
#endif

#if defined(INCLUDE_REGEX) && defined(BCM_TRIUMPH3_SUPPORT)
    if (soc_feature(unit, soc_feature_regex)) { 
        return  _bcm_esw_regex_policer_destroy_all(unit);
    }
#endif

    return (rv);
}

/*
 * Function:
 *      bcm_policer_traverse
 * Purpose:
 *      Traverse all existing policer entries and call supplied
 *      callback function.
 * Parameters:
 *      unit - (IN) Unit number.
 *      cb - (IN) Callback function.
 *      user_data - (IN) User data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *     To speed up traverse operation - no hw read is perfomed.
 */
int 
bcm_esw_policer_traverse(int unit, bcm_policer_traverse_cb cb, 
                         void *user_data)
{
    _field_control_t        *fc;      /* Field control structure.       */
    _field_policer_t        *f_pl;    /* Internal policer descriptor.   */
    bcm_policer_config_t    cfg;      /* Policer configuration.         */
    int                     idx;      /* Policer hash iteration index.  */
    int              rv = BCM_E_NONE; /* Operation return status.       */

    /* Input parameter check. */
    if (NULL == cb) {
        return (BCM_E_PARAM);
    } 

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /* Iterate over all hash buckets. */
    for (idx = 0; idx < _FP_HASH_SZ(fc); idx++) {
        /* Iterate over entries in each bucket. */
        f_pl = fc->policer_hash[idx]; 
        while (NULL != f_pl) {
            sal_memcpy(&cfg, &f_pl->cfg, sizeof(bcm_policer_config_t));
            rv = (*cb)(unit, f_pl->pid, &cfg, user_data);  
            if (BCM_FAILURE(rv)) {
                break;
            }
            f_pl = f_pl->next;
        }
        if (BCM_FAILURE(rv)) {
            break;
        }
    }
    FP_UNLOCK(unit);
#if defined(BCM_KATANA_SUPPORT) || defined(BCM_TRIUMPH3_SUPPORT) || \
    defined(BCM_APACHE_SUPPORT) || defined(BCM_GREYHOUND2_SUPPORT)
    if (SOC_IS_KATANAX(unit) || SOC_IS_TRIUMPH3(unit) ||
        SOC_IS_APACHE(unit) || SOC_IS_GREYHOUND2(unit)) {
        if (soc_feature(unit, soc_feature_global_meter)) {
            rv = _bcm_esw_global_meter_policer_traverse(unit,cb,user_data);
        }
    }
#endif /* BCM_KATANA_SUPPORT || BCM_TRIUMPH3_SUPPORT ||
          BCM_APACHE_SUPPORT || BCM_GREYHOUND2_SUPPORT */

#if defined(INCLUDE_REGEX) && defined(BCM_TRIUMPH3_SUPPORT)
    if (soc_feature(unit, soc_feature_regex)) { 
        return  _bcm_esw_regex_policer_traverse(unit, cb, user_data);
    }
#endif

    return (rv);
}

/*
* Function: bcm_field_resync
*
* Purpose:
*     To invalidate HW FP entries that have not been replayed after warm boot.
*     Can be used in general to clear entries that are in HW but not in SW.
*
* Parameters:
*     unit     - BCM unit number
*
* Returns:
*     BCM_E_INIT      - Unit not initialized
*     BCM_E_NONE      - Success
*     BCM_E_XXX       - Other errors
*/
int
bcm_esw_field_resync(int unit)
{
    int               i, rv, tcam_idx, tcam_size;
    _field_stage_t    *stage_fc;
    _field_slice_t    *fs;
    soc_mem_t         mem = INVALIDm;
    soc_field_t field = VALIDf;
    uint32            valid, e[SOC_MAX_MEM_FIELD_WORDS];
    int               slice_number = 0;
    int               slice_offset = 0;

    FP_LOCK(unit);
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS,
                                                  &stage_fc);
    if (BCM_FAILURE(rv)) {
       FP_UNLOCK(unit);
       return rv;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       rv = _bcm_field_th_resync(unit, stage_fc);
       FP_UNLOCK(unit);
       return rv;
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
 
#ifdef BCM_FIREBOLT_SUPPORT
    if (SOC_IS_FBX(unit)) {
       mem = FP_TCAMm;
    }
#endif /* BCM_FIREBOLT_SUPPORT */

    if (mem == INVALIDm) {
       FP_UNLOCK(unit);
       return BCM_E_UNAVAIL;
    }

    tcam_size = soc_mem_index_count(unit, mem);
    for (tcam_idx = 0; tcam_idx < tcam_size; tcam_idx++) {
        /* Read tcam entry. */
        sal_memset(e, 0, sizeof(uint32) * SOC_MAX_MEM_FIELD_WORDS);
        rv = soc_mem_read(unit, mem, MEM_BLOCK_ANY, tcam_idx, e);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }

        valid = soc_mem_field32_get(unit, mem, e, field);

        if (valid) {
            rv = _bcm_field_tcam_idx_to_slice_offset (unit, stage_fc,
                                                      _FP_DEF_INST,
                                                      tcam_idx,
                                                      &slice_number,
                                                      &slice_offset);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return rv;
            }
            fs = &stage_fc->slices[_FP_DEF_INST][slice_number];
            for (i = 0; i < fs->entry_count; i++) {
                if (fs->entries[i] != NULL) {
                    if (!(fs->entries[i]->group->flags &
                          _FP_GROUP_INTRASLICE_DOUBLEWIDE) && 
                        fs->entries[i]->slice_idx == slice_offset) {
                        break;
                    } else if (fs->entries[i]->group->flags & 
                               _FP_GROUP_INTRASLICE_DOUBLEWIDE) {
                        if ((fs->entries[i]->flags & _FP_ENTRY_SECOND_HALF) && 
                            fs->entries[i]->slice_idx == slice_offset
                            - fs->entry_count /                               \
                           ((stage_fc->flags & _FP_STAGE_HALF_SLICE) ? 1 : 2)) {
                            break;
                        } else if (!(fs->entries[i]->flags &
                                      _FP_ENTRY_SECOND_HALF) &&  
                                   fs->entries[i]->slice_idx == slice_offset) {
                            break;
                        }           
                    }
                }
            }
            if (i == fs->entry_count)
            {
                soc_mem_field32_set(unit, mem, e, field, 0);
                rv = soc_mem_write(unit, mem, MEM_BLOCK_ANY, tcam_idx, e);
                if (BCM_FAILURE(rv)) {
                    FP_UNLOCK(unit);
                    return rv;
                }
            }
        }
    }
    FP_UNLOCK(unit);
    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_data_qualifier_create
 * Purpose:
 *      Create an data/offset based qualifier.
 * Parameters:
 *      unit           - (IN) bcm device.
 *      data_qualifier - (IN) Qualifier descriptor:
 *                           such as packet type, byte offset, etc.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_data_qualifier_create(int unit,  
                                 bcm_field_data_qualifier_t *data_qualifier)
{
    int                 rv;      /* Operation return status.     */

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }

    /* Input parameters check. */
    if (NULL == data_qualifier) {
        return (BCM_E_PARAM);
    }

    /* Check data qualifier flags support */
    if ((0 == SOC_MEM_FIELD_VALID(unit, FP_UDF_OFFSETm,
                                  UDF1_ADD_GRE_OPTIONS0f)) &&
        (data_qualifier->flags &
         BCM_FIELD_DATA_QUALIFIER_OFFSET_GRE_OPTIONS_ADJUST)) {
        return (BCM_E_UNAVAIL);
    }
    if ((0 == SOC_MEM_FIELD_VALID(unit, FP_UDF_OFFSETm,
                                  UDF1_ADD_IPV4_OPTIONS0f)) &&
        (data_qualifier->flags &
         BCM_FIELD_DATA_QUALIFIER_OFFSET_IP4_OPTIONS_ADJUST)) {
        return (BCM_E_UNAVAIL);
    }
    if (data_qualifier->flags &
        BCM_FIELD_DATA_QUALIFIER_OFFSET_IP6_EXTENSIONS_ADJUST) {
        return (BCM_E_UNAVAIL);
    }
    if (data_qualifier->flags &
        BCM_FIELD_DATA_QUALIFIER_OFFSET_NEGATIVE) {
        return (BCM_E_UNAVAIL);
    }
    if (data_qualifier->flags &
        BCM_FIELD_DATA_QUALIFIER_OFFSET_PREDEFINED) {
        return (BCM_E_UNAVAIL);
    }
    
    FP_LOCK(unit);

    rv = _field_data_qualifier_create(unit, data_qualifier); 

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_data_qualifier_multi_get
 *
 * Purpose:
 *      Return list of ids of defined data qualifiers, per standard API idiom.
 *
 * Parameters:
 *      unit       - (IN)  bcm device.
 *      qual_size  - (IN)  Size of given qualifier id array; if 0, indicates
 *                         return count of data qualifiers only.
 *      qual_array - (OUT) Base of array where to store returned data qualifier
 *                         ids.
 *      qual_count - (OUT) Number of qualifier ids stored in above array; if
 *                         qual_size was given as 0, then number of defined
 *                         qualifiers. 
 *
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_field_data_qualifier_multi_get(int unit, int qual_size, int *qual_array, int *qual_count)
{
    _field_stage_t          *stage_fc;
    _field_data_control_t   *data_ctrl;
    _field_data_qualifier_t *f_dq;
    unsigned                dqcnt;

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }

    /* Parameter checking */
    if (qual_count == NULL) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: qual_count == NULL.\n"),
                   unit));
        return (BCM_E_PARAM);
    }

    if (qual_size != 0 && qual_array == NULL) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: qual_array == NULL.\n"),
                   unit));
        return (BCM_E_PARAM);
    }

    /* Point to needed things */

    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                                 _BCM_FIELD_STAGE_INGRESS,
                                                 &stage_fc
                                                 )
                        );
    data_ctrl = stage_fc->data_ctrl;

    FP_LOCK(unit);

    /* Count defined data qualifiers */

    for (dqcnt = 0, f_dq = data_ctrl->data_qual;
         f_dq;
         f_dq = f_dq->next, ++dqcnt
         );

    if (qual_size == 0) {
        /* Return count of data qualifiers only */

        *qual_count = dqcnt;
    } else {
        /* Return array of data qualifier ids */ 

        if (qual_size > dqcnt) {
            qual_size = dqcnt;
        }
        
        *qual_count = qual_size;

        for (f_dq = data_ctrl->data_qual;
             qual_size != 0 && f_dq != NULL;
             --qual_size, f_dq = f_dq->next, ++qual_array
             ) {
            *qual_array = f_dq->qid;
        }
    }

    FP_UNLOCK(unit);

    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_data_qualifier_get
 *
 * Purpose:
 *      Return configuration of given data qualifier.
 *
 * Parameters:
 *      unit       - (IN)  bcm device.
 *      qual_id    - (IN)  Id of data qualifier.
 *      qual       - (OUT) Attributes of given data qualifier.
 *
 * Returns:
 *      BCM_E_XXX
 */

int
bcm_esw_field_data_qualifier_get(int unit, int qual_id, bcm_field_data_qualifier_t *qual)
{
    int                     rv;
    _field_stage_t          *stage_fc;
    _field_data_qualifier_t *f_dq;

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }

    /* Parameter checking */
    if (qual == NULL) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: qual == NULL.\n"),
                   unit));
        return (BCM_E_PARAM);
    }

    /* Point to needed things */

    
    BCM_IF_ERROR_RETURN(_field_stage_control_get(unit,
                                                 _BCM_FIELD_STAGE_INGRESS,
                                                 &stage_fc
                                                 )
                        );

    FP_LOCK(unit);
                        
    if ((rv = _bcm_field_data_qualifier_get(unit,
                                            stage_fc,
                                            qual_id,
                                            &f_dq
                                            )
         )
        == BCM_E_NONE
        ) {
        qual->qual_id     = f_dq->qid;
        qual->flags       = f_dq->flags;
        qual->offset_base = f_dq->offset_base;
        qual->offset      = f_dq->offset;
        qual->length      = f_dq->length;

        if (FP_VERB_CHECK()) {
          (void)_field_data_qualifier_debug(unit, stage_fc, f_dq);
        }
    }

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_data_qualifier_destroy
 * Purpose:
 *      Destroy an data/offset based qualifier.
 * Parameters:
 *      unit     - (IN)  bcm device.
 *      qual_id  - (IN)  Data qualifier id.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_data_qualifier_destroy(int unit, int qual_id)
{
   int rv = BCM_E_UNAVAIL;      /* Operation return status.     */
    
#if defined BCM_TRIDENT3_SUPPORT
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       return rv;
    }
#endif
    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }
    FP_LOCK(unit);

    rv = _bcm_field_data_qualifier_destroy(unit, qual_id); 

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_data_qualifier_destroy_all
 * Purpose:
 *      Delete all data/offset based qualifiers.
 * Parameters:
 *      unit          - (IN)  bcm device.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_data_qualifier_destroy_all(int unit)
{
   int rv = BCM_E_UNAVAIL;      /* Operation return status.     */
    
#if defined BCM_TRIDENT3_SUPPORT
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       return rv;
    }
#endif 
    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }
    FP_LOCK(unit);

    rv = _field_data_qualifier_destroy_all(unit); 

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qset_data_qualifier_get
 * Purpose:
 *      Get field data qualifiers included in group qset. 
 * Parameters:
 *      unit          - (IN) bcm device.
 *      qset          - (IN) Group qualifier set.
 *      qual_max      - (IN) Maximum qualifiers to fill.
 *      qual_arr      - (OUT) Data qualifiers array.
 *      qual_count    - (OUT) Number of data qualifiers filled in qual_arr.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_qset_data_qualifier_get(int unit, bcm_field_qset_t qset, int qual_max,
                                  int *qual_arr, int *qual_count) 
{
    _field_data_qualifier_p f_dq;  /* Field data qualifier iterator. */
    _field_stage_t *stage_fc;      /* Stage field control structure. */
    bcm_field_qset_t  qset_temp;   /* Temporary qset copy.           */
    int count;                     /* Filled entries count.          */
    int rv;                        /* Operation return status.       */

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }

    /* Input parameters check. */
    if ((qual_max <= 0) || (NULL == qual_arr) ||
        (NULL == qual_count)) {
        return BCM_E_PARAM;
    }
    /* Get field control structure. */
    
    FP_LOCK(unit);

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc); 
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Reset caller provided array. */
    sal_memset(qual_arr, 0, qual_max * sizeof(int));

    /* Copy qset to a temporary variable. */
    qset_temp = qset;

    /* Fill caller array. */
    count = 0;
    f_dq = stage_fc->data_ctrl->data_qual; 

    /* Stage data qualifiers iteration array. */
    while (NULL != f_dq) {
        if (f_dq->hw_bmap & qset_temp.udf_map[0]) {
            /* Remove data qualifier udfs from the temporary qset. */
            qset_temp.udf_map[0] &= ~f_dq->hw_bmap;
            /* Add data qualifier id to caller array. */
            qual_arr[count] = f_dq->qid;
            count++;
            if (count >= qual_max) {
                break;
            }
        }
        f_dq = f_dq->next;
    }
    *qual_count = count;

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qset_data_qualifier_add
 * Purpose:
 *      Add field data qualifier to group qset.
 * Parameters:
 *      unit          - (IN) bcm device.
 *      qset          - (IN/OUT) Group qualifier set.
 *      qualifier_id  - (IN) Data qualifier id.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_qset_data_qualifier_add(int unit, bcm_field_qset_t *qset,  
                                      int qual_id)
{
    _field_stage_t          *stage_fc;  /* Stage field control.       */
    _field_data_qualifier_t *f_dq;      /* Data qualifier descriptor. */
    int                     idx;        /* HW bitmap iteration index. */
    int                     rv;         /* Operation return status.   */
#ifdef BCM_TRIUMPH_SUPPORT
    uint32              reg_val;        /* Register value */
    uint32              ext_udf_support = 0; /* External UDF support status */
#endif
#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
    int offset0_1 = 0;                  /* HW offset 0 and 1 usage status. */
    int offset2_3 = 0;                  /* HW offset 2 and 3 usage status. */
    int offset4_5 = 0;                  /* HW offset 4 and 5 usage status. */
    int offset6_7 = 0;                  /* HW offset 6 and 7 usage status. */
#endif /* !BCM_TRIDENT_SUPPORT */

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }

    /* Input parameters check. */
    if (NULL == qset) {
        return (BCM_E_PARAM);
    }

    FP_LOCK(unit);

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc); 
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /*Get data qualifier info. */
    rv = _bcm_field_data_qualifier_get(unit, stage_fc, qual_id,  &f_dq);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        FP_UNLOCK(unit);
        rv = _bcm_field_th_field_qset_data_qualifier_add(unit, qset, qual_id);
        return (rv);
    }
#endif

#ifdef BCM_TRIUMPH_SUPPORT
    if (SOC_IS_TRIUMPH(unit) || SOC_IS_TRIUMPH2(unit)) {
        rv = READ_ESM_KEYGEN_CTLr(unit, &reg_val);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
        ext_udf_support = soc_reg_field_get(unit, ESM_KEYGEN_CTLr, reg_val, 
                                            L2_ACL_PAYLOAD_MODEf);
    }
#endif

    for (idx = 0; idx <= stage_fc->data_ctrl->num_elems * 2; idx++) {
        if (f_dq->hw_bmap & (1 << idx)) {
            SHR_BITSET(qset->udf_map, idx);
            if (idx >= 0 && idx < stage_fc->data_ctrl->num_elems) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData0);
#ifdef BCM_TRIUMPH_SUPPORT
                /* External UDF support has to be enabled in ESM_KEYGEN_CTRLr*/
                if ((SOC_IS_TRIUMPH(unit) || SOC_IS_TRIUMPH2(unit)) && 
                    (1 == ext_udf_support)) {
                    if (SHR_BITGET(qset->udf_map, 0) && 
                        !SHR_BITGET(qset->udf_map, 1) &&
                        !SHR_BITGET(qset->udf_map, 3)) {
                        BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
                    }
                } 
#endif /* !BCM_TRIUMPH_SUPPORT */
            } else if (idx >= stage_fc->data_ctrl->num_elems &&
                       idx < stage_fc->data_ctrl->num_elems * 2) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData1);
            }
        }
    }

#if defined(BCM_ENDURO_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
    if(BCM_FIELD_QSET_TEST_INTERNAL(*qset, _bcmFieldQualifyData0)
        && (SOC_IS_ENDURO(unit)
            || SOC_IS_HURRICANEX(unit) || SOC_IS_GREYHOUND(unit)
            || SOC_IS_GREYHOUND2(unit)
            || (SOC_IS_TRIUMPH2(unit) && !BCM_FIELD_QSET_TEST_INTERNAL(*qset, bcmFieldQualifyStageExternal))
            || SOC_IS_APOLLO(unit) || SOC_IS_VALKYRIE2(unit))) {
        /* See if not having to use all UDF1 */
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData0);
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData2);
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData3);

        if (!SHR_BITGET(qset->udf_map, 0) &&
            SHR_BITGET(qset->udf_map, 1) &&
            !SHR_BITGET(qset->udf_map, 2) && 
            !SHR_BITGET(qset->udf_map, 3)) {
            /* Add UDF1_95_64 */
            BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData3);
        } else if(!SHR_BITGET(qset->udf_map, 0) &&
                  !SHR_BITGET(qset->udf_map, 1) && 
                  !SHR_BITGET(qset->udf_map, 2) && 
                  SHR_BITGET(qset->udf_map, 3)){
                  /* Add UDF1_31_0 */
                  BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
        } else if(!SHR_BITGET(qset->udf_map, 0) &&
                  SHR_BITGET(qset->udf_map, 1) && 
                  !SHR_BITGET(qset->udf_map, 2) && 
                  SHR_BITGET(qset->udf_map, 3)){
            /* Add both UDF1_31_0 and UDF1_95_64 */
            BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
                  BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData3);
        } else {
            /* Add UDF1_127_0 */
            BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData0);
        }
    }
#endif /* BCM_ENDURO_SUPPORT */

#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_KATANA_SUPPORT) 
    if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, _bcmFieldQualifyData0)
        && !((f_dq->flags & BCM_FIELD_DATA_QUALIFIER_STAGE_LOOKUP)
            || BCM_FIELD_QSET_TEST_INTERNAL(*qset, bcmFieldQualifyStageLookup))
        && (SOC_IS_TD_TT(unit)
            || SOC_IS_KATANAX(unit)
            || SOC_IS_TRIUMPH3(unit)
            )
        ) {

        /* Remove the internal qualifiers. */
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData0);
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData2);
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData3);

        /* Get HW offsets usage status. */
        SHR_BITTEST_RANGE(qset->udf_map, 0, 2, offset0_1);
        SHR_BITTEST_RANGE(qset->udf_map, 2, 2, offset2_3);
        SHR_BITTEST_RANGE(qset->udf_map, 4, 2, offset4_5);
        SHR_BITTEST_RANGE(qset->udf_map, 6, 2, offset6_7);

        /* Add new internal qualifiers based on HW offsets usage status. */
        if ((!offset0_1 && !offset4_5) && (offset2_3 || offset6_7)) {
            if (offset2_3 && offset6_7) {
                /* Add both UDF1_31_0 and UDF1_95_64 */
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData3);
            } else if (offset6_7 && !offset2_3) {
                  /* Add UDF1_31_0 */
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
            } else {
                  /* Add UDF1_95_64 */
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData3);
            }
        } else {
            /* Add UDF1_127_0 */
            BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData0);
        }
    }
#endif /* !BCM_TRIDENT_SUPPORT or BCM_KATANA_SUPPORT*/

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qset_data_qualifier_delete
 * Purpose:
 *      Delete field data qualifier from group qset.
 * Parameters:
 *      unit          - (IN) bcm device.
 *      qset          - (IN/OUT) Group qualifier set.
 *      qualifier_id  - (IN) Data qualifier id.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_qset_data_qualifier_delete(int unit, bcm_field_qset_t *qset,  
                                         int qual_id)
{
    _field_stage_t          *stage_fc;  /* Stage field control.       */
    _field_data_qualifier_t *f_dq;      /* Data qualifier descriptor. */
    int                     idx;        /* HW bitmap iteration index. */
    int                     rv;         /* Operation return status.   */
#ifdef BCM_TRIUMPH_SUPPORT
    uint32              reg_val;        /* Register value */
    uint32              ext_udf_support = 0; /* External UDF support status */
#endif
#if defined(BCM_TRIDENT_SUPPORT) /* BCM_TRIDENT_SUPPORT */
    int offset0_1 = 0;                  /* HW offset 0 and 1 usage status. */
    int offset2_3 = 0;                  /* HW offset 2 and 3 usage status. */
    int offset4_5 = 0;                  /* HW offset 4 and 5 usage status. */
    int offset6_7 = 0;                  /* HW offset 6 and 7 usage status. */
#endif /* !BCM_TRIDENT_SUPPORT */

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }

    /* Input parameters check. */
    if (NULL == qset) {
        return (BCM_E_PARAM);
    }

    FP_LOCK(unit);

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc); 
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /*Get data qualifier info. */
    rv = _bcm_field_data_qualifier_get(unit, stage_fc, qual_id,  &f_dq);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) && 
            !(f_dq->flags & BCM_FIELD_DATA_QUALIFIER_STAGE_LOOKUP)) {
        FP_UNLOCK(unit);
        rv = _bcm_field_th_field_qset_data_qualifier_delete(unit, qset, qual_id);
        return (rv);
    }
#endif

#ifdef BCM_TRIUMPH_SUPPORT
    if (SOC_IS_TRIUMPH(unit) || SOC_IS_TRIUMPH2(unit)) {
        rv = READ_ESM_KEYGEN_CTLr(unit, &reg_val);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
        ext_udf_support = soc_reg_field_get(unit, ESM_KEYGEN_CTLr, reg_val, 
                                            L2_ACL_PAYLOAD_MODEf);
    }
#endif

    /* Remove the internal qualifiers. */
    BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData0);
    BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData1);
    BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData2);
    BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData3);

    for (idx = 0; idx <= stage_fc->data_ctrl->num_elems * 2; idx++) {
        if (f_dq->hw_bmap & (1 << idx)) {
            SHR_BITCLR(qset->udf_map, idx);
        } else if (SHR_BITGET(qset->udf_map, idx)) {
            if (idx >= 0 && idx < stage_fc->data_ctrl->num_elems) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData0);
#ifdef BCM_TRIUMPH_SUPPORT
                /* External UDF support has to be enabled in ESM_KEYGEN_CTRLr*/
                if ((SOC_IS_TRIUMPH(unit) || SOC_IS_TRIUMPH2(unit)) && 
                    (1 == ext_udf_support)) {
                    if (SHR_BITGET(qset->udf_map, 0) && 
                        !SHR_BITGET(qset->udf_map, 1) &&
                        !SHR_BITGET(qset->udf_map, 3)) {
                        BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
                    }
                } 
#endif /* !BCM_TRIUMPH_SUPPORT */
            } else if (idx >= stage_fc->data_ctrl->num_elems &&
                       idx < stage_fc->data_ctrl->num_elems * 2) {
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData1);
            }
        }
    }

#if defined(BCM_ENDURO_SUPPORT) || defined(BCM_TRIUMPH2_SUPPORT)
    if(BCM_FIELD_QSET_TEST_INTERNAL(*qset, _bcmFieldQualifyData0)
        && (SOC_IS_ENDURO(unit)
            || SOC_IS_HURRICANEX(unit) || SOC_IS_GREYHOUND(unit)
            || (SOC_IS_TRIUMPH2(unit) && !BCM_FIELD_QSET_TEST_INTERNAL(*qset, bcmFieldQualifyStageExternal))
            || SOC_IS_APOLLO(unit) || SOC_IS_VALKYRIE2(unit))) {
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData2);
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData3);

        if (SHR_BITGET(qset->udf_map, 0) &&
            !SHR_BITGET(qset->udf_map, 1) &&
            SHR_BITGET(qset->udf_map, 2) && 
            !SHR_BITGET(qset->udf_map, 3)) {

            /* No need to use all UDF1. Remove UDF1_127_0. */
            BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData0);
            /* Add both UDF1_31_0 and UDF1_95_64 */
            BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
            BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData3);
        } else if(SHR_BITGET(qset->udf_map, 0) &&
                  !SHR_BITGET(qset->udf_map, 1) && 
                  !SHR_BITGET(qset->udf_map, 2) && 
                  !SHR_BITGET(qset->udf_map, 3)){

             /* No need to use all UDF1. Remove UDF1_127_0. */
             BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData0);
             /* Add UDF1_31_0 */
             BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
        } else if(!SHR_BITGET(qset->udf_map, 0) &&
                  !SHR_BITGET(qset->udf_map, 1) && 
                  SHR_BITGET(qset->udf_map, 2) && 
                  !SHR_BITGET(qset->udf_map, 3)){

             /* No need to use all UDF1. Remove UDF1_127_0. */
             BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData0);
             /* Add UDF1_95_64 */
             BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData3);
        }
    }
#endif /* BCM_ENDURO_SUPPORT */

#if defined(BCM_TRIDENT_SUPPORT) || defined(BCM_KATANA_SUPPORT)
    if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, _bcmFieldQualifyData0)
        && !((f_dq->flags & BCM_FIELD_DATA_QUALIFIER_STAGE_LOOKUP)
            || BCM_FIELD_QSET_TEST_INTERNAL(*qset, bcmFieldQualifyStageLookup))
        && (SOC_IS_TD_TT(unit)
            || SOC_IS_KATANA(unit)
            || SOC_IS_TRIUMPH3(unit)
            )
        ) {

        /* Remove the internal qualifiers. */
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData2);
        BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData3);

        /* Get HW offsets usage status. */
        SHR_BITTEST_RANGE(qset->udf_map, 0, 2, offset0_1);
        SHR_BITTEST_RANGE(qset->udf_map, 2, 2, offset2_3);
        SHR_BITTEST_RANGE(qset->udf_map, 4, 2, offset4_5);
        SHR_BITTEST_RANGE(qset->udf_map, 6, 2, offset6_7);

        /* Add new internal qualifiers based on HW offsets usage status. */
        if ((!offset0_1 && !offset4_5) && (offset2_3 || offset6_7)) {
            if (offset2_3 && offset6_7) {
                /* No need to use all UDF1. Remove UDF1_127_0. */
                BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData0);
                /* Add both UDF1_31_0 and UDF1_95_64 */
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData3);
            } else if (offset6_7 && !offset2_3) {
                /* No need to use all UDF1. Remove UDF1_127_0. */
                BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData0);
                  /* Add UDF1_31_0 */
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData2);
            } else {
                /* No need to use all UDF1. Remove UDF1_127_0. */
                BCM_FIELD_QSET_REMOVE_INTERNAL(*qset, _bcmFieldQualifyData0);
                  /* Add UDF1_95_64 */
                BCM_FIELD_QSET_ADD_INTERNAL(*qset, _bcmFieldQualifyData3);
            }
        } 
    }
#endif /* !BCM_TRIDENT_SUPPORT or BCM_KATANA_SUPPORT*/

    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_data
 * Purpose:
 *      Set data/mask in the search engine for entry field data qualifier.
 * Parameters:
 *      unit          - (IN) bcm device.
 *      eid           - (IN) Entry id. 
 *      qual_id       - (IN) Data qualifier id.
 *      data          - (IN) Match data.
 *      mask          - (IN) Match mask.
 *      length        - (IN) Length of data & mask arrays.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_qualify_data(int unit, bcm_field_entry_t eid, int qual_id,
                           uint8 *data, uint8 *mask, uint16 length)
{
    int                     rv;         /* Operation return status.   */

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    FP_LOCK(unit);

    rv = _field_qualify_data(unit, eid, qual_id, data, mask, length);

    FP_UNLOCK(unit);
    return (rv);
}

#define _FP_L2_FORMAT_MIN   (0)
#define _FP_L2_FORMAT_MAX   (2)
/*
 * Function:
 *      bcm_esw_field_data_qualifier_ethertype_add
 * Purpose:
 *      Add ethertype based offset to data qualifier object.
 * Parameters:
 *      unit       - (IN) bcm device.
 *      qual_id    - (IN) Data qualifier id.
 *      etype      - (IN) Ethertype based offset specification.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_data_qualifier_ethertype_add(int unit,  int qual_id,
                                 bcm_field_data_ethertype_t *etype)
{
    _field_control_t  *fc;             /* Field control structure.  */
    int               rv = BCM_E_NONE; /* Operation return status.  */

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }
    /* Input parameters check. */
    if (NULL == etype) {
        return (BCM_E_PARAM);
    }

    /* Relative offset calculation. */
    if (SOC_MEM_FIELD_VALID(unit, FP_UDF_OFFSETm, UDF1_OFFSET4f)) {
        if (0 != etype->relative_offset % 2)  {
            return (BCM_E_PARAM);
        }
    } else if (0 != etype->relative_offset % 4)  {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = fc->functions.fp_data_qualifier_ethertype_add(unit, qual_id, etype); 

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_data_qualifier_ethertype_delete
 * Purpose:
 *      Remove ethertype based offset from data qualifier object. 
 * Parameters:
 *      unit       - (IN) bcm device.
 *      qual_id    - (IN) Data qualifier id.
 *      etype      - (IN) Ethertype based offset specification.                 
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_data_qualifier_ethertype_delete(int unit, int qual_id,
                                 bcm_field_data_ethertype_t *etype)
{
    _field_control_t  *fc;             /* Field control structure.  */
    int               rv = BCM_E_NONE; /* Operation return status.  */

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }

    /* Input parameters check. */
    if (NULL == etype) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = fc->functions.fp_data_qualifier_ethertype_delete(unit, qual_id, 
                                                          etype); 

    FP_UNLOCK(unit);
    return (rv);
}
#undef _FP_L2_FORMAT_MIN
#undef _FP_L2_FORMAT_MAX

/*
 * Function:
 *      bcm_esw_field_data_qualifier_ip_protocol_add
 * Purpose:
 *      Add ip protocol based offset to data qualifier object.
 * Parameters:
 *      unit        - (IN) bcm device.
 *      qual_id     - (IN) Data qualifier id.
 *      ip_protocol - (IN) Ethertype based offset specification.                 
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_data_qualifier_ip_protocol_add(int unit, int qual_id,
                                 bcm_field_data_ip_protocol_t *ip_protocol)
{
    _field_control_t  *fc;             /* Field control structure.  */
    int               rv = BCM_E_NONE; /* Operation return status.  */

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }

    /* Input parameters check. */
    if (NULL == ip_protocol) {
        return (BCM_E_PARAM);
    }

    /* Relative offset Calculation. */
    if (SOC_MEM_FIELD_VALID(unit, FP_UDF_OFFSETm, UDF1_OFFSET4f)) {
        if (0 != ip_protocol->relative_offset % 2)  {
            return (BCM_E_PARAM);
        }
    } else if (0 != ip_protocol->relative_offset % 4)  {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }
    rv = fc->functions.fp_data_qualifier_ip_protocol_add(unit, qual_id, 
                                                         ip_protocol); 
    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_data_qualifier_ip_protocol_delete
 * Purpose:
 *      Remove ip protocol based offset from data qualifier object. 
 * Parameters:
 *      unit        - (IN) bcm device.
 *      qual_id     - (IN) Data qualifier id.
 *      ip_protocol - (IN) Ethertype based offset specification.                 
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_data_qualifier_ip_protocol_delete(int unit, int qual_id,
                                 bcm_field_data_ip_protocol_t *ip_protocol)
{
    _field_control_t  *fc;             /* Field control structure.  */
    int               rv = BCM_E_NONE; /* Operation return status.  */

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }

    /* Input parameters check. */
    if (NULL == ip_protocol) {
        return (BCM_E_PARAM);
    }
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = fc->functions.fp_data_qualifier_ip_protocol_delete(unit, qual_id, 
                                                            ip_protocol); 
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_data_qualifier_packet_format_add
 * Purpose:
 *      Add packet format based offset to data qualifier object.
 * Parameters:
 *      unit          - (IN) bcm device.
 *      qual_id       - (IN) Data qualifier id.
 *      packet_format - (IN) Ethertype based offset specification.                 
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_data_qualifier_packet_format_add(int unit, int qual_id,
                                 bcm_field_data_packet_format_t *packet_format)
{
    _field_control_t          *fc;   /* Field control structure.  */
    int                       rv;    /* Operation return status.  */

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }

    /* Input parameters check. */
    if (NULL == packet_format) {
        return (BCM_E_PARAM);
    }

    /* Relative offset calculation. */
    if (SOC_MEM_FIELD_VALID(unit, FP_UDF_OFFSETm, UDF1_OFFSET4f)) {
        if (0 != packet_format->relative_offset % 2)  {
            return (BCM_E_PARAM);
        }
    } else if (0 != packet_format->relative_offset % 4)  {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = fc->functions.fp_data_qualifier_packet_format_add(unit, qual_id, 
                                                           packet_format);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_data_qualifier_packet_format_delete
 * Purpose:
 *      Remove packet format based offset from data qualifier object. 
 * Parameters:
 *      unit           - (IN) bcm device.
 *      qual_id        - (IN) Data qualifier id.
 *      packet_format  - (IN) Ethertype based offset specification.                 
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_data_qualifier_packet_format_delete(int unit, int qual_id,
                                 bcm_field_data_packet_format_t *packet_format)
{
    _field_control_t           *fc;   /* Field control structure.  */
    int                        rv;    /* Operation return status.  */

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }

    /* Input parameters check. */
    if (NULL == packet_format) {
        return (BCM_E_PARAM);
    }
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = fc->functions.fp_data_qualifier_packet_format_delete(unit, qual_id, 
                                                              packet_format);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_data_get
 * Purpose:
 *      Get data/mask in the search engine for entry field data qualifier.
 * Parameters:
 *      unit          - (IN) bcm device.
 *      eid           - (IN) Entry id. 
 *      qual_id       - (IN) Data qualifier id.
 *      length_max    - (IN) Length of data & mask arrays.
 *      data          - (OUT) Match data.
 *      mask          - (OUT) Match mask.
 *      length        - (OUT) Length of data & mask arrays.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_esw_field_qualify_data_get(int unit, bcm_field_entry_t eid, int qual_id,
                               uint16 length_max,  uint8 *data, uint8 *mask,
                               uint16 *length)
{
    _field_stage_t          *stage_fc;  /* Stage field control.       */
    _field_data_qualifier_t *f_dq;      /* Data qualifier descriptor. */
    _field_entry_t          *f_ent = NULL;
    _field_group_t          *fg;
    bcm_field_qset_t        *qset; 
    int  num_elems = 0;
    int  qualifier_id = 0;
    int idx;        /* HW bitmap iteration index. */
    int rv;         /* Operation return status.   */
    int copy_len;
    int len = 0;
    int off = 0;
    int max_elems = 0;
    int min_elems = 0;
    int udf1_elems = 0; /* elements in UDF1 */
    int udf2_elems = 0; /* elements in UDF2 */
    _bcm_field_qual_data_t udf_data; /* UDF full data */
    _bcm_field_qual_data_t udf_mask; /* UDF mask for full data */
    _bcm_field_qual_data_t udf_data1; /* UDF full data */
    _bcm_field_qual_data_t udf_mask1; /* UDF mask for full data */
#ifdef LE_HOST
    _bcm_field_qual_data_t udf_data_swap; /* UDF full data */
    _bcm_field_qual_data_t udf_mask_swap; /* UDF mask for full data */
    int part = 0;
#endif /* LE_HOST */
    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask) || 
            (NULL == length) || (length_max == 0)) {
        return (BCM_E_PARAM);
    }

    if (soc_feature(unit, soc_feature_no_fp_data_qual_api_support)) {
       return BCM_E_UNAVAIL;
    }

    FP_LOCK(unit);

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, _BCM_FIELD_STAGE_INGRESS, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Get data qualifier info. */
    rv = _bcm_field_data_qualifier_get(unit, stage_fc, qual_id,  &f_dq);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        FP_UNLOCK(unit);
        rv = _bcm_field_th_field_qualify_data_get(unit, eid, qual_id,
                length_max, data, mask, length);
        return (rv);
    }
#endif
    /*
     * If provided entry data length is less than data length used
     * to create qualifier then return error
     */

    if (length_max < f_dq->length) {
        FP_UNLOCK(unit);
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_get_by_id(unit, eid, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Get field group */
    fg = f_ent->group;

    /* get qset */
    qset = &(fg->qset);

    /* Get number of elems per UDF and elem size */
    num_elems = stage_fc->data_ctrl->num_elems;

    for (idx = 0; idx < num_elems; idx++) {
        if (!(f_dq->hw_bmap & (1 << idx))) {
            continue;
        }
        udf1_elems++;
    }

    for (idx = num_elems; idx < num_elems*2; idx++) {
        if (!(f_dq->hw_bmap & (1 << idx))) {
            continue;
        }
        udf2_elems++;
    }

    if (udf1_elems != 0) {
        qualifier_id = _bcmFieldQualifyData0;
        max_elems = stage_fc->data_ctrl->num_elems;
        min_elems = 0;
    } else if (udf2_elems != 0) {
        qualifier_id = _bcmFieldQualifyData1;
        max_elems = stage_fc->data_ctrl->num_elems*2;
        min_elems = stage_fc->data_ctrl->num_elems;
    }

    do {
        /* Qset has Data2 Data3 instead of Data0 qualifier */
        if ((qualifier_id == _bcmFieldQualifyData0) &&
                (!BCM_FIELD_QSET_TEST_INTERNAL(*qset, _bcmFieldQualifyData0))) {
            sal_memset(udf_data, 0, sizeof(_bcm_field_qual_data_t));
            sal_memset(udf_mask, 0, sizeof(_bcm_field_qual_data_t));
            if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, _bcmFieldQualifyData2)) {
                rv = _field_entry_qualifier_key_get(unit, eid, _bcmFieldQualifyData2,
                        udf_data1, udf_mask1);
                if (BCM_FAILURE(rv)) {
                    FP_UNLOCK(unit);
                    return (rv);
                }
                udf_data[0] = udf_data1[0];
                udf_mask[0] = udf_mask1[0];
            }
            if (BCM_FIELD_QSET_TEST_INTERNAL(*qset, _bcmFieldQualifyData3)) {
                rv = _field_entry_qualifier_key_get(unit, eid, _bcmFieldQualifyData3,
                        udf_data1, udf_mask1);
                if (BCM_FAILURE(rv)) {
                    FP_UNLOCK(unit);
                    return (rv);
                }
                udf_data[2] = udf_data1[0];
                udf_mask[2] = udf_mask1[0];
            }
        } else {
            rv = _field_entry_qualifier_key_get(unit, eid, qualifier_id,
                    udf_data, udf_mask);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }
        }
#ifdef LE_HOST
        for (part = 0; part <= BCM_FIELD_USER_MAX_USER_NUM; part++) {
            udf_data_swap[part]= _shr_swap32(udf_data[part]);
            udf_data[part]= udf_data_swap[part];
            udf_mask_swap[part]= _shr_swap32(udf_mask[part]);
            udf_mask[part]= udf_mask_swap[part];
        }
#endif /* LE_HOST */

        for (idx = min_elems; idx < max_elems; idx++) {
            if (!(f_dq->hw_bmap & (1 << idx))) {
                continue;
            }

            if ((f_dq->length - len) <= 0) {
                break;
            }

            if (stage_fc->data_ctrl->elem_size == 2) {
                /*
                 * Retreive the relevant data and mask from 4 words
                 * (4 * 4 = 16 bytes) of data and mask.
                 * For each index set  a chunk(2 bytes) are read. The way
                 * information is organized is for different index values
                 * data resides in following location.
                 * index = 0 data in 12,13 - W = 3 offset = 0
                 * index = 1 data in 14,15 - W = 3 offset = 2
                 * index = 2 data in 8,9   - W = 2 offset = 0
                 * index = 3 data in 10,11 - W = 2 offset = 2
                 * index = 4 data in 4,5   - W = 1 offset = 0
                 * index = 5 data in 6,7   - W = 1 offset = 2
                 * index = 6 data is 0,1   - W = 0 offset = 0
                 * index = 7 data is 2,3   - W = 0 offset = 2
                 */
                off = idx % 2 * 2;
                copy_len = ((f_dq->length - len) == 1)? 1 : 2;
                if (len == 0) {
                    off += f_dq->byte_offset;
                    copy_len = 2 - f_dq->byte_offset;
                    if (copy_len > f_dq->length) {
                        copy_len = f_dq->length;
                    }
                }
                sal_memcpy(data+len,
                        (uint8 *)&udf_data[((max_elems - 1)
                            - idx)/2]+off, copy_len);
                sal_memcpy(mask+len,
                        (uint8 *)&udf_mask[((max_elems - 1)
                            - idx)/2]+off, copy_len);
                len += copy_len;
            } else if (stage_fc->data_ctrl->elem_size == 4) {
                /*
                 * Retreive the relevant data and mask from 4 words
                 * (4 * 4 = 16 bytes) of data and mask.
                 * For each index set  a chunk(4 bytes) are read. The way
                 * information is organized is for different index values
                 * data resides in following location.
                 * index = 0 data in 12,13,14,15 - W = 3 offset = 0
                 * index = 1 data in 8,9,10,11   - W = 2 offset = 0
                 * index = 2 data in 4,5,6,7     - W = 1 offset = 0
                 * index = 3 data is 0,1,2,3     - W = 0 offset = 0
                 *
                 * If the data offset in first UDF is not zero,
                 * the location should be shifted.
                 * For example :
                 * index = 0 data in 10,11,12,13 - W = 3 offset = 2
                 * index = 1 data in 6,7,8,9   - W = 2 offset = 2
                 * index = 2 data in 2,3,4,5     - W = 1 offset = 2
                 * index = 3 data is X,X, 0,1     - W = 0 offset = 2
                 */
                off = f_dq->byte_offset;
                if (len == 0) {
                    /* first word */
                    copy_len = 4 - off;
                    /* Only one word */
                    if (copy_len > f_dq->length) {
                        copy_len = f_dq->length;
                    }
                    sal_memcpy(data+len,
                            (uint8 *)&udf_data[(max_elems - 1) - idx] + off,
                            copy_len);
                    sal_memcpy(mask+len,
                            (uint8 *)&udf_mask[(max_elems - 1) - idx] + off,
                            copy_len);
                    len += copy_len;
                } else if ((len + 4) > f_dq->length) {
                    /* last word */
                    sal_memcpy(data+len,
                            (uint8 *)&udf_data[(max_elems - 1) - idx],
                            (f_dq->length - len));
                    sal_memcpy(mask+len,
                            (uint8 *)&udf_mask[(max_elems - 1) - idx],
                            (f_dq->length - len));
                    len += (f_dq->length - len);
                } else {
                    /* others */
                    sal_memcpy(data+len,
                            (uint8 *)&udf_data[(max_elems - 1) - idx], 4);
                    sal_memcpy(mask+len,
                            (uint8 *)&udf_mask[(max_elems - 1) - idx], 4);
                    len += 4;
                }
            } else {
                FP_UNLOCK(unit);
                return (BCM_E_INTERNAL);
            }
        }

        if ((qualifier_id == _bcmFieldQualifyData0) && (udf2_elems != 0)) {
            qualifier_id = _bcmFieldQualifyData1;
            max_elems = stage_fc->data_ctrl->num_elems*2;
            min_elems = stage_fc->data_ctrl->num_elems;
            continue;
        }
        *length = f_dq->length;
        break;
    } while (1);

    FP_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_LoopbackType_get
 * Purpose:
 *      Get loopback type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      loopback_type - (OUT) Loopback type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_LoopbackType_get(int unit, 
                                       bcm_field_entry_t entry, 
                                       bcm_field_LoopbackType_t *loopback_type)
{
    uint8            data; /* HW data match criteria.  */
    uint8            mask; /* HW data mask.            */
    int              rv;   /* Operation return status. */

    /* Input parameters check. */
    if (NULL == loopback_type) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                          bcmFieldQualifyLoopbackType,
                                          &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
#if defined(BCM_TOMAHAWK_SUPPORT)
        _field_entry_t *f_ent;  /* Field entry structure.   */
        uint8 presel_entry = 0;

        if (soc_feature(unit, soc_feature_field_preselector_support) &&
                        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
            presel_entry = 1;
        } else {
            /* Get field entry part that contains the qualifier. */
            rv = _bcm_field_entry_qual_get(unit, entry, bcmFieldQualifyLoopbackType, &f_ent);
            BCM_IF_ERROR_RETURN(rv);
        } 

#if defined(BCM_TOMAHAWK3_SUPPORT)
        if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
            return (_bcm_field_th3_qualify_LoopbackType_get(data, mask, loopback_type));
        } else
#endif

#if defined(BCM_TRIDENT3_SUPPORT)
        if (soc_feature(unit, soc_feature_td3_style_fp) &&
            ((presel_entry == 1) || (f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS))) {
            return (_bcm_field_td3_qualify_LoopbackType_get(data, mask, loopback_type));
        } else
#endif
        if (presel_entry == 1) {
           return BCM_E_PARAM;
        }

        if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
                (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS)) {
            /*Loopback Type encoding in Tomahawk Egress is different from TD2.*/
            return (_bcm_field_th_qualify_LoopbackType_get(data, mask, loopback_type)); 
        }
        else
#endif
        {
            return (_bcm_field_td2_qualify_LoopbackType_get(data, mask, loopback_type));
        }
    }
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        return (_bcm_field_tr3_qualify_LoopbackType_get(data, mask, loopback_type));
    }
#endif

    switch (data) {
      case 0x8:
          *loopback_type = bcmFieldLoopbackTypeAny;
          break;
      case 0x9:
#ifdef BCM_KATANA2_SUPPORT
          if (SOC_IS_KATANA2(unit)) {
              *loopback_type = bcmFieldLoopbackTypeMirror;
          } else
#endif /* BCM_KATANA2_SUPPORT */
          {
              *loopback_type = bcmFieldLoopbackTypeRedirect;
          }
          break;
#ifdef BCM_KATANA2_SUPPORT
      case 0xa:
          if (SOC_IS_KATANA2(unit)) {
              *loopback_type = bcmFieldLoopbackTypeRedirect;
          } else {
              return (BCM_E_INTERNAL);
          }
          break;
#endif /* BCM_KATANA2_SUPPORT */
      case 0xb:
          *loopback_type = bcmFieldLoopbackTypeMim;
          break;
      case 0xc:
#ifdef BCM_TRIDENT_SUPPORT
          if (SOC_IS_TD_TT(unit) || SOC_IS_KATANA(unit)) {
              *loopback_type = bcmFieldLoopbackTypeTrillNetwork;
          } else 
#endif /* BCM_TRIDENT_SUPPORT */
          {
              *loopback_type = bcmFieldLoopbackTypeWlan;
          }
          break;
#ifdef BCM_TRIDENT_SUPPORT
      case 0xd:
          if (SOC_IS_TD_TT(unit) || SOC_IS_KATANA(unit)) {
              *loopback_type = bcmFieldLoopbackTypeTrillAccess;
          } 
          break;
#endif /* BCM_TRIDENT_SUPPORT */
      case 0xe:
          {
              *loopback_type = bcmFieldLoopbackTypeMirror;
          }
          break;
      default:
          return (BCM_E_INTERNAL);
    }
    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelType_get
 * Purpose:
 *      Get tunnel type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      tunnel_type - (OUT) Tunnel type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TunnelType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_TunnelType_t *tunnel_type)
{
    uint8            data; /* HW data match criteria.  */
    uint8            mask; /* HW data mask.            */
    int              rv;   /* Operation return status. */

    /* Input parameters check. */
    if (NULL == tunnel_type) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                          bcmFieldQualifyTunnelType,
                                          &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        return (_bcm_field_td3_qualify_TunnelType_get(unit, data, mask, tunnel_type));
    }
#endif /* BCM_TRIDENT3_SUPPORT */
#if defined(BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_fp_no_dvp_support)) {
        return (_bcm_field_th3_qualify_TunnelType_get(data, mask, tunnel_type));
    }
#endif /* BCM_TOMAHAWK3_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        return (_bcm_field_td2_qualify_TunnelType_get(data, mask, tunnel_type));
    }
#endif /* BCM_TRIDENT2_SUPPORT */
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        return (_bcm_field_tr3_qualify_TunnelType_get(data, mask, tunnel_type));
    }
#endif

    switch (data) {
      case 0x1:
          *tunnel_type = bcmFieldTunnelTypeIp;
          break;
      case 0x2:
          *tunnel_type = bcmFieldTunnelTypeMpls;
          break;
      case 0x3:
          *tunnel_type = bcmFieldTunnelTypeMim;
          break;
      case 0x4:
          *tunnel_type = bcmFieldTunnelTypeWlanWtpToAc;
          break;
      case 0x5:
          *tunnel_type = bcmFieldTunnelTypeWlanAcToAc;
          break;
      case 0x6:
          *tunnel_type = bcmFieldTunnelTypeAutoMulticast;
          break;
      case 0x7:
          *tunnel_type = bcmFieldTunnelTypeTrill;
          break;
      case 0x0:
          if(mask) {
              *tunnel_type = bcmFieldTunnelTypeNone;
              break;
          }
      default:
          return (BCM_E_INTERNAL);
    }
    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstL3Egress_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstL3Egress
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      if_id - (OUT) L3 forwarding object.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstL3Egress_get(int unit, bcm_field_entry_t entry, 
                                      bcm_if_t *if_id)
{
    int               rv = BCM_E_UNAVAIL;  /* Operation return status. */
#if defined(INCLUDE_L3)
    uint32            data; /* HW data match criteria.  */
    uint32            mask; /* HW data mask.            */

    /* Input parameters check. */
    if (NULL == if_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                           bcmFieldQualifyDstL3Egress,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
        entry, bcmFieldQualifyDstL3Egress, &data, &mask));

    *if_id = data + BCM_XGS3_EGRESS_IDX_MIN(unit);
#endif /* INCLUDE_L3 */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMulticastGroup_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMulticastGroup
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      group - (OUT) Multicast group id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstMulticastGroup_get(int unit, 
                                            bcm_field_entry_t entry, 
                                            bcm_multicast_t *group)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */
    uint8 mc_grptype_data; /* Multicast Group Type */

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                            bcmFieldQualifyDstMulticastGroup,
                                            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    /* Get Multicast group type info */
    mc_grptype_data = data >> _FP_MCAST_D_TYPE_OFFSET(unit);

    BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
        entry, bcmFieldQualifyDstMulticastGroup, &data, &mask));

    if (_bcmFieldDestTypeL2mc == mc_grptype_data) {
        /* L2 MC */
        _BCM_MULTICAST_GROUP_SET(*group, _BCM_MULTICAST_TYPE_L2, data);
    } else if (_bcmFieldDestTypeL3mc == mc_grptype_data)  {
        /* IPMC */
        _BCM_MULTICAST_GROUP_SET(*group, _BCM_MULTICAST_TYPE_L3, data);
    } else {
        return (BCM_E_INTERNAL);
    }
    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcMplsGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcMplsGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mpls_port_id - (OUT) Mpls port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcMplsGport_get(int unit, 
                                       bcm_field_entry_t entry,
                                       bcm_gport_t *mpls_port_id)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == mpls_port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                           bcmFieldQualifySrcMplsGport,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    data &=  0x1fff;
    BCM_GPORT_MPLS_PORT_ID_SET(*mpls_port_id, data);

    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMplsGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMplsGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mpls_port_id - (OUT) Mpls port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstMplsGport_get(int unit, 
                                       bcm_field_entry_t entry, 
                                       bcm_gport_t *mpls_port_id)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */
    _field_entry_t *f_ent; /* Field entry structure. */

    /* Input parameters check. */
    if (NULL == mpls_port_id) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
        bcmFieldQualifyDstMplsGport, &f_ent));

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyDstMplsGport,
                                            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
         /* Clear DVP Valid bit. */
         data >>= 1;
    } else {
        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
            entry, bcmFieldQualifyDstMplsGport, &data, &mask));
    }

    BCM_GPORT_MPLS_PORT_ID_SET(*mpls_port_id, data);

    return BCM_E_NONE; 
}



/*
 * Function:
 *      bcm_esw_field_qualify_SrcNivGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcNivGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      niv_port_id - (OUT) Niv port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcNivGport_get(int unit, 
                                       bcm_field_entry_t entry,
                                       bcm_gport_t *niv_port_id)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == niv_port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                           bcmFieldQualifySrcNivGport,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    data &=  0x1fff;
    BCM_GPORT_NIV_PORT_ID_SET(*niv_port_id, data);

    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstNivGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstNivGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      niv_port_id - (OUT) Niv port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstNivGport_get(int unit, 
                                       bcm_field_entry_t entry, 
                                       bcm_gport_t *niv_port_id)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */
    _field_entry_t *f_ent; /* Field entry structure. */

    /* Input parameters check. */
    if (NULL == niv_port_id) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
        bcmFieldQualifyDstNivGport, &f_ent));

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyDstNivGport,
                                            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
         /* Clear DVP Valid bit. */
         data >>= 1;
    } else {
        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
            entry, bcmFieldQualifyDstNivGport, &data, &mask));
    }

    BCM_GPORT_NIV_PORT_ID_SET(*niv_port_id, data);

    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcMimGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcMimGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mim_port_id - (OUT) Mim port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcMimGport_get(int unit, 
                                      bcm_field_entry_t entry, 
                                      bcm_gport_t *mim_port_id)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == mim_port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                            bcmFieldQualifySrcMimGport,
                                            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    data &= 0x1fff;
    BCM_GPORT_MIM_PORT_ID_SET(*mim_port_id, data);

    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMimGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMimGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mim_port_id - (OUT) Mim port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstMimGport_get(int unit, 
                                      bcm_field_entry_t entry, 
                                      bcm_gport_t *mim_port_id)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */
    _field_entry_t *f_ent; /* Field entry structure. */

    /* Input parameters check. */
    if (NULL == mim_port_id) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
            bcmFieldQualifyDstMimGport, &f_ent));

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
            bcmFieldQualifyDstMimGport, &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /* Clear DVP Valid bit. */
        data >>= 1;
    } else {
        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
            entry, bcmFieldQualifyDstMimGport, &data, &mask));
    }

    BCM_GPORT_MIM_PORT_ID_SET(*mim_port_id, data);

    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcWlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcWlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      wlan_port_id - (OUT) Wlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcWlanGport_get(int unit, 
                                       bcm_field_entry_t entry, 
                                       bcm_gport_t *wlan_port_id)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == wlan_port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                           bcmFieldQualifySrcWlanGport,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    data &= 0x1fff;
    BCM_GPORT_WLAN_PORT_ID_SET(*wlan_port_id, data);

    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstWlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstWlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      wlan_port_id - (OUT) Wlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstWlanGport_get(int unit, 
                                       bcm_field_entry_t entry, 
                                       bcm_gport_t *wlan_port_id)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == wlan_port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifyDstWlanGport,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
        entry, bcmFieldQualifyDstWlanGport, &data, &mask));

    BCM_GPORT_WLAN_PORT_ID_SET(*wlan_port_id, data);

    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcVxlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcVxlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      vxlan_port_id - (OUT) Vxlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcVxlanGport_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_gport_t *vxlan_port_id)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */
    _field_entry_t *f_ent = NULL;  /* Field entry structure.   */

    /* Input parameters check. */
    if (NULL == vxlan_port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifySrcVxlanGport,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    data &= 0x1fff;
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
            bcmFieldQualifySrcVxlanGport, &f_ent));
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    switch (f_ent->svp_type) {
        case _bcmVpTypeFlow :
            BCM_GPORT_FLOW_PORT_ID_SET(*vxlan_port_id, data);
            break;
        case _bcmVpTypeVxlan:
            BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_id, data);
            break;
        default:
            BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_id, data);
    }
#else
    BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_id, data);
#endif

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstVxlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstVxlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      vxlan_port_id - (OUT) Vxlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstVxlanGport_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_gport_t *vxlan_port_id)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */
    _field_entry_t *f_ent = NULL;  /* Field entry structure.   */

    /* Input parameters check. */
    if (NULL == vxlan_port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifyDstVxlanGport,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
        entry, bcmFieldQualifyDstVxlanGport, &data, &mask));

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
            bcmFieldQualifyDstVxlanGport, &f_ent));
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    switch (f_ent->dvp_type) {
        case _bcmVpTypeFlow :
            BCM_GPORT_FLOW_PORT_ID_SET(*vxlan_port_id, data);
            break;
        case _bcmVpTypeVxlan:
            BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_id, data);
            break;
        default:
            BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_id, data);
    }
#else
    BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_id, data);
#endif

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_Loopback_get
 * Purpose:
 *      Get loopback field qualification from  a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data - (OUT) Data to qualify with.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Loopback_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyLoopback,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InPort_get(int unit, bcm_field_entry_t entry, 
                                 bcm_port_t *data, bcm_port_t *mask)
{
    _field_entry_t   *f_ent;              /* Field entry structure.      */
    int              rv;                  /* Operation return status.    */
    int              isGport;             /* Port format is gport.       */
#if defined(BCM_RAPTOR_SUPPORT) || defined (BCM_TRX_SUPPORT)
    _field_group_t   *fg;                 /* Field group structure.      */
    bcm_port_t       port = 0;            /* Port iterator.              */
#endif /* BCM_RAPTOR_SUPPORT || BCM_TRX_SUPPORT */

    /* Check requested output format. */
    rv = bcm_esw_switch_control_get(unit, bcmSwitchUseGport, &isGport);
    BCM_IF_ERROR_RETURN(rv);

    /* Get field control structure. */
    
    FP_LOCK(unit);

    /* Get field entry that contains InPort qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry,
                                   bcmFieldQualifyInPort, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_RAPTOR_SUPPORT) || defined (BCM_TRX_SUPPORT)
    fg = f_ent->group;
    if ((_BCM_FIELD_STAGE_INGRESS == fg->stage_id) && 
        (soc_feature(unit, soc_feature_field_ingress_ipbm))) {
        BCM_PBMP_ITER(f_ent->pbmp.data, port) {
            *data = *mask = port;
            break;
        }
    } else 
#endif /* BCM_RAPTOR_SUPPORT || BCM_TRX_SUPPORT */
    {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                              bcmFieldQualifyInPort,
                                              (uint32 *)data, (uint32 *)mask);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }
    FP_UNLOCK(unit);

    if (isGport) {
        rv = bcm_esw_port_gport_get(unit, *data, data);
        BCM_IF_ERROR_RETURN(rv);
    } 
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OutPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyOutPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OutPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_port_t *data, 
    bcm_port_t *mask)
{
    int              rv;                  /* Operation return status.    */
    int              isGport;             /* Port format is gport.       */


    /* Check requested output format. */
    rv = bcm_esw_switch_control_get(unit, bcmSwitchUseGport, &isGport);
    BCM_IF_ERROR_RETURN(rv);

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                           bcmFieldQualifyOutPort,
                                           (uint32 *)data, (uint32 *)mask);
    BCM_IF_ERROR_RETURN(rv);

    if (isGport) {
        rv = bcm_esw_port_gport_get(unit, *data, data);
        BCM_IF_ERROR_RETURN(rv);
    } 
    return (BCM_E_NONE);
}


/*
 * Function:
 *      bcm_esw_field_qualify_InPorts_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInPorts
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InPorts_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_pbmp_t *data, 
    bcm_pbmp_t *mask)
{
    int rv;                  /* Operation return status.    */

    if (soc_feature(unit, soc_feature_ifp_no_inports_support)) {
        return (BCM_E_UNAVAIL);
    }
    
    FP_LOCK(unit);
    rv = _bcm_field_qualify_InPorts_get(unit, entry, bcmFieldQualifyInPorts,
                                        data, mask);
    FP_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OutPorts_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyOutPorts
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OutPorts_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_pbmp_t *data, 
    bcm_pbmp_t *mask)
{
    uint32 hw_data;          /* HW encoded qualifier data.  */
    uint32 hw_mask;          /* HW encoding qualifier mask. */
    int rv;                  /* Operation return status.    */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                           bcmFieldQualifyOutPorts,
                                           (uint32 *)&hw_data, 
                                           (uint32 *)&hw_mask);
    FP_UNLOCK(unit);
    BCM_IF_ERROR_RETURN(rv);

    SOC_PBMP_WORD_SET(*data, 0, hw_data);
    SOC_PBMP_WORD_SET(*mask, 0, hw_mask);
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_Drop_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDrop
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Drop_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
#ifdef BCM_FIREBOLT2_SUPPORT
    /* 
     * FB2 has Drop at two places:
     *     one is FIXED (always used), and the other based on selectors. 
     */
    if (SOC_IS_FIREBOLT2(unit)) {
        _field_entry_t   *f_ent;
        int              rv;

        
        FP_LOCK(unit);

        rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

        /* Add data & mask to entry. */
        *data = f_ent->tcam.drop;
        *mask = f_ent->tcam.drop_mask;

        FP_UNLOCK(unit);
        return (BCM_E_NONE);
    }
#endif /* BCM_FIREBOLT2_SUPPORT */    

    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyDrop,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data_modid - (OUT) Qualifier module id.
 *      mask_modid - (OUT) Qualifier module id mask.
 *      data_port - (OUT) Qualifier port id.
 *      mask_port - (OUT) Qualifier port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_module_t *data_modid, 
    bcm_module_t *mask_modid, 
    bcm_port_t *data_port, 
    bcm_port_t *mask_port)
{
    int isGport;             /* Port format is gport.       */
    int isLocal;             /* Local module id flag.       */
    int rv;                  /* Operation return status.    */
    /* Input parameters check. */
    if ((NULL == data_port) || (NULL == mask_port) ||
        (NULL == data_modid) || (NULL == mask_modid)) {
        return (BCM_E_PARAM);
    }


    
    FP_LOCK(unit);

    rv = _field_qualify_Port_get(unit, entry,
                                 data_modid, mask_modid,
                                 data_port,  mask_port,
                                 bcmFieldQualifySrcPort);
    FP_UNLOCK(unit);
    BCM_IF_ERROR_RETURN(rv);

    /* Check requested output format. */
    rv = bcm_esw_switch_control_get(unit, bcmSwitchUseGport, &isGport);
    BCM_IF_ERROR_RETURN(rv);

    if (isGport) {
        BCM_IF_ERROR_RETURN(_bcm_esw_stk_modmap_map(unit,
            BCM_STK_MODMAP_GET, *data_modid, *data_port,
            data_modid, data_port));
        BCM_GPORT_MODPORT_SET(*data_port, *data_modid, *data_port);
        *mask_port = BCM_FIELD_EXACT_MATCH_MASK;
    } else {
        if ((NUM_MODID(unit) > 1) && (SOC_IS_TR_VL(unit)) ) {
#if defined(BCM_TOMAHAWK_SUPPORT)
            if (soc_feature(unit, soc_feature_asymmetric_dual_modid)) {
                if ((*data_port) > (SOC_MODPORT_MAX_FIRST(unit))) {
                    *data_port = (*data_port)-(SOC_MODPORT_MAX_FIRST(unit)+1);
                    (*data_modid) += 1;
                }
            } else
#endif
            {
            rv = _bcm_esw_modid_is_local(unit, *data_modid, &isLocal);
            BCM_IF_ERROR_RETURN(rv);
            if (isLocal) {
                (*data_modid) += ((*data_port) / (SOC_MODPORT_MAX(unit) + 1));
                *data_port = (*data_port) % (SOC_MODPORT_MAX(unit) + 1);
            }
        }
    }
    }
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcTrunk_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcTrunk
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcTrunk_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_trunk_t *data, 
    bcm_trunk_t *mask)
{
    _field_control_t *fc;    /* Field control structure.    */
    int isGport;             /* Port format is gport.       */
    int rv;                  /* Operation return status.    */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = fc->functions.fp_qualify_trunk_get(unit, entry,
                                            bcmFieldQualifySrcTrunk, 
                                            data, mask);
    FP_UNLOCK(unit);
    BCM_IF_ERROR_RETURN(rv);

    /* Check requested output format. */
    rv = bcm_esw_switch_control_get(unit, bcmSwitchUseGport, &isGport);
    BCM_IF_ERROR_RETURN(rv);

    if (isGport) {
        BCM_GPORT_TRUNK_SET(*data, *data);
        *mask = BCM_FIELD_EXACT_MATCH_MASK;
    }
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcTrunkMemberGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcTrunkMemberGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      port  - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcTrunkMemberGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *port) 
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == port) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                           bcmFieldQualifySrcTrunkMemberGport,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    BCM_GPORT_MODPORT_SET(*port, ((data >> _FP_PORT_BITWIDTH(unit)) & 0xff), 
                          (data & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));

    return BCM_E_NONE;

}

/*
 * Function:
 *      bcm_esw_field_qualify_DstPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data_modid - (OUT) Qualifier module id.
 *      mask_modid - (OUT) Qualifier module id mask.
 *      data_port - (OUT) Qualifier port id.
 *      mask_port - (OUT) Qualifier port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_module_t *data_modid, 
    bcm_module_t *mask_modid, 
    bcm_port_t *data_port, 
    bcm_port_t *mask_port)
{
    int isGport;             /* Port format is gport.       */
    int isLocal;             /* Local module id flag.       */
    int rv;                  /* Operation return status.    */

    /* Input parameters check. */
    if ((NULL == data_port) || (NULL == mask_port) ||
        (NULL == data_modid) || (NULL == mask_modid)) {
        return (BCM_E_PARAM);
    }


    
    FP_LOCK(unit);

    rv = _field_qualify_Port_get(unit, entry,
                                 data_modid, mask_modid,
                                 data_port,  mask_port,
                                 bcmFieldQualifyDstPort);
    FP_UNLOCK(unit);
    BCM_IF_ERROR_RETURN(rv);

    /* Check requested output format. */
    rv = bcm_esw_switch_control_get(unit, bcmSwitchUseGport, &isGport);
    BCM_IF_ERROR_RETURN(rv);

    if (isGport) {
        BCM_IF_ERROR_RETURN(_bcm_esw_stk_modmap_map(unit,
            BCM_STK_MODMAP_GET, *data_modid, *data_port,
            data_modid, data_port));
        BCM_GPORT_MODPORT_SET(*data_port, *data_modid, *data_port);
        *mask_port = BCM_FIELD_EXACT_MATCH_MASK;
    } else {
        if ((NUM_MODID(unit) > 1) && (SOC_IS_TR_VL(unit)) ) {
#if defined(BCM_TOMAHAWK_SUPPORT)
            if (soc_feature(unit, soc_feature_asymmetric_dual_modid)) {
                if ((*data_port) > (SOC_MODPORT_MAX_FIRST(unit))) {
                    *data_port = (*data_port)-(SOC_MODPORT_MAX_FIRST(unit)+1);
                    (*data_modid) += 1;
                }
            } else
#endif
            {
            rv = _bcm_esw_modid_is_local(unit, *data_modid, &isLocal);
            BCM_IF_ERROR_RETURN(rv);
            if (isLocal) {
                (*data_modid) += ((*data_port) / (SOC_MODPORT_MAX(unit) + 1));
                *data_port = (*data_port) % (SOC_MODPORT_MAX(unit) + 1);
            }
        }
    }
    }
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstTrunk_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstTrunk
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstTrunk_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_trunk_t *data, 
    bcm_trunk_t *mask)
{
    _field_control_t *fc;    /* Field control structure.    */
    int isGport;             /* Port format is gport.       */
    int rv;                  /* Operation return status.    */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = fc->functions.fp_qualify_trunk_get(unit, entry, 
                                            bcmFieldQualifyDstTrunk,
                                            data, mask);
    FP_UNLOCK(unit);
    BCM_IF_ERROR_RETURN(rv);

    /* Check requested output format. */
    rv = bcm_esw_switch_control_get(unit, bcmSwitchUseGport, &isGport);
    BCM_IF_ERROR_RETURN(rv);

    if (isGport) {
        BCM_GPORT_TRUNK_SET(*data, *data);
        *mask = BCM_FIELD_EXACT_MATCH_MASK;
    }
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerL4SrcPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerL4SrcPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerL4SrcPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                             bcmFieldQualifyInnerL4SrcPort,
                                             (uint32 *)data, (uint32 *)mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerL4DstPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerL4DstPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerL4DstPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                             bcmFieldQualifyInnerL4DstPort,
                                             (uint32 *)data, (uint32 *)mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L4SrcPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL4SrcPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L4SrcPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                             bcmFieldQualifyL4SrcPort,
                                             (uint32 *)data, (uint32 *)mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L4DstPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL4DstPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L4DstPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                             bcmFieldQualifyL4DstPort,
                                             (uint32 *)data, (uint32 *)mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlan_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyOuterVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    int     rv;       /* Operation return status. */
    uint8  hw_data;  /* Installed entry value.   */
    uint8  hw_mask;  /* Installed entry mask.    */

    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
        
        if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
            return (rv); 
        }
    
        if (rv == BCM_E_NONE) { /*Stage is Ingress*/ 
            return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                                   bcmFieldQualifyOuterVlan,
                                                   data, mask);
        }
    }
#endif

    rv = bcm_esw_field_qualify_OuterVlanId_get(unit, entry, 
                                               data, mask);
    BCM_IF_ERROR_RETURN(rv);

    rv = bcm_esw_field_qualify_OuterVlanCfi_get(unit, entry,
                                                &hw_data, &hw_mask); 
    BCM_IF_ERROR_RETURN(rv);
    *data |= (hw_data << 12);
    *mask |= (hw_mask << 12);

    rv = bcm_esw_field_qualify_OuterVlanPri_get(unit, entry,
                                                &hw_data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);
    *data |= (hw_data << 13);
    *mask |= (hw_mask << 13);
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlan_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    uint8  hw_data;  /* Installed entry value.   */
    uint8  hw_mask;  /* Installed entry mask.    */
    int    rv;       /* Operation return status. */

    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
        if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
            /*Error fetching entry*/
            return (rv); 
        }
    
        if (rv == BCM_E_NONE) { /*Stage is Ingress*/ 
            return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                                   bcmFieldQualifyInnerVlan,
                                                   data, mask);
        }
    }
#endif

    rv = bcm_esw_field_qualify_InnerVlanId_get(unit, entry, 
                                               data, mask);
    BCM_IF_ERROR_RETURN(rv);

    rv = bcm_esw_field_qualify_InnerVlanCfi_get(unit, entry,
                                                &hw_data, &hw_mask); 
    BCM_IF_ERROR_RETURN(rv);
    *data |= (hw_data << 12);
    *mask |= (hw_mask << 12);

    rv = bcm_esw_field_qualify_InnerVlanPri_get(unit, entry,
                                                 &hw_data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);
    *data |= (hw_data << 13);
    *mask |= (hw_mask << 13);
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_EtherType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyEtherType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_EtherType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                             bcmFieldQualifyEtherType,
                                             data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpProtocol_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpProtocol
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpProtocol_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyIpProtocol,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpInfo_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpInfo
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpInfo_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    int  rv;           /* Operation return status. */
#if defined(BCM_TRX_SUPPORT)
    _field_entry_t      *f_ent;
#endif /* BCM_TRX_SUPPORT*/

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                           bcmFieldQualifyIpInfo,
                                           data, mask);

#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_RAPTOR_SUPPORT) || defined(BCM_TRX_SUPPORT)
    if (SOC_IS_FIREBOLT2(unit) || SOC_IS_RAVEN(unit) || \
        SOC_IS_TRX(unit) || SOC_IS_HAWKEYE(unit)) {
        if (*mask & BCM_FIELD_IP_HDR_FLAGS_MF) {
            /* In FB2 More fragments bit replaced with whole packet bit. */
            *data = ((*data & BCM_FIELD_IP_HDR_OFFSET_ZERO) | 
                 (*data & BCM_FIELD_IP_CHECKSUM_OK) | 
                 (*data ^ BCM_FIELD_IP_HDR_FLAGS_MF));
        }
    }
#endif /* BCM_FIREBOLT_SUPPORT || BCM_RAPTOR_SUPPORT || BCM_TRX_SUPPORT */

#if defined(BCM_TRX_SUPPORT)
    /* For VFP on TRX devices and for ingress and Exact match stage
     * on TD2 and TH family devices, the checksum is 1-bit field and
       for all other devices, IpInfo field is 3 bit
     */
    BCM_IF_ERROR_RETURN(_field_entry_get(unit, entry,
                             _FP_ENTRY_PRIMARY, &f_ent));
    if ( ((SOC_IS_TRX(unit) &&
          (_BCM_FIELD_STAGE_LOOKUP == f_ent->group->stage_id)) ||
         ((SOC_IS_TD2_TT2(unit) &&
           ((_BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) ||
            (_BCM_FIELD_STAGE_EXACTMATCH == f_ent->group->stage_id)) ))) ){
        /* On Trident2 IP_INFO field is devided into two parts
         * IP_FRAG_INFO(2bits) and IP_CHECKSUM_OK(1bit). IP_FRAG_INFO
         * can be qualified using bcmFieldQualifyIpFrag and IP_CHECKSUM_OK
         * can be qualified using bcmFieldQualifyIpInfo.
         */
        if (*mask & 0x1) {
            *mask = BCM_FIELD_IP_CHECKSUM_OK;
        }
        *data = (*data & 0x1) ? BCM_FIELD_IP_CHECKSUM_OK : 0;
    }
#endif /* BCM_TRX_SUPPORT */

    return rv; 
}


int 
bcm_esw_field_qualify_PacketRes_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    int  rv;            /* Operation return status. */
    _field_control_t *fc = NULL;

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                           bcmFieldQualifyPacketRes,
                                           data, mask);
    BCM_IF_ERROR_RETURN(rv);

    FP_LOCK(unit);

    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    if (NULL == fc->functions.fp_qualify_packet_res_get) {
        FP_UNLOCK(unit);
        return BCM_E_CONFIG;
    }

    rv = fc->functions.fp_qualify_packet_res_get(unit, entry, data, mask);

    FP_UNLOCK(unit);
    return rv;  
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcIp_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                              bcmFieldQualifySrcIp,
                                              data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstIp_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                              bcmFieldQualifyDstIp,
                                              data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_Tos_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTos
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Tos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return  _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                             bcmFieldQualifyTos,
                                             data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DSCP_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDSCP
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DSCP_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return  _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                             bcmFieldQualifyDSCP,
                                             data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpFlags_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpFlags
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpFlags_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return  _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                             bcmFieldQualifyIpFlags,
                                             data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TcpControl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTcpControl
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TcpControl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return  _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                              bcmFieldQualifyTcpControl,
                                              data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TcpSequenceZero_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTcpSequenceZero
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      flag - (OUT) Qualifier match flags.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TcpSequenceZero_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *flag)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_TcpHeaderSize_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTcpHeaderSize
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TcpHeaderSize_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_Ttl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTtl
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Ttl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int              rv;

    
    FP_LOCK(unit);

#if defined(BCM_FIREBOLT2_SUPPORT)
    if (SOC_IS_FIREBOLT2(unit)) {
        rv =  _bcm_field_fb2_qualify_ttl_get(unit, entry, data, mask);     
    } else 
#endif /* BCM_FIREBOLT2_SUPPORT */
        
#if defined(BCM_RAPTOR_SUPPORT)
    if (SOC_IS_RAVEN(unit) || SOC_IS_HAWKEYE(unit)) {
        rv =  _bcm_field_raven_qualify_ttl_get(unit, entry, data, mask);     
    } else 
#endif /* BCM_RAPTOR_SUPPORT */
    {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                              bcmFieldQualifyTtl,
                                              data, mask);
    }
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_RangeCheck_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyRangeCheck
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      max_count - (IN) Max entries to fill.
 *      range - (OUT) Range checkers array.
 *      invert - (OUT) Range checkers invert array.
 *      count - (OUT) Number of filled range checkers.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_RangeCheck_get(
    int unit, 
    bcm_field_entry_t entry, 
    int max_count, 
    bcm_field_range_t *range, 
    int *invert, 
    int *count)
{
    _bcm_field_qual_offset_t *q_offset;
    _field_stage_t           *stage_fc;
    _field_entry_t           *f_ent;
    _bcm_field_qual_data_t   data;
    _bcm_field_qual_data_t   mask;
    _bcm_field_qual_data_t   data1;
    _bcm_field_qual_data_t   mask1;
    _field_range_t           *fr;
    int                      idx;
    int                      rv;
#ifdef BCM_TOMAHAWK_SUPPORT
    _range_t                *tmp = NULL;
#endif
    /* Input parameters check. */
    if (NULL == count) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    /* Get field entry part that contains qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, bcmFieldQualifyRangeCheck, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    if (NULL == f_ent->group) {
        FP_UNLOCK(unit);
        return (BCM_E_INTERNAL);
    }

    /* Get stage field control structure. */
    rv = _field_stage_control_get(unit, f_ent->group->stage_id, &stage_fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* Read qualifier match value and mask. */
       rv = _field_entry_qualifier_key_get(unit, entry,
                                           bcmFieldQualifyRangeCheck,
                                           data, mask);
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
       /* Get qualifier offsets in the tcam. */
       rv = _field_qual_offset_get(unit, f_ent, bcmFieldQualifyRangeCheck,
                                   &q_offset);
       if (BCM_FAILURE(rv)) {
           FP_UNLOCK(unit);
           return (rv);
       }

       /* Read qualifier match value and mask. */
       rv = _bcm_field_qual_value_get(unit, q_offset, f_ent, 
                                      data, mask);
       if (BCM_SUCCESS(rv) && BCM_FIELD_QSET_TEST(f_ent->group->qset,
                   _bcmFieldQualifyRangeCheckBits24_31)) {
           /* Get field entry part that contains qualifier. */
           rv = _bcm_field_entry_qual_get(unit, entry,
                   _bcmFieldQualifyRangeCheckBits24_31, &f_ent);
           if (BCM_FAILURE(rv)) {
               FP_UNLOCK(unit);
               return rv;
           }

           /* Get qualifier offsets in the tcam. */
           rv = _field_qual_offset_get(unit, f_ent, _bcmFieldQualifyRangeCheckBits24_31,
                   &q_offset);
           if (BCM_FAILURE(rv)) {
               FP_UNLOCK(unit);
               return (rv);
           }

           /* Read qualifier match value and mask. */
           rv = _bcm_field_qual_value_get(unit, q_offset, f_ent,
                   data1, mask1);
           if (BCM_FAILURE(rv)) {
               FP_UNLOCK(unit);
               return (rv);
           }
           data[0] |= (data1[0] & 0xff) << 24;
           mask[0] |= (mask1[0] & 0xff) << 24;
       }
    }

    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Fill range indexes. */
    idx = 0;
#ifdef BCM_TOMAHAWK_SUPPORT
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)
           && RANGE_CTRL(unit) &&
           (RANGE_CTRL(unit)->range_used_by_module ==
              RANGE_USED_BY_RANGE_MODULE)){
        for (tmp = RANGE_CTRL(unit)->ranges; tmp != NULL; tmp = tmp->next) {
            if (SHR_BITGET(mask, tmp->hw_index)) {
                if (idx >=  max_count) {
                    idx++;
                    continue;
                }
                if (NULL != range) {
                    range[idx] = tmp->rid;
                }
                if (NULL != invert) {
                    if (SHR_BITGET(data, tmp->hw_index)) {
                        invert[idx] = FALSE;
                    } else {
                       invert[idx] = TRUE;
                    }
                }
                idx++;
            }
        }
    } else
#endif
    {
        for (fr = stage_fc->ranges; fr != NULL; fr = fr->next) {
            if (mask[0] & (1 <<  fr->hw_index)) {
                if (idx >=  max_count) {
                    idx++;
                    continue;
                }
                if (NULL != range) {
                    range[idx] = fr->rid;
                }
                if (NULL != invert) {
                    if (data[0] & (1 << fr->hw_index)) {
                        invert[idx] = FALSE;
                    } else {
                        invert[idx] = TRUE;
                    }
               }
                idx++;
            }
        }
    }
    *count = idx;
    FP_UNLOCK(unit);
    return (BCM_E_NONE);
}


/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcIp6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return _field_qualify_ip6_get(unit, entry,
                                  bcmFieldQualifySrcIp6,
                                  data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstIp6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return _field_qualify_ip6_get(unit, entry,
                                  bcmFieldQualifyDstIp6, 
                                  data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcIp6High_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return _field_qualify_ip6_get(unit, entry,
                                  bcmFieldQualifySrcIp6High,
                                  data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6Low_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcIp6Low
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcIp6Low_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return _field_qualify_ip6_get(unit, entry,
                                  bcmFieldQualifySrcIp6Low,
                                  data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6Low_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstIp6Low
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstIp6Low_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return _field_qualify_ip6_get(unit, entry,
                                  bcmFieldQualifyDstIp6Low,
                                  data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstIp6High_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return _field_qualify_ip6_get(unit, entry,
                                  bcmFieldQualifyDstIp6High,
                                  data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_Ip6NextHeader_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIp6NextHeader
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Ip6NextHeader_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyIp6NextHeader,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_Ip6TrafficClass_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIp6TrafficClass
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Ip6TrafficClass_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyIp6TrafficClass,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerIp6FlowLabel_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerIp6FlowLabel
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerIp6FlowLabel_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                             bcmFieldQualifyInnerIp6FlowLabel,
                             data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_Ip6FlowLabel_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIp6FlowLabel
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Ip6FlowLabel_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                                 bcmFieldQualifyIp6FlowLabel,
                                                 data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_Ip6HopLimit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIp6HopLimit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Ip6HopLimit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return bcm_esw_field_qualify_Ttl_get(unit, entry, data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcMac_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
    return _field_qualify_macaddr_get(unit, entry,
                                      bcmFieldQualifySrcMac, 
                                      data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMac_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
    return _field_qualify_macaddr_get(unit, entry,
                                      bcmFieldQualifyDstMac, 
                                      data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerIpType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerIpType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Inner ip header ip type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerIpType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpType_t *type)
{
    _field_entry_t      *f_ent;  /* Field entry structure.   */
    _field_control_t    *fc;     /* Field control structure. */
    int                 rv;      /* Operation return status. */

    if (NULL == type) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = fc->functions.fp_qualify_ip_type_get(unit, entry, type, 
                                              bcmFieldQualifyInnerIpType);
   
    FP_UNLOCK(unit);

    return rv; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_ForwardingType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyForwardingType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Qualifier match forwarding type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ForwardingType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ForwardingType_t *type)
{
    int               rv;     /* Operation return structure. */
    uint32            data;   /* HW qualifier value.         */
    uint32            mask;   /* HW qualifier mask.          */
    _field_stage_id_t stage_id;

    /* Input parameters check. */
    if (NULL == type) {
        return (BCM_E_PARAM);
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) && 
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
        stage_id = _BCM_FIELD_STAGE_INGRESS;
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
       _field_entry_t *f_ent;

       /* Retrieve Field entry structure. */
       BCM_IF_ERROR_RETURN(_field_entry_get(unit, entry,
                               _FP_ENTRY_PRIMARY, &f_ent));

       stage_id = f_ent->group->stage_id;
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                             bcmFieldQualifyForwardingType,
                             &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    switch (stage_id) {    
    case _BCM_FIELD_STAGE_INGRESS:
    case _BCM_FIELD_STAGE_EXACTMATCH:
#if defined(BCM_TOMAHAWK_SUPPORT)
        if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
#if defined(BCM_TRIDENT3_SUPPORT)
            if(soc_feature(unit, soc_feature_td3_style_fp)) {
               return _bcm_field_td3_forwardingType_get(unit, stage_id, entry, 
                                                   data, mask, type);
            } else
#endif
#if defined(BCM_TOMAHAWK3_SUPPORT)
            if(soc_feature(unit, soc_feature_fp_no_dvp_support)) {
               return _bcm_field_th3_forwardingType_get(unit, stage_id, entry, 
                                                   data, mask, type);
            } else
#endif
            {
           return _bcm_field_th_forwardingType_get(unit, stage_id, entry, 
                                                   data, mask, type);
        }
        }
#endif /* BCM_TOMAHAWK_SUPPORT */ 
        if ((0 == data) && (mask == 0)) {
            *type = bcmFieldForwardingTypeAny;
        } else if ((0 == data) && (mask == 6)) {
            *type = bcmFieldForwardingTypeL2;
        } else if ((0 == data) && (mask == 7)) {
            *type = bcmFieldForwardingTypeL2Independent;
        } else if ((1 == data) && (mask == 7)) {
            *type = bcmFieldForwardingTypeL2Shared;
        } else if ((2 == data) && (mask == 7)) {
            *type =  bcmFieldForwardingTypeL2Vpn;
        } else if ((3 == data) && (mask == 7)) {
            *type = bcmFieldForwardingTypeL2VpnDirect;
        } else if ((4 == data) && (mask == 7)) {
            *type = bcmFieldForwardingTypeL3Direct;
        } else if ((5 == data) && (mask == 7)) {
            *type = bcmFieldForwardingTypeL3;
        } else if ((7 == data) && (mask == 7)) {
            *type = bcmFieldForwardingTypeMpls;
        } else {
            return (BCM_E_INTERNAL);
        }
        return (BCM_E_NONE);
        
    case _BCM_FIELD_STAGE_EXTERNAL:
        /* N.B.  Currently only supported for Triumph2 */
        
        if (mask == 0) {
            *type = bcmFieldForwardingTypeAny;
        } else if (data == 0) {
            *type = bcmFieldForwardingTypeL2;
        } else {
            *type = bcmFieldForwardingTypeL2Vpn;            
        }

        return (BCM_E_NONE);

    case _BCM_FIELD_STAGE_EGRESS:

#ifdef BCM_TRIUMPH3_SUPPORT

        if ((SOC_IS_KATANA2(unit)) || (SOC_IS_TRIUMPH3(unit)) ||
                (SOC_IS_TD2_TT2(unit))) {
            if ((0 == data) && (mask == 0)) {
                *type = bcmFieldForwardingTypeAny;
            } else if ((1 == data) && (mask == 3)) {
                *type = bcmFieldForwardingTypeL2Independent;
            } else if ((2 == data) && (mask == 3)) {
                *type =  bcmFieldForwardingTypeL2Vpn;
            } else if ((3 == data) && (mask == 3)) {
                *type = bcmFieldForwardingTypeL3;
            } else {
                return (BCM_E_INTERNAL);
            }
            return (BCM_E_NONE);
        }
#endif
        break;

#if defined(BCM_FLOWTRACKER_SUPPORT)
    case _BCM_FIELD_STAGE_FLOWTRACKER:
        if (soc_feature(unit, soc_feature_field_flowtracker_support)) {
            if ((0 == data) && (mask == 0)) {
                *type = bcmFieldForwardingTypeAny;
            } else if ((0 == data) && (3 == mask)) {
                *type = bcmFieldForwardingTypeL2Independent;
            } else if ((1 == data) && (3 == mask)) {
                *type = bcmFieldForwardingTypeL2Vpn;
            } else {
                return (BCM_E_INTERNAL);
            }
            return (BCM_E_NONE);
        }
#endif

    default:
        ;
    }

    return (BCM_E_INTERNAL);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Qualifier match ip type.
 * Returns: *      BCM_E_XXX * Notes: */
int 
bcm_esw_field_qualify_IpType_get(int unit, 
                                 bcm_field_entry_t entry, 
                                 bcm_field_IpType_t *type)
{
    _field_control_t    *fc;     /* Field control structure. */
    int                 rv;      /* Operation return status. */

    if (NULL == type) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = fc->functions.fp_qualify_ip_type_get(unit, entry, type,
                                              bcmFieldQualifyIpType);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2Format_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL2Format
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Qualifier match l2 format.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2Format_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_L2Format_t *type)
{
    int       rv;     /* Operation return structure. */
    uint32    data = 0;/* HW qualifier value.         */
    uint32    mask = 0;/* HW qualifier mask.          */

    /* Input parameters check. */
    if (NULL == type) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                             bcmFieldQualifyL2Format,
                             &data, &mask);
    if ((0 == data) && (mask == 0)) {
        *type = bcmFieldL2FormatAny;
    } else if ((0 == data) && (mask == 3)) {
        *type = bcmFieldL2FormatEthII;
    } else if ((1 == data) && (mask == 3)) {
        *type = bcmFieldL2FormatSnap;
    } else if ((2 == data) && (mask == 7)) {
        *type = bcmFieldL2FormatLlc;
    } else {
        return (BCM_E_INTERNAL);
    }
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_VlanFormat_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVlanFormat
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_VlanFormat_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int              rv;        /* Operation return status. */


    
    FP_LOCK(unit);

    rv = _field_qualify_VlanFormat_get(unit, entry, 
                                          bcmFieldQualifyVlanFormat,
                                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MHOpcode_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMHOpcode
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MHOpcode_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return  _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                             bcmFieldQualifyMHOpcode,
                             data, mask);
}

/*
 * Function:
 *     bcm_esw_field_qualify_Decap_get
 * Purpose:
 *     Get match criteria for bcmFieildQualifyDecap
 *     qualifier from the field entry.
 * Parameters:
 *     unit  - (IN) Unit number.
 *     entry - (IN) BCM field entry id.
 *     decap - (OUT) Qualifier Decap type.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_Decap_get(int unit, bcm_field_entry_t entry,
                                bcm_field_decap_t *decap)
{
    int rv = BCM_E_UNAVAIL;
#ifdef BCM_GREYHOUND2_SUPPORT
    uint8 data = 0;  /* Installed entry value */
    uint8 mask = 0;  /* Installed entry mask */

    if (soc_feature(unit, soc_feature_vxlan_lite_riot)) {
        /* Input parameters check. */
        if (NULL == decap) {
            return BCM_E_PARAM;
        }

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                  bcmFieldQualifyDecap,
                                                  &data, &mask);
        BCM_IF_ERROR_RETURN(rv);

        if (data == 0) {
            *decap = bcmFieldDecapNone;
        } else if (data == 0x1 && mask == 0x1) {
            *decap = bcmFieldDecapVxlan;
        } else {
            return BCM_E_INTERNAL;
        }
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGig_get
 * Purpose:
 *      Qualify on HiGig packets.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_HiGig_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    _field_entry_t   *f_ent;  /* Field entry structure.   */
    int rv = BCM_E_UNAVAIL;   /* Operation return status. */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    if (SOC_IS_TRX(unit)) {
        /* Read qualifier match value and mask. */
        return  _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                     bcmFieldQualifyHiGig,
                                                     data, mask);
    } else if (SOC_IS_FBX(unit)) {
        
        FP_LOCK(unit);

        rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);

        FP_UNLOCK(unit);
        BCM_IF_ERROR_RETURN(rv);

        /* Add data & mask to entry. */
        *data = f_ent->tcam.higig;
        *mask = f_ent->tcam.higig_mask;
    }
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InterfaceClassPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInterfaceClassPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InterfaceClassPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                                                              entry, 
                                                              bcmFieldQualifyInterfaceClassPort,
                                                              data,
                                                              mask
                                                              )
                        );

    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InterfaceClassVPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInterfaceClassVPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_InterfaceClassVPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                                                              entry,
                                                              bcmFieldQualifyInterfaceClassVPort,
                                                              data,
                                                              mask
                                                              )
                        );

    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressInterfaceClassVPort
 * Purpose:
 *      Set match criteria for bcmFieildQualifyIngressInterfaceClassVPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressInterfaceClassVPort(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int                    rv;


#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class(unit, entry,
                                      bcmFieldQualifyIngressInterfaceClassVPort,
                                      &data, &mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyIngressInterfaceClassVPort,
                                          &data,
                                          &mask
                                          )
            );
    } else
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_tr3_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyIngressInterfaceClassVPort,
                                          &data,
                                          &mask
                                          )
            );
    } else
#endif
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyIngressInterfaceClassVPort,
                                          &data,
                                          &mask
                                          ));
    } else 
#endif /* BCM_KATANA2_SUPPORT */
    {
        /* Input parameters check. */
        if (data > SOC_ADDR_CLASS_MAX(unit)) {
            return (BCM_E_PARAM);
        }
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIngressInterfaceClassVPort,
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);

}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressInterfaceClassVPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIngressInterfaceClassVPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressInterfaceClassVPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    /*Read qualifier and match value and mask */

    BCM_IF_ERROR_RETURN
        (_bcm_field_entry_qualifier_uint32_get(unit,
                                               entry,
                                               bcmFieldQualifyIngressInterfaceClassVPort,
                                               data,
                                               mask)
        );

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class_get(unit, entry,
                                      bcmFieldQualifyIngressInterfaceClassVPort,
                                      data, mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
     if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
         BCM_IF_ERROR_RETURN
             (_bcm_field_td2_qualify_class_get(unit,
                                               entry,
                                               bcmFieldQualifyIngressInterfaceClassVPort,
                                               data,
                                               mask)
             );
        return (BCM_E_NONE);

     } else
#endif
#if defined BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)){
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyIngressInterfaceClassVPort,
                                              data,
                                              mask
                                             )
            );
        return (BCM_E_NONE);
    } else
#endif

#ifdef BCM_TRIUMPH3_SUPPORT
     if (SOC_IS_TRIUMPH3(unit)) {
         BCM_IF_ERROR_RETURN
             (_bcm_field_tr3_qualify_class_get(unit,
                                               entry,
                                               bcmFieldQualifyIngressInterfaceClassVPort,
                                               data,
                                               mask)
             );
         return (BCM_E_NONE);

     }
#endif
     return (BCM_E_NONE);

}

/*
 * Function:
 *      bcm_esw_field_qualify_InterfaceClassL2_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInterfaceClassL2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InterfaceClassL2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                                                              entry, 
                                                              bcmFieldQualifyInterfaceClassL2,
                                                              data,
                                                              mask
                                                              )
                        );
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class_get(unit, entry,
                                           bcmFieldQualifyInterfaceClassL2,
                                           data, mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyInterfaceClassL2,
                                              data,
                                              mask
                                              )
            );
        return (BCM_E_NONE);
    }
#endif
#if defined BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)){
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyInterfaceClassL2,
                                              data,
                                              mask
                                             )
            );
        return (BCM_E_NONE);
    }
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class_get(unit,
                                                             entry,
                                                             bcmFieldQualifyInterfaceClassL2,
                                                             data,
                                                             mask
                                                             )
                            );
    }
#endif
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InterfaceClassL3_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInterfaceClassL3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InterfaceClassL3_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                                                              entry, 
                                                              bcmFieldQualifyInterfaceClassL3,
                                                              data,
                                                              mask
                                                              )
                        );
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class_get(unit, entry,
                                           bcmFieldQualifyInterfaceClassL3,
                                           data, mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyInterfaceClassL3,
                                              data,
                                              mask
                                              )
            );
        return (BCM_E_NONE);
    }
#endif
#if defined BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)){
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyInterfaceClassL3,
                                              data,
                                              mask
                                             )
            );
        return (BCM_E_NONE);
    }
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class_get(unit,
                                                             entry,
                                                             bcmFieldQualifyInterfaceClassL3,
                                                             data,
                                                             mask
                                                             )
                            );
    }
#endif
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcClassL2_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcClassL2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcClassL2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                                                              entry, 
                                                              bcmFieldQualifySrcClassL2,
                                                              data,
                                                              mask
                                                              )
                        );

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class_get(unit, entry,
                                           bcmFieldQualifySrcClassL2,
                                           data, mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifySrcClassL2,
                                              data,
                                              mask
                                              )
            );
        return (BCM_E_NONE);
    }
#endif
#if defined BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)){
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifySrcClassL2,
                                              data,
                                              mask
                                             )
            );
        return (BCM_E_NONE);
    }
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class_get(unit,
                                                             entry,
                                                             bcmFieldQualifySrcClassL2,
                                                             data,
                                                             mask
                                                             )
                            );
    }
#endif
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcClassL3_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcClassL3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcClassL3_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                                                              entry, 
                                                              bcmFieldQualifySrcClassL3,
                                                              data,
                                                              mask
                                                              )
                        );

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class_get(unit, entry,
                                           bcmFieldQualifySrcClassL3,
                                           data, mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifySrcClassL3,
                                              data,
                                              mask
                                              )
            );
        return (BCM_E_NONE);
    }
#endif
#if defined BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)){
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifySrcClassL3,
                                              data,
                                              mask
                                             )
            );
        return (BCM_E_NONE);
    }
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class_get(unit,
                                                             entry,
                                                             bcmFieldQualifySrcClassL3,
                                                             data,
                                                             mask
                                                             )
                            );
    }
#endif
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcCompressionClassId_get
 * Purpose:
 *      Get match criteria for SrcCompressionClassId
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcCompressionClassId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    if (!soc_feature(unit, soc_feature_field_aacl_compression)) {
        return BCM_E_UNAVAIL;
    }

    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifySrcCompressionClassId,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcCompressionClassId
 * Purpose:
 *      Set match criteria for SrcCompressionClassId
 *                     qualifier for the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcCompressionClassId(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

    if (!soc_feature(unit, soc_feature_field_aacl_compression)) {
        return rv;
    }

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, bcmFieldQualifySrcCompressionClassId,
                          data, mask);
    FP_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstCompressionClassId_get
 * Purpose:
 *      Get match criteria for DstCompressionClassId
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstCompressionClassId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    if (!soc_feature(unit, soc_feature_field_aacl_compression)) {
        return BCM_E_UNAVAIL;
    }

    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyDstCompressionClassId,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstCompressionClassId
 * Purpose:
 *      Set match criteria for DstCompressionClassId
 *                     qualifier for the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstCompressionClassId(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

    if (!soc_feature(unit, soc_feature_field_aacl_compression)) {
        return rv;
    }

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstCompressionClassId,
                          data, mask);
    FP_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcClassField_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcClassField
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcClassField_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                                                              entry, 
                                                              bcmFieldQualifySrcClassField,
                                                              data,
                                                              mask
                                                              )
                        );

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class_get(unit, entry,
                                           bcmFieldQualifySrcClassField,
                                           data, mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifySrcClassField,
                                              data,
                                              mask
                                              )
            );
        return (BCM_E_NONE);
    }
#endif
#if defined BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)){
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifySrcClassField,
                                              data,
                                              mask
                                             )
            );
        return (BCM_E_NONE);
    }
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class_get(unit,
                                                             entry,
                                                             bcmFieldQualifySrcClassField,
                                                             data,
                                                             mask
                                                             )
                            );
    }
#endif
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstClassL2_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstClassL2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstClassL2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                                                              entry, 
                                                              bcmFieldQualifyDstClassL2,
                                                              data,
                                                              mask
                                                              )
                        );

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class_get(unit, entry,
                                           bcmFieldQualifyDstClassL2,
                                           data, mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyDstClassL2,
                                              data,
                                              mask
                                              )
            );
        return (BCM_E_NONE);
    }
#endif
#if defined BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)){
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyDstClassL2,
                                              data,
                                              mask
                                             )
            );
        return (BCM_E_NONE);
    }
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class_get(unit,
                                                             entry,
                                                             bcmFieldQualifyDstClassL2,
                                                             data,
                                                             mask
                                                             )
                            );
    }
#endif
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstClassL3_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstClassL3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstClassL3_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                                                              entry, 
                                                              bcmFieldQualifyDstClassL3,
                                                              data,
                                                              mask
                                                              )
                        );

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class_get(unit, entry,
                                           bcmFieldQualifyDstClassL3,
                                           data, mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyDstClassL3,
                                              data,
                                              mask
                                              )
            );
        return (BCM_E_NONE);
    }
#endif
#if defined BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)){
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyDstClassL3,
                                              data,
                                              mask
                                             )
            );
        return (BCM_E_NONE);
    }
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class_get(unit,
                                                             entry,
                                                             bcmFieldQualifyDstClassL3,
                                                             data,
                                                             mask
                                                             )
                            );
    }
#endif
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstClassField_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstClassField
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstClassField_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                                                              entry, 
                                                              bcmFieldQualifyDstClassField,
                                                              data,
                                                              mask
                                                              )
                        );

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class_get(unit, entry,
                                           bcmFieldQualifyDstClassField,
                                           data, mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyDstClassField,
                                              data,
                                              mask
                                              )
            );
        return (BCM_E_NONE);
    }
#endif
#if defined BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)){
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyDstClassField,
                                              data,
                                              mask
                                             )
            );
        return (BCM_E_NONE);
    }
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class_get(unit,
                                                             entry,
                                                             bcmFieldQualifyDstClassField,
                                                             data,
                                                             mask
                                                             )
                            );
    }
#endif
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpProtocolCommon_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpProtocolCommon
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      protocol - (OUT) Qualifier protocol encoding.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpProtocolCommon_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpProtocolCommon_t *protocol)
{
    return _field_qualify_IpProtocolCommon_get(unit, entry, 
                                    bcmFieldQualifyIpProtocolCommon,
                                    protocol);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerIpProtocolCommon_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerIpProtocolCommon
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      protocol - (OUT) Qualifier inner ip protocol encodnig.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerIpProtocolCommon_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpProtocolCommon_t *protocol)
{
    return _field_qualify_IpProtocolCommon_get(unit, entry, 
                                    bcmFieldQualifyInnerIpProtocolCommon,
                                    protocol);
}

/*
 * Function:
 *      bcm_esw_field_qualify_Snap_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySnap
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Snap_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_snap_header_t *data, 
    bcm_field_snap_header_t *mask)
{
    _bcm_field_qual_offset_t *q_offset;
    _field_entry_t           *f_ent;
    uint32                   ref_data[_FP_QUAL_DATA_WORDS];
    uint32                   ref_mask[_FP_QUAL_DATA_WORDS];
    int                      rv;

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    /* Initialization. */
    sal_memset(ref_data, 0, _FP_QUAL_DATA_WORDS * sizeof(uint32));
    sal_memset(ref_mask, 0, _FP_QUAL_DATA_WORDS * sizeof(uint32));

    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry, 
                                   bcmFieldQualifySnap, &f_ent);
    BCM_IF_ERROR_RETURN(rv);
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* Read qualifier match value and mask. */
       rv = _field_entry_qualifier_key_get(unit, entry, bcmFieldQualifySnap,
                                        ref_data, ref_mask);
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
    {
      /* Get qualifier offsets in the tcam. */
      rv = _field_qual_offset_get(unit, f_ent, 
                                  bcmFieldQualifySnap, &q_offset);
      BCM_IF_ERROR_RETURN(rv);

      /* Read qualifier match value and mask. */
      rv = _bcm_field_qual_value_get(unit, q_offset, f_ent, 
                                     ref_data, ref_mask);
    }
    BCM_IF_ERROR_RETURN(rv);

    data->org_code = (ref_data[1] << 16) | (ref_data[0] >> 16);
    data->type = ref_data[0] & 0xffff;

    mask->org_code = (ref_mask[1] << 16) | (ref_mask[0] >> 16);
    mask->type = ref_mask[0] & 0xffff;

    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_Llc_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyLlc
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Llc_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_llc_header_t *data, 
    bcm_field_llc_header_t *mask)
{
    uint32    hw_data = 0;       /* HW buffer data.             */
    uint32    hw_mask = 0;       /* HW buffer mask.             */
    int       rv;                /* Operation return stauts.    */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                               bcmFieldQualifyLlc,
                                               &hw_data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);

    data->dsap    = (hw_data>> 16) & 0xff;
    data->ssap    = (hw_data >> 8)  & 0xff;
    data->control = hw_data & 0xff;

    mask->dsap    = (hw_mask >> 16) & 0xff;
    mask->ssap    = (hw_mask >> 8)  & 0xff;
    mask->control = hw_mask & 0xff;

    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerTpid_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerTpid
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      tpid - (OUT) Qualifier tpid.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerTpid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *tpid)
{
    uint32    hw_data = 0;       /* HW buffer data.             */
    uint32    hw_mask = 0;       /* HW buffer mask.             */
    int       rv;                /* Operation return stauts.    */

    /* Input parameters check. */
    if (NULL == tpid) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                               bcmFieldQualifyInnerTpid,
                                               &hw_data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);

    if (hw_mask == 0) {
        return BCM_E_NOT_FOUND;
    }
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        rv = _bcm_field_td3_tpid_hw_decode(unit, hw_data, 0, tpid);
    } else
#endif
    {
    rv = _field_tpid_hw_decode(unit, hw_data, tpid);
    }
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OuterTpid_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyOuterTpid
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      tpid - (OUT) Qualifier tpid.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterTpid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *tpid)
{
    uint32    hw_data = 0;       /* HW buffer data.             */
    uint32    hw_mask = 0;       /* HW buffer mask.             */
    int       rv;                /* Operation return stauts.    */

    /* Input parameters check. */
    if (NULL == tpid) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                               bcmFieldQualifyOuterTpid,
                                               &hw_data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);

    if (hw_mask == 0) {
        return BCM_E_NOT_FOUND;
    }
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        rv = _bcm_field_td3_tpid_hw_decode(unit, hw_data, 1, tpid);
    } else
#endif
    {
    rv = _field_tpid_hw_decode(unit, hw_data, tpid);
    }
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L3Routable_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL3Routable
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L3Routable_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                bcmFieldQualifyL3Routable,
                                                data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpFrag_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpFrag
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      frag_info - (OUT) Qualifier ip framentation encoding.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpFrag_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpFrag_t *frag_info)
{
    int             rv = BCM_E_UNAVAIL;
#if defined(BCM_FIREBOLT2_SUPPORT) || defined(BCM_TRX_SUPPORT) \
    || defined(BCM_RAPTOR_SUPPORT)

    
    FP_LOCK(unit);

    if (SOC_IS_FIREBOLT2(unit) || SOC_IS_TRX(unit) || 
        SOC_IS_RAVEN(unit) || SOC_IS_HAWKEYE(unit)) {
        rv = _field_qualify_IpFrag_get(unit, entry, 
                                       bcmFieldQualifyIpFrag, 
                                       frag_info);
    }
    FP_UNLOCK(unit);
#endif /* BCM_FIREBOLT2_SUPPORT || BCM_TRX_SUPPORT || BCM_RAPTOR_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_Vrf_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVrf
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Vrf_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                                 bcmFieldQualifyVrf,
                                                 data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L3Ingress_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL3Ingress
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L3Ingress_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                                 bcmFieldQualifyL3Ingress,
                                                 data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_ExtensionHeaderType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyExtensionHeaderType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ExtensionHeaderType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyExtensionHeaderType,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_ExtensionHeaderSubCode_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyExtensionHeaderSubCode
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ExtensionHeaderSubCode_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyExtensionHeaderSubCode,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_ExtensionHeader2Type_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyExtensionHeader2Type
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ExtensionHeader2Type_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyExtensionHeader2Type,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L4Ports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL4Ports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L4Ports_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyL4Ports,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MirrorCopy_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMirrorCopy
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MirrorCopy_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyMirrorCopy,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelTerminated_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelTerminated
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TunnelTerminated_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyTunnelTerminated,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MplsTerminated_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMplsTerminated
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MplsTerminated_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    _field_group_t *fg;         /* Field group structure        */
    int i = 0;                  /* Entry parts                  */
    int rv = BCM_E_INTERNAL;    /* Operation return stauts.     */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask))  {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                    bcmFieldQualifyMplsTerminated,
                                    data, mask);
    BCM_IF_ERROR_RETURN(rv);
    if (SOC_IS_TRIUMPH2(unit) || SOC_IS_KATANAX(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));
        for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
            if ((int8) bcmFieldTunnelTypeMpls
                    == fg->sel_codes[i].loopback_type_sel) {
                if ((uint8) bcmFieldTunnelTypeMpls == (*data & *mask)) {
                    *data = 0x1;
                    *mask = 0x1;
                }
                break;
            }
        }
    }
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerSrcIp_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerSrcIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerSrcIp_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                              bcmFieldQualifyInnerSrcIp,
                                              data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerDstIp_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerDstIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerDstIp_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                                  bcmFieldQualifyInnerDstIp,
                                                  data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerSrcIp6_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerSrcIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerSrcIp6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return _field_qualify_ip6_get(unit, entry,
                                  bcmFieldQualifyInnerSrcIp6,
                                  data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerDstIp6_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerDstIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerDstIp6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return _field_qualify_ip6_get(unit, entry,
                                  bcmFieldQualifyInnerDstIp6, 
                                  data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerSrcIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerSrcIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerSrcIp6High_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return _field_qualify_ip6_get(unit, entry,
                                  bcmFieldQualifyInnerSrcIp6High,
                                  data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerDstIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerDstIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerDstIp6High_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return _field_qualify_ip6_get(unit, entry,
                                  bcmFieldQualifyInnerDstIp6High,
                                  data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMultipath
 * Purpose:
 *     Add a multipath egress object field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      mpintf - (IN) Multipath egress object id. 
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMultipath(int               unit, 
                                   bcm_field_entry_t entry, 
                                   bcm_if_t          mpintf
                                   )
{
    int rv = BCM_E_UNAVAIL;   /* Operation return status. */

#if defined(INCLUDE_L3)
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    uint32 flags;           /* L3 forwarding flags      */
    int nh_ecmp_id;         /* Next hop/Ecmp group id.  */

    /* Get next hop id. */
    rv = bcm_xgs3_l3_egress_id_parse(unit, mpintf, &flags, &nh_ecmp_id);
    BCM_IF_ERROR_RETURN(rv);

    if (!(flags & BCM_L3_MULTIPATH)) {
        return (BCM_E_UNAVAIL);
    }

    data = nh_ecmp_id;
    mask = (BCM_FIELD_EXACT_MATCH_MASK);

    /*
     * Invoke driver function for multi pipe devices.
     */ 
    
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
        if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
            /*Error fetching entry*/
            return (rv); 
        }
        if (rv == BCM_E_NONE) { /*Stage is Ingress*/ 
            /* Trunk bit has to be set for this qualifier */
            data = data | (1 << 16);

            FP_LOCK(unit);
            rv = _field_control_get(unit, &fc);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return rv;
            }
            rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstMultipath,
                                          data, mask, 0);
            FP_UNLOCK(unit);
            return (rv);
        }
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    BCM_IF_ERROR_RETURN(_field_dest_type_qualify(unit,
                        entry, bcmFieldQualifyDstMultipath, &data, &mask, 
                        _bcmFieldDestTypeNone));

    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstMultipath, 
                          data, mask);

    FP_UNLOCK(unit);
#endif /* INCLUDE_L3 */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMultipath_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMultipath
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mpintf - (OUT) Multipath egress object id. 
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstMultipath_get(int               unit,
                                       bcm_field_entry_t entry, 
                                       bcm_if_t          *mpintf
                                       )
{
    int               rv = BCM_E_UNAVAIL;  /* Operation return status. */
#if defined(INCLUDE_L3)
    uint32            data; /* HW data match criteria.  */
    uint32            mask; /* HW data mask.            */

    /* Input parameters check. */
    if (NULL == mpintf) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                           bcmFieldQualifyDstMultipath,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
        entry, bcmFieldQualifyDstMultipath, &data, &mask));

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
        if (BCM_SUCCESS(rv)) {
            data = data & ~(1 << 16);
        }
    }
#endif

    *mpintf = data + BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit);
#endif /* INCLUDE_L3 */
    return (rv);
}
/*
 * Function:
 *      bcm_esw_field_qualify_DstMultipathOverlay
 * Purpose:
 *      Set match criteria for bcmFieildQualifyDstMultipathOverlay
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) ECMP interface(s) with overlay flag
 *      mask  - (IN) corresponding mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMultipathOverlay(int unit, bcm_field_entry_t entry,
                                          bcm_if_t data, bcm_if_t mask) {

    int rv = BCM_E_UNAVAIL;
#if defined(INCLUDE_L3) && defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
    uint32 qual_data = 0;   /* HW data match criteria.  */
    uint32 qual_mask = 0;   /* HW data mask.            */
    uint32 tbl_size = 0;    /* ECMP table size to find number of entries */
    int grp_id = 0, idx = 0; /* group index and loop variable */
    uint32 flags;           /* L3 forwarding flags      */
    int nh_ecmp_id;         /* Next hop/Ecmp group id.  */

    if (!soc_feature(unit, soc_feature_hierarchical_ecmp) &&
        !soc_feature(unit, soc_feature_multi_level_ecmp)) {
        return rv;
    }

    

    if (mask == BCM_FIELD_EXACT_MATCH_MASK) {
        /* Get next hop id. */
        rv = bcm_xgs3_l3_egress_id_parse(unit, data, &flags, &nh_ecmp_id);
        BCM_IF_ERROR_RETURN(rv);

        if (!(flags & BCM_L3_MULTIPATH)) {
            return (BCM_E_PARAM);
        }
        if (!(BCM_XGS3_L3_ECMP_GROUP_FLAGS_ISSET(unit,
                                           data-BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit),
                                           BCM_L3_ECMP_OVERLAY))) {
            return BCM_E_PARAM;
        }
        qual_data = nh_ecmp_id;
        qual_mask = (uint32) mask;

    } else {
        /* Iterate through all groups and assert that groups which qualify have
           overlay and multipath flags */
        if (mask > 0x7ff) {
            return BCM_E_PARAM;
        }
        qual_data = (data & mask);
        tbl_size = soc_mem_index_count(unit, INITIAL_L3_ECMP_GROUPm);
        for (idx = 0; idx < tbl_size; idx++) {
             grp_id = BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit) + idx;
             if (qual_data == (grp_id & mask)) {
                 rv = bcm_xgs3_l3_egress_id_parse(unit, grp_id, &flags,
                                                  &nh_ecmp_id);
                 BCM_IF_ERROR_RETURN(rv);

                 if (!(flags & BCM_L3_MULTIPATH)) {
                     return (BCM_E_PARAM);
                 }
                 if (!(BCM_XGS3_L3_ECMP_GROUP_FLAGS_ISSET(unit, idx,
                                                  BCM_L3_ECMP_OVERLAY))) {
                     return BCM_E_PARAM;
                 }
            }
        }
        qual_data = data - BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit);
        qual_mask = mask;
    }

    rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                         _BCM_FIELD_STAGE_INGRESS);

    if (rv == BCM_E_NONE) { /*Stage is Ingress*/
        /* Trunk bit has to be set for this qualifier */
        qual_data = qual_data | (1 << 16);
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstMultipathOverlay,
                                          qual_data, qual_mask, 0);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* INCLUDE_L3 && BCM_TOMAHAWK_SUPPORT */
    return rv;
}
/*
 * Function:
 *      bcm_esw_field_qualify_DstMultipathOverlay_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMultipathOverlay
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (OUT) ECMP interface(s) with overlay flag
 *      mask  - (OUT) corresponding mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMultipathOverlay_get(int unit, bcm_field_entry_t entry,
                                             bcm_if_t *data, bcm_if_t *mask) {
    int               rv = BCM_E_UNAVAIL;  /* Operation return status. */
#if defined(INCLUDE_L3)
    uint32            qual_data; /* HW data match criteria.  */
    uint32            qual_mask; /* HW data mask.            */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifyDstMultipathOverlay,
                                           &qual_data, &qual_mask);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
        if (BCM_SUCCESS(rv)) {
            qual_data = qual_data & ~(1 << 16);
        }
    }
#endif

    *data = qual_data + BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit);
    *mask = qual_mask;
#endif /* INCLUDE_L3 */
    return (rv);

}
/*
 * Function:
 *      bcm_esw_field_qualify_DstMultipathUnderlay
 * Purpose:
 *      Set match criteria for bcmFieildQualifyDstMultipathUnderlay
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) ECMP interface(s) with Underlay flag
 *      mask  - (IN) corresponding mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMultipathUnderlay(int unit, bcm_field_entry_t entry,
                                         bcm_if_t data, bcm_if_t mask) {
    int rv = BCM_E_UNAVAIL;
#if defined(INCLUDE_L3) && defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
    uint32 qual_data = 0;   /* HW data match criteria.  */
    uint32 qual_mask = 0;   /* HW data mask.            */
    uint32 tbl_size = 0;    /* ECMP table size to find number of entries */
    int grp_id = 0, idx = 0; /* group index and loop variable */
    uint32 flags;           /* L3 forwarding flags      */
    int nh_ecmp_id;         /* Next hop/Ecmp group id.  */

    if (!soc_feature(unit, soc_feature_hierarchical_ecmp) &&
        !soc_feature(unit, soc_feature_multi_level_ecmp)) {
        return rv;
    }

    

    if (mask == BCM_FIELD_EXACT_MATCH_MASK) {
        /* Get next hop id. */
        rv = bcm_xgs3_l3_egress_id_parse(unit, data, &flags, &nh_ecmp_id);
        BCM_IF_ERROR_RETURN(rv);

        if (!(flags & BCM_L3_MULTIPATH)) {
            return (BCM_E_PARAM);
        }
        if (!(BCM_XGS3_L3_ECMP_GROUP_FLAGS_ISSET(unit,
                data-BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit),
                BCM_L3_ECMP_UNDERLAY))) {

            return BCM_E_PARAM;
        }
        qual_data = nh_ecmp_id;
        qual_mask = (uint32) mask;

    } else {
        /* Iterate through all groups and assert that groups which qualify have
           overlay and multipath flags */
        if (mask > 0x7ff) {
            return BCM_E_PARAM;
        }
        qual_data = (data & mask);
        tbl_size = soc_mem_index_count(unit, INITIAL_L3_ECMP_GROUPm);
        for (idx = 0; idx < tbl_size; idx++) {
             grp_id = BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit) + idx;
             if (qual_data == (grp_id & mask)) {
                 rv = bcm_xgs3_l3_egress_id_parse(unit, grp_id, &flags,
                                                  &nh_ecmp_id);
                 BCM_IF_ERROR_RETURN(rv);

                 if (!(flags & BCM_L3_MULTIPATH)) {
                     return (BCM_E_PARAM);
                 }
                 if (!(BCM_XGS3_L3_ECMP_GROUP_FLAGS_ISSET(unit, idx,
                                                  BCM_L3_ECMP_UNDERLAY))) {
                     return BCM_E_PARAM;
                 }
            }
        }
        qual_data = data - BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit);
        qual_mask = mask;
    }

    rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                         _BCM_FIELD_STAGE_INGRESS);

    if (rv == BCM_E_NONE) { /*Stage is Ingress*/
        /* Trunk bit has to be set for this qualifier */
        qual_data = qual_data | (1 << 16);
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstMultipathUnderlay,
                                          qual_data, qual_mask, 0);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* INCLUDE_L3 && BCM_TOMAHAWK_SUPPORT */
    return rv;
}
 /*
 * Function:
 *      bcm_esw_field_qualify_DstMultipathUnderlay_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMultipathUnderlay
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (OUT) ECMP interface(s) with Underlay flag
 *      mask  - (OUT) corresponding mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMultipathUnderlay_get(int unit, bcm_field_entry_t entry,
                                               bcm_if_t *data, bcm_if_t *mask) {
    int               rv = BCM_E_UNAVAIL;  /* Operation return status. */
#if defined(INCLUDE_L3)
    uint32            qual_data = 0; /* HW data match criteria.  */
    uint32            qual_mask = 0; /* HW data mask.            */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask))  {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifyDstMultipathUnderlay,
                                           &qual_data, &qual_mask);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
        if (BCM_SUCCESS(rv)) {
            qual_data = qual_data & ~(1 << 16);
        }
    }
#endif

    *data = qual_data + BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit);
    *mask = qual_mask;
#endif /* INCLUDE_L3 */
    return (rv);

}
/*
 * Function:
 *      bcm_esw_field_qualify_InnerTtl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerTtl
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerTtl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyInnerTtl,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerTos_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerDSCP
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerTos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyInnerTos,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerDSCP_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerDSCP
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerDSCP_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyInnerDSCP,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerIpProtocol_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerIpProtocol
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerIpProtocol_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyInnerIpProtocol,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerIp6HopLimit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerIp6HopLimit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerIp6HopLimit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyInnerIp6HopLimit,
                                   data, mask);
}


/*
 * Function:
 *      bcm_esw_field_qualify_InnerIp6NextHeader_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerIp6NextHeader
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerIp6NextHeader_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyInnerIp6NextHeader,
                                   data, mask);
}


/*
 * Function:
 *      bcm_esw_field_qualify_InnerIpFrag_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerIpFrag
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      frag_info - (OUT) Inner ip header fragmentation info.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerIpFrag_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpFrag_t *frag_info)
{
    int             rv = BCM_E_UNAVAIL;
#if  defined(BCM_TRX_SUPPORT) 

    
    FP_LOCK(unit);

    if (SOC_IS_TRX(unit)) {
        rv = _field_qualify_IpFrag_get(unit, entry, 
                                       bcmFieldQualifyInnerIpFrag,
                                       frag_info);
    }
    FP_UNLOCK(unit);
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DosAttack_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDosAttack
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DosAttack_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyDosAttack,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpmcStarGroupHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpmcStarGroupHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpmcStarGroupHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyIpmcStarGroupHit,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MyStationHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMyStationHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MyStationHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyMyStationHit,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2PayloadFirstEightBytes_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL2PayloadFirstEightBytes
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data1 - (OUT) Qualifier first four bytes of match data.
 *      data2 - (OUT) Qualifier last four bytes of match data.
 *      mask1 - (OUT) Qualifier first four bytes of match mask.
 *      mask2 - (OUT) Qualifier last four bytes of match mask.
 *
 * Note: Values returned in data1 and data2 are in actual packet data format
 *       order.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2PayloadFirstEightBytes_get(int unit, 
                                                   bcm_field_entry_t entry,
                                                   uint32 *data1, uint32 *data2,
                                                   uint32 *mask1, uint32 *mask2)
{
    int rv;

    /* Input parameters check. */
    if ((NULL == data1) || (NULL == data2) ||
        (NULL == mask1) || (NULL == mask2)) {
        return (BCM_E_PARAM);
    }

    rv = _field_qualify_L2PayloadFirstEightBytes_get(unit, entry, 
            bcmFieldQualifyL2PayloadFirstEightBytes, data1, data2, mask1, mask2);

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_L3DestRouteHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL3DestRouteHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L3DestRouteHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyL3DestRouteHit,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L3DestHostHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL3DestHostHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L3DestHostHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyL3DestHostHit,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L3SrcHostHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL3SrcHostHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L3SrcHostHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyL3SrcHostHit,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2CacheHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL2CacheHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2CacheHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyL2CacheHit,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2StationMove_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL2StationMove
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2StationMove_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyL2StationMove,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2DestHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL2DestHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2DestHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyL2DestHit,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2SrcStatic_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL2SrcStatic
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2SrcStatic_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyL2SrcStatic,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2SrcHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL2SrcHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2SrcHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyL2SrcHit,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressStpState_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIngressStpState
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IngressStpState_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    uint32    hw_data = 0;       /* HW buffer data.             */
    uint32    hw_mask = 0;       /* HW buffer mask.             */
    int       rv;                /* Operation return stauts.    */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                               bcmFieldQualifyIngressStpState,
                                               &hw_data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);

    switch (hw_data & hw_mask) {
      case 0: 
          *data = BCM_STG_STP_DISABLE;
          break;
      case 1: 
          *data = BCM_STG_STP_BLOCK;
          break;
      case 2: 
          *data = BCM_STG_STP_LEARN;
          break;
      case 3: 
          *data = BCM_STG_STP_FORWARD;
          break;
      default:
          return (BCM_E_INTERNAL);
    }
    *mask = (0 == hw_mask) ? 0 : 0xff;
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_ForwardingVlanValid_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyForwardingVlanValid
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ForwardingVlanValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyForwardingVlanValid,
                                   data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcVirtualPortValid_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcVirtualPortValid
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcVirtualPortValid_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                    bcmFieldQualifySrcVirtualPortValid,
                                    data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstL3EgressNextHops_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstL3EgressNextHops
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstL3EgressNextHops_get(int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#if defined(INCLUDE_L3)
    int i, size_bit_len = 0;

    /* Check if L3 feature is supported on the device */
    if (!soc_feature(unit, soc_feature_l3)) {
        return (rv);
    }

    /*  Make sure module was initialized. */
    if (!BCM_XGS3_L3_INITIALIZED(unit)) {
        return (rv);
    }

    /* Read qualifier match value and mask. */ 
    rv =  _bcm_field_entry_qualifier_uint32_get(unit, entry,
                bcmFieldQualifyDstL3EgressNextHops,
                data, mask);
    BCM_IF_ERROR_RETURN(rv);


    /* Retrieve the mask value according to the table size */
    for (i = 0; i < 32; i++) {
        if (BCM_XGS3_L3_NH_TBL_SIZE(unit) <= (1 << i)) {
            size_bit_len = i;
            break;
        }
    }
    
    *mask = *mask & ((1 << size_bit_len) - 1);

    /* Clear destination type in data and mask */
    BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
        entry, bcmFieldQualifyDstL3EgressNextHops, data, mask));
#endif
    return (rv);

}

/*
 * Function:
 *      bcm_esw_field_qualify_VlanTranslationHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVlanTranslationHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_VlanTranslationHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */
    int (*func)(int, bcm_field_entry_t, uint8 *, uint8 *) =
                                     _field_qualify_VlanTranslationHit_get;

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyVlanTranslationHit,
                                   data, mask);

    BCM_IF_ERROR_RETURN(rv);

#ifdef BCM_TRIDENT2_SUPPORT
    if (SOC_IS_TD2_TT2(unit)) {
        func = _bcm_field_td2_qualify_VlanTranslationHit_get;
    }
#endif

    BCM_IF_ERROR_RETURN((*func)(unit, entry, data, mask));

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IcmpTypeCode_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIcmpTypeCode
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IcmpTypeCode_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    int rv = BCM_E_INTERNAL;
    uint32 data_hw = 0, mask_hw = 0;

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                             bcmFieldQualifyIcmpTypeCode,
                                             &data_hw, &mask_hw);
    *data = (uint16) data_hw;
    *mask = (uint16) mask_hw;
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TranslatedVlanFormat_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTranslatedVlanFormat
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TranslatedVlanFormat_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int              rv;        /* Operation return status. */
    
    FP_LOCK(unit);

    rv = _field_qualify_VlanFormat_get(unit, entry, 
                                          bcmFieldQualifyTranslatedVlanFormat,
                                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IntPriority_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIntPriority
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IntPriority_get(int unit, bcm_field_entry_t entry,
                                      uint8 *data, uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyIntPriority,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_Color_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyColor
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      color - (OUT) Qualifier match color.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Color_get(int unit, bcm_field_entry_t entry, 
                                uint8 *color)
{
    int rv;          /* Operation return status. */
    uint8 data;      /* Qualifier data.          */
    uint8 mask;      /* Qualifier mask.          */

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, bcmFieldQualifyColor,
                                          &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    switch (data) {
      case 0:
          *color = BCM_FIELD_COLOR_GREEN;
          break;
      case 1:
          *color = BCM_FIELD_COLOR_RED;
          break;
      case 3:
          *color = BCM_FIELD_COLOR_YELLOW;
          break;
      default:
          rv = BCM_E_INTERNAL;
    }
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChannOuter_get
 * Purpose:
 *      Get Fibre Channel outer header type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (OUT) Fibre Channel header type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_FibreChanOuter_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_FibreChan_t *fibre_chan_type)
{
    uint8            data; /* HW data match criteria.  */
    uint8            mask; /* HW data mask.            */
    int              rv;   /* Operation return status. */

    /* Input parameters check. */
    if (NULL == fibre_chan_type) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                          bcmFieldQualifyFibreChanOuter,
                                          &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    switch (data) {
      case 0x1:
          *fibre_chan_type = bcmFieldFibreChan;
          break;
      case 0x2:
          *fibre_chan_type = bcmFieldFibreChanVirtual;
          break;
      case 0x3:
          *fibre_chan_type = bcmFieldFibreChanEncap;
          break;
      case 0x4:
          *fibre_chan_type = bcmFieldFibreChanRouted;
          break;
      default:
          return (BCM_E_INTERNAL);
    }
    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChannInner_get
 * Purpose:
 *      Get Fibre Channel inner header type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (OUT) Fibre Channel header type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_FibreChanInner_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_FibreChan_t *fibre_chan_type)
{
    uint8            data; /* HW data match criteria.  */
    uint8            mask; /* HW data mask.            */
    int              rv;   /* Operation return status. */

    /* Input parameters check. */
    if (NULL == fibre_chan_type) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                          bcmFieldQualifyFibreChanInner,
                                          &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    switch (data) {
      case 0x1:
          *fibre_chan_type = bcmFieldFibreChan;
          break;
      case 0x2:
          *fibre_chan_type = bcmFieldFibreChanVirtual;
          break;
      case 0x3:
          *fibre_chan_type = bcmFieldFibreChanEncap;
          break;
      case 0x4:
          *fibre_chan_type = bcmFieldFibreChanRouted;
          break;
      default:
          return (BCM_E_INTERNAL);
    }
    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_VnTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyVnTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_VnTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                                 bcmFieldQualifyVnTag,
                                                 data, mask);
}

/*
 * Function:
 *  bcm_esw_field_qualify_ETag_get
 * Purpose:
 *  Get match criteria for bcmFieldQualifyETag
 *  qualifier from the field entry.
 * Parameters:
 *  unit - (IN) Unit number.
 *  entry - (IN) BCM field entry id.
 *  data - (OUT) Qualifier match data.
 *  mask - (OUT) Qualifier match mask.
 * Returns:
 *  BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ETag_get(int unit, bcm_field_entry_t entry,
                                       uint64 *data, uint64 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

    /* Read qualifier match value and mask. */
    uint32 edata = 0;
    uint32 emask = 0;

    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                               bcmFieldQualifyETag,
                                               &edata, &emask);
    if (BCM_SUCCESS(rv)) {
        COMPILER_64_SET(*data, 0, edata);
        COMPILER_64_SET(*mask, 0, emask);
    }

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SubportPktTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySubportPktTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SubportPktTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                                 bcmFieldQualifySubportPktTag,
                                                 data, mask);
}


/*
 * Function:
 *      bcm_esw_field_qualify_CnTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyCnTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_CnTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                                 bcmFieldQualifyCnTag,
                                                 data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FabricQueueTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFabricQueueTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_FabricQueueTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                                 bcmFieldQualifyFabricQueueTag,
                                                 data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcModPortGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcModPortGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      port  - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcModPortGport_get(int unit, 
                                          bcm_field_entry_t entry, 
                                          bcm_gport_t *port)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == port) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                           bcmFieldQualifySrcModPortGport,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    BCM_GPORT_MODPORT_SET(*port, ((data >> _FP_PORT_BITWIDTH(unit)) & 0xff), 
                          (data & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));

    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcModuleGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcModuleGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      port  - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcModuleGport_get(int unit, 
                                          bcm_field_entry_t entry,
                                          bcm_gport_t *port)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == port) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                           bcmFieldQualifySrcModuleGport,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    BCM_GPORT_MODPORT_SET(*port, (data & 0xff), 0);

    return BCM_E_NONE; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_CpuQueue
 * Purpose:
 *      Set match criteria for bcmFieldQualifyCpuQueue 
 *      qualifier for this field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) CPU COS queue value.
 *      mask    - (IN) CPU COS match mask value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_CpuQueue(int unit,
                               bcm_field_entry_t entry,
                               uint8 data,
                               uint8 mask)
{
    int              rv;    /* Operation return status */

    
    FP_LOCK(unit);

    /* Qualify CpuQueue */
    rv = _field_qualify_cpu_queue(unit, entry,
                                  bcmFieldQualifyCpuQueue,
                                  data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_CpuQueue_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyCpuQueue
 *      qualifier from the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (OUT) CPU COS Queue matched value.
 *      mask  - (OUT) CPU COS Queue matched mask value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_CpuQueue_get(int unit,
                                   bcm_field_entry_t entry,
                                   uint8 *data,
                                   uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _field_qualify_cpu_queue_get(unit, entry,
                bcmFieldQualifyCpuQueue, data, mask);
}

int
bcm_esw_field_qualify_DstIpLocal(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    /* Input data validation, it should not be more 1 bit */
    if (data & ~(1)) {
       return BCM_E_PARAM;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstIpLocal,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_DstIpLocal_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int              rv;       /* Operation return status. */

    /* Read qualifier match value and mask. */ 
    rv = (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                               bcmFieldQualifyDstIpLocal,
                                               data, mask));
    return rv;
}


int
bcm_esw_field_qualify_GenericAssociatedChannelLabelValid(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyGenericAssociatedChannelLabelValid,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_GenericAssociatedChannelLabelValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                 bcmFieldQualifyGenericAssociatedChannelLabelValid,
                                                 data, mask
                                                 )
            );
}


int
bcm_esw_field_qualify_IpAddrsNormalized(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIpAddrsNormalized,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_IpAddrsNormalized_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                  bcmFieldQualifyIpAddrsNormalized,
                                                  data, mask
                                                  )
             );
 }


 int
 bcm_esw_field_qualify_IpTunnelHit(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
 {
     int              rv;       /* Operation return status. */

     
     FP_LOCK(unit);

     rv = _field_qualify32(unit, entry, bcmFieldQualifyIpTunnelHit,
                           data, mask);

     FP_UNLOCK(unit);
     return (rv);
 }


 int 
 bcm_esw_field_qualify_IpTunnelHit_get(
     int unit, 
     bcm_field_entry_t entry, 
     uint8 *data, 
     uint8 *mask)
 {
     /* Read qualifier match value and mask. */ 
     return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                  bcmFieldQualifyIpTunnelHit,
                                                  data, mask
                                                  )
             );
 }

int
bcm_esw_field_qualify_L2GreVsid(int unit, bcm_field_entry_t entry,
                                uint32 data, uint32 mask)
{
    int rv = BCM_E_UNAVAIL;
#ifdef BCM_TOMAHAWK_SUPPORT

    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyL2GreVsid,
                                            data, mask);

        FP_UNLOCK(unit);
    }
#endif
    return rv;
}
int
bcm_esw_field_qualify_L2GreVsid_get(int unit, bcm_field_entry_t entry,
                                uint32 *data, uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;
#ifdef BCM_TOMAHAWK_SUPPORT
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyL2GreVsid,
                                            data, mask);
    }
#endif
    return rv;
}
int
 bcm_esw_field_qualify_L2GreSrcIpHit(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
 {
     int              rv;       /* Operation return status. */

     
     FP_LOCK(unit);

     rv = _field_qualify32(unit, entry, bcmFieldQualifyL2GreSrcIpHit,
                           data, mask);

     FP_UNLOCK(unit);
     return (rv);
 }


 int 
 bcm_esw_field_qualify_L2GreSrcIpHit_get(
     int unit, 
     bcm_field_entry_t entry, 
     uint8 *data, 
     uint8 *mask)
 {
     /* Read qualifier match value and mask. */ 
     return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                  bcmFieldQualifyL2GreSrcIpHit,
                                                  data, mask
                                                  )
             );
 }


 int
 bcm_esw_field_qualify_L2GreVfiHit(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
 {
     int              rv;       /* Operation return status. */

     
     FP_LOCK(unit);

     rv = _field_qualify32(unit, entry, bcmFieldQualifyL2GreVfiHit,
                           data, mask);

     FP_UNLOCK(unit);
     return (rv);
 }


 int 
 bcm_esw_field_qualify_L2GreVfiHit_get(
     int unit, 
     bcm_field_entry_t entry, 
     uint8 *data, 
     uint8 *mask)
 {
     /* Read qualifier match value and mask. */ 
     return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                  bcmFieldQualifyL2GreVfiHit,
                                                  data, mask
                                                  )
             );
 }


 int
 bcm_esw_field_qualify_MacAddrsNormalized(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
 {
     int              rv;       /* Operation return status. */

     
     FP_LOCK(unit);

     rv = _field_qualify32(unit, entry, bcmFieldQualifyMacAddrsNormalized,
                           data, mask);

     FP_UNLOCK(unit);
     return (rv);
 }


 int 
 bcm_esw_field_qualify_MacAddrsNormalized_get(
     int unit, 
     bcm_field_entry_t entry, 
     uint8 *data, 
     uint8 *mask)
 {
     /* Read qualifier match value and mask. */ 
     return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                  bcmFieldQualifyMacAddrsNormalized,
                                                  data, mask
                                                  )
             );
 }


 int
 bcm_esw_field_qualify_MimSrcGportHit(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
 {
     int              rv;       /* Operation return status. */

     
     FP_LOCK(unit);

     rv = _field_qualify32(unit, entry, bcmFieldQualifyMimSrcGportHit,
                           data, mask);

     FP_UNLOCK(unit);
     return (rv);
 }


 int 
 bcm_esw_field_qualify_MimSrcGportHit_get(
     int unit, 
     bcm_field_entry_t entry, 
     uint8 *data, 
     uint8 *mask)
 {
     /* Read qualifier match value and mask. */ 
     return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                  bcmFieldQualifyMimSrcGportHit,
                                                  data, mask
                                                  )
             );
 }


 int
 bcm_esw_field_qualify_MimVfiHit(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
 {
     int              rv;       /* Operation return status. */

     
     FP_LOCK(unit);

     rv = _field_qualify32(unit, entry, bcmFieldQualifyMimVfiHit,
                           data, mask);

     FP_UNLOCK(unit);
     return (rv);
 }


 int 
 bcm_esw_field_qualify_MimVfiHit_get(
     int unit, 
     bcm_field_entry_t entry, 
     uint8 *data, 
     uint8 *mask)
 {
     /* Read qualifier match value and mask. */ 
     return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                  bcmFieldQualifyMimVfiHit,
                                                  data, mask
                                                  )
            );
}


int
bcm_esw_field_qualify_MplsControlWord(int unit, bcm_field_entry_t entry,
                                uint32 data, uint32 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsControlWord,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_MplsControlWord_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                                 bcmFieldQualifyMplsControlWord,
                                                 data, mask
                                                 )
            );
}


int
bcm_esw_field_qualify_MplsControlWordValid(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsControlWordValid,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_MplsControlWordValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                 bcmFieldQualifyMplsControlWordValid,
                                                 data, mask
                                                 )
            );
}


int
bcm_esw_field_qualify_MplsForwardingLabel(int unit, bcm_field_entry_t entry,
                                uint32 data, uint32 mask)
{
    return (_bcm_esw_field_qualify_aux_tag(unit,
                                           entry,
                                           bcmFieldQualifyMplsForwardingLabel,
                                           data,
                                           mask
                                           )
            );
}


int 
bcm_esw_field_qualify_MplsForwardingLabel_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                                  bcmFieldQualifyMplsForwardingLabel,
                                                  data, mask
                                                  )
            );
}


int
bcm_esw_field_qualify_MplsForwardingLabelAction(int unit, bcm_field_entry_t entry,
                                uint8 mplslabelaction, uint8 mask)
{
    int              rv;       /* Operation return status. */
    uint8            data;     /* Mpls label action data */

    switch (mplslabelaction) {
        case BCM_FIELD_MPLS_FORWARDING_LABEL_ACTION_PHP:
            data = 2;
            break;
        case BCM_FIELD_MPLS_FORWARDING_LABEL_ACTION_SWAP:
            data = 3;
            break;
        case BCM_FIELD_MPLS_FORWARDING_LABEL_ACTION_POP:
            data = 4;
            break;
        case BCM_FIELD_MPLS_FORWARDING_LABEL_ACTION_POP_USE_L2_VPN:
            data = 5;
            break;
        case BCM_FIELD_MPLS_FORWARDING_LABEL_ACTION_POP_USE_L3_VPN:
            data = 6;
            break;
        case BCM_FIELD_MPLS_FORWARDING_LABEL_ACTION_POP_USE_ENTROPY:
            data = 7;
            break;
        default:
            return (BCM_E_PARAM);
    }

    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsForwardingLabelAction,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_MplsForwardingLabelAction_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                 bcmFieldQualifyMplsForwardingLabelAction,
                                                 data, mask
                                                 )
            );
}


int
bcm_esw_field_qualify_MplsForwardingLabelBos(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    /* Skip the Aux tag settings for Multi Pipe devices */
    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* Add in AUX_TAG_VALID */
       data |= 1 << 1;
       mask |= 1 << 1;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsForwardingLabelBos,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_MplsForwardingLabelBos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint8_get(
                            unit,
                            entry, 
                            bcmFieldQualifyMplsForwardingLabelBos,
                            data,
                            mask
                                                             )
                        );

    /* Skip the Aux tag settings for Multi Pipe devices */
    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        /* Mask off AUX_TAG_VALID */
        *data &= 1;
        *mask &= 1;
    }

    return (BCM_E_NONE);
}


int
bcm_esw_field_qualify_MplsForwardingLabelExp(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    /* Skip the Aux tag settings for Multi Pipe devices */
    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* Add in AUX_TAG_VALID */
       data |= 1 << 3;
       mask |= 1 << 3;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsForwardingLabelExp,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_MplsForwardingLabelExp_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint8_get(
                            unit,
                            entry, 
                            bcmFieldQualifyMplsForwardingLabelExp,
                            data,
                            mask
                                                             )
                        );

    /* Skip the Aux tag settings for Multi Pipe devices */
    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* Mask off AUX_TAG_VALID */
       *data &= (1 << 3) - 1;
       *mask &= (1 << 3) - 1;
    }

    return (BCM_E_NONE);
}


int
bcm_esw_field_qualify_MplsForwardingLabelId(int unit, bcm_field_entry_t entry,
                                uint32 data, uint32 mask)
{
    int              rv;       /* Operation return status. */

    /* Skip the Aux tag settings for Multi Pipe devices */
    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* Add in AUX_TAG_VALID */
       data |= 1 << 20;
       mask |= 1 << 20;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsForwardingLabelId,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_MplsForwardingLabelId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */ 
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(
                            unit,
                            entry, 
                            bcmFieldQualifyMplsForwardingLabelId,
                            data,
                            mask
                                                              )
                        );

    /* Skip the Aux tag settings for Multi Pipe devices */
    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* Mask off AUX_TAG_VALID */
       *data &= (1 << 20) - 1;
       *mask &= (1 << 20) - 1;
    }

    return (BCM_E_NONE);
}


int
bcm_esw_field_qualify_MplsForwardingLabelTtl(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    /* Skip the Aux tag settings for Multi Pipe devices */
    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* Add in AUX_TAG_VALID (1 << 8)*/
       data = data | (1 << 8);
       mask = mask | (1 << 8);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsForwardingLabelTtl,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_MplsForwardingLabelTtl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint8_get(
                            unit,
                            entry, 
                            bcmFieldQualifyMplsForwardingLabelTtl,
                            data,
                            mask
                                                             )
                        );

    /* Skip the Aux tag settings for Multi Pipe devices */
    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* Mask off AUX_TAG_VALID */
       *data &= (1 << 8) - 1;
       *mask &= (1 << 8) - 1;
    }

    return (BCM_E_NONE);
}


int
bcm_esw_field_qualify_MplsLabel1Hit(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsLabel1Hit,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_MplsLabel1Hit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                 bcmFieldQualifyMplsLabel1Hit,
                                                 data, mask
                                                 )
            );
}


int
bcm_esw_field_qualify_MplsLabel2Hit(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsLabel2Hit,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_MplsLabel2Hit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                 bcmFieldQualifyMplsLabel2Hit,
                                                 data, mask
                                                 )
            );
}


int
bcm_esw_field_qualify_RecoverableDrop(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyRecoverableDrop,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_RecoverableDrop_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                 bcmFieldQualifyRecoverableDrop,
                                                 data, mask
                                                 )
            );
}


int
bcm_esw_field_qualify_RepCopy(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyRepCopy,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_RepCopy_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                 bcmFieldQualifyRepCopy,
                                                 data, mask
                                                 )
            );
}


int
bcm_esw_field_qualify_RouterAlertLabelValid(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyRouterAlertLabelValid,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_RouterAlertLabelValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                 bcmFieldQualifyRouterAlertLabelValid,
                                                 data, mask
                                                 )
            );
}


int
bcm_esw_field_qualify_Rtag7AHashLower(int unit, bcm_field_entry_t entry,
                                uint16 data, uint16 mask)
{
    int              rv;       /* Operation return status. */
    uint32           ref_data, ref_mask;

    ref_data = (uint32) data;
    ref_mask = (uint32) mask;

    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* AUX_TAG_VALID_1/2 field needs to be set in TCAM table */
       ref_data |= 1 << (sizeof(data) * 8);
       ref_mask |= 1 << (sizeof(data) * 8);
    } 

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyRtag7AHashLower,
                          ref_data, ref_mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_Rtag7AHashLower_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                                  bcmFieldQualifyRtag7AHashLower,
                                                  data, mask
                                                  )
            );
}


int
bcm_esw_field_qualify_Rtag7AHashUpper(int unit, bcm_field_entry_t entry,
                                uint16 data, uint16 mask)
{
    int              rv;       /* Operation return status. */
    uint32           ref_data, ref_mask;

    ref_data = (uint32) data;
    ref_mask = (uint32) mask;

    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* AUX_TAG_VALID_1/2 field needs to be set in TCAM table */
       ref_data |= 1 << (sizeof(data) * 8);
       ref_mask |= 1 << (sizeof(data) * 8);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyRtag7AHashUpper,
                          ref_data, ref_mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_Rtag7AHashUpper_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                                  bcmFieldQualifyRtag7AHashUpper,
                                                  data, mask
                                                  )
            );
}


int
bcm_esw_field_qualify_Rtag7BHashLower(int unit, bcm_field_entry_t entry,
                                uint16 data, uint16 mask)
{
    int              rv;       /* Operation return status. */
    uint32           ref_data, ref_mask;

    ref_data = (uint32) data;
    ref_mask = (uint32) mask;

    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* AUX_TAG_VALID_1/2 field needs to be set in TCAM table */
       ref_data |= 1 << (sizeof(data) * 8);
       ref_mask |= 1 << (sizeof(data) * 8);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyRtag7BHashLower,
                          ref_data, ref_mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_Rtag7BHashLower_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                                  bcmFieldQualifyRtag7BHashLower,
                                                  data, mask
                                                  )
            );
}


int
bcm_esw_field_qualify_Rtag7BHashUpper(int unit, bcm_field_entry_t entry,
                                uint16 data, uint16 mask)
{
    int              rv;       /* Operation return status. */
    uint32           ref_data, ref_mask;

    ref_data = (uint32) data;
    ref_mask = (uint32) mask;

    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* AUX_TAG_VALID_1/2 field needs to be set in TCAM table */
       ref_data |= 1 << (sizeof(data) * 8);
       ref_mask |= 1 << (sizeof(data) * 8);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyRtag7BHashUpper,
                          ref_data, ref_mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_Rtag7BHashUpper_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                                  bcmFieldQualifyRtag7BHashUpper,
                                                  data, mask
                                                  )
            );
}


int
bcm_esw_field_qualify_TrillEgressRbridgeHit(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyTrillEgressRbridgeHit,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_TrillEgressRbridgeHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                 bcmFieldQualifyTrillEgressRbridgeHit,
                                                 data, mask
                                                 )
            );
}


int
bcm_esw_field_qualify_TrillIngressRbridgeHit(int unit, bcm_field_entry_t entry,
                                uint8 data, uint8 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyTrillIngressRbridgeHit,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_TrillIngressRbridgeHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */ 
    return (_bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                                 bcmFieldQualifyTrillIngressRbridgeHit,
                                                 data, mask
                                                 )
            );
}


int
bcm_esw_field_qualify_EgressClass(int unit, bcm_field_entry_t entry,
                                uint16 data, uint16 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyEgressClass,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_EgressClass_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                             bcmFieldQualifyEgressClass,
                                             data, mask);
}


int
bcm_esw_field_qualify_EgressClassL2Gre(int unit, bcm_field_entry_t entry,
                                uint16 data, uint16 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyEgressClassL2Gre,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_EgressClassL2Gre_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                             bcmFieldQualifyEgressClassL2Gre,
                                             data, mask);
}


int
bcm_esw_field_qualify_EgressClassL3Interface(int unit, bcm_field_entry_t entry,
                                uint16 data, uint16 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyEgressClassL3Interface,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_EgressClassL3Interface_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                             bcmFieldQualifyEgressClassL3Interface,
                                             data, mask);
}


int
bcm_esw_field_qualify_EgressClassTrill(int unit, bcm_field_entry_t entry,
                                uint16 data, uint16 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyEgressClassTrill,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_EgressClassTrill_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                             bcmFieldQualifyEgressClassTrill,
                                             data, mask);
}


int
bcm_esw_field_qualify_EgressClassWlan(int unit, bcm_field_entry_t entry,
                                uint16 data, uint16 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyEgressClassWlan,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


int 
bcm_esw_field_qualify_EgressClassWlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                             bcmFieldQualifyEgressClassWlan,
                                             data, mask);
}

/* 
 * Set match criteria for EgressClassVxlan
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassVxlan(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    int              rv;       /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyEgressClassVxlan,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/* 
 * Get match criteria for EgressClassVxlan
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassVxlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
      /* Read qualifier match value and mask. */ 
    return _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                             bcmFieldQualifyEgressClassVxlan,
                                             data, mask);
}

/*
 * Function:
 *     bcm_esw_field_qualify_SrcGport
 * Purpose:
 *     Add Source ModPort or MPLS/MiM/WLAN/Niv/extender port qualification to a
 *     field entry.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field Entry id.
 *     port_id  - (IN) ModPort Gport or MPLS/MiM/WLAN/Niv/extender Gport ID.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_qualify_SrcGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t port_id)
{
    int rv = BCM_E_UNAVAIL; /* Operation return status. */
    _field_control_t *fc;   /* Field control structure. */
    _field_entry_t *f_ent;   /* Field entry information. */
    uint32 data;            /* HW data match value.     */
    uint32 mask;            /* HW data mask value.      */
    bcm_module_t modid;     /* Source Module ID.        */
    bcm_port_t port;        /* Source Port.             */

#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    int ingress_entity = 0;
#endif

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Include all bits for mask value */
    mask = BCM_FIELD_EXACT_MATCH_MASK;

    if ( f_ent->group->stage_id  == _BCM_FIELD_STAGE_LOOKUP) {
        if (BCM_GPORT_IS_MODPORT(port_id)) {
            /* Get the Mod/Port pair value for the given Gport value. */
            rv = _field_qualifier_gport_resolve(unit, port_id, mask,
                                            &port, &modid, NULL);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }

            /* Qualify the source port value. */
            rv = _field_qualify_Port(unit, entry, modid,
                                 mask, port,
                                 mask, bcmFieldQualifySrcGport);
            if (BCM_SUCCESS(rv)) {
                f_ent->flags &= ~_FP_ENTRY_QUAL_PORT_TYPE_TRUNK;
            }

        } else  if (BCM_GPORT_IS_TRUNK(port_id)) {
            rv = _field_qualifier_gport_resolve(unit, port_id, mask, 
                                           NULL, NULL, (bcm_trunk_t *)&data);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }

            /* Qualify the source trunk value. */
            rv = fc->functions.fp_qualify_trunk(unit, entry, 
                                            bcmFieldQualifySrcGport, 
                                            data, mask);
            if (BCM_SUCCESS(rv)) {
                f_ent->flags |= _FP_ENTRY_QUAL_PORT_TYPE_TRUNK;
            }
        } else {
            rv = BCM_E_PARAM;
        }
    } else {
    
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)

        /* Input parameters check. */
        /* coverity[dead_error_line : FALSE] */ 
        if ((0 == BCM_GPORT_IS_MPLS_PORT(port_id))
            && (0 == BCM_GPORT_IS_MIM_PORT(port_id)
            && (0 == BCM_GPORT_IS_WLAN_PORT(port_id))
            && (0 == BCM_GPORT_IS_NIV_PORT(port_id))
            && (!soc_feature(unit, soc_feature_niv) &&
                (BCM_GPORT_IS_NIV_PORT(port_id)))
            && (0 == BCM_GPORT_IS_VLAN_PORT(port_id))
            && (0 == BCM_GPORT_IS_MODPORT(port_id))
            && (0 == BCM_GPORT_IS_EXTENDER_PORT(port_id))
            && (0 == BCM_GPORT_IS_TRUNK(port_id)))
            && (0 == BCM_GPORT_IS_FLOW_PORT(port_id))
            && (0 == BCM_GPORT_IS_VXLAN_PORT(port_id))) {
            return (BCM_E_PARAM);
        }

        /* Include all bits for mask value */
        mask = BCM_FIELD_EXACT_MATCH_MASK;


        /* Check if source port is a generic logical port. */
        if (BCM_GPORT_IS_MODPORT(port_id)) {
#if defined(BCM_TOMAHAWK_SUPPORT)
            if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
                LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: Gport=%#x "
                                "is Mod port Gport. Use Qual"
                                " SrcModPortGport to match\n"), unit, port_id));
                FP_UNLOCK(unit);
                return (BCM_E_CONFIG);
            }
#endif
            /* Get the Mod/Port pair value for the given Gport value. */
            rv = _field_qualifier_gport_resolve(unit, port_id, mask,
                                            &port, &modid, NULL);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }

            /* Qualify the source port value. */
            rv = _field_qualify_Port(unit, entry, modid,
                                 mask, port,
                                 mask, bcmFieldQualifySrcGport);
        } else if (BCM_GPORT_IS_TRUNK(port_id)) {

            /* Get the Mod/Port pair value for the given Gport value. */
            rv = _field_qualifier_gport_resolve(unit, port_id, mask, 
                                       NULL, NULL, (bcm_trunk_t *)&data);
            if (BCM_FAILURE(rv)) {
               FP_UNLOCK(unit);
                return (rv);
            }

            /* Qualify the source trunk value. */
            rv = fc->functions.fp_qualify_trunk(unit, entry, 
                                            bcmFieldQualifySrcGport, 
                                            data, mask);
        } else {
            /*
             * Source port is a virtual port.
             */
    
            /* Get field entry part that contains the qualifier. */
            rv = _bcm_field_entry_qual_get(unit, entry,
                                   bcmFieldQualifySrcGport, &f_ent);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }

            /* Get the source virtual port value */
            if (BCM_GPORT_IS_MPLS_PORT(port_id)) {
                data = BCM_GPORT_MPLS_PORT_ID_GET(port_id);
                f_ent->svp_type = _bcmVpTypeMpls;
            } else if (BCM_GPORT_IS_MIM_PORT(port_id)) {
                data = BCM_GPORT_MIM_PORT_ID_GET(port_id);
                f_ent->svp_type = _bcmVpTypeMim;
            } else if (BCM_GPORT_IS_NIV_PORT(port_id)) {
                data = BCM_GPORT_NIV_PORT_ID_GET(port_id);
                f_ent->svp_type = _bcmVpTypeNiv;
            } else if (BCM_GPORT_IS_VLAN_PORT(port_id)) {
                data = BCM_GPORT_VLAN_PORT_ID_GET(port_id);
                f_ent->svp_type = _bcmVpTypeVlan;
            } else if (BCM_GPORT_IS_EXTENDER_PORT(port_id)) {
                data = BCM_GPORT_EXTENDER_PORT_ID_GET(port_id);
                f_ent->svp_type = _bcmVpTypeExtender;
            } else if (BCM_GPORT_IS_VXLAN_PORT(port_id)) {
                data = BCM_GPORT_VXLAN_PORT_ID_GET(port_id);
                f_ent->svp_type = _bcmVpTypeVxlan;
            } else if (BCM_GPORT_IS_FLOW_PORT(port_id)) {
                data = BCM_GPORT_FLOW_PORT_ID_GET(port_id);
                f_ent->svp_type = _bcmVpTypeFlow;
            }else {
                data = BCM_GPORT_WLAN_PORT_ID_GET(port_id);
                f_ent->svp_type = _bcmVpTypeWlan;
            }

#if defined(BCM_TOMAHAWK_SUPPORT)
           /*
            * Invoke driver function for multi pipe supported devices.
            */ 
            if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
                rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                                 _BCM_FIELD_STAGE_INGRESS);

                if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
                    FP_UNLOCK(unit);
                    return (rv); 
                }
    
                if (rv == BCM_E_NONE) { /*Stage is Ingress*/ 
                    rv = fc->functions.fp_qualify_svp(unit, entry,
                                              bcmFieldQualifySrcGport,
                                              data, mask, 1);
                    FP_UNLOCK(unit);
                    return (rv);
                }
            }
#endif /* BCM_TOMAHAWK_SUPPORT */

#ifdef BCM_TRIDENT2_SUPPORT
            if (SOC_IS_TD2_TT2(unit)) {
                /* Internal qualifier to set SVP valid bit in Fixed field */
                rv = _field_qualify32(unit, entry,
                                      _bcmFieldQualifySvpValid, 1, 1);

                if (BCM_FAILURE(rv)) {
                    FP_UNLOCK(unit);
                    return (rv);
                }
                ingress_entity = 1;
            }
#endif /* BCM_TRIDENT2_SUPPORT */

            /* Qualify Source Virtual Port */
            rv = _field_qualify_source_virtual_port(unit, entry,
                                                bcmFieldQualifySrcGport,
                                                data, mask, ingress_entity);
        }

#endif
    }
    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *     bcm_esw_field_qualify_SrcGport_get
 * Purpose:
 *     Get Source ModPort or MPLS/MiM/WLAN/extender gport value from a
 *     field entry.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field Entry id.
 *     port_id  - (OUT) ModPort Gport or MPLS/MiM/WLAN/extender Gport ID.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_qualify_SrcGport_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_gport_t *port_id)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
    _field_entry_t *f_ent;   /* Field entry information.      */
    bcm_module_t data_modid; /* Module ID.                    */
    bcm_port_t data_port;    /* Port ID.                      */
    bcm_module_t mask_modid;
    bcm_port_t mask_port;
    bcm_trunk_t t_mask;
    _field_control_t *fc;    /* Field control structure.    */

#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    uint32 data;             /* HW encoded qualifier data.    */
    uint32 mask;             /* HW encoding qualifier mask.   */
    bcm_module_t modid;      /* Module ID.                    */
    bcm_port_t port;         /* Port ID.                      */
    uint8 num_bits_for_port; /* Port bitmap bits count.       */
    uint8 trunk_bit_pos;     /* Trunk indicator bit position. */
    _bcm_field_qual_offset_t *q_offset; /* Qualifier offset.  */
#endif

    /* Input parameters check. */
    if (NULL == port_id) {
        return (BCM_E_PARAM);
    }
    FP_LOCK(unit);

    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }
    if ( f_ent->group->stage_id  == _BCM_FIELD_STAGE_LOOKUP) {
        if ((f_ent->flags & _FP_ENTRY_QUAL_PORT_TYPE_TRUNK) ==
             _FP_ENTRY_QUAL_PORT_TYPE_TRUNK) {
            rv = fc->functions.fp_qualify_trunk_get(unit, entry,
                                            bcmFieldQualifySrcGport, 
                                            port_id, &t_mask);
            if (BCM_SUCCESS(rv)) {
                BCM_GPORT_TRUNK_SET(*port_id, *port_id);
            }
        } else {
            rv = _field_qualify_Port_get(unit, entry,
                                 &data_modid, &mask_modid,
                                 &data_port,  &mask_port,
                                 bcmFieldQualifySrcGport);
            if (BCM_SUCCESS(rv)) {
                rv = _bcm_esw_stk_modmap_map(unit,
                     BCM_STK_MODMAP_GET, data_modid, data_port,
                     &data_modid, &data_port);
                BCM_GPORT_MODPORT_SET(*port_id, data_modid, data_port);
            }
        }
        FP_UNLOCK(unit);
    } else {

#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                               bcmFieldQualifySrcGport,
                                               &data, &mask);
        FP_UNLOCK(unit);
        BCM_IF_ERROR_RETURN(rv);

        if (mask == 0) {
            return BCM_E_NOT_FOUND;
        }

        /* Get field entry part that contains the qualifier. */
        rv = _bcm_field_entry_qual_get(unit, entry,
                                   bcmFieldQualifySrcGport, &f_ent);
        BCM_IF_ERROR_RETURN(rv);

        /* Get qualifier offsets in the tcam. */
        rv = _field_qual_offset_get(unit, f_ent,
                                bcmFieldQualifySrcGport, &q_offset);
        BCM_IF_ERROR_RETURN(rv);

        if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
            /* Clear SVP valid bit. */
           data &= ((1 << (q_offset->width[0] - 1)) - 1);
        }

        if (f_ent->svp_type == _bcmVpTypeMpls) {
            BCM_GPORT_MPLS_PORT_ID_SET(*port_id, data);
        } else if (f_ent->svp_type == _bcmVpTypeMim) {
            BCM_GPORT_MIM_PORT_ID_SET(*port_id, data);
        } else if (f_ent->svp_type == _bcmVpTypeNiv) {
            BCM_GPORT_NIV_PORT_ID_SET(*port_id, data);
        } else if (f_ent->svp_type == _bcmVpTypeVlan) {
            BCM_GPORT_VLAN_PORT_ID_SET(*port_id, data);
        } else if (f_ent->svp_type == _bcmVpTypeExtender) {
            BCM_GPORT_EXTENDER_PORT_ID_SET(*port_id, data);
        } else if (f_ent->svp_type == _bcmVpTypeVxlan) {
            BCM_GPORT_VXLAN_PORT_ID_SET(*port_id, data);
        } else if (f_ent->svp_type == _bcmVpTypeFlow) {
            BCM_GPORT_FLOW_PORT_ID_SET(*port_id, data);
        } else if (f_ent->svp_type == _bcmVpTypeWlan) {
            BCM_GPORT_WLAN_PORT_ID_SET(*port_id, data);
        } else {
#if defined(BCM_TOMAHAWK_SUPPORT)
            if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
                return BCM_E_INTERNAL;
            }
#endif
            /* ModPort Gport type. */
            if (soc_feature(unit, soc_feature_trunk_group_overlay)) {
                num_bits_for_port
                    = _shr_popcount((unsigned int)SOC_PORT_ADDR_MAX(unit));
            /* SrcPort and DstPort are programmed as 0 - 7 bits are used to
             *  store port and 7 - 14 are for Module ID num_bits_for_port is
             *  increased by 2 as SOC_PORT_ADDR_MAX returns 5 for Metrolite.
            */

#if defined(BCM_METROLITE_SUPPORT)
            if (SOC_IS_METROLITE(unit)) {
                num_bits_for_port += 2;
            }
#endif

                data_modid = data >> num_bits_for_port;
                data_port = data & ((1 << num_bits_for_port) - 1);
            } else {
                 /* Get the trunk bit position */
                trunk_bit_pos = SOC_TRUNK_BIT_POS(unit);
                data_modid = data >> (trunk_bit_pos + 1);
                data_port = data & ((1 << trunk_bit_pos) - 1);
            }

            BCM_IF_ERROR_RETURN
                (_bcm_esw_stk_modmap_map(unit, BCM_STK_MODMAP_GET, data_modid,
                                     data_port, &modid, &port));
            BCM_GPORT_MODPORT_SET(*port_id, modid, port);
        }
#endif
    }
    return (rv);
}



/*
 * Function:
 *     bcm_esw_field_qualify_DstGport
 * Purpose:
 *     Add Destination Gport qualification to a
 *     field entry.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field Entry id.
 *     port_id  - (IN) Gport ID.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_qualify_DstGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t port_id)
{
    _field_control_t *fc;   /* Field control structure. */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv = 0;             /* Operation return status. */
    _field_entry_t *f_ent;  /* Field entry structure.   */
    bcm_module_t modid;     /* Source Module ID.        */
    bcm_port_t port;        /* Source Port.             */

    /* Input parameters check. */
    /* coverity[dead_error_line : FALSE] */  
    if ((0 == BCM_GPORT_IS_MPLS_PORT(port_id))
        && (0 == BCM_GPORT_IS_MIM_PORT(port_id)
        && (0 == BCM_GPORT_IS_WLAN_PORT(port_id))
        && (0 == BCM_GPORT_IS_NIV_PORT(port_id))
        && (!soc_feature(unit, soc_feature_niv) && (BCM_GPORT_IS_NIV_PORT(port_id)))
        && (0 == BCM_GPORT_IS_VLAN_PORT(port_id))
        && (0 == BCM_GPORT_IS_EXTENDER_PORT(port_id))
        && (0 == BCM_GPORT_IS_MODPORT(port_id))
        && (0 == BCM_GPORT_IS_TRUNK(port_id))
        && (0 == BCM_GPORT_IS_FLOW_PORT(port_id))
        && (0 == BCM_GPORT_IS_VXLAN_PORT(port_id)))) {
        return (BCM_E_PARAM);
    }

    /* Include all bits for mask value */
    mask = BCM_FIELD_EXACT_MATCH_MASK;

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
                         bcmFieldQualifyDstGport, &f_ent));

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /* 
         * LSB is DVP valid bit.
  * Shift DVP value by 1-bit,
         */
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
        /* Get the source virtual port value */
        if (BCM_GPORT_IS_MPLS_PORT(port_id)) {
            data = BCM_GPORT_MPLS_PORT_ID_GET(port_id);
            f_ent->dvp_type = _bcmVpTypeMpls;
        } else if (BCM_GPORT_IS_MIM_PORT(port_id)) {
            data = BCM_GPORT_MIM_PORT_ID_GET(port_id);
            f_ent->dvp_type = _bcmVpTypeMim;
        } else if (BCM_GPORT_IS_NIV_PORT(port_id)) {
            data = BCM_GPORT_NIV_PORT_ID_GET(port_id);
            f_ent->dvp_type = _bcmVpTypeNiv;
        } else if (BCM_GPORT_IS_VLAN_PORT(port_id)) {
            data = BCM_GPORT_VLAN_PORT_ID_GET(port_id);
            f_ent->dvp_type = _bcmVpTypeVlan;
        } else if (BCM_GPORT_IS_EXTENDER_PORT(port_id)) {
            data = BCM_GPORT_EXTENDER_PORT_ID_GET(port_id);
            f_ent->dvp_type = _bcmVpTypeExtender;
        } else if (BCM_GPORT_IS_VXLAN_PORT(port_id)) {
            data = BCM_GPORT_VXLAN_PORT_ID_GET(port_id);
            f_ent->dvp_type = _bcmVpTypeVxlan;
        } else if (BCM_GPORT_IS_FLOW_PORT(port_id)) {
            data = BCM_GPORT_FLOW_PORT_ID_GET(port_id);
            f_ent->dvp_type = _bcmVpTypeFlow;
        } else if (BCM_GPORT_IS_WLAN_PORT(port_id)) {
            data = BCM_GPORT_WLAN_PORT_ID_GET(port_id);
            f_ent->dvp_type = _bcmVpTypeWlan;
        } else
#endif /* INCLUDE_L3 & TRX_SUPPORT */
        {
            if (BCM_GPORT_IS_MODPORT(port_id)) {
                rv = _field_qualifier_gport_resolve(unit, port_id, mask,
                                                &port, &modid, NULL);
                if (BCM_FAILURE(rv)) {
                    FP_UNLOCK(unit);
                    return (rv);
                }

                /* Qualify the source port value. */
                rv = _field_qualify_Port(unit, entry, modid,
                                     mask, port,
                                     mask, bcmFieldQualifyDstGport);
                f_ent->dvp_type = _BCM_GPORT_TYPE_MOD_PORT;
                FP_UNLOCK(unit);
                return (rv);
            } else {
                FP_UNLOCK(unit);
                return (BCM_E_PARAM);
            }
        }

        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;
        rv = _field_qualify32(unit, entry, bcmFieldQualifyDstGport,
                              data, mask);
    } else {
        /* Check if source port is a generic logical port. */
        if (BCM_GPORT_IS_MODPORT(port_id)) {

            /* Get the Mod/Port pair value for the given Gport value. */
            rv = _field_qualifier_gport_resolve(unit, port_id, mask,
                                                &port, &modid, NULL);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }

            /* Qualify the source port value. */
            rv = _field_qualify_Port(unit, entry, modid,
                                     mask, port,
                                     mask, bcmFieldQualifyDstGport);
        } else if (BCM_GPORT_IS_TRUNK(port_id)) {

            /* Get the Mod/Port pair value for the given Gport value. */
            rv = _field_qualifier_gport_resolve(unit, port_id, mask,
                                               NULL, NULL, (bcm_trunk_t *)&data);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }

            /* Qualify the source trunk value. */
            rv = fc->functions.fp_qualify_trunk(unit, entry, 
                                                bcmFieldQualifyDstGport, 
                                                data, mask);
        } else {
            /*
             * Destination port is a virtual port.
             */
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)

            /* Get the source virtual port value */
            if (BCM_GPORT_IS_MPLS_PORT(port_id)) {
                data = BCM_GPORT_MPLS_PORT_ID_GET(port_id);
                f_ent->dvp_type = _bcmVpTypeMpls;
            } else if (BCM_GPORT_IS_MIM_PORT(port_id)) {
                data = BCM_GPORT_MIM_PORT_ID_GET(port_id);
                f_ent->dvp_type = _bcmVpTypeMim;
            } else if (BCM_GPORT_IS_NIV_PORT(port_id)) {
                data = BCM_GPORT_NIV_PORT_ID_GET(port_id);
                f_ent->dvp_type = _bcmVpTypeNiv;
            } else if (BCM_GPORT_IS_VLAN_PORT(port_id)) {
                data = BCM_GPORT_VLAN_PORT_ID_GET(port_id);
                f_ent->dvp_type = _bcmVpTypeVlan;
            } else if (BCM_GPORT_IS_EXTENDER_PORT(port_id)) {
                data = BCM_GPORT_EXTENDER_PORT_ID_GET(port_id);
                f_ent->dvp_type = _bcmVpTypeExtender;
            } else if (BCM_GPORT_IS_VXLAN_PORT(port_id)) {
                data = BCM_GPORT_VXLAN_PORT_ID_GET(port_id);
                f_ent->dvp_type = _bcmVpTypeVxlan;
            } else if (BCM_GPORT_IS_FLOW_PORT(port_id)) {
                data = BCM_GPORT_FLOW_PORT_ID_GET(port_id);
                f_ent->dvp_type = _bcmVpTypeFlow;
            } else {
                data = BCM_GPORT_WLAN_PORT_ID_GET(port_id);
                f_ent->dvp_type = _bcmVpTypeWlan;
            }

           /*
            * Invoke driver function for multi pipe supported devices.
            */
#if defined(BCM_TOMAHAWK_SUPPORT)
            if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
                _BCM_FIELD_STAGE_INGRESS == f_ent->group->stage_id) {
                  rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstGport,
                                          data, mask, 1);
                  FP_UNLOCK(unit);
                  return (rv);
            }
#endif /* BCM_TOMAHAWK_SUPPORT */

            /* Qualify the destination type qualifier */
            rv = _field_dest_type_qualify(unit, entry,
                                          bcmFieldQualifyDstGport, 
                                          &data, &mask, 
                                          _bcmFieldDestTypeDvp);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }
            rv = _field_qualify32(unit, entry, bcmFieldQualifyDstGport,
                                  data, mask);
#endif /* INCLUDE_L3 & TRX_SUPPORT */ 
        }
    }
    FP_UNLOCK(unit);
    return (rv);
}
/*
 * Function:
 *     bcm_esw_field_qualify_DstGport_get
 * Purpose:
 *     Get Destination Gport value from a
 *     field entry.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field Entry id.
 *     port_id  - (OUT) Gport ID.
 * Returns:
 *      BCM_E_XXX
 */

int 
bcm_esw_field_qualify_DstGport_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_gport_t *port_id)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */
    _field_entry_t *f_ent; /* Field entry structure. */
    bcm_module_t data_modid; /* Module ID.                    */
    bcm_port_t data_port;    /* Port ID.                      */
    bcm_module_t modid;      /* Module ID.                    */
    bcm_port_t port;         /* Port ID.                      */
    uint8 num_bits_for_port; /* Port bitmap bits count.       */
    uint8 trunk_bit_pos;

    /* Input parameters check. */
    if (NULL == port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                            bcmFieldQualifyDstGport,
                                            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
        bcmFieldQualifyDstGport, &f_ent));

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
         /* Clear DVP Valid bit. */
        if (f_ent->dvp_type != _BCM_GPORT_TYPE_MOD_PORT)  {
            data >>= 1;
        }
    } else {

        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
            entry, bcmFieldQualifyDstGport, &data, &mask));
    }

    /* Get the trunk bit position */
    trunk_bit_pos = SOC_TRUNK_BIT_POS(unit);

    if (data >> trunk_bit_pos != 1) {
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
        if (f_ent->dvp_type == _bcmVpTypeMpls) {
            BCM_GPORT_MPLS_PORT_ID_SET(*port_id, data);
        } else if (f_ent->dvp_type == _bcmVpTypeMim) {
            BCM_GPORT_MIM_PORT_ID_SET(*port_id, data);
        } else if (f_ent->dvp_type == _bcmVpTypeNiv) {
            BCM_GPORT_NIV_PORT_ID_SET(*port_id, data);
        } else if (f_ent->dvp_type == _bcmVpTypeVlan) {
            BCM_GPORT_VLAN_PORT_ID_SET(*port_id, data);
        } else if (f_ent->dvp_type == _bcmVpTypeExtender) {
            BCM_GPORT_EXTENDER_PORT_ID_SET(*port_id, data);
        } else if (f_ent->dvp_type == _bcmVpTypeWlan) {
            BCM_GPORT_WLAN_PORT_ID_SET(*port_id, data);
        } else if (f_ent->dvp_type == _bcmVpTypeVxlan) {
            BCM_GPORT_VXLAN_PORT_ID_SET(*port_id, data);
        } else if (f_ent->dvp_type == _bcmVpTypeFlow) {
            BCM_GPORT_FLOW_PORT_ID_SET(*port_id, data);
        } else
#endif /* INCLUDE_L3 & TRX_SUPPORT */
            {

                /* ModPort Gport type. */
                if (soc_feature(unit, soc_feature_trunk_group_overlay)) {
                    num_bits_for_port
                        = _shr_popcount((unsigned int)SOC_PORT_ADDR_MAX(unit));

                    /* SrcPort and DstPort are programmed as 0 - 7 bits are used to store port and 7 - 14 are for Module ID
                       num_bits_for_port is increased by 2 as SOC_PORT_ADDR_MAX returns 5 for Metrolite.
                    */
#if defined(BCM_METROLITE_SUPPORT)
                    if (SOC_IS_METROLITE(unit)) {
                        num_bits_for_port += 2;
                    }
#endif
                    data_modid = data >> num_bits_for_port;
                    data_port = data & ((1 << num_bits_for_port) - 1);
                    BCM_IF_ERROR_RETURN
                       (_bcm_esw_stk_modmap_map(unit, BCM_STK_MODMAP_GET, data_modid,
                                         data_port, &modid, &port));
                    BCM_GPORT_MODPORT_SET(*port_id, modid, port);
                }
            }
    } else {
        data = (data & ( ~( 1 << trunk_bit_pos)));
        BCM_GPORT_TRUNK_SET(*port_id, data);
    }

    return BCM_E_NONE; 
}


/*
 * Function:
 *      bcm_esw_field_qualify_SrcVlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcVlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      vlan_port_id - (OUT) Vlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcVlanGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *vlan_port_id)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == vlan_port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
            bcmFieldQualifySrcVlanGport,
            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    data &=  0x1fff;
    BCM_GPORT_VLAN_PORT_ID_SET(*vlan_port_id, data);

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstVlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstVlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      vlan_port_id - (OUT) Vlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstVlanGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *vlan_port_id)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */
    _field_entry_t *f_ent; /* Field entry structure. */

    /* Input parameters check. */
    if (NULL == vlan_port_id) {
        return (BCM_E_PARAM);
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
                bcmFieldQualifyDstVlanGport, &f_ent));

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
            bcmFieldQualifyDstVlanGport,
            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /* Clear DVP Valid bit. */
        data >>= 1;
    } else {
        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
                    entry, bcmFieldQualifyDstVlanGport, &data, &mask));
    }

    BCM_GPORT_VLAN_PORT_ID_SET(*vlan_port_id, data);

    return BCM_E_NONE;
}


/*
 * Function:
 *      bcm_esw_field_qualify_MplsOuterLabelPop
 * Purpose:
 *      Set match criteria for bcmFieildQualifyMplsOuterLabelPop
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MplsOuterLabelPop(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
                bcmFieldQualifyMplsOuterLabelPop, data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MplsStationHitTunnelUnterminated
 * Purpose:
 *      Set match criteria for bcmFieildQualifyMplsStationHitTunnelUnterminated
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MplsStationHitTunnelUnterminated(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
                bcmFieldQualifyMplsStationHitTunnelUnterminated, data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MplsOuterLabelPop_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMplsOuterLabelPop
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MplsOuterLabelPop_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyMplsOuterLabelPop, data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MplsStationHitTunnelUnterminated_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMplsStationHitTunnelUnterminated
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MplsStationHitTunnelUnterminated_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyMplsStationHitTunnelUnterminated, data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressClassField
 * Purpose:
 *      Set match criteria for bcmFieildQualifyIngressClassField
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IngressClassField(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) 
{
    int                    rv;


#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class(unit, entry,
                                       bcmFieldQualifyIngressClassField,
                                       &data, &mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyIngressClassField,
                                          &data,
                                          &mask
                                          )
            );
    } else
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class(unit,
                                                         entry,
                                                         bcmFieldQualifyIngressClassField,
                                                         &data,
                                                         &mask
                                                         )
                            );
    } else
#endif
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyIngressClassField,
                                          &data,
                                          &mask
                                          ));
    } else
#endif /* BCM_KATANA2_SUPPORT */
    {
        /* Input parameters check. */
        if (data > SOC_ADDR_CLASS_MAX(unit)) {
            return (BCM_E_PARAM);
        }
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIngressClassField, 
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressClassField_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIngressClassField
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressClassField_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN
       (_bcm_field_entry_qualifier_uint32_get(unit,
                                              entry,
                                              bcmFieldQualifyIngressClassField,
                                              data,
                                              mask
                                              )
       );
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class_get(unit, entry,
                                           bcmFieldQualifyIngressClassField,
                                           data, mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyIngressClassField,
                                              data,
                                              mask
                                              )
            );
        return (BCM_E_NONE);
    }
#endif
#if defined BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)){
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyIngressClassField,
                                              data,
                                              mask
                                             )
            );
        return (BCM_E_NONE);
    }
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_tr3_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyIngressClassField,
                                              data,
                                              mask
                                             )
            );
        return (BCM_E_NONE);
    }
#endif
#if defined BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)){
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class_get(unit,
                                              entry,
                                              bcmFieldQualifyIngressClassField,
                                              data,
                                              mask
                                             )
            );
        return (BCM_E_NONE);
    }
#endif
    return (BCM_E_NONE);

}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressInterfaceClassPort
 * Purpose:
 *      Set match criteria for bcmFieildQualifyIngressInterfaceClassPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IngressInterfaceClassPort(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) 
{
    int                    rv;

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class(unit, entry,
                                       bcmFieldQualifyIngressInterfaceClassPort,
                                       &data, &mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
    if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_td2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyIngressInterfaceClassPort,
                                          &data,
                                          &mask
                                          )
            );
    } else
#endif
#ifdef BCM_TRIUMPH3_SUPPORT
    if (SOC_IS_TRIUMPH3(unit)) {
        BCM_IF_ERROR_RETURN(_bcm_field_tr3_qualify_class(unit,
                                                         entry,
                                                         bcmFieldQualifyIngressInterfaceClassPort,
                                                         &data,
                                                         &mask
                                                         )
                            );
    } else
#endif
#ifdef BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)) {
        BCM_IF_ERROR_RETURN
            (_bcm_field_kt2_qualify_class(unit,
                                          entry,
                                          bcmFieldQualifyIngressInterfaceClassPort,
                                          &data,
                                          &mask
                                          ));
    } else
#endif /* BCM_KATANA2_SUPPORT */

    {
        /* Input parameters check. */
        if (data > SOC_ADDR_CLASS_MAX(unit)) {
            return (BCM_E_PARAM);
        }
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIngressInterfaceClassPort, 
                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressInterfaceClassPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIngressInterfaceClassPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressInterfaceClassPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    /*Read qualifier and match value and mask */

    BCM_IF_ERROR_RETURN
        (_bcm_field_entry_qualifier_uint32_get(
                                      unit, entry,
                                      bcmFieldQualifyIngressInterfaceClassPort,
                                      data, mask)
                                      );

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
          (_bcm_field_th_qualify_class_get(unit, entry,
                                      bcmFieldQualifyIngressInterfaceClassPort,
                                      data, mask));
    } else
#endif /* BCM_TOMAHAWK_SUPPORT */
#ifdef BCM_TRIDENT2_SUPPORT
     if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
         BCM_IF_ERROR_RETURN
             (_bcm_field_td2_qualify_class_get(
                                       unit, entry,
                                       bcmFieldQualifyIngressInterfaceClassPort,
                                       data, mask)
             );
        return (BCM_E_NONE);

     } else
#endif
#if defined BCM_KATANA2_SUPPORT
    if (SOC_IS_KATANA2(unit)){
        BCM_IF_ERROR_RETURN
             (_bcm_field_kt2_qualify_class_get(
                                       unit, entry,
                                       bcmFieldQualifyIngressInterfaceClassPort,
                                       data, mask)
             );
        return (BCM_E_NONE);
    } else
#endif

#ifdef BCM_TRIUMPH3_SUPPORT
     if (SOC_IS_TRIUMPH3(unit)) {
         BCM_IF_ERROR_RETURN
             (_bcm_field_tr3_qualify_class_get(
                                       unit, entry,
                                       bcmFieldQualifyIngressInterfaceClassPort,
                                       data, mask)
             );
         return (BCM_E_NONE);

     }
#endif
     return (BCM_E_NONE);

}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanFlags
 * Purpose:
 *      Set match criteria for bcmFieildQualifyVxlanFlags
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanFlags(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    if (soc_feature(unit, soc_feature_vxlan) ||
        soc_feature(unit, soc_feature_flex_flow)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyVxlanFlags,
                              data, mask);
        FP_UNLOCK(unit);
    }
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanFlags_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVxlanFlags
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanFlags_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_vxlan) ||
        soc_feature(unit, soc_feature_flex_flow)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyVxlanFlags, data, mask);
    }
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanNetworkId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyVxlanNetworkId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanNetworkId(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    if (soc_feature(unit, soc_feature_vxlan) ||
        soc_feature(unit, soc_feature_vxlan_lite) ||
        soc_feature(unit, soc_feature_flex_flow)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyVxlanNetworkId,
                              data, mask);
        FP_UNLOCK(unit);
    }
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanNetworkId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVxlanNetworkId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanNetworkId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_vxlan) ||
        soc_feature(unit, soc_feature_vxlan_lite) ||
        soc_feature(unit, soc_feature_flex_flow)) {
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                    bcmFieldQualifyVxlanNetworkId, data, mask);
    }
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_NatNeeded
 * Purpose:
 *      Set match criteria for bcmFieildQualifyNatNeeded
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_NatNeeded(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    if (soc_feature(unit, soc_feature_nat) ||
        soc_feature(unit, soc_feature_large_scale_nat)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyNatNeeded,
                              data, mask);
        FP_UNLOCK(unit);
    }
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_NatNeeded_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyNatNeeded
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_NatNeeded_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_nat) ||
        soc_feature(unit, soc_feature_large_scale_nat)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyNatNeeded, data, mask);
    }
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_NatDstRealmId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyNatDstRealmId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_NatDstRealmId(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    if (soc_feature(unit, soc_feature_nat) ||
        soc_feature(unit, soc_feature_large_scale_nat)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyNatDstRealmId,
                              data, mask);
        FP_UNLOCK(unit);
    }
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_NatDstRealmId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyNatDstRealmId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_NatDstRealmId_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_nat) ||
        soc_feature(unit, soc_feature_large_scale_nat)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyNatDstRealmId, data, mask);
    }
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_NatSrcRealmId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyNatSrcRealmId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_NatSrcRealmId(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    if (soc_feature(unit, soc_feature_nat) ||
        soc_feature(unit, soc_feature_large_scale_nat)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyNatSrcRealmId,
                              data, mask);
        FP_UNLOCK(unit);
    }
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_NatSrcRealmId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyNatSrcRealmId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_NatSrcRealmId_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_nat) ||
        soc_feature(unit, soc_feature_large_scale_nat)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyNatSrcRealmId, data, mask);
    }
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IcmpError
 * Purpose:
 *      Set match criteria for bcmFieildQualifyIcmpError
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IcmpError(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    if (soc_feature(unit, soc_feature_nat)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyIcmpError,
                              data, mask);
        FP_UNLOCK(unit);
    }
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IcmpError_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIcmpError
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IcmpError_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_nat)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyIcmpError, data, mask);
    }
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanRCtl
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanRCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanRCtl(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)

    if (SOC_IS_TD2_TT2(unit)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanRCtl,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanRCtl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanRCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanRCtl_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFibreChanRCtl, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanFCtl
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanFCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanFCtl(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)

    if (SOC_IS_TD2_TT2(unit)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanFCtl,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanFCtl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanFCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanFCtl_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                    bcmFieldQualifyFibreChanFCtl, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanCSCtl
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanCSCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanCSCtl(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)

    if (SOC_IS_TD2_TT2(unit)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanCSCtl,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanCSCtl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanCSCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanCSCtl_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFibreChanCSCtl, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDFCtl
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanDFCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDFCtl(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)

    if (SOC_IS_TD2_TT2(unit)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanDFCtl,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDFCtl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanDFCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDFCtl_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFibreChanDFCtl, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanType
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanType(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)

    if (SOC_IS_TD2_TT2(unit)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanType,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanType_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFibreChanType, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanSrcId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcId(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)

    if (SOC_IS_TD2_TT2(unit)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanSrcId,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanSrcId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                    bcmFieldQualifyFibreChanSrcId, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDstId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanDstId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDstId(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)

    if (SOC_IS_TD2_TT2(unit)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanDstId,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDstId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanDstId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDstId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                    bcmFieldQualifyFibreChanDstId, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanZoneCheck
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanZoneCheck
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanZoneCheck(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)

    if (SOC_IS_TD2_TT2(unit)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanZoneCheck,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanZoneCheck_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanZoneCheck
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanZoneCheck_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFibreChanZoneCheck, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcFpmaCheck
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanSrcFpmaCheck
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcFpmaCheck(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)

    if (SOC_IS_TD2_TT2(unit)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanSrcFpmaCheck,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcFpmaCheck_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanSrcFpmaCheck
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcFpmaCheck_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFibreChanSrcFpmaCheck, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcBindCheck
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanSrcBindCheck
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcBindCheck(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)

    if (SOC_IS_TD2_TT2(unit)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanSrcBindCheck,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcBindCheck_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanSrcBindCheck
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcBindCheck_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFibreChanSrcBindCheck, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTVersion
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTVersion
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTVersion(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)

    if (SOC_IS_TD2_TT2(unit)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanVFTVersion,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTVersion_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTVersion
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTVersion_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFibreChanVFTVersion, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTPri
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTPri
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTPri(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)

    if (SOC_IS_TD2_TT2(unit)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanVFTPri,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTPri_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTPri
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTPri_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (SOC_IS_TD2_TT2(unit)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFibreChanVFTPri, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTFabricId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTFabricId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTFabricId(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (soc_feature(unit, soc_feature_fcoe)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanVFTFabricId,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTFabricId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTFabricId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTFabricId_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_fcoe)) {
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                    bcmFieldQualifyFibreChanVFTFabricId, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTHopCount
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTHopCount
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTHopCount(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (soc_feature(unit, soc_feature_fcoe)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanVFTHopCount,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTHopCount_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTHopCount
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTHopCount_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_fcoe)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFibreChanVFTHopCount, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTVsanId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTVsanId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTVsanId(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (soc_feature(unit, soc_feature_fcoe)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanVFTVsanId,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTVsanId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTVsanId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTVsanId_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_fcoe)) {
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                    bcmFieldQualifyFibreChanVFTVsanId, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTVsanPri
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTVsanPri
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTVsanPri(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (soc_feature(unit, soc_feature_fcoe)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanVFTVsanPri,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTVsanPri_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTVsanPri
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTVsanPri_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_fcoe)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFibreChanVFTVsanPri, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTValid
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTValid
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTValid(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (soc_feature(unit, soc_feature_fcoe)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFibreChanVFTValid,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTValid_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTValid
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTValid_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_fcoe)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFibreChanVFTValid, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeSOF
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFcoeSOF
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeSOF(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (soc_feature(unit, soc_feature_fcoe)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFcoeSOF,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeSOF_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFcoeSOF
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeSOF_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
    
    /* Read qualifier match value and mask. */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (soc_feature(unit, soc_feature_fcoe)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFcoeSOF, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeVersionIsZero
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFcoeVersionIsZero
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeVersionIsZero(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (soc_feature(unit, soc_feature_fcoe)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyFcoeVersionIsZero,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeVersionIsZero_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFcoeVersionIsZero
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeVersionIsZero_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
    
    /* Read qualifier match value and mask. */
#if defined(BCM_TRIDENT2_SUPPORT)
    if (soc_feature(unit, soc_feature_fcoe)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyFcoeVersionIsZero, data, mask);
    }
#endif
    return(rv);
}

/*
 * Function:
 *     bcm_esw_field_entry_operation
 * Purpose:
 *     Perform entry backup, restore and backup copy free operations
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     entry_oper - (IN) Pointer to field entry operation structure
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_entry_operation(int unit, bcm_field_entry_oper_t *entry_oper)
{
    /* Input parameter check. */
    if (entry_oper == NULL) {
        return (BCM_E_PARAM);
    }

    /* Invalid operation check. */
    if (entry_oper->flags & (~BCM_FIELD_ENTRY_OPER_MASK)) {
        return (BCM_E_PARAM);
    }

    if (entry_oper->flags & BCM_FIELD_ENTRY_OPER_BACKUP) {
        BCM_IF_ERROR_RETURN(_bcm_field_entry_backup(unit,
            entry_oper->entry_id));
    }

    if (entry_oper->flags & BCM_FIELD_ENTRY_OPER_RESTORE) {
        BCM_IF_ERROR_RETURN(_bcm_field_entry_restore(unit,
            entry_oper->entry_id));
    }

    if (entry_oper->flags & BCM_FIELD_ENTRY_OPER_CLEANUP) {
        BCM_IF_ERROR_RETURN(_bcm_field_entry_cleanup(unit,
            entry_oper->entry_id));
    }

    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamMdl
 * Purpose:
 *      Set match criteria for bcmFieildQualifyOamMdl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamMdl(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

    
    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamMdl,
                          data, mask);
    FP_UNLOCK(unit);

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamMdl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyOamMdl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamMdl_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyOamMdl, data, mask);

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamType
 * Purpose:
 *      Set match criteria for bcmFieildQualifyOamType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_type_t oam_type)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */
    uint32 mask = 0;

    
    FP_LOCK(unit);

    /* Include all bits for mask value */
    mask = BCM_FIELD_EXACT_MATCH_MASK;

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamType,
           oam_type, mask);
    FP_UNLOCK(unit);

    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyOamType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_type_t *oam_type)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */
    uint8 mask = 0;
    uint8 data = 0;

    if (oam_type == NULL) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
            bcmFieldQualifyOamType, &data, &mask);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    *oam_type = data;

    return(rv);
}



/*
 * Function:
 *     bcm_esw_field_qualify_OamHeaderBits0_31
 * Purpose:
 *      Set match criteria for bcmFieldQualifyOamHeaderBits0_31
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on First 4 Bytes of OAM Header
                       in Egress Pipeline.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamHeaderBits0_31(
    int unit, bcm_field_entry_t entry,
    uint32 data, uint32 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyOamHeaderBits0_31, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamHeaderBits0_31,
            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *     bcm_esw_field_qualify_OamHeaderBits0_31_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamHeaderBits0_31
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) First 4 Bytes of OAM Header
                        in Egress Pipeline.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamHeaderBits0_31_get(
    int unit, bcm_field_entry_t entry, uint32 *data,
    uint32 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint32_get(unit, entry,
                bcmFieldQualifyOamHeaderBits0_31,
                data, mask));

    return BCM_E_NONE;
}


/*
 * Function:
 *     bcm_esw_field_qualify_OamHeaderBits32_63
 * Purpose:
 *      Set match criteria for bcmFieldQualifyOamHeaderBits32_63
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Second 4 Bytes of OAM Header
                       in Egress Pipeline.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_OamHeaderBits32_63(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyOamHeaderBits32_63, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamHeaderBits32_63,
            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_OamHeaderBits32_63_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamHeaderBits32_63
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Second 4 Bytes of OAM Header
                        in Egress Pipeline.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_OamHeaderBits32_63_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint32_get(unit, entry,
                bcmFieldQualifyOamHeaderBits32_63,
                data, mask));

    return BCM_E_NONE;
}

/*
 * Function:
 *     bcm_esw_field_qualify_OamEgressClassPort
 * Purpose:
 *      Set match criteria for bcmFieldQualifyOamEgressClassPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualify the OAM ClassId obtained from EGR_PORT table
                       in Egress Pipeline.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_OamEgressClassPort(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyOamEgressClassPort, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }


    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamEgressClassPort,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_OamEgressClassPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamEgressClassPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) OAM ClassId obtained from EGR_PORT table
                        in Egress Pipeline.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_OamEgressClassPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint16_get(unit, entry,
                bcmFieldQualifyOamEgressClassPort,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     bcm_esw_field_qualify_OamEgressClassVxlt
 * Purpose:
 *      Set match criteria for bcmFieldQualifyOamEgressClassVxlt
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualify the OAM ClassId obtained from Vlan_Xlate table
                       in Egress Pipeline.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_OamEgressClassVxlt(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyOamEgressClassVxlt, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamEgressClassVxlt,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}
/*
 * Function:
 *     bcm_esw_field_qualify_OamEgressClassVxlt_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamEgressClassVxlt
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) OAM ClassId obtained from Vlan_Xlate table
                        in Egress Pipeline.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_OamEgressClassVxlt_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint16_get(unit, entry,
                bcmFieldQualifyOamEgressClassVxlt,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *    bcm_esw_field_qualify_EthernetOamHeaderBits0_31
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamHeaderBits0_31
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on First 4 Bytes of Ethernet OAM Header.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamHeaderBits0_31(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyEthernetOamHeaderBits0_31, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyEthernetOamHeaderBits0_31,
            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamHeaderBits0_31_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamHeaderBits0_31
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) First 4 Bytes of Ethernet OAM Header.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamHeaderBits0_31_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint32_get(unit, entry,
                bcmFieldQualifyEthernetOamHeaderBits0_31,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamHeaderBits32_63
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamHeaderBits32_63
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Second 4 Bytes of Ethernet OAM Header.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_EthernetOamHeaderBits32_63(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyEthernetOamHeaderBits32_63, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyEthernetOamHeaderBits32_63,
            data, mask);

    FP_UNLOCK(unit);
    return (rv);

}
/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamHeaderBits32_63_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamHeaderBit32_63
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Second 4 Bytes of Ethernet OAM Header.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_EthernetOamHeaderBits32_63_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint32_get(unit, entry,
                bcmFieldQualifyEthernetOamHeaderBits32_63,
                data, mask));

    return (BCM_E_NONE);
}
/*
 * Function:
 *     bcm_esw_field_qualifyEthernetOamDstClassL2
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamDstClassL2
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
                       DstMac lookup in L2 table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamDstClassL2(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
                bcmFieldQualifyEthernetOamDstClassL2, entry,
                &data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyEthernetOamDstClassL2,
            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamDstClassL2_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamDstClassL2
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from DstMac lookup in L2 table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_EthernetOamDstClassL2_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyEthernetOamDstClassL2,
                data, mask));

    return (BCM_E_NONE);
}
/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamTxPktUPMEP
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamTxPktUPMEP
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Ethernet OAM UP-MEP Tx Pkt.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamTxPktUPMEP(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyEthernetOamTxPktUPMEP, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }


    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyEthernetOamTxPktUPMEP,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamTxPktUPMEP_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamTxPktUPMEP
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Ethernet OAM UP-MEP Tx Pkt.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamTxPktUPMEP_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyEthernetOamTxPktUPMEP,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     bcm_esw_field_qualifyEthernetOamInterfaceClassPort
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamInterfaceClassPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
                       Source trunk map table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassPort(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyEthernetOamInterfaceClassPort, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyEthernetOamInterfaceClassPort,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamInterfaceClassPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from Source trunk map table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyEthernetOamInterfaceClassPort,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeyFirst
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamClassVxlt1
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
                       1st Lookup of Vlan_Xlate table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeyFirst(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyEthernetOamClassVlanTranslateKeyFirst, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyEthernetOamClassVlanTranslateKeyFirst,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeyFirst_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamClassVxlt1
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from 1st Lookup of Vlan_Xlate table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeyFirst_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyEthernetOamClassVlanTranslateKeyFirst,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeySecond
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamClassVxlt2
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
                       2nd Lookup of Vlan_Xlate table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeySecond(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyEthernetOamClassVlanTranslateKeySecond, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyEthernetOamClassVlanTranslateKeySecond,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeySecond_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamClassVxlt2
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from 2nd Lookup of Vlan_Xlate table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeySecond_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyEthernetOamClassVlanTranslateKeySecond,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassVlan
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamInterfaceClassVlan
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
 SVP table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassVlan(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyEthernetOamInterfaceClassVlan, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyEthernetOamInterfaceClassVlan,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassVlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamInterfaceClassVlan
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from SVP table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassVlan_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyEthernetOamInterfaceClassVlan,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassVxlan
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamInterfaceClassVxlan
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
                       SVP table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassVxlan(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyEthernetOamInterfaceClassVxlan, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyEthernetOamInterfaceClassVxlan,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassVxlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamInterfaceClassVxlan
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from SVP table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassVxlan_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyEthernetOamInterfaceClassVxlan,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassMim
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamInterfaceClassMim
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
 SVP table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassMim(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyEthernetOamInterfaceClassMim, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyEthernetOamInterfaceClassMim,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassMim_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamInterfaceClassMim
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from SVP table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassMim_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyEthernetOamInterfaceClassMim,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassNiv
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamInterfaceClassNiv
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
 SVP table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassNiv(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyEthernetOamInterfaceClassNiv, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyEthernetOamInterfaceClassNiv,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassNiv_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamInterfaceClassNiv
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from SVP table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassNiv_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyEthernetOamInterfaceClassNiv,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassMpls
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamInterfaceClassMpls
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
 SVP table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassMpls(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyEthernetOamInterfaceClassMpls, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyEthernetOamInterfaceClassMpls,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassMpls_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamInterfaceClassMpls
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from SVP table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassMpls_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyEthernetOamInterfaceClassMpls,
                data, mask));

    return (BCM_E_NONE);
}


/*
 * Function:
 *     bcm_esw_field_qualifyEthernetOamClassVpn
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamClassVpn
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
                       VFI table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamClassVpn(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyEthernetOamClassVpn, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyEthernetOamClassVpn,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamClassVpn_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamClassVpn
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from VFI table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_EthernetOamClassVpn_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyEthernetOamClassVpn,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *    bcm_esw_field_qualify_MplsOamHeaderBits0_31
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamHeaderBits0_31
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on First 4 Bytes of MPLS OAM Header.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamHeaderBits0_31(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyMplsOamHeaderBits0_31, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsOamHeaderBits0_31,
            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamHeaderBits0_31_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamHeaderBits0_31
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) First 4 Bytes of MPLS OAM Header.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamHeaderBits0_31_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint32_get(unit, entry,
                bcmFieldQualifyMplsOamHeaderBits0_31,
                data, mask));

    return BCM_E_NONE;
}


/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamHeaderBits32_63
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamHeaderBits32_63
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Second 4 Bytes of MPLS OAM Header.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamHeaderBits32_63(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyMplsOamHeaderBits32_63, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsOamHeaderBits32_63,
            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamHeaderBits32_63_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamHeaderBits32_63
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Second 4 Bytes of MPLS OAM Header.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamHeaderBits32_63_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint32_get(unit, entry,
                bcmFieldQualifyMplsOamHeaderBits32_63,
                data, mask));

    return BCM_E_NONE;
}

/*
 * Function:
 *    bcm_esw_field_qualify_MplsOamGALLabelOnly
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamGALLabelOnly
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies MPLS OAM packets with
                       single label only that is GAL label.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamGALLabelOnly(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyMplsOamGALLabelOnly, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsOamGALLabelOnly,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamGALLabelOnly_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamGALLabelOnly
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) MPLS OAM packets with
                        single label only that is GAL label.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamGALLabelOnly_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyMplsOamGALLabelOnly,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *    bcm_esw_field_qualify_MplsOamUpperLabelDataDrop 
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamUpperLabelDataDrop
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
 SVP table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamUpperLabelDataDrop(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyMplsOamUpperLabelDataDrop, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }


    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyMplsOamUpperLabelDataDrop,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamUpperLabelDataDrop_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamUpperLabelDataDrop
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from SVP table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamUpperLabelDataDrop_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyMplsOamUpperLabelDataDrop,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *    bcm_esw_field_qualify_MplsOamGALExposed
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamGALExposed
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies MPLS OAM packets which has GAL Exposed.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamGALExposed(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyMplsOamGALExposed, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsOamGALExposed,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamGALExposed_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamGALExposed
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) MPLS OAM packets which has GAL Exposed.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamGALExposed_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyMplsOamGALExposed,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *    bcm_esw_field_qualify_MplsOamACH
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamACH
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies MPLS OAM ACH Header.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamACH(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
            bcmFieldQualifyMplsOamACH, entry,
            (uint8 *)&data, sizeof (data));

    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsOamACH,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamACH_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamACH
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) MPLS OAM ACH Header.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamACH_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint32_get(unit, entry,
                bcmFieldQualifyMplsOamACH,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *    bcm_esw_field_qualify_MplsOamControlPktType
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamControlPktType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualify the MPLS OAM Control Packets
                       based on packet type.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamControlPktType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_MplsOam_Control_pktType_t data)
{
    int rv;                 /* Operation return status. */
    uint32 mask = 0;

    
    FP_LOCK(unit);

    mask = BCM_FIELD_EXACT_MATCH_MASK;

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsOamControlPktType,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamControlPktType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamControlPktType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) MPLS OAM Control Packets based on packet type.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_MplsOamControlPktType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_MplsOam_Control_pktType_t *data)
{
    uint32 mask = 0;
    int rv = BCM_E_NONE;

    if (data == NULL) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
            bcmFieldQualifyMplsOamControlPktType,
            data, &mask);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamClassMplsSwitchLabel
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamClassMpls
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from 
                       MPLS_ENTRY table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamClassMplsSwitchLabel(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv;                 /* Operation return status. */

    /* Input range check */
    rv = _field_qualifier32_input_range_check(unit,
                bcmFieldQualifyMplsOamClassMplsSwitchLabel, entry,
                (uint8 *)&data, sizeof (data));
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: data=%#x "
                            "out-of-range\n"), unit, data));
        return rv;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyMplsOamClassMplsSwitchLabel,
            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamClassMplsSwitchLabel_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamClassMpls
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from MPLS_ENTRY table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamClassMplsSwitchLabel_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(
            _bcm_field_entry_qualifier_uint16_get(unit, entry,
                bcmFieldQualifyMplsOamClassMplsSwitchLabel,
                data, mask));

    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qset_id_multi_set
 * Purpose:
 *      Add qualifier objects to field group qset.
 * Parameters:
 *      unit                - (IN) Unit number.
 *      qualifier           - (IN) Type of objects.
 *      num_objects         - (IN)  Number of objects.
 *      object_list         - (IN)  Number of objects (Ex; UDF ids).
 *      qset                - (OUT) Qualifier set.
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_field_qset_id_multi_set(
    int unit,
    bcm_field_qualify_t qualifier,
    int num_objects,
    int objects_list[],
    bcm_field_qset_t *qset
    )
{

    FIELD_IS_INIT(unit);

    /* Input parameters check. */
    if (NULL == qset) {
        return (BCM_E_PARAM);
    }

    if (soc_feature(unit, soc_feature_udf_td3x_support)) {
        _field_control_t *fc;
        int rv = BCM_E_UNAVAIL;

        _BCM_UDF_INIT_CHECK(unit);

        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
  
        if (fc->functions.fp_qset_id_multi_set != NULL) {
           _BCM_UDF_LOCK(unit);  
           rv = fc->functions.fp_qset_id_multi_set(unit, qualifier,
                                                   num_objects,
                                                   objects_list,
                                                   qset);
           _BCM_UDF_UNLOCK(unit);  
        }
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined(BCM_TRIUMPH2_SUPPORT)
    UDF_INIT_CHECK(unit);
    if (soc_feature(unit, soc_feature_udf_support)) {
        if (qualifier == bcmFieldQualifyUdf) {
            return bcmi_xgs4_field_qset_udf_id_multi_set(unit, 
                     num_objects, objects_list, qset);
        }
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

    return (BCM_E_UNAVAIL);
}

/*
 * Function:
 *      bcm_esw_field_qset_id_multi_get
 * Purpose:
 *      Get qualifier objects added to the field group qset.
 * Parameters:
 *      unit                - (IN)  Unit number.
 *      qset                - (IN)  Qualifier set.
 *      max                 - (IN)  Max number of objects.
 *      object_list         - (OUT) List of objects (Ex; UDF ids).
 *      actual              - (OUT) Number of objects.
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_field_qset_id_multi_get(
    int unit,
    bcm_field_qset_t qset,
    bcm_field_qualify_t qualifier,
    int max,
    int *objects_list,
    int *actual
    )
{
    FIELD_IS_INIT(unit);

    if (actual == NULL) {
        return BCM_E_PARAM;
    }

    if (soc_feature(unit, soc_feature_udf_td3x_support)) {
        _field_control_t *fc;
        int rv = BCM_E_UNAVAIL;

        _BCM_UDF_INIT_CHECK(unit);

        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
  
        if (fc->functions.fp_qset_id_multi_get != NULL) {
           _BCM_UDF_LOCK(unit);  
           rv = fc->functions.fp_qset_id_multi_get(unit,
                                                   qset,
                                                   qualifier,
                                                   max,
                                                   objects_list,
                                                   actual);
           _BCM_UDF_UNLOCK(unit);  
        }
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined (BCM_TRIUMPH2_SUPPORT)
    UDF_INIT_CHECK(unit);
    if (soc_feature(unit, soc_feature_udf_support)) {
        if (qualifier == bcmFieldQualifyUdf) {
            return bcmi_xgs4_field_qset_udf_id_multi_get(unit, qset, max,
                                                         objects_list, actual);
        }
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

    return (BCM_E_UNAVAIL);

}


/*
 * Function:
 *      bcm_esw_field_qset_id_multi_delete
 * Purpose:
 *      Delete qualifier objects to field group qset.
 * Parameters:
 *      unit                - (IN)  Unit number.
 *      num_objects         - (IN)  Number of objects.
 *      object_list         - (IN)  List of objects (Ex; UDF ids).
 *      qset                - (OUT) Qualifier set.
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_field_qset_id_multi_delete(
    int unit,
    bcm_field_qualify_t qualifier,
    int num_objects,
    int objects_list[],
    bcm_field_qset_t *qset
    )
{
    FIELD_IS_INIT(unit);

    if (qset == NULL) {
        return BCM_E_PARAM;
    }

    if (soc_feature(unit, soc_feature_udf_td3x_support)) {
        _field_control_t *fc;
        int rv = BCM_E_UNAVAIL;

        _BCM_UDF_INIT_CHECK(unit);

        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
  
        if (fc->functions.fp_qset_id_multi_delete != NULL) {
           _BCM_UDF_LOCK(unit);  
           rv = fc->functions.fp_qset_id_multi_delete(unit,
                                                      qualifier,
                                                      num_objects,
                                                      objects_list,
                                                      qset);
           _BCM_UDF_UNLOCK(unit);  
        }
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined (BCM_TRIUMPH2_SUPPORT)
    UDF_INIT_CHECK(unit);
    if (soc_feature(unit, soc_feature_udf_support)) {
        if (qualifier == bcmFieldQualifyUdf) {
            return bcmi_xgs4_field_qset_udf_id_multi_delete(unit, num_objects,
                                                            objects_list, qset);
        }
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

    return (BCM_E_UNAVAIL);
}

/*
 * Function:
 *      bcm_esw_field_qualify_udf
 * Purpose:
 *      Add UDF data that the packet must match to trigger qualifier.
 * Parameters:
 *      unit            - (IN)  Unit number.
 *      eid             - (IN)  Field Entry.
 *      udf_id          - (IN)  UDF ID.
 *      length          - (IN)  Number of bytes to match in field entry.
 *      data            - (IN)  Input data to qualify the entry.
 *      mask            - (IN)  Input mask to qualify the entry.
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int
bcm_esw_field_qualify_udf(int unit, bcm_field_entry_t eid, bcm_udf_id_t udf_id,
                          int length, uint8 *data, uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TOMAHAWK3_SUPPORT)
    _field_entry_t      *f_ent;      /* Field entry pointer.     */
#endif

    FIELD_IS_INIT(unit);

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    if (soc_feature(unit, soc_feature_udf_td3x_support)) {
        _field_control_t *fc;
        int rv = BCM_E_UNAVAIL;

        _BCM_UDF_INIT_CHECK(unit);

        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
  
        if (fc->functions.fp_qualify_udf != NULL) {
           _BCM_UDF_LOCK(unit);  
           rv = fc->functions.fp_qualify_udf(unit, eid, udf_id,
                                            length, data, mask);
           _BCM_UDF_UNLOCK(unit);  
        }
        FP_UNLOCK(unit);
        return (rv);
    }

    
#if defined(BCM_TOMAHAWK3_SUPPORT)
    FP_LOCK(unit);
    /* Get field entry structure pointer. */
    rv = _field_entry_get(unit, eid, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    UDF_INIT_CHECK(unit);
    if (soc_feature(unit, soc_feature_udf_selector_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_LOOKUP) ||
         (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {
        UDF_LOCK(unit);
        rv = _bcm_field_th3_qualify_udf(unit, eid, udf_id,
                                        length, data, mask);
        FP_UNLOCK(unit);
        UDF_UNLOCK(unit);
        return rv;

    } else {
        FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK3_SUPPORT */

#if defined(BCM_TRIUMPH2_SUPPORT)
    UDF_INIT_CHECK(unit);
    if (soc_feature(unit, soc_feature_udf_support)) {
        return bcmi_xgs4_field_qualify_udf_data(unit, eid, udf_id,
                                              length, data, mask);
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_udf_get
 * Purpose:
 *      Get data/mask qualified on an entry corresponding to a UDF ID.
 * Parameters:
 *      unit            - (IN)  Unit number.
 *      eid             - (IN)  Field Entry.
 *      udf_id          - (IN)  UDF ID.
 *      max_length      - (IN)  Length of bytes of data/mask to fetch.
 *      data            - (OUT) Data to qualify the entry.
 *      mask            - (OUT  Mask to qualify the entry.
 *      actual_length   - (OUT) Length of bytes of data/mask fetched.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_udf_get(int unit, bcm_field_entry_t eid,
                              bcm_udf_id_t udf_id, int max_length,
                              uint8 *data, uint8 *mask, int *actual_length)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TOMAHAWK3_SUPPORT)
    _field_entry_t      *f_ent;      /* Field entry pointer.     */
#endif

    FIELD_IS_INIT(unit);

    if (soc_feature(unit, soc_feature_udf_td3x_support)) {
        _field_control_t *fc;
        int rv = BCM_E_UNAVAIL;

        _BCM_UDF_INIT_CHECK(unit);

        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
  
        if (fc->functions.fp_qualify_udf_get != NULL) {
           _BCM_UDF_LOCK(unit);  
           rv = fc->functions.fp_qualify_udf_get(unit, eid, udf_id,
                                                 max_length, data, mask,
                                                 actual_length);
           _BCM_UDF_UNLOCK(unit);  
        }
        FP_UNLOCK(unit);
        return (rv);
    }

#if defined (BCM_TOMAHAWK3_SUPPORT)
    FP_LOCK(unit);
    /* Get field entry structure pointer. */
    rv = _field_entry_get(unit, eid, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    UDF_INIT_CHECK(unit);
    if (soc_feature(unit, soc_feature_udf_selector_support) &&
        ((f_ent->group->stage_id == _BCM_FIELD_STAGE_INGRESS) ||
        (f_ent->group->stage_id == _BCM_FIELD_STAGE_LOOKUP) ||
         (f_ent->group->stage_id == _BCM_FIELD_STAGE_EXACTMATCH))) {

        UDF_LOCK(unit);
        rv = _bcm_field_th3_qualify_udf_get(unit, eid, udf_id, max_length,
                                               data, mask, actual_length);
        FP_UNLOCK(unit);
        UDF_UNLOCK(unit);
        return rv;

    } else {
        FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK3_SUPPORT */

#if defined (BCM_TRIUMPH2_SUPPORT)
    UDF_INIT_CHECK(unit);
    if (soc_feature(unit, soc_feature_udf_support)) {
        return bcmi_xgs4_field_qualify_udf_get(unit, eid, udf_id, max_length,
                                               data, mask, actual_length);
    }
#endif /* BCM_TRIUMPH2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcVlanGports
 * Purpose:
 *      Add source vlan port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      vlan_port_id - (IN) Vlan virtual port id.
 *      vlan_port_mask - (IN) Vlan virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcVlanGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t vlan_port_id,
    bcm_gport_t vlan_port_mask)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    _field_group_t *fg;     /* Field group structure    */
    uint32 data = 0;        /* HW data match criteria.  */
    uint32 mask = 0;        /* HW data mask.            */
    int rv;                 /* Operation return status. */
    int ingress_entity = 0; /* Ingress entity or source entity */
    int i;

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_VLAN_PORT(vlan_port_id)) {
        return (BCM_E_PARAM);
    }

    if (vlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_GPORT_IS_VLAN_PORT(vlan_port_mask)) {
            return (BCM_E_PARAM);
        }
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

    /* Get the source virtual port value and mask*/
    data  = BCM_GPORT_VLAN_PORT_ID_GET(vlan_port_id);

    if (vlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask  = BCM_GPORT_VLAN_PORT_ID_GET(vlan_port_mask);
    } else {
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
#if defined(BCM_TOMAHAWK_SUPPORT)
    /*
     * Invoke driver function for multi pipe supported devices.
     */ 
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_svp(unit, entry,
                                          bcmFieldQualifySrcVlanGports,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check which configuration of SrcVlanGport is in use */
    for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
        if (fg->sel_codes[i].ingress_entity_sel ==
                   _bcmFieldFwdEntityVlanGport) {
            ingress_entity = 1;
            break;
        }
    }

    FP_LOCK(unit);

    if (ingress_entity) {
        /* Internal qualifier to set SVP valid bit in Fixed field */
        rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 1, 1);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    /* Qualify Vlan Source Virtual Port */
    /* In Stage Lookup bcmFieldQualifySrcVlanGports = 20 bits
       S_FIELD = 16 bits S_TYPE_SEL = 3 bits SVP_VALID = 1 bits
       S_TYPE_SEL = 0 and SVP_VALID = 1 implies S_FIELD = svp
       ==> data = svp_valid|s_type_sel|s_field
     */
    rv = _field_qualify_source_virtual_port(unit, entry,
            bcmFieldQualifySrcVlanGports, data, mask, ingress_entity);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_SrcVlanGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcVlanGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      vlan_port_id - (OUT) Vlan port id.
 *      vlan_port_mask - (OUT) Vlan port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcVlanGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *vlan_port_id,
    bcm_gport_t *vlan_port_mask)
{
    uint32 data = 0;   /* HW encoded qualifier data.  */
    uint32 mask = 0;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == vlan_port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifySrcVlanGports,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       data &=  0x1fff;
    }
    BCM_GPORT_VLAN_PORT_ID_SET(*vlan_port_id, data);
    BCM_GPORT_VLAN_PORT_ID_SET(*vlan_port_mask, mask);

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstVlanGports
 * Purpose:
 *      Add destination vlan port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      vlan_port_id - (IN) Vlan virtual port id.
 *      vlan_port_mask - (IN) Vlan virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstVlanGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t vlan_port_id,
    bcm_gport_t vlan_port_mask)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    uint32 data = 0;        /* HW data match criteria.  */
    uint32 mask = 0;        /* HW data mask.            */
    int rv;                 /* Operation return status. */
    _field_entry_t *f_ent;  /* Field entry structure.   */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_VLAN_PORT(vlan_port_id)) {
        return (BCM_E_PARAM);
    }

    if (vlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_GPORT_IS_VLAN_PORT(vlan_port_mask)) {
            return (BCM_E_PARAM);
        }
    }

    data  = BCM_GPORT_VLAN_PORT_ID_GET(vlan_port_id);

    if (vlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask  = BCM_GPORT_VLAN_PORT_ID_GET(vlan_port_mask);
    } else {
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
                        bcmFieldQualifyDstVlanGports, &f_ent));
    /*
     * Invoke driver function for multi pipe supported devices.
     */
     
#if defined(BCM_TOMAHAWK_SUPPORT)
     if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
         (_BCM_FIELD_STAGE_EGRESS != f_ent->group->stage_id)) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstVlanGports,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
     }
#endif /* BCM_TOMAHAWK_SUPPORT */


    FP_LOCK(unit);

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /*
         * LSB is DVP valid bit.
         * Shift DVP value by 1-bit ,
         */
        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;

        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask <<= 1;
            mask |=1;
        }
    } else {
        /* Qualify the destination type qualifier */
        rv = _field_dest_type_qualify(unit, entry,
                                      bcmFieldQualifyDstVlanGports, 
                                      &data, &mask, 
                                      _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstVlanGports,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstVlanGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstVlanGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      vlan_port_id - (OUT) Vlan port id.
 *      vlan_port_mask - (OUT) Vlan port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstVlanGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *vlan_port_id,
    bcm_gport_t *vlan_port_mask)
{
    uint32 data = 0;       /* HW encoded qualifier data.  */
    uint32 mask = 0;       /* HW encoding qualifier mask. */
    int rv;                /* Operation return status.    */
    _field_entry_t *f_ent; /* Field entry structure. */

    /* Input parameters check. */
    if ((NULL == vlan_port_id) || (NULL == vlan_port_mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyDstVlanGports,
                                            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
        bcmFieldQualifyDstVlanGports, &f_ent));

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
         /* Clear DVP Valid bit. */
         data >>= 1;
        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask >>= 1;
        }
    } else {
        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
            entry, bcmFieldQualifyDstVlanGports, &data, &mask));
    }

    BCM_GPORT_VLAN_PORT_ID_SET(*vlan_port_id, data);
    BCM_GPORT_VLAN_PORT_ID_SET(*vlan_port_mask, mask);

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcVxlanGports
 * Purpose:
 *      Add source vxlan port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      vxlan_port_id - (IN) Vxlan virtual port id.
 *      vxlan_port_mask - (IN) Vxlan virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcVxlanGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t vxlan_port_id,
    bcm_gport_t vxlan_port_mask)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    _field_group_t *fg;     /* Field group structure    */
    _field_entry_t *f_ent = NULL;  /* Field entry structure.   */
    uint32 data = 0;        /* HW data match criteria.  */
    uint32 mask = 0;        /* HW data mask.            */
    int rv;                 /* Operation return status. */
    int ingress_entity = 0; /* Ingress entity or source entity */
    int i;

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_VXLAN_PORT(vxlan_port_id)
        && (0 == BCM_GPORT_IS_FLOW_PORT(vxlan_port_id))) {
        return (BCM_E_PARAM);
    }

    if (vxlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if ((0 == BCM_GPORT_IS_VXLAN_PORT(vxlan_port_mask)
            && (0 == BCM_GPORT_IS_FLOW_PORT(vxlan_port_mask)))) {
            return (BCM_E_PARAM);
        }
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
            bcmFieldQualifySrcVxlanGports, &f_ent));
    /* Get the source virtual port value and mask*/
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    if (soc_feature(unit, soc_feature_flex_flow)
        && BCM_GPORT_IS_FLOW_PORT(vxlan_port_id)) {
        data  = BCM_GPORT_FLOW_PORT_ID_GET(vxlan_port_id);
        f_ent->svp_type = _bcmVpTypeFlow;
        if (vxlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask = BCM_GPORT_FLOW_PORT_ID_GET(vxlan_port_mask);
        } else {
            /* Include all bits for Mask value */
            mask = BCM_FIELD_EXACT_MATCH_MASK;
        }
    } else {
        data  = BCM_GPORT_VXLAN_PORT_ID_GET(vxlan_port_id);
        f_ent->svp_type = _bcmVpTypeVxlan;
        if (vxlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask = BCM_GPORT_VXLAN_PORT_ID_GET(vxlan_port_mask);
        } else {
            /* Include all bits for Mask value */
            mask = BCM_FIELD_EXACT_MATCH_MASK;
        }
    }
#else
    data  = BCM_GPORT_VXLAN_PORT_ID_GET(vxlan_port_id);
    if (vxlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask = BCM_GPORT_VXLAN_PORT_ID_GET(vxlan_port_mask);
    } else {
        /* Include all bits for Mask value */
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }
#endif

#if defined(BCM_TOMAHAWK_SUPPORT)
    /*
     * Invoke driver function for multi pipe supported devices.
     */ 
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_svp(unit, entry,
                                          bcmFieldQualifySrcVxlanGports,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check which configuration of SrcVlanGport is in use */
    for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
        if (fg->sel_codes[i].ingress_entity_sel ==
                    _bcmFieldFwdEntityVxlanGport) {
            ingress_entity = 1;
            break;
        }
    }

    FP_LOCK(unit);

    if (ingress_entity) {
        /* Internal qualifier to set SVP valid bit in Fixed field */
        rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 1, 1);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    /* Qualify Vxlan Source Virtual Port */
    /* In Stage Lookup bcmFieldQualifySrcVxlanGports = 20 bits
       S_FIELD = 16 bits S_TYPE_SEL = 3 bits SVP_VALID = 1 bits
       S_TYPE_SEL = 0 and SVP_VALID = 1 implies S_FIELD = svp
       ==> data = svp_valid|s_type_sel|s_field
     */
    rv = _field_qualify_source_virtual_port(unit, entry,
            bcmFieldQualifySrcVxlanGports, data, mask, ingress_entity);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcVxlanGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcVxlanGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      vxlan_port_id - (OUT) Vxlan port id.
 *      vxlan_port_mask - (OUT) Vxlan port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcVxlanGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *vxlan_port_id,
    bcm_gport_t *vxlan_port_mask)
{
    uint32 data = 0;   /* HW encoded qualifier data.  */
    uint32 mask = 0;   /* HW encoding qualifier mask. */
    int rv;            /* Operation return status.    */
    _field_entry_t *f_ent = NULL;  /* Field entry structure.   */

    /* Input parameters check. */
    if (NULL == vxlan_port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifySrcVxlanGports,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       data &=  0x1fff;
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
            bcmFieldQualifySrcVxlanGports, &f_ent));

#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    switch (f_ent->svp_type) {
        case _bcmVpTypeFlow :
            BCM_GPORT_FLOW_PORT_ID_SET(*vxlan_port_id, data);
            BCM_GPORT_FLOW_PORT_ID_SET(*vxlan_port_mask, mask);
            break;
        case _bcmVpTypeVxlan:
            BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_id, data);
            BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_mask, mask);
            break;
        default:
            BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_id, data);
            BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_mask, mask);
    }
#else
    BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_id, data);
    BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_mask, mask);
#endif
    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstVxlanGports
 * Purpose:
 *      Add destination vxlan port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      vxlan_port_id - (IN) Vxlan virtual port id.
 *      vxlan_port_mask - (IN) Vxlan virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstVxlanGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t vxlan_port_id,
    bcm_gport_t vxlan_port_mask)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    uint32 data = 0;        /* HW data match criteria.  */
    uint32 mask = 0;        /* HW data mask.            */
    int rv;                 /* Operation return status. */
    _field_entry_t *f_ent;  /* Field entry structure.   */

    /* Input parameters check. */
    if ((0 == BCM_GPORT_IS_VXLAN_PORT(vxlan_port_id)) &&
        (0 == BCM_GPORT_IS_FLOW_PORT(vxlan_port_id))) {
        return (BCM_E_PARAM);
    }
    if (vxlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if ((0 == BCM_GPORT_IS_VXLAN_PORT(vxlan_port_mask))
            && (0 == (BCM_GPORT_IS_FLOW_PORT(vxlan_port_mask)))) {
            return (BCM_E_PARAM);
        }
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
                        bcmFieldQualifyDstVxlanGports, &f_ent));

#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    /* Get the destiantion virtual port value and mask*/
    if (soc_feature(unit, soc_feature_flex_flow)
        && BCM_GPORT_IS_FLOW_PORT(vxlan_port_id)) {
        data  = BCM_GPORT_FLOW_PORT_ID_GET(vxlan_port_id);
        f_ent->dvp_type = _bcmVpTypeFlow;
        if (vxlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask = BCM_GPORT_FLOW_PORT_ID_GET(vxlan_port_mask);
        } else {
            /* Include all bits for Mask value */
            mask = BCM_FIELD_EXACT_MATCH_MASK;
        }
    } else {
        data  = BCM_GPORT_VXLAN_PORT_ID_GET(vxlan_port_id);
        f_ent->dvp_type = _bcmVpTypeVxlan;
        if (vxlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask = BCM_GPORT_VXLAN_PORT_ID_GET(vxlan_port_mask);
        } else {
            /* Include all bits for Mask value */
            mask = BCM_FIELD_EXACT_MATCH_MASK;
        }
    }
#else
    data  = BCM_GPORT_VXLAN_PORT_ID_GET(vxlan_port_id);
    if (vxlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask = BCM_GPORT_VXLAN_PORT_ID_GET(vxlan_port_mask);
    } else {
        /* Include all bits for Mask value */
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }
#endif
    /*
     * Invoke driver function for multi pipe supported devices.
     */
     
#if defined(BCM_TOMAHAWK_SUPPORT)
     if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
         (_BCM_FIELD_STAGE_EGRESS != f_ent->group->stage_id)) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
            rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstVxlanGports,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
     }
#endif /* BCM_TOMAHAWK_SUPPORT */

    FP_LOCK(unit);

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /*
         * LSB is DVP valid bit.
         * Shift DVP value by 1-bit,
         */
        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;

        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask <<= 1;
            mask |=1;
        }
#if defined(BCM_TRIDENT2_SUPPORT)
        /* Set the DVP TYPE to 2  for VxlanDstPorts */
        if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
            data |= (2 << 17);
            mask |= (3 << 17);
        }
#endif
    } else {
        /* Qualify the destination type qualifier */
        rv = _field_dest_type_qualify(unit, entry,
                                      bcmFieldQualifyDstVxlanGports, 
                                      &data, &mask, 
                                      _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstVxlanGports,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstVxlanGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstVxlanGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      vxlan_port_id - (OUT) Vxlan port id.
 *      vxlan_port_mask - (OUT) Vxlan port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstVxlanGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *vxlan_port_id,
    bcm_gport_t *vxlan_port_mask)
{
    uint32 data = 0;       /* HW encoded qualifier data.  */
    uint32 mask = 0;       /* HW encoding qualifier mask. */
    int rv;                /* Operation return status.    */
    _field_entry_t *f_ent = NULL ; /* Field entry structure. */

    /* Input parameters check. */
    if ((NULL == vxlan_port_id) || (NULL == vxlan_port_mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyDstVxlanGports,
                                            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
        bcmFieldQualifyDstVxlanGports, &f_ent));

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
#if defined(BCM_TRIDENT2_SUPPORT)
        /* Clear DVP TYPE in data and mask */
        if ((SOC_IS_TRIDENT2X(unit) || SOC_IS_TITAN2PLUS(unit))) {
            data &= ~(2 << 17);
            mask &= ~(3 << 17);
        }
#endif
         /* Clear DVP Valid bit. */
         data >>= 1;

        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask >>= 1;
        }
    } else {
        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
            entry, bcmFieldQualifyDstVxlanGports, &data, &mask));
    }

#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    switch (f_ent->dvp_type) {
        case _bcmVpTypeFlow :
            BCM_GPORT_FLOW_PORT_ID_SET(*vxlan_port_id, data);
            BCM_GPORT_FLOW_PORT_ID_SET(*vxlan_port_mask, mask);
            break;
        case _bcmVpTypeVxlan:
            BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_id, data);
            BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_mask, mask);
            break;
        default:
            BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_id, data);
            BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_mask, mask);
    }
#else
    BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_id, data);
    BCM_GPORT_VXLAN_PORT_ID_SET(*vxlan_port_mask, mask);
#endif

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcWlanGports
 * Purpose:
 *      Add source wlan port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      wlan_port_id - (IN) Wlan virtual port id.
 *      wlan_port_mask - (IN) Wlan virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcWlanGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t wlan_port_id,
    bcm_gport_t wlan_port_mask)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    _field_group_t *fg;     /* Field group structure    */
    uint32 data = 0;        /* HW data match criteria.  */
    uint32 mask = 0;        /* HW data mask.            */
    int rv;                 /* Operation return status. */
    int ingress_entity = 0; /* Ingress entity or source entity */
    int i;

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_WLAN_PORT(wlan_port_id)) {
        return (BCM_E_PARAM);
    }

    if (wlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_GPORT_IS_WLAN_PORT(wlan_port_mask)) {
            return (BCM_E_PARAM);
        }
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

    /* Get the source virtual port value and mask*/
    data  = BCM_GPORT_WLAN_PORT_ID_GET(wlan_port_id);

    if (wlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask  = BCM_GPORT_WLAN_PORT_ID_GET(wlan_port_mask);
    } else {
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
#if defined(BCM_TOMAHAWK_SUPPORT)
    /*
     * Invoke driver function for multi pipe supported devices.
     */ 
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_svp(unit, entry,
                                          bcmFieldQualifySrcWlanGports,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check which configuration of SrcWlanGport is in use */
    for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
        if (fg->sel_codes[i].ingress_entity_sel ==
                _bcmFieldFwdEntityWlanGport) {
            ingress_entity = 1;
            break;
        }
    }

    FP_LOCK(unit);

    if (ingress_entity) {
        /* Internal qualifier to set SVP valid bit in Fixed field */
        rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 1, 1);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    /* Qualify Wlan Source Virtual Port */
    /* In Stage Lookup bcmFieldQualifySrcWlanGports = 20 bits
       S_FIELD = 16 bits S_TYPE_SEL = 3 bits SVP_VALID = 1 bits
       S_TYPE_SEL = 0 and SVP_VALID = 1 implies S_FIELD = svp
       ==> data = svp_valid|s_type_sel|s_field
     */
    rv = _field_qualify_source_virtual_port(unit, entry,
            bcmFieldQualifySrcWlanGports, data, mask, ingress_entity);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcWlanGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcWlanGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      wlan_port_id - (OUT) Wlan port id.
 *      wlan_port_mask - (OUT) Wlan port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcWlanGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *wlan_port_id,
    bcm_gport_t *wlan_port_mask)
{
    uint32 data = 0;   /* HW encoded qualifier data.  */
    uint32 mask = 0;   /* HW encoding qualifier mask. */
    int rv;            /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == wlan_port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifySrcWlanGports,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       data &=  0x1fff;
    }
    BCM_GPORT_WLAN_PORT_ID_SET(*wlan_port_id, data);
    BCM_GPORT_WLAN_PORT_ID_SET(*wlan_port_mask, mask);

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstWlanGports
 * Purpose:
 *      Add destination wlan port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      wlan_port_id - (IN) Wlan virtual port id.
 *      wlan_port_mask - (IN) Wlan virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstWlanGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t wlan_port_id,
    bcm_gport_t wlan_port_mask)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    uint32 data = 0;        /* HW data match criteria.  */
    uint32 mask = 0;        /* HW data mask.            */
    int rv;                 /* Operation return status. */
    _field_entry_t *f_ent;  /* Field entry structure.   */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_WLAN_PORT(wlan_port_id)) {
        return (BCM_E_PARAM);
    }

    if (wlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_GPORT_IS_WLAN_PORT(wlan_port_mask)) {
            return (BCM_E_PARAM);
        }
    }

    data  = BCM_GPORT_WLAN_PORT_ID_GET(wlan_port_id);

    if (wlan_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask  = BCM_GPORT_WLAN_PORT_ID_GET(wlan_port_mask);
    } else {
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    /*
     * Invoke driver function for multi pipe supported devices.
     */
     
#if defined(BCM_TOMAHAWK_SUPPORT)
     if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstWlanGports,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
     }
#endif /* BCM_TOMAHAWK_SUPPORT */

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
        bcmFieldQualifyDstWlanGports, &f_ent));

    FP_LOCK(unit);

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /*
         * LSB is DVP valid bit.
         * Shift DVP value by 1-bit,
         */
        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;

        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask <<= 1;
            mask |=1;
        }
    } else {
        /* Qualify the destination type qualifier */
        rv = _field_dest_type_qualify(unit, entry,
                                      bcmFieldQualifyDstWlanGports, 
                                      &data, &mask, 
                                      _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstWlanGports,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_DstWlanGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstWlanGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      wlan_port_id - (OUT) Wlan port id.
 *      wlan_port_mask - (OUT) Wlan port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstWlanGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *wlan_port_id,
    bcm_gport_t *wlan_port_mask)
{
    uint32 data = 0;       /* HW encoded qualifier data.  */
    uint32 mask = 0;       /* HW encoding qualifier mask. */
    int rv;                /* Operation return status.    */
    _field_entry_t *f_ent; /* Field entry structure. */

    /* Input parameters check. */
    if ((NULL == wlan_port_id) || (NULL == wlan_port_mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyDstWlanGports,
                                            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
        bcmFieldQualifyDstWlanGports, &f_ent));

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
         /* Clear DVP Valid bit. */
         data >>= 1;

        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask >>= 1;
        }
    } else {
        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
            entry, bcmFieldQualifyDstWlanGports, &data, &mask));
    }

    BCM_GPORT_WLAN_PORT_ID_SET(*wlan_port_id, data);
    BCM_GPORT_WLAN_PORT_ID_SET(*wlan_port_mask, mask);

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcMplsGports
 * Purpose:
 *      Add source mpls port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      mpls_port_id - (IN) Mpls virtual port id.
 *      mpls_port_mask - (IN) Mpls virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_SrcMplsGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t mpls_port_id,
    bcm_gport_t mpls_port_mask)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    _field_group_t *fg;     /* Field group structure    */
    uint32 data = 0;        /* HW data match criteria.  */
    uint32 mask = 0;        /* HW data mask.            */
    int rv;                 /* Operation return status. */
    int ingress_entity = 0; /* Ingress entity or source entity */
    int i;

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_MPLS_PORT(mpls_port_id)) {
        return (BCM_E_PARAM);
    }

    if (mpls_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_GPORT_IS_MPLS_PORT(mpls_port_mask)) {
            return (BCM_E_PARAM);
        }
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

    /* Get the source virtual port value and mask*/
    data  = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id);

    if (mpls_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask  = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_mask);
    } else {
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
#if defined(BCM_TOMAHAWK_SUPPORT)
    /*
     * Invoke driver function for multi pipe supported devices.
     */ 
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_svp(unit, entry,
                                          bcmFieldQualifySrcMplsGports,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check which c nfiguration of SrcVlanGport is in use */
    for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
        if (fg->sel_codes[i].ingress_entity_sel ==
                    _bcmFieldFwdEntityMplsGport) {
            ingress_entity = 1;
            break;
        }
    }

    FP_LOCK(unit);

    if (ingress_entity) {
        /* Internal qualifier to set SVP valid bit in Fixed field */
        rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 1, 1);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    /* Qualify Mpls Source Virtual Port */
    /* In Stage Lookup bcmFieldQualifySrcMplsGports = 20 bits
       S_FIELD = 16 bits S_TYPE_SEL = 3 bits SVP_VALID = 1 bits
       S_TYPE_SEL = 0 and SVP_VALID = 1 implies S_FIELD = svp
       ==> data = svp_valid|s_type_sel|s_field
     */
    rv = _field_qualify_source_virtual_port(unit, entry,
            bcmFieldQualifySrcMplsGports, data, mask, ingress_entity);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcMplsGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcMplsGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mpls_port_id - (OUT) Mpls port id.
 *      mpls_port_mask - (OUT) Mpls port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_SrcMplsGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mpls_port_id,
    bcm_gport_t *mpls_port_mask)
{
    uint32 data = 0;  /* HW encoded qualifier data.  */
    uint32 mask = 0;  /* HW encoding qualifier mask. */
    int rv;           /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == mpls_port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifySrcMplsGports,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       data &=  0x1fff;
    }
    BCM_GPORT_MPLS_PORT_ID_SET(*mpls_port_id, data);
    BCM_GPORT_MPLS_PORT_ID_SET(*mpls_port_mask, mask);

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMplsGports
 * Purpose:
 *      Add source mpls port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      mpls_port_id - (IN) Mpls virtual port id.
 *      mpls_port_mask - (IN) Mpls virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstMplsGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t mpls_port_id,
    bcm_gport_t mpls_port_mask)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    uint32 data = 0;        /* HW data match criteria.  */
    uint32 mask = 0;        /* HW data mask.            */
    int rv;                 /* Operation return status. */
    _field_entry_t *f_ent;  /* Field entry structure.   */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_MPLS_PORT(mpls_port_id)) {
        return (BCM_E_PARAM);
    }

    if (mpls_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_GPORT_IS_MPLS_PORT(mpls_port_mask)) {
            return (BCM_E_PARAM);
        }
    }

    data  = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_id);

    if (mpls_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask  = BCM_GPORT_MPLS_PORT_ID_GET(mpls_port_mask);
    } else {
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
                        bcmFieldQualifyDstMplsGports, &f_ent));
    /*
     * Invoke driver function for multi pipe supported devices.
     */
     
#if defined(BCM_TOMAHAWK_SUPPORT)
     if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
         (_BCM_FIELD_STAGE_EGRESS != f_ent->group->stage_id)) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstMplsGports,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
     }
#endif /* BCM_TOMAHAWK_SUPPORT */


    FP_LOCK(unit);

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /*
         * LSB is DVP valid bit.
         * Shift DVP value by 1-bit,
         */
        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;

        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask <<= 1;
            mask |=1;
        }
    } else {
        /* Qualify the destination type qualifier */
        rv = _field_dest_type_qualify(unit, entry,
                                      bcmFieldQualifyDstMplsGports, 
                                      &data, &mask, 
                                      _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstMplsGports,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_DstMplsGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMplsGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mpls_port_id - (OUT) Mpls port id.
 *      mpls_port_mask - (OUT) Mpls port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstMplsGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mpls_port_id,
    bcm_gport_t *mpls_port_mask)
{
    uint32 data = 0;       /* HW encoded qualifier data.  */
    uint32 mask = 0;       /* HW encoding qualifier mask. */
    int rv;                /* Operation return status.    */
    _field_entry_t *f_ent; /* Field entry structure. */

    /* Input parameters check. */
    if ((NULL == mpls_port_id) || (NULL == mpls_port_mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyDstMplsGports,
                                            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
        bcmFieldQualifyDstMplsGports, &f_ent));

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
         /* Clear DVP Valid bit. */
         data >>= 1;

        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask >>= 1;
        }
    } else {
        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
            entry, bcmFieldQualifyDstMplsGports, &data, &mask));
    }

    BCM_GPORT_MPLS_PORT_ID_SET(*mpls_port_id, data);
    BCM_GPORT_MPLS_PORT_ID_SET(*mpls_port_mask, mask);

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcGports
 * Purpose:
 *      Add source  gport field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      port_id - (IN) virtual port id.
 *      port_mask - (IN)  virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t port_id,
    bcm_gport_t port_mask)
{
    int rv = BCM_E_UNAVAIL; /* Operation return status. */
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    _field_control_t *fc;   /* Field control structure. */
    uint32 data;            /* HW data match value.     */
    uint32 mask = 0;        /* HW data mask value.      */
    int ingress_entity = 0;
    int port_gport_type = 0;
    int mask_gport_type = 0;
    _field_entry_t *f_ent; /* Field entry structure. */
#if defined(BCM_TRIDENT2_SUPPORT)
    int svp_valid = 1;
#endif /* BCM_TRIDENT2_SUPPORT */

    /* Input parameters check. */
    /* coverity[dead_error_line : FALSE] */ 
    if ((0 == BCM_GPORT_IS_MODPORT(port_id))
        && (0 == BCM_GPORT_IS_MPLS_PORT(port_id))
        && (0 == BCM_GPORT_IS_MIM_PORT(port_id)
        && (0 == BCM_GPORT_IS_WLAN_PORT(port_id))
        && (0 == BCM_GPORT_IS_NIV_PORT(port_id))
        && (!soc_feature(unit, soc_feature_niv) && (BCM_GPORT_IS_NIV_PORT(port_id)))
        && (0 == BCM_GPORT_IS_VLAN_PORT(port_id)))) {
        return (BCM_E_PARAM);
    }

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if ((0 == BCM_GPORT_IS_MODPORT(port_id))
            && (0 == BCM_GPORT_IS_MPLS_PORT(port_mask))
            && (0 == BCM_GPORT_IS_MIM_PORT(port_mask)
            && (0 == BCM_GPORT_IS_WLAN_PORT(port_mask))
            && (0 == BCM_GPORT_IS_NIV_PORT(port_mask))
            && (0 == BCM_GPORT_IS_VLAN_PORT(port_mask)))) {
            return (BCM_E_PARAM);
        }
    }

    /* No mismatch between port and port_mask gport type */
    port_gport_type =
        ((port_id   >> _SHR_GPORT_TYPE_SHIFT) & _SHR_GPORT_TYPE_MASK);

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask_gport_type =
            ((port_mask >> _SHR_GPORT_TYPE_SHIFT) & _SHR_GPORT_TYPE_MASK);

        if (port_gport_type != mask_gport_type) {
            return (BCM_E_PARAM);
        }
    }

    

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry,
                                   bcmFieldQualifySrcGports, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Include all bits for mask value */
     /*
      * Source port is a virtual port.
      */

     f_ent->svp_type = _bcmVpTypeAny; 
     /* Get the source virtual port value */
     if (BCM_GPORT_IS_MODPORT(port_id)) {
         data  = BCM_GPORT_MODPORT_PORT_GET(port_id);
         data |= ((BCM_GPORT_MODPORT_MODID_GET(port_id)) << _FP_PORT_BITWIDTH(unit));
#if defined(BCM_TRIDENT2_SUPPORT)
         svp_valid = 0;
#endif /* BCM_TRIDENT2_SUPPORT */
         ingress_entity = 1;
     } else if (BCM_GPORT_IS_MPLS_PORT(port_id)) {
         data = BCM_GPORT_MPLS_PORT_ID_GET(port_id);
         f_ent->svp_type = _bcmVpTypeMpls; 
     } else if (BCM_GPORT_IS_MIM_PORT(port_id)) {
         data = BCM_GPORT_MIM_PORT_ID_GET(port_id);
         f_ent->svp_type = _bcmVpTypeMim; 
     } else if (BCM_GPORT_IS_NIV_PORT(port_id)) {
         data = BCM_GPORT_NIV_PORT_ID_GET(port_id);
         f_ent->svp_type = _bcmVpTypeNiv; 
     } else if (BCM_GPORT_IS_VLAN_PORT(port_id)) {
         data = BCM_GPORT_VLAN_PORT_ID_GET(port_id);
         f_ent->svp_type = _bcmVpTypeVlan; 
     } else {
         data = BCM_GPORT_WLAN_PORT_ID_GET(port_id);
         f_ent->svp_type = _bcmVpTypeWlan; 
     }

     if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
         /* Get the source virtual port value */
         if (BCM_GPORT_IS_MODPORT(port_id)) {
             mask = BCM_GPORT_MODPORT_PORT_GET(port_mask);
             mask |= ((BCM_GPORT_MODPORT_MODID_GET(port_mask)) << _FP_PORT_BITWIDTH(unit));
         } else if (BCM_GPORT_IS_MPLS_PORT(port_mask)) {
             mask = BCM_GPORT_MPLS_PORT_ID_GET(port_mask);
         } else if (BCM_GPORT_IS_MIM_PORT(port_mask)) {
             mask = BCM_GPORT_MIM_PORT_ID_GET(port_mask);
         } else if (BCM_GPORT_IS_NIV_PORT(port_mask)) {
             mask = BCM_GPORT_NIV_PORT_ID_GET(port_mask);
         } else if (BCM_GPORT_IS_VLAN_PORT(port_mask)) {
             mask = BCM_GPORT_VLAN_PORT_ID_GET(port_mask);
         } else {
             mask = BCM_GPORT_WLAN_PORT_ID_GET(port_mask);
         }
     } else {
         mask = BCM_FIELD_EXACT_MATCH_MASK;
     }

#if defined(BCM_TOMAHAWK_SUPPORT)
    /*
     * Invoke driver function for multi pipe supported devices.
     */ 
     if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
         rv = fc->functions.fp_qualify_svp(unit, entry,
                                           bcmFieldQualifySrcGports,
                                           data, mask, svp_valid);
         FP_UNLOCK(unit);
         return (rv);
     }
#endif /* BCM_TOMAHAWK_SUPPORT */

#if defined(BCM_TRIDENT2_SUPPORT)
     if (SOC_IS_TD2_TT2(unit) && (svp_valid == 1)) {
         /* Internal qualifier to set SVP valid bit in Fixed field */
         rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 1, 1);

         if (BCM_FAILURE(rv)) {
             FP_UNLOCK(unit);
             return (rv);
         }
         ingress_entity = 1;
     }
#endif /* BCM_TRIDENT2_SUPPORT */

     /* Qualify Source Virtual Port */
     rv = _field_qualify_source_virtual_port(unit, entry,
                                             bcmFieldQualifySrcGports,
                                             data, mask, ingress_entity);

    FP_UNLOCK(unit);
#endif
    return (rv);
}



/*
 * Function:
 *      bcm_esw_field_qualify_SrcGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      port_id - (OUT)  port id.
 *      port_mask - (OUT)  port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *port_id,
    bcm_gport_t *port_mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    uint32 data = 0;         /* HW encoded qualifier data.    */
    uint32 mask = 0;         /* HW encoding qualifier mask.   */
    _bcm_field_qual_offset_t *q_offset; /* Qualifier offset.  */
    _field_entry_t *f_ent;   /* Field entry information.      */

    /* Input parameters check. */
    if ((NULL == port_id) || (NULL == port_mask)) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                               bcmFieldQualifySrcGports,
                                               &data, &mask);
    if (BCM_FAILURE(rv)) {
       FP_UNLOCK(unit);
       return rv;
    }

    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry,
                                   bcmFieldQualifySrcGports, &f_ent);
    if (BCM_FAILURE(rv)) {
       FP_UNLOCK(unit);
       return rv;
    }

    /* Get qualifier offsets in the tcam. */
    rv = _field_qual_offset_get(unit, f_ent,
                                bcmFieldQualifySrcGports, &q_offset);
    if (BCM_FAILURE(rv)) {
       FP_UNLOCK(unit);
       return rv;
    }

    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       /* Clear SVP valid bit. */
       data &= ((1 << (q_offset->width[0] - 1)) - 1);
    }

    if (f_ent->svp_type == _bcmVpTypeMpls) {
        BCM_GPORT_MPLS_PORT_ID_SET(*port_id, data);
        BCM_GPORT_MPLS_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeMim) {
        BCM_GPORT_MIM_PORT_ID_SET(*port_id, data);
        BCM_GPORT_MIM_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeNiv) {
        BCM_GPORT_NIV_PORT_ID_SET(*port_id, data);
        BCM_GPORT_NIV_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeVlan) {
        BCM_GPORT_VLAN_PORT_ID_SET(*port_id, data);
        BCM_GPORT_VLAN_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeWlan) {
        BCM_GPORT_WLAN_PORT_ID_SET(*port_id, data);
        BCM_GPORT_WLAN_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeVxlan) {
        BCM_GPORT_VXLAN_PORT_ID_SET(*port_id, data);
        BCM_GPORT_VXLAN_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeFlow) {
        BCM_GPORT_FLOW_PORT_ID_SET(*port_id, data);
        BCM_GPORT_FLOW_PORT_ID_SET(*port_mask, mask);
    } else {
        BCM_GPORT_MODPORT_SET(*port_id, ((data >> _FP_PORT_BITWIDTH(unit)) & 0xff),
                             (data & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
        BCM_GPORT_MODPORT_SET(*port_mask, ((mask >> _FP_PORT_BITWIDTH(unit)) & 0xff),
                             (mask & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
    }
    FP_UNLOCK(unit);
#endif
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstGports
 * Purpose:
 *      Add destination port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      port_id - (IN)  virtual port id.
 *      port_mask - (IN) virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t port_id,
    bcm_gport_t port_mask)
{
    int rv = BCM_E_UNAVAIL; /* Operation return status. */
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    uint32 data = 0;        /* HW data match criteria.  */
    uint32 mask = 0;        /* HW data mask.            */
    _field_entry_t *f_ent;  /* Field entry structure.   */

   /* Input parameters check. */
   /* coverity[dead_error_line : FALSE] */ 
   if ((0 == BCM_GPORT_IS_MODPORT(port_id))
        && (0 == BCM_GPORT_IS_MPLS_PORT(port_id))
        && (0 == BCM_GPORT_IS_MIM_PORT(port_id)
        && (0 == BCM_GPORT_IS_WLAN_PORT(port_id))
        && (0 == BCM_GPORT_IS_NIV_PORT(port_id))
        && (!soc_feature(unit, soc_feature_niv) && (BCM_GPORT_IS_NIV_PORT(port_id)))
        && (0 == BCM_GPORT_IS_VLAN_PORT(port_id)))) {
        return (BCM_E_PARAM);
    }

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if ((0 == BCM_GPORT_IS_MODPORT(port_id))
            && (0 == BCM_GPORT_IS_MPLS_PORT(port_mask))
            && (0 == BCM_GPORT_IS_MIM_PORT(port_mask)
            && (0 == BCM_GPORT_IS_WLAN_PORT(port_mask))
            && (0 == BCM_GPORT_IS_NIV_PORT(port_mask))
            && (0 == BCM_GPORT_IS_VLAN_PORT(port_mask)))) {
            return (BCM_E_PARAM);
        }
    }

	/* Get the source virtual port value */
     if (BCM_GPORT_IS_MODPORT(port_id)) {
         data  = BCM_GPORT_MODPORT_PORT_GET(port_id);
         data |= ((BCM_GPORT_MODPORT_MODID_GET(port_id)) << _FP_PORT_BITWIDTH(unit));
     } else if (BCM_GPORT_IS_MPLS_PORT(port_id)) {
         data = BCM_GPORT_MPLS_PORT_ID_GET(port_id);
     } else if (BCM_GPORT_IS_MIM_PORT(port_id)) {
         data = BCM_GPORT_MIM_PORT_ID_GET(port_id);
     } else if (BCM_GPORT_IS_NIV_PORT(port_id)) {
         data = BCM_GPORT_NIV_PORT_ID_GET(port_id);
     } else if (BCM_GPORT_IS_VLAN_PORT(port_id)) {
         data = BCM_GPORT_VLAN_PORT_ID_GET(port_id);
     } else {
         data = BCM_GPORT_WLAN_PORT_ID_GET(port_id);
     }

     if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
         /* Get the source virtual port value */
         if (BCM_GPORT_IS_MODPORT(port_id)) {
             mask = BCM_GPORT_MODPORT_PORT_GET(port_mask);
             mask |= ((BCM_GPORT_MODPORT_MODID_GET(port_mask)) << _FP_PORT_BITWIDTH(unit));
         } else if (BCM_GPORT_IS_MPLS_PORT(port_mask)) {
             mask = BCM_GPORT_MPLS_PORT_ID_GET(port_mask);
         } else if (BCM_GPORT_IS_MIM_PORT(port_mask)) {
             mask = BCM_GPORT_MIM_PORT_ID_GET(port_mask);
         } else if (BCM_GPORT_IS_NIV_PORT(port_mask)) {
             mask = BCM_GPORT_NIV_PORT_ID_GET(port_mask);
         } else if (BCM_GPORT_IS_VLAN_PORT(port_mask)) {
             mask = BCM_GPORT_VLAN_PORT_ID_GET(port_mask);
         } else {
             mask = BCM_GPORT_WLAN_PORT_ID_GET(port_mask);
         }
     } else {
         mask = BCM_FIELD_EXACT_MATCH_MASK;
     }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
                        bcmFieldQualifyDstGports, &f_ent));

    /*
     * Invoke driver function for multi pipe supported devices.
     */
     
#if defined(BCM_TOMAHAWK_SUPPORT)
     if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
         (_BCM_FIELD_STAGE_EGRESS != f_ent->group->stage_id)) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstGports,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
     }
#endif /* BCM_TOMAHAWK_SUPPORT */

    FP_LOCK(unit);

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /*
         * LSB is DVP valid bit.
         * Shift DVP value by 1-bit,
         */
        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;

        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask <<= 1;
            mask |=1;
        }
    } else {
        /* Qualify the destination type qualifier */
        rv = _field_dest_type_qualify(unit, entry,
                                      bcmFieldQualifyDstGports, 
                                      &data, &mask, 
                                      _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstGports,
                          data, mask);

    FP_UNLOCK(unit);
#endif
    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_DstGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      port_id - (OUT)  port id.
 *      port_mask - (OUT)  port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *port_id,
    bcm_gport_t *port_mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.  */
#if defined(BCM_TRX_SUPPORT) && defined(INCLUDE_L3)
    uint32 data = 0;       /* HW encoded qualifier data.  */
    uint32 mask = 0;       /* HW encoding qualifier mask. */
    _field_entry_t *f_ent; /* Field entry structure. */

    /* Input parameters check. */
    if ((NULL == port_id) || (NULL == port_mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyDstGports,
                                            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
        bcmFieldQualifyDstGports, &f_ent));

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
         /* Clear DVP Valid bit. */
         data >>= 1;

        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask >>= 1;
        }
    } else {
        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
            entry, bcmFieldQualifyDstGports, &data, &mask));
    }

    if (_bcm_vp_used_get(unit, data, _bcmVpTypeMpls)) {
        BCM_GPORT_MPLS_PORT_ID_SET(*port_id, data);
        BCM_GPORT_MPLS_PORT_ID_SET(*port_mask, mask);
    } else if (_bcm_vp_used_get(unit, data, _bcmVpTypeMim)) {
        BCM_GPORT_MIM_PORT_ID_SET(*port_id, data);
        BCM_GPORT_MIM_PORT_ID_SET(*port_mask, mask);
    } else if (_bcm_vp_used_get(unit, data, _bcmVpTypeNiv)) {
        BCM_GPORT_NIV_PORT_ID_SET(*port_id, data);
        BCM_GPORT_NIV_PORT_ID_SET(*port_mask, mask);
    } else if (_bcm_vp_used_get(unit, data, _bcmVpTypeVlan)) {
        BCM_GPORT_VLAN_PORT_ID_SET(*port_id, data);
        BCM_GPORT_VLAN_PORT_ID_SET(*port_mask, mask);
    } else if (_bcm_vp_used_get(unit, data, _bcmVpTypeWlan)) {
        BCM_GPORT_WLAN_PORT_ID_SET(*port_id, data);
        BCM_GPORT_WLAN_PORT_ID_SET(*port_mask, mask);
    } else if (_bcm_vp_used_get(unit, data, _bcmVpTypeVxlan)) {
        BCM_GPORT_VXLAN_PORT_ID_SET(*port_id, data);
        BCM_GPORT_VXLAN_PORT_ID_SET(*port_mask, mask);
    } else if (_bcm_vp_used_get(unit, data, _bcmVpTypeFlow)) {
        BCM_GPORT_FLOW_PORT_ID_SET(*port_id, data);
        BCM_GPORT_FLOW_PORT_ID_SET(*port_mask, mask);
    } else {
        BCM_GPORT_MODPORT_SET(*port_id, ((data >> _FP_PORT_BITWIDTH(unit)) & 0xff),
                             (data & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
        BCM_GPORT_MODPORT_SET(*port_mask, ((mask >> _FP_PORT_BITWIDTH(unit)) & 0xff),
                             (mask & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
    }
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcMimGports
 * Purpose:
 *      Add source mim port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      mim_port_id - (IN) Mim virtual port id.
 *      mim_port_mask - (IN) Mim virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcMimGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t mim_port_id,
    bcm_gport_t mim_port_mask)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    _field_group_t *fg;     /* Field group structure    */
    uint32 data = 0;        /* HW data match criteria.  */
    uint32 mask = 0;        /* HW data mask.            */
    int rv;                 /* Operation return status. */
    int ingress_entity = 0; /* Ingress entity or source entity */
    int i;

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_MIM_PORT(mim_port_id)) {
        return (BCM_E_PARAM);
    }

    if (mim_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_GPORT_IS_MIM_PORT(mim_port_mask)) {
            return (BCM_E_PARAM);
        }
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

    /* Get the source virtual port value and mask*/
    data  = BCM_GPORT_MIM_PORT_ID_GET(mim_port_id);

    if (mim_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask  = BCM_GPORT_MIM_PORT_ID_GET(mim_port_mask);
    } else {
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
    /*
     * Invoke driver function for multi pipe supported devices.
     */ 
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_svp(unit, entry,
                                          bcmFieldQualifySrcMimGports,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check which configuration of SrcVlanGport is in use */
    for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
         if (fg->sel_codes[i].ingress_entity_sel ==
                 _bcmFieldFwdEntityMimGport) {
             ingress_entity = 1;
             break;
         }
    }

    FP_LOCK(unit);

    if (ingress_entity) {
        /* Internal qualifier to set SVP valid bit in Fixed field */
        rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 1, 1);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    /* Qualify Vlan Source Virtual Port */
    /* In Stage Lookup bcmFieldQualifySrcMimGports = 20 bits
       S_FIELD = 16 bits S_TYPE_SEL = 3 bits SVP_VALID = 1 bits
       S_TYPE_SEL = 0 and SVP_VALID = 1 implies S_FIELD = svp
       ==> data = svp_valid|s_type_sel|s_field
     */
    rv = _field_qualify_source_virtual_port(unit, entry,
            bcmFieldQualifySrcMimGports, data, mask, ingress_entity);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcMimGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcMimGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mim_port_id - (OUT) Mim port id.
 *      mim_port_mask - (OUT) Mim port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcMimGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mim_port_id,
    bcm_gport_t *mim_port_mask)
{
    uint32 data = 0;   /* HW encoded qualifier data.  */
    uint32 mask = 0;   /* HW encoding qualifier mask. */
    int rv;            /* Operation return status.    */

    /* Input parameters check. */
    if (NULL == mim_port_id) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifySrcMimGports,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        data &=  0x1fff;
    }
    BCM_GPORT_MIM_PORT_ID_SET(*mim_port_id, data);
    BCM_GPORT_MIM_PORT_ID_SET(*mim_port_mask, mask);

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMimGports
 * Purpose:
 *      Add destination mim port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      mim_port_id - (IN) Mim virtual port id.
 *      mim_port_mask - (IN) Mim virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstMimGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t mim_port_id,
    bcm_gport_t mim_port_mask)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    uint32 data = 0;        /* HW data match criteria.  */
    uint32 mask = 0;        /* HW data mask.            */
    int rv;                 /* Operation return status. */
    _field_entry_t *f_ent;  /* Field entry structure.   */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_MIM_PORT(mim_port_id)) {
        return (BCM_E_PARAM);
    }

    if (mim_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_GPORT_IS_MIM_PORT(mim_port_mask)) {
            return (BCM_E_PARAM);
        }
    }

    data  = BCM_GPORT_MIM_PORT_ID_GET(mim_port_id);

    if (mim_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask  = BCM_GPORT_MIM_PORT_ID_GET(mim_port_mask);
    } else {
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
                        bcmFieldQualifyDstMimGports, &f_ent));
    /*
     * Invoke driver function for multi pipe supported devices.
     */ 
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (_BCM_FIELD_STAGE_EGRESS != f_ent->group->stage_id)) {

        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstMimGports,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */



    FP_LOCK(unit);

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /*
         * LSB is DVP valid bit.
         * Shift DVP value by 1-bit,
         */
        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;

        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask <<= 1;
            mask |=1;
        }
    } else {
        /* Qualify the destination type qualifier */
        rv = _field_dest_type_qualify(unit, entry,
                                      bcmFieldQualifyDstMimGports, 
                                      &data, &mask, 
                                      _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstMimGports,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMimGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMimGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mim_port_id - (OUT) Mim port id.
 *      mim_port_mask - (OUT) Mim port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstMimGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mim_port_id,
    bcm_gport_t *mim_port_mask)
{
    uint32 data = 0;       /* HW encoded qualifier data.  */
    uint32 mask = 0;       /* HW encoding qualifier mask. */
    int rv;                /* Operation return status.    */
    _field_entry_t *f_ent; /* Field entry structure. */

    /* Input parameters check. */
    if ((NULL == mim_port_id) || (NULL == mim_port_mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyDstMimGports,
                                            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
        bcmFieldQualifyDstMimGports, &f_ent));

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
         /* Clear DVP Valid bit. */
         data >>= 1;

        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask >>= 1;
        }
    } else {
        if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
           BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
               entry, bcmFieldQualifyDstMimGports, &data, &mask));
        } 
    }

    BCM_GPORT_MIM_PORT_ID_SET(*mim_port_id, data);
    BCM_GPORT_MIM_PORT_ID_SET(*mim_port_mask, mask);

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcNivGports
 * Purpose:
 *      Add source niv port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      niv_port_id - (IN) Niv virtual port id.
 *      niv_port_mask - (IN) Niv virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcNivGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t niv_port_id,
    bcm_gport_t niv_port_mask)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    _field_group_t *fg;     /* Field group structure    */
    uint32 data = 0;        /* HW data match criteria.  */
    uint32 mask = 0;        /* HW data mask.            */
    int rv;                 /* Operation return status. */
    int ingress_entity = 0; /* Ingress entity or source entity */
    int i;

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_NIV_PORT(niv_port_id)) {
        return (BCM_E_PARAM);
    }

    if (niv_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_GPORT_IS_NIV_PORT(niv_port_mask)) {
            return (BCM_E_PARAM);
        }
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_group_find(unit, entry, &fg));

    /* Get the source virtual port value and mask*/
    data  = BCM_GPORT_NIV_PORT_ID_GET(niv_port_id);

    if (niv_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask  = BCM_GPORT_NIV_PORT_ID_GET(niv_port_mask);
    } else {
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
    /*
     * Invoke driver function for multi pipe supported devices.
     */ 
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_svp(unit, entry,
                                          bcmFieldQualifySrcNivGports,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    /* Check which configuration of SrcVlanGport is in use */
    for (i = 0; i < _FP_MAX_ENTRY_WIDTH; i++) {
         if (fg->sel_codes[i].ingress_entity_sel ==
                    _bcmFieldFwdEntityNivGport) {
             ingress_entity = 1;
             break;
         }
    }

    FP_LOCK(unit);

    if (ingress_entity) {
        /* Internal qualifier to set SVP valid bit in Fixed field */
        rv = _field_qualify32(unit, entry, _bcmFieldQualifySvpValid, 1, 1);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    /* Qualify Niv Source Virtual Port */
    /* In Stage Lookup bcmFieldQualifySrcNivGports = 20 bits
       S_FIELD = 16 bits S_TYPE_SEL = 3 bits SVP_VALID = 1 bits
       S_TYPE_SEL = 0 and SVP_VALID = 1 implies S_FIELD = svp
       ==> data = svp_valid|s_type_sel|s_field
     */
    rv = _field_qualify_source_virtual_port(unit, entry,
            bcmFieldQualifySrcNivGports, data, mask, ingress_entity);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcNivGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyNivGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      niv_port_id - (OUT) Niv port id.
 *      niv_port_mask - (OUT) Niv port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcNivGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *niv_port_id,
    bcm_gport_t *niv_port_mask)
{
    uint32 data = 0; /* HW encoded qualifier data.  */
    uint32 mask = 0; /* HW encoding qualifier mask. */
    int rv;          /* Operation return status.    */

    /* Input parameters check. */
    if ((NULL == niv_port_id) || (NULL == niv_port_mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifySrcNivGports,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if (!soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       data &=  0x1fff;
    }
    BCM_GPORT_NIV_PORT_ID_SET(*niv_port_id, data);
    BCM_GPORT_NIV_PORT_ID_SET(*niv_port_mask, mask);

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstNivGports
 * Purpose:
 *      Add destination niv port field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      niv_port_id - (IN) Niv virtual port id.
 *      niv_port_mask - (IN) Niv virtual port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstNivGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t niv_port_id,
    bcm_gport_t niv_port_mask)
{
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
#endif
    uint32 data = 0;        /* HW data match criteria.  */
    uint32 mask = 0;        /* HW data mask.            */
    int rv;                 /* Operation return status. */
    _field_entry_t *f_ent;  /* Field entry structure.   */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_NIV_PORT(niv_port_id)) {
        return (BCM_E_PARAM);
    }

    if (niv_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_GPORT_IS_NIV_PORT(niv_port_mask)) {
            return (BCM_E_PARAM);
        }
    }

    data  = BCM_GPORT_NIV_PORT_ID_GET(niv_port_id);

    if (niv_port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask  = BCM_GPORT_NIV_PORT_ID_GET(niv_port_mask);
    } else {
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
                        bcmFieldQualifyDstNivGports, &f_ent));
    
    /*
     * Invoke driver function for multi pipe supported devices.
     */ 
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (_BCM_FIELD_STAGE_EGRESS != f_ent->group->stage_id)) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstNivGports,
                                          data, mask, 1);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    FP_LOCK(unit);

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
        /*
         * LSB is DVP valid bit.
         * Shift DVP value by 1-bit,
         */
        data <<= 1;

        /* Set DVP Valid bit. */
        data |= 1;

        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask <<= 1;
            mask |=1;
        }
    } else {
        /* Qualify the destination type qualifier */
        rv = _field_dest_type_qualify(unit, entry,
                                      bcmFieldQualifyDstNivGports, 
                                      &data, &mask, 
                                      _bcmFieldDestTypeNone);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstNivGports,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstNivGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstNivGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      niv_port_id - (OUT) Niv port id.
 *      niv_port_mask - (OUT) Niv port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DstNivGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *niv_port_id,
    bcm_gport_t *niv_port_mask)
{
    uint32 data = 0;       /* HW encoded qualifier data.  */
    uint32 mask = 0;       /* HW encoding qualifier mask. */
    int rv;                /* Operation return status.    */
    _field_entry_t *f_ent; /* Field entry structure. */

    /* Input parameters check. */
    if ((NULL == niv_port_id) || (NULL == niv_port_mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyDstNivGports,
                                            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    BCM_IF_ERROR_RETURN(_bcm_field_entry_qual_get(unit, entry,
        bcmFieldQualifyDstNivGports, &f_ent));

    /* Check if entry belongs to Egress Stage. */
    if (_BCM_FIELD_STAGE_EGRESS == f_ent->group->stage_id) {
         /* Clear DVP Valid bit. */
         data >>= 1;

        if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
            mask >>= 1;
        }
    } else {
        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
            entry, bcmFieldQualifyDstNivGports, &data, &mask));
    }

    BCM_GPORT_NIV_PORT_ID_SET(*niv_port_id, data);
    BCM_GPORT_NIV_PORT_ID_SET(*niv_port_mask, mask);

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcModPortGports
 * Purpose:
 *      Add source modport field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      port_id - (IN) ModPort id.
 *      port_mask - (IN) ModPort id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcModPortGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t port_id,
    bcm_gport_t port_mask)
{
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_MODPORT(port_id)) {
        return (BCM_E_PARAM);
    }

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_GPORT_IS_MODPORT(port_mask)) {
            return (BCM_E_PARAM);
        }
    }

    data  = BCM_GPORT_MODPORT_PORT_GET(port_id);
    data |= ((BCM_GPORT_MODPORT_MODID_GET(port_id)) << _FP_PORT_BITWIDTH(unit));

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask = BCM_GPORT_MODPORT_PORT_GET(port_mask);
        mask |= ((BCM_GPORT_MODPORT_MODID_GET(port_mask)) << _FP_PORT_BITWIDTH(unit));
    } else {
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifySrcModPortGports,
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcModPortGports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcModPortGports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      port_id - (OUT) ModPort port id.
 *      port_mask - (OUT) ModPort port mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcModPortGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *port_id,
    bcm_gport_t *port_mask)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Input parameters check. */
    if ((NULL == port_id) || (NULL == port_mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifySrcModPortGports,
                                           &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    BCM_GPORT_MODPORT_SET(*port_id, ((data >> _FP_PORT_BITWIDTH(unit)) & 0xff),
                          (data & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));

    BCM_GPORT_MODPORT_SET(*port_mask, ((mask >> _FP_PORT_BITWIDTH(unit)) & 0xff),
                          (mask & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMulticastGroups
 * Purpose:
 *     Add a destination multicast group field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      group - (IN) Multicast group id.
 *      mask  - (IN) Multicast group id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMulticastGroups(
    int unit,
    bcm_field_entry_t entry,
    bcm_multicast_t group,
    bcm_multicast_t mask)
{
    uint32 hw_data;            /* HW data match criteria.  */
    uint32 hw_mask;            /* HW data mask.            */
    int rv;                 /* Operation return status. */
    uint8 ipmc_grp_type = 0;/* IPMC group type. */

    /* Input parameters check. */
    if (0 == BCM_MULTICAST_IS_SET(group)) {
        return (BCM_E_PARAM);
    }

    if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_MULTICAST_IS_SET(mask)) {
            return (BCM_E_PARAM);
        }
    }

    if (BCM_MULTICAST_IS_L3(group)) {
        ipmc_grp_type = _bcmFieldDestTypeL3mc;
        hw_data = BCM_MULTICAST_L3_GET(group);
    } else if (BCM_MULTICAST_IS_L2(group)) {
        ipmc_grp_type = _bcmFieldDestTypeL2mc;
        hw_data = BCM_MULTICAST_L2_GET(group);
    } else {
        return (BCM_E_PARAM);
    }

    if (mask == BCM_FIELD_EXACT_MATCH_MASK) {
        hw_mask = (BCM_FIELD_EXACT_MATCH_MASK);
    } else {
        if (ipmc_grp_type == _bcmFieldDestTypeL3mc) {
            hw_mask = BCM_MULTICAST_L3_GET(mask);
        } else {
            hw_mask = BCM_MULTICAST_L2_GET(mask);
        }
    }

    BCM_IF_ERROR_RETURN(_field_dest_type_qualify(unit, entry,
        bcmFieldQualifyDstMulticastGroups, &hw_data, &hw_mask, ipmc_grp_type));

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstMulticastGroups,
                          hw_data, hw_mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMulticastGroups_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMulticastGroups
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      group - (OUT) Multicast group id.
 *      mask  - (OUT) Multicast group id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int
bcm_esw_field_qualify_DstMulticastGroups_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_multicast_t *group,
    bcm_multicast_t *mask)
{
    uint32 hw_data;   /* HW encoded qualifier data.  */
    uint32 hw_mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */
    uint8 mc_grptype_data; /* Multicast Group Type */

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyDstMulticastGroups,
                                            &hw_data, &hw_mask);

    BCM_IF_ERROR_RETURN(rv);

    /* Get Multicast group type info */
    mc_grptype_data = hw_data >> _FP_MCAST_D_TYPE_OFFSET(unit);

    BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
                entry, bcmFieldQualifyDstMulticastGroups, &hw_data, &hw_mask));

    if (_bcmFieldDestTypeL2mc == mc_grptype_data) {
        /* L2 MC */
        BCM_MULTICAST_L2_SET(*group, hw_data);
        BCM_MULTICAST_L2_SET(*mask, hw_mask);
    } else if (_bcmFieldDestTypeL3mc == mc_grptype_data)  {
        /* IPMC */
        BCM_MULTICAST_L3_SET(*group, hw_data);
        BCM_MULTICAST_L3_SET(*mask, hw_mask);
    } else {
        return (BCM_E_INTERNAL);
    }

    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanHeaderBits8_31
 * Purpose:
 *      Qualify Reserved_1(bits 8 to 31) field in Vxlan Header.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data - (IN) Reserved_1 field (Lower 24 bits from the 32bit data).
 *      mask - (IN) mask for Reserved_1 field.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_VxlanHeaderBits8_31(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int                 rv;      /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyVxlanHeaderBits8_31,
                                   data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanHeaderBits8_31_get
 * Purpose:
 *      Get match criteria for Reserved_1(Bits 8 to 31)
 *      field in Vxlan Header.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data - (OUT) Reserved_1 field (Lower 24 bits from the 32bit data).
 *      mask - (OUT) mask for Reserved_1 field.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_VxlanHeaderBits8_31_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    int              rv;        /* Operation return status. */


    
    FP_LOCK(unit);

    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                          bcmFieldQualifyVxlanHeaderBits8_31,
                                          data, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanHeaderBits56_63
 * Purpose:
 *      Qualify Reserved_2(bits 56 to 63) field in Vxlan Header.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data - (IN) Reserved_2 field.
 *      mask - (IN) mask for Reserved_2 field.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_VxlanHeaderBits56_63(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int                 rv;      /* Operation return status. */

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyVxlanHeaderBits56_63,
                                   data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanHeaderBits56_63_get
 * Purpose:
 *      Get match criteria for Reserved_2(Bits 56 to 63)
 *      field in Vxlan Header.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data - (OUT) Reserved_2 field.
 *      mask - (OUT) mask for Reserved_2 field.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_VxlanHeaderBits56_63_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int              rv;        /* Operation return status. */


    
    FP_LOCK(unit);

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyVxlanHeaderBits56_63,
                                            data, mask);
    FP_UNLOCK(unit);
    return (rv);
}
/*
 * Function:
 *      bcm_esw_field_group_oper_mode_set
 * Purpose:
 *      Configure Field Processor Group operational mode
 *      per-CAP stage.
 * Parameters:
 *      unit    - (IN) BCM Device number.
 *      stage   - (IN) Field Stage Qualifier enum value.
 *      mode    - (IN) Field Group Operational Mode enum value.
 * Returns:
 *      BCM_E_NONE   - Operation successful.
 *      BCM_E_PARAM  - Invalid operational mode or Field Stage.
 *      BCM_E_INIT   - BCM unit not initialized.
 *      BCM_E_BUSY   - Field stage has valid group/entry configured.
 *
 * Notes:
 *      Valid "stage" input parameter values supported by
 *      this API are:
 *              "bcmFieldQualifyStageLookup"
 * 	            "bcmFieldQualifyStageIngress"
 *              "bcmFieldQualifyStageEgress"
 *              "bcmFieldQualifyStageIngressExactMatch"
 *              "bcmFieldQualifyStageClass"
 *              "bcmFieldQualifyStageClassExactMatch".
 */
int
bcm_esw_field_group_oper_mode_set(
    int unit,
    bcm_field_qualify_t stage,
    bcm_field_group_oper_mode_t mode)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (0 == soc_feature(unit, soc_feature_field_single_pipe_support))) {
       

       FP_LOCK(unit);
       rv = (_bcm_field_th_group_oper_mode_set(unit, stage, mode));
       FP_UNLOCK(unit);
    } 
#endif /* BCM_TOMAHAWK_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_group_oper_mode_get
 * Purpose:
 *      Retrieve Field Processor Group operational mode
 *      per-CAP stage.
 * Parameters:
 *      unit    - (IN)  BCM Device number.
 *      stage   - (IN)  Field Stage Qualifier enum value.
 *      mode    - (OUT) Reference to Field Group Operational
 *                      Mode enum value.
 * Returns:
 *      BCM_E_NONE   - Operation successful.
 *      BCM_E_PARAM  - Invalid parameter.
 *      BCM_E_INIT   - BCM unit not initialized.
 *
 * Notes:
 *      Valid "stage" input parameter values supported by
 *      this API are:
 *              "bcmFieldQualifyStageLookup"
 * 	            "bcmFieldQualifyStageIngress"
 *              "bcmFieldQualifyStageEgress"
 *              "bcmFieldQualifyStageIngressExactMatch"
 *              "bcmFieldQualifyStageClass"
 *              "bcmFieldQualifyStageClassExactMatch".
 */

int
bcm_esw_field_group_oper_mode_get(
    int unit,
    bcm_field_qualify_t stage,
    bcm_field_group_oper_mode_t *mode)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) &&
        (0 == soc_feature(unit, soc_feature_field_single_pipe_support))) {
       rv = _bcm_field_th_group_oper_mode_get(unit, stage, mode);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DestVirtualPortValid
 *      Set match criteria for bcmFieldQualifyDestVirtualPortValid
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DestVirtualPortValid(int unit, bcm_field_entry_t entry,
                                          uint8 data, uint8 mask) 
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)

    if (data > 0x1) {
        return (BCM_E_PARAM);
    }

    

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, bcmFieldQualifyDestVirtualPortValid,
                          data, mask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DestVirtualPortValid_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDestVirtualPortValid
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DestVirtualPortValid_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 *data,
                                               uint8 *mask)
{
   int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined(BCM_TOMAHAWK_SUPPORT) || defined(BCM_TRIDENT2_SUPPORT)
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                    bcmFieldQualifyDestVirtualPortValid,
                                    data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeOxID
 *      Set match criteria for bcmFieldQualifyFcoeOxID
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeOxID(int unit, 
        bcm_field_entry_t entry,
        uint16 data, 
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TRIDENT2_SUPPORT

    if (soc_feature(unit, soc_feature_field_multi_pipe_support) ||
            SOC_IS_APACHE(unit)) {

        

        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyFcoeOxID,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT2_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeOxID_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFcoeOxID
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeOxID_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TRIDENT2_SUPPORT
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) ||
            SOC_IS_APACHE(unit)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                               bcmFieldQualifyFcoeOxID,
                                               data, mask);
    }
#endif /* BCM_TRIDENT2_SUPPORT */
    return (rv);

}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeRxID
 *      Set match criteria for bcmFieldQualifyFcoeRxID
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeRxID(int unit, 
        bcm_field_entry_t entry,
        uint16 data, 
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TRIDENT2_SUPPORT

    if (soc_feature(unit, soc_feature_field_multi_pipe_support) ||
            SOC_IS_APACHE(unit)) {
        

        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyFcoeRxID,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT2_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeRxID_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFcoeRxID
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeRxID_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TRIDENT2_SUPPORT
    if (soc_feature(unit, soc_feature_field_multi_pipe_support) ||
            SOC_IS_APACHE(unit)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                               bcmFieldQualifyFcoeRxID,
                                               data, mask);
    }
#endif /* BCM_TRIDENT2_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpProtocolClass
 *      Set match criteria for bcmFieldQualifyIpProtocolClass
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IpProtocolClass(int unit, 
                                      bcm_field_entry_t entry,
                                      bcm_class_t data, 
                                      bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */
    
    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyIpProtocolClass,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpProtocolClass_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpProtocolClass
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IpProtocolClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyIpProtocolClass,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_EtherTypeClass
 *      Set match criteria for bcmFieldQualifyEtherTypeClass
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_EtherTypeClass(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyEtherTypeClass,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_EtherTypeClass_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEtherTypeClass
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_EtherTypeClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyEtherTypeClass,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L4SrcPortClass
 *      Set match criteria for bcmFieldQualifyL4SrcPortClass
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_L4SrcPortClass(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyL4SrcPortClass,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L4SrcPortClass_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL4SrcPortClass
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_L4SrcPortClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyL4SrcPortClass,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L4DstPortClass
 *      Set match criteria for bcmFieldQualifyL4DstPortClass
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_L4DstPortClass(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyL4DstPortClass,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_L4DstPortClass_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL4DstPortClass
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_L4DstPortClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyL4DstPortClass,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIpClass
 *      Set match criteria for bcmFieldQualifySrcIpClass
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIpClass(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 ref_data[_FP_QUAL_DATA_WORDS]; 
    uint32 ref_mask[_FP_QUAL_DATA_WORDS];

    

    sal_memset(&ref_data, 0, sizeof(ref_data));
    sal_memset(&ref_mask, 0, sizeof(ref_mask));

    COMPILER_64_TO_32_LO(ref_data[0], data);
    COMPILER_64_TO_32_HI(ref_data[1], data);
    COMPILER_64_TO_32_LO(ref_mask[0], mask);
    COMPILER_64_TO_32_HI(ref_mask[1], mask);
    
    FP_LOCK(unit);
    rv = _bcm_field_th_qualify_set(unit, entry, 
                                   bcmFieldQualifySrcIpClass,
                                   ref_data, ref_mask,
                                   _FP_QUALIFIER_ADD);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIpClass_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIpClass
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIpClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifySrcIpClass,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIpClassMsbNibble
 *      Set match criteria for bcmFieldQualifySrcIpClassMsbNibble
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIpClassMsbNibble(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifySrcIpClassMsbNibble,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIpClassMsbNibble_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIpClassMsbNibble
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIpClassMsbNibble_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                           bcmFieldQualifySrcIpClassMsbNibble,
                                           data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIpClassLower
 *      Set match criteria for bcmFieldQualifySrcIpClassLower
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIpClassLower(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifySrcIpClassLower,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIpClassLower_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIpClassLower
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIpClassLower_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifySrcIpClassLower,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIpClassUpper
 *      Set match criteria for bcmFieldQualifySrcIpClassUpper
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIpClassUpper(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifySrcIpClassUpper,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIpClassUpper_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIpClassUpper
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIpClassUpper_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifySrcIpClassUpper, 
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6Class
 *      Set match criteria for bcmFieldQualifySrcIp6Class
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIp6Class(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 ref_data[_FP_QUAL_DATA_WORDS];
    uint32 ref_mask[_FP_QUAL_DATA_WORDS];

    

    sal_memset(&ref_data, 0, sizeof(ref_data));
    sal_memset(&ref_mask, 0, sizeof(ref_mask));

    COMPILER_64_TO_32_LO(ref_data[0], data);
    COMPILER_64_TO_32_HI(ref_data[1], data);
    COMPILER_64_TO_32_LO(ref_mask[0], mask);
    COMPILER_64_TO_32_HI(ref_mask[1], mask);

    FP_LOCK(unit);
    rv = _bcm_field_th_qualify_set(unit, entry, 
                                   bcmFieldQualifySrcIp6Class,
                                   ref_data, ref_mask,
                                   _FP_QUALIFIER_ADD);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6Class_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIp6Class
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIp6Class_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifySrcIp6Class,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6ClassMsbNibble
 *      Set match criteria for bcmFieldQualifySrcIp6ClassMsbNibble
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
    int
bcm_esw_field_qualify_SrcIp6ClassMsbNibble(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifySrcIp6ClassMsbNibble,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6ClassMsbNibble_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIp6ClassMsbNibble
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIp6ClassMsbNibble_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                           bcmFieldQualifySrcIp6ClassMsbNibble,
                                           data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6ClassLower
 *      Set match criteria for bcmFieldQualifySrcIp6ClassLower
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIp6ClassLower(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifySrcIp6ClassLower,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6ClassLower_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIp6ClassLower
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIp6ClassLower_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifySrcIp6ClassLower,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6ClassUpper
 *      Set match criteria for bcmFieldQualifySrcIp6ClassUpper
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIp6ClassUpper(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifySrcIp6ClassUpper,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6ClassUpper_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIp6ClassUpper
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcIp6ClassUpper_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifySrcIp6ClassUpper,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeOxIDClass
 *      Set match criteria for bcmFieldQualifyFcoeOxIDClass
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeOxIDClass(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyFcoeOxIDClass,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeOxIDClass_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFcoeOxIDClass
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeOxIDClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyFcoeOxIDClass,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIpClass
 *      Set match criteria for bcmFieldQualifyDstIpClass
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIpClass(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 ref_data[_FP_QUAL_DATA_WORDS];
    uint32 ref_mask[_FP_QUAL_DATA_WORDS];

    

    sal_memset(&ref_data, 0, sizeof(ref_data));
    sal_memset(&ref_mask, 0, sizeof(ref_mask));

    COMPILER_64_TO_32_LO(ref_data[0], data);
    COMPILER_64_TO_32_HI(ref_data[1], data);
    COMPILER_64_TO_32_LO(ref_mask[0], mask);
    COMPILER_64_TO_32_HI(ref_mask[1], mask);

    FP_LOCK(unit);
    rv = _bcm_field_th_qualify_set(unit, entry, 
                                   bcmFieldQualifyDstIpClass,
                                   ref_data, ref_mask, _FP_QUALIFIER_ADD);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return (rv);

}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIpClass_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIpClass
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIpClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyDstIpClass,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIpClassMsbNibble
 *      Set match criteria for bcmFieldQualifyDstIpClassMsbNibble
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIpClassMsbNibble(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyDstIpClassMsbNibble,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);

}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIpClassMsbNibble_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIpClassMsbNibble
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIpClassMsbNibble_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                           bcmFieldQualifyDstIpClassMsbNibble,
                                           data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIpClassLower
 *      Set match criteria for bcmFieldQualifyDstIpClassLower
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIpClassLower(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyDstIpClassLower,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIpClassLower_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIpClassLower
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIpClassLower_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyDstIpClassLower,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIpClassUpper
 *      Set match criteria for bcmFieldQualifyDstIpClassUpper
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIpClassUpper(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data,
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyDstIpClassUpper, 
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);

}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIpClassUpper_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIpClassUpper
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIpClassUpper_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyDstIpClassUpper,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6Class
 *      Set match criteria for bcmFieldQualifyDstIp6Class
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIp6Class(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 ref_data[_FP_QUAL_DATA_WORDS];
    uint32 ref_mask[_FP_QUAL_DATA_WORDS];

    

    sal_memset(&ref_data, 0, sizeof(ref_data));
    sal_memset(&ref_mask, 0, sizeof(ref_mask));

    COMPILER_64_TO_32_LO(ref_data[0], data);
    COMPILER_64_TO_32_HI(ref_data[1], data);
    COMPILER_64_TO_32_LO(ref_mask[0], mask);
    COMPILER_64_TO_32_HI(ref_mask[1], mask);

    FP_LOCK(unit);
    rv = _bcm_field_th_qualify_set(unit, entry, 
                                   bcmFieldQualifyDstIp6Class,
                                   ref_data, ref_mask, 
                                   _FP_QUALIFIER_ADD);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6Class_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIp6Class
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIp6Class_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyDstIp6Class,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6ClassMsbNibble
 *      Set match criteria for bcmFieldQualifyDstIp6ClassMsbNibble
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
    int
bcm_esw_field_qualify_DstIp6ClassMsbNibble(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyDstIp6ClassMsbNibble,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6ClassMsbNibble_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIp6ClassMsbNibble
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIp6ClassMsbNibble_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                           bcmFieldQualifyDstIp6ClassMsbNibble,
                                           data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6ClassLower
 *      Set match criteria for bcmFieldQualifyDstIp6ClassLower
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIp6ClassLower(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyDstIp6ClassLower, 
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6ClassLower_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIp6ClassLower
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIp6ClassLower_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyDstIp6ClassLower,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6ClassUpper
 *      Set match criteria for bcmFieldQualifyDstIp6ClassUpper
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIp6ClassUpper(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyDstIp6ClassUpper,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);

}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6ClassUpper_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIp6ClassUpper
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstIp6ClassUpper_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyDstIp6ClassUpper,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeRxIDClass
 *      Set match criteria for bcmFieldQualifyFcoeRxIDClass
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
    int
bcm_esw_field_qualify_FcoeRxIDClass(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyFcoeRxIDClass,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeRxIDClass_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFcoeRxIDClass
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeRxIDClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyFcoeRxIDClass,
                                               data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcIdClass
 *      Set match criteria for bcmFieldQualifyFibreChanSrcIdClass
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcIdClass(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 ref_data[_FP_QUAL_DATA_WORDS];
    uint32 ref_mask[_FP_QUAL_DATA_WORDS];

    

    sal_memset(&ref_data, 0, sizeof(ref_data));
    sal_memset(&ref_mask, 0, sizeof(ref_mask));

    COMPILER_64_TO_32_LO(ref_data[0], data);
    COMPILER_64_TO_32_HI(ref_data[1], data);
    COMPILER_64_TO_32_LO(ref_mask[0], mask);
    COMPILER_64_TO_32_HI(ref_mask[1], mask);

    FP_LOCK(unit);
    rv = _bcm_field_th_qualify_set(unit, entry, 
                                   bcmFieldQualifyFibreChanSrcIdClass,
                                   ref_data, ref_mask,
                                   _FP_QUALIFIER_ADD);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcIdClass_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFibreChanSrcIdClass
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcIdClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                           bcmFieldQualifyFibreChanSrcIdClass,
                                           data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcIdClassMsbNibble
 *      Set match criteria for bcmFieldQualifyFibreChanSrcIdClassMsbNibble
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
    int
bcm_esw_field_qualify_FibreChanSrcIdClassMsbNibble(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyFibreChanSrcIdClassMsbNibble,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcIdClassMsbNibble_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFibreChanSrcIdClassMsbNibble
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcIdClassMsbNibble_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                  bcmFieldQualifyFibreChanSrcIdClassMsbNibble,
                                  data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcIdClassLower
 *      Set match criteria for bcmFieldQualifyFibreChanSrcIdClassLower
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcIdClassLower(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyFibreChanSrcIdClassLower,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);

}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcIdClassLower_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFibreChanSrcIdClassLower
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcIdClassLower_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                            bcmFieldQualifyFibreChanSrcIdClassLower,
                            data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcIdClassUpper
 *      Set match criteria for bcmFieldQualifyFibreChanSrcIdClassUpper
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcIdClassUpper(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyFibreChanSrcIdClassUpper,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcIdClassUpper_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFibreChanSrcIdClassUpper
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcIdClassUpper_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                bcmFieldQualifyFibreChanSrcIdClassUpper,
                                data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDstIdClass
 *      Set match criteria for bcmFieldQualifyFibreChanDstIdClass
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDstIdClass(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 ref_data[_FP_QUAL_DATA_WORDS];
    uint32 ref_mask[_FP_QUAL_DATA_WORDS];

    

    sal_memset(&ref_data, 0, sizeof(ref_data));
    sal_memset(&ref_mask, 0, sizeof(ref_mask));

    COMPILER_64_TO_32_LO(ref_data[0], data);
    COMPILER_64_TO_32_HI(ref_data[1], data);
    COMPILER_64_TO_32_LO(ref_mask[0], mask);
    COMPILER_64_TO_32_HI(ref_mask[1], mask);

    FP_LOCK(unit);
    rv = _bcm_field_th_qualify_set(unit, entry, 
                                   bcmFieldQualifyFibreChanDstIdClass,
                                   ref_data, ref_mask,
                                   _FP_QUALIFIER_ADD);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDstIdClass_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFibreChanDstIdClass
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDstIdClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                bcmFieldQualifyFibreChanDstIdClass,
                                data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDstIdClassMsbNibble
 *      Set match criteria for bcmFieldQualifyFibreChanDstIdClassMsbNibble
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDstIdClassMsbNibble(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyFibreChanDstIdClassMsbNibble,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDstIdClassMsbNibble_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFibreChanDstIdClassMsbNibble
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDstIdClassMsbNibble_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                            bcmFieldQualifyFibreChanDstIdClassMsbNibble,
                            data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDstIdClassLower
 *      Set match criteria for bcmFieldQualifyFibreChanDstIdClassLower
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDstIdClassLower(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyFibreChanDstIdClassLower,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDstIdClassLower_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFibreChanDstIdClassLower
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDstIdClassLower_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                        bcmFieldQualifyFibreChanDstIdClassLower,
                        data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDstIdClassUpper
 *      Set match criteria for bcmFieldQualifyFibreChanDstIdClassUpper
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDstIdClassUpper(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyFibreChanDstIdClassUpper,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDstIdClassUpper_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFibreChanDstIdClassUpper
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDstIdClassUpper_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                    bcmFieldQualifyFibreChanDstIdClassUpper, 
                    data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TcpClassZero
 *      Set match criteria for bcmFieldQualifyTcpClassZero
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TcpClassZero(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TRX_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyTcpClassZero,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TcpClassZero_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTcpClassZero
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TcpClassZero_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TRX_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyTcpClassZero,
                                               data, mask);
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TosClassZero
 *      Set match criteria for bcmFieldQualifyTosClassZero
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TosClassZero(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TRX_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyTosClassZero,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TosClassZero_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTosClassZero
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TosClassZero_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined(BCM_TRX_SUPPORT)
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                        bcmFieldQualifyTosClassZero,
                                        data, mask);
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TtlClassZero
 *      Set match criteria for bcmFieldQualifyTtlClassZero
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TtlClassZero(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TRX_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyTtlClassZero,
                          cdata, cmask);

    FP_UNLOCK(unit);
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TtlClassZero_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTtlClassZero
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TtlClassZero_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TRX_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyTtlClassZero,
                                               data, mask);
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TcpClassOne
 *      Set match criteria for bcmFieldQualifyTcpClassOne
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TcpClassOne(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined (BCM_TRX_SUPPORT)
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyTcpClassOne,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TRX_SUPPORT */

    return (rv);

}

/*
 * Function:
 *      bcm_esw_field_qualify_TcpClassOne_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTcpClassOne
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TcpClassOne_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TRX_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyTcpClassOne,
                                               data, mask);
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TosClassOne
 *      Set match criteria for bcmFieldQualifyTosClassOne
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TosClassOne(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TRX_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyTosClassOne,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TosClassOne_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTosClassOne
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TosClassOne_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TRX_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyTosClassOne,
                                               data, mask);
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TtlClassOne
 *      Set match criteria for bcmFieldQualifyTtlClassOne
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TtlClassOne(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TRX_SUPPORT
    uint32 cdata = 0;           /* Class Data */
    uint32 cmask = 0;           /* Class Mask */

    

    COMPILER_64_TO_32_LO(cdata, data);
    COMPILER_64_TO_32_LO(cmask, mask);

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, 
                          bcmFieldQualifyTtlClassOne,
                          cdata, cmask);
    FP_UNLOCK(unit);
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TtlClassOne_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTtlClassOne
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TtlClassOne_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined BCM_TRX_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                                               bcmFieldQualifyTtlClassOne,
                                               data, mask);
#endif /* BCM_TRX_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstMulticast
 *      Set match criteria for bcmFieldQualifyHiGigDstMulticast
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 */
int bcm_esw_field_qualify_HiGigDstMulticast(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigDstMulticast, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstMulticast_get
 *      Get match criteria for bcmFieldQualifyHiGigDstMulticast
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 */
int bcm_esw_field_qualify_HiGigDstMulticast_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigDstMulticast, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstMulticastGroupId
 *      Set match criteria for bcmFieldQualifyHiGigDstMulticastGroupId
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      group    -   (IN) Qualifier match group.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstMulticastGroupId(int unit,
        bcm_field_entry_t entry,
        bcm_multicast_t group, 
        bcm_multicast_t mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 hw_data = 0;            /* HW data match criteria.  */
    uint32 hw_mask = 0;            /* HW data mask.            */

    if (0 == BCM_MULTICAST_IS_SET(group)) {
        return (BCM_E_PARAM);
    }

    if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_MULTICAST_IS_SET(mask)) {
            return (BCM_E_PARAM);
        }
    }

    if (BCM_MULTICAST_IS_L3(group)) {
        hw_data = BCM_MULTICAST_L3_GET(group);
    } else if (BCM_MULTICAST_IS_L2(group)) {
        hw_data = BCM_MULTICAST_L2_GET(group);
    } else {
        return (BCM_E_PARAM);
    }

    if (mask == BCM_FIELD_EXACT_MATCH_MASK) {
        hw_mask = (BCM_FIELD_EXACT_MATCH_MASK);
    } else {
        if (BCM_MULTICAST_IS_L3(mask)) {
            hw_mask = BCM_MULTICAST_L3_GET(mask);
        } else if(BCM_MULTICAST_IS_L2(mask)) {
            hw_mask = BCM_MULTICAST_L2_GET(mask);
        }
    }

   
   FP_LOCK(unit);

   rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigDstMulticastGroupId,
           hw_data, hw_mask);

   FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstMulticastGroupId_get
 *      Get match criteria for bcmFieldQualifyHiGigDstMulticastGroupId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      group    - (OUT) Qualifier match group.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstMulticastGroupId_get(int unit,
        bcm_field_entry_t entry,
        bcm_multicast_t *group,
        bcm_multicast_t *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 hw_data = 0;   /* HW encoded qualifier data.  */
    uint32 hw_mask = 0;   /* HW encoding qualifier mask. */
    uint8 mc_grptype_data; /* Multicast Group Type */

    /* Input parameters check. */
    if ((NULL == group) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
            bcmFieldQualifyHiGigDstMulticastGroupId,
            &hw_data, &hw_mask);
    
    BCM_IF_ERROR_RETURN(rv);

    /* Get Multicast group type info */
    mc_grptype_data = hw_data >> _FP_MCAST_D_TYPE_OFFSET(unit);

    if (_bcmFieldDestTypeL2mc == mc_grptype_data) {
        /* L2 MC */
        BCM_MULTICAST_L2_SET(*group, hw_data);
        BCM_MULTICAST_L2_SET(*mask, hw_mask);
    } else if (_bcmFieldDestTypeL3mc == mc_grptype_data)  {
        /* IPMC */
        BCM_MULTICAST_L3_SET(*group, hw_data);
        BCM_MULTICAST_L3_SET(*mask, hw_mask);
    } else {
        return (BCM_E_INTERNAL);
    }
    
    rv = BCM_E_NONE;
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigTrafficClass
 *      Set match criteria for bcmFieldQualifyHiGigTrafficClass
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigTrafficClass(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigTrafficClass,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigTrafficClass_get
 *      Get match criteria for bcmFieldQualifyHiGigTrafficClass
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigTrafficClass_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                bcmFieldQualifyHiGigTrafficClass,
                                                data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstModuleGport
 *      Set match criteria for bcmFieldQualifyHiGigDstModuleGport
 *      qualifier in the field entry.
 * Parameters:
 *      unit      -   (IN) Unit number.
 *      entry     -   (IN) BCM field entry id.
 *      port_id   -   (IN) Qualifier match port.
 *      port_mask -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstModuleGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;            /* HW data match criteria.  */
    uint32 mask = 0;            /* HW data mask.            */

    if (0 == BCM_GPORT_IS_MODPORT(port_id)) {
        return (BCM_E_PARAM);
    }

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) { 
        if (0 == BCM_GPORT_IS_MODPORT(port_mask)) { 
            return (BCM_E_PARAM);
        }
    }
   
    data  = BCM_GPORT_MODPORT_MODID_GET(port_id);

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask |= BCM_GPORT_MODPORT_MODID_GET(port_mask);
    } else { 
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigDstModuleGport,
            data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstModuleGport_get
 *      Get match criteria for bcmFieldQualifyHiGigDstModuleGport
 *      qualifier from the field entry.
 * Parameters:
 *      unit        - (IN) Unit number.
 *      entry       - (IN) BCM field entry id.
 *      port_id     - (OUT) Qualifier match port.
 *      port_mask   - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstModuleGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;   /* HW encoded qualifier data.  */
    uint32 mask = 0;   /* HW encoding qualifier mask. */
    
    if ((NULL == port_id) || (NULL == port_mask)) {
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
            bcmFieldQualifyHiGigDstModuleGport, &data, &mask);
    
    BCM_IF_ERROR_RETURN(rv);
    BCM_GPORT_MODPORT_SET(*port_id, (data & 0xff), 0);
    BCM_GPORT_MODPORT_SET(*port_mask, (data & 0xff), 0);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstPortGport
 *      Set match criteria for bcmFieldQualifyHiGigDstPortGport
 *      qualifier in the field entry.
 * Parameters:
 *      unit        -   (IN) Unit number.
 *      entry       -   (IN) BCM field entry id.
 *      port_id     -   (IN) Qualifier match port.
 *      port_mask   -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstPortGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;            /* HW data match criteria.  */
    uint32 mask = 0;            /* HW data mask.            */

    if (0 == BCM_GPORT_IS_MODPORT(port_id)) {
        return (BCM_E_PARAM);
    }

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) { 
        if (0 == BCM_GPORT_IS_MODPORT(port_mask)) { 
            return (BCM_E_PARAM);
        }
    }
   
    data  = BCM_GPORT_MODPORT_PORT_GET(port_id);

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask |= BCM_GPORT_MODPORT_PORT_GET(port_mask);
    } else { 
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigDstPortGport,
            data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstPortGport_get
 *      Get match criteria for bcmFieldQualifyHiGigDstPortGport
 *      qualifier from the field entry.
 * Parameters:
 *      unit       - (IN) Unit number.
 *      entry      - (IN) BCM field entry id.
 *      port_id    - (OUT) Qualifier match port.
 *      port_mask  - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstPortGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;   /* HW encoded qualifier data.  */
    uint32 mask = 0;   /* HW encoding qualifier mask. */
    
    if ((NULL == port_id) || (NULL == port_mask)) {
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
            bcmFieldQualifyHiGigDstPortGport, &data, &mask);
    
    BCM_IF_ERROR_RETURN(rv);
    BCM_GPORT_MODPORT_SET(*port_id, 0, 
            (data & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
    BCM_GPORT_MODPORT_SET(*port_mask, 0, 
            (mask & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstModPortGport
 *      Set match criteria for bcmFieldQualifyHiGigDstModPortGport
 *      qualifier in the field entry.
 * Parameters:
 *      unit        - (IN) Unit number.
 *      entry       - (IN) BCM field entry id.
 *      port_id     - (IN) Qualifier match port.
 *      port_mask   - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstModPortGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;            /* HW data match criteria.  */
    uint32 mask = 0;            /* HW data mask.            */

    if (0 == BCM_GPORT_IS_MODPORT(port_id)) {
        return (BCM_E_PARAM);
    }

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) { 
        if (0 == BCM_GPORT_IS_MODPORT(port_mask)) { 
            return (BCM_E_PARAM);
        }
    }
   
    data  = BCM_GPORT_MODPORT_PORT_GET(port_id);
    data |= ((BCM_GPORT_MODPORT_MODID_GET(port_id)) << _FP_PORT_BITWIDTH(unit));

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask = BCM_GPORT_MODPORT_PORT_GET(port_mask);
        mask |= ((BCM_GPORT_MODPORT_MODID_GET(port_mask)) << _FP_PORT_BITWIDTH(unit));
    } else { 
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigDstModPortGport,
            data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstModPortGport_get
 *      Get match criteria for bcmFieldQualifyHiGigDstModPortGport
 *      qualifier from the field entry.
 * Parameters:
 *      unit        - (IN) Unit number.
 *      entry       - (IN) BCM field entry id.
 *      port_id     - (OUT) Qualifier match data.
 *      port_mask   - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstModPortGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;   /* HW encoded qualifier data.  */
    uint32 mask = 0;   /* HW encoding qualifier mask. */
    
    if ((NULL == port_id) || (NULL == port_mask)) {
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
            bcmFieldQualifyHiGigDstModPortGport, &data, &mask);
    
    BCM_IF_ERROR_RETURN(rv);
    BCM_GPORT_MODPORT_SET(*port_id, ((data >> _FP_PORT_BITWIDTH(unit)) & 0xff), 
            (data & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
    BCM_GPORT_MODPORT_SET(*port_mask, ((mask >> _FP_PORT_BITWIDTH(unit)) & 0xff), 
            (mask & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigSrcModuleGport
 *      Set match criteria for bcmFieldQualifyHiGigSrcModuleGport
 *      qualifier in the field entry.
 * Parameters:
 *      unit        -   (IN) Unit number.
 *      entry       -   (IN) BCM field entry id.
 *      port_id     -   (IN) Qualifier match port.
 *      port_mask   -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigSrcModuleGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;            /* HW data match criteria.  */
    uint32 mask = 0;            /* HW data mask.            */

    if (0 == BCM_GPORT_IS_MODPORT(port_id)) {
        return (BCM_E_PARAM);
    }

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) { 
        if (0 == BCM_GPORT_IS_MODPORT(port_mask)) { 
            return (BCM_E_PARAM);
        }
    }
   
    data  = BCM_GPORT_MODPORT_MODID_GET(port_id);

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask |= BCM_GPORT_MODPORT_MODID_GET(port_mask);
    } else { 
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigSrcModuleGport,
            data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigSrcModuleGport_get
 *      Get match criteria for bcmFieldQualifyHiGigSrcModuleGport
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match port.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigSrcModuleGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;   /* HW encoded qualifier data.  */
    uint32 mask = 0;   /* HW encoding qualifier mask. */
    
    if ((NULL == port_id) || (NULL == port_mask)) {
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
            bcmFieldQualifyHiGigSrcModuleGport, &data, &mask);
    
    BCM_IF_ERROR_RETURN(rv);
    BCM_GPORT_MODPORT_SET(*port_id, (data & 0xff), 0);
    BCM_GPORT_MODPORT_SET(*port_mask, (data & 0xff), 0);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigSrcPortGport
 *      Set match criteria for bcmFieldQualifyHiGigSrcPortGport
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match port.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigSrcPortGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;            /* HW data match criteria.  */
    uint32 mask = 0;            /* HW data mask.            */

    if (0 == BCM_GPORT_IS_MODPORT(port_id)) {
        return (BCM_E_PARAM);
    }

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) { 
        if (0 == BCM_GPORT_IS_MODPORT(port_mask)) { 
            return (BCM_E_PARAM);
        }
    }
   
    data  = BCM_GPORT_MODPORT_PORT_GET(port_id);

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask |= BCM_GPORT_MODPORT_PORT_GET(port_mask);
    } else { 
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigSrcPortGport,
            data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigSrcPortGport_get
 *      Get match criteria for bcmFieldQualifyHiGigSrcPortGport
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match port.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigSrcPortGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;   /* HW encoded qualifier data.  */
    uint32 mask = 0;   /* HW encoding qualifier mask. */
    
    if ((NULL == port_id) || (NULL == port_mask)) {
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
            bcmFieldQualifyHiGigSrcPortGport, &data, &mask);
    
    BCM_IF_ERROR_RETURN(rv);
    BCM_GPORT_MODPORT_SET(*port_id, 0, 
                          (data & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
    BCM_GPORT_MODPORT_SET(*port_mask, 0, 
                          (mask & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigSrcModPortGport
 *      Set match criteria for bcmFieldQualifyHiGigSrcModPortGport
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match port.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigSrcModPortGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;            /* HW data match criteria.  */
    uint32 mask = 0;            /* HW data mask.            */

    if (0 == BCM_GPORT_IS_MODPORT(port_id)) {
        return (BCM_E_PARAM);
    }

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) { 
        if (0 == BCM_GPORT_IS_MODPORT(port_mask)) { 
            return (BCM_E_PARAM);
        }
    }
   
    data  = BCM_GPORT_MODPORT_PORT_GET(port_id);
    data |= ((BCM_GPORT_MODPORT_MODID_GET(port_id)) << _FP_PORT_BITWIDTH(unit));

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask = BCM_GPORT_MODPORT_PORT_GET(port_mask);
        mask |= ((BCM_GPORT_MODPORT_MODID_GET(port_mask)) << _FP_PORT_BITWIDTH(unit));
    } else { 
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigSrcModPortGport,
            data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigSrcModPortGport_get
 *      Get match criteria for bcmFieldQualifyHiGigSrcModPortGport
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match port.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigSrcModPortGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;   /* HW encoded qualifier data.  */
    uint32 mask = 0;   /* HW encoding qualifier mask. */
    
    if ((NULL == port_id) || (NULL == port_mask)) {
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
            bcmFieldQualifyHiGigSrcModPortGport, &data, &mask);
    
    BCM_IF_ERROR_RETURN(rv);
    BCM_GPORT_MODPORT_SET(*port_id, ((data >> _FP_PORT_BITWIDTH(unit)) & 0xff), 
            (data & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
    BCM_GPORT_MODPORT_SET(*port_mask, ((mask >> _FP_PORT_BITWIDTH(unit)) & 0xff), 
            (mask & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigLoadBalanceID
 *      Set match criteria for bcmFieldQualifyHiGigLoadBalanceID
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigLoadBalanceID(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigLoadBalanceID, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigLoadBalanceID_get
 *      Get match criteria for bcmFieldQualifyHiGigLoadBalanceID
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigLoadBalanceID_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigLoadBalanceID, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigColor
 *      Set match criteria for bcmFieldQualifyHiGigColor
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigColor(int unit,
        bcm_field_entry_t entry,
        uint8 color)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint8 data = 0;           /* Qualifier data.          */
    uint8 mask = 0x3;     /* Qualifier mask.          */

    switch (color) {
        case BCM_FIELD_COLOR_GREEN:
            data = 0;
            break;
        case BCM_FIELD_COLOR_RED:
            data = 1;
            break;
        case BCM_FIELD_COLOR_YELLOW:
            data = 3;
            break;
        default:
            return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigColor, data, mask);

    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigColor_get
 *      Get match criteria for bcmFieldQualifyHiGigColor
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigColor_get(int unit,
        bcm_field_entry_t entry,
        uint8 *color)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint8 data = 0;      /* Qualifier data.          */
    uint8 mask = 0;      /* Qualifier mask.          */

    if (NULL == color) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, bcmFieldQualifyHiGigColor,
            &data, &mask);

    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    switch (data) {
        case 0:
            *color = BCM_FIELD_COLOR_GREEN;
            break;
        case 1:
            *color = BCM_FIELD_COLOR_RED;
            break;
        case 3:
            *color = BCM_FIELD_COLOR_YELLOW;
            break;
        default:
            rv = BCM_E_INTERNAL;
    }
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigIntCongestionNotification
 *      Set match criteria for bcmFieldQualifyHiGigIntCongestionNotification
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigIntCongestionNotification(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    if (soc_feature(unit, soc_feature_ecn_wred)) {
        
        if ((data > _BCM_ECN_INT_CN_VALUE_MAX) ||
            (mask > _BCM_ECN_INT_CN_VALUE_MAX)) {
            return BCM_E_PARAM;
        }

        
        FP_LOCK(unit);
        
        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyHiGigIntCongestionNotification,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigIntCongestionNotification_get
 *      Get match criteria for bcmFieldQualifyHiGigIntCongestionNotification
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigIntCongestionNotification_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    if (soc_feature(unit, soc_feature_ecn_wred)) {
        /* Read qualifier match value and mask. */
        return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                        bcmFieldQualifyHiGigIntCongestionNotification,
                        data, mask);
    }
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigIngressTagged
 *      Set match criteria for bcmFieldQualifyHiGigIngressTagged
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigIngressTagged(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigIngressTagged, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigIngressTagged_get
 *      Get match criteria for bcmFieldQualifyHiGigIngressTagged
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigIngressTagged_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigIngressTagged, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstTrunk
 *      Set match criteria for bcmFieldQualifyHiGigDstTrunk
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstTrunk(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigDstTrunk, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstTrunk_get
 *      Get match criteria for bcmFieldQualifyHiGigDstTrunk
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstTrunk_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigDstTrunk, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstTrunkId
 *      Set match criteria for bcmFieldQualifyHiGigDstTrunkId
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstTrunkId(int unit,
        bcm_field_entry_t entry,
        bcm_trunk_t data,
        bcm_trunk_t mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    if (BCM_GPORT_IS_SET(data)) {
        rv = _field_qualifier_gport_resolve(unit, data, mask,
                NULL, NULL, &data);
        BCM_IF_ERROR_RETURN(rv);
    }

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigDstTrunkId,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstTrunkId_get
 *      Get match criteria for bcmFieldQualifyHiGigDstTrunkId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstTrunkId_get(int unit,
        bcm_field_entry_t entry,
        bcm_trunk_t *data,
        bcm_trunk_t *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    int isGport;             /* Port format is gport.       */
    uint8 hw_data = 0;
    uint8 hw_mask = 0;

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyHiGigDstTrunkId, &hw_data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);

    /* Check requested output format. */
    rv = bcm_esw_switch_control_get(unit, bcmSwitchUseGport, &isGport);
    BCM_IF_ERROR_RETURN(rv);

    if (isGport) {
        BCM_GPORT_TRUNK_SET(hw_data, hw_data);
        hw_mask = BCM_FIELD_EXACT_MATCH_MASK;
    }
    *data = hw_data;
    *mask = hw_mask;
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigIngressL3SwitchPkt
 *      Set match criteria for bcmFieldQualifyHiGigIngressL3SwitchPkt
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigIngressL3SwitchPkt(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigIngressL3SwitchPkt, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigIngressL3SwitchPkt_get
 *      Get match criteria for bcmFieldQualifyHiGigIngressL3SwitchPkt
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigIngressL3SwitchPkt_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigIngressL3SwitchPkt, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigLabel
 *      Set match criteria for bcmFieldQualifyHiGigLabel
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigLabel(int unit,
        bcm_field_entry_t entry,
        uint32 data,
        uint32 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigLabel, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigLabel_get
 *      Get match criteria for bcmFieldQualifyHiGigLabel
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigLabel_get(int unit,
        bcm_field_entry_t entry,
        uint32 *data,
        uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                        bcmFieldQualifyHiGigLabel, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigReplicationId
 *      Set match criteria for bcmFieldQualifyHiGigReplicationId
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigReplicationId(int unit,
        bcm_field_entry_t entry,
        uint32 data,
        uint32 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigReplicationId, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigReplicationId_get
 *      Get match criteria for bcmFieldQualifyHiGigReplicationId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigReplicationId_get(int unit,
        bcm_field_entry_t entry,
        uint32 *data,
        uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                        bcmFieldQualifyHiGigReplicationId, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigVlan
 *      Set match criteria for bcmFieldQualifyHiGigVlan
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigVlan(int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    
    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigVlan, 
                                   data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigVlan_get
 *      Get match criteria for bcmFieldQualifyHiGigVlan
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigVlan_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
   rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                              bcmFieldQualifyHiGigVlan,
                                              data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigPortFilteringMode
 *      Set match criteria for bcmFieldQualifyHiGigPortFilteringMode
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigPortFilteringMode(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigPortFilteringMode, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigPortFilteringMode_get
 *      Get match criteria for bcmFieldQualifyHiGigPortFilteringMode
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigPortFilteringMode_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigPortFilteringMode, data, mask);

#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigSrcTrunk
 *      Set match criteria for bcmFieldQualifyHiGigSrcTrunk
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigSrcTrunk(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigSrcTrunk, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigSrcTrunk_get
 *      Get match criteria for bcmFieldQualifyHiGigSrcTrunk
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigSrcTrunk_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigSrcTrunk, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigIngressClassificationTag
 *      Set match criteria for bcmFieldQualifyHiGigIngressClassificationTag
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigIngressClassificationTag(int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigIngressClassificationTag, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigIngressClassificationTag_get
 *      Get match criteria for bcmFieldQualifyHiGigIngressClassificationTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigIngressClassificationTag_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                        bcmFieldQualifyHiGigIngressClassificationTag, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigEgressMcast
 *      Set match criteria for bcmFieldQualifyHiGigEgressMcast
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigEgressMcast(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT


    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigEgressMcast, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigEgressMcast_get
 *      Get match criteria for bcmFieldQualifyHiGigEgressMcast
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigEgressMcast_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigEgressMcast, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigVni
 *      Set match criteria for bcmFieldQualifyHiGigVni
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigVni(int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigVni, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigVni_get
 *      Get match criteria for bcmFieldQualifyHiGigVni
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigVni_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                        bcmFieldQualifyHiGigVni, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstGport
 *      Set match criteria for bcmFieldQualifyHiGigDstGport
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match port.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */
    uint32 data = 0;       /* HW encoded qualifier data.  */
    uint32 mask = 0;       /* HW encoding qualifier mask. */

    /* Input parameters check. */
    if (0 == BCM_GPORT_IS_MODPORT(port_id)) {
        return BCM_E_PARAM;
    }

    data = BCM_GPORT_MODPORT_PORT_GET(port_id);
    data |= ((BCM_GPORT_MODPORT_MODID_GET(port_id)) << _FP_PORT_BITWIDTH(unit));

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        data = BCM_GPORT_MODPORT_PORT_GET(port_mask);
        data |= ((BCM_GPORT_MODPORT_MODID_GET(port_mask)) << _FP_PORT_BITWIDTH(unit));
    } else {
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigDstGport, data, mask);
    FP_UNLOCK(unit);
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstGport_get
 *      Get match criteria for bcmFieldQualifyHiGigDstGport
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match port.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */
    uint32 data = 0;       /* HW encoded qualifier data.  */
    uint32 mask = 0;       /* HW encoding qualifier mask. */

    /* Input parameters check. */
    if ((NULL == port_id) || (NULL == port_mask)) {
        return (BCM_E_PARAM);
    }

    FP_LOCK(unit);

    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                        bcmFieldQualifyHiGigDstGport,
                        &data, &mask);
    FP_UNLOCK(unit);
    BCM_IF_ERROR_RETURN(rv);

    BCM_GPORT_MODPORT_SET(*port_id, ((data >> _FP_PORT_BITWIDTH(unit)) & 0xff),
                          (data & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
    BCM_GPORT_MODPORT_SET(*port_mask, ((mask >> _FP_PORT_BITWIDTH(unit)) & 0xff),
                          (mask & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigMulticastIndex
 *      Set match criteria for bcmFieldQualifyHiGigMulticastIndex
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigMulticastIndex(int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigMulticastIndex, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigMulticastIndex_get
 *      Get match criteria for bcmFieldQualifyHiGigMulticastIndex
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigMulticastIndex_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                        bcmFieldQualifyHiGigMulticastIndex, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigVpReplicationId
 *      Set match criteria for bcmFieldQualifyHiGigVpReplicationId
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigVpReplicationId(int unit,
        bcm_field_entry_t entry,
        uint32 data,
        uint32 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigVpReplicationId, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigVpReplicationId_get
 *      Get match criteria for bcmFieldQualifyHiGigVpReplicationId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigVpReplicationId_get(int unit,
        bcm_field_entry_t entry,
        uint32 *data,
        uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                        bcmFieldQualifyHiGigVpReplicationId, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigSrcGport
 *      Set match criteria for bcmFieldQualifyHiGigSrcGport
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigSrcGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT && defined(INCLUDE_L3)
    uint32 data = 0;        /* HW data match value.     */
    uint32 mask = 0;        /* HW data mask value.      */
    int port_gport_type = 0;
    int mask_gport_type = 0;
    _field_entry_t *f_ent;   /* Field entry information. */

    /* Input parameters check. */
    if ((0 == BCM_GPORT_IS_MPLS_PORT(port_id))
            && (0 == BCM_GPORT_IS_MIM_PORT(port_id))
            && (0 == BCM_GPORT_IS_WLAN_PORT(port_id))
            && (0 == BCM_GPORT_IS_NIV_PORT(port_id))
            && (0 == BCM_GPORT_IS_VLAN_PORT(port_id))
            && (0 == BCM_GPORT_IS_FLOW_PORT(port_id))
            && (0 == BCM_GPORT_IS_VXLAN_PORT(port_id))) {
        return (BCM_E_PARAM);
    }

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if ((0 == BCM_GPORT_IS_MPLS_PORT(port_mask))
            && (0 == BCM_GPORT_IS_MIM_PORT(port_mask))
            && (0 == BCM_GPORT_IS_WLAN_PORT(port_mask))
            && (0 == BCM_GPORT_IS_NIV_PORT(port_mask))
            && (0 == BCM_GPORT_IS_VLAN_PORT(port_mask))
            && (0 == BCM_GPORT_IS_FLOW_PORT(port_mask))
            && (0 == BCM_GPORT_IS_VXLAN_PORT(port_id))) {
            return (BCM_E_PARAM);
        }
    }
    
    /* No mismatch between port and port_mask gport type */
    port_gport_type =
        ((port_id   >> _SHR_GPORT_TYPE_SHIFT) & _SHR_GPORT_TYPE_MASK);

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask_gport_type =
            ((port_mask >> _SHR_GPORT_TYPE_SHIFT) & _SHR_GPORT_TYPE_MASK);

        if (port_gport_type != mask_gport_type) {
            return (BCM_E_PARAM);
        }
    }

    
    FP_LOCK(unit);
    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry,
                                  bcmFieldQualifyHiGigSrcGport, &f_ent);
    if (BCM_FAILURE(rv)) {
       FP_UNLOCK(unit);
       return rv;
    }

    /* Get the source virtual port value */
    if (BCM_GPORT_IS_MPLS_PORT(port_id)) {
        data = BCM_GPORT_MPLS_PORT_ID_GET(port_id);
        f_ent->svp_type = _bcmVpTypeMpls;
    } else if (BCM_GPORT_IS_MIM_PORT(port_id)) {
        data = BCM_GPORT_MIM_PORT_ID_GET(port_id);
        f_ent->svp_type = _bcmVpTypeMim;
    } else if (BCM_GPORT_IS_NIV_PORT(port_id)) {
        data = BCM_GPORT_NIV_PORT_ID_GET(port_id);
        f_ent->svp_type = _bcmVpTypeNiv;
    } else if (BCM_GPORT_IS_VLAN_PORT(port_id)) {
        data = BCM_GPORT_VLAN_PORT_ID_GET(port_id);
        f_ent->svp_type = _bcmVpTypeVlan;
    } else if (BCM_GPORT_IS_VXLAN_PORT(port_id)) {
        data = BCM_GPORT_VXLAN_PORT_ID_GET(port_id);
        f_ent->svp_type = _bcmVpTypeVxlan;
    } else if (BCM_GPORT_IS_FLOW_PORT(port_id)) {
        data = BCM_GPORT_FLOW_PORT_ID_GET(port_id);
        f_ent->svp_type = _bcmVpTypeFlow;
    }else {
        data = BCM_GPORT_WLAN_PORT_ID_GET(port_id);
        f_ent->svp_type = _bcmVpTypeWlan;
    }

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        /* Get the source virtual port value */
        if (BCM_GPORT_IS_MPLS_PORT(port_mask)) {
            mask = BCM_GPORT_MPLS_PORT_ID_GET(port_mask);
        } else if (BCM_GPORT_IS_MIM_PORT(port_mask)) {
            mask = BCM_GPORT_MIM_PORT_ID_GET(port_mask);
        } else if (BCM_GPORT_IS_NIV_PORT(port_mask)) {
            mask = BCM_GPORT_NIV_PORT_ID_GET(port_mask);
        } else if (BCM_GPORT_IS_VLAN_PORT(port_mask)) {
            mask = BCM_GPORT_VLAN_PORT_ID_GET(port_mask);
        } else if (BCM_GPORT_IS_VXLAN_PORT(port_mask)) {
            mask = BCM_GPORT_VXLAN_PORT_ID_GET(port_mask);
        } else if (BCM_GPORT_IS_FLOW_PORT(port_mask)) {
            mask = BCM_GPORT_FLOW_PORT_ID_GET(port_mask);
        } else {         
            mask = BCM_GPORT_WLAN_PORT_ID_GET(port_mask);
        }
    } else {
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }
       
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigSrcGport, data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigSrcGport_get
 *      Get match criteria for bcmFieldQualifyHiGigSrcGport
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigSrcGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT && defined(INCLUDE_L3)
    uint32 data = 0;         /* HW encoded qualifier data.    */
    uint32 mask = 0;         /* HW encoding qualifier mask.   */
    _field_entry_t *f_ent;   /* Field entry information. */

    /* Input parameters check. */
    if ((NULL == port_id) || (NULL == port_mask)) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry,
                                   bcmFieldQualifyHiGigSrcGport, &f_ent);
    if (BCM_FAILURE(rv)) {
       FP_UNLOCK(unit);
       return rv;
    }
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                        bcmFieldQualifyHiGigSrcGport,
                        &data, &mask);
    if (BCM_FAILURE(rv)) {
       FP_UNLOCK(unit);
       return rv;
    }

    if (f_ent->svp_type == _bcmVpTypeMpls) {
        BCM_GPORT_MPLS_PORT_ID_SET(*port_id, data);
        BCM_GPORT_MPLS_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeMim) {
        BCM_GPORT_MIM_PORT_ID_SET(*port_id, data);
        BCM_GPORT_MIM_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeNiv) {
        BCM_GPORT_NIV_PORT_ID_SET(*port_id, data);
        BCM_GPORT_NIV_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeVlan) {
        BCM_GPORT_VLAN_PORT_ID_SET(*port_id, data);
        BCM_GPORT_VLAN_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeWlan) {
        BCM_GPORT_WLAN_PORT_ID_SET(*port_id, data);
        BCM_GPORT_WLAN_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeVxlan) {
        BCM_GPORT_VXLAN_PORT_ID_SET(*port_id, data);
        BCM_GPORT_VXLAN_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeFlow) {
        BCM_GPORT_FLOW_PORT_ID_SET(*port_id, data);
        BCM_GPORT_FLOW_PORT_ID_SET(*port_mask, mask);
    } else {
        rv = BCM_E_NOT_FOUND;
    }
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigProtectionSwitchingStatus
 *      Set match criteria for bcmFieldQualifyHiGigProtectionSwitchingStatus
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigProtectionSwitchingStatus(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigProtectionSwitchingStatus, 
                          data, mask);

    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigProtectionSwitchingStatus_get
 *      Get match criteria for bcmFieldQualifyHiGigProtectionSwitchingStatus
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigProtectionSwitchingStatus_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigProtectionSwitchingStatus, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigMirrorToVp
 *      Set match criteria for bcmFieldQualifyHiGigMirrorToVp
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigMirrorToVp(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigMirrorToVp, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigMirrorToVp_get
 *      Get match criteria for bcmFieldQualifyHiGigMirrorToVp
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigMirrorToVp_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigMirrorToVp, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstType
 *      Set match criteria for bcmFieldQualifyHiGigDstType
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstType(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigDstType, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDstType_get
 *      Get match criteria for bcmFieldQualifyHiGigDstType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDstType_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigDstType, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigSrcType
 *      Set match criteria for bcmFieldQualifyHiGigSrcType
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigSrcType(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigSrcType, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigSrcType_get
 *      Get match criteria for bcmFieldQualifyHiGigSrcType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigSrcType_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigSrcType, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEngineClassificationTag
 *      Set match criteria for bcmFieldQualifyHiGigOffloadEngineClassificationTag
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEngineClassificationTag(int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigOffloadEngineClassificationTag, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEngineClassificationTag_get
 *      Get match criteria for bcmFieldQualifyHiGigOffloadEngineClassificationTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEngineClassificationTag_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                        bcmFieldQualifyHiGigOffloadEngineClassificationTag, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEnginePktPriNew
 *      Set match criteria for bcmFieldQualifyHiGigOffloadEnginePktPriNew
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEnginePktPriNew(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigOffloadEnginePktPriNew, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEnginePktPriNew_get
 *      Get match criteria for bcmFieldQualifyHiGigOffloadEnginePktPriNew
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEnginePktPriNew_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigOffloadEnginePktPriNew, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEngineDscpNew
 *      Set match criteria for bcmFieldQualifyHiGigOffloadEngineDscpNew
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEngineDscpNew(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigOffloadEngineDscpNew, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEngineDscpNew_get
 *      Get match criteria for bcmFieldQualifyHiGigOffloadEngineDscpNew
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEngineDscpNew_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigOffloadEngineDscpNew, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_LoopBackQueue
 *      Set match criteria for bcmFieldQualifyLoopBackQueue
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_LoopBackQueue(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyLoopBackQueue, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_LoopBackQueue_get
 *      Get match criteria for bcmFieldQualifyLoopBackQueue
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_LoopBackQueue_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyLoopBackQueue, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_LoopBackSrcGport
 *      Set match criteria for bcmFieldQualifyLoopBackSrcGport
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_LoopBackSrcGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT && defined(INCLUDE_L3)
    uint32 data = 0;        /* HW data match value.     */
    uint32 mask = 0;        /* HW data mask value.      */
    int port_gport_type = 0;
    int mask_gport_type = 0;
    _field_entry_t *f_ent;   /* Field entry information. */

    /* Input parameters check. */
    if ((0 == BCM_GPORT_IS_MPLS_PORT(port_id))
            && (0 == BCM_GPORT_IS_MIM_PORT(port_id))
            && (0 == BCM_GPORT_IS_WLAN_PORT(port_id))
            && (0 == BCM_GPORT_IS_NIV_PORT(port_id))
            && (0 == BCM_GPORT_IS_VLAN_PORT(port_id))
            && (0 == BCM_GPORT_IS_VXLAN_PORT(port_id))
            && (0 == BCM_GPORT_IS_FLOW_PORT(port_id))
            && (0 == BCM_GPORT_IS_MODPORT(port_id))) {
        return (BCM_E_PARAM);
    }

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if ((0 == BCM_GPORT_IS_MPLS_PORT(port_mask))
            && (0 == BCM_GPORT_IS_MIM_PORT(port_mask))
            && (0 == BCM_GPORT_IS_WLAN_PORT(port_mask))
            && (0 == BCM_GPORT_IS_NIV_PORT(port_mask))
            && (0 == BCM_GPORT_IS_VLAN_PORT(port_mask))
            && (0 == BCM_GPORT_IS_VXLAN_PORT(port_mask))
            && (0 == BCM_GPORT_IS_FLOW_PORT(port_mask))
            && (0 == BCM_GPORT_IS_MODPORT(port_mask))) {
            return (BCM_E_PARAM);
        }
    }
    
    /* No mismatch between port and port_mask gport type */
    port_gport_type =
        ((port_id   >> _SHR_GPORT_TYPE_SHIFT) & _SHR_GPORT_TYPE_MASK);

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask_gport_type =
            ((port_mask >> _SHR_GPORT_TYPE_SHIFT) & _SHR_GPORT_TYPE_MASK);

        if (port_gport_type != mask_gport_type) {
            return (BCM_E_PARAM);
        }
    }

     
     FP_LOCK(unit);
     /* Get field entry part that contains the qualifier. */
     rv = _bcm_field_entry_qual_get(unit, entry,
                               bcmFieldQualifyLoopBackSrcGport, &f_ent);
     if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
     }

     f_ent->svp_type = _bcmVpTypeAny;
     /* Get the source virtual port value */
     if (BCM_GPORT_IS_MPLS_PORT(port_id)) {
         data = BCM_GPORT_MPLS_PORT_ID_GET(port_id);
         f_ent->svp_type = _bcmVpTypeMpls;
     } else if (BCM_GPORT_IS_MIM_PORT(port_id)) {
         data = BCM_GPORT_MIM_PORT_ID_GET(port_id);
         f_ent->svp_type = _bcmVpTypeMim;
     } else if (BCM_GPORT_IS_NIV_PORT(port_id)) {
         data = BCM_GPORT_NIV_PORT_ID_GET(port_id);
         f_ent->svp_type = _bcmVpTypeNiv;
     } else if (BCM_GPORT_IS_VLAN_PORT(port_id)) {
         data = BCM_GPORT_VLAN_PORT_ID_GET(port_id);
         f_ent->svp_type = _bcmVpTypeVlan;
     } else if (BCM_GPORT_IS_VXLAN_PORT(port_id)) {
         data = BCM_GPORT_VXLAN_PORT_ID_GET(port_id);
         f_ent->svp_type = _bcmVpTypeVxlan;
     } else if (BCM_GPORT_IS_FLOW_PORT(port_id)) {
         data = BCM_GPORT_FLOW_PORT_ID_GET(port_id);
         f_ent->svp_type = _bcmVpTypeFlow;
     } else if (BCM_GPORT_IS_MODPORT(port_id)) {
         data = BCM_GPORT_MODPORT_PORT_GET(port_id);
         data |= ((BCM_GPORT_MODPORT_MODID_GET(port_id)) << _FP_PORT_BITWIDTH(unit));
     } else {
         data = BCM_GPORT_WLAN_PORT_ID_GET(port_id);
     }

     if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
         /* Get the source virtual port value */
         if (BCM_GPORT_IS_MPLS_PORT(port_mask)) {
             mask = BCM_GPORT_MPLS_PORT_ID_GET(port_mask);
         } else if (BCM_GPORT_IS_MIM_PORT(port_mask)) {
             mask = BCM_GPORT_MIM_PORT_ID_GET(port_mask);
         } else if (BCM_GPORT_IS_NIV_PORT(port_mask)) {
             mask = BCM_GPORT_NIV_PORT_ID_GET(port_mask);
         } else if (BCM_GPORT_IS_VLAN_PORT(port_mask)) {
             mask = BCM_GPORT_VLAN_PORT_ID_GET(port_mask);
         } else if (BCM_GPORT_IS_VXLAN_PORT(port_mask)) {
             mask = BCM_GPORT_VXLAN_PORT_ID_GET(port_mask);
         } else if (BCM_GPORT_IS_FLOW_PORT(port_mask)) {
             mask = BCM_GPORT_FLOW_PORT_ID_GET(port_mask);
         } else if (BCM_GPORT_IS_MODPORT(port_mask)) {
             mask = BCM_GPORT_MODPORT_PORT_GET(port_mask);
             mask |= ((BCM_GPORT_MODPORT_MODID_GET(port_mask)) << _FP_PORT_BITWIDTH(unit));
         } else {
             mask = BCM_GPORT_WLAN_PORT_ID_GET(port_mask);
         }
     } else {
         mask = BCM_FIELD_EXACT_MATCH_MASK;
     }

     rv = _field_qualify32(unit, entry, bcmFieldQualifyLoopBackSrcGport, data, mask);

     FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_LoopBackSrcGport_get
 *      Get match criteria for bcmFieldQualifyLoopBackSrcGport
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_LoopBackSrcGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT && defined(INCLUDE_L3)
    uint32 data = 0;         /* HW encoded qualifier data.    */
    uint32 mask = 0;         /* HW encoding qualifier mask.   */
    _field_entry_t *f_ent;   /* Field entry information. */

    /* Input parameters check. */
    if ((NULL == port_id) || (NULL == port_mask)) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    /* Get field entry part that contains the qualifier. */
    rv = _bcm_field_entry_qual_get(unit, entry,
                               bcmFieldQualifyLoopBackSrcGport, &f_ent);
    if (BCM_FAILURE(rv)) {
       FP_UNLOCK(unit);
       return rv;
    }
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                        bcmFieldQualifyLoopBackSrcGport,
                        &data, &mask);
    if (BCM_FAILURE(rv)) {
       FP_UNLOCK(unit);
       return rv;
    }

    if (f_ent->svp_type == _bcmVpTypeMpls) {
        BCM_GPORT_MPLS_PORT_ID_SET(*port_id, data);
        BCM_GPORT_MPLS_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeMim) {
        BCM_GPORT_MIM_PORT_ID_SET(*port_id, data);
        BCM_GPORT_MIM_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeNiv) {
        BCM_GPORT_NIV_PORT_ID_SET(*port_id, data);
        BCM_GPORT_NIV_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeVlan) {
        BCM_GPORT_VLAN_PORT_ID_SET(*port_id, data);
        BCM_GPORT_VLAN_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeWlan) {
        BCM_GPORT_WLAN_PORT_ID_SET(*port_id, data);
        BCM_GPORT_WLAN_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeVxlan) {
        BCM_GPORT_VXLAN_PORT_ID_SET(*port_id, data);
        BCM_GPORT_VXLAN_PORT_ID_SET(*port_mask, mask);
    } else if (f_ent->svp_type == _bcmVpTypeFlow) {
        BCM_GPORT_FLOW_PORT_ID_SET(*port_id, data);
        BCM_GPORT_FLOW_PORT_ID_SET(*port_mask, mask);
    } else {
        rv = BCM_E_NOT_FOUND;
    }
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_PktIsVisible
 *      Set match criteria for bcmFieldQualifyPktIsVisible
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_PktIsVisible(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyPktIsVisible, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_PktIsVisible_get
 *      Get match criteria for bcmFieldQualifyPktIsVisible
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_PktIsVisible_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyPktIsVisible, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_LoopBackCpuMasqueradePktProfile
 *      Set match criteria for bcmFieldQualifyLoopBackCpuMasqueradePktProfile
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_LoopBackCpuMasqueradePktProfile(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyLoopBackCpuMasqueradePktProfile, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_LoopBackCpuMasqueradePktProfile_get
 *      Get match criteria for bcmFieldQualifyLoopBackCpuMasqueradePktProfile
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_LoopBackCpuMasqueradePktProfile_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyLoopBackCpuMasqueradePktProfile, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_LoopBackColor
 *      Set match criteria for bcmFieldQualifyLoopBackColor
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_LoopBackColor(int unit,
        bcm_field_entry_t entry,
        uint8 color)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint8 data;           /* Qualifier data.          */
    uint8 mask = 0x3;     /* Qualifier mask.          */

    switch (color) {
        case BCM_FIELD_COLOR_GREEN:
            data = 0;
            break;
        case BCM_FIELD_COLOR_RED:
            data = 1;
            break;
        case BCM_FIELD_COLOR_YELLOW:
            data = 3;
            break;
        default:
            return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyLoopBackColor, data, mask);

    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_LoopBackColor_get
 *      Get match criteria for bcmFieldQualifyLoopBackColor
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_LoopBackColor_get(int unit,
        bcm_field_entry_t entry,
        uint8 *color)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint8 data = 0;      /* Qualifier data.          */
    uint8 mask = 0;      /* Qualifier mask.          */

    if (NULL == color) {
        return (BCM_E_PARAM);
    }
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, bcmFieldQualifyLoopBackColor,
            &data, &mask);

    BCM_IF_ERROR_RETURN(rv);

    if (mask == 0) {
        return BCM_E_NOT_FOUND;
    }

    switch (data) {
        case 0:
            *color = BCM_FIELD_COLOR_GREEN;
            break;
        case 1:
            *color = BCM_FIELD_COLOR_RED;
            break;
        case 3:
            *color = BCM_FIELD_COLOR_YELLOW;
            break;
        default:
            rv = BCM_E_INTERNAL;
    }

#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_LoopBackTrafficClass
 *      Set match criteria for bcmFieldQualifyLoopBackTrafficClass
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_LoopBackTrafficClass(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyLoopBackTrafficClass,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_LoopBackTrafficClass_get
 *      Get match criteria for bcmFieldQualifyLoopBackTrafficClass
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_LoopBackTrafficClass_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                bcmFieldQualifyLoopBackTrafficClass,
                                                data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_LoopBackPacketProcessingPort
 *      Set match criteria for bcmFieldQualifyLoopBackPacketProcessingPort
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match port.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_LoopBackPacketProcessingPort(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;            /* HW data match criteria.  */
    uint32 mask = 0;            /* HW data mask.            */

    if (0 == BCM_GPORT_IS_MODPORT(port_id)) {
        return (BCM_E_PARAM);
    }

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_GPORT_IS_MODPORT(port_mask)) {
            return (BCM_E_PARAM);
        }
    }

    data  = BCM_GPORT_MODPORT_PORT_GET(port_id);

    if (port_mask != BCM_FIELD_EXACT_MATCH_MASK) {
        mask = BCM_GPORT_MODPORT_PORT_GET(port_mask);
    } else { 
        mask = BCM_FIELD_EXACT_MATCH_MASK;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyLoopBackPacketProcessingPort, 
            data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_LoopBackPacketProcessingPort_get
 *      Get match criteria for bcmFieldQualifyLoopBackPacketProcessingPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match port.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_LoopBackPacketProcessingPort_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 data = 0;   /* HW encoded qualifier data.  */
    uint32 mask = 0;   /* HW encoding qualifier mask. */

    if ((NULL == port_id) || (NULL == port_mask)) {
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
            bcmFieldQualifyLoopBackPacketProcessingPort, &data, &mask);
    
    BCM_IF_ERROR_RETURN(rv);
    BCM_GPORT_MODPORT_SET(*port_id, ((data >> _FP_PORT_BITWIDTH(unit)) & 0xff), 
            (data & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
    BCM_GPORT_MODPORT_SET(*port_mask, ((mask >> _FP_PORT_BITWIDTH(unit)) & 0xff), 
            (mask & ((1 << _FP_PORT_BITWIDTH(unit)) - 1)));
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigMirrorOrSwitchPkt
 *      Set match criteria for bcmFieldQualifyHiGigMirrorOrSwitchPkt
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigMirrorOrSwitchPkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
 
    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigMirrorOrSwitchPkt, 
                          data, mask);
    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigMirrorOrSwitchPkt_get
 *      Get match criteria for bcmFieldQualifyHiGigMirrorOrSwitchPkt
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigMirrorOrSwitchPkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    if((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM; 
     }
 
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigMirrorOrSwitchPkt, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigMplsPkt
 *      Set match criteria for bcmFieldQualifyHiGigMplsPkt
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigMplsPkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
   
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigMplsPkt, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigMplsPkt_get
 *      Get match criteria for bcmFieldQualifyHiGigMplsPkt
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigMplsPkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigMplsPkt, data, mask);

#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDoNotFlags
 *      Set match criteria for bcmFieldQualifyHiGigDoNotFlags
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDoNotFlags(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    const uint32  data_max = BCM_FIELD_HIGIG_DONOT_LEARN | 
                             BCM_FIELD_HIGIG_DONOT_MODIFY;

    /*Input parameters check.*/
    if (data > data_max) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigDoNotFlags, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigDoNotFlags_get
 *      Get match criteria for bcmFieldQualifyHiGigDoNotFlags
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigDoNotFlags_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigDoNotFlags, data, mask);

#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigPreserveFlags
 *      Set match criteria for bcmFieldQualifyHiGigPreserveFlags
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigPreserveFlags(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    const uint32  data_max = BCM_FIELD_HIGIG_PRESERVE_DSCP | 
                             BCM_FIELD_HIGIG_PRESERVE_DOT1P;

    /*Input parameters check.*/
    if (data > data_max) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigPreserveFlags, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigPreserveFlags_get
 *      Get match criteria for bcmFieldQualifyHiGigPreserveFlags
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigPreserveFlags_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigPreserveFlags, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigLabelType
 *      Set match criteria for bcmFieldQualifyHiGigLabelType
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigLabelType(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT

    
     FP_LOCK(unit);
   
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigLabelType, 
                          data, mask);
 
    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigLabelType_get
 *      Get match criteria for bcmFieldQualifyHiGigLabelType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigLabelType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigLabelType, data, mask);         
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigVpPreserveFlags
 *      Set match criteria for bcmFieldQualifyHiGigVpPreserveFlags
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigVpPreserveFlags(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    const uint32  data_max = BCM_FIELD_HIGIG_PRESERVE_DSCP | 
                             BCM_FIELD_HIGIG_PRESERVE_DOT1P;

    /*Input parameters check.*/
    if (data > data_max) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigVpPreserveFlags, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigVpPreserveFlags_get
 *      Get match criteria for bcmFieldQualifyHiGigVpPreserveFlags
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigVpPreserveFlags_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigVpPreserveFlags, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEnginePreserveDscp
 *      Set match criteria for bcmFieldQualifyHiGigOffloadEnginePreserveDscp
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEnginePreserveDscp(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigOffloadEnginePreserveDscp, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEnginePreserveDscp_get
 *      Get match criteria for bcmFieldQualifyHiGigOffloadEnginePreserveDscp
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEnginePreserveDscp_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigOffloadEnginePreserveDscp, data, mask);

#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEnginePreserveDot1p
 *      Set match criteria for bcmFieldQualifyHiGigOffloadEnginePreserveDot1p
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEnginePreserveDot1p(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigOffloadEnginePreserveDot1p, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEnginePreserveDot1p_get
 *      Get match criteria for bcmFieldQualifyHiGigOffloadEnginePreserveDot1p
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEnginePreserveDot1p_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigOffloadEnginePreserveDot1p, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEngineSrcType
 *      Set match criteria for bcmFieldQualifyHiGigOffloadEngineSrcType
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEngineSrcType(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigOffloadEngineSrcType, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEngineSrcType_get
 *      Get match criteria for bcmFieldQualifyHiGigOffloadEngineSrcType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEngineSrcType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigOffloadEngineSrcType, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigExtendedHeaderPresent
 *      Set match criteria for bcmFieldQualifyHiGigExtendedHeaderPresent
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigExtendedHeaderPresent(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigExtendedHeaderPresent, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigExtendedHeaderPresent_get
 *      Get match criteria for bcmFieldQualifyHiGigExtendedHeaderPresent
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigExtendedHeaderPresent_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigExtendedHeaderPresent, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigVpLagFailoverPacket
 *      Set match criteria for bcmFieldQualifyHiGigVpLagFailoverPacket
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigVpLagFailoverPacket(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigVpLagFailoverPacket, 
                          data, mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigVpLagFailoverPacket_get
 *      Get match criteria for bcmFieldQualifyHiGigVpLagFailoverPacket
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigVpLagFailoverPacket_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigVpLagFailoverPacket, data, mask);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigForwardingType
 *      Set match criteria for bcmFieldQualifyHiGigForwardingType
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigForwardingType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_HiGigForwardingType_t type) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    uint32            data = 0; /* HW qualifier value.         */
    uint32            mask = 0; /* HW qualifier mask.          */
    
    if (type >= bcmFieldHiGigForwardingTypeCount) {
        return (BCM_E_PARAM);
    }

    
    
    switch (type) {
        case bcmFieldHiGigForwardingTypeControlPacket:
            data = 0;
            mask = 7;
            break;
        case bcmFieldHiGigForwardingTypeKnownL2:
            data = 4;
            mask = 7;
            break;
        case bcmFieldHiGigForwardingTypeKnownL3:
            data = 2;
            mask = 7;
            break;
        case bcmFieldHiGigForwardingTypeUnknownL2Multicast:
            data = 5;
            mask = 7;
            break;
        case bcmFieldHiGigForwardingTypeUnknownL3Multicast:
            data = 3;
            mask = 7;
            break;
        case bcmFieldHiGigForwardingTypeBroadcastOnUnknownL2Unicast:
            data = 6;
            mask = 7;
            break;
        case bcmFieldHiGigForwardingTypeBroadcast:
            data = 7;
            mask = 7;
            break;
        default:
            return (BCM_E_PARAM);
    }
    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigForwardingType,
                          data, mask);

    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigForwardingType_get
 *      Get match criteria for bcmFieldQualifyHiGigForwardingType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigForwardingType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_HiGigForwardingType_t *type)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    uint32            data;   /* HW qualifier value.         */
    uint32            mask;   /* HW qualifier mask.          */

    /* Input parameters check. */
    if (NULL == type) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                            bcmFieldQualifyHiGigForwardingType,
                            &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    if ((0 == data) && (mask == 7)) {
        *type = bcmFieldHiGigForwardingTypeControlPacket;
    } else if ((4 == data) && (mask == 7)) {
        *type = bcmFieldHiGigForwardingTypeKnownL2;
    } else if ((2 == data) && (mask == 7)) {
        *type = bcmFieldHiGigForwardingTypeKnownL3;
    } else if ((5 == data) && (mask == 7)) {
        *type = bcmFieldHiGigForwardingTypeUnknownL2Multicast;
    } else if ((3 == data) && (mask == 7)) {
        *type = bcmFieldHiGigForwardingTypeUnknownL3Multicast;
    } else if ((6 == data) && (mask == 7)) {
        *type = bcmFieldHiGigForwardingTypeBroadcastOnUnknownL2Unicast;
    } else if ((7 == data) && (mask == 7)) {
        *type = bcmFieldHiGigForwardingTypeBroadcast;
    } else {
        return (BCM_E_INTERNAL);
    }
    rv = BCM_E_NONE;
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEngineDeferredFlags
 *      Set match criteria for bcmFieldQualifyHiGigOffloadEngineDeferredFlags
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEngineDeferredFlags(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    uint32 hw_data = 0;
    uint32 hw_mask = 0;
    const uint32  data_max = BCM_FIELD_HIGIG_OFFLOAD_ENGINE_DEFERRED_DROP | 
                             BCM_FIELD_HIGIG_OFFLOAD_ENGINE_DEFERRED_CHANGE_PKT_PRIORITY |
                             BCM_FIELD_HIGIG_OFFLOAD_ENGINE_DEFERRED_CHANGE_DSCP;

    /*Input parameters check.*/
    if (data > data_max) {
        return (BCM_E_PARAM);
    }

    if (data & BCM_FIELD_HIGIG_OFFLOAD_ENGINE_DEFERRED_DROP) {
        hw_data |= 1;
        hw_mask |= 1;
    }
    
    if (data & BCM_FIELD_HIGIG_OFFLOAD_ENGINE_DEFERRED_CHANGE_PKT_PRIORITY) {
        hw_data |= 1 << 1;
        hw_mask |= 1 << 1;
    }
    
    if (data & BCM_FIELD_HIGIG_OFFLOAD_ENGINE_DEFERRED_CHANGE_DSCP) {
        hw_data |= 1 << 2;
        hw_mask |= 1 << 2;
    }
    
    
    FP_LOCK(unit);
    
    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigOffloadEngineDeferredFlags, 
                          hw_data, hw_mask);

    FP_UNLOCK(unit);    
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEngineDeferredFlags_get
 *      Get match criteria for bcmFieldQualifyHiGigOffloadEngineDeferredFlags
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEngineDeferredFlags_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    uint8 hw_data = 0;
    uint8 hw_mask = 0;

    if((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM; 
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                        bcmFieldQualifyHiGigOffloadEngineDeferredFlags, &hw_data, &hw_mask);
    
    if ((hw_data & 1) && (hw_mask & 1))  {
        *data |= BCM_FIELD_HIGIG_OFFLOAD_ENGINE_DEFERRED_DROP;
        *mask |= BCM_FIELD_HIGIG_OFFLOAD_ENGINE_DEFERRED_DROP;
    }
    if ((hw_data & (1 << 1)) && (hw_mask & (1 << 1))) {
        *data |= BCM_FIELD_HIGIG_OFFLOAD_ENGINE_DEFERRED_CHANGE_PKT_PRIORITY;
        *mask |= BCM_FIELD_HIGIG_OFFLOAD_ENGINE_DEFERRED_CHANGE_PKT_PRIORITY;
    }
    if ((hw_data & (1 << 2)) && (hw_mask & (1 << 2))) {
        *data |= BCM_FIELD_HIGIG_OFFLOAD_ENGINE_DEFERRED_CHANGE_DSCP;
        *mask |= BCM_FIELD_HIGIG_OFFLOAD_ENGINE_DEFERRED_CHANGE_DSCP;
    }
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEngineVxltStatus
 *      Set match criteria for bcmFieldQualifyHiGigOffloadEngineVxltStatus
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEngineVxltStatus(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigOffloadEngineVxltStatus,
            data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigOffloadEngineVxltStatus_get
 *      Get match criteria for bcmFieldQualifyHiGigOffloadEngineVxltStatus
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_HiGigOffloadEngineVxltStatus_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL; 

#if defined BCM_TOMAHAWK_SUPPORT
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                        bcmFieldQualifyHiGigOffloadEngineVxltStatus, 
                        data, mask);
#endif
    return rv;
}


/*
 * Function: bcm_esw_field_presel_get
 *
 * Purpose:
 *     Retrieve the set of preselectors associated with the given group.
 *
 * Parameters:
 *     unit      - (IN)  BCM device number.
 *     group     - (IN)  Group Id.
 *     presel    - (OUT) Reference to the set of preselectors. 
 *
 * Returns:
 *     BCM_E_PARAM    - if presel_id == NULL or given group Id is not valid.
 *     BCM_E_UNAVAIL  - not supported
 *     BCM_E_NONE     - Success
 */

int
bcm_esw_field_group_presel_get(
    int unit,
    bcm_field_group_t group,
    bcm_field_presel_set_t *presel)
{
    int                  rv = BCM_E_UNAVAIL; /* Operation return status.  */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support)) {

       /* Get field control structure. */
       
       FP_LOCK(unit);
       rv = (_bcm_field_th_group_presel_get(unit, group, presel));
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    return rv;
}

/*
 * Function: bcm_esw_field_presel_set
 *
 * Purpose:
 *     Set the preselectors to the given group.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     group     - (IN) Group Id.
 *     presel    - (IN) Reference to the set of preselectors. 
 *
 * Returns:
 *     BCM_E_PARAM     - if presel_id == NULL
 *     BCM_E_UNAVAIL   - not supported
 *     BCM_E_NOT_FOUND - if the presel Ids are not created.
 *     BCM_E_INTERNAL   - in-case of internal functionality issues.
 *     BCM_E_NONE      - Success
 */

int
bcm_esw_field_group_presel_set(
    int unit,
    bcm_field_group_t group,
    bcm_field_presel_set_t *presel)
{
    int                  rv = BCM_E_UNAVAIL; /* Operation return status.  */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support)) {

       /* Get field control structure. */
       
       FP_LOCK(unit);
       rv = (_bcm_field_th_group_presel_set(unit, group, presel));
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    return rv;
}

/*
 * Function: bcm_esw_field_presel_create
 *
 * Purpose:
 *     Create an unique new field preselector Id.
 *
 * Parameters:
 *     unit      - (IN)  BCM device number.
 *     presel_id - (OUT) Reference to a new preselector ID to be created
 *
 * Returns:
 *     BCM_E_PARAM    - if presel_id == NULL
 *     BCM_E_UNAVAIL  - not supported
 *     BCM_E_NONE     - Success
 */

int
bcm_esw_field_presel_create(
    int unit,
    bcm_field_presel_t *presel_id)
{
    int                  rv = BCM_E_UNAVAIL; /* Operation return status.  */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support)) {

       /* Get field control structure. */
       
       FP_LOCK(unit);
       rv = (_bcm_field_th_presel_create(unit, 0, presel_id));
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    return rv;
}

/*
 * Function: bcm_esw_field_presel_create_id
 *
 * Purpose:
 *     Create the requested field preselector Id.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     presel_id - (IN) A new preselector ID to be created
 *
 * Returns:
 *     BCM_E_PARAM    - if the given presel_id is not valid.
 *     BCM_E_UNAVAIL  - not supported
 *     BCM_E_NONE     - Success
 */
int
bcm_esw_field_presel_create_id(
    int unit,
    bcm_field_presel_t presel_id)

{
    int                  rv = BCM_E_UNAVAIL; /* Operation return status.  */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support)) {

       /* Get field control structure. */
       
       FP_LOCK(unit);

       rv = (_bcm_field_th_presel_create(unit, _bcmFieldPreselCreateWithId,
                                         &presel_id));
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    return rv;
}

/*
 * Function: bcm_esw_field_presel_destroy
 *
 * Purpose:
 *     Destroy the requested field preselector Id.
 *
 * Parameters:
 *     unit      - (IN) BCM device number.
 *     presel_id - (IN) A new preselector ID to be destroyed
 *
 * Returns:
 *     BCM_E_PARAM   - if the given presel_id is not valid.
 *     BCM_E_UNAVAIL - not supported
 *     BCM_E_BUSY    - If the presel is already in use by a group.
 *     BCM_E_NONE    - Success
 */
int
bcm_esw_field_presel_destroy(
    int unit,
    bcm_field_presel_t presel_id)
{
    int                  rv = BCM_E_UNAVAIL; /* Operation return status.  */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support)) {

       /* Get field control structure. */
       
       FP_LOCK(unit);
       rv = (_bcm_field_th_presel_destroy(unit, presel_id));
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    return rv;
}
 
/*
 * Function: bcm_esw_field_qualify_Stage
 *
 * Purpose:
 *     Set match criteria for bcmFieldQualifyStage
 *     qualifier in the field entry.
 *
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) Stage Qualifier match data.
 *
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_Stage(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_stage_t data)
{
    int  rv = BCM_E_UNAVAIL; /* Operation return status.  */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) &&
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
       uint32               data32, mask32;

       /* Get field control structure. */
       
       FP_LOCK(unit);
       data32 = mask32 = data;
       /* coverity[address_of : FALSE] */
       /* coverity[callee_ptr_arith : FALSE] */
       rv = _bcm_field_presel_qualify_set(unit, entry,
                                          bcmFieldQualifyStage,
                                          &data32, &mask32);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    return rv;
}

/*
 * Function: bcm_esw_field_qualify_Stage_get
 *
 * Purpose:
 *     Retrieve the stage qualifier configured for the given entry.
 *
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (OUT) Stage Qualifier match data.
 *
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_Stage_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_stage_t *data)
{
    int  rv = BCM_E_UNAVAIL; /* Operation return status.  */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_preselector_support) &&
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
       _bcm_field_qual_data_t q_data = {0};
       _bcm_field_qual_data_t q_mask = {0};

       /* Get field control structure. */
       
       FP_LOCK(unit);
       rv = _bcm_field_presel_qualifier_get(unit, entry,
                                            bcmFieldQualifyStage,
                                            q_data, q_mask);
       *data = q_data[0];
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    return rv;
}

/* Function    : bcm_esw_field_qualify_IpFragNonOrFirst
 * Description : qualify on Ip Frag Info.
 * Parameters  : (IN) unit       BCM device number
 *               (IN) entry      Field entry to qualify
 *               (IN) data       Matching data
 *               (IN) mask       Bit mask for data
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_IpFragNonOrFirst(int unit, bcm_field_entry_t entry,
                                  uint8 data, uint8 mask)
{
    int             rv = BCM_E_UNAVAIL;
#if defined(BCM_TOMAHAWK_SUPPORT)

    if (data > 0x1) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIpFragNonOrFirst, data, mask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/* Function    : bcm_esw_field_qualify_IpFragNonOrFirst_get
 * Description : qualify on Ip Frag Info.
 * Parameters  : (IN) unit       BCM device number
 *               (IN) entry      Field entry to qualify
 *               (OUT) data       Matching data
 *               (OUT) mask       Bit mask for data
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_IpFragNonOrFirst_get(int unit, bcm_field_entry_t entry,
                                  uint8 *data, uint8 *mask)
{
    int             rv = BCM_E_UNAVAIL;
#if defined(BCM_TOMAHAWK_SUPPORT)
    /* Input parameters check. */
    if ((NULL == data) || (NULL ==mask)) {
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, bcmFieldQualifyIpFragNonOrFirst, data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/* Function    : bcm_esw_field_qualify_PacketLength
 * Description : qualify on Packet Length (excluding L2 header and VLAN TAG).
 * Parameters  : (IN) unit       BCM device number
 *               (IN) entry      Field entry to qualify
 *               (IN) data       Matching data
 *               (IN) mask       Bit mask for data
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_PacketLength(int unit, bcm_field_entry_t entry,
                                  uint16 data, uint16 mask)
{
    int             rv = BCM_E_UNAVAIL;
#if defined(BCM_TOMAHAWK_SUPPORT)

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyPacketLength, data, mask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/* Function    : bcm_esw_field_qualify_PacketLength_get
 * Description : qualify on Packet Length (excluding L2 header and VLAN TAG).
 * Parameters  : (IN) unit       BCM device number
 *               (IN) entry      Field entry to qualify
 *               (OUT) data       Matching data
 *               (OUT) mask       Bit mask for data
 * Returns     : BCM_E_XXX
 */
int bcm_esw_field_qualify_PacketLength_get(int unit, bcm_field_entry_t entry,
                                  uint16 *data, uint16 *mask)
{
    int             rv = BCM_E_UNAVAIL;
#if defined(BCM_TOMAHAWK_SUPPORT)
    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    rv = _bcm_field_entry_qualifier_uint16_get(unit, entry, bcmFieldQualifyPacketLength, data, mask);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_GroupClass
 *
 * Purpose:
 *     Set a Group class id packet qualification on an entry.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number
 *     entry    - (IN) Entry ID
 *     data     - (IN) Group Class id.
 *     mask     - (IN) Group Class mask.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_GroupClass(int unit, bcm_field_entry_t entry,
                                         uint32 data, uint32 mask)
{

    int             rv = BCM_E_UNAVAIL;
#if defined(BCM_TOMAHAWK_SUPPORT)

    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
              (_bcm_field_th_qualify_class(unit, entry,
                                           bcmFieldQualifyGroupClass,
                                           &data, &mask));
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyGroupClass,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_GroupClass_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifGroupClass
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_GroupClass_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                entry,
                bcmFieldQualifyGroupClass,
                data,
                mask
                ));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     bcm_esw_field_qualify_UdfClass
 *
 * Purpose:
 *     Set a Udf class id packet qualification on an entry.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number
 *     entry    - (IN) Entry ID
 *     data     - (IN) UDF Class id.
 *     mask     - (IN) UDF Class mask.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_UdfClass(int unit, bcm_field_entry_t entry,
                                         uint32 data, uint32 mask)
{

    int             rv = BCM_E_UNAVAIL;
#if defined(BCM_TOMAHAWK_SUPPORT)

    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
              (_bcm_field_th_qualify_class(unit, entry,
                                           bcmFieldQualifyUdfClass,
                                           &data, &mask));
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyUdfClass,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_UdfClass_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifUdfClass
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_UdfClass_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                entry,
                bcmFieldQualifyUdfClass,
                data,
                mask
                ));

    return (BCM_E_NONE);
}

/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceLookupClassPort
 *
 * Purpose:
 *     Set a Port interface Lookup class id packet qualification on an entry.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number
 *     entry    - (IN) Entry ID
 *     data     - (IN) Interface Class id.
 *     mask     - (IN) Interface Class mask.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_InterfaceLookupClassPort(int unit, bcm_field_entry_t entry,
                                         uint32 data, uint32 mask)
{

    int             rv = BCM_E_UNAVAIL;
#if defined(BCM_TOMAHAWK_SUPPORT)

    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
              (_bcm_field_th_qualify_class(unit, entry,
                                           bcmFieldQualifyInterfaceLookupClassPort,
                                           &data, &mask));
    } else if (data  > SOC_INTF_CLASS_MAX(unit)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: data=%#x out-of-range\n"),
                   unit, data));
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInterfaceLookupClassPort,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InterfaceLookupClassPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInterfaceLookupClassPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_InterfaceLookupClassPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                entry,
                bcmFieldQualifyInterfaceLookupClassPort,
                data,
                mask
                ));

    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_ExactMatchHitStatus
 * Purpose:
 *      Set a exact match hit status qualification on an entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field entry Id.
 *      group_pri - (IN) Field Group Priority.
 *      data      - (IN) Exact Match Hit Status.
 *      mask      - (IN) Exact Match Hit Status Mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ExactMatchHitStatus(int unit,
                                          bcm_field_entry_t entry,
                                          int group_pri,
                                          uint8 data,
                                          uint8 mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint8  lkup = 0;            /* Exact Match Group Lookup Information. */
    
    /* Retreive Field Control Information. */
    

    /* Take Field Lock. */
    FP_LOCK(unit);
    
    /* Get Exact Match Group Lookup Information. */
    rv = _field_th_em_group_lookup_get(unit, group_pri, &lkup);
    
    /* If found, qualify for corresponding lookup information. */
    if (BCM_SUCCESS(rv)) {
        if (lkup == BCM_FIELD_EXACT_MATCH_LOOKUP_0) {
            rv = _field_qualify32(unit, entry, 
                                  _bcmFieldQualifyExactMatchHitStatusLookup0,
                                  data, mask);
        } else if (lkup == BCM_FIELD_EXACT_MATCH_LOOKUP_1) {
            rv = _field_qualify32(unit, entry, 
                                  _bcmFieldQualifyExactMatchHitStatusLookup1,
                                  data, mask);
        } else {
            rv = BCM_E_INTERNAL; 
        }
    }
    
    /* Release Field Lock. */
    FP_UNLOCK(unit);
#endif
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_ExactMatchHitStatus_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyExactMatchHitStatus
 *                     qualifier from the field entry.
 * Parameters:
 *      unit      - (IN)  Unit number.
 *      entry     - (IN)  Field entry Id.
 *      group_pri - (IN)  Field Group Priority.
 *      data      - (OUT) Exact Match Hit Status.
 *      mask      - (OUT) Exact Match Hit Status Mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ExactMatchHitStatus_get(int unit,
                                              bcm_field_entry_t entry,
                                              int group_pri,
                                              uint8 *data,
                                              uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;         /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint8  lkup = 0;                /* Exact Match Group Lookup 
                                       Information.             */
    _bcm_field_qual_data_t q_data;  /* Qualifier match data.    */ 
    _bcm_field_qual_data_t q_mask;  /* Qualifier match mask.    */

    /* Retreive Field Control Information. */
    

    /* Input Parameter Check. */
    if ((NULL == data) || (NULL == mask)) {
        return (BCM_E_PARAM);
    }

    /* Take Field Lock. */
    FP_LOCK(unit);

    /* Get Exact Match Group Lookup Information. */
    rv = _field_th_em_group_lookup_get(unit, group_pri, &lkup);

    /* If found, qualify for corresponding lookup information. */
    if (BCM_SUCCESS(rv)) {
        if (lkup == BCM_FIELD_EXACT_MATCH_LOOKUP_0) {
            rv = _field_entry_qualifier_key_get(unit, entry,
                    _bcmFieldQualifyExactMatchHitStatusLookup0,
                    q_data, q_mask);
        } else if (lkup == BCM_FIELD_EXACT_MATCH_LOOKUP_1) {
            rv = _field_entry_qualifier_key_get(unit, entry,
                    _bcmFieldQualifyExactMatchHitStatusLookup1,
                    q_data, q_mask);
        } else {
            rv = BCM_E_INTERNAL;
        }
    }

    if (BCM_SUCCESS(rv)) {
        *data = q_data[0];
        *mask = q_mask[0];
    }

    /* Release Field Lock. */
    FP_UNLOCK(unit);
#endif
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_ExactMatchActionClassId
 * Purpose:
 *      Set a exact match action classid qualification on an entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field entry Id.
 *      group_pri - (IN) Field Group Priority.
 *      data      - (IN) Exact Match Action Class Id.
 *      mask      - (IN) Exact Match Action Class Id Mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ExactMatchActionClassId(int unit,
                                              bcm_field_entry_t entry,
                                              int group_pri,
                                              uint32 data,
                                              uint32 mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint8  lkup = 0;            /* Exact Match Group Lookup
                                   Information.             */
    /* Retreive Field Control Structure. */
    
    
    FP_LOCK(unit);
    
    /* Retreive exact match group lookup information. */
    rv = _field_th_em_group_lookup_get(unit, group_pri, &lkup);

    /* If found, qualify for corresponding lookup information. */ 
    if (BCM_SUCCESS(rv)) {
        if (lkup == BCM_FIELD_EXACT_MATCH_LOOKUP_0) {
            rv = _field_qualify32(unit, entry, 
                                  _bcmFieldQualifyExactMatchActionClassIdLookup0, 
                                  data, mask);
        } else if (lkup == BCM_FIELD_EXACT_MATCH_LOOKUP_1) {
            rv = _field_qualify32(unit, entry, 
                                  _bcmFieldQualifyExactMatchActionClassIdLookup1, 
                                  data, mask);
        } else {
            rv = BCM_E_INTERNAL;
        }
    }
    
    FP_UNLOCK(unit);
#endif
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_ExactMatchActionClassId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyExactMatchActionClassId
 *                     qualifier from the field entry.
 * Parameters:
 *      unit      - (IN)  Unit number.
 *      entry     - (IN)  Field entry Id.
 *      group_pri - (IN)  Field Group Priority.
 *      data      - (OUT) Exact Match Action Class Id.
 *      mask      - (OUT) Exact Match Action Class Id Mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ExactMatchActionClassId_get(int unit,
                                                  bcm_field_entry_t entry,
                                                  int group_pri,
                                                  uint32 *data,
                                                  uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint8  lkup = 0;                 /* Exact Match Group Lookup
                                        Information.             */
    _bcm_field_qual_data_t q_data;   /* Qualifier match data.    */ 
    _bcm_field_qual_data_t q_mask;   /* Qualifier match mask.    */

    /* Retreive field control structure. */
    

    FP_LOCK(unit);

    /* Retreive exact match group lookup information. */
    rv = _field_th_em_group_lookup_get(unit, group_pri, &lkup);

    /* If found, qualify for corresponding lookup information. */
    if (BCM_SUCCESS(rv)) {
        if (lkup == BCM_FIELD_EXACT_MATCH_LOOKUP_0) {
            rv = _field_entry_qualifier_key_get(unit, entry, 
                                                _bcmFieldQualifyExactMatchActionClassIdLookup0,
                                                q_data, q_mask);
        } else if (lkup == BCM_FIELD_EXACT_MATCH_LOOKUP_1) {
            rv = _field_entry_qualifier_key_get(unit, entry, 
                                                _bcmFieldQualifyExactMatchActionClassIdLookup1,
                                                q_data, q_mask);
        } else {
            rv = BCM_E_INTERNAL;
        }
    }

    if (BCM_SUCCESS(rv)) {
        *data = q_data[0];
        *mask = q_mask[0];
    }
    FP_UNLOCK(unit);
#endif


    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_ExactMatchGroupClassId
 * Purpose:
 *      Set a exact match group classid qualification on an entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field entry Id.
 *      group_pri - (IN) Field Group Priority.
 *      group     - (IN) Field group Id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ExactMatchGroupClassId(int unit,
                                             bcm_field_entry_t entry,
                                             int group_pri,
                                             bcm_field_group_t group)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint8  lkup = 0;        /* Exact Match Group Lookup
                               Information.             */
    _field_group_t *fg;     /* Field Group Structure.   */

    /* Retreive Field Control Information. */
    
    
    FP_LOCK(unit);
   
    /* Retreive exact match group lookup information. */   
    rv = _field_th_em_group_lookup_get(unit, group_pri, &lkup);
    
    /* If found, qualify for corresponding lookup information. */
    if (BCM_SUCCESS(rv)) {
        rv = _field_group_get(unit, group, &fg);
        if (BCM_SUCCESS(rv)) {
            if (lkup == BCM_FIELD_EXACT_MATCH_LOOKUP_0) {
                rv = _field_qualify32(unit, entry, 
                                      _bcmFieldQualifyExactMatchGroupClassIdLookup0, 
                                       fg->lt_id, -1);
            } else if (lkup == BCM_FIELD_EXACT_MATCH_LOOKUP_1) {
                rv = _field_qualify32(unit, entry, 
                                      _bcmFieldQualifyExactMatchGroupClassIdLookup1, 
                                      fg->lt_id, -1);
            } else {
                rv = BCM_E_INTERNAL; 
            }
        }
    }
    
    FP_UNLOCK(unit);
#endif
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_ExactMatchGroupClassId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyExactMatchGroupClassId
 *                     qualifier from the field entry.
 * Parameters:
 *      unit      - (IN)  Unit number.
 *      entry     - (IN)  Field entry Id.
 *      group_pri - (IN)  Field Group Priority.
 *      group     - (OUT) Field Group Id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ExactMatchGroupClassId_get(int unit,
                                                 bcm_field_entry_t entry,
                                                 int group_pri,
                                                 bcm_field_group_t *group)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */
#if defined BCM_TOMAHAWK_SUPPORT
    uint8  lkup = 0;                /* Exact Match Group Lookup
                                       Information.             */
    _bcm_field_qual_data_t q_data;  /* Qualifier match data.    */ 
    _bcm_field_qual_data_t q_mask;  /* Qualifier match mask.    */
    int ltid = -1;                  /* Logical Table Id.        */

    /* Retreive Field Control Information. */
    
    
    FP_LOCK(unit);

    /* Retreive exact match group lookup information. */
    rv = _field_th_em_group_lookup_get(unit, group_pri, &lkup);
    
    /* If found, qualify for corresponding lookup information. */   
    if (BCM_SUCCESS(rv)) {
        if (lkup == BCM_FIELD_EXACT_MATCH_LOOKUP_0) {
            rv = _field_entry_qualifier_key_get(unit, entry, 
                                                _bcmFieldQualifyExactMatchGroupClassIdLookup0, 
                                                q_data, q_mask);
        } else if (lkup == BCM_FIELD_EXACT_MATCH_LOOKUP_1) {
            rv = _field_entry_qualifier_key_get(unit, entry, 
                                                _bcmFieldQualifyExactMatchGroupClassIdLookup1, 
                                                q_data, q_mask);
        } else {
            rv = BCM_E_INTERNAL;
        }
    }

    if (BCM_SUCCESS(rv)) {
        ltid = q_data[0];
        /* Retreive Field Group Based on ltid. */
        rv = _field_th_em_ltid_based_groupid_get(unit, ltid, group);
    }

    FP_UNLOCK(unit);
#endif
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_source_class_mode_set
 * Purpose:
 *      Configure Field Processor Source Class operational mode
 *      per-CAP stage.
 * Parameters:
 *      unit    - (IN) BCM Device number.
 *      stage   - (IN) Field Stage enum value.
 *      pbmp    - (IN) Device Port Bitmap value
 *      mode    - (IN) Field Source Class Operational Mode enum value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      Valid "stage" input parameter values supported by
 *      this API are:
 * 	            "bcmFieldStageIngress"
 *              "bcmFieldStageIngressExactMatch"
 */
int
bcm_esw_field_source_class_mode_set(int unit,
                                        bcm_field_stage_t stage,
                                        bcm_pbmp_t pbmp,
                                        bcm_field_src_class_mode_t mode)
{
    int                      rv = BCM_E_UNAVAIL; /* Operation return status. */
#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       

       FP_LOCK(unit);
       rv = (_bcm_field_th_source_class_mode_set(unit, stage, pbmp, mode));
       FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_source_class_mode_get
 * Purpose:
 *      Retrieve Field Processor Source Class operational mode
 *      per-CAP stage.
 * Parameters:
 *      unit    - (IN)  BCM Device number.
 *      stage   - (IN)  Field Stage enum value.
 *      pbmp    - (IN)  Device Port Bitmap value
 *      mode    - (OUT) Reference to Field Source Class Operational
 *                      Mode enum value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      Valid "stage" input parameter values supported by
 *      this API are:
 * 	            "bcmFieldStageIngress"
 *              "bcmFieldStageIngressExactMatch"
 */
int
bcm_esw_field_source_class_mode_get(int unit,
                                        bcm_field_stage_t stage,
                                        bcm_pbmp_t pbmp,
                                        bcm_field_src_class_mode_t *mode)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

#if defined(BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       rv = _bcm_field_th_source_class_mode_get(unit, stage, pbmp, mode);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */

    return rv;
}

 /*
 * Function:
 *      bcm_esw_field_qualify_MixedSrcClassId
 * Purpose:
 *     Add a Mixed Source Class Id field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      pbmp  - (IN) Device Port Bitmap value
 *      data  - (IN) Mixed Source Class Id.
 *      mask  - (IN) Mixed Source Class Id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MixedSrcClassId(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_pbmp_t pbmp,
                                        bcm_field_src_class_t data,
                                        bcm_field_src_class_t mask)
{
    int                      rv = BCM_E_UNAVAIL; /* Operation return status. */
#if defined(BCM_TOMAHAWK_SUPPORT)

    
    FP_LOCK(unit);

    rv = _bcm_field_th_qualify_MixedSrcClassId(unit, entry, pbmp, data, mask);

    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MixedSrcClassId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMixedSrcClassId
 *                     qualifier from the field entry.
 * Parameters:
 *      unit  - (IN)  Unit number.
 *      entry - (IN)  Field Entry id.
 *      pbmp  - (IN)  Device Port Bitmap value
 *      data  - (OUT) Mixed Source Class Id.
 *      mask  - (OUT) Mixed Source Class Id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MixedSrcClassId_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_pbmp_t pbmp,
                                        bcm_field_src_class_t *data,
                                        bcm_field_src_class_t *mask)
{
    int                      rv = BCM_E_UNAVAIL; /* Operation return status. */
#if defined(BCM_TOMAHAWK_SUPPORT)
    uint32                   hw_data;            /* HW data match criteria.  */
    uint32                   hw_mask;            /* HW data mask.            */

    if ((data == NULL) || (mask == NULL)) {
        return BCM_E_PARAM;
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyMixedSrcClassId,
                                            &hw_data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);

    
    FP_LOCK(unit);

    rv = _bcm_field_th_qualify_MixedSrcClassId_get(unit, entry, pbmp,
            hw_data, hw_mask, data, mask);

    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_InterfaceIngressKeySelectClassPort
 *
 * Purpose:
 *     Set a Port interface Ingress Key Select class id packet qualification on an entry.
 *
 * Parameters:
 *     unit     - (IN) BCM unit number
 *     entry    - (IN) Entry ID
 *     data     - (IN) Interface Class id.
 *     mask     - (IN) Interface Class mask.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_InterfaceIngressKeySelectClassPort(int unit, bcm_field_entry_t entry,
                                         uint32 data, uint32 mask)
{

    int             rv = BCM_E_UNAVAIL;
#if defined(BCM_TOMAHAWK_SUPPORT)

    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        BCM_IF_ERROR_RETURN
              (_bcm_field_th_qualify_class(unit, entry,
                                           bcmFieldQualifyInterfaceIngressKeySelectClassPort,
                                           &data, &mask));
    } else if (data  > SOC_INTF_CLASS_MAX(unit)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: data=%#x out-of-range\n"),
                   unit, data));
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInterfaceIngressKeySelectClassPort,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_InterfaceIngressKeySelectClassPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInterfaceIngressKeySelectClassPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 *
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_qualify_InterfaceIngressKeySelectClassPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    /* Read qualifier match value and mask. */
    BCM_IF_ERROR_RETURN(_bcm_field_entry_qualifier_uint32_get(unit,
                entry,
                bcmFieldQualifyInterfaceIngressKeySelectClassPort,
                data,
                mask
                ));

    return (BCM_E_NONE);
}


/*
 * Function:
 *      bcm_esw_field_qualify_ISid
 * Purpose:
 *      Add Service Instance tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ISid(int unit, bcm_field_entry_t entry,
                            uint32 data, uint32 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyISid,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_ISid_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyISid
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ISid_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                                 bcmFieldQualifyISid,
                                                 data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_ITag
 * Purpose:
 *      Add Service Instance tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ITag(int unit, bcm_field_entry_t entry,
                            uint32 data, uint32 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyITag,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_ITag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyITag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ITag_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                                 bcmFieldQualifyITag,
                                                 data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_BfdYourDiscriminator
 * Purpose:
 *      Add BFD Your Discriminator field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_BfdYourDiscriminator(int unit, bcm_field_entry_t entry,
                            uint32 data, uint32 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyBfdYourDiscriminator,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_BfdYourDiscriminator_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyBfdYourDiscriminator
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_BfdYourDiscriminator_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                                 bcmFieldQualifyBfdYourDiscriminator,
                                                 data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_CpuVisibilityPacket
 * Purpose:
 *      Add CPU Visibility Packet field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_CpuVisibilityPacket(int unit, bcm_field_entry_t entry,
                            uint8 data, uint8 mask)
{
    int rv = BCM_E_UNAVAIL;          /* Operation return status. */

#if defined BCM_TOMAHAWK_SUPPORT

    if (data > 0x1) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyCpuVisibilityPacket,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_CpuVisibilityPacket_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyCpuVisibilityPacket
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_CpuVisibilityPacket_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                 bcmFieldQualifyCpuVisibilityPacket,
                                                 data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstL2MulticastGroup
 * Purpose:
 *     Add a destination L2 multicast group field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      group - (IN) L2 Multicast group id.
 *      mask  - (IN) L2 Multicast group id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstL2MulticastGroup(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_multicast_t group,
                                        bcm_multicast_t mask)
{
    int rv = BCM_E_UNAVAIL;                 /* Operation return status. */
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
    uint32 data;            /* HW data match criteria.  */
    uint32 hw_mask;            /* HW data mask.            */

    /* Input parameters check. */
    if (0 == _BCM_MULTICAST_IS_SET(group)) {
        return (BCM_E_PARAM);
    }

    if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_MULTICAST_IS_SET(mask)) {
            return (BCM_E_PARAM);
        }
        hw_mask = BCM_MULTICAST_L2_GET(mask);
    } else {
        hw_mask = (BCM_FIELD_EXACT_MATCH_MASK);
    }

    if ( !(_BCM_MULTICAST_IS_L2(group))) {
        return (BCM_E_PARAM);
    }

    data  = BCM_MULTICAST_L2_GET(group);

    BCM_IF_ERROR_RETURN(_field_dest_type_qualify(unit, entry,
                        bcmFieldQualifyDstL2MulticastGroup, &data, &hw_mask,
                        _bcmFieldDestTypeL2mc));

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstL2MulticastGroup,
                                          data, hw_mask, 0);
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstL2MulticastGroup,
                          data, hw_mask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstL2MulticastGroup_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstL2MulticastGroup
 *                     qualifier from the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      group - (OUT) L2 Multicast group id.
 *      mask  - (OUT) L2 Multicast group id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstL2MulticastGroup_get(int unit,
                                            bcm_field_entry_t entry,
                                            bcm_multicast_t *group,
                                            bcm_multicast_t *mask)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 hw_mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyDstL2MulticastGroup,
                                            &data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);

    BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
        entry, bcmFieldQualifyDstL2MulticastGroup, &data, &hw_mask));

    /* L2 MC */
    BCM_MULTICAST_L2_SET(*group, data);
    BCM_MULTICAST_L2_SET(*mask, hw_mask);
    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstL3MulticastGroup
 * Purpose:
 *     Add a destination L3 multicast group field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      group - (IN) L3 Multicast group id.
 *      mask  - (IN) L3 Multicast group id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstL3MulticastGroup(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_multicast_t group,
                                        bcm_multicast_t mask)
{
    int rv = BCM_E_UNAVAIL;                 /* Operation return status. */
#if defined(BCM_TOMAHAWK_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
    uint32 data;            /* HW data match criteria.  */
    uint32 hw_mask;            /* HW data mask.            */

    /* Input parameters check. */
    if (0 == _BCM_MULTICAST_IS_SET(group)) {
        return (BCM_E_PARAM);
    }

    if (mask != BCM_FIELD_EXACT_MATCH_MASK) {
        if (0 == BCM_MULTICAST_IS_SET(mask)) {
            return (BCM_E_PARAM);
        }
        hw_mask = BCM_MULTICAST_L3_GET(mask);
    } else {
        hw_mask = (BCM_FIELD_EXACT_MATCH_MASK);
    }

    if (!(_BCM_MULTICAST_IS_L3(group))) {
        return (BCM_E_PARAM);
    }

    data  = BCM_MULTICAST_L3_GET(group);

    BCM_IF_ERROR_RETURN(_field_dest_type_qualify(unit, entry,
                        bcmFieldQualifyDstL3MulticastGroup, &data, &hw_mask,
                        _bcmFieldDestTypeL3mc));

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstL3MulticastGroup,
                                          data, hw_mask, 0);
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = _field_qualify32(unit, entry, bcmFieldQualifyDstL3MulticastGroup,
                          data, hw_mask);
    FP_UNLOCK(unit);
#endif /* BCM_TOMAHAWK_SUPPORT */
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstL3MulticastGroup_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstL3MulticastGroup
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      group - (OUT) L3 Multicast group id.
 *      mask  - (OUT) L3 Multicast group id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstL3MulticastGroup_get(int unit,
                                            bcm_field_entry_t entry,
                                            bcm_multicast_t *group,
                                            bcm_multicast_t *mask)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 hw_mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyDstL3MulticastGroup,
                                            &data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);

    BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
        entry, bcmFieldQualifyDstL3MulticastGroup, &data, &hw_mask));

    /* IPMC */
    BCM_MULTICAST_L3_SET(*group, data);
    BCM_MULTICAST_L3_SET(*mask, hw_mask);
    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_qualify_CustomHeaderPkt
 * Purpose:
 *       Set match criteria for bcmFieldQualifyCustomHeaderPkt
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_CustomHeaderPkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int              rv;       /* Operation return status. */

    /* Validate Custom header packet, should not be more than 1-bit */
    if (data & ~(0x1)) {
       return BCM_E_PARAM; 
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyCustomHeaderPkt, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_CustomHeaderPkt_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyCustomHeaderPkt
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_CustomHeaderPkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyCustomHeaderPkt,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_CustomHeaderData
 * Purpose:
 *       Set match criteria for bcmFieldQualifyCustomHeaderData
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_CustomHeaderData(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    int              rv;       /* Operation return status. */


    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyCustomHeaderData, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_CustomHeaderData_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyCustomHeaderData
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_CustomHeaderData_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                            bcmFieldQualifyCustomHeaderData,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MHPriority
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMHPriority
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MHPriority(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int              rv;       /* Operation return status. */

    /* Validate MHPriority, should not be more than 4-bit */
    if (data & ~(0xF)) {
       return BCM_E_PARAM;
    }

    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMHPriority, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MHPriority_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMHPriority
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MHPriority_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyMHPriority,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_PdelayReq
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPdelayReq
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_PdelayReq(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int              rv;       /* Operation return status. */

    /* Validate PDELAY_REQ, should not be more than 1-bit */
    if (data & ~(0x1)) {
       return BCM_E_PARAM;
    }

    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyPdelayReq, data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_PdelayReq_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPdelayReq
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_PdelayReq_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyPdelayReq,
                                            data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlPkt
 * Purpose:
 *      Set match criteria for bcmFieildQualifyMimlPkt
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data. 0/1 Non-Miml/Miml packets
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MimlPkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_miml)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, bcmFieldQualifyMimlPkt, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlPkt_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMimlPkt
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MimlPkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_miml)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                   bcmFieldQualifyMimlPkt,
                                   data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlSrcMac
 * Purpose:
 *      Set match criteria for bcmFieildQualifyMimlSrcMac
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MimlSrcMac(int unit, bcm_field_entry_t entry,
                             bcm_mac_t data, bcm_mac_t mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_miml)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify_macaddr(unit, entry, bcmFieldQualifyMimlSrcMac,
                                    data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlDstMac
 * Purpose:
 *      Set match criteria for bcmFieildQualifyMimlDstMac
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MimlDstMac(int unit, bcm_field_entry_t entry,
                             bcm_mac_t data, bcm_mac_t mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_miml)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify_macaddr(unit, entry, bcmFieldQualifyMimlDstMac,
                                    data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlSrcMac_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMimlSrcMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MimlSrcMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_miml)) {
        rv = _field_qualify_macaddr_get(unit, entry, 
                                   bcmFieldQualifyMimlSrcMac,
                                   data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlDstMac_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMimlDstMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MimlDstMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_miml)) {
        rv = _field_qualify_macaddr_get(unit, entry, 
                                   bcmFieldQualifyMimlDstMac,
                                   data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlVlan
 * Purpose:
 *       Set match criteria for bcmFieildQualifyMimlVlan
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MimlVlan(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_miml)) {
        rv = bcm_esw_field_qualify_MimlVlanId(unit, entry, 
                                               (data & 0xfff), 
                                               (mask & 0xfff));
        BCM_IF_ERROR_RETURN(rv);
    
        rv = bcm_esw_field_qualify_MimlVlanCfi(unit, entry, 
                                                ((data >> 12) & 0x1),
                                                ((mask >> 12) & 0x1));
        BCM_IF_ERROR_RETURN(rv);
    
        rv = bcm_esw_field_qualify_MimlVlanPri(unit, entry,
                                                (data >> 13),
                                                (mask >> 13));
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlVlanId
 * Purpose:
 *       Set match criteria for bcmFieildQualifyMimlVlanId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MimlVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_miml)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, bcmFieldQualifyMimlVlanId, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlVlanPri
 * Purpose:
 *       Set match criteria for bcmFieildQualifyMimlVlanPri
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MimlVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_miml)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, bcmFieldQualifyMimlVlanPri, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}


/*
 * Function:
 *      bcm_esw_field_qualify_MimlVlanCfi
 * Purpose:
 *       Set match criteria for bcmFieildQualifyMimlVlanCfi
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MimlVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_miml)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, bcmFieldQualifyMimlVlanCfi, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlVlan_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMimlVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MimlVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    uint8  hw_data;  /* Installed entry value. */
    uint8  hw_mask;  /* Installed entry mask. */

    if (soc_feature(unit, soc_feature_miml)) {
        if ((NULL == data) || (NULL == mask)) {
            return (BCM_E_PARAM);
        }
    
        rv = bcm_esw_field_qualify_MimlVlanId_get(unit, entry, 
                                                   data, mask);
        BCM_IF_ERROR_RETURN(rv);
    
        rv = bcm_esw_field_qualify_MimlVlanCfi_get(unit, entry,
                                                    &hw_data, &hw_mask); 
        BCM_IF_ERROR_RETURN(rv);
        *data |= (hw_data << 12);
        *mask |= (hw_mask << 12);
    
        rv = bcm_esw_field_qualify_MimlVlanPri_get(unit, entry,
                                                    &hw_data, &hw_mask);
        BCM_IF_ERROR_RETURN(rv);
        *data |= (hw_data << 13);
        *mask |= (hw_mask << 13);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyMimlVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MimlVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_miml)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                            bcmFieldQualifyMimlVlanId,
                                            data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlVlanPri_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyMimlVlanPri
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MimlVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_miml)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyMimlVlanPri,
                                            data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlVlanCfi_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyMimlVlanCfi_get
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MimlVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_miml)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyMimlVlanCfi,
                                            data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlInnerTag
 * Purpose:
 *       Set match criteria for bcmFieildQualifyMimlInnerTag
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MimlInnerTag(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_miml)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_esw_field_qualify_aux_tag(unit,
                                           entry,
                                           bcmFieldQualifyMimlInnerTag,
                                           data,
                                           mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MimlInnerTag_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyMimlInnerTag_get
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MimlInnerTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_miml)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                            bcmFieldQualifyMimlInnerTag,
                                            data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapHdrType
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapHdrType(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int  rv = BCM_E_UNAVAIL; /* Operation return status.  */
#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {

        /* Add in AUX_TAG_VALID */
        data |= 1 << 1;
        mask |= 1 << 1;
        
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapHdrType, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);

}

/* 
 * Get match criteria for bcmFieldQualifyCapwapHdrType
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapHdrType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyCapwapHdrType,
                                            data, mask);

        /* Mask off AUX_TAG_VALID */
        *data &= 1;
        *mask &= 1;
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapHdrRid
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapHdrRid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int  rv = BCM_E_UNAVAIL; /* Operation return status.  */
#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {

        /* Add in AUX_TAG_VALID */
        data |= 1 << 5;
        mask |= 1 << 5;
        
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapHdrRid, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapHdrRid
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapHdrRid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyCapwapHdrRid,
                                            data, mask);

        /* Mask off AUX_TAG_VALID */
       *data &= (1 << 5) - 1;
       *mask &= (1 << 5) - 1;
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadSOF
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadSOF(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int  rv = BCM_E_UNAVAIL; /* Operation return status.  */
#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {

        /* Add in AUX_TAG_VALID */
        data |= 1 << 1;
        mask |= 1 << 1;
        
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadSOF, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadSOF
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadSOF_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                            bcmFieldQualifyCapwapPayloadSOF,
                                            data, mask);
        
        /* Mask off AUX_TAG_VALID */
        *data &= 1;
        *mask &= 1;
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadDstMac
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadDstMac(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask)
{
    int  rv = BCM_E_UNAVAIL; /* Operation return status.  */
#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);

        rv = _field_qualify_macaddr(unit, entry, 
                                    bcmFieldQualifyCapwapPayloadDstMac,
                                    data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for CapwapPayloadDstMac
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadDstMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        rv = _field_qualify_macaddr_get(unit, entry, 
                                   bcmFieldQualifyCapwapPayloadDstMac,
                                   data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadSrcMac
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadSrcMac(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask)
{
    int  rv = BCM_E_UNAVAIL; /* Operation return status.  */
#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);

        
        rv = _field_qualify_macaddr(unit, entry, 
                                   bcmFieldQualifyCapwapPayloadSrcMac,
                                   data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadSrcMac
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadSrcMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        rv = _field_qualify_macaddr_get(unit, entry, 
                                   bcmFieldQualifyCapwapPayloadSrcMac,
                                   data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Configure match criteria for bcmFieldQualifyCapwapPayloadEtherType
 *             qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadEtherType(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    int  rv = BCM_E_UNAVAIL; /* Operation return status.  */
#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadEtherType, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadEtherType
 *             qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadEtherType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                bcmFieldQualifyCapwapPayloadEtherType,
                                data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadOuterVlan
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlan(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    int  rv = BCM_E_UNAVAIL; /* Operation return status.  */
#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        rv = bcm_esw_field_qualify_CapwapPayloadOuterVlanId(unit, entry, 
                                               (data & 0xfff), 
                                               (mask & 0xfff));
        BCM_IF_ERROR_RETURN(rv);
    
        rv = bcm_esw_field_qualify_CapwapPayloadOuterVlanCfi(unit, entry, 
                                                ((data >> 12) & 0x1),
                                                ((mask >> 12) & 0x1));
        BCM_IF_ERROR_RETURN(rv);
    
        rv = bcm_esw_field_qualify_CapwapPayloadOuterVlanPri(unit, entry,
                                                (data >> 13),
                                                (mask >> 13));
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadOuterVlan
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    uint8  hw_data;  /* Installed entry value. */
    uint8  hw_mask;  /* Installed entry mask. */

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        if ((NULL == data) || (NULL == mask)) {
            return (BCM_E_PARAM);
        }
    
        rv = bcm_esw_field_qualify_CapwapPayloadOuterVlanId_get(unit, entry, 
                                                   data, mask);
        BCM_IF_ERROR_RETURN(rv);
    
        rv = bcm_esw_field_qualify_CapwapPayloadOuterVlanCfi_get(unit, entry,
                                                    &hw_data, &hw_mask); 
        BCM_IF_ERROR_RETURN(rv);
        *data |= (hw_data << 12);
        *mask |= (hw_mask << 12);
    
        rv = bcm_esw_field_qualify_CapwapPayloadOuterVlanPri_get(unit, entry,
                                                    &hw_data, &hw_mask);
        BCM_IF_ERROR_RETURN(rv);
        *data |= (hw_data << 13);
        *mask |= (hw_mask << 13);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadOuterVlanId
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadOuterVlanId, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadOuterVlanId
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                bcmFieldQualifyCapwapPayloadOuterVlanId,
                                data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadOuterVlanPri
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadOuterVlanPri, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadOuterVlanPri
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                bcmFieldQualifyCapwapPayloadOuterVlanPri,
                                data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadOuterVlanCfi
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadOuterVlanCfi, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadOuterVlanCfi_get
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                bcmFieldQualifyCapwapPayloadOuterVlanCfi,
                                data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadInnerVlan
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlan(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    int  rv = BCM_E_UNAVAIL; /* Operation return status.  */
#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        rv = bcm_esw_field_qualify_CapwapPayloadInnerVlanId(unit, entry, 
                                               (data & 0xfff), 
                                               (mask & 0xfff));
        BCM_IF_ERROR_RETURN(rv);
    
        rv = bcm_esw_field_qualify_CapwapPayloadInnerVlanCfi(unit, entry, 
                                                ((data >> 12) & 0x1),
                                                ((mask >> 12) & 0x1));
        BCM_IF_ERROR_RETURN(rv);
    
        rv = bcm_esw_field_qualify_CapwapPayloadInnerVlanPri(unit, entry,
                                                (data >> 13),
                                                (mask >> 13));
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadInnerVlan
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    uint8  hw_data;  /* Installed entry value. */
    uint8  hw_mask;  /* Installed entry mask. */

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        if ((NULL == data) || (NULL == mask)) {
            return (BCM_E_PARAM);
        }
    
        rv = bcm_esw_field_qualify_CapwapPayloadInnerVlanId_get(unit, entry, 
                                                   data, mask);
        BCM_IF_ERROR_RETURN(rv);
    
        rv = bcm_esw_field_qualify_CapwapPayloadInnerVlanCfi_get(unit, entry,
                                                    &hw_data, &hw_mask); 
        BCM_IF_ERROR_RETURN(rv);
        *data |= (hw_data << 12);
        *mask |= (hw_mask << 12);
    
        rv = bcm_esw_field_qualify_CapwapPayloadInnerVlanPri_get(unit, entry,
                                                    &hw_data, &hw_mask);
        BCM_IF_ERROR_RETURN(rv);
        *data |= (hw_data << 13);
        *mask |= (hw_mask << 13);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadInnerVlanId
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        /* Add in AUX_TAG_VALID */
        data |= 1 << 12;
        mask |= 1 << 12;
        
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadInnerVlanId, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadInnerVlanId
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                                bcmFieldQualifyCapwapPayloadInnerVlanId,
                                data, mask);
        /* Mask off AUX_TAG_VALID */
       *data &= (1 << 12) - 1;
       *mask &= (1 << 12) - 1;
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadInnerVlanPri
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {

        /* Add in AUX_TAG_VALID */
        data |= 1 << 3;
        mask |= 1 << 3;
        
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadInnerVlanPri, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadInnerVlanPri
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                bcmFieldQualifyCapwapPayloadInnerVlanPri,
                                data, mask);

        /* Mask off AUX_TAG_VALID */
       *data &= (1 << 3) - 1;
       *mask &= (1 << 3) - 1;
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadInnerVlanCfi
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {

        /* Add in AUX_TAG_VALID */
        data |= 1 << 1;
        mask |= 1 << 1;
        
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadInnerVlanCfi, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadInnerVlanCfi_get
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                bcmFieldQualifyCapwapPayloadInnerVlanCfi,
                                data, mask);

        /* Mask off AUX_TAG_VALID */
        *data &= 1;
        *mask &= 1;
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadVlanFormat
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadVlanFormat(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {

        if (soc_feature(unit, soc_feature_field_qual_vlanformat_reverse)) {
            /* The position of outer and inner tagged bits are exchanged in Hw */
            data = (((data & 0x2) >> 1) | ((data & 0x1) << 1)); 
            mask = (((mask & 0x2) >> 1) | ((mask & 0x1) << 1));
        }
        
        /* Add in AUX_TAG_VALID */
        data |= 1 << 2;
        mask |= 1 << 2;
        
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadVlanFormat, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadVlanFormat
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadVlanFormat_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    uint8  hw_data = 0;  /* Installed entry value. */
    uint8  hw_mask = 0;  /* Installed entry mask. */
    
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                bcmFieldQualifyCapwapPayloadVlanFormat,
                                &hw_data, &hw_mask);

        if (soc_feature(unit, soc_feature_field_qual_vlanformat_reverse)) {
            /* The position of outer and inner tagged bits are exchanged in Hw */
            *data = (((hw_data & 0x2) >> 1) | ((hw_data & 0x1) << 1));
            *mask = (((hw_mask & 0x2) >> 1) | ((hw_mask & 0x1) << 1)); 
        } else {
        
            /* Mask off AUX_TAG_VALID */
            *data &= (1 << 2) - 1;
            *mask &= (1 << 2) - 1;
        }
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* bcm_field_qualify_CapwapPayloadSip */
int 
bcm_esw_field_qualify_CapwapPayloadSip(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t data, 
    bcm_ip_t mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadSip, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* bcm_field_qualify_CapwapPayloadDip */
int 
bcm_esw_field_qualify_CapwapPayloadDip(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t data, 
    bcm_ip_t mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadDip, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);

}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadSip
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadSip_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                  bcmFieldQualifyCapwapPayloadSip,
                                  data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadDip
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadDip_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                  bcmFieldQualifyCapwapPayloadDip,
                                  data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* bcm_field_qualify_CapwapPayloadSip6 */
int 
bcm_esw_field_qualify_CapwapPayloadSip6(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify_ip6(unit, entry, 
                            bcmFieldQualifyCapwapPayloadSip6, 
                            data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* bcm_field_qualify_CapwapPayloadDip6 */
int 
bcm_esw_field_qualify_CapwapPayloadDip6(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify_ip6(unit, entry, 
                            bcmFieldQualifyCapwapPayloadDip6, 
                            data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadSip6
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadSip6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _field_qualify_ip6_get(unit, entry,
                                  bcmFieldQualifyCapwapPayloadSip6,
                                  data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);

}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadDip6
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadDip6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _field_qualify_ip6_get(unit, entry,
                                  bcmFieldQualifyCapwapPayloadDip6,
                                  data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadIpProtocol
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadIpProtocol(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadIpProtocol, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadIpProtocol_get
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadIpProtocol_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                bcmFieldQualifyCapwapPayloadIpProtocol,
                                data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadTos
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadTos(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadTos, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadTos_get
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadTos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                bcmFieldQualifyCapwapPayloadTos,
                                data, mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* bcm_field_qualify_CapwapPayloadL4SrcPort */
int 
bcm_esw_field_qualify_CapwapPayloadL4SrcPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t data, 
    bcm_l4_port_t mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadL4SrcPort, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* bcm_field_qualify_CapwapPayloadL4DstPort */
int 
bcm_esw_field_qualify_CapwapPayloadL4DstPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t data, 
    bcm_l4_port_t mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadL4DstPort, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadL4SrcPort
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadL4SrcPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                  bcmFieldQualifyCapwapPayloadL4SrcPort,
                                  (uint32 *)data, (uint32 *)mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadL4DstPort
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadL4DstPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                  bcmFieldQualifyCapwapPayloadL4DstPort,
                                  (uint32 *)data, (uint32 *)mask);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadL3HdrParseable
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadL3HdrParseable(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {

        /* Add in AUX_TAG_VALID */
        data |= 1 << 1;
        mask |= 1 << 1;
        
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadL3HdrParseable, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadL3HdrParseable_get
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadL3HdrParseable_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                bcmFieldQualifyCapwapPayloadL3HdrParseable,
                                data, mask);

        /* Mask off AUX_TAG_VALID */
        *data &= 1;
        *mask &= 1;
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadL4HdrParseable
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadL4HdrParseable(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT

    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        
        /* Add in AUX_TAG_VALID */
        data |= 1 << 1;
        mask |= 1 << 1;
        
        
        FP_LOCK(unit);
    
        rv = _field_qualify32(unit, entry, 
            bcmFieldQualifyCapwapPayloadL4HdrParseable, data, mask);
    
        FP_UNLOCK(unit);
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadL4HdrParseable_get
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadL4HdrParseable_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#ifdef BCM_HURRICANE3_SUPPORT
    if (soc_feature(unit, soc_feature_ing_capwap_parser)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                bcmFieldQualifyCapwapPayloadL4HdrParseable,
                                data, mask);
        
        /* Mask off AUX_TAG_VALID */
        *data &= 1;
        *mask &= 1;
    }
#endif /* BCM_HURRICANE3_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DownMepSatTerminated
 * Purpose:
 *      Set match criteria to qualify Rx Down Mep SAT terminated hit status
 *      for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DownMepSatTerminated(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined (BCM_SABER2_SUPPORT)
    if (SOC_IS_SABER2(unit)) {

        /* Validate data. */
        if (data & ~(1)) {
           return BCM_E_PARAM;
        }

        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyDownMepSatTerminated,
                              data, (mask ? 0x1 : 0));
        FP_UNLOCK(unit);
    }
#endif /* BCM_SABER2_SUPPORT */
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DownMepSatTerminated_get
 * Purpose:
 *      Get match criteria for Rx Down Mep SAT terminated hit status
 *      from the given field entry.
 * Parameters:
 *      unit  - (IN)  Unit number.
 *      entry - (IN)  BCM field entry id.
 *      data  - (OUT) Reference to Qualifier match data.
 *      mask  - (OUT) Reference to Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_DownMepSatTerminated_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined (BCM_SABER2_SUPPORT)
    if (SOC_IS_SABER2(unit)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                          bcmFieldQualifyDownMepSatTerminated,
                                                  data, mask);
    }
#endif /* BCM_SABER2_SUPPORT */
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_StpState
 *      Set match criteria for bcmFieldQualifyStpState
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_StpState(int unit, bcm_field_entry_t entry,
                                         uint8 data)
{
    int               value = 0;    /* HW data */
    int               mask  = 0;    /* HW mask */
    int               rv;           /* Return Status */   

    switch (data) {
      case BCM_FIELD_STG_STP_DISABLE:
           value = 0x0; 
           mask  = 0x3;
           break;
      case BCM_FIELD_STG_STP_BLOCK:
           value = 0x1;
           mask  = 0x3;
           break;
      case BCM_FIELD_STG_STP_LEARN:
           value = 0x2;
           mask  = 0x3;
           break;
      case BCM_FIELD_STG_STP_FORWARD:
           value = 0x3;
           mask  = 0x3;
           break;
      case (BCM_FIELD_STG_STP_DISABLE|BCM_FIELD_STG_STP_BLOCK):
           value = 0x0;
           mask  = 0x2;
           break;
      case (BCM_FIELD_STG_STP_DISABLE|BCM_FIELD_STG_STP_LEARN):
           value = 0x0;
           mask  = 0x1;
           break;
      case (BCM_FIELD_STG_STP_BLOCK|BCM_FIELD_STG_STP_FORWARD):
           value = 0x1;
           mask  = 0x1;
           break;
      case (BCM_FIELD_STG_STP_LEARN|BCM_FIELD_STG_STP_FORWARD):
           value = 0x2;
           mask  = 0x2;
           break;
      default:
          return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyStpState,
                            value, mask);
    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_StpState_get
 *      Get match criteria for bcmFieldQualifyStpState
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_StpState_get(int unit, bcm_field_entry_t entry,
                                         uint8 *data)
{
    uint32    hw_data = 0;       /* HW buffer data.             */
    uint32    hw_mask = 0;       /* HW buffer mask.             */
    int       rv;                /* Operation return stauts.    */

    /* Input parameters check. */
    if ((NULL == data)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */ 
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                               bcmFieldQualifyStpState,
                                               &hw_data, &hw_mask);
    BCM_IF_ERROR_RETURN(rv);

    switch (hw_data) {
      case 0: 
          if (hw_mask == 0x3) {
              *data = BCM_FIELD_STG_STP_DISABLE;
          } else if (hw_mask == 0x2) {
              *data = (BCM_FIELD_STG_STP_DISABLE|BCM_FIELD_STG_STP_BLOCK);
          } else if (hw_mask == 0x1) {
              *data = (BCM_FIELD_STG_STP_DISABLE|BCM_FIELD_STG_STP_LEARN);
          } else {
              return (BCM_E_INTERNAL);
          }
          break;
      case 1: 
          if (hw_mask == 0x3) {
              *data = BCM_FIELD_STG_STP_BLOCK;
          } else if (hw_mask == 0x1) {
              *data =(BCM_FIELD_STG_STP_BLOCK|BCM_FIELD_STG_STP_FORWARD);
          } else {
              return (BCM_E_INTERNAL);
          }
          break;
      case 2: 
          if (hw_mask == 0x3) {
              *data = BCM_FIELD_STG_STP_LEARN;
          } else if (hw_mask == 0x2) {
               *data = (BCM_FIELD_STG_STP_LEARN|BCM_FIELD_STG_STP_FORWARD);
          } else {
              return (BCM_E_INTERNAL);
          }
          break;
      case 3:
          if (hw_mask == 0x3) {
              *data = BCM_FIELD_STG_STP_FORWARD;
          } else {
              return (BCM_E_INTERNAL);
          }
          break;
      default:
          return (BCM_E_INTERNAL);
    }
    return (BCM_E_NONE);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DevicePortBitmap
 * Purpose:
 *      Set match criteria to qualify Device Port Bitmap
 *      for a given entry.
 *      To qualify on a port bitmap generated from Device ingress port.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DevicePortBitmap(
    int unit,
    bcm_field_entry_t entry,
    bcm_pbmp_t data,
    bcm_pbmp_t mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined (BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       _field_control_t *fc;          /* Field Control Operational Structure. */

       
       FP_LOCK(unit);
       rv = _field_control_get(unit, &fc);
       if (BCM_FAILURE(rv)) {
           FP_UNLOCK(unit);
           return rv;
       }
       rv = fc->functions.fp_qualify_inports(unit, entry, 
                                             bcmFieldQualifyDevicePortBitmap,
                                             data, mask);
       FP_UNLOCK(unit); 
    } 
#endif /* BCM_TOMAHAWK_SUPPORT */
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DevicePortBitmap_get
 * Purpose:
 *      Get match criteria for Device Port Bitmap
 *      from the given field entry.
 * Parameters:
 *      unit  - (IN)  Unit number.
 *      entry - (IN)  BCM field entry id.
 *      data  - (OUT) Reference to Qualifier match data.
 *      mask  - (OUT) Reference to Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DevicePortBitmap_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_pbmp_t *data,
    bcm_pbmp_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.    */

#if defined (BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       FP_LOCK(unit);
       rv = _bcm_field_qualify_InPorts_get(unit, entry,
                                           bcmFieldQualifyDevicePortBitmap,
                                           data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_SystemPortBitmap(
    int unit,
    bcm_field_entry_t entry,
    bcm_pbmp_t data,
    bcm_pbmp_t mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined (BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       _field_control_t *fc;          /* Field Control Operational Structure. */

       
       FP_LOCK(unit);
       rv = _field_control_get(unit, &fc);
       if (BCM_FAILURE(rv)) {
           FP_UNLOCK(unit);
           return rv;
       }
       rv = fc->functions.fp_qualify_inports(unit, entry, 
                                             bcmFieldQualifySystemPortBitmap,
                                             data, mask);
       FP_UNLOCK(unit); 
    } 
#endif /* BCM_TOMAHAWK_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_SystemPortBitmap_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_pbmp_t *data,
    bcm_pbmp_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.    */

#if defined (BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       FP_LOCK(unit);
       rv = _bcm_field_qualify_InPorts_get(unit, entry,
                                           bcmFieldQualifySystemPortBitmap,
                                           data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_SourceGportBitmap(
    int unit,
    bcm_field_entry_t entry,
    bcm_pbmp_t data,
    bcm_pbmp_t mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined (BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       _field_control_t *fc;          /* Field Control Operational Structure. */

       
       FP_LOCK(unit);
       rv = _field_control_get(unit, &fc);
       if (BCM_FAILURE(rv)) {
           FP_UNLOCK(unit);
           return rv;
       }
       rv = fc->functions.fp_qualify_inports(unit, entry, 
                                             bcmFieldQualifySourceGportBitmap,
                                             data, mask);
       FP_UNLOCK(unit); 
    } 
#endif /* BCM_TOMAHAWK_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_SourceGportBitmap_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_pbmp_t *data,
    bcm_pbmp_t *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.    */

#if defined (BCM_TOMAHAWK_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
       FP_LOCK(unit);
       rv = _bcm_field_qualify_InPorts_get(unit, entry,
                                           bcmFieldQualifySourceGportBitmap,
                                           data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK_SUPPORT */
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_action_copytocpu_config_set
 * Purpose:
 *      Configures CopyToCpu action for a given entry.
 * Parameters:
 *      unit              - (IN) Unit number.
 *      entry             - (IN) BCM field entry id.
 *      CopyToCpu_config  - (IN) CopyToCpu Config Structure.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_action_copytocpu_config_set(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_CopyToCpu_config_t CopyToCpu_config)
{
    int                 rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)
    _field_control_t    *fc;
    _field_entry_t      *f_ent;
    _field_action_t     *fa = NULL;    /* Field action descriptor. */
    _field_action_t      copytocpu_action;    /* Field action descriptor. */

    /* Atleast one of color related flags needs to be set */
    if ((CopyToCpu_config.flags & (~BCM_FIELD_COPYTOCPU_TRUNCATE)) == 0) {
        return BCM_E_PARAM;
    }
    if (!soc_feature(unit, soc_feature_ep_redirect_v2)) {
        return rv;
    }
    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /* Get field entry structure pointer. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    if (!(SOC_IS_APACHE(unit) &&
                (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS))) {
        FP_UNLOCK(unit);
        return BCM_E_CONFIG;
    }

    /* Check if action already exists in the entry */
    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
        if (fa->action == bcmFieldActionCopyToCpu) {
            break;
        }
    }

    /* Action exists do params and dependency check of new parameters
       and then delete the old action */
    if (fa) {
        /* Check if the existing action was created
           not using bcm_field_action_copytocpu_config_set */
        if (fa->param[2] == 0) {
            FP_UNLOCK(unit);
            return BCM_E_CONFIG;
        }

        sal_memset(&copytocpu_action, 0, sizeof(_field_action_t));

        copytocpu_action.action = bcmFieldActionCopyToCpu;
        copytocpu_action.param[2] = CopyToCpu_config.flags;
        copytocpu_action.param[3] = CopyToCpu_config.match_rule;

        /* Check action parameters. */
        rv = fc->functions.fp_action_params_check(unit, f_ent, &copytocpu_action);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
#ifdef BROADCOM_DEBUG
            LOG_VERBOSE(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: action=%s parameters check failed (%d)\n"),
                     unit, _field_action_name(fa->action), rv));
#endif
            return (rv);
        }

        /* Check dependency(s) of action */
        if (fc->functions.fp_action_depends_check) {
            rv = (*fc->functions.fp_action_depends_check)(unit, f_ent, &copytocpu_action);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
#ifdef BROADCOM_DEBUG
                LOG_VERBOSE(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP(unit %d) Error: action=%s dependency check failed (%d)\n"),
                         unit, _field_action_name(fa->action), rv));
#endif
                return (rv);
            }
        }

        rv = _field_action_delete(unit,
                                  entry,
                                  fa->action,
                                  fa->param[0],
                                  fa->param[1]);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return BCM_E_INTERNAL;
        }
        fa = NULL;
    }

    /*
     * Allocate the action descriptor, only param2 and param3 are valid.
     */
    rv = _field_action_alloc(unit, bcmFieldActionCopyToCpu, 0, 0,
                             CopyToCpu_config.flags,
                             CopyToCpu_config.match_rule,
                             0, 0,
                             &fa);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: failure in _field_action_alloc()\n"),
                 unit));
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Add action to entry actions list.
     */
    rv = _field_action_add(unit, fc, entry, fa);
    FP_UNLOCK(unit);
    if (BCM_FAILURE(rv)) {
        sal_free(fa);
        return rv;
    }

#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_action_copytocpu_config_get
 * Purpose:
 *      Gets CopyToCpu action parameters configured
 *      through bcm_esw_field_action_copytocpu_config_set
 *      for a given entry.
 * Parameters:
 *      unit              - (IN) Unit number.
 *      entry             - (IN) BCM field entry id.
 *      CopyToCpu_config  - (OUT) CopyToCpu Config Structure.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
/* Get CopyToCpu action from the field entry. */
int bcm_esw_field_action_copytocpu_config_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_CopyToCpu_config_t *CopyToCpu_config)
{
    int                 rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)
    _field_entry_t      *f_ent;
    _field_action_t     *fa = NULL;    /* Field action descriptor. */

    /* Input parameters check. */
    if (NULL == CopyToCpu_config) {
        return (BCM_E_PARAM);
    }
    if (!soc_feature(unit, soc_feature_ep_redirect_v2)) {
        return rv;
    }

    if (!soc_feature(unit, soc_feature_ep_redirect_v2)) {
        return rv;
    }

    /* Lock the module. */
    
    FP_LOCK(unit);

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    if (!(SOC_IS_APACHE(unit) &&
                (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS))) {
        FP_UNLOCK(unit);
        return BCM_E_CONFIG;
    }

    /* Find matching action in the entry */
    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
        if (fa->action == bcmFieldActionCopyToCpu) {
            break;
        }
    }

    if (fa == NULL) {
        FP_UNLOCK(unit);
        LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: action not in entry=%d\n"),
                 unit, entry));
        return (BCM_E_NOT_FOUND);
    }

    /* Configured not using
       bcm_field_action_copytocpu_config_set API */
    if (fa->param[2] == 0) {
        FP_UNLOCK(unit);
        LOG_VERBOSE(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: action not configured using"
                                " bcm_field_action_copytocpu_config_set in entry=%d\n"),
                     unit, entry));
        return (BCM_E_CONFIG);
    }

    CopyToCpu_config->flags = fa->param[2];
    CopyToCpu_config->match_rule = fa->param[3];

    /* Unlock the module. */
    FP_UNLOCK(unit);

#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_action_redirect_config_set
 * Purpose:
 *      Configures Redirect action for a given entry.
 * Parameters:
 *      unit              - (IN) Unit number.
 *      entry             - (IN) BCM field entry id.
 *      redirect_config   - (IN) Redirect Config Structure.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_action_redirect_config_set(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_redirect_config_t redirect_config)
{
    int                 rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)
    _field_control_t    *fc;
    _field_entry_t      *f_ent;
    _field_action_t     *fa = NULL;    /* Field action descriptor. */
    _field_action_t      redirect_action;    /* Field action descriptor. */
    int                 src_port = -1;

    if (!soc_feature(unit, soc_feature_ep_redirect_v2)) {
        return rv;
    }

    /* Atleast one of color related flags needs to be set */
    if ((redirect_config.flags &
                ~(BCM_FIELD_REDIRECT_TRUNCATE |
                    BCM_FIELD_REDIRECT_SOURCE_USE_CONFIGURED |
                    BCM_FIELD_REDIRECT_SOURCE_USE_ORIGINAL_DESTINATION |
                    BCM_FIELD_REDIRECT_SOURCE_USE_ORIGINAL_SOURCE)) == 0) {
        return BCM_E_PARAM;
    }

    
    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    /* Get field entry structure pointer. */
    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    BCM_IF_ERROR_RETURN(rv);

    if (!(SOC_IS_APACHE(unit) &&
                (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS))) {
        FP_UNLOCK(unit);
        return BCM_E_CONFIG;
    }

    /* Check if action already exists in the entry */
    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
        if (fa->action == bcmFieldActionRedirect) {
            break;
        }
    }

    /* Action exists do params and dependency check of new parameters
       and then delete the old action */
    if (fa) {
        /* Check if the existing action was created
           not using bcm_field_action_redirect_config_set */
        if (fa->param[2] == 0) {
            FP_UNLOCK(unit);
            return BCM_E_CONFIG;
        }

        sal_memset(&redirect_action, 0, sizeof(_field_action_t));

        redirect_action.action = bcmFieldActionRedirect;
        redirect_action.param[2] = redirect_config.flags;
        redirect_action.param[3] = redirect_config.destination_type;
        redirect_action.param[4] = redirect_config.destination;
        redirect_action.param[5] = redirect_config.source_port;

        /* Check action parameters. */
        rv = fc->functions.fp_action_params_check(unit, f_ent, &redirect_action);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
#ifdef BROADCOM_DEBUG
            LOG_VERBOSE(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: action=%s parameters check failed (%d)\n"),
                     unit, _field_action_name(fa->action), rv));
#endif
            return (rv);
        }

        /* Check dependency(s) of action */
        if (fc->functions.fp_action_depends_check) {
            rv = (*fc->functions.fp_action_depends_check)(unit, f_ent, &redirect_action);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
#ifdef BROADCOM_DEBUG
                LOG_VERBOSE(BSL_LS_BCM_FP,
                        (BSL_META_U(unit,
                                    "FP(unit %d) Error: action=%s dependency check failed (%d)\n"),
                         unit, _field_action_name(fa->action), rv));
#endif
                return (rv);
            }
        }

        rv = _field_action_delete(unit,
                                  entry,
                                  fa->action,
                                  fa->param[0],
                                  fa->param[1]);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return BCM_E_INTERNAL;
        }
        fa = NULL;
    }

    if (redirect_config.flags & BCM_FIELD_REDIRECT_SOURCE_USE_CONFIGURED) {
        src_port = redirect_config.source_port;
    }
    /*
     * Allocate the action descriptor, param0 and param1 are not valid.
     */

    rv = _field_action_alloc(unit, bcmFieldActionRedirect, 0, 0,
                             redirect_config.flags,
                             redirect_config.destination_type,
                             redirect_config.destination,
                             src_port,
                             &fa);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: failure in _field_action_alloc()\n"),
                 unit));
        FP_UNLOCK(unit);
        return rv;
    }

    /*
     * Add action to entry actions list.
     */
    rv = _field_action_add(unit, fc, entry, fa);
    FP_UNLOCK(unit);
    if (BCM_FAILURE(rv)) {
        sal_free(fa);
        return rv;
    }

#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_action_redirect_config_get
 * Purpose:
 *      Gets Redirect action parameters configured
 *      through bcm_esw_field_action_redirect_config_set
 *      for a given entry.
 * Parameters:
 *      unit              - (IN) Unit number.
 *      entry             - (IN) BCM field entry id.
 *      redirect_config   - (OUT) Redirect Config Structure.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_action_redirect_config_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_redirect_config_t *redirect_config)
{
    int                 rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)
    _field_entry_t      *f_ent;
    _field_action_t     *fa = NULL;    /* Field action descriptor. */

    /* Input parameters check. */
    if (NULL == redirect_config) {
        return (BCM_E_PARAM);
    }

    if (!soc_feature(unit, soc_feature_ep_redirect_v2)) {
        return rv;
    }

    /* Lock the module. */
    
    FP_LOCK(unit);

    rv = _field_entry_get(unit, entry, _FP_ENTRY_PRIMARY, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    if (!(SOC_IS_APACHE(unit) &&
                (f_ent->group->stage_id == _BCM_FIELD_STAGE_EGRESS))) {
        FP_UNLOCK(unit);
        return BCM_E_CONFIG;
    }

    /* Find matching action in the entry */
    for (fa = f_ent->actions; fa != NULL; fa = fa->next) {
        if (fa->action == bcmFieldActionRedirect) {
            break;
        }
    }

    if (fa == NULL) {
        FP_UNLOCK(unit);
        LOG_VERBOSE(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                            "FP(unit %d) Error: action not in entry=%d\n"),
                 unit, entry));
        return (BCM_E_NOT_FOUND);
    }

    /* Configured not using
       bcm_field_action_redirect_config_set API */
    if (fa->param[2] == 0) {
        FP_UNLOCK(unit);
        LOG_VERBOSE(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: action not configured using"
                                " bcm_field_action_redirect_config_set in entry=%d\n"),
                     unit, entry));
        return (BCM_E_CONFIG);
    }

    redirect_config->flags            = fa->param[2];
    redirect_config->destination_type = fa->param[3];
    redirect_config->destination      = fa->param[4];
    redirect_config->source_port      = fa->param[5];

    /* Unlock the module. */
    FP_UNLOCK(unit);

#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TosLower4Bits
 * Purpose:
 *      Set match criteria to qualify on Lower 4bits of TOS value
 *      for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TosLower4Bits(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)

    if (data > 0xf) {
        return BCM_E_PARAM;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyTosLower4Bits,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TosLower4Bits_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTosLower4Bits
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TosLower4Bits_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                      bcmFieldQualifyTosLower4Bits,
                      data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressClass2Vxlt
 * Purpose:
 *      Set match criteria to qualify on OAM Class Id assigned for packet
 *      based on 2nd Lookup in EGR_VLAN_XLATE table for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressClass2Vxlt(
        int unit,
        bcm_field_entry_t entry,
        uint32 data,
        uint32 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)

    if (data > 0xfff) {
        return BCM_E_PARAM;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamEgressClass2Vxlt,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressClass2Vxlt_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamEgressClass2Vxlt
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressClass2Vxlt_get(
        int unit,
        bcm_field_entry_t entry,
        uint32 *data,
        uint32 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint32_get(unit, entry,
                      bcmFieldQualifyOamEgressClass2Vxlt,
                      data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressVxltFirstHit
 * Purpose:
 *      Set match criteria to qualify on First EGR_VXLT lookup hit status
 *      for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressVxltFirstHit(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)

    if (data > 0x1) {
        return BCM_E_PARAM;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamEgressVxltFirstHit,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressVxltFirstHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamEgressVxltFirstHit
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressVxltFirstHit_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                      bcmFieldQualifyOamEgressVxltFirstHit,
                      data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressVxltSecondHit
 * Purpose:
 *      Set match criteria to qualify on Second EGR_VXLT lookup hit status
 *      for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressVxltSecondHit(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)

    if (data > 0x1) {
        return BCM_E_PARAM;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamEgressVxltSecondHit,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressVxltSecondHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamEgressVxltSecondHit
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressVxltSecondHit_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                      bcmFieldQualifyOamEgressVxltSecondHit,
                      data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamDownMEPLoopbackPacket
 * Purpose:
 *      Set match criteria to qualify on Down-MEP Loopback or
 *      Down-SAT Latching Loopback packet for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamDownMEPLoopbackPacket(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)

    if (data > 0x1) {
        return BCM_E_PARAM;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamDownMEPLoopbackPacket,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamDownMEPLoopbackPacket_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamDownMEPLoopbackPacket
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamDownMEPLoopbackPacket_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                      bcmFieldQualifyOamDownMEPLoopbackPacket,
                      data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressPortUnicastDstMacHit
 * Purpose:
 *      Set match criteria to qualify on EGR_PORT MAC DA hit status
 *      for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressPortUnicastDstMacHit(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)

    if (data > 0x1) {
        return BCM_E_PARAM;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamEgressPortUnicastDstMacHit,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressPortUnicastDstMacHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamEgressPortUnicastDstMacHit
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressPortUnicastDstMacHit_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                      bcmFieldQualifyOamEgressPortUnicastDstMacHit,
                      data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressDropEthernetOamControl
 * Purpose:
 *      Set match criteria to qualify on Drop reason for
 *      Ethernet OAM control packets for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mep_type  - (IN) Qualifier Mep Type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressDropEthernetOamControl(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t mep_type)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)

    
    FP_LOCK(unit);

    rv = _bcm_field_apache_qualify_OamDropReason(unit, entry,
            bcmFieldQualifyIngressDropEthernetOamControl,
            mep_type);

    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressDropEthernetOamControl_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIngressDropEthernetOamControl
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mep_type - (OUT) Qualifier Mep Type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressDropEthernetOamControl_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t *mep_type)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)
    rv = _bcm_field_apache_qualify_OamDropReason_get(unit, entry,
            bcmFieldQualifyIngressDropEthernetOamControl,
            mep_type);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressDropEthernetOamData
 * Purpose:
 *      Set match criteria to qualify on Drop reason for
 *      Ethernet OAM data packets for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mep_type  - (IN) Qualifier Mep Type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressDropEthernetOamData(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t mep_type)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)

    
    FP_LOCK(unit);

    rv = _bcm_field_apache_qualify_OamDropReason(unit, entry,
            bcmFieldQualifyIngressDropEthernetOamData,
            mep_type);

    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressDropEthernetOamData_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIngressDropEthernetOamData
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mep_type - (OUT) Qualifier Mep Type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressDropEthernetOamData_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t *mep_type)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)
    rv = _bcm_field_apache_qualify_OamDropReason_get(unit, entry,
            bcmFieldQualifyIngressDropEthernetOamData,
            mep_type);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressDropMplsOamControl
 * Purpose:
 *      Set match criteria to qualify on Drop reason for
 *      Mpls OAM control packets for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mep_type  - (IN) Qualifier Mep Type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressDropMplsOamControl(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t mep_type)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)

    
    FP_LOCK(unit);

    rv = _bcm_field_apache_qualify_OamDropReason(unit, entry,
            bcmFieldQualifyIngressDropMplsOamControl,
            mep_type);

    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressDropMplsOamControl_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIngressDropMplsOamControl
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mep_type - (OUT) Qualifier Mep Type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressDropMplsOamControl_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t *mep_type)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)
    rv = _bcm_field_apache_qualify_OamDropReason_get(unit, entry,
            bcmFieldQualifyIngressDropMplsOamControl,
            mep_type);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressDropMplsOamData
 * Purpose:
 *      Set match criteria to qualify on Drop reason for
 *      Mpls OAM data packets for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mep_type  - (IN) Qualifier Mep Type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressDropMplsOamData(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t mep_type)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)

    
    FP_LOCK(unit);

    rv = _bcm_field_apache_qualify_OamDropReason(unit, entry,
            bcmFieldQualifyIngressDropMplsOamData,
            mep_type);

    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressDropMplsOamData_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIngressDropMplsOamData
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mep_type - (OUT) Qualifier Mep Type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressDropMplsOamData_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t *mep_type)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)
    rv = _bcm_field_apache_qualify_OamDropReason_get(unit, entry,
            bcmFieldQualifyIngressDropMplsOamData,
            mep_type);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressEtherType
 * Purpose:
 *      Set match criteria to qualify on OAM or SAT
 *      Ethernet Type for a given entry.
 *      Allowed values are 0x8902 or 0x88b7
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) Qualifier data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressEtherType(
    int unit,
    bcm_field_entry_t entry,
    uint16 data)
{
    int                 rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)
    uint16              mask;

    if ((data != _FP_ETHOAM_ETHER_TYPE) && (data != _FP_SAT_ETHER_TYPE)) {
        return BCM_E_PARAM;
    }

    if (data == _FP_ETHOAM_ETHER_TYPE) {
        data = _FP_EGRESS_OAM_CLASS_ID;
    } else {
        data = _FP_EGRESS_SAT_CLASS_ID;
    }

    mask = 0x3;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamEgressEtherType,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressEtherType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamEgressEtherType
 *      qualifier from the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (OUT) Qualifier data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressEtherType_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data)
{
    int         rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)
    uint16      hw_data;
    uint16      hw_mask;

    if (data == NULL) {
        return BCM_E_PARAM;
    }

    rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                          bcmFieldQualifyOamEgressEtherType,
                          &hw_data, &hw_mask);

    if (BCM_SUCCESS(rv)) {
        if (hw_mask == 0) {
            return BCM_E_NOT_FOUND;
        }

        switch(hw_data & hw_mask) {
            case _FP_EGRESS_OAM_CLASS_ID:
                *data = _FP_ETHOAM_ETHER_TYPE;
                break;
            case _FP_EGRESS_SAT_CLASS_ID:
                *data = _FP_SAT_ETHER_TYPE;
                break;
            default:
                return BCM_E_INTERNAL;
        }
    }
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressMulticastMacHit
 * Purpose:
 *      Set match criteria to qualify on OAM Multicast
 *      MAC Range Hit status for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) Qualifier data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressMulticastMacHit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data)
{
    int                 rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)
    uint8              mask;

    if ((data < BCM_FIELD_OAM_MUTLICAST_MAC_NO_HIT) ||
            (data > BCM_FIELD_OAM_MUTLICAST_MAC_CLASS2_HIT)) {
        return BCM_E_PARAM;
    }

    if (data == BCM_FIELD_OAM_MUTLICAST_MAC_NO_HIT) {
        data = 0x0;
    } else if (data == BCM_FIELD_OAM_MUTLICAST_MAC_CLASS1_HIT) {
        data = 0x1;
    } else {
        data = 0x2;
    }

    mask = 0x3;

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamEgressMulticastMacHit,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressMulticastMacHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamEgressMulticastMacHit
 *      qualifier from the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (OUT) Qualifier data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressMulticastMacHit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data)
{
    int         rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)
    uint8      hw_data = 0;
    uint8      hw_mask = 0;

    if (data == NULL) {
        return BCM_E_PARAM;
    }

    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                          bcmFieldQualifyOamEgressMulticastMacHit,
                          &hw_data, &hw_mask);

    if (BCM_SUCCESS(rv)) {
        if (hw_mask == 0) {
            return BCM_E_NOT_FOUND;
        }

        switch(hw_data & hw_mask) {
            case 0x0:
                *data = BCM_FIELD_OAM_MUTLICAST_MAC_NO_HIT;
                break;
            case 0x1:
                *data = BCM_FIELD_OAM_MUTLICAST_MAC_CLASS1_HIT;
                break;
            case 0x2:
                *data = BCM_FIELD_OAM_MUTLICAST_MAC_CLASS2_HIT;
                break;
            default:
                return BCM_E_INTERNAL;
        }
    }
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressClassSrcMac
 * Purpose:
 *      Set match criteria to qualify on Srouce MAC Class Id
 *      assigned for packet based on Hit in
 *      EGR_OAM_SAT_MISC_MAC_SA_0.15 registers for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressClassSrcMac(
        int unit,
        bcm_field_entry_t entry,
        uint32 data,
        uint32 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_APACHE_SUPPORT)

    if (data > 0xf) {
        return BCM_E_PARAM;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyOamEgressClassSrcMac,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamEgressClassSrcMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamEgressClassSrcMac
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamEgressClassSrcMac_get(
        int unit,
        bcm_field_entry_t entry,
        uint32 *data,
        uint32 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint32_get(unit, entry,
                      bcmFieldQualifyOamEgressClassSrcMac,
                      data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_MyStation2Hit
 * Purpose:
 *      Set match criteria to qualify on My Station tacm hit
 *      based on Overlay L2 termination lookup hit for tunnel packets or
 *      Routing hit for non-tunnel packets for a given entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MyStation2Hit(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT2PLUS_SUPPORT)

    if (data > 0x1) {
        return BCM_E_PARAM;
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyMyStation2Hit,
                          data, mask);
    FP_UNLOCK(unit);
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_MyStation2Hit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMyStation2Hit
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MyStation2Hit_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                      bcmFieldQualifyMyStation2Hit,
                      data, mask);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TrunkMemberSourceModuleId
 * Purpose:
 *      Add source trunk module field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      modid - (IN) Module Id
 *      modid_mask - (IN) Module Id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TrunkMemberSourceModuleId(
    int unit, 
    bcm_field_entry_t entry, 
    int modid, 
    int modid_mask)
{
    int rv;                 /* Operation return status. */

    /* Input parameters check. */
    if ((modid < 0) && (modid > SOC_MODID_MAX(unit))) {
        return (BCM_E_PARAM);
    }

    
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyTrunkMemberSourceModuleId,
                          modid, modid_mask);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TrunkMemberSourceModuleId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcTrunkModuleGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit  - (IN)  Unit number.
 *      entry - (IN)  Field Entry id.
 *      modid - (OUT) Module Id.
 *      modid_mask - (OUT) Module Id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TrunkMemberSourceModuleId_get(
    int unit, 
    bcm_field_entry_t entry, 
    int *modid, 
    int *modid_mask)
{
    uint32 data;   /* HW encoded qualifier data.  */
    uint32 mask;   /* HW encoding qualifier mask. */
    int rv;        /* Operation return status.    */

    /* Input parameters check. */
    if ((NULL == modid) || (NULL == modid_mask)) {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                  bcmFieldQualifyTrunkMemberSourceModuleId,
                                             &data, &mask);
    BCM_IF_ERROR_RETURN(rv);

    *modid = data & 0xff;
    *modid_mask = mask & 0xff;
    return BCM_E_NONE;
}

/*
 * Function:
 *      bcm_esw_field_action_vlan_actions_add
 * Purpose:
 *      Add VLAN Actions "bcmFieldActionVlanActions" to the field entry.
 * Parameters:
 *      unit   - (IN)  Unit number.
 *      entry  - (IN)  Field Entry id.
 *      action - (IN)  Field Action type.
 *      vlan_action_set - (IN) Reference to bcm_vlan_action_set_t.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_action_vlan_actions_add(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_action_t action,
    bcm_vlan_action_set_t *vlan_action_set)
{
    int     rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _bcm_field_action_vlan_actions_add(unit, entry,
                                    action, vlan_action_set);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_action_vlan_actions_get
 * Purpose:
 *      Retrieve VLAN Actions associated to the field entry.
 * Parameters:
 *      unit   - (IN)  Unit number.
 *      entry  - (IN)  Field Entry id.
 *      action - (IN)  Field Action type.
 *      vlan_action_set - (OUT) Reference to bcm_vlan_action_set_t.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int
bcm_esw_field_action_vlan_actions_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_action_t action,
    bcm_vlan_action_set_t *vlan_action_set)
{
    int     rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _bcm_field_action_vlan_actions_get(unit, entry,
                                  action, vlan_action_set);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}


/*
 * Function:
 *      bcm_esw_field_qualify_PreemptablePacket
 * Purpose:
 *      Set match criteria for bcmFieldQualifyPreemptablePacket 
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (IN) Qualifier match data.
 *                   The data = 1 is meant to qualify the preemptable packet
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_PreemptablePacket(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

 #if defined(BCM_PREEMPTION_SUPPORT)
    if (soc_feature(unit, soc_feature_preemption)) {
        if (data > 0x1 || mask > 0x1) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyPreemptablePacket,
                              data, mask);
        FP_UNLOCK(unit);
    }
 #endif /* BCM_PREEMPTION_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_PreemptablePacket_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyPreemptablePacket 
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (OUT) Qualifier match data.
 *                    The data = 1 is meant to qualify the preemptable packet
 *      mask  - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_PreemptablePacket_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_PREEMPTION_SUPPORT)
    if (soc_feature(unit, soc_feature_preemption)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                  bcmFieldQualifyPreemptablePacket,
                                                  data, mask);
    }
#endif /* BCM_PREEMPTION_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanClassValid
 * Purpose:
 *      Set match criteria for bcmFieildQualifyVxlanClassValid
 *      qualifier from the field entry.
 *      The VXLAN Class contains complete {Flags, Reserved1 and Reserved2} fields except for
 *      VN_ID in VXLAN header. It is to indicate the incoming VXLAN header with pre-configured
 *      value (VXLAN Class) is valid or not (TRUE or FALSE).
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     TRUE: Valid VXLAN Class.
 *                     FALSE: Invalid VXLAN Class.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanClassValid(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        if (data > 0x1 || mask > 0x1) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyVxlanClassValid,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanClassValid_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVxlanClassValid
 *      qualifier from the field entry.
 *      The VXLAN Class contains complete {Flags, Reserved1 and Reserved2} fields except for
 *      VN_ID in VXLAN header. It is to indicate the incoming VXLAN header with pre-configured
 *      value (VXLAN Class) is valid or not (TRUE or FALSE).
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      TRUE: Valid VXLAN Class.
 *                      FALSE: Invalid VXLAN Class.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanClassValid_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                  bcmFieldQualifyVxlanClassValid,
                                                  data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanPacket
 * Purpose:
 *      Set match criteria for bcmFieildQualifyVxlanPacket
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     TRUE: VXLAN packet.
 *                     FALSE: Non-VXLAN packet.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanPacket(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        if (data > 0x1 || mask > 0x1) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyVxlanPacket,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanPacket_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVxlanPacket
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      TRUE: VXLAN packet.
 *                      FALSE: Non-VXLAN packet.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanPacket_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                  bcmFieldQualifyVxlanPacket,
                                                  data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanVnidVlanTranslateHit
 * Purpose:
 *      Set match criteria for bcmFieildQualifyVxlanVnidVlanTranslateHit
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     VXLAN Network Identifier (VN_ID) lookup hit status (TRUE or FALSE)
 *                     through VLAN Translation.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanVnidVlanTranslateHit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        if (data > 0x1 || mask > 0x1) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyVxlanVnidVlanTranslateHit,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanVnidVlanTranslateHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVxlanVnidVlanTranslateHit
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      VXLAN Network Identifier (VN_ID) lookup hit status (TRUE or FALSE)
 *                      through VLAN Translation.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanVnidVlanTranslateHit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                  bcmFieldQualifyVxlanVnidVlanTranslateHit,
                                                  data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanPayloadVlanFormat
 * Purpose:
 *      Set match criteria for bcmFieildQualifyVxlanPayloadVlanFormat
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Incoming Vxlan L2 payload VLAN tag status:
 *                     0: untagged
 *                     1: single inner-tag (BCM_FIELD_VLAN_FORMAT_INNER_TAGGED = 0x2)
 *                     2: single outer-tag (BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED = 0x1)
 *                     3: double tagged (BCM_FIELD_VLAN_FORMAT_INNER_TAGGED |
 *                                       BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED)
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanPayloadVlanFormat(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

    if (data & ~(BCM_FIELD_VLAN_FORMAT_INNER_TAGGED |
                 BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED)) {
        return BCM_E_PARAM;
    }

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        if (soc_feature(unit, soc_feature_field_qual_vlanformat_reverse)) {
            /* The position of outer and inner tagged bits are exchanged in Hw */
            data = (((data & BCM_FIELD_VLAN_FORMAT_INNER_TAGGED) >> 1) |
                   ((data & BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED) << 1));
            mask = (((mask & BCM_FIELD_VLAN_FORMAT_INNER_TAGGED) >> 1) |
                   ((mask & BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED) << 1));
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyVxlanPayloadVlanFormat,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanPayloadVlanFormat_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVxlanPayloadVlanFormat
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Incoming Vxlan L2 payload VLAN tag status:
 *                      0: untagged
 *                      1: single inner-tag (BCM_FIELD_VLAN_FORMAT_INNER_TAGGED = 0x2)
 *                      2: single outer-tag (BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED = 0x1)
 *                      3: double tagged (BCM_FIELD_VLAN_FORMAT_INNER_TAGGED |
 *                                        BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED)
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanPayloadVlanFormat_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    uint8  hw_data = 0;  /* Installed entry value. */
    uint8  hw_mask = 0;  /* Installed entry mask. */

    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                  bcmFieldQualifyVxlanPayloadVlanFormat,
                                                  &hw_data, &hw_mask);
        if (soc_feature(unit, soc_feature_field_qual_vlanformat_reverse)) {
            /* The position of outer and inner tagged bits are exchanged in Hw */
            *data = (((hw_data & BCM_FIELD_VLAN_FORMAT_INNER_TAGGED) >> 1) |
                    ((hw_data & BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED) << 1));
            *mask = (((hw_mask & BCM_FIELD_VLAN_FORMAT_INNER_TAGGED) >> 1) |
                    ((hw_mask & BCM_FIELD_VLAN_FORMAT_OUTER_TAGGED) << 1));

        }
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadDstMac
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadDstMac
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload MACDA
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadDstMac(
    int unit,
    bcm_field_entry_t entry,
    bcm_mac_t  data,
    bcm_mac_t  mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);

        rv = _field_qualify_macaddr(unit, entry, bcmFieldQualifyTunnelPayloadDstMac,
                                    data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadDstMac_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadDstMac
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload MACDA
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadDstMac_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_mac_t  *data,
    bcm_mac_t  *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        rv = _field_qualify_macaddr_get(unit, entry,
                                        bcmFieldQualifyTunnelPayloadDstMac,
                                        data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadSrcMac
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadSrcMac
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload MACSA
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadSrcMac(
    int unit,
    bcm_field_entry_t entry,
    bcm_mac_t  data,
    bcm_mac_t  mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);

        rv = _field_qualify_macaddr(unit, entry, bcmFieldQualifyTunnelPayloadSrcMac,
                                    data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadSrcMac_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadSrcMac
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload MACSA
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadSrcMac_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_mac_t  *data,
    bcm_mac_t  *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        rv = _field_qualify_macaddr_get(unit, entry,
                                        bcmFieldQualifyTunnelPayloadSrcMac,
                                        data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadEtherType
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadEtherType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload Ethernet Type (16 bits)
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadEtherType(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyTunnelPayloadEtherType,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadEtherType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadEtherType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload Ethernet Type (16 bits)
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadEtherType_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                                   bcmFieldQualifyTunnelPayloadEtherType,
                                                   data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadOuterVlan
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadOuterVlan
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload outer VLAN Tag field value (Vid, Pri, Cfi)
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadOuterVlan(
    int unit,
    bcm_field_entry_t entry,
    bcm_vlan_t data,
    bcm_vlan_t mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyTunnelPayloadOuterVlan,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadOuterVlan_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadOuterVlan
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload outer VLAN Tag field value (Vid, Pri, Cfi)
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadOuterVlan_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_vlan_t *data,
    bcm_vlan_t *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        if ((NULL == data) || (NULL == mask)) {
            return (BCM_E_PARAM);
        }
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                                   bcmFieldQualifyTunnelPayloadOuterVlan,
                                                                data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadOuterVlanId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadOuterVlanId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload outer VLAN Tag field value (Vid)
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadOuterVlanId(
    int unit,
    bcm_field_entry_t entry,
    bcm_vlan_t data,
    bcm_vlan_t mask)
{
    int rv = BCM_E_UNAVAIL;

    if (!BCM_VLAN_VALID(data)) {
        return BCM_E_PARAM;
    }

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyTunnelPayloadOuterVlanId,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadOuterVlanId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadOuterVlanId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload outer VLAN Tag field value (Vid)
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadOuterVlanId_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_vlan_t *data,
    bcm_vlan_t *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                                   bcmFieldQualifyTunnelPayloadOuterVlanId,
                                                   data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadOuterVlanPri
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadOuterVlanPri
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload outer VLAN Tag field value (Pri)
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadOuterVlanPri(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

    if (data & ~(0x7)) {
        return BCM_E_PARAM;
    }

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyTunnelPayloadOuterVlanPri,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadOuterVlanPri_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadOuterVlanPri
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload outer VLAN Tag field value (Pri)
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadOuterVlanPri_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                  bcmFieldQualifyTunnelPayloadOuterVlanPri,
                                                  data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadOuterVlanCfi
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadOuterVlanCfi
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload outer VLAN Tag field value (Cfi)
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadOuterVlanCfi(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

    if (data & ~(0x1)) {
        return BCM_E_PARAM;
    }

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyTunnelPayloadOuterVlanCfi,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadOuterVlanCfi_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadOuterVlanCfi
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload outer VLAN Tag field value (Cfi)
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadOuterVlanCfi_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                  bcmFieldQualifyTunnelPayloadOuterVlanCfi,
                                                  data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadSip
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadSip
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload IPv4 source IP
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadSip(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip_t data,
    bcm_ip_t mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyTunnelPayloadSip,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadDip
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadDip
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload IPv4 destination IP
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadDip(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip_t data,
    bcm_ip_t mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyTunnelPayloadDip,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadSip_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadSip
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload IPv4 source IP
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadSip_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip_t *data,
    bcm_ip_t *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                                   bcmFieldQualifyTunnelPayloadSip,
                                                   data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadDip_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadDip
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload IPv4 destination IP
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadDip_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip_t *data,
    bcm_ip_t *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                                   bcmFieldQualifyTunnelPayloadDip,
                                                   data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadSip6
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadSip6
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload IPv6 source IP
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadSip6(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip6_t data,
    bcm_ip6_t mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);

        rv = _field_qualify_ip6(unit, entry, bcmFieldQualifyTunnelPayloadSip6,
                                data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadDip6
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadDip6
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload IPv6 destination IP
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadDip6(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip6_t data,
    bcm_ip6_t mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);

        rv = _field_qualify_ip6(unit, entry, bcmFieldQualifyTunnelPayloadDip6,
                                data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadSip6_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadSip6
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload IPv6 source IP
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadSip6_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip6_t *data,
    bcm_ip6_t *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _field_qualify_ip6_get(unit, entry,
                                    bcmFieldQualifyTunnelPayloadSip6,
                                    data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadDip6_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadDip6
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload IPv6 destination IP
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadDip6_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip6_t *data,
    bcm_ip6_t *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _field_qualify_ip6_get(unit, entry,
                                    bcmFieldQualifyTunnelPayloadDip6,
                                    data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadIpProtocol
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadIpProtocol
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload IP Protocol (16 bits)
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadIpProtocol(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyTunnelPayloadIpProtocol,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadIpProtocol_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadIpProtocol
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload IP Protocol (16 bits)
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadIpProtocol_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                  bcmFieldQualifyTunnelPayloadIpProtocol,
                                                  data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadL4SrcPort
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadL4SrcPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload L4 source port number
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadL4SrcPort(
    int unit,
    bcm_field_entry_t entry,
    bcm_l4_port_t data,
    bcm_l4_port_t mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyTunnelPayloadL4SrcPort,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadL4DstPort
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTunnelPayloadL4DstPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *                     Indicates Tunnel payload L4 destination port number
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadL4DstPort(
    int unit,
    bcm_field_entry_t entry,
    bcm_l4_port_t data,
    bcm_l4_port_t mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyTunnelPayloadL4DstPort,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadL4SrcPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadL4SrcPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload L4 source port number
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadL4SrcPort_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_l4_port_t *data,
    bcm_l4_port_t *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                                   bcmFieldQualifyTunnelPayloadL4SrcPort,
                                                   (uint32 *)data, (uint32 *)mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelPayloadL4DstPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelPayloadL4DstPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *                      Indicates Tunnel payload L4 destination port number
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TunnelPayloadL4DstPort_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_l4_port_t *data,
    bcm_l4_port_t *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_vxlan_lite)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                                   bcmFieldQualifyTunnelPayloadL4DstPort,
                                                   (uint32 *)data, (uint32 *)mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}


/*
 * Function:
 *      bcm_esw_field_qualify_bcmFieldQualifyRoceBthOpcode
 * Purpose:
 *      Set match criteria for bcmFieldQualifyRoceBthOpcode
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_RoceBthOpcode(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_rroce)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyRoceBthOpcode,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}
/*
 * Function:
 *      bcm_esw_field_qualify_bcmFieldQualifyRoceBthOpcode_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyRoceBthOpcode
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (OUT) Qualifier match data.
 *      mask  - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_RoceBthOpcode_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_rroce)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                unit, entry, bcmFieldQualifyRoceBthOpcode, data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}
/*
 * Function:
 *      bcm_esw_field_qualify_bcmFieldQualifyRoceBthPartitionKey
 * Purpose:
 *      Set match criteria for bcmFieldQualifyRoceBthPartitionKey
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_RoceBthPartitionKey(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_rroce)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyRoceBthPartitionKey,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}
/*
 * Function:
 *      bcm_esw_field_qualify_bcmFieldQualifyRoceBthPartitionKey_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyRoceBthPartitionKey
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (OUT) Qualifier match data.
 *      mask  - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_RoceBthPartitionKey_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_rroce)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint16_get(
                unit, entry, bcmFieldQualifyRoceBthPartitionKey, data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}
/*
 * Function:
 *      bcm_esw_field_qualify_bcmFieldQualifyRoceBthDstQueuePair
 * Purpose:
 *      Set match criteria for bcmFieldQualifyRoceBthDstQueuePair
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_RoceBthDstQueuePair(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_rroce)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyRoceBthDstQueuePair,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}
/*
 * Function:
 *      bcm_esw_field_qualify_bcmFieldQualifyRoceBthDstQueuePair_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyRoceBthDstQueuePair
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (OUT) Qualifier match data.
 *      mask  - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_RoceBthDstQueuePair_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_rroce)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(
                unit, entry, bcmFieldQualifyRoceBthDstQueuePair, data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}
/*
 * Function:
 *      bcm_esw_field_qualify_bcmFieldQualifyRoceBthFlags
 * Purpose:
 *      Set match criteria for bcmFieldQualifyRoceBthFlags
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_RoceBthFlags(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_rroce)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyRoceBthFlags,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}
/*
 * Function:
 *      bcm_esw_field_qualify_bcmFieldQualifyRoceBthFlags_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyRoceBthFlags
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (OUT) Qualifier match data.
 *      mask  - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_RoceBthFlags_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_rroce)) {
    /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                unit, entry, bcmFieldQualifyRoceBthFlags, data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}
/*
 * Function:
 *      bcm_esw_field_qualify_bcmFieldQualifyRoceVer1Pkt
 * Purpose:
 *      Set match criteria for bcmFieldQualifyRoceVer1Pkt
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_RoceVer1Pkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_rroce)) {
        if (data > 0x1 || mask > 0x1) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyRoceVer1Pkt, data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}
/*
 * Function:
 *      bcm_esw_field_qualify_bcmFieldQualifyRoceVer1Pkt_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyRoceVer1Pkt
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (OUT) Qualifier match data.
 *      mask  - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_RoceVer1Pkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_rroce)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                unit, entry, bcmFieldQualifyRoceVer1Pkt, data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}
/*
 * Function:
 *      bcm_esw_field_qualify_bcmFieldQualifyRoceVer2Pkt
 * Purpose:
 *      Set match criteria for bcmFieldQualifyRoceVer2Pkt
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_RoceVer2Pkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_rroce)) {
        if (data > 0x1 || mask > 0x1) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyRoceVer2Pkt, data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}
/*
 * Function:
 *      bcm_esw_field_qualify_bcmFieldQualifyRoceVer2Pkt_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyRoceVer2Pkt
 *      qualifier in the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field Entry id.
 *      data  - (OUT) Qualifier match data.
 *      mask  - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_RoceVer2Pkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_GREYHOUND2_SUPPORT
    if (soc_feature(unit, soc_feature_rroce)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                unit, entry, bcmFieldQualifyRoceVer2Pkt, data, mask);
    }
#endif /* BCM_GREYHOUND2_SUPPORT */

    return rv;
}


#ifdef BROADCOM_DEBUG

/* Section: Field Debug */


/*
 * Function: bcm_field_show
 *
 * Purpose:
 *     Show current S/W state if compiled in debug mode.
 *
 * Parameters:
 *     unit - BCM device number
 *     pfx - Character string to prefix output lines
 *
 * Returns:
 *     Nothing.
 */
int
bcm_esw_field_show(int unit, const char *pfx)
{
    BCM_IF_ERROR_RETURN(_bcm_esw_field_udf_show(unit, pfx));
    BCM_IF_ERROR_RETURN(_bcm_esw_field_range_show(unit, pfx, -1));
    return _bcm_esw_field_show(unit, pfx, -1);
    }

/*
 * Function: bcm_field_entry_dump
 *
 * Purpose:
 *     Show contents of a field entry.
 *
 * Parameters:
 *     unit  - BCM device number
 *     entry - Field entry to dump
 *
 * Returns:
 *     Nothing.
 */

int
bcm_esw_field_entry_dump(int unit, bcm_field_entry_t entry)
{
    return _bcm_esw_field_entry_dump(unit, entry, -1);
    }
/*
 * Function: bcm_field_group_dump
 *
 * Purpose:
 *     Show contents of a field group.
 *
 * Parameters:
 *     unit  - BCM device number
 *     group - Field group to dump
 *
 * Returns:
 *     Nothing.
 */

int
bcm_esw_field_group_dump(int unit, bcm_field_group_t group)
{
    return _bcm_esw_field_group_dump(unit, group, -1);
    }
#endif /* BROADCOM_DEBUG */

/*
 * Function: bcm_esw_field_group_ports_add
 *
 * Purpose:
 *    Add ports to the specified group.
 *
 * Parameters:
 *     unit  - BCM device number
 *     group - Field group
 *     pbmp - Set of Ports
 *
 * Returns:
 *     BCM_E_XXX - from _bcm_esw_field_group_ports_add
 *     BCM_E_UNAVAIL - for Tomahawk and non TRX devices.
 */
int
bcm_esw_field_group_ports_add(
    int unit,
    bcm_field_group_t group,
    bcm_pbmp_t pbmp)
{
    int rv = BCM_E_UNAVAIL;

    FP_LOCK(unit);
#if defined(BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit) && (!SOC_IS_TOMAHAWKX(unit))) {
        rv = _bcm_esw_field_group_ports_add(
             unit, group, pbmp);
    } 
#endif
    FP_UNLOCK(unit);
    return rv;
}

/*
 * Function: bcm_esw_field_group_ports_remove
 *
 * Purpose:
 *    Remove ports from the specified group.
 *
 * Parameters:
 *     unit  - BCM device number
 *     group - Field group
 *     pbmp - Set of Ports
 *
 * Returns:
 *     BCM_E_XXX - from _bcm_esw_field_group_ports_remove
 *     BCM_E_UNAVAIL - for Tomahawk and non TRX devices.
 */

int
bcm_esw_field_group_ports_remove(
    int unit,
    bcm_field_group_t group,
    bcm_pbmp_t pbmp)
{
    int rv = BCM_E_UNAVAIL;

    FP_LOCK(unit);
#if defined(BCM_TRX_SUPPORT)
    if (SOC_IS_TRX(unit) && (!SOC_IS_TOMAHAWKX(unit))) {
        rv = _bcm_esw_field_group_ports_remove(
             unit, group, pbmp);
    } 
#endif
    FP_UNLOCK(unit);
    return rv;
}

/*
 * Function : 
 *      bcm_esw_field_class_map_get
 * Purpose :
 *      To get the set of mapped TTL/ToS/TCP values of the packet for
 *      a given set of TTL/ToS/TCP values respectively.
 * Parameters :
 *      unit              :   (IN) BCM device number
 *      stage             :   (IN) Field Stage of type bcm_field_stage_t.                        
 *      qual              :   (IN) Field qualifier of type bcm_field_qualify_t.   
 *      num_entries       :   (IN) Number of entries in the Orig_values array               
 *      orig_values_array :   (IN) List of TTL/TOS/TCPFlags Values
 *      map_values_array  :   (OUT) List of Mapped Values for each TTL/TOS/TCPFlags
 * Returns :
 *      BCM_E_XXX
 */
bcm_error_t
bcm_esw_field_class_map_get (int unit, 
        bcm_field_stage_t stage,
        bcm_field_qualify_t qual, 
        uint32 num_entries,
        uint32 *orig_values_array,
        uint32 *map_values_array)
{
    bcm_error_t rv = BCM_E_UNAVAIL;
#if defined(BCM_TRX_SUPPORT)
    if (stage != bcmFieldStageIngress) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: bcm_esw_field_class_map_get is "
                              "supported only in Ingress based Field Processor\n"),
                   unit));
        return rv;
    }

    if (!soc_feature(unit, soc_feature_fp_class_map_no_support)) {
        FP_LOCK(unit);
        rv = _bcm_esw_field_class_map_get(unit, qual, num_entries, orig_values_array,
                                          map_values_array);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function :
 *      bcm_esw_field_class_map_set
 * Purpose :
 *      To map a given set of TTL/ToS/TCP values of the packet
 *      to another set of TTL/ToS/TCP values respectively.
 * Parameters :
 *      unit              :   (IN) BCM device number
 *      stage             :   (IN) Field Stage of type bcm_field_stage_t
 *      qual              :   (IN) Field qualifier of type bcm_field_qualify_t
 *      num_entries       :   (IN) Number of entries in the Orig_values array
 *      orig_values_array :   (IN) List of TTL/TOS/TCPFlags Values
 *      map_values_array  :   (IN) List of Mapped Values for each TTL/TOS/TCPFlags
 * Returns :
 *      BCM_E_XXX
 */
bcm_error_t
bcm_esw_field_class_map_set (int unit, 
        bcm_field_stage_t stage,
        bcm_field_qualify_t qual, 
        uint32 num_entries,
        uint32 *orig_values_array,
        uint32 *map_values_array)
{
    bcm_error_t rv = BCM_E_UNAVAIL;

#if defined(BCM_TRX_SUPPORT)
    if (stage != bcmFieldStageIngress) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: bcm_esw_field_class_map_set is "
                              "supported only in Ingress based Field Processor\n"),
                   unit));
        return rv;
    }

    if (!soc_feature(unit, soc_feature_fp_class_map_no_support)) {
        FP_LOCK(unit);
        rv = _bcm_esw_field_class_map_set(unit, qual, num_entries, orig_values_array,
                                          map_values_array);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function: bcm_esw_field_group_ports_get
 *
 * Purpose:
 *    Retrieve bitmap of the ports associated
 *    with a given field group ID
 *
 * Parameters:
 *     unit  - BCM device number
 *     group - Field group
 *     pbmp -  Port bitmap of a given field group
 *
 * Returns:
 *     BCM_E_NOT_FOUND - If given group ID is not found
 */

int
bcm_esw_field_group_ports_get(
    int unit,
    bcm_field_group_t group,
    bcm_pbmp_t *pbmp)
{
    int rv = BCM_E_NONE;
    _field_group_t      *fg;  /* Field group structure. */
    FP_LOCK(unit);

    rv = _field_group_get(unit, group, &fg);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: group=%d not found \n"),
                   unit, group));
        FP_UNLOCK(unit);
        return (BCM_E_NOT_FOUND);
    }

    BCM_PBMP_ASSIGN(*pbmp, fg->pbmp);

    FP_UNLOCK(unit);
    return (rv);
}

/*
 * Function: bcm_esw_field_group_config_validate
 *
 * Purpose:
 *     To verify whether a group can be created with a given qset and mode.
 *
 * Parameters:
 *     unit  - BCM device number
 *     gc    - Field group config.
 *     group_mode - Field Group Mode.
 *
 * Returns:
 *     BCM_E_XXX - from _bcm_esw_field_group_config_validate()
 */

int bcm_esw_field_group_config_validate(
                          int unit,
                          bcm_field_group_config_t *gc,
                          bcm_field_group_mode_t *group_mode) {

    int rv = BCM_E_NONE;
    FP_LOCK(unit);
    rv = _bcm_esw_field_group_config_validate(unit, gc, group_mode);
    FP_UNLOCK(unit);
    return rv;
}

/* 
 * Set match criteria for EgressClassTunnel
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassTunnel(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyEgressClassTunnel,
                              data, mask);
        FP_UNLOCK(unit);
    }
    return(rv);
}

/* 
 * Get match criteria for EgressClassTunnel
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassTunnel_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                      bcmFieldQualifyEgressClassTunnel,
                      data, mask);
    }
    return(rv);
}
/* 
 * Set match criteria for EgressClassL3InterfaceTunnel
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassL3InterfaceTunnel(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, 
                              bcmFieldQualifyEgressClassL3InterfaceTunnel,
                              data, mask);
        FP_UNLOCK(unit);
    }
    return(rv);
}

/* 
 * Get match criteria for EgressClassL3InterfaceTunnel
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassL3InterfaceTunnel_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */

    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry, 
                      bcmFieldQualifyEgressClassL3InterfaceTunnel,
                      data, mask);
    }
    return(rv);
}

/*
 * bit 3   : ING[/EGR]_SR_ENABLE
 * bit 2~0 : ING[/EGR]_SR_TYPE
 */
#define _FP_SRTYPE_ENCODING_NONE        (0)
#define _FP_SRTYPE_ENCODING_ETHERNET    ((1 << 3) | 0)
#define _FP_SRTYPE_ENCODING_PRP         ((1 << 3) | 1)
#define _FP_SRTYPE_ENCODING_HSR         ((1 << 3) | 2)
#define _FP_SRTYPE_ENCODING_DOT1CB      ((1 << 3) | 3)

/*
 * Function:
 *      bcm_esw_field_qualify_SrcPortSRType
 * Purpose:
 *      Set match criteria for bcmFieldQualifySrcPortSRType
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (IN) SR (Seamless Redundancy) port type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcPortSRType(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_field_port_sr_type_t type)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 data = 0;

        switch (type) {
            case bcmFieldPortSRTypeNone:
                data = _FP_SRTYPE_ENCODING_NONE;
                break;
            case bcmFieldPortSRTypeEthernet:
                data = _FP_SRTYPE_ENCODING_ETHERNET;
                break;
            case bcmFieldPortSRTypePrp:
                data = _FP_SRTYPE_ENCODING_PRP;
                break;
            case bcmFieldPortSRTypeHsr:
                data = _FP_SRTYPE_ENCODING_HSR;
                break;
            case bcmFieldPortSRTypeDot1cb:
                data = _FP_SRTYPE_ENCODING_DOT1CB;
                break;
            default:
                return BCM_E_PARAM;
        }

        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySrcPortSRType, data,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcPortSRType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcPortSRType
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (OUT) SR (Seamless Redundancy) port type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcPortSRType_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_port_sr_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 data, mask;

        if (NULL == type) {
            return BCM_E_PARAM;
        }

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(
                 unit, entry, bcmFieldQualifySrcPortSRType,
                 &data, &mask);

        if (BCM_SUCCESS(rv)) {
            switch (data) {
                case _FP_SRTYPE_ENCODING_NONE:
                    *type = bcmFieldPortSRTypeNone;
                    break;
                case _FP_SRTYPE_ENCODING_ETHERNET:
                    *type = bcmFieldPortSRTypeEthernet;
                    break;
                case _FP_SRTYPE_ENCODING_PRP:
                    *type = bcmFieldPortSRTypePrp;
                    break;
                case _FP_SRTYPE_ENCODING_HSR:
                    *type = bcmFieldPortSRTypeHsr;
                    break;
                case _FP_SRTYPE_ENCODING_DOT1CB:
                    *type = bcmFieldPortSRTypeDot1cb;
                    break;
                default:
                    rv = BCM_E_INTERNAL; /* should not happen */
            }
        }
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstPortSRType
 * Purpose:
 *      Set match criteria for bcmFieldQualifyDstPortSRType
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (IN) SR (Seamless Redundancy) port type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstPortSRType(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_field_port_sr_type_t type)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 data = 0;

        switch (type) {
            case bcmFieldPortSRTypeNone:
                data = _FP_SRTYPE_ENCODING_NONE;
                break;
            case bcmFieldPortSRTypeEthernet:
                data = _FP_SRTYPE_ENCODING_ETHERNET;
                break;
            case bcmFieldPortSRTypePrp:
                data = _FP_SRTYPE_ENCODING_PRP;
                break;
            case bcmFieldPortSRTypeHsr:
                data = _FP_SRTYPE_ENCODING_HSR;
                break;
            case bcmFieldPortSRTypeDot1cb:
                data = _FP_SRTYPE_ENCODING_DOT1CB;
                break;
            default:
                return BCM_E_PARAM;
        }

        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyDstPortSRType, data,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstPortSRType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstPortSRType
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (OUT) SR (Seamless Redundancy) port type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstPortSRType_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_port_sr_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 data, mask;

        if (NULL == type) {
            return BCM_E_PARAM;
        }

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(
                 unit, entry, bcmFieldQualifyDstPortSRType,
                 &data, &mask);

        if (BCM_SUCCESS(rv)) {
            switch (data) {
                case _FP_SRTYPE_ENCODING_NONE:
                    *type = bcmFieldPortSRTypeNone;
                    break;
                case _FP_SRTYPE_ENCODING_ETHERNET:
                    *type = bcmFieldPortSRTypeEthernet;
                    break;
                case _FP_SRTYPE_ENCODING_PRP:
                    *type = bcmFieldPortSRTypePrp;
                    break;
                case _FP_SRTYPE_ENCODING_HSR:
                    *type = bcmFieldPortSRTypeHsr;
                    break;
                case _FP_SRTYPE_ENCODING_DOT1CB:
                    *type = bcmFieldPortSRTypeDot1cb;
                    break;
                default:
                    rv = BCM_E_INTERNAL; /* should not happen */
            }
        }
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcPortSRRoleInterlink
 * Purpose:
 *      Set match criteria for bcmFieldQualifySrcPortSRRoleInterlink
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcPortSRRoleInterlink(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 data)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 hw_data;

        if (0 == data) {
            hw_data = 1;
        } else if (1 == data) {
            hw_data = 0;
        } else {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySrcPortSRRoleInterlink, hw_data,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcPortSRRoleInterlink_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcPortSRRoleInterlink
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcPortSRRoleInterlink_get(int unit,
                                                 bcm_field_entry_t entry,
                                                 uint8 *data)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 hw_data;
        uint8 hw_mask;

        if (NULL == data) {
            return BCM_E_PARAM;
        }
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifySrcPortSRRoleInterlink,
                 &hw_data, &hw_mask);
        if (BCM_SUCCESS(rv)) {
            if (0 == hw_data) {
                *data = 1;
            } else if (1 == hw_data) {
                *data = 0;
            } else {
                rv = BCM_E_INTERNAL;
            }
        }
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstPortSRRoleInterlink
 * Purpose:
 *      Set match criteria for bcmFieldQualifyDstPortSRRoleInterlink
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstPortSRRoleInterlink(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 data)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 hw_data;

        if (0 == data) {
            hw_data = 1;
        } else if (1 == data) {
            hw_data = 0;
        } else {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyDstPortSRRoleInterlink, hw_data,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstPortSRRoleInterlink_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstPortSRRoleInterlink
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstPortSRRoleInterlink_get(int unit,
                                                 bcm_field_entry_t entry,
                                                 uint8 *data)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 hw_data;
        uint8 hw_mask;

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifyDstPortSRRoleInterlink,
                 &hw_data, &hw_mask);
        if (BCM_SUCCESS(rv)) {
            if (0 == hw_data) {
                *data = 1;
            } else if (1 == hw_data) {
                *data = 0;
            } else {
                rv = BCM_E_INTERNAL;
            }
        }
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcPortSRMode
 * Purpose:
 *      Set match criteria for bcmFieldQualifySrcPortSRMode
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (IN) SR (Seamless Redundancy) port mode.
 *      mask      - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcPortSRMode(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_field_sr_port_mode_t type,
                                    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        if (type < 0 || type >= bcmFieldSRPortModeCount) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySrcPortSRMode, type, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcPortSRMode_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcPortSRMode
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (OUT) SR (Seamless Redundancy) port mode.
 *      mask      - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcPortSRMode_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_sr_port_mode_t *type,
                                        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

    if (NULL == type) {
        return BCM_E_PARAM;
    }

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 hw_value;

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifySrcPortSRMode,
                 &hw_value, mask);
        if (BCM_SUCCESS(rv)) {
            if (hw_value >= bcmFieldSRPortModeCount) {
                rv = BCM_E_INTERNAL;
            }
        }
        if (BCM_SUCCESS(rv)) {
            *type = (bcm_field_sr_port_mode_t)hw_value;
        }
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstPortSRMode
 * Purpose:
 *      Set match criteria for bcmFieldQualifyDstPortSRMode
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (IN) SR (Seamless Redundancy) port mode.
 *      mask      - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstPortSRMode(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_field_sr_port_mode_t type,
                                    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        if (type < 0 || type >= bcmFieldSRPortModeCount) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyDstPortSRMode, type, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstPortSRMode_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstPortSRMode
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (OUT) SR (Seamless Redundancy) port mode.
 *      mask      - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstPortSRMode_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_sr_port_mode_t *type,
                                        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

    if (NULL == type) {
        return BCM_E_PARAM;
    }
#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 hw_value;

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifyDstPortSRMode,
                 &hw_value, mask);
        if (BCM_SUCCESS(rv)) {
            if (hw_value >= bcmFieldSRPortModeCount) {
                rv = BCM_E_INTERNAL;
            } else {
                *type = (bcm_field_sr_port_mode_t)hw_value;
            }
        }
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcPortSRNetId
 * Purpose:
 *      Set match criteria for bcmFieldQualifySrcPortSRNetId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      net_id    - (IN) Net Id.
 *      mask      - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcPortSRNetId(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 net_id, uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        if (net_id >= 8) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySrcPortSRNetId, net_id, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcPortSRNetId_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcPortSRNetId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      net_id    - (OUT) Net Id.
 *      mask      - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_SrcPortSRNetId_get(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 *net_id, uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifySrcPortSRNetId,
                 net_id, mask);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstPortSRNetId
 * Purpose:
 *      Set match criteria for bcmFieldQualifyDstPortSRNetId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      net_id    - (IN) Net Id.
 *      mask      - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstPortSRNetId(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 net_id, uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        if (net_id >= 8) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyDstPortSRNetId, net_id, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstPortSRNetId_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstPortSRNetId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      net_id    - (OUT) Net Id.
 *      mask      - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstPortSRNetId_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *net_id, uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifyDstPortSRNetId,
                 net_id, mask);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcPortSRLanId
 * Purpose:
 *      Set match criteria for bcmFieldQualifySrcPortSRLanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      lan_id    - (IN) Lan Id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcPortSRLanId(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 lan_id)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        if (lan_id != 0 && lan_id != 1) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySrcPortSRLanId, lan_id,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcPortSRLanId_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcPortSRLanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      lan_id    - (OUT) Lan Id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcPortSRLanId_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *lan_id)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 mask;

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifySrcPortSRLanId,
                 lan_id, &mask);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstPortSRLanId
 * Purpose:
 *      Set match criteria for bcmFieldQualifyDstPortSRLanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      lan_id    - (IN) Lan Id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstPortSRLanId(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 lan_id)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        if (lan_id != 0 && lan_id != 1) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyDstPortSRLanId, lan_id,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstPortSRLanId_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstPortSRLanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      lan_id    - (OUT) Lan Id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstPortSRLanId_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *lan_id)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 mask;

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifyDstPortSRLanId,
                 lan_id, &mask);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * hw value PKT.SR_TYPE
 */
#define _FP_SRTAGTYPE_ENCODING_NONE        (0)
#define _FP_SRTAGTYPE_ENCODING_HSR         (2)
#define _FP_SRTAGTYPE_ENCODING_PRP         (4)
#define _FP_SRTAGTYPE_ENCODING_DOT1CB      (3)

/*
 * Function:
 *      bcm_esw_field_qualify_SRTagType
 * Purpose:
 *      Set match criteria for bcmFieldQualifySRTagType
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (IN) SR (Seamless Redundancy) tag type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRTagType(int unit, bcm_field_entry_t entry,
                                bcm_field_sr_tag_type_t type)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 data;

        switch (type) {
            case bcmFieldSRTagTypeNone:
                data = _FP_SRTAGTYPE_ENCODING_NONE;
                break;
            case bcmFieldSRTagTypeHsr:
                data = _FP_SRTAGTYPE_ENCODING_HSR;
                break;
            case bcmFieldSRTagTypePrp:
                data = _FP_SRTAGTYPE_ENCODING_PRP;
                break;
            case bcmFieldSRTagTypeDot1cb:
                data = _FP_SRTAGTYPE_ENCODING_DOT1CB;
                break;
            default:
                return BCM_E_PARAM;
        }

        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySRTagType, data,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRTagType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySRTagType
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (OUT) SR (Seamless Redundancy) tag type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRTagType_get(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_field_sr_tag_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 data, mask;

        if (NULL == type) {
            return BCM_E_PARAM;
        }

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(
                 unit, entry, bcmFieldQualifySRTagType,
                 &data, &mask);

        if (BCM_SUCCESS(rv)) {
            switch (data) {
                case _FP_SRTAGTYPE_ENCODING_NONE:
                    *type = bcmFieldSRTagTypeNone;
                    break;
                case _FP_SRTAGTYPE_ENCODING_HSR:
                    *type = bcmFieldSRTagTypeHsr;
                    break;
                case _FP_SRTAGTYPE_ENCODING_PRP:
                    *type = bcmFieldSRTagTypePrp;
                    break;
                case _FP_SRTAGTYPE_ENCODING_DOT1CB:
                    *type = bcmFieldSRTagTypeDot1cb;
                    break;
                default:
                    rv = BCM_E_INTERNAL; /* should not happen */
            }
        }
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * hw value SRLanId
 */
#define _FP_SRLANID_ENCODING(_lanid_) ((0x1 << 1) | ((_lanid_) & 0x1))
#define _FP_SRLANID_DECODING(_hwid_)  ((_hwid_) & 0x1)

/*
 * Function:
 *      bcm_esw_field_qualify_SRLanId
 * Purpose:
 *      Set match criteria for bcmFieldQualifySRLanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      lan_id    - (IN) LAN Id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRLanId(int unit, bcm_field_entry_t entry,
                              int lan_id)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 hw_value;

        if (lan_id != 0 && lan_id != 1) {
            return BCM_E_PARAM;
        }
        hw_value = _FP_SRLANID_ENCODING(lan_id);
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySRLanId, hw_value,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRLanId_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySRLanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      lan_id    - (OUT) LAN Id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRLanId_get(int unit, bcm_field_entry_t entry,
                                  int *lan_id)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 hw_value;
        uint32 mask;
        if (NULL == lan_id) {
            return BCM_E_PARAM;
        }

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(
                 unit, entry, bcmFieldQualifySRLanId,
                 &hw_value, &mask);
        if (BCM_SUCCESS(rv)) {
            *lan_id = _FP_SRLANID_DECODING(hw_value);
        }
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * hw value SRNetId
 */
#define _FP_SRNETID_ENCODING(_netid_) ((0x1 << 3) | ((_netid_) & 0x7))
#define _FP_SRNETID_DECODING(_hwid_)  ((_hwid_) & 0x7)

/*
 * Function:
 *      bcm_esw_field_qualify_SRNetId
 * Purpose:
 *      Set match criteria for bcmFieldQualifySRNetId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      net_id    - (IN) Net Id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRNetId(int unit, bcm_field_entry_t entry,
                              int net_id)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 hw_value;

        if (net_id < 0 || net_id > 7) {
            return BCM_E_PARAM;
        }
        hw_value = _FP_SRNETID_ENCODING(net_id);
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySRNetId, hw_value,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRNetId_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySRNetId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      net_id    - (OUT) Net Id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRNetId_get(int unit, bcm_field_entry_t entry,
                                  int *net_id)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 hw_value;
        uint32 mask;
        if (NULL == net_id) {
            return BCM_E_PARAM;
        }

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(
                 unit, entry, bcmFieldQualifySRNetId,
                 &hw_value, &mask);
        if (BCM_SUCCESS(rv)) {
            *net_id = _FP_SRNETID_DECODING(hw_value);
        }
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VlanSREnable
 * Purpose:
 *      Set match criteria for bcmFieldQualifyVlanSREnable
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VlanSREnable(int unit, bcm_field_entry_t entry,
                                   uint8 data)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        if (data != 0 && data != 1) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyVlanSREnable, data,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VlanSREnable_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyVlanSREnable
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VlanSREnable_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 *data)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 mask;

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifyVlanSREnable,
                 data, &mask);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VlanSRLanId
 * Purpose:
 *      Set match criteria for bcmFieldQualifyVlanSRLanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      lan_id    - (IN) LAN Id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VlanSRLanId(int unit, bcm_field_entry_t entry,
                                  uint8 lan_id)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        if (lan_id != 0 && lan_id != 1) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyVlanSRLanId, lan_id,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VlanSRLanId_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyVlanSRLanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      lan_id    - (OUT) LAN Id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VlanSRLanId_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 *lan_id)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 mask;

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifyVlanSRLanId,
                 lan_id, &mask);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRFlowId
 * Purpose:
 *      Set match criteria for bcmFieldQualifySRFlowId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (IN) Qualifier match data.
 *      mask      - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRFlowId(int unit, bcm_field_entry_t entry,
                               uint32 data, uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 hw_idx;

        BCM_IF_ERROR_RETURN(
            bcmi_esw_tsn_sr_hw_flow_id_get(unit, (bcm_tsn_sr_flow_t)data,
                                           &hw_idx));
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySRFlowId, hw_idx, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRFlowId_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySRFlowId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (OUT) Qualifier match data.
 *      mask      - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRFlowId_get(int unit, bcm_field_entry_t entry,
                                   uint32 *data, uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 hw_idx;

        if (NULL == data || NULL == mask) {
            return BCM_E_PARAM;
        }
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(
                 unit, entry, bcmFieldQualifySRFlowId,
                 &hw_idx, mask);
        if (BCM_SUCCESS(rv) && *mask != 0) {
            rv = bcmi_esw_tsn_sr_sw_flow_id_get(
                     unit, hw_idx, (bcm_tsn_sr_flow_t *)data);
        }
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2DestSRNodeType
 * Purpose:
 *      Set match criteria for bcmFieldQualifyL2DestSRNodeType
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (IN) SR (Seamless Redundancy) node type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_L2DestSRNodeType(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_field_sr_node_type_t type)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        if (type < 0 || type >= bcmFieldSRNodeTypeCount) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyL2DestSRNodeType, type,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2DestSRNodeType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL2DestSRNodeType
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (OUT) SR (Seamless Redundancy) node type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_L2DestSRNodeType_get(int unit,
                                           bcm_field_entry_t entry,
                                           bcm_field_sr_node_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 mask;

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(
                 unit, entry, bcmFieldQualifyL2DestSRNodeType,
                 type, &mask);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRNetIdMatched
 * Purpose:
 *      Set match criteria for bcmFieldQualifySRNetIdMatched
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRNetIdMatched(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        if (data != 0 && data != 1) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySRNetIdMatched, data,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRNetIdMatched_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySRNetIdMatched
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRNetIdMatched_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 mask;

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifySRNetIdMatched,
                 data, &mask);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRSrcNodeIsSan
 * Purpose:
 *      Set match criteria for bcmFieldQualifySRSrcNodeIsSan
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRSrcNodeIsSan(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        if (data != 0 && data != 1) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySRSrcNodeIsSan, data,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRSrcNodeIsSan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySRSrcNodeIsSan
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRSrcNodeIsSan_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 mask;

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifySRSrcNodeIsSan,
                 data, &mask);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRSupervisionType
 * Purpose:
 *      Set match criteria for bcmFieldQualifySRSupervisionType
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (IN) SR (Seamless Redundancy) supervision type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRSupervisionType(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_sr_supervision_type_t type)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        if (type < 0 || type >= bcmFieldSRSupervisionTypeCount) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySRSupervisionType, type,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRSupervisionType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySRSupervisionType
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      type      - (OUT) SR (Seamless Redundancy) supervision type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRSupervisionType_get(int unit,
                                            bcm_field_entry_t entry,
                                            bcm_field_sr_supervision_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 mask;

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(
                 unit, entry, bcmFieldQualifySRSupervisionType,
                 type, &mask);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRError
 * Purpose:
 *      Set match criteria for bcmFieldQualifySRError
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (IN) Qualifier match data.
 *      mask      - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRError(int unit, bcm_field_entry_t entry,
                              uint32 data, uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 valid_mask = BCM_FIELD_SR_ERROR_UNEXPECTED_PKT |
                            BCM_FIELD_SR_ERROR_TAG_ERROR |
                            BCM_FIELD_SR_ERROR_RX_ERROR;
        if (data & (~valid_mask) || mask & (~valid_mask)) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySRError, data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRError_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySRError
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (OUT) Qualifier match data.
 *      mask      - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRError_get(int unit, bcm_field_entry_t entry,
                                  uint32 *data, uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(
                 unit, entry, bcmFieldQualifySRError,
                 data, mask);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2SrcMulticastHit
 * Purpose:
 *      Set match criteria for bcmFieldQualifyL2SrcMulticastHit
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (IN) Qualifier match data.
 *      mask      - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_L2SrcMulticastHit(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 data, uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SUPPORT
    if (soc_feature(unit, soc_feature_tsn)) {
        uint8 hw_data;

        if (data > 0x1 || mask != 0x1) {
            return BCM_E_PARAM;
        }
        hw_data = (data == 0) ? 0 : 3;

        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyL2SrcMulticastHit, hw_data,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2SrcMulticastHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL2SrcMulticastHit
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (OUT) Qualifier match data.
 *      mask      - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_L2SrcMulticastHit_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint8 *data, uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SUPPORT
    if (soc_feature(unit, soc_feature_tsn)) {
        uint8 hw_data, hw_mask;

        if (NULL == data || NULL == mask) {
            return BCM_E_PARAM;
        }

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifyL2SrcMulticastHit,
                 &hw_data, &hw_mask);
        if (BCM_SUCCESS(rv)) {
            if (0 == hw_mask) {
                *data = 0;
                *mask = 0;
            } else if (3 == hw_data) {
                *data = 1;
                *mask = 1;
            } else if (0 == hw_data) {
                *data = 0;
                *mask = 1;
            } else {
                rv = BCM_E_INTERNAL; /* should not happen */
            }
        }
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2DstMulticastHit
 * Purpose:
 *      Set match criteria for bcmFieldQualifyL2DstMulticastHit
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (IN) Qualifier match data.
 *      mask      - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_L2DstMulticastHit(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 data, uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 hw_data;

        if (data > 0x1 || mask != 0x1) {
            return BCM_E_PARAM;
        }
        hw_data = (data == 0) ? 0 : 2;

        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyL2DstMulticastHit, hw_data,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2DstMulticastHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL2DstMulticastHit
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (OUT) Qualifier match data.
 *      mask      - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_L2DstMulticastHit_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint8 *data, uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 hw_data, hw_mask;

        if (NULL == data || NULL == mask) {
            return BCM_E_PARAM;
        }
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifyL2DstMulticastHit,
                 &hw_data, &hw_mask);
        if (BCM_SUCCESS(rv)) {
            if (0 == hw_mask) {
                *data = 0;
                *mask = 0;
            } else if (2 == hw_data) {
                *data = 1;
                *mask = 1;
            } else if (0 == hw_data) {
                *data = 0;
                *mask = 1;
            } else {
                rv = BCM_E_INTERNAL; /* should not happen */
            }
        }
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRDuplicate
 * Purpose:
 *      Set match criteria for bcmFieldQualifySRDuplicate
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRDuplicate(int unit, bcm_field_entry_t entry,
                                  uint8 data)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        if (data != 0 && data != 1) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifySRDuplicate, data,
                              BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SRDuplicate_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySRDuplicate
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SRDuplicate_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 *data)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint8 mask;

        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifySRDuplicate,
                 data, &mask);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TsnFlowId
 * Purpose:
 *      Set match criteria for bcmFieldQualifyTsnFlowId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (IN) Qualifier match data.
 *      mask      - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TsnFlowId(int unit, bcm_field_entry_t entry,
                                uint32 data, uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 hw_idx;

        BCM_IF_ERROR_RETURN(
            bcmi_esw_tsn_hw_flow_id_get(unit, (bcm_tsn_flow_t)data,
                                        &hw_idx));
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyTsnFlowId, hw_idx, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_TsnFlowId_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTsnFlowId
 *      qualifier in the field entry.
 * Parameters:
 *      unit      - (IN) Unit number.
 *      entry     - (IN) Field Entry id.
 *      data      - (OUT) Qualifier match data.
 *      mask      - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TsnFlowId_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint32 *data, uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TSN_SR_SUPPORT
    if (soc_feature(unit, soc_feature_tsn_sr)) {
        uint32 hw_idx;

        if (NULL == data || NULL == mask) {
            return BCM_E_PARAM;
        }
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint32_get(
                 unit, entry, bcmFieldQualifyTsnFlowId,
                 &hw_idx, mask);
        if (BCM_SUCCESS(rv) && *mask != 0) {
            rv = bcmi_esw_tsn_sw_flow_id_get(
                     unit, hw_idx, (bcm_tsn_flow_t *)data);
        }
    }
#endif /* BCM_TSN_SR_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpTunnelTtl_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpTunnelTtl
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpTunnelTtl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)

{
    int rv = BCM_E_UNAVAIL;
    if (soc_feature(unit, soc_feature_th3_style_fp)) {
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                        bcmFieldQualifyIpTunnelTtl,
                        data, mask);
        FP_UNLOCK(unit);
    }

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpTunnelTtl
 * Purpose:
 *      Set match criteria for bcmFieldQualifyIpTunnelTtl
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpTunnelTtl(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)

{
    int rv = BCM_E_UNAVAIL;

    if (soc_feature(unit, soc_feature_th3_style_fp)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyIpTunnelTtl,
                              data, mask);
        FP_UNLOCK(unit);
    }

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpTunnelTtlClassZero
 *      Set match criteria for bcmFieldQualifyIpTunnelTtlClassZero
 *      qualifier in the field entry.
 * Parameters:
 *      unit    -   (IN) Unit number.
 *      entry   -   (IN) BCM field entry id.
 *      data    -   (IN) Qualifier match data.
 *      mask    -   (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IpTunnelTtlClassZero(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, 
        bcm_class_t mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

    if (soc_feature(unit, soc_feature_th3_style_fp)) {
        uint32 cdata = 0;           /* Class Data */
        uint32 cmask = 0;           /* Class Mask */

        COMPILER_64_TO_32_LO(cdata, data);
        COMPILER_64_TO_32_LO(cmask, mask);

        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyIpTunnelTtlClassZero,
                              cdata, cmask);

        FP_UNLOCK(unit);
    }
    return rv;

}

/*
 * Function:
 *      bcm_esw_field_qualify_IpTunnelTtlClassZero_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpTunnelTtlClassZero
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IpTunnelTtlClassZero_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    int rv = BCM_E_UNAVAIL;     /* Operation return status. */

    if (soc_feature(unit, soc_feature_th3_style_fp)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint64_get(unit, entry,
                        bcmFieldQualifyIpTunnelTtlClassZero,
                        data, mask);
    }

    return (rv);

}

/*
 * Function:
 *      bcm_esw_field_qualify_TafGateId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTafGateId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TafGateId(int unit, bcm_field_entry_t entry,
                                uint32 data, uint32 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#if defined(BCM_TSN_SUPPORT)
    if (soc_feature(unit, soc_feature_tsn_taf)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyTafGateId,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TafGateId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTafGateId
 *      qualifier from the field entry.
 * Parameters:
 *      unit   - (IN) Unit number.
 *      entry  - (IN) BCM field entry id.
 *      data   - (OUT) Qualifier match data.
 *      mask   - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TafGateId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data, uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#if defined(BCM_TSN_SUPPORT)
    if (soc_feature(unit, soc_feature_tsn_taf)) {
        rv = _bcm_field_entry_qualifier_uint32_get(
                 unit, entry, bcmFieldQualifyTafGateId,
                 data, mask);
    }
#endif /* BCM_TSN_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TafEnable
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTafEnable
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      enable  - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TafEnable(int unit, bcm_field_entry_t entry,
                                uint8 enable)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#if defined(BCM_TSN_SUPPORT)
    if (soc_feature(unit, soc_feature_tsn_taf)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyTafEnable,
                              enable, BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TafEnable_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTafEnable
 *      qualifier from the field entry.
 * Parameters:
 *      unit   - (IN) Unit number.
 *      entry  - (IN) BCM field entry id.
 *      enable - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TafEnable_get(
    int unit,
    bcm_field_entry_t entry,
    uint8* enable)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#if defined(BCM_TSN_SUPPORT)
    if (soc_feature(unit, soc_feature_tsn_taf)) {
        uint8 hw_mask;

        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifyTafEnable,
                 enable, &hw_mask);
    }
#endif /* BCM_TSN_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TafGateState
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTafGateState
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      state   - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TafGateState(int unit, bcm_field_entry_t entry,
                                uint8 state)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#if defined(BCM_TSN_SUPPORT)
    if (soc_feature(unit, soc_feature_tsn_taf)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyTafGateState,
                              state, BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TafGateState_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTafGateState
 *      qualifier from the field entry.
 * Parameters:
 *      unit   - (IN) Unit number.
 *      entry  - (IN) BCM field entry id.
 *      state  - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TafGateState_get(
    int unit,
    bcm_field_entry_t entry,
    uint8* state)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#if defined(BCM_TSN_SUPPORT)
    if (soc_feature(unit, soc_feature_tsn_taf)) {
        uint8 hw_mask;

        rv = _bcm_field_entry_qualifier_uint8_get(
                 unit, entry, bcmFieldQualifyTafGateState,
                 state, &hw_mask);
    }
#endif /* BCM_TSN_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TafCosProfile
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTafCosProfile
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TafCosProfile(int unit, bcm_field_entry_t entry,
                                uint32 data, uint32 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#if defined(BCM_TSN_SUPPORT)
    if (soc_feature(unit, soc_feature_tsn_taf)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyTafCosProfile,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TSN_SUPPORT */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_TafCosProfile_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTafCosProfile
 *      qualifier from the field entry.
 * Parameters:
 *      unit   - (IN) Unit number.
 *      entry  - (IN) BCM field entry id.
 *      data   - (OUT) Qualifier match data.
 *      mask   - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_TafCosProfile_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data, uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#if defined(BCM_TSN_SUPPORT)
    if (soc_feature(unit, soc_feature_tsn_taf)) {
        rv = _bcm_field_entry_qualifier_uint32_get(
                 unit, entry, bcmFieldQualifyTafCosProfile,
                 data, mask);
    }
#endif /* BCM_TSN_SUPPORT */

    return (rv);
}



int
bcm_esw_field_qualify_CnTagPresent(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyCnTagPresent,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_CnTagPresent_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyCnTagPresent,
                                            data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_FrontPanelPkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint8 tcam_data;
       uint8 tcam_mask;

       BCM_IF_ERROR_RETURN(_bcm_field_td3_qualify_flow_type(unit,
                                              bcmFieldQualifyFrontPanelPkt,
                                              data, mask, &tcam_data, &tcam_mask));
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyFrontPanelPkt,
                             tcam_data, tcam_mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_FrontPanelPkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint8 tcam_data;
       uint8 tcam_mask;
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyFrontPanelPkt,
                                            &tcam_data, &tcam_mask);
       BCM_IF_ERROR_RETURN(rv);

       BCM_IF_ERROR_RETURN(_bcm_field_td3_qualify_flow_type_get(unit,
                                              bcmFieldQualifyFrontPanelPkt,
                                              tcam_data, tcam_mask, data, mask));
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_IpChecksumOkPkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyIpChecksumOkPkt,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_IpChecksumOkPkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyIpChecksumOkPkt,
                                            data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_IpFragPkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyIpFragPkt,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_IpFragPkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyIpFragPkt,
                                            data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_OuterPriTaggedPkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyOuterPriTaggedPkt,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_OuterPriTaggedPkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyOuterPriTaggedPkt,
                                            data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_IpInIpPkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyIpInIpPkt, data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);

}

int
bcm_esw_field_qualify_IpInIpPkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyIpInIpPkt,
                                            data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_IpTtlZeroPkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyIpTtlZeroPkt,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return (rv);
}

int
bcm_esw_field_qualify_IpTtlZeroPkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyIpTtlZeroPkt,
                                            data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_IpmcV4Pkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyIpmcV4Pkt,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_IpmcV4Pkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                  bcmFieldQualifyIpmcV4Pkt,
                                                  data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */	
    return rv;
}

int
bcm_esw_field_qualify_IpmcV6Pkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyIpmcV6Pkt, data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_IpmcV6Pkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       /* Read qualifier match value and mask. */
       return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyIpmcV6Pkt,
                                            data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */	
    return rv;
}

int
bcm_esw_field_qualify_Ipv4OptionHdrType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_ip_option_hdr_type_t type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _bcm_field_td3_qualify_IpOptionHdrType(unit,
                              bcmFieldQualifyIpv4OptionHdrType,
                              type, &data, &mask);
       if (BCM_FAILURE(rv)) {
          FP_UNLOCK(unit);
          return rv;
       }

       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyIpv4OptionHdrType,
                             data, mask);
       FP_UNLOCK(unit);
     }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_Ipv4OptionHdrType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_ip_option_hdr_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                  bcmFieldQualifyIpv4OptionHdrType,
                                  &data, &mask);
       BCM_IF_ERROR_RETURN(rv);
       rv = _bcm_field_td3_qualify_IpOptionHdrType_get(unit,
                                  bcmFieldQualifyIpv4OptionHdrType,
                                  data, mask, type);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_Ipv6ExtensionHdrType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_ip_option_hdr_type_t type)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _bcm_field_td3_qualify_IpOptionHdrType(unit,
                               bcmFieldQualifyIpv6ExtensionHdrType,
                               type, &data, &mask);
       if (BCM_FAILURE(rv)) {
          FP_UNLOCK(unit);
          return rv;
       }

       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyIpv6ExtensionHdrType,
                             data, mask);
       FP_UNLOCK(unit);
     }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_Ipv6ExtensionHdrType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_ip_option_hdr_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                  bcmFieldQualifyIpv6ExtensionHdrType,
                                  &data, &mask);
       BCM_IF_ERROR_RETURN(rv);
       rv = _bcm_field_td3_qualify_IpOptionHdrType_get(unit,
                                  bcmFieldQualifyIpv6ExtensionHdrType,
                                  data, mask, type);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_L2PktType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_l2_pkt_type_t type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _bcm_field_td3_qualify_L2PktType(unit, type, &data, &mask);
       if (BCM_FAILURE(rv)) {
          FP_UNLOCK(unit);
          return rv;
       }

       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyL2PktType,
                             data, mask);
       FP_UNLOCK(unit);
     }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_L2PktType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_l2_pkt_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyL2PktType,
                                            &data, &mask);
       BCM_IF_ERROR_RETURN(rv);
       rv = _bcm_field_td3_qualify_L2PktType_get(unit, data, mask, type);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_MplsCwPresent(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint8 hw_data;
       uint8 hw_mask;

       rv = _bcm_field_td3_qualify_MplsType(unit, bcmFieldQualifyMplsCwPresent,
                                               data, mask, &hw_data, &hw_mask);
       BCM_IF_ERROR_RETURN(rv);
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyMplsCwPresent,
                             hw_data, hw_mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_MplsCwPresent_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;
	
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint8 hw_data;
       uint8 hw_mask;

       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyMplsCwPresent,
                                            &hw_data, &hw_mask);
       FP_UNLOCK(unit);
       if (BCM_SUCCESS(rv)) {
          rv = _bcm_field_td3_qualify_MplsType_get(unit,
                           bcmFieldQualifyMplsCwPresent,
                          hw_data, hw_mask, data, mask);
       }
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_MplsMcastEthertypePresent(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint8 hw_data;
       uint8 hw_mask;

       rv = _bcm_field_td3_qualify_MplsType
              (unit,
               bcmFieldQualifyMplsMcastEthertypePresent,
               data, mask, &hw_data, &hw_mask);
       BCM_IF_ERROR_RETURN(rv);

       FP_LOCK(unit);
       rv = _field_qualify32
               (unit, entry,
                bcmFieldQualifyMplsMcastEthertypePresent,
                hw_data, hw_mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return (rv);
}

int
bcm_esw_field_qualify_MplsMcastEthertypePresent_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;
	
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint8 hw_data;
       uint8 hw_mask;

       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                    bcmFieldQualifyMplsMcastEthertypePresent,
                                         &hw_data, &hw_mask);

       FP_UNLOCK(unit);
       if (BCM_SUCCESS(rv)) {
          rv = _bcm_field_td3_qualify_MplsType_get
                   (unit,
                    bcmFieldQualifyMplsMcastEthertypePresent,
                    hw_data, hw_mask, data, mask);
       }
    }
#endif /* BCM_TRIDENT3_SUPPORT */
 
    return (rv);
}

int
bcm_esw_field_qualify_NetworkTagMulticastPkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyNetworkTagMulticastPkt,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_NetworkTagMulticastPkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;
	
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       /* Read qualifier match value and mask. */
       return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyNetworkTagMulticastPkt,
                                            data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_HiGigProxyTunnelType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_higig_proxy_tunnel_type_t type)
{
    int rv = BCM_E_UNAVAIL;
	
#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       int qual_id = bcmFieldQualifyHiGigProxyTunnelType; 

       FP_LOCK(unit);
       rv =  _bcm_field_td3_qualify_HiGigProxyTunnelType(type, &data, &mask);
       if (BCM_FAILURE(rv)) {
          FP_UNLOCK(unit);
          return rv;
       }

       rv = _field_qualify32(unit, entry, qual_id,
                             data, mask);
       FP_UNLOCK(unit);
     }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_HiGigProxyTunnelType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_higig_proxy_tunnel_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       int qual_id = bcmFieldQualifyHiGigProxyTunnelType;
 
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, qual_id,
                                                 &data, &mask);
       BCM_IF_ERROR_RETURN(rv);  
       rv = _bcm_field_td3_qualify_HiGigProxyTunnelType_get(data, mask, type);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_NetworkTagType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_network_tag_type_t type)
{
    int rv = BCM_E_UNAVAIL;
	
#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _bcm_field_td3_qualify_NetworkTagType(unit, type, &data, &mask);
       if (BCM_FAILURE(rv)) {
          FP_UNLOCK(unit);
          return rv;
       }

       rv = _field_qualify32(unit, entry, bcmFieldQualifyNetworkTagType,
                             data, mask);
       FP_UNLOCK(unit);
     }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_NetworkTagType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_network_tag_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyNetworkTagType,
                                            &data, &mask);
       BCM_IF_ERROR_RETURN(rv);  
       rv = _bcm_field_td3_qualify_NetworkTagType_get(unit, data, mask, type);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_OverlayIpv4OptionHdrType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_ip_option_hdr_type_t type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _bcm_field_td3_qualify_IpOptionHdrType(unit,
                             bcmFieldQualifyOverlayIpv4OptionHdrType,
                             type, &data, &mask);
       if (BCM_FAILURE(rv)) {
          FP_UNLOCK(unit);
          return rv;
       }

       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyOverlayIpv4OptionHdrType,
                             data, mask);
       FP_UNLOCK(unit);
     }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_OverlayIpv4OptionHdrType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_ip_option_hdr_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                  bcmFieldQualifyOverlayIpv4OptionHdrType,
                                  &data, &mask);
       BCM_IF_ERROR_RETURN(rv);
       rv = _bcm_field_td3_qualify_IpOptionHdrType_get(unit,
                              bcmFieldQualifyOverlayIpv4OptionHdrType,
                              data, mask, type);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_OverlayIpv6ExtensionHdrType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_ip_option_hdr_type_t type)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _bcm_field_td3_qualify_IpOptionHdrType(unit,
                             bcmFieldQualifyOverlayIpv6ExtensionHdrType,
                             type, &data, &mask);
       if (BCM_FAILURE(rv)) {
          FP_UNLOCK(unit);
          return rv;
       }

       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyOverlayIpv6ExtensionHdrType,
                             data, mask);
       FP_UNLOCK(unit);
     }
#endif /* BCM_TRIDENT3_SUPPORT */

    return (rv);
}

int
bcm_esw_field_qualify_OverlayIpv6ExtensionHdrType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_ip_option_hdr_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                  bcmFieldQualifyOverlayIpv6ExtensionHdrType,
                                  &data, &mask);
       BCM_IF_ERROR_RETURN(rv);
       rv = _bcm_field_td3_qualify_IpOptionHdrType_get(unit,
                                  bcmFieldQualifyOverlayIpv6ExtensionHdrType,
                                  data, mask, type);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return (rv);
}

int
bcm_esw_field_qualify_OverlayL2PktType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_l2_pkt_type_t type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _bcm_field_td3_qualify_L2PktType(unit, type, &data, &mask);
       if (BCM_FAILURE(rv)) {
          FP_UNLOCK(unit);
          return rv;
       }

       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyOverlayL2PktType,
                             data, mask);
       FP_UNLOCK(unit);
     }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_OverlayL2PktType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_l2_pkt_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyOverlayL2PktType,
                                            &data, &mask);
       BCM_IF_ERROR_RETURN(rv);
       rv = _bcm_field_td3_qualify_L2PktType_get(unit, data, mask, type);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_OverlayPktType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_pkt_type_t type)
{
    int rv = BCM_E_UNAVAIL;

#if defined (BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint32 data, mask;

       /* Overlay fields doesn't support MPLS and FCoE packet types */
       if ((type >= bcmFieldPktTypeMplsNot) && (type <= bcmFieldPktTypeFCoEFip)) {
          return BCM_E_PARAM;
       }

       BCM_IF_ERROR_RETURN(_bcm_field_td3_qualify_PktType(unit, type,
                                                          &data, &mask));
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyOverlayPktType, data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_OverlayPktType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_pkt_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined (BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint32 data, mask;

       /* Read qualifier match value and mask. */ 
       rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                           bcmFieldQualifyOverlayPktType,
                                           &data, &mask);
       BCM_IF_ERROR_RETURN(rv);

       rv = (_bcm_field_td3_qualify_PktType_get(unit, data, mask, type));
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_OverlayVlanFormat(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint8 hw_data, hw_mask;
       FP_LOCK(unit);

       rv = (_bcm_field_td3_qualify_VlanFormat(
                            unit, bcmFieldQualifyOverlayVlanFormat,
                            data, mask,
                            &hw_data, &hw_mask));

       if (BCM_SUCCESS(rv)) {
          rv = _field_qualify32(unit, entry,
                                bcmFieldQualifyOverlayVlanFormat,
                                hw_data, hw_mask);
       }
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return (rv);
}


int
bcm_esw_field_qualify_OverlayVlanFormat_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint8 hw_data, hw_mask;
       FP_LOCK(unit);

       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                 bcmFieldQualifyOverlayVlanFormat,
                                                 &hw_data, &hw_mask);

       if (BCM_SUCCESS(rv)) {
           rv = (_bcm_field_td3_qualify_VlanFormat_get(
                            unit, bcmFieldQualifyOverlayVlanFormat,
                            hw_data, hw_mask,
                            data, mask));
       }
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);

}

int
bcm_esw_field_qualify_PimBidirDfStatus(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       data = (data & 1) ? 0 : 1;
       rv = _field_qualify32(unit, entry, bcmFieldQualifyPimBidirDfStatus,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_PimBidirDfStatus_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;
	
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyPimBidirDfStatus,
                                            data, mask);
       BCM_IF_ERROR_RETURN(rv);
       *data = (*data == 1) ? 0 : 1;
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_PktType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_pkt_type_t type)
{
    int rv = BCM_E_UNAVAIL;

#if defined (BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint32 data, mask;

       BCM_IF_ERROR_RETURN(_bcm_field_td3_qualify_PktType(unit, type,
                                                          &data, &mask));
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyPktType, data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_PktType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_pkt_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined (BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint32 data, mask;

       /* Read qualifier match value and mask. */ 
       rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                                  bcmFieldQualifyPktType,
                                                  &data, &mask);
       BCM_IF_ERROR_RETURN(rv);

       rv = (_bcm_field_td3_qualify_PktType_get(unit, data, mask, type));
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}


int
bcm_esw_field_qualify_SubportTagPresent(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifySubportTagPresent,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_SubportTagPresent_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;
	
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifySubportTagPresent,
                                            data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_SysHdrType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_sys_hdr_type_t type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _bcm_field_td3_qualify_SysHdrType(unit, type, &data, &mask);
       if (BCM_FAILURE(rv)) {
          FP_UNLOCK(unit);
          return rv;
       }

       rv = _field_qualify32(unit, entry, bcmFieldQualifySysHdrType,
                             data, mask);
       FP_UNLOCK(unit);
     }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_SysHdrType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_sys_hdr_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                 bcmFieldQualifySysHdrType,
                                                 &data, &mask);
       BCM_IF_ERROR_RETURN(rv);
       rv = _bcm_field_td3_qualify_SysHdrType_get(unit, data, mask, type);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_InterfaceClassL2Type(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_interface_class_l2_type_t type)
{
    int rv = BCM_E_UNAVAIL;
	
#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       int qual_id = bcmFieldQualifyInterfaceClassL2Type; 

       rv =  _bcm_field_td3_qualify_InterfaceClassL2Type(type, &data, &mask);
       BCM_IF_ERROR_RETURN(rv);  

       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, qual_id,
                             data, mask);
       FP_UNLOCK(unit);
     }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_InterfaceClassL2Type_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_interface_class_l2_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    uint8 data;
    uint8 mask;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       int qual_id = bcmFieldQualifyInterfaceClassL2Type;
 
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, qual_id,
                                                 &data, &mask);
       FP_UNLOCK(unit);
       BCM_IF_ERROR_RETURN(rv);  
       rv = _bcm_field_td3_qualify_InterfaceClassL2Type_get(data, mask, type);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int 
bcm_esw_field_qualify_IntPktFinalHop(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint8 d;

       if (data & ~1) {
          return BCM_E_PARAM;
       }

       d = (data == 0) ? 1 : 0;

       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyIntPktFinalHop,
                             d, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;

}

int 
bcm_esw_field_qualify_IntPktFinalHop_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyIntPktFinalHop,
                                            data, mask);
       FP_UNLOCK(unit);

       if (BCM_SUCCESS(rv) && (*mask & 1)) {
          *data = (*data == 0) ? 1 : 0;
       }
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int 
bcm_esw_field_qualify_IntPktType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_int_pkt_type_t type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint32 data, mask;
 
       FP_LOCK(unit);
       if (type == bcmFieldIntPktTypeProbeRequest) {
          data = 0x1;
       } else {
          data = 0x0;
       }
       mask = 0x1;
        
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyIntPktType,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;

}

int 
bcm_esw_field_qualify_IntPktType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_int_pkt_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint8 data = 0;
       uint8 mask = 0;

       if (type == NULL) {
          return BCM_E_PARAM;
       }

       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyIntPktType,
                                            &data, &mask);
       FP_UNLOCK(unit);
       BCM_IF_ERROR_RETURN(rv);

       if (mask == 0x1) {
          if (data == 0x1) {
             *type = bcmFieldIntPktTypeProbeRequest;
          } else if (data == 0x0) {
             *type = bcmFieldIntPktTypeProbeReply;
          }
       } 
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int 
bcm_esw_field_qualify_IntPktOverflowed(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       uint8 d;
 
       if (data & ~1) {
          return BCM_E_PARAM;
       }

       d = (data == 0) ? 1 : 0;       
 
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyIntPktOverflowed,
                             d, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;

}

int 
bcm_esw_field_qualify_IntPktOverflowed_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyIntPktOverflowed,
                                            data, mask);
       FP_UNLOCK(unit);

       if (BCM_SUCCESS(rv) && (*mask & 1)) {
          *data = (*data == 0) ? 1 : 0;
       }
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}
int 
bcm_esw_field_qualify_IntPktLengthValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyIntPktLengthValid,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;

}

int 
bcm_esw_field_qualify_IntPktLengthValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyIntPktLengthValid,
                                            data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int 
bcm_esw_field_qualify_IntPktVersionOne(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyIntPktVersionOne,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

int 
bcm_esw_field_qualify_IntPktVersionOne_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyIntPktVersionOne,
                                            data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_NshServiceIndex(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        if (data >> 8) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyNshServiceIndex,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_NshServiceIndex_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        uint8 d,m;
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyNshServiceIndex,
                                            &d, &m);
        *data = d;
        *mask = m;
        FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_NshServicePathId(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        if (data >> 24) {
            return BCM_E_PARAM;
        }
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyNshServicePathId,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_NshServicePathId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                            bcmFieldQualifyNshServicePathId,
                                            data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_TunnelSubType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_TunnelSubType_t type)
{
    int               rv;   /* Operation return status. */
    uint32            data; /* HW data match criteria.  */
    uint32            mask; /* HW data mask.            */

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        BCM_IF_ERROR_RETURN(_bcm_field_td3_qualify_TunnelSubType(unit,
                                                                 type,
                                                                 &data,
                                                                 &mask));
    } else
#endif /* BCM_TRIDENT3_SUPPORT */
    {
        return BCM_E_UNAVAIL;
    }

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry, bcmFieldQualifyTunnelSubType, 
                          data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_TunnelSubType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_TunnelSubType_t *type)
{
    uint8            data; /* HW data match criteria.  */
    uint8            mask; /* HW data mask.            */
    int              rv;   /* Operation return status. */

    /* Input parameters check. */
    if (NULL == type) {
        return (BCM_E_PARAM);
    }

    FP_LOCK(unit);
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                          bcmFieldQualifyTunnelSubType,
                                          &data, &mask);
    FP_UNLOCK(unit);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        return (_bcm_field_td3_qualify_TunnelSubType_get(unit, data, mask, type));
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_BfdGoodPkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyBfdGoodPkt,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_BfdGoodPkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                          bcmFieldQualifyBfdGoodPkt,
                                          data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_BfdPktWithDstIpLoopbackAddr(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyBfdPktWithDstIpLoopbackAddr,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_BfdPktWithDstIpLoopbackAddr_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                          bcmFieldQualifyBfdPktWithDstIpLoopbackAddr,
                                          data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;

}

int
bcm_esw_field_qualify_MplsControlPkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyMplsControlPkt,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_MplsControlPkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                          bcmFieldQualifyMplsControlPkt,
                                          data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_BfdPktVersionOne(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyBfdPktVersionOne,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_BfdPktVersionOne_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                          bcmFieldQualifyBfdPktVersionOne,
                                          data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_GenevePktVersionZero(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyGenevePktVersionZero,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_GenevePktVersionZero_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                          bcmFieldQualifyGenevePktVersionZero,
                                          data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_GenevePktWithOam(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyGenevePktWithOam,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_GenevePktWithOam_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                          bcmFieldQualifyGenevePktWithOam,
                                          data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_GpePktVersionZero(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyGpePktVersionZero,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_GpePktVersionZero_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                          bcmFieldQualifyGpePktVersionZero,
                                          data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_GpePktWithOam(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyGpePktWithOam,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_GpePktWithOam_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                          bcmFieldQualifyGpePktWithOam,
                                          data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_InnerBfdPktVersionOne(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyInnerBfdPktVersionOne,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_InnerBfdPktVersionOne_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                          bcmFieldQualifyInnerBfdPktVersionOne,
                                          data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_PktDstAddrType(
    int unit,
    bcm_field_entry_t entry,
    uint32 dst_addr_type)
{
    int               rv = BCM_E_NONE;      /* Operation return status. */
    uint32            hw_data = 0;          /* HW data match criteria.  */
    uint32            hw_mask = 0;          /* HW data mask.            */

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_support)) {
        BCM_IF_ERROR_RETURN(_bcm_field_hx5_qualify_PktDstAddrType(unit,
                    bcmFieldQualifyPktDstAddrType, dst_addr_type,
                    &hw_data, &hw_mask));
    } else
#endif /* BCM_FLOWTRACKER_SUPPORT */
    {
        return BCM_E_UNAVAIL;
    }

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyPktDstAddrType, hw_data, hw_mask);

    FP_UNLOCK(unit);

    return (rv);
}

int
bcm_esw_field_qualify_PktDstAddrType_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *dst_addr_type)
{
    int              rv = BCM_E_NONE;      /* Operation return status. */
    uint32           hw_data = 0;          /* HW data match criteria.  */
    uint32           hw_mask = 0;          /* HW data mask.            */

    /* Input parameters check. */
    if (NULL == dst_addr_type) {
        return (BCM_E_PARAM);
    }

    FP_LOCK(unit);
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                          bcmFieldQualifyPktDstAddrType,
                                          &hw_data, &hw_mask);
    FP_UNLOCK(unit);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_support)) {
        return (_bcm_field_hx5_qualify_PktDstAddrType_get(unit,
                        bcmFieldQualifyPktDstAddrType,
                        hw_data, hw_mask, dst_addr_type));
    }
#endif /* BCM_FLOWTRACKER_SUPPORT */

    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_PktInnerDstAddrType(
    int unit,
    bcm_field_entry_t entry,
    uint32 dst_addr_type)
{
    int               rv = BCM_E_NONE;      /* Operation return status. */
    uint32            hw_data = 0;          /* HW data match criteria.  */
    uint32            hw_mask = 0;          /* HW data mask.            */

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_support)) {
        BCM_IF_ERROR_RETURN(_bcm_field_hx5_qualify_PktDstAddrType(unit,
                    bcmFieldQualifyPktInnerDstAddrType,
                    dst_addr_type, &hw_data, &hw_mask));
    } else
#endif /* BCM_FLOWTRACKER_SUPPORT */
    {
        return BCM_E_UNAVAIL;
    }

    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyPktInnerDstAddrType, hw_data, hw_mask);

    FP_UNLOCK(unit);

    return (rv);
}

int
bcm_esw_field_qualify_PktInnerDstAddrType_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *dst_addr_type)
{
    int               rv = BCM_E_NONE;      /* Operation return status. */
    uint32            hw_data = 0;          /* HW data match criteria.  */
    uint32            hw_mask = 0;          /* HW data mask.            */

    /* Input parameters check. */
    if (NULL == dst_addr_type) {
        return (BCM_E_PARAM);
    }

    FP_LOCK(unit);
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
            bcmFieldQualifyPktInnerDstAddrType,
            &hw_data, &hw_mask);
    FP_UNLOCK(unit);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_support)) {
        return (_bcm_field_hx5_qualify_PktDstAddrType_get(unit,
                    bcmFieldQualifyPktInnerDstAddrType,
                    hw_data, hw_mask, dst_addr_type));
    }
#endif /* BCM_FLOWTRACKER_SUPPORT */

    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerL4Ports(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

    FP_LOCK(unit);

#if defined(BCM_FLOWTRACKER_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_support)) {
        rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerL4Ports,
                        data, mask);
    }
#endif  /* BCM_FLOWTRACKER_SUPPORT */
    FP_UNLOCK(unit);

    return (rv);
}

int
bcm_esw_field_qualify_InnerL4Ports_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_SUPPORT)
    /* Read qualifier match value and mask. */
    if (soc_feature(unit, soc_feature_field_flowtracker_support)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyInnerL4Ports,
                data, mask);
    }
#endif

    return rv;
}

int
bcm_esw_field_qualify_Ip6PktNextHeader(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIp6PktNextHeader,
                            data, mask);
    FP_UNLOCK(unit);
#endif

    return (rv);
}

int
bcm_esw_field_qualify_Ip6PktNextHeader_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyIp6PktNextHeader,
                                            data, mask);
#endif

    return (rv);
}

int
bcm_esw_field_qualify_Ip6PktHopLimit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIp6PktHopLimit,
                            data, mask);
    FP_UNLOCK(unit);
#endif

    return (rv);
}

int
bcm_esw_field_qualify_Ip6PktHopLimit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyIp6PktHopLimit,
                                            data, mask);
#endif

    return (rv);
}

int
bcm_esw_field_qualify_Ip6PktTrafficClass(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyIp6PktTrafficClass,
                            data, mask);
    FP_UNLOCK(unit);
#endif

    return (rv);
}

int
bcm_esw_field_qualify_Ip6PktTrafficClass_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyIp6PktTrafficClass,
                                            data, mask);
#endif

    return (rv);
}

int
bcm_esw_field_qualify_InnerIp6PktNextHeader(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerIp6PktNextHeader,
                            data, mask);
    FP_UNLOCK(unit);
#endif

    return (rv);
}

int
bcm_esw_field_qualify_InnerIp6PktNextHeader_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyInnerIp6PktNextHeader,
                                            data, mask);
#endif

    return (rv);
}

int
bcm_esw_field_qualify_InnerIp6PktHopLimit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerIp6PktHopLimit,
                            data, mask);
    FP_UNLOCK(unit);
#endif

    return (rv);
}

int
bcm_esw_field_qualify_InnerIp6PktHopLimit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyInnerIp6PktHopLimit,
                                            data, mask);
#endif

    return (rv);
}

int
bcm_esw_field_qualify_InnerIp6PktTrafficClass(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    FP_LOCK(unit);

    rv = _field_qualify32(unit, entry, bcmFieldQualifyInnerIp6PktTrafficClass,
                            data, mask);
    FP_UNLOCK(unit);
#endif

    return (rv);
}

int
bcm_esw_field_qualify_InnerIp6PktTrafficClass_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyInnerIp6PktTrafficClass,
                                            data, mask);
#endif

    return (rv);
}

int
bcm_esw_field_action_config_info_add(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_action_t action,
    bcm_field_action_params_t *params,
    bcm_field_action_match_config_t *match_config)
{
    _field_control_t    *fc;           /* Field control structure. */
    _field_action_t     *fa = NULL;    /* Field action descriptor. */
    int                 rv;            /* Operation return status. */

    if ((NULL == params) || (NULL == match_config)) {
        return (BCM_E_PARAM);
    }

    if (!(soc_feature(unit, soc_feature_th3_style_fp)) &&
        !(SOC_IS_FIRELIGHT(unit))) {
         return BCM_E_UNAVAIL;
    }

#ifdef BROADCOM_DEBUG
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "FP(unit %d) vverb: bcm_field_action_add(entry=%d, action=%s, "
                          "p0=%d, p1=%d, p2=%d)\n"), unit, entry,
               _field_action_name(action), params->param0, params->param1, params->param2));
#endif

    FP_LOCK(unit);
    rv = _field_control_get(unit, &fc);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return rv;
    }

    fa = NULL;

    /*
     * Allocate the action descriptor, param2 to param5 are not valid here.
     */
    rv = _field_action_alloc(unit, action, params->param0, params->param1,
                             params->param2, 0, 0, 0, &fa);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: failure in _field_action_alloc()\n"),
                   unit));
        FP_UNLOCK(unit);
        return rv;
    }

    rv = _field_action_match_config_alloc (unit, match_config, fa);
    if (BCM_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "FP(unit %d) Error: failure in _field_action_match_config_alloc ()\n"),
                   unit));
        FP_UNLOCK(unit);
        sal_free(fa);
        return rv;
    }

    /*
     * Add action to entry actions list.
     */
    rv = _field_action_add(unit, fc, entry, fa);
    FP_UNLOCK(unit);
    if (BCM_FAILURE(rv)) {
        if (NULL != (fa->egress_pbmp)) {
            sal_free(fa->egress_pbmp);
        }
        sal_free(fa);
        return rv;
    }

    return (BCM_E_NONE);

}

int bcm_esw_field_action_config_info_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_action_t action,
    bcm_field_action_params_t *params,
    bcm_field_action_match_config_t *match_config)
{

    _field_action_t     *fa = NULL;    /* Field action descriptor. */
    int                 rv = 0;        /* Operation return status. */
    _field_entry_t      *f_ent = NULL; /* Field Entry Structure */
    int                 parts_count = 0;
    int                 idx = 0;

#ifdef BCM_FIRELIGHT_SUPPORT
    if (SOC_IS_FIRELIGHT(unit)) {
        if (NULL == params) {
            return (BCM_E_PARAM);
        }
    } else
#endif
    {
        if ((NULL == params) || (NULL == match_config)) {
            return (BCM_E_PARAM);
        }
    }

    /* Lock the module. */
    FP_LOCK(unit);

    rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    rv = _bcm_field_entry_tcam_parts_count (unit, f_ent->group->stage_id,
                                       f_ent->group->flags, &parts_count);
    if (BCM_FAILURE(rv)) {
        FP_UNLOCK(unit);
        return (rv);
    }

    /* Find matching action in the entry */
    for (idx = 0; idx < parts_count; idx++) {
        fa = f_ent[idx].actions;
        while (fa != NULL) {
        if (fa->action == action) {
                /* if match found, jump out of searching loop */
                goto action_found;
            }
            fa = fa->next;
        }
    }

action_found:
    if (fa == NULL) {
        FP_UNLOCK(unit);
        LOG_VERBOSE(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: action not in entry=%d\n"),
                     unit, entry));
        return (BCM_E_NOT_FOUND);
    }

    if (NULL != (fa->egress_pbmp)) {
         BCM_PBMP_ASSIGN((match_config->egr_pbmp), *(fa->egress_pbmp));
    }

    (match_config->elephant_pkt_only) = (fa->elephant_pkts_only);

    params->param0 = fa->param[0];
    params->param1 = fa->param[1];
    params->param2 = fa->param[2];

    /* Unlock the module. */
    FP_UNLOCK(unit);
    return rv;
}

/* 
 * Configure match criteria for bcmFieldQualifyRangeCheckGroup
 *         qualifier from the field entry.
 */
int bcm_esw_field_qualify_RangeCheckGroup(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;
    uint16 hw_data = 0;
    uint16 hw_mask = 0;
    uint8 hw_index = 0;
    _field_entry_t *f_ent = NULL;

    if (soc_feature(unit, soc_feature_range_check_group_support)) {

        FP_LOCK(unit);

        rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

#if defined (BCM_TOMAHAWK_SUPPORT)
        /* Validate Range Group  and get the HW index */
        rv = bcmi_xgs5_range_group_hw_idx_get(unit,
                       data, f_ent->group->instance,
                       &hw_index);

        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }
#endif

        hw_data = (1 << hw_index);
        hw_mask = 0xff;
#if defined (BCM_TOMAHAWK_SUPPORT)
        if (mask != 0xff) {
            /* Validate Range Group  and get the HW index */
            rv = bcmi_xgs5_range_group_hw_idx_get(unit,
                                                  mask, f_ent->group->instance,
                                                  &hw_index);

            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return (rv);
            }
            hw_mask = (1 << hw_index);
        }
#endif
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyRangeCheckGroup,
                              hw_data, hw_mask);
        FP_UNLOCK(unit);
    }
    return (rv);
}


/* 
 * Get match criteria for bcmFieldQualifyRangeCheckGroup
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_RangeCheckGroup_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;
    uint16 hw_data = 0;
    uint16 hw_mask = 0;
    _field_entry_t *f_ent = NULL;

    if (soc_feature(unit, soc_feature_range_check_group_support)) {
        FP_LOCK(unit);
        *mask = 0xff;
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                        bcmFieldQualifyRangeCheckGroup,
                        &hw_data, &hw_mask);

        *data = 0;
        if (hw_data) {
            while ((hw_data & 0x1) == 0) {
                *data = *data + 1;
                hw_data = hw_data >> 1;
            }
        }

        rv = _bcm_field_entry_get_by_id(unit, entry, &f_ent);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return (rv);
        }

#if defined (BCM_TOMAHAWK_SUPPORT)
        /* Validate HW index  and get the Range Group Id */
        rv = bcmi_xgs5_range_group_id_get(unit,
                                  f_ent->group->instance,
                                  data);
        if (BCM_SUCCESS(rv) && (hw_mask != 0xff)) {
            *mask = 0;
            if (hw_mask) {
                while ((hw_mask & 0x1) == 0) {
                    *mask = *mask + 1;
                    hw_mask = hw_mask >> 1;
                }
            }

            rv = bcmi_xgs5_range_group_id_get(unit,
                                              f_ent->group->instance,
                                              mask);
        }
#endif

        FP_UNLOCK(unit);
    }

    return (rv);
}

/* Qualifies on the tag type configured for opaque tags. */
int bcm_esw_field_qualify_OpaqueTagType(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_th3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyOpaqueTagType,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK3_SUPPORT */

    return rv;

}

/* 
 * To get the qualified inputs on the tag type configured for opaque
 * tags.
 */
int bcm_esw_field_qualify_OpaqueTagType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_th3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                          bcmFieldQualifyOpaqueTagType,
                                          data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK3_SUPPORT */

    return rv;

}

/* Qualifies on the higher 32 bits of opaque tag allowed in the system */
int bcm_esw_field_qualify_OpaqueTagHigh(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_th3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyOpaqueTagHigh,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK3_SUPPORT */

    return rv;
}

/* 
 * To get the qualified inputs on the higher 32 bits of opaque tag
 * allowed in the system.
 */
int bcm_esw_field_qualify_OpaqueTagHigh_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_th3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                          bcmFieldQualifyOpaqueTagHigh,
                                          data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK3_SUPPORT */

    return rv;
}

/* Qualifies on the lower 32 bits of opaque tag allowed in the system */
int bcm_esw_field_qualify_OpaqueTagLow(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_th3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry,
                             bcmFieldQualifyOpaqueTagLow,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK3_SUPPORT */

    return rv;
}

/* 
 * To get the qualified inputs on the lower 32 bits of opaque tag allowed
 * in the system.
 */
int bcm_esw_field_qualify_OpaqueTagLow_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TOMAHAWK3_SUPPORT)
    if (soc_feature(unit, soc_feature_th3_style_fp)) {
       FP_LOCK(unit);
       /* Read qualifier match value and mask. */
       rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                          bcmFieldQualifyOpaqueTagLow,
                                          data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TOMAHAWK3_SUPPORT */

    return rv;
}

/*
 * Set qualification to define packet flow for a given entry. This API is
 * normally used for preselectors.
 */
int bcm_esw_field_qualify_PktFlowType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_pkt_flow_type_t type)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp) &&
        soc_feature(unit, soc_feature_field_preselector_support) &&
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
       uint32  data32, mask32;

       FP_LOCK(unit);
       data32 = mask32 = type;
       /* coverity[address_of : FALSE] */
       /* coverity[callee_ptr_arith : FALSE] */
       rv = _bcm_field_presel_qualify_set(unit, entry,
                                          bcmFieldQualifyPktFlowType,
                                          &data32, &mask32);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

/* 
 * Retrieve packet flow type configured for given entry id. This API is
 * normally used for preselectors.
 */
int bcm_esw_field_qualify_PktFlowType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_pkt_flow_type_t *type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp) &&
        soc_feature(unit, soc_feature_field_preselector_support) &&
        (_BCM_FIELD_IS_PRESEL_ENTRY(entry) == TRUE)) {
       _bcm_field_qual_data_t q_data = {0};
       _bcm_field_qual_data_t q_mask = {0};

       /* Get field control structure. */
       FP_LOCK(unit);
       rv = _bcm_field_presel_qualifier_get(unit, entry,
                                            bcmFieldQualifyPktFlowType,
                                            q_data, q_mask);
       *type = q_data[0];
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_InnerDosAttack(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_broadscan_dos_ctrl)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyInnerDosAttack, data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return (rv);
}

/*
 * Function:
 *    bcm_esw_field_qualify_InnerDosAttack_get
 *
 * Purpose:
 *    To get match criteria for bcmFieldQualifyInnerDosAttack
 *    qualifier from the field entry.
 *
 * Parameters:
 *    unit     BCM device number.
 *    entry    Field entry ID.
 *    data     Qualifier match data.
 *    mask     Qualifier match mask.
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully.
 *    BCM_E_INIT        BCM unit not initialized.
 *    BCM_E_NOT_FOUND   Entry ID not found.
 *    BCM_E_UNAVAIL     Qualifier not supported.
 */
int
bcm_esw_field_qualify_InnerDosAttack_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

    /* Read qualifier match value and mask. */
#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_broadscan_dos_ctrl)) {
        rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyInnerDosAttack,
                data, mask);
    }
#endif
    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_DosAttackEvents
 *
 * Purpose:
 *    Configure match criteria for bcmFieldQualifyInnerDosAttack
 *    qualifier for the field entry.
 *
 * Parameters:
 *    unit     BCM device number.
 *    entry    Field entry ID.
 *    data     Qualifier match data.
 *    mask     Qualifier match mask.
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully.
 *    BCM_E_INIT        BCM unit not initialized.
 *    BCM_E_NOT_FOUND   Entry ID not found.
 *    BCM_E_UNAVAIL     Qualifier not supported.
 */
int
bcm_esw_field_qualify_DosAttackEvents(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_broadscan_dos_ctrl)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyDosAttackEvents,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return (rv);
}

/*
 * Function:
 *    bcm_esw_field_qualify_DosAttackEvents_get
 *
 * Purpose:
 *    To get match criteria for bcmFieldQualifyDosAttackEvents
 *    qualifier from the field entry.
 *
 * Parameters:
 *    unit     BCM device number.
 *    entry    Field entry ID.
 *    data     Qualifier match data.
 *    mask     Qualifier match mask.
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully.
 *    BCM_E_INIT        BCM unit not initialized.
 *    BCM_E_NOT_FOUND   Entry ID not found.
 *    BCM_E_UNAVAIL     Qualifier not supported.
 */
int
bcm_esw_field_qualify_DosAttackEvents_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;

    /* Read qualifier match value and mask. */
#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_broadscan_dos_ctrl)) {
        rv =  _bcm_field_entry_qualifier_uint32_get(unit, entry,
                bcmFieldQualifyDosAttackEvents, data, mask);
    }
#endif

    return rv;
}

/*
 * Function:
 *    bcm_esw_field_qualify_InnerDosAttackEvents
 *
 * Purpose:
 *    Configure match criteria for bcmFieldQualifyInnerDosAttackEvents
 *    qualifier for the field entry.
 *
 * Parameters:
 *    unit     BCM device number.
 *    entry    Field entry ID.
 *    data     Qualifier match data.
 *    mask     Qualifier match mask.
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully.
 *    BCM_E_INIT        BCM unit not initialized.
 *    BCM_E_NOT_FOUND   Entry ID not found.
 *    BCM_E_UNAVAIL     Qualifier not supported.
 */
int
bcm_esw_field_qualify_InnerDosAttackEvents(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_broadscan_dos_ctrl)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyInnerDosAttackEvents,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return (rv);
}

/*
 * Function:
 *    bcm_esw_field_qualify_InnerDosAttackEvents_get
 *
 * Purpose:
 *    To get match criteria for bcmFieldQualifyInnerDosAttackEvents
 *    qualifier from the field entry.
 *
 * Parameters:
 *    unit     BCM device number.
 *    entry    Field entry ID.
 *    data     Qualifier match data.
 *    mask     Qualifier match mask.
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully.
 *    BCM_E_INIT        BCM unit not initialized.
 *    BCM_E_NOT_FOUND   Entry ID not found.
 *    BCM_E_UNAVAIL     Qualifier not supported.
 */
int
bcm_esw_field_qualify_InnerDosAttackEvents_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;

    /* Read qualifier match value and mask. */
#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_broadscan_dos_ctrl)) {
        rv =  _bcm_field_entry_qualifier_uint32_get(unit, entry,
                bcmFieldQualifyInnerDosAttackEvents, data, mask);
    }
#endif

    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EgressForwardingClassId
 *
 * Purpose:
 *    To Qualify on Class identifier assigned by Egress adaptation forwarding tables
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_EgressForwardingClassId(
        int unit,
        bcm_field_entry_t entry,
        int data,
        int mask)
{
    int              rv = BCM_E_UNAVAIL;       /* Operation return status. */

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyEgressForwardingClassId,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EgressForwardingClassId
 *
 * Purpose:
 *    To get the qualified inputs on Class identifier assigned by Egress adaptation forwarding tables
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_EgressForwardingClassId_get(
        int unit,
        bcm_field_entry_t entry,
        int *data,
        int *mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint32_get(unit,
                                                   entry,
                                                   bcmFieldQualifyEgressForwardingClassId,
                                                   (uint32 *)data,
                                                   (uint32 *)mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_VlanTranslateClassId
 *
 * Purpose:
 *    To qualify on Class identifier assigned by Vlan Translation tables 
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_VlanTranslateClassId(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        if (data >> 12) {
            return (BCM_E_PARAM);
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit,
                              entry,
                              bcmFieldQualifyVlanTranslateClassId,
                              data,
                              mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_VlanTranslateClassId_get
 *
 * Purpose:
 *    To get qualified inputs on Class identifier assigned by Vlan Translation tables 
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 */
int
bcm_esw_field_qualify_VlanTranslateClassId_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint16_get(unit,
                                                   entry, 
                                                   bcmFieldQualifyVlanTranslateClassId,
                                                   data,
                                                   mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/* To Qualify on identifier field available in IP header. */
int bcm_esw_field_qualify_IpIdentifier(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit,
                              entry,
                              bcmFieldQualifyIpIdentifier,
                              data,
                              mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/* To get the qualified inputs on IP identifier. */
int bcm_esw_field_qualify_IpIdentifier_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint16_get(unit,
                                                   entry, 
                                                   bcmFieldQualifyIpIdentifier,
                                                   data,
                                                   mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_Ip4Length
 *
 * Purpose:
 *    Configure match criteria for bcmFieldQualifyIp4Length
 *    qualifier for the field entry.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 *    BCM_E_UNAVAIL     Qualifier unavailable
 */
int
bcm_esw_field_qualify_Ip4Length(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyIp4Length,
            data, mask);
    FP_UNLOCK(unit);
#endif

    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_Ip4Length_get
 *
 * Purpose:
 *    Get match criteria for bcmFieldQualifyIp4Length
 *    qualifier from the field entry.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 *    BCM_E_UNAVAIL     Qualifier unavailable
 */
int
bcm_esw_field_qualify_Ip4Length_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
            bcmFieldQualifyIp4Length, data, mask);
#endif

    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_Ip6Length
 *
 * Purpose:
 *    Configure match criteria for bcmFieldQualifyIp6Length
 *    qualifier for the field entry.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 *    BCM_E_UNAVAIL     Qualifier unavailable
 */
int
bcm_esw_field_qualify_Ip6Length(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyIp6Length,
            data, mask);
    FP_UNLOCK(unit);
#endif

    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_Ip6Length_get
 *
 * Purpose:
 *    Get match criteria for bcmFieldQualifyIp6Length
 *    qualifier from the field entry.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 *    BCM_E_UNAVAIL     Qualifier unavailable
 */
int
bcm_esw_field_qualify_Ip6Length_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
            bcmFieldQualifyIp6Length, data, mask);
#endif

    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_TunnelPayloadIp4Length
 *
 * Purpose:
 *    Configure match criteria for bcmFieldQualifyTunnelPayloadIp4Length
 *    qualifier for the field entry.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 *    BCM_E_UNAVAIL     Qualifier unavailable
 */
int
bcm_esw_field_qualify_TunnelPayloadIp4Length(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyTunnelPayloadIp4Length,
            data, mask);
    FP_UNLOCK(unit);
#endif

    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_TunnelPayloadIp4Length_get
 *
 * Purpose:
 *    Get match criteria for bcmFieldQualifyTunnelPayloadIp4Length
 *    qualifier from the field entry.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 *    BCM_E_UNAVAIL     Qualifier unavailable
 */
int
bcm_esw_field_qualify_TunnelPayloadIp4Length_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
            bcmFieldQualifyTunnelPayloadIp4Length, data, mask);
#endif

    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_TunnelPayloadIp6Length
 *
 * Purpose:
 *    Configure match criteria for bcmFieldQualifyTunnelPayloadIp6Length
 *    qualifier for the field entry.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 *    BCM_E_UNAVAIL     Qualifier unavailable
 */
int
bcm_esw_field_qualify_TunnelPayloadIp6Length(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    FP_LOCK(unit);
    rv = _field_qualify32(unit, entry,
            bcmFieldQualifyTunnelPayloadIp6Length,
            data, mask);
    FP_UNLOCK(unit);
#endif

    return rv;
}

/*
 * Function:
 *     bcm_esw_field_qualify_TunnelPayloadIp6Length_get
 *
 * Purpose:
 *    Get match criteria for bcmFieldQualifyTunnelPayloadIp6Length
 *    qualifier from the field entry.
 *
 * Parameters:
 *    unit     BCM device number
 *    entry    Field entry ID
 *    data     Qualifier match data
 *    mask     Qualifier match mask
 *
 * Returns:
 *    BCM_E_NONE        Operation completed successfully
 *    BCM_E_INIT        BCM unit not initialized
 *    BCM_E_PARAM       Invalid Parameter passed
 *    BCM_E_NOT_FOUND   Entry ID not found
 *    BCM_E_UNAVAIL     Qualifier unavailable
 */
int
bcm_esw_field_qualify_TunnelPayloadIp6Length_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
            bcmFieldQualifyTunnelPayloadIp6Length, data, mask);
#endif

    return rv;
}

int
bcm_esw_field_qualify_GbpPresent(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_hx5_flex_gbp_support)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyGbpPresent,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_HELIX5_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_GbpPresent_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_hx5_flex_gbp_support)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyGbpPresent,
                                            data, mask);
    }
#endif /* BCM_HELIX5_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_HiGigGbpPresent(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_hx5_flex_gbp_support)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigGbpPresent,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_HELIX5_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_HiGigGbpPresent_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_hx5_flex_gbp_support)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyHiGigGbpPresent,
                                            data, mask);
    }
#endif /* BCM_HELIX5_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_VxlanGbpPresent(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyVxlanGbpPresent,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT*/
    return (rv);
}

int
bcm_esw_field_qualify_VxlanGbpPresent_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                            bcmFieldQualifyVxlanGbpPresent,
                                            data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT*/
    return (rv);
}

int
bcm_esw_field_qualify_HiGigGbpSrcId(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyHiGigGbpSrcId,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_HiGigGbpSrcId_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                            bcmFieldQualifyHiGigGbpSrcId,
                                            data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_GbpSrcId(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyGbpSrcId,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_GbpSrcId_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                            bcmFieldQualifyGbpSrcId,
                                            data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_GbpDstId(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyGbpDstId,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_GbpDstId_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                            bcmFieldQualifyGbpDstId,
                                            data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_FlowtrackerCheck(
        int unit,
        bcm_field_entry_t entry,
        bcm_flowtracker_group_t  flow_group_id,
        uint32 num_checks,
        bcm_field_flowtrackercheck_t *list_of_check_ids)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        uint32 data = 0, mask = 0;
        /* Parameters Check */
        if ((NULL == list_of_check_ids) || (0 == num_checks)) {
            return BCM_E_PARAM;
        }
        /* Check Whether FlowtrackerGroupId qualifier is already configured or not */
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                               bcmFieldQualifyFlowtrackerGroupId,
                                               &data, &mask);
        BCM_IF_ERROR_RETURN(rv);
        if (flow_group_id != data) {
           LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                      "(unit %d) Error: FlowtrackerCheck qualifier should be"
                      "qualified with same Flowtracker Group Id %d as in"
                      "Qualifier FlowtrackerGroupId"),
                      unit, data));
           return BCM_E_PARAM;
        }
        data = mask = 0;
        rv = _bcm_field_ft_group_checkbmp_get(unit, flow_group_id,
                                              num_checks,
                                              list_of_check_ids,
                                              &data, &mask);
        BCM_IF_ERROR_RETURN(rv);
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyFlowtrackerCheck,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return (rv);
}
int
bcm_esw_field_qualify_FlowtrackerCheck_get(
        int unit,
        bcm_field_entry_t entry,
        bcm_flowtracker_group_t  flow_group_id,
        uint32 num_checks,
        bcm_field_flowtrackercheck_t *list_of_check_ids,
        uint32 *actual_num_checks)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)

    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        uint32 data = 0, mask = 0;
        /* Parameters Check */
        if ((NULL == list_of_check_ids) || (0 == num_checks)
            || (NULL == actual_num_checks)) {
            return BCM_E_PARAM;
        }
        /* Check Whether FlowtrackerGroupId qualifier is already configured or not */
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                               bcmFieldQualifyFlowtrackerGroupId,
                                               &data, &mask);
        BCM_IF_ERROR_RETURN(rv);
        if (flow_group_id != data) {
           LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                      "(unit %d) Error: FlowtrackerCheck qualifier should be"
                      "qualified with same Flowtracker Group Id %d as in"
                      "Qualifier FlowtrackerGroupId"),
                      unit, data));
           return BCM_E_PARAM;
        }
        data = mask = 0;
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                               bcmFieldQualifyFlowtrackerCheck,
                                               &data, &mask);
        BCM_IF_ERROR_RETURN(rv);
        rv = _bcm_field_ft_group_checklist_get(unit, flow_group_id,
                                               data, mask,
                                               num_checks,
                                               list_of_check_ids,
                                               actual_num_checks);
        BCM_IF_ERROR_RETURN(rv);
    }
#endif

    return (rv);
}
int
bcm_esw_field_qualify_FlowtrackerLearn(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        if (data >> 1) {
            return BCM_E_PARAM;
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyFlowtrackerLearn,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

int
bcm_esw_field_qualify_FlowtrackerLearn_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    if (soc_feature(unit, soc_feature_flex_flowtracker_ver_1)) {
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                               bcmFieldQualifyFlowtrackerLearn,
                                               data, mask);
    }
#endif

    return rv;
}

int
bcm_esw_field_qualify_CosMapSelect(
        int unit,
        bcm_field_entry_t entry,
        bcm_field_cos_map_select_t cos_map_select)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    if (SOC_IS_HELIX5(unit) || SOC_IS_HURRICANE4(unit)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyCosMapSelect,
                              cos_map_select, -1);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

int
bcm_esw_field_qualify_CosMapSelect_get(
        int unit,
        bcm_field_entry_t entry,
        bcm_field_cos_map_select_t *cos_map_select)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_HELIX5_SUPPORT)
    uint32 mask =0;
    if (SOC_IS_HELIX5(unit) || SOC_IS_HURRICANE4(unit)) {
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                               bcmFieldQualifyCosMapSelect,
                                               cos_map_select, &mask);
    }
#endif

    return rv;
}

int
bcm_esw_field_qualify_OpaqueObject1(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyOpaqueObject1,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int
bcm_esw_field_qualify_OpaqueObject1_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                            bcmFieldQualifyOpaqueObject1,
                                            data, mask);
    }
#endif
    return (rv);
}


int
bcm_esw_field_qualify_OpaqueObject2(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyOpaqueObject2,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int
bcm_esw_field_qualify_OpaqueObject2_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                            bcmFieldQualifyOpaqueObject2,
                                            data, mask);
    }
#endif
    return (rv);
}


int
bcm_esw_field_qualify_OpaqueObject3(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyOpaqueObject3,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int
bcm_esw_field_qualify_OpaqueObject3_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                            bcmFieldQualifyOpaqueObject3,
                                            data, mask);
    }
#endif
    return (rv);
}


int
bcm_esw_field_qualify_OpaqueObject4(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
       FP_LOCK(unit);
       rv = _field_qualify32(unit, entry, bcmFieldQualifyOpaqueObject4,
                             data, mask);
       FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int
bcm_esw_field_qualify_OpaqueObject4_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
      /* Read qualifier match value and mask. */
      return _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                            bcmFieldQualifyOpaqueObject4,
                                            data, mask);
    }
#endif
    return (rv);
}

int 
bcm_esw_field_qualify_IncomingOuterVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    int rv = BCM_E_UNAVAIL;

    if (!BCM_VLAN_VALID(data)) {
        return BCM_E_PARAM;
    }

#ifdef BCM_TRIDENT3_SUPPORT
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyIncomingOuterVlanId,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int 
bcm_esw_field_qualify_IncomingOuterVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TRIDENT3_SUPPORT
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                                                   bcmFieldQualifyIncomingOuterVlanId,
                                                   data, mask);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_LoopbackSubtype(
        int unit,
        bcm_field_entry_t entry, 
        bcm_field_loopback_subtype_t lb_subtype)
{
    int    rv = BCM_E_UNAVAIL;

#ifdef BCM_TRIDENT3_SUPPORT
    uint32 data = 0;
    uint32 mask = 0;

    if (bcmFieldLoopbackSubtypeCount <= lb_subtype) {
        return BCM_E_PARAM;
    }

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        rv = _bcm_field_td3_qualify_LoopbackSubtype(unit, lb_subtype, &data, &mask);
        BCM_IF_ERROR_RETURN(rv);

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyLoopbackSubtype,
                              data, mask);

        FP_UNLOCK(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}

int
bcm_esw_field_qualify_LoopbackSubtype_get(
        int unit,
        bcm_field_entry_t entry,
        bcm_field_loopback_subtype_t *lb_subtype)
{
    int rv = BCM_E_UNAVAIL;

#ifdef BCM_TRIDENT3_SUPPORT
    uint8 data = 0;
    uint8 mask = 0;
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        /* Read qualifier match value and mask. */
        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                                   bcmFieldQualifyLoopbackSubtype,
                                                   &data, &mask);
        BCM_IF_ERROR_RETURN(rv);
        rv = _bcm_field_td3_qualify_LoopbackSubtype_get(unit, data, mask, lb_subtype);
    }
#endif /* BCM_TRIDENT3_SUPPORT */

    return rv;
}


int 
bcm_esw_field_qualify_DstL3EgressUnderlay(int unit, 
                                        bcm_field_entry_t entry, 
                                        bcm_if_t if_id)
{
    int rv = BCM_E_UNAVAIL;   /* Operation return status. */
#if defined(INCLUDE_L3)
#if defined(BCM_TRIDENT3_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
    uint32 data;            /* HW data match criteria.  */
    uint32 mask;            /* HW data mask.            */
    uint32 flags;           /* L3 forwarding flags      */
    int nh_ecmp_id;         /* Next hop/Ecmp group id.  */

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        /* Get next hop id. */
        rv = bcm_xgs3_l3_egress_id_parse(unit, if_id, &flags, &nh_ecmp_id);
        BCM_IF_ERROR_RETURN(rv);

        if (flags & BCM_L3_MULTIPATH) {
            return (BCM_E_UNAVAIL);
        }

        data = nh_ecmp_id;
        mask = (BCM_FIELD_EXACT_MATCH_MASK);
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                            _BCM_FIELD_STAGE_INGRESS);
        if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
            /*Error fetching entry*/
            return (rv);
        }

        if (rv == BCM_E_NONE) { /*Stage is Ingress*/
            FP_LOCK(unit);
            rv = _field_control_get(unit, &fc);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return rv;
            }
            rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstL3EgressUnderlay,
                                          data, mask, 0);
            FP_UNLOCK(unit);
            return (rv);
        }
    }

#endif /* BCM_TRIDENT3_SUPPORT */
#endif /* INCLUDE_L3 */

    return (rv);
}

int 
bcm_esw_field_qualify_DstL3EgressUnderlay_get(int unit, 
                                        bcm_field_entry_t entry, 
                                        bcm_if_t *if_id)
{
    int               rv = BCM_E_UNAVAIL;  /* Operation return status. */
#if defined(INCLUDE_L3)
#if defined(BCM_TRIDENT3_SUPPORT)
    uint32            data; /* HW data match criteria.  */
    uint32            mask; /* HW data mask.            */

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        /* Input parameters check. */
        if (NULL == if_id) {
            return (BCM_E_PARAM);
        }

        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                        bcmFieldQualifyDstL3EgressUnderlay,
                                        &data, &mask);
        BCM_IF_ERROR_RETURN(rv);

        if (mask == 0) {
            return BCM_E_NOT_FOUND;
        }

        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
                                            entry,
                                            bcmFieldQualifyDstL3EgressUnderlay,
                                            &data, &mask));

        *if_id = data + BCM_XGS3_EGRESS_IDX_MIN(unit);
    }
#endif /* BCM_TRIDENT3_SUPPORT */
#endif /* INCLUDE_L3 */
    return (rv);
}

int 
bcm_esw_field_qualify_DstL3EgressNextHopsUnderlay(int unit, 
                                                bcm_field_entry_t entry, 
                                                uint32 data,
                                                uint32 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */
#if defined(INCLUDE_L3)
#ifdef BCM_TRIDENT3_SUPPORT
    _field_control_t *fc;
    uint32 max_nexthop_index = 0;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        /* Check if L3 feature is supported on the device */
        if (!soc_feature(unit, soc_feature_l3)) {
            return (rv);
        }

        /*  Make sure module was initialized. */
        if (!BCM_XGS3_L3_INITIALIZED(unit)) {
            return (rv);
        }

        max_nexthop_index = (BCM_XGS3_L3_NH_TBL_SIZE(unit) - 1);

        /* Check if mask is greater than possible table index value */
        if ((mask != BCM_FIELD_EXACT_MATCH_MASK) && (mask > max_nexthop_index)) {
            return (BCM_E_PARAM);
        }

        /* Check if data is greater than possible table index value */
        if (data > max_nexthop_index) {
            return (BCM_E_PARAM);
        }


        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }

        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                        _BCM_FIELD_STAGE_INGRESS);

        if ((rv != BCM_E_NONE) && (rv != BCM_E_CONFIG)) {
            /*Error fetching entry*/
            FP_UNLOCK(unit);
            return (rv);
        }

        if (rv == BCM_E_NONE) { /*Stage is Ingress*/ 
            rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstL3EgressNextHopsUnderlay,
                                          data, mask, 0);
            FP_UNLOCK(unit);
            return (rv);
        }
    }
#endif /* BCM_TRIDENT3_SUPPORT */
#endif /* INCLUDE_L3 */

    return (rv);

}

int 
bcm_esw_field_qualify_DstL3EgressNextHopsUnderlay_get(int unit, 
                                                bcm_field_entry_t entry, 
                                                uint32 *data,
                                                uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */

#if defined(INCLUDE_L3)
#if defined(BCM_TRIDENT3_SUPPORT)
    int i, size_bit_len = 0;

    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        /* Check if L3 feature is supported on the device */
        if (!soc_feature(unit, soc_feature_l3)) {
            return (rv);
        }

        /*  Make sure module was initialized. */
        if (!BCM_XGS3_L3_INITIALIZED(unit)) {
            return (rv);
        }

        /* Read qualifier match value and mask. */ 
        rv =  _bcm_field_entry_qualifier_uint32_get(unit, entry,
                bcmFieldQualifyDstL3EgressNextHopsUnderlay,
                data, mask);
        BCM_IF_ERROR_RETURN(rv);


        /* Retrieve the mask value according to the table size */
        for (i = 0; i < 32; i++) {
            if (BCM_XGS3_L3_NH_TBL_SIZE(unit) <= (1 << i)) {
                size_bit_len = i;
                break;
            }
        }

        *mask = *mask & ((1 << size_bit_len) - 1);

        /* Clear destination type in data and mask */
        BCM_IF_ERROR_RETURN(_field_dest_type_clear(unit,
                    entry, bcmFieldQualifyDstL3EgressNextHopsUnderlay, data, mask));
    }
#endif
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);

}

int bcm_esw_field_qualify_EgressClassPort(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int              rv = BCM_E_UNAVAIL;       /* Operation return status. */

#if defined(BCM_HELIX5_SUPPORT)
    if (SOC_IS_HELIX5X(unit)) {
        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry, bcmFieldQualifyEgressClassPort,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int bcm_esw_field_qualify_EgressClassPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_HELIX5_SUPPORT)
    if (SOC_IS_HELIX5X(unit)) {
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint16_get(unit,
                                                   entry,
                                                   bcmFieldQualifyEgressClassPort,
                                                   data,
                                                   mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

int
bcm_esw_field_qualify_INTProbeMarker1(int unit,
                                      bcm_field_entry_t entry,
                                      uint32 data,
                                      uint32 mask)
{
    int rv = BCM_E_UNAVAIL;                 /* Operation return status. */

    if (soc_feature(unit, soc_feature_udf_td3x_support)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyINTProbeMarker1,
                              data, mask);
        FP_UNLOCK(unit);
    }
    return (rv);
}

int
bcm_esw_field_qualify_INTProbeMarker1_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint32 *data,
                                          uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;                 /* Operation return status. */

    if (soc_feature(unit, soc_feature_udf_td3x_support)) {
        if ((data == NULL) || (mask == NULL)) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */
        rv = (_bcm_field_entry_qualifier_uint32_get(unit, entry,
                                 bcmFieldQualifyINTProbeMarker1,
                                 data, mask));
        FP_UNLOCK(unit);
    }
    return (rv);
}

int
bcm_esw_field_qualify_INTProbeMarker2(int unit,
                                      bcm_field_entry_t entry,
                                      uint32 data,
                                      uint32 mask)
{
    int rv = BCM_E_UNAVAIL;                 /* Operation return status. */

    if (soc_feature(unit, soc_feature_udf_td3x_support)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyINTProbeMarker2,
                              data, mask);
        FP_UNLOCK(unit);
    }
    return (rv);
}

int
bcm_esw_field_qualify_INTProbeMarker2_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint32 *data,
                                          uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;                 /* Operation return status. */

    if (soc_feature(unit, soc_feature_udf_td3x_support)) {
        if ((data == NULL) || (mask == NULL)) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */
        rv = (_bcm_field_entry_qualifier_uint32_get(unit, entry,
                                 bcmFieldQualifyINTProbeMarker2,
                                 data, mask));
        FP_UNLOCK(unit);
    }
    return (rv);
}

int
bcm_esw_field_qualify_INTReserved4Bytes(int unit,
                                        bcm_field_entry_t entry,
                                        uint32 data,
                                        uint32 mask)
{
    int rv = BCM_E_UNAVAIL;                 /* Operation return status. */

    if (soc_feature(unit, soc_feature_udf_td3x_support)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyINTReserved4Bytes,
                              data, mask);
        FP_UNLOCK(unit);
    }
    return (rv);
}

int
bcm_esw_field_qualify_INTReserved4Bytes_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint32 *data,
                                            uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;                 /* Operation return status. */

    if (soc_feature(unit, soc_feature_udf_td3x_support)) {
        if ((data == NULL) || (mask == NULL)) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */
        rv = (_bcm_field_entry_qualifier_uint32_get(unit, entry,
                                 bcmFieldQualifyINTReserved4Bytes,
                                 data, mask));
        FP_UNLOCK(unit);
    }
    return (rv);
}

int
bcm_esw_field_qualify_FlowControlType(
               int unit,
               bcm_field_entry_t entry,
               bcm_field_flow_control_pkt_type_t fc_type)
{
    bcm_error_t rv = BCM_E_UNAVAIL;

#if defined (BCM_CHANNELIZED_SWITCHING_SUPPORT)
    if (soc_feature(unit, soc_feature_channelized_switching)) {
        if (fc_type >= bcmFieldFlowControlPktTypeCount) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyFlowControlType,
                              fc_type, (uint32)BCM_FIELD_EXACT_MATCH_MASK);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

int
bcm_esw_field_qualify_FlowControlType_get(
               int unit,
               bcm_field_entry_t entry,
               bcm_field_flow_control_pkt_type_t *fc_type)
{
    bcm_error_t rv = BCM_E_UNAVAIL;

#if defined (BCM_CHANNELIZED_SWITCHING_SUPPORT)
    uint32 mask = 0;
    if (soc_feature(unit, soc_feature_channelized_switching)) {
        if (NULL == fc_type) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                                   bcmFieldQualifyFlowControlType,
                                                   fc_type, &mask);
        FP_UNLOCK(unit);
    }
#endif

    return rv;
}

int
bcm_esw_field_qualify_EgressPortCtrlType(
               int unit,
               bcm_field_entry_t entry,
               bcm_field_egress_port_ctrl_t ctrl_type)
{
    bcm_error_t rv = BCM_E_UNAVAIL;

#if defined (BCM_CHANNELIZED_SWITCHING_SUPPORT)
    uint32 data = 0, mask = 0;

    if (soc_feature(unit, soc_feature_channelized_switching)) {
        if (ctrl_type >= bcmFieldEgressPortCtrlTypeCount) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _bcm_field_td3_qual_EgressPortCtrlType_set(unit, entry, ctrl_type, &data, &mask);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = _field_qualify32(unit, entry,
                              bcmFieldQualifyEgressPortCtrlType,
                              data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return rv;
}
int
bcm_esw_field_qualify_EgressPortCtrlType_get(
               int unit,
               bcm_field_entry_t entry,
               bcm_field_egress_port_ctrl_t *ctrl_type)
{
    bcm_error_t rv = BCM_E_UNAVAIL;

#if defined (BCM_CHANNELIZED_SWITCHING_SUPPORT)
    uint32 data = 0, mask = 0;
    if (soc_feature(unit, soc_feature_channelized_switching)) {
        if (NULL == ctrl_type) {
            return BCM_E_PARAM;
        }
        FP_LOCK(unit);
        rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                                   bcmFieldQualifyEgressPortCtrlType,
                                                   &data, &mask);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = _bcm_field_td3_qual_EgressPortCtrlType_get(unit, entry, data, mask, ctrl_type);
        FP_UNLOCK(unit);
    }
#endif

    return rv;
}

int
bcm_esw_field_qualify_TimeStampTxPktType(
               int unit,
               bcm_field_entry_t entry,
               bcm_field_timestamp_transmit_pkt_type_t ts_pkt_type)
{
    bcm_error_t rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_twamp_owamp_support)) {
        uint16 data;
        uint16 mask;

        if (ts_pkt_type >= bcmFieldTimestampCount) {
            return BCM_E_PARAM;
        }

        if (soc_feature(unit, soc_feature_td3_style_fp)) {
            FP_LOCK(unit);
            rv = _bcm_field_td3_qualify_TimeStampTxPktType(unit,
                            ts_pkt_type, &data, &mask);
            if (BCM_FAILURE(rv)) {
                FP_UNLOCK(unit);
                return rv;
            }

            rv = _field_qualify32(unit, entry, bcmFieldQualifyTimeStampTxPktType,
                    data, mask);
            FP_UNLOCK(unit);
        }
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return rv;
}

int
bcm_esw_field_qualify_TimeStampTxPktType_get(
               int unit,
               bcm_field_entry_t entry,
               bcm_field_timestamp_transmit_pkt_type_t *ts_pkt_type)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_twamp_owamp_support)) {
        uint16 data;
        uint16 mask;

        if (soc_feature(unit, soc_feature_td3_style_fp)) {
            /* Read qualifier match value and mask. */
            rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                            bcmFieldQualifyTimeStampTxPktType,
                    &data, &mask);
            BCM_IF_ERROR_RETURN(rv);
            rv = _bcm_field_td3_qualify_TimeStampTxPktType_get(unit, data,
                            mask, ts_pkt_type);
        }
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_SysHdrLocalDstport(int unit,
                             bcm_field_entry_t entry,
                             bcm_port_t data, bcm_port_t mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_twamp_owamp_support)) {
        if (soc_feature(unit, soc_feature_td3_style_fp)) {
            FP_LOCK(unit);
            rv = _field_qualify32(unit, entry, bcmFieldQualifySysHdrLocalDstport,
                                  data, mask);
            FP_UNLOCK(unit);
        }
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}

int
bcm_esw_field_qualify_SysHdrLocalDstport_get(int unit,
                             bcm_field_entry_t entry,
                             bcm_port_t *data, bcm_port_t *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_twamp_owamp_support)) {
        if (soc_feature(unit, soc_feature_td3_style_fp)) {
            /* Read qualifier match value and mask. */
            return _bcm_field_entry_qualifier_uint32_get(unit, entry,
                              bcmFieldQualifySysHdrLocalDstport,
                              (uint32 *)data, (uint32 *)mask);
        }
    }
#endif /* BCM_TRIDENT3_SUPPORT */
    return (rv);
}


int
bcm_esw_field_qualify_IOAMRemainingLenValid(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)

    if (soc_feature(unit, soc_feature_ioam_support)
            && soc_feature(unit, soc_feature_td3_style_fp)) {
        if (data >> 1) {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: data=%d too large.\n"),
                     unit, data));
            return BCM_E_PARAM;
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry_id, bcmFieldQualifyIOAMRemainingLenValid, data, mask);

        FP_UNLOCK(unit);
    }
#endif
    return rv;
}



int
bcm_esw_field_qualify_IOAMRemainingLenValid_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)

    if (soc_feature(unit, soc_feature_ioam_support)
            && soc_feature(unit, soc_feature_td3_style_fp)) {
        if ((NULL == data) || (NULL == mask)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: NULL pointer passed as parameter.\n"),
                     unit));
            return BCM_E_PARAM;
        }

        rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                                bcmFieldQualifyIOAMRemainingLenValid,
                                data, mask);
    }
#endif
    return rv;
}


int
bcm_esw_field_qualify_IOAMPktOverflowed(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)

    if (soc_feature(unit, soc_feature_ioam_support)
            && soc_feature(unit, soc_feature_td3_style_fp)) {
        if (data >> 1) {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: data=%d too large.\n"),
                     unit, data));
            return BCM_E_PARAM;
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry_id, bcmFieldQualifyIOAMPktOverflowed, data, mask);

        FP_UNLOCK(unit);
    }
#endif
    return rv;
}


int
bcm_esw_field_qualify_IOAMPktOverflowed_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)

    if (soc_feature(unit, soc_feature_ioam_support)
            && soc_feature(unit, soc_feature_td3_style_fp)) {
        if ((NULL == data) || (NULL == mask)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: NULL pointer passed as parameter.\n"),
                     unit));
            return BCM_E_PARAM;
        }

        rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                                bcmFieldQualifyIOAMPktOverflowed,
                                data, mask);
    }
#endif
    return rv;
}

int
bcm_esw_field_qualify_IOAMNameSpaceIdMatch(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)

    if (soc_feature(unit, soc_feature_ioam_support)
            && soc_feature(unit, soc_feature_td3_style_fp)) {
        if (data >> 1) {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: data=%d too large.\n"),
                     unit, data));
            return BCM_E_PARAM;
        }

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry_id, bcmFieldQualifyIOAMNameSpaceIdMatch, data, mask);

        FP_UNLOCK(unit);
    }
#endif
    return rv;
}


int
bcm_esw_field_qualify_IOAMNameSpaceIdMatch_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    int    rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)

    if (soc_feature(unit, soc_feature_ioam_support)
            && soc_feature(unit, soc_feature_td3_style_fp)) {
        if ((NULL == data) || (NULL == mask)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                                "FP(unit %d) Error: NULL pointer passed as parameter.\n"),
                     unit));
            return BCM_E_PARAM;
        }

        rv =  _bcm_field_entry_qualifier_uint8_get(unit, entry_id,
                                bcmFieldQualifyIOAMNameSpaceIdMatch,
                                data, mask);
    }
#endif
    return rv;
}

int
bcm_esw_field_qualify_SubportGroupIds(
                            int unit,
                            bcm_field_entry_t entry,
                            uint32 num_groups,
                            bcm_subport_port_group_t *subport_group_id_arr)
{
    bcm_error_t rv = BCM_E_UNAVAIL;

#if defined (BCM_CHANNELIZED_SWITCHING_SUPPORT) && defined (BCM_TOMAHAWK_SUPPORT)
    int                       i = 0;
    _field_entry_t           *f_ent = NULL;
    uint32                   ref_data[_FP_QUAL_DATA_WORDS];
    uint32                   ref_mask[_FP_QUAL_DATA_WORDS];

    if (soc_feature(unit, soc_feature_channelized_switching)
        && soc_feature(unit, soc_feature_field_multi_pipe_support)) {

        if ((NULL == subport_group_id_arr)
                || (num_groups > _BCM_SUBPORT_PORT_GROUP_CNT(unit))) {
            return BCM_E_PARAM;
        }

        rv = _bcm_field_entry_qual_get(unit, entry,
                                       bcmFieldQualifySubportGroupIds,
                                       &f_ent);
        BCM_IF_ERROR_RETURN(rv);

        /* Initialization. */
        sal_memset(ref_data, 0, _FP_QUAL_DATA_WORDS * sizeof(uint32));
        sal_memset(ref_mask, BCM_FIELD_EXACT_MATCH_MASK, _FP_QUAL_DATA_WORDS * sizeof(uint32));

        for (i = 0; i < num_groups; i++) {
            if ((subport_group_id_arr[i] > _BCM_SUBPORT_PORT_GROUP_CNT(unit))
                || (0 == SHR_BITGET(_BCM_SUBPORT_PORT_GROUP_BMP(unit), \
                                subport_group_id_arr[i]))) {
                LOG_ERROR(BSL_LS_BCM_FP, \
                        (BSL_META("(unit %d) Subport Group ID : %d is"
                                  " not valid or doesn't exist\n"), \
                         unit, subport_group_id_arr[i]));   \
                    return BCM_E_PARAM;
            }
            SHR_BITSET(ref_data, subport_group_id_arr[i]);
        }

        FP_LOCK(unit);
        /* coverity[callee_ptr_arith : FALSE] */
        rv = (_bcm_field_th_qualify_set(unit, entry,
                                        bcmFieldQualifySubportGroupIds,
                                        ref_data, ref_mask,
                                        _FP_QUALIFIER_ADD));
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

int
bcm_esw_field_qualify_SubportGroupIds_get(
                            int unit,
                            bcm_field_entry_t entry,
                            uint32 num_groups,
                            bcm_subport_port_group_t *subport_group_id_arr,
                            uint32 *actual_groups)
{
    int                      rv = BCM_E_UNAVAIL;
#if defined (BCM_CHANNELIZED_SWITCHING_SUPPORT) && defined (BCM_TOMAHAWK_SUPPORT)
    _field_entry_t           *f_ent = NULL;
    int                      idx = 0;
    int                      i = 0;
    uint32                   ref_data[_FP_QUAL_DATA_WORDS];
    uint32                   ref_mask[_FP_QUAL_DATA_WORDS];

    if (soc_feature(unit, soc_feature_channelized_switching)
        || soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        /* Input parameters check. */
        if ((NULL == subport_group_id_arr) || (NULL == actual_groups)
            || (num_groups > _BCM_SUBPORT_PORT_GROUP_CNT(unit))) {
            return (BCM_E_PARAM);
        }

        /* Initialization. */
        sal_memset(ref_data, 0, _FP_QUAL_DATA_WORDS * sizeof(uint32));
        sal_memset(ref_mask, 0, _FP_QUAL_DATA_WORDS * sizeof(uint32));

        /* Get field entry part that contains the qualifier. */
        rv = _bcm_field_entry_qual_get(unit, entry, 
                                    bcmFieldQualifySubportGroupIds, &f_ent);
        BCM_IF_ERROR_RETURN(rv);

        FP_LOCK(unit);
        /* Read qualifier match value and mask. */
        rv = _field_entry_qualifier_key_get(unit, entry,
                                bcmFieldQualifySubportGroupIds,
                                ref_data, ref_mask);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        idx = 0;
        for (i = 0; i < _BCM_SUBPORT_PORT_GROUP_CNT(unit); i++) {
            if (SHR_BITGET(ref_data, i)) {
                /* Fill group ID array with the group ID */
                subport_group_id_arr[idx] = i;
                idx++;
                if (idx == num_groups) {
                    /* Array max range reached, return */
                    break;
                }
            }
        }
        /* Note down how many groups have been filled in subport_group_id_arr */
        *actual_groups = idx;
        FP_UNLOCK(unit);
    }
#endif

    return (rv);
}

int
bcm_esw_field_qualify_FlowtrackerAggregateClass(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyFlowtrackerAggregateClass,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return rv;
}

int
bcm_esw_field_qualify_FlowtrackerAggregateClass_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                bcmFieldQualifyFlowtrackerAggregateClass,
                data, mask);
    }
#endif

    return (rv);
}

int
bcm_esw_field_qualify_FlowtrackerClassIdSource1(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyFlowtrackerClassIdSource1,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

int
bcm_esw_field_qualify_FlowtrackerClassIdSource1_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                bcmFieldQualifyFlowtrackerClassIdSource1,
                data, mask);
    }
#endif

    return (rv);
}

int
bcm_esw_field_qualify_FlowtrackerClassIdSource2(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyFlowtrackerClassIdSource2,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return rv;
}

int
bcm_esw_field_qualify_FlowtrackerClassIdSource2_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                bcmFieldQualifyFlowtrackerClassIdSource2,
                data, mask);
    }
#endif
    return (rv);
}

int
bcm_esw_field_qualify_ApplSignatureId(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyApplSignatureId,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return (rv);
}

int
bcm_esw_field_qualify_ApplSignatureId_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                bcmFieldQualifyApplSignatureId,
                data, mask);
    }
#endif
    return (rv);
}

int
bcm_esw_field_qualify_InnerApplSignatureId(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyInnerApplSignatureId,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return (rv);
}

int
bcm_esw_field_qualify_InnerApplSignatureId_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        rv = _bcm_field_entry_qualifier_uint16_get(unit, entry,
                bcmFieldQualifyInnerApplSignatureId,
                data, mask);
    }
#endif
    return (rv);
}

int
bcm_esw_field_qualify_CosQueueId(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t queue_gport)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FIREBOLT6_SUPPORT)
    FP_LOCK(unit);

    rv = _bcm_field_fb6_qualify_cos_queueid(unit, entry, queue_gport);

    FP_UNLOCK(unit);
#endif

    return rv;
}

int
bcm_esw_field_qualify_CosQueueId_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *queue_gport)
{
#if defined(BCM_FIREBOLT6_SUPPORT)
    return _bcm_field_fb6_qualify_cos_queueid_get(unit,
            entry, queue_gport);
#else
    return BCM_E_UNAVAIL;
#endif
}

int
bcm_esw_field_qualify_CongestionExperienced(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyCongestionExperienced,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return (rv);
}

int
bcm_esw_field_qualify_CongestionExperienced_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        rv = _bcm_field_entry_qualifier_uint8_get(unit, entry,
                bcmFieldQualifyCongestionExperienced,
                data, mask);
    }
#endif
    return (rv);
}

int
bcm_esw_field_qualify_CongestionMarked(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyCongestionMarked,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return (rv);
}

int
bcm_esw_field_qualify_CongestionMarked_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        rv = _bcm_field_entry_qualifier_uint8_get(unit,
                entry, bcmFieldQualifyCongestionMarked,
                data, mask);
    }
#endif
    return (rv);
}

int
bcm_esw_field_qualify_IsUcastCosQueue(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyIsUcastCosQueue,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return (rv);
}

int
bcm_esw_field_qualify_IsUcastCosQueue_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        rv = _bcm_field_entry_qualifier_uint8_get(unit,
                entry, bcmFieldQualifyIsUcastCosQueue,
                data, mask);
    }
#endif
    return (rv);
}

int
bcm_esw_field_qualify_EgressPortQueue(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        FP_LOCK(unit);

        rv = _field_qualify32(unit, entry,
                bcmFieldQualifyEgressPortQueue,
                data, mask);
        FP_UNLOCK(unit);
    }
#endif

    return (rv);
}

int
bcm_esw_field_qualify_EgressPortQueue_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;

#if defined(BCM_FLOWTRACKER_V3_SUPPORT)
    if (soc_feature(unit, soc_feature_field_flowtracker_v3_support)) {

        rv = _bcm_field_entry_qualifier_uint8_get(unit,
                entry, bcmFieldQualifyEgressPortQueue,
                data, mask);
    }
#endif

    return (rv);
}
int
bcm_esw_field_qualify_ArpSenderIp4(int unit, bcm_field_entry_t entry,
                                   bcm_ip_t data, bcm_ip_t mask)
{
    int              rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyArpSenderIp4, data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int 
bcm_esw_field_qualify_ArpSenderIp4_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    if (soc_feature(unit, soc_feature_td3_style_fp) == 0) {
        return BCM_E_UNAVAIL;
    }
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                              bcmFieldQualifyArpSenderIp4,
                                              data, mask);
}

int
bcm_esw_field_qualify_ArpTargetIp4(int unit, bcm_field_entry_t entry,
                                   bcm_ip_t data, bcm_ip_t mask)
{
    int              rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyArpTargetIp4, data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int 
bcm_esw_field_qualify_ArpTargetIp4_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    if (soc_feature(unit, soc_feature_td3_style_fp) == 0) {
        return BCM_E_UNAVAIL;
    }
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                              bcmFieldQualifyArpTargetIp4,
                                              data, mask);
}

int 
bcm_esw_field_qualify_IfaCurrentLength(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    int              rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_enable_ifa_2)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyIfaCurrentLength, data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int 
bcm_esw_field_qualify_IfaRequestVector(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    int              rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_enable_ifa_2)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyIfaRequestVector, data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int 
bcm_esw_field_qualify_IfaRequestVector_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    if (soc_feature(unit, soc_feature_enable_ifa_2) == 0) {
        return BCM_E_UNAVAIL;
    }
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                              bcmFieldQualifyIfaRequestVector,
                                              data, mask);
}

int 
bcm_esw_field_qualify_IfaCurrentLengthEqualToZero(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int              rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_enable_ifa_2)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyIfaCurrentLengthEqualToZero, data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int 
bcm_esw_field_qualify_IfaCurrentLengthEqualToZero_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    if (soc_feature(unit, soc_feature_enable_ifa_2) == 0) {
        return BCM_E_UNAVAIL;
    }
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                              bcmFieldQualifyIfaCurrentLengthEqualToZero,
                                              data, mask);
}

int 
bcm_esw_field_qualify_IfaCurrentLength_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    if (soc_feature(unit, soc_feature_enable_ifa_2) == 0) {
        return BCM_E_UNAVAIL;
    }
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                              bcmFieldQualifyIfaCurrentLength,
                                              data, mask);
}

int 
bcm_esw_field_qualify_IfaGlobalNameSpace(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    int              rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_enable_ifa_2)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyIfaGlobalNameSpace, data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int 
bcm_esw_field_qualify_IfaGlobalNameSpace_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    if (soc_feature(unit, soc_feature_enable_ifa_2) == 0) {
        return BCM_E_UNAVAIL;
    }
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                              bcmFieldQualifyIfaGlobalNameSpace,
                                              data, mask);
}

int 
bcm_esw_field_qualify_IfaHopLimitEqualToZero(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int              rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_enable_ifa_2)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyIfaHopLimitEqualToZero, data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int 
bcm_esw_field_qualify_IfaHopLimitEqualToZero_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    if (soc_feature(unit, soc_feature_enable_ifa_2) == 0) {
        return BCM_E_UNAVAIL;
    }
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint8_get(unit, entry,
                                              bcmFieldQualifyIfaHopLimitEqualToZero,
                                              data, mask);
}

int 
bcm_esw_field_qualify_IfaLocalNameSpace(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    int              rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_enable_ifa_2)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyIfaLocalNameSpace, data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int 
bcm_esw_field_qualify_IfaLocalNameSpace_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    if (soc_feature(unit, soc_feature_enable_ifa_2) == 0) {
        return BCM_E_UNAVAIL;
    }
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                              bcmFieldQualifyIfaLocalNameSpace,
                                              data, mask);
}

int 
bcm_esw_field_qualify_IfaVersion2(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    int              rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_enable_ifa_2)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyIfaVersion2, data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int 
bcm_esw_field_qualify_IfaVersion2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    if (soc_feature(unit, soc_feature_enable_ifa_2) == 0) {
        return BCM_E_UNAVAIL;
    }
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint8_get(unit, entry, 
                                              bcmFieldQualifyIfaVersion2,
                                              data, mask);
}

int 
bcm_esw_field_qualify_IfaActionVector(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    int              rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_enable_ifa_2)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyIfaActionVector, data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int 
bcm_esw_field_qualify_IfaActionVector_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    if (soc_feature(unit, soc_feature_enable_ifa_2) == 0) {
        return BCM_E_UNAVAIL;
    }
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                              bcmFieldQualifyIfaActionVector,
                                              data, mask);
}

int 
bcm_esw_field_qualify_IfaFlags(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    int              rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_enable_ifa_2)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyIfaFlags, data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int 
bcm_esw_field_qualify_IfaFlags_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    if (soc_feature(unit, soc_feature_enable_ifa_2) == 0) {
        return BCM_E_UNAVAIL;
    }
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                              bcmFieldQualifyIfaFlags,
                                              data, mask);
}

int 
bcm_esw_field_qualify_IfaMaxLength(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    int              rv = BCM_E_UNAVAIL;

#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_enable_ifa_2)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit, entry, bcmFieldQualifyIfaMaxLength, data, mask);
        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int 
bcm_esw_field_qualify_IfaMaxLength_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    if (soc_feature(unit, soc_feature_enable_ifa_2) == 0) {
        return BCM_E_UNAVAIL;
    }
    /* Read qualifier match value and mask. */ 
    return  _bcm_field_entry_qualifier_uint32_get(unit, entry, 
                                              bcmFieldQualifyIfaMaxLength,
                                              data, mask);
}

int
bcm_esw_field_qualify_InnerTcpControl(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv;

    FP_LOCK(unit);

    rv = _field_qualify32(unit,
            entry, bcmFieldQualifyInnerTcpControl,
            data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int
bcm_esw_field_qualify_InnerTcpControl_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    /* Read qualifier match value and mask. */
    return  _bcm_field_entry_qualifier_uint8_get(unit,
            entry, bcmFieldQualifyInnerTcpControl,
            data, mask);
}

int
bcm_esw_field_qualify_IncomingVlanFormat(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
{
    int                 rv;      /* Operation return status. */

    
    FP_LOCK(unit);
    rv = _field_qualify_VlanFormat(unit, entry, bcmFieldQualifyIncomingVlanFormat,
                                   data, mask);

    FP_UNLOCK(unit);
    return (rv);
}

int 
bcm_esw_field_qualify_IncomingVlanFormat_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    int              rv;        /* Operation return status. */

    FP_LOCK(unit);

    rv = _field_qualify_VlanFormat_get(unit, entry, 
                                       bcmFieldQualifyIncomingVlanFormat,
                                       data, mask);
    FP_UNLOCK(unit);
    return (rv);
}


int
bcm_esw_field_qualify_LoopbackIfaSwitchCopyDrop(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    int rv = BCM_E_UNAVAIL;


#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        rv = _field_qualify32(unit,
                entry, bcmFieldQualifyLoopbackIfaSwitchCopyDrop,
                data, mask);

        FP_UNLOCK(unit);
    }
#endif
    return (rv);
}

int
bcm_esw_field_qualify_LoopbackIfaSwitchCopyDrop_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        FP_LOCK(unit);
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint8_get(unit,
                                                   entry,
                                                   bcmFieldQualifyLoopbackIfaSwitchCopyDrop,
                                                   data,
                                                   mask);
        FP_UNLOCK(unit);
    }
#endif
    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMultipathLevel1
 * Purpose:
 *      Set match criteria for bcmFieildQualifyDstMultipathLevel1
 *                     qualifier to the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) ECMP interface(s)
 *      mask  - (IN) corresponding mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMultipathLevel1(
    int unit,
    bcm_field_entry_t entry,
    bcm_if_t data,
    bcm_if_t mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(INCLUDE_L3) && defined(BCM_FIREBOLT6_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
    uint32 qual_data = 0;   /* HW data match criteria.  */
    uint32 qual_mask = 0;   /* HW data mask.            */
    uint32 tbl_size = 0;    /* ECMP table size to find number of entries */
    int grp_id = 0, idx = 0; /* group index and loop variable */
    uint32 flags;           /* L3 forwarding flags      */
    int ecmp_id;            /* Ecmp group id.  */

    if (!soc_feature(unit, soc_feature_hierarchical_ecmp) &&
        !soc_feature(unit, soc_feature_multi_level_ecmp)) {
        return rv;
    }

    if (mask == BCM_FIELD_EXACT_MATCH_MASK) {
        /* Get Ecmp Group id. */
        rv = bcm_xgs3_l3_egress_id_parse(unit, data, &flags, &ecmp_id);
        BCM_IF_ERROR_RETURN(rv);

        if (!(flags & BCM_L3_MULTIPATH)) {
            return (BCM_E_PARAM);
        }
        qual_data = ecmp_id;
        qual_mask = (uint32) mask;

    } else {
        /* Iterate through all groups and assert that groups which
           qualify have multipath flags */
        tbl_size = soc_mem_index_count(unit, INITIAL_L3_ECMP_GROUPm);
        if (mask > (tbl_size - 1)) {
            return BCM_E_PARAM;
        }
        qual_data = (data & mask);
        for (idx = 0; idx < tbl_size; idx++) {
             grp_id = BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit) + idx;
             if (qual_data == (grp_id & mask)) {
                 rv = bcm_xgs3_l3_egress_id_parse(unit,
                            grp_id, &flags, &ecmp_id);
                 BCM_IF_ERROR_RETURN(rv);

                 if (!(flags & BCM_L3_MULTIPATH)) {
                     return (BCM_E_PARAM);
                 }
            }
        }
        qual_data = data - BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit);
        qual_mask = mask;
    }

    rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                         _BCM_FIELD_STAGE_INGRESS);

    if (rv == BCM_E_NONE) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstMultipathLevel1,
                                          qual_data, qual_mask, 0);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* INCLUDE_L3 && BCM_FIREBOLT6_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMultipatLevel1_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMultipathLevel1
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (OUT) ECMP interface(s)
 *      mask  - (OUT) corresponding mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMultipathLevel1_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_if_t *data,
    bcm_if_t *mask)
{
    int               rv = BCM_E_UNAVAIL;  /* Operation return status. */
#if defined(INCLUDE_L3)
    uint32            qual_data = 0; /* HW data match criteria.  */
    uint32            qual_mask = 0; /* HW data mask.            */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask))  {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifyDstMultipathLevel1,
                                           &qual_data, &qual_mask);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_FIREBOLT6_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
    }
#endif

    *data = qual_data + BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit);
    *mask = qual_mask;
#endif /* INCLUDE_L3 */

    return (rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMultipathLevel2
 * Purpose:
 *      Set match criteria for bcmFieildQualifyDstMultipathLevel2
 *                     qualifier to the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) ECMP interface(s)
 *      mask  - (IN) corresponding mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMultipathLevel2(
    int unit,
    bcm_field_entry_t entry,
    bcm_if_t data,
    bcm_if_t mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(INCLUDE_L3) && defined(BCM_FIREBOLT6_SUPPORT)
    _field_control_t *fc;   /* Field control structure. */
    uint32 qual_data = 0;   /* HW data match criteria.  */
    uint32 qual_mask = 0;   /* HW data mask.            */
    uint32 tbl_size = 0;    /* ECMP table size to find number of entries */
    int grp_id = 0, idx = 0; /* group index and loop variable */
    uint32 flags;           /* L3 forwarding flags      */
    int ecmp_id;            /* Ecmp group id.  */

    if (!soc_feature(unit, soc_feature_hierarchical_ecmp) &&
        !soc_feature(unit, soc_feature_multi_level_ecmp)) {
        return rv;
    }

    if (mask == BCM_FIELD_EXACT_MATCH_MASK) {
        /* Get Ecmp Group id. */
        rv = bcm_xgs3_l3_egress_id_parse(unit, data, &flags, &ecmp_id);
        BCM_IF_ERROR_RETURN(rv);

        if (!(flags & BCM_L3_MULTIPATH)) {
            return (BCM_E_PARAM);
        }
        qual_data = ecmp_id;
        qual_mask = (uint32) mask;

    } else {
        /* Iterate through all groups and assert that groups which
           qualify have multipath flags */
        tbl_size = soc_mem_index_count(unit, INITIAL_L3_ECMP_GROUPm);
        if (mask > (tbl_size - 1)) {
            return BCM_E_PARAM;
        }
        qual_data = (data & mask);
        for (idx = 0; idx < tbl_size; idx++) {
             grp_id = BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit) + idx;
             if (qual_data == (grp_id & mask)) {
                 rv = bcm_xgs3_l3_egress_id_parse(unit,
                            grp_id, &flags, &ecmp_id);
                 BCM_IF_ERROR_RETURN(rv);

                 if (!(flags & BCM_L3_MULTIPATH)) {
                     return (BCM_E_PARAM);
                 }
            }
        }
        qual_data = data - BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit);
        qual_mask = mask;
    }

    rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                         _BCM_FIELD_STAGE_INGRESS);

    if (rv == BCM_E_NONE) {
        FP_LOCK(unit);
        rv = _field_control_get(unit, &fc);
        if (BCM_FAILURE(rv)) {
            FP_UNLOCK(unit);
            return rv;
        }
        rv = fc->functions.fp_qualify_dvp(unit, entry,
                                          bcmFieldQualifyDstMultipathLevel2,
                                          qual_data, qual_mask, 0);
        FP_UNLOCK(unit);
        return (rv);
    }
#endif /* INCLUDE_L3 && BCM_FIREBOLT6_SUPPORT */

    return rv;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMultipatLevel2_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMultipathLevel2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (OUT) ECMP interface(s)
 *      mask  - (OUT) corresponding mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMultipathLevel2_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_if_t *data,
    bcm_if_t *mask)
{
    int               rv = BCM_E_UNAVAIL;  /* Operation return status. */
#if defined(INCLUDE_L3)
    uint32            qual_data = 0; /* HW data match criteria.  */
    uint32            qual_mask = 0; /* HW data mask.            */

    /* Input parameters check. */
    if ((NULL == data) || (NULL == mask))  {
        return (BCM_E_PARAM);
    }

    /* Read qualifier match value and mask. */
    rv = _bcm_field_entry_qualifier_uint32_get(unit, entry,
                                           bcmFieldQualifyDstMultipathLevel2,
                                           &qual_data, &qual_mask);
    BCM_IF_ERROR_RETURN(rv);

#if defined(BCM_FIREBOLT6_SUPPORT)
    if (soc_feature(unit, soc_feature_field_multi_pipe_support)) {
        rv = _bcm_field_is_entry_stage_valid(unit, entry,
                                             _BCM_FIELD_STAGE_INGRESS);
    }
#endif

    *data = qual_data + BCM_XGS3_MPATH_EGRESS_IDX_MIN(unit);
    *mask = qual_mask;
#endif /* INCLUDE_L3 */

    return (rv);
}

int
bcm_esw_field_qualify_ForwardingPacketRes(
        int unit,
        bcm_field_entry_t entry,
        uint32 data,
        uint32 mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        if (data >> 4) {
            return (BCM_E_PARAM);
        }
        if (BCM_FIELD_FWD_PKT_RES_MC == data) {
            mask = BCM_FIELD_EXACT_MATCH_MASK;
        }
        rv = _field_qualify32(unit,
                              entry,
                              bcmFieldQualifyForwardingPacketRes,
                              data,
                              mask);
    }
#endif
    return rv;
}
int 
bcm_esw_field_qualify_ForwardingPacketRes_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    int rv = BCM_E_UNAVAIL;
#if defined(BCM_TRIDENT3_SUPPORT)
    if (soc_feature(unit, soc_feature_td3_style_fp)) {
        /* Read qualifier match value and mask. */ 
        rv = _bcm_field_entry_qualifier_uint32_get(unit,
                                           entry,
                                           bcmFieldQualifyForwardingPacketRes,
                                           data,
                                           mask);
    }
#endif
    return rv;
}
#else  /* !BCM_FIELD_SUPPORT */



int
bcm_esw_field_init(int unit)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_stage_qset_get(int unit, bcm_field_stage_t stage,
                          uint8 presel, bcm_field_qset_t *qset) {
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_detach(int unit)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_flush(int unit, bcm_field_group_t group)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_control_get(int unit, bcm_field_control_t control, uint32 *state)
{
    return (BCM_E_UNAVAIL);
}


int
bcm_esw_field_control_set(int unit, bcm_field_control_t control, uint32 state)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_stage_slice_count_get(
    int unit,
    bcm_field_stage_t stage_id,
    int *slice_count) {
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_stage_slice_info_get(
    int unit,
    bcm_field_stage_t stage_id,
    bcm_pbmp_t pbmp,
    int slice_no,
    bcm_field_stage_slice_info_t *slice_info) {
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_group_create(int unit,
                           bcm_field_qset_t qset,
                           int pri,
                           bcm_field_group_t *group)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_create_id(int unit,
                              bcm_field_qset_t qset,
                              int pri,
                              bcm_field_group_t group)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_create_mode(int unit,
                                   bcm_field_qset_t qset,
                                   int pri,
                                   bcm_field_group_mode_t mode,
                                   bcm_field_group_t *group)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_create_mode_id(int unit,
                                   bcm_field_qset_t qset,
                                   int pri,
                                   bcm_field_group_mode_t mode,
                                   bcm_field_group_t group)
{
    return (BCM_E_UNAVAIL);
}

int                                                                                                             
bcm_esw_field_group_expansion_enable_set(int unit,                                                              
                                         bcm_field_group_t group,                                               
                                         int enable)                                                            
{                                                                                                               
    return (BCM_E_UNAVAIL);                                                                                     
}                                                                                                               
                                                                                                                
int                                                                                                              
bcm_esw_field_group_expansion_enable_get(int unit,                                                               
                                         bcm_field_group_t group,                                                
                                         int *enable)                                                            
{                                                                                                               
    return (BCM_E_UNAVAIL);                                                                                     
}                                                                                                               
 
int
bcm_esw_field_group_port_create_mode(int unit, bcm_port_t port,
                                         bcm_field_qset_t qset, int pri,
                                     bcm_field_group_mode_t mode,
                                     bcm_field_group_t *group)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_port_create_mode_id(int unit, bcm_port_t port,
                                        bcm_field_qset_t qset, int pri,
                                        bcm_field_group_mode_t mode,
                                        bcm_field_group_t group)
{
    return (BCM_E_UNAVAIL);
}


int
bcm_esw_field_group_ports_create_mode(int unit, bcm_pbmp_t pbmp,
                                      bcm_field_qset_t qset, int pri,
                                      bcm_field_group_mode_t mode,
                                      bcm_field_group_t *group)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_ports_create_mode_id(int unit, bcm_pbmp_t pbmp,
                                         bcm_field_qset_t qset, int pri,
                                         bcm_field_group_mode_t mode,
                                         bcm_field_group_t group)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_action_set(int               unit,
                               bcm_field_group_t group,
                               bcm_field_aset_t  aset
                               )
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_action_get(int               unit,
                               bcm_field_group_t group,
                               bcm_field_aset_t  *aset
                               )
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_mode_get(int unit,
                             bcm_field_group_t group,
                             bcm_field_group_mode_t *mode)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_set(int unit,
                        bcm_field_group_t group,
                        bcm_field_qset_t qset)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_get(int unit,
                        bcm_field_group_t group,
                        bcm_field_qset_t *qset)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_destroy(int unit,
                            bcm_field_group_t group)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_status_get(int unit,
                               bcm_field_group_t group,
                               bcm_field_group_status_t *status)
{
    return (BCM_E_UNAVAIL);
}

    int
bcm_esw_field_group_enable_set(int unit, bcm_field_group_t group, int enable)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_enable_get(int unit, bcm_field_group_t group, int *enable)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_default_entry_set(int unit, bcm_field_group_t group,
                                      bcm_field_entry_t entry,
                                      int enable)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_default_entry_get(int unit, bcm_field_group_t group,
                                      bcm_field_entry_t *entry)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_range_create_id(int unit,
                              bcm_field_range_t range,
                              uint32 flags,
                              bcm_l4_port_t min,
                              bcm_l4_port_t max)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_range_create(int unit,
                           bcm_field_range_t *range,
                           uint32 flags,
                           bcm_l4_port_t min,
                           bcm_l4_port_t max)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_range_group_create_id(int unit,
                                    bcm_field_range_t range,
                                    uint32 flags,
                                    bcm_l4_port_t min,
                                    bcm_l4_port_t max,
                                    bcm_if_group_t group)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_range_group_create(int unit,
                                 bcm_field_range_t *range,
                                 uint32 flags,
                                 bcm_l4_port_t min,
                                 bcm_l4_port_t max,
                                 bcm_if_group_t group)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_range_get(int unit,
                        bcm_field_range_t range,
                        uint32 *flags,
                        bcm_l4_port_t *min,
                        bcm_l4_port_t *max)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_range_destroy(int unit,
                            bcm_field_range_t range)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_range_set(int unit,
                              bcm_field_group_t group,
                              uint32 flags,
                              bcm_l4_port_t min,
                              bcm_l4_port_t max)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_range_get(int unit,
                              bcm_field_group_t group,
                              uint32 *flags,
                              bcm_l4_port_t *min,
                              bcm_l4_port_t *max)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_entry_create(int unit,
                           bcm_field_group_t group,
                           bcm_field_entry_t *entry)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_entry_create_id(int unit,
                              bcm_field_group_t group,
                              bcm_field_entry_t entry)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_entry_multi_get(int unit, bcm_field_group_t group,
    int entry_size, bcm_field_entry_t *entry_array, int *entry_count)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_entry_destroy(int unit,
                            bcm_field_entry_t entry)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_entry_destroy_all(int unit)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_entry_config_copy(int unit,
                         bcm_field_entry_t src_entry,
                         bcm_field_entry_t *dst_entry,
                         uint32 flags);
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_entry_copy(int unit,
                         bcm_field_entry_t src_entry,
                         bcm_field_entry_t *dst_entry)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_entry_copy_id(int unit,
                            bcm_field_entry_t src_entry,
                            bcm_field_entry_t dst_entry)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_entry_install(int unit,
                            bcm_field_entry_t entry)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_entry_reinstall(int unit,
                              bcm_field_entry_t entry)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_entry_remove(int unit,
                           bcm_field_entry_t entry)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_entry_enable_set(int unit,
                               bcm_field_entry_t entry,
                               int enable_flag)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_entry_enable_get(int unit,
                               bcm_field_entry_t entry,
                               int *enable_flag)
{
    return (BCM_E_UNAVAIL);
}


int
bcm_esw_field_group_install(int unit,
                           bcm_field_group_t group)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_remove(int unit,
                           bcm_field_group_t group)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_entry_prio_get(int unit, bcm_field_entry_t entry, int *prio)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_entry_prio_set(int unit, bcm_field_entry_t entry, int prio)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_resync(int unit)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_clear(int unit, bcm_field_entry_t entry)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InPort(int unit, bcm_field_entry_t entry,
                             bcm_port_t data, bcm_port_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_OutPort(int unit, bcm_field_entry_t entry,
                             bcm_port_t data, bcm_port_t mask)
{
    return (BCM_E_UNAVAIL);
}



int
bcm_esw_field_qualify_InPorts(int unit, bcm_field_entry_t entry,
                              bcm_pbmp_t data, bcm_pbmp_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_OutPorts(int unit, bcm_field_entry_t entry,
                               bcm_pbmp_t data, bcm_pbmp_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_Drop(int unit, bcm_field_entry_t entry,
                           uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_SrcPort(int unit, bcm_field_entry_t entry,
                              bcm_module_t data_modid,
                              bcm_module_t mask_modid,
                              bcm_port_t   data_port,
                              bcm_port_t   mask_port)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_SrcTrunk(int unit, bcm_field_entry_t entry,
                               bcm_trunk_t data, bcm_trunk_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_SrcTrunkMemberGport(int unit,
        bcm_field_entry_t entry ,bcm_gport_t port)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_DstPort(int unit, bcm_field_entry_t entry,
                              bcm_module_t data_modid,
                              bcm_module_t mask_modid,
                              bcm_port_t   data_port,
                              bcm_port_t   mask_port)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_DstTrunk(int unit, bcm_field_entry_t entry,
                               bcm_trunk_t data, bcm_trunk_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_L4SrcPort(int unit, bcm_field_entry_t entry,
                                bcm_l4_port_t data, bcm_l4_port_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_L4DstPort(int unit, bcm_field_entry_t entry,
                                bcm_l4_port_t data, bcm_l4_port_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerL4SrcPort(int unit, bcm_field_entry_t entry,
                                bcm_l4_port_t data, bcm_l4_port_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerL4DstPort(int unit, bcm_field_entry_t entry,
                                bcm_l4_port_t data, bcm_l4_port_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_OuterVlan(int unit, bcm_field_entry_t entry,
                                bcm_vlan_t data, bcm_vlan_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerVlan(int unit, bcm_field_entry_t entry,
                                bcm_vlan_t data, bcm_vlan_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_EtherType(int unit, bcm_field_entry_t entry,
                                uint16 data, uint16 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_IpProtocol(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_DosAttack(int unit, bcm_field_entry_t entry, 
                                uint8 data, uint8 mask) 
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_IpmcStarGroupHit(int unit, bcm_field_entry_t entry, 
                                       uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_MyStationHit(int unit, bcm_field_entry_t entry, 
                                       uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_L2PayloadFirstEightBytes(int unit, bcm_field_entry_t entry,
                                            uint32 data1, uint32 data2,
                                            uint32 mask1, uint32 mask2)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_L3DestRouteHit(int unit, bcm_field_entry_t entry, 
                                uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_L3DestHostHit(int unit, bcm_field_entry_t entry, 
                                uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_L3SrcHostHit(int unit, bcm_field_entry_t entry, 
                               uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_L2CacheHit(int unit, bcm_field_entry_t entry, 
                                  uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_L2StationMove(int unit, bcm_field_entry_t entry, 
                                    uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_L2DestHit(int unit, bcm_field_entry_t entry, 
                                uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_L2SrcStatic(int unit, bcm_field_entry_t entry, 
                                  uint8 data, uint8 mask) 
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_L2SrcHit(int unit, bcm_field_entry_t entry, 
                               uint8 data, uint8 mask) 
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_IngressStpState(int unit,bcm_field_entry_t entry, 
                                      uint8 data, uint8 mask) 
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_ForwardingVlanValid(int unit, bcm_field_entry_t entry, 
                                          uint8 data, uint8 mask) 
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_SrcVirtualPortValid(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 data,
                                          uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_DstL3EgressNextHops(int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_VlanTranslationHit(int unit, bcm_field_entry_t entry, 
                                         uint8 data, uint8 mask) 
{
    return (BCM_E_UNAVAIL);
}


int
bcm_esw_field_qualify_IpInfo(int unit, bcm_field_entry_t entry,
                             uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_PacketRes(int unit, bcm_field_entry_t entry,
                                uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_SrcIp(int unit, bcm_field_entry_t entry,
                            bcm_ip_t data, bcm_ip_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_DstIp(int unit, bcm_field_entry_t entry,
                            bcm_ip_t data, bcm_ip_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_DSCP(int unit, bcm_field_entry_t entry,
                           uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_Tos(int unit, bcm_field_entry_t entry,
                           uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_IpFlags(int unit, bcm_field_entry_t entry,
                              uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_TcpControl(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_Ttl(int unit, bcm_field_entry_t entry,
                          uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_RangeCheck(int unit, bcm_field_entry_t entry,
                                 bcm_field_range_t range, int invert)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_SrcIp6(int unit, bcm_field_entry_t entry,
                             bcm_ip6_t data, bcm_ip6_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_DstIp6(int unit, bcm_field_entry_t entry,
                             bcm_ip6_t data, bcm_ip6_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_SrcIp6High(int unit, bcm_field_entry_t entry,
                                 bcm_ip6_t data, bcm_ip6_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_DstIp6High(int unit, bcm_field_entry_t entry,
                                 bcm_ip6_t data, bcm_ip6_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_SrcIp6Low(int unit, bcm_field_entry_t entry,
                                 bcm_ip6_t data, bcm_ip6_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_DstIp6Low(int unit, bcm_field_entry_t entry,
                                 bcm_ip6_t data, bcm_ip6_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_Ip6NextHeader(int unit, bcm_field_entry_t entry,
                                    uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerIp6NextHeader(int unit, bcm_field_entry_t entry,
                                    uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerIp6NextHeader_get(int unit, bcm_field_entry_t entry,
                                    uint8 *data, uint8 *mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerIp6FlowLabel(int unit, bcm_field_entry_t entry,
                                   uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_Ip6TrafficClass(int unit, bcm_field_entry_t entry,
                                      uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_Ip6FlowLabel(int unit, bcm_field_entry_t entry,
                                   uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_Ip6HopLimit(int unit, bcm_field_entry_t entry,
                                  uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerIp6HopLimit(int unit, bcm_field_entry_t entry,
                                  uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerIp6HopLimit_get(int unit, bcm_field_entry_t entry,
                                  uint8 *data, uint8 *mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_SrcMac(int unit, bcm_field_entry_t entry,
                             bcm_mac_t data, bcm_mac_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_DstMac(int unit, bcm_field_entry_t entry,
                             bcm_mac_t data, bcm_mac_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_IpType(int unit, bcm_field_entry_t entry,
                             bcm_field_IpType_t data)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_ForwardingType(int unit, bcm_field_entry_t entry,
                             bcm_field_ForwardingType_t data)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_L2Format(int unit, bcm_field_entry_t entry,
                               bcm_field_L2Format_t type)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_VlanFormat(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_MHOpcode(int unit, bcm_field_entry_t entry,
                               uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_Decap(int unit, bcm_field_entry_t entry,
                            bcm_field_decap_t decap)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_HiGig(int unit, bcm_field_entry_t entry,
                            uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}
int
bcm_esw_field_qualify_HiGigProxy(int unit, bcm_field_entry_t entry,
                            uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}
int
bcm_esw_field_qualify_InterfaceClassL2(int unit, bcm_field_entry_t entry,
                                       uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InterfaceClassVPort(int unit, bcm_field_entry_t entry,
                                         uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InterfaceClassL3(int unit, bcm_field_entry_t entry,
                                       uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InterfaceClassPort(int unit, bcm_field_entry_t entry,
                                       uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_SrcClassL2(int unit, bcm_field_entry_t entry,
                                 uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_SrcClassL3(int unit, bcm_field_entry_t entry,
                                 uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_SrcClassField(int unit, bcm_field_entry_t entry,
                                     uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_DstClassL2(int unit, bcm_field_entry_t entry,
                                 uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_DstClassL3(int unit, bcm_field_entry_t entry,
                                 uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_DstClassField(int unit, bcm_field_entry_t entry,
                                     uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_TcpSequenceZero(int unit, bcm_field_entry_t entry,
                            uint32 flag)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_TcpHeaderSize(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_IpProtocolCommon(int unit, bcm_field_entry_t entry,
                                       bcm_field_IpProtocolCommon_t protocol)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerIpProtocolCommon(int unit, bcm_field_entry_t entry,
                                       bcm_field_IpProtocolCommon_t protocol)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_Snap(int unit, bcm_field_entry_t entry,
                           bcm_field_snap_header_t data, 
                           bcm_field_snap_header_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_Llc(int unit, bcm_field_entry_t entry,
                          bcm_field_llc_header_t data, 
                          bcm_field_llc_header_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerTpid(int unit, bcm_field_entry_t entry,
                                uint16 tpid)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_OuterTpid(int unit, bcm_field_entry_t entry,
                                uint16 tpid)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_qualify_L3Routable(int unit, bcm_field_entry_t entry,
                                  uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_qualify_IpFrag(int unit, bcm_field_entry_t entry,
                                  bcm_field_IpFrag_t frag_info)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_qualify_Vrf(int unit, bcm_field_entry_t entry,
                              uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_qualify_L3Ingress(int unit, bcm_field_entry_t entry,
                              uint32 data, uint32 mask)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_qualify_L4Ports(int unit, bcm_field_entry_t entry,
                                  uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_qualify_MirrorCopy(int unit, bcm_field_entry_t entry,
                                  uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}


int bcm_esw_field_qualify_TunnelTerminated(int unit, bcm_field_entry_t entry,
                                           uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_qualify_MplsTerminated(int unit, bcm_field_entry_t entry,
                                           uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}


int bcm_esw_field_qualify_ExtensionHeaderType(int unit, 
                                              bcm_field_entry_t entry,
                                              uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_qualify_ExtensionHeaderSubCode(int unit, 
                                                 bcm_field_entry_t entry,
                                                 uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_qualify_ExtensionHeader2Type(int unit, 
                                              bcm_field_entry_t entry,
                                              uint8 data, uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_action_add(int unit,
                         bcm_field_entry_t entry,
                         bcm_field_action_t action,
                         uint32 param0,
                         uint32 param1)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_action_ports_add(int unit,
                               bcm_field_entry_t entry,
                               bcm_field_action_t action,
                               bcm_pbmp_t pbmp)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_action_get(int unit,
                         bcm_field_entry_t entry,
                         bcm_field_action_t action,
                         uint32 *param0,
                         uint32 *param1)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_action_ports_get(int unit,
                               bcm_field_entry_t entry,
                               bcm_field_action_t action,
                               bcm_pbmp_t *pbmp)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_action_delete(int unit, bcm_field_entry_t entry, 
                        bcm_field_action_t action, 
                        uint32 param0, uint32 param1)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_action_remove(int unit,
                            bcm_field_entry_t entry,
                            bcm_field_action_t action)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_action_remove_all(int unit,
                                bcm_field_entry_t entry)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_entry_dump(int unit, 
                         bcm_field_entry_t entry)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_dump(int unit,
                         bcm_field_group_t group)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_show(int unit,
                   const char *pfx)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerSrcIp(int unit, bcm_field_entry_t entry,
                            bcm_ip_t data, bcm_ip_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerDstIp(int unit, bcm_field_entry_t entry,
                            bcm_ip_t data, bcm_ip_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerSrcIp6(int unit, bcm_field_entry_t entry,
                             bcm_ip6_t data, bcm_ip6_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerDstIp6(int unit, bcm_field_entry_t entry,
                             bcm_ip6_t data, bcm_ip6_t mask)
{
     return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerSrcIp6High(int unit, bcm_field_entry_t entry,
                                 bcm_ip6_t data, bcm_ip6_t mask)
{
     return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerDstIp6High(int unit, bcm_field_entry_t entry,
                                 bcm_ip6_t data, bcm_ip6_t mask)
{
     return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerTos(int unit, bcm_field_entry_t entry,
                           uint8 data, uint8 mask)
{
     return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerDSCP(int unit, bcm_field_entry_t entry,
                           uint8 data, uint8 mask)
{
     return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerIpProtocol(int unit, bcm_field_entry_t entry,
                                 uint8 data, uint8 mask)
{
     return (BCM_E_UNAVAIL);
}


int bcm_esw_field_qualify_InnerIpFrag(int unit, bcm_field_entry_t entry,
                                  bcm_field_IpFrag_t frag_info)
{
     return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerTtl(int unit, bcm_field_entry_t entry,
                          uint8 data, uint8 mask)
{
     return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_IcmpTypeCode(int unit, bcm_field_entry_t entry,
                                         uint16 data,uint16 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_data_qualifier_create(int unit,  
                                 bcm_field_data_qualifier_t *data_qualifier)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_data_qualifier_multi_get(int unit, 
                                                                                int qual_size, 
                                                                                int *qual_array, int *qual_count)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_data_qualifier_get(int unit, 
                                                                        int qual_id, 
                                                                        bcm_field_data_qualifier_t *qual)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_data_qualifier_destroy(int unit, int qual_id)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_data_qualifier_destroy_all(int unit)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qset_data_qualifier_add(int unit, bcm_field_qset_t *qset,  
                                      int qual_id)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qset_data_qualifier_delete(int unit, bcm_field_qset_t *qset,  
                                         int qual_id)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qset_data_qualifier_get(int unit, bcm_field_qset_t qset, int qual_max,
                                  int *qual_arr, int *qual_count) 
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_data(int unit, bcm_field_entry_t eid, int qual_id,
                           uint8 *data, uint8 *mask, uint16 length)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_data_qualifier_ethertype_add(int unit, int qual_id,
                                 bcm_field_data_ethertype_t *etype)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_data_qualifier_ethertype_delete(int unit, int qual_id,
                                 bcm_field_data_ethertype_t *etype)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_data_qualifier_ip_protocol_add(int unit, int qual_id,
                                 bcm_field_data_ip_protocol_t *ip_protocol)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_data_qualifier_ip_protocol_delete(int unit, int qual_id,
                                 bcm_field_data_ip_protocol_t *ip_protocol)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_data_qualifier_packet_format_add(int unit,  int qual_id,
                                 bcm_field_data_packet_format_t *packet_format)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_data_qualifier_packet_format_delete(int unit, int qual_id,
                                 bcm_field_data_packet_format_t *packet_format)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_compress(int unit, bcm_field_group_t group)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_priority_set(int unit, bcm_field_group_t group,
                                 int priority)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_group_priority_get(int unit, bcm_field_group_t group,
                                 int *priority)
{
    return (BCM_E_UNAVAIL);
}
int 
bcm_esw_policer_init(int unit)
{
    return (BCM_E_UNAVAIL);
}
int 
bcm_esw_policer_get(int unit, bcm_policer_t policer_id, 
                    bcm_policer_config_t *pol_cfg)
{
    return (BCM_E_UNAVAIL);
}
int
bcm_esw_policer_packet_counter_get32(int unit, bcm_policer_t policer_id,
                    uint32 *count)
{
    return (BCM_E_UNAVAIL);
}
int
bcm_esw_policer_packet_reset_counter_get32(int unit, bcm_policer_t policer_id,
                    uint32 *count)
{
    return (BCM_E_UNAVAIL);
}
int 
bcm_esw_policer_set(int unit, bcm_policer_t policer_id, 
                    bcm_policer_config_t *pol_cfg)
{
    return (BCM_E_UNAVAIL);
}
int 
bcm_esw_field_entry_policer_attach(int unit, bcm_field_entry_t entry_id, 
                                   int level, bcm_policer_t policer_id)
{
    return (BCM_E_UNAVAIL);
}
int 
bcm_esw_field_entry_policer_detach(int unit, bcm_field_entry_t entry_id, 
                                   int level)
{
    return (BCM_E_UNAVAIL);
}
int 
bcm_esw_field_entry_policer_detach_all(int unit, bcm_field_entry_t entry_id)
{
    return (BCM_E_UNAVAIL);
}
int 
bcm_esw_field_entry_policer_get(int unit, bcm_field_entry_t entry_id, 
                                int level, bcm_policer_t *policer_id)
{
    return (BCM_E_UNAVAIL);
}
int 
bcm_esw_policer_create(int unit, bcm_policer_config_t *pol_cfg, 
                       bcm_policer_t *policer_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_policer_destroy(int unit, bcm_policer_t policer_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_policer_destroy_all(int unit)
{
    return BCM_E_UNAVAIL;
}
int 
bcm_esw_policer_traverse(int unit, bcm_policer_traverse_cb cb, 
                         void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_stat_create(int unit, bcm_field_group_t group, int nstat, 
                          bcm_field_stat_t *stat_arr, int *stat_id) 
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_stat_create_id(int unit, bcm_field_group_t group, int nstat, 
                          bcm_field_stat_t *stat_arr, int stat_id) 
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_stat_attach(int unit, bcm_field_group_t field_group, 
                          uint32 stat_counter_id, uint32 *stat_id)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_stat_detach(int unit, uint32 stat_id)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_stat_counter_get(int unit, uint32 stat_id, bcm_field_stat_t stat, 
                               uint32 num_entries, uint32 *counter_indexes, 
                               bcm_stat_value_t *counter_values)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_stat_counter_set(int unit, uint32 stat_id, bcm_field_stat_t stat, 
                               uint32 num_entries, uint32 *counter_indexes, 
                               bcm_stat_value_t *counter_values)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_stat_id_get(int               unit,
                              bcm_field_group_t group,
                              uint32            stat_id, 
                              uint32            *stat_counter_id)
{
   return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_stat_destroy(int unit, int stat_id)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_stat_size(int unit, int stat_id, int *stat_size)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_stat_config_get(int unit, int stat_id, int nstat, 
                              bcm_field_stat_t *stat_arr)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_stat_get(int unit, int stat_id, bcm_field_stat_t stat, 
                       uint64 *value)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_stat_get32(int unit, int stat_id, 
                             bcm_field_stat_t stat, uint32 *value)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_stat_multi_get(int unit, int stat_id, int nstat, 
                                 bcm_field_stat_t *stat_arr, uint64 *value_arr)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_stat_multi_get32(int unit, int stat_id, int nstat, 
                                   bcm_field_stat_t *stat_arr, 
                                   uint32 *value_arr)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_entry_stat_attach(int unit, bcm_field_entry_t entry, 
                                    int stat_id)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_entry_stat_extended_attach(int unit,
                                           bcm_field_entry_t entry,
                                           int stat_id,
                                           bcm_field_stat_action_t stat_action) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_entry_stat_detach(int unit, bcm_field_entry_t entry,
                                    int stat_id)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_entry_stat_get(int unit, bcm_field_entry_t entry, int *stat_id)
{
    return (BCM_E_UNAVAIL);
}

int bcm_esw_field_entry_stat_extended_get(int unit,
                                          bcm_field_entry_t entry,
                                          int *stat_id,
                                          bcm_field_stat_action_t *stat_action)
{
    return BCM_E_UNAVAIL;
}

/* Add Oam Stat action to Field Processor entry. */
int bcm_esw_field_oam_stat_action_add(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_stat_action_t *oam_stat_action)
{
    return BCM_E_UNAVAIL;
}

/* Remove Oam Stat action from Field Processor entry. */
int bcm_esw_field_oam_stat_action_delete(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_stat_action_t *oam_stat_action)
{
    return BCM_E_UNAVAIL;
}

/* Remove all Oam Stat action from Field Processor entry. */
int bcm_esw_field_oam_stat_action_delete_all(
    int unit,
    bcm_field_entry_t entry)
{
    return BCM_E_UNAVAIL;
}

/* Get Oam Stat action from Field Processor entry. */
int bcm_esw_field_oam_stat_action_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_stat_action_t *oam_stat_action)
{
    return BCM_E_UNAVAIL;
}

/* Get all Oam Stat action from Field Processor entry. */
int bcm_esw_field_oam_stat_action_get_all(
    int unit,
    bcm_field_entry_t entry,
    int oam_stat_max,
    bcm_field_oam_stat_action_t *oam_stat_action,
    int *oam_stat_count)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_stat_set(int unit, int stat_id, bcm_field_stat_t stat, 
                       uint64 value)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_stat_set32(int unit, int stat_id, bcm_field_stat_t stat, 
                         uint32 value)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_stat_all_set(int unit, int stat_id, uint64 value)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_stat_all_set32(int unit, int stat_id, uint32 value)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerIpType(int unit, bcm_field_entry_t entry,
                             bcm_field_IpType_t type)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_DstL3Egress(int unit, 
                                  bcm_field_entry_t entry, 
                                  bcm_if_t if_id)
{
    return BCM_E_UNAVAIL; 
}

int 
bcm_esw_field_qualify_DstMulticastGroup(int unit, 
                                 bcm_field_entry_t entry, 
                                 bcm_gport_t group)
{
    return BCM_E_UNAVAIL; 
}

int 
bcm_esw_field_qualify_DstMultipath(int               unit, 
                                   bcm_field_entry_t entry, 
                                   bcm_if_t          mpintf
                                   )
{
    return BCM_E_UNAVAIL; 
}

int 
bcm_esw_field_qualify_DstMultipath_get(int               unit, 
                                       bcm_field_entry_t entry, 
                                       bcm_if_t          *mpintf
                                       )
{
    return BCM_E_UNAVAIL; 
}

int 
bcm_esw_field_qualify_SrcMplsGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t mpls_port_id)
{
    return BCM_E_UNAVAIL; 
}


int 
bcm_esw_field_qualify_DstMplsGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t mpls_port_id)
{
    return BCM_E_UNAVAIL; 
}


int 
bcm_esw_field_qualify_SrcNivGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t niv_port_id)
{
    return BCM_E_UNAVAIL; 
}


int 
bcm_esw_field_qualify_DstNivGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t niv_port_id)
{
    return BCM_E_UNAVAIL; 
}

int 
bcm_esw_field_qualify_SrcMimGport(int unit, 
                              bcm_field_entry_t entry, 
                              bcm_gport_t mim_port_id)
{
    return BCM_E_UNAVAIL; 
}


int 
bcm_esw_field_qualify_DstMimGport(int unit, 
                              bcm_field_entry_t entry, 
                              bcm_gport_t mim_port_id)
{
    return BCM_E_UNAVAIL; 
}


int 
bcm_esw_field_qualify_SrcWlanGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t wlan_port_id)
{
    return BCM_E_UNAVAIL; 
}

int 
bcm_esw_field_qualify_DstWlanGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t wlan_port_id)
{
    return BCM_E_UNAVAIL; 
}

int
bcm_esw_field_qualify_SrcVlanGport(int unit,
                               bcm_field_entry_t entry,
                               bcm_gport_t vlan_port_id)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DstVlanGport(int unit,
                               bcm_field_entry_t entry,
                               bcm_gport_t vlan_port_id)
{
    return BCM_E_UNAVAIL;
}
 
int 
bcm_esw_field_qualify_Loopback(int unit, 
                               bcm_field_entry_t entry, 
                               uint8 data, 
                               uint8 mask)
{
    return BCM_E_UNAVAIL; 
}

int 
bcm_esw_field_qualify_LoopbackType(int unit, 
                                   bcm_field_entry_t entry, 
                                   bcm_field_LoopbackType_t loopback_type)
{
    return BCM_E_UNAVAIL; 
}

int 
bcm_esw_field_qualify_TunnelType(int unit, 
                                 bcm_field_entry_t entry, 
                                 bcm_field_TunnelType_t tunnel_type)
{
    return BCM_E_UNAVAIL; 
}


/*
 * Function:
 *      bcm_esw_field_qualify_LoopbackType_get
 * Purpose:
 *      Get loopback type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      loopback_type - (OUT) Loopback type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_LoopbackType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_LoopbackType_t *loopback_type)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelType_get
 * Purpose:
 *      Get tunnel type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      tunnel_type - (OUT) Tunnel type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TunnelType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_TunnelType_t *tunnel_type)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstL3Egress_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstL3Egress
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      if_id - (OUT) L3 forwarding object.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstL3Egress_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_if_t *if_id)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMulticastGroup_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMulticastGroup
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      group - (OUT) Multicast group id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstMulticastGroup_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *group)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcMplsGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcMplsGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mpls_port_id - (OUT) Mpls port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcMplsGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *mpls_port_id)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMplsGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMplsGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mpls_port_id - (OUT) Mpls port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstMplsGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *mpls_port_id)
{
    return BCM_E_UNAVAIL; 
}



/*
 * Function:
 *      bcm_esw_field_qualify_SrcNivGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcNivGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      niv_port_id - (OUT) Niv port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcNivGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *niv_port_id)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstNivGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstNivGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      niv_port_id - (OUT) Niv port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstNivGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *niv_port_id)
{
    return BCM_E_UNAVAIL; 
}


/*
 * Function:
 *      bcm_esw_field_qualify_SrcMimGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcMimGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mim_port_id - (OUT) Mim port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcMimGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *mim_port_id)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMimGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMimGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mim_port_id - (OUT) Mim port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstMimGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *mim_port_id)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcWlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcWlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      wlan_port_id - (OUT) Wlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcWlanGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *wlan_port_id)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstWlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstWlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      wlan_port_id - (OUT) Wlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstWlanGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *wlan_port_id)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcVlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcVlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      vlan_port_id - (OUT) Vlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SrcVlanGport_get(
        int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *vlan_port_id)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstVlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstVlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      vlan_port_id - (OUT) Vlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstVlanGport_get(
        int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *vlan_port_id)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_Loopback_get
 * Purpose:
 *      Get loopback field qualification from  a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data - (OUT) Data to qualify with.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Loopback_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_port_t *data, 
    bcm_port_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_OutPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyOutPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OutPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_port_t *data, 
    bcm_port_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InPorts_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInPorts
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InPorts_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_pbmp_t *data, 
    bcm_pbmp_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_OutPorts_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyOutPorts
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OutPorts_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_pbmp_t *data, 
    bcm_pbmp_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_Drop_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDrop
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Drop_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data_modid - (OUT) Qualifier module id.
 *      mask_modid - (OUT) Qualifier module id mask.
 *      data_port - (OUT) Qualifier port id.
 *      mask_port - (OUT) Qualifier port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_module_t *data_modid, 
    bcm_module_t *mask_modid, 
    bcm_port_t *data_port, 
    bcm_port_t *mask_port)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcTrunk_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcTrunk
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcTrunk_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_trunk_t *data, 
    bcm_trunk_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcTrunkMemberGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcTrunkMemberGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      port  - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcTrunkMemberGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *port) 
{
    return (BCM_E_UNAVAIL);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data_modid - (OUT) Qualifier module id.
 *      mask_modid - (OUT) Qualifier module id mask.
 *      data_port - (OUT) Qualifier port id.
 *      mask_port - (OUT) Qualifier port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_module_t *data_modid, 
    bcm_module_t *mask_modid, 
    bcm_port_t *data_port, 
    bcm_port_t *mask_port)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstTrunk_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstTrunk
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstTrunk_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_trunk_t *data, 
    bcm_trunk_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerL4SrcPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerL4SrcPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerL4SrcPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerL4DstPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerL4DstPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerL4DstPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L4SrcPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL4SrcPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L4SrcPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L4DstPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL4DstPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L4DstPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlan_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyOuterVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlan_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_EtherType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyEtherType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_EtherType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpProtocol_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpProtocol
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpProtocol_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpInfo_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpInfo
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpInfo_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_PacketRes_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyPacketRes
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_PacketRes_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcIp_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstIp_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_Tos_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTos
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Tos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DSCP_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDSCP
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DSCP_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpFlags_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpFlags
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpFlags_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_TcpControl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTcpControl
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TcpControl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_TcpSequenceZero_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTcpSequenceZero
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      flag - (OUT) Qualifier match flags.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TcpSequenceZero_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *flag)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_TcpHeaderSize_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTcpHeaderSize
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TcpHeaderSize_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_Ttl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTtl
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Ttl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_RangeCheck_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyRangeCheck
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      max_count - (IN) Max entries to fill.
 *      range - (OUT) Range checkers array.
 *      invert - (OUT) Range checkers invert array.
 *      count - (OUT) Number of filled range checkers.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_RangeCheck_get(
    int unit, 
    bcm_field_entry_t entry, 
    int max_count, 
    bcm_field_range_t *range, 
    int *invert, 
    int *count)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcIp6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstIp6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcIp6High_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcIp6Low_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcIp6Low
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcIp6Low_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6Low_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstIp6Low
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstIp6Low_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstIp6High_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_Ip6NextHeader_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIp6NextHeader
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Ip6NextHeader_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_Ip6TrafficClass_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIp6TrafficClass
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Ip6TrafficClass_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerIp6FlowLabel_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerIp6FlowLabel
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerIp6FlowLabel_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_Ip6FlowLabel_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIp6FlowLabel
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Ip6FlowLabel_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_Ip6HopLimit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIp6HopLimit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Ip6HopLimit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcMac_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstMac_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerIpType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerIpType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Inner ip header ip type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerIpType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpType_t *type)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_ForwardingType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyForwardingType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Qualifier match forwarding type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ForwardingType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ForwardingType_t *type)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Qualifier match ip type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpType_t *type)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2Format_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL2Format
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Qualifier match l2 format.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2Format_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_L2Format_t *type)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_VlanFormat_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVlanFormat
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_VlanFormat_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_MHOpcode_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMHOpcode
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MHOpcode_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *     bcm_esw_field_qualify_Decap_get
 * Purpose:
 *     Get match criteria for bcmFieildQualifyDecap
 *     qualifier from the field entry.
 * Parameters:
 *     unit  - (IN) Unit number.
 *     entry - (IN) BCM field entry id.
 *     decap - (OUT) Qualifier decap type.
 * Returns:
 *     BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_Decap_get(int unit, bcm_field_entry_t entry,
                                bcm_field_decap_t *decap)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGig_get
 * Purpose:
 *      Qualify on HiGig packets.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_HiGig_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_HiGigProxy_get
 * Purpose:
 *      Qualify on HiGig lookedup packets.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_HiGigProxy_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_InterfaceClassPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInterfaceClassPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InterfaceClassPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InterfaceClassVPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInterfaceClassVPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_InterfaceClassVPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_InterfaceClassL2_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInterfaceClassL2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InterfaceClassL2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InterfaceClassL3_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInterfaceClassL3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InterfaceClassL3_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcClassL2_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcClassL2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcClassL2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcClassL3_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcClassL3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcClassL3_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcClassField_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcClassField
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcClassField_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstClassL2_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstClassL2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstClassL2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstClassL3_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstClassL3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstClassL3_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstClassField_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstClassField
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstClassField_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpProtocolCommon_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpProtocolCommon
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      protocol - (OUT) Qualifier protocol encoding.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpProtocolCommon_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpProtocolCommon_t *protocol)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerIpProtocolCommon_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerIpProtocolCommon
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      protocol - (OUT) Qualifier inner ip protocol encodnig.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerIpProtocolCommon_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpProtocolCommon_t *protocol)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_Snap_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySnap
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Snap_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_snap_header_t *data, 
    bcm_field_snap_header_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_Llc_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyLlc
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Llc_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_llc_header_t *data, 
    bcm_field_llc_header_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerTpid_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerTpid
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      tpid - (OUT) Qualifier tpid.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerTpid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *tpid)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_OuterTpid_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyOuterTpid
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      tpid - (OUT) Qualifier tpid.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterTpid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *tpid)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L3Routable_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL3Routable
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L3Routable_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpFrag_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpFrag
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      frag_info - (OUT) Qualifier ip framentation encoding.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpFrag_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpFrag_t *frag_info)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_Vrf_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVrf
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Vrf_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L3Ingress_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVrf
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L3Ingress_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_ExtensionHeaderType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyExtensionHeaderType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ExtensionHeaderType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_ExtensionHeaderSubCode_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyExtensionHeaderSubCode
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ExtensionHeaderSubCode_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_ExtensionHeader2Type_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyExtensionHeader2Type
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ExtensionHeader2Type_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L4Ports_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL4Ports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L4Ports_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_MirrorCopy_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMirrorCopy
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MirrorCopy_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_TunnelTerminated_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTunnelTerminated
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TunnelTerminated_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_MplsTerminated_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMplsTerminated
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MplsTerminated_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerSrcIp_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerSrcIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerSrcIp_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerDstIp_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerDstIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerDstIp_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerSrcIp6_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerSrcIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerSrcIp6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerDstIp6_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerDstIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerDstIp6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerSrcIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerSrcIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerSrcIp6High_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerDstIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerDstIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerDstIp6High_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerTtl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerTtl
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerTtl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerTos_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerDSCP
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerTos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerDSCP_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerDSCP
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerDSCP_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerIpProtocol_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerIpProtocol
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerIpProtocol_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerIpFrag_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInnerIpFrag
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      frag_info - (OUT) Inner ip header fragmentation info.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerIpFrag_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpFrag_t *frag_info)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DosAttack_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDosAttack
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DosAttack_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_IpmcStarGroupHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIpmcStarGroupHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IpmcStarGroupHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_MyStationHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMyStationHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_MyStationHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2PayloadFirstEightBytes_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL2PayloadFirstEightBytes
 *          qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data1 - (OUT) Qualifier first four bytes of match data.
 *      data2 - (OUT) Qualifier last four bytes of match data.
 *      mask1 - (OUT) Qualifier first four bytes of match mask.
 *      mask2 - (OUT) Qualifier last four bytes of match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2PayloadFirstEightBytes_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data1, uint32 *data2,
    uint32 *mask1, uint32 *mask2)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L3DestRouteHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL3DestRouteHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L3DestRouteHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L3DestHostHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL3DestHostHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L3DestHostHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L3SrcHostHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL3SrcHostHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L3SrcHostHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2CacheHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL2CacheHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2CacheHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2StationMove_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL2StationMove
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2StationMove_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2DestHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL2DestHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2DestHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2SrcStatic_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL2SrcStatic
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2SrcStatic_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_L2SrcHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyL2SrcHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_L2SrcHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressStpState_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIngressStpState
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IngressStpState_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_ForwardingVlanValid_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyForwardingVlanValid
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ForwardingVlanValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcVirtualPortValid_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcVirtualPortValid
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcVirtualPortValid_get(int unit,
                                              bcm_field_entry_t entry,
                                              uint8 *data,
                                              uint8 *mask)
{
    return (BCM_E_UNAVAIL);
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstL3EgressNextHops_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstL3EgressNextHops
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstL3EgressNextHops_get(int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return (BCM_E_UNAVAIL);
}

/*
 * Function:
 *      bcm_esw_field_qualify_VlanTranslationHit_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVlanTranslationHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_VlanTranslationHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_IcmpTypeCode_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIcmpTypeCode
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IcmpTypeCode_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_TranslatedVlanFormat
 * Purpose:
 *      Set match criteria for bcmFieildQualifyTranslatedVlanFormat
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TranslatedVlanFormat(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_IntPriority
 * Purpose:
 *      Set match criteria for bcmFieildQualifyIntPriority
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IntPriority(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL; 
}


/*
 * Function:
 *      bcm_esw_field_qualify_Color
 * Purpose:
 *      Set match criteria for bcmFieildQualifyColor
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      color - (IN) Qualifier match color.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Color(int unit, bcm_field_entry_t entry, 
                            uint8 color)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanOuter
 * Purpose:
 *      Add Fibre Channel outer header type field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (IN) Data to qualify with.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_FibreChanOuter(int unit, 
                             bcm_field_entry_t entry, 
                             bcm_field_FibreChan_t fibre_chan_type)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanInner
 * Purpose:
 *      Add Fibre Channel inner header type field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (IN) Data to qualify with.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_FibreChanInner(int unit, 
                             bcm_field_entry_t entry, 
                             bcm_field_FibreChan_t fibre_chan_type)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VnTag
 * Purpose:
 *      Add NIV VN tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VnTag(int unit, bcm_field_entry_t entry,
                            uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *  bcm_esw_field_qualify_ETag
 * Purpose:
 *  Add Etag field qualification to a field entry.
 * Parameters:
 *  unit  - (IN) Unit number.
 *  entry - (IN) Field entry id.
 *  data  - (IN) Qualifier match data.
 *  mask  - (IN) Qualifier match mask.
 * Returns:
 *  BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ETag(int unit, bcm_field_entry_t entry,
                                     uint64 data, uint64 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SubportPktTag
 * Purpose:
 *      Add LLTAG tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_SubportPktTag(int unit, bcm_field_entry_t entry,
                            uint16 data, uint16 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_L2GreVsid(int unit, bcm_field_entry_t entry,
                                        uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_L2GreVsid_get(int unit, bcm_field_entry_t entry,
                                    uint32 *data, uint32 *mask) {
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_CnTag
 * Purpose:
 *      Add QCN CN tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_CnTag(int unit, bcm_field_entry_t entry,
                            uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FabricQueueTag
 * Purpose:
 *      Add Fabric Queue tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FabricQueueTag(int unit, bcm_field_entry_t entry,
                                     uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcModPortGport
 * Purpose:
 *      Set match criteria for bcmFieildQualifySrcModPortGport
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcModPortGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t data)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcModuleGport
 * Purpose:
 *      Set match criteria for bcmFieildQualifySrcModuleGport
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcModuleGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t data)
{
    return BCM_E_UNAVAIL; 
}


/*
 * Function:
 *      bcm_esw_field_qualify_TranslatedVlanFormat_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyTranslatedVlanFormat
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_TranslatedVlanFormat_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_IntPriority_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIntPriority
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IntPriority_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_Color_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyColor
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      color - (OUT) Qualifier match color.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Color_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *color)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChannOuter_get
 * Purpose:
 *      Get Fibre Channel outer header type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (OUT) Fibre Channel header type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_FibreChanOuter_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_FibreChan_t *fibre_chan_type)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChannInner_get
 * Purpose:
 *      Get Fibre Channel inner header type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (OUT) Fibre Channel header type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_FibreChanInner_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_FibreChan_t *fibre_chan_type)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_VnTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyVnTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_VnTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *  bcm_esw_field_qualify_ETag_get
 * Purpose:
 *  Get match criteria for bcmFieldQualifyETag
 *  qualifier from the field entry.
 * Parameters:
 *  unit - (IN) Unit number.
 *  entry - (IN) BCM field entry id.
 *  data - (OUT) Qualifier match data.
 *  mask - (OUT) Qualifier match mask.
 * Returns:
 *  BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_ETag_get(int unit, bcm_field_entry_t entry,
                                      uint64 *data, uint64 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_SubportPktTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySubportPktTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SubportPktTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_CnTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyCnTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_CnTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_FabricQueueTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFabricQueueTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_FabricQueueTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcModPortGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcModPortGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcModPortGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *data)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_SrcModuleGport_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifySrcModuleGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_SrcModuleGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *data)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualifier_delete
 * Purpose:
 *      Remove match criteria from a field processor entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      qual_id - (IN) BCM field qualifier id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualifier_delete(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_qualify_t qual_id)
{
    return BCM_E_UNAVAIL; 
}


/* Function: bcm_esw_field_group_wlan_create_mode
 *     
 * Purpose:
 *     Create a wlan field group with a mode (single, double, etc.).
 *
 * Parameters:
 *     unit - BCM device number.
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - (OUT) field Group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_wlan_create_mode(int unit, bcm_field_qset_t qset, int pri,
                                     bcm_field_group_mode_t mode,
                                     bcm_field_group_t *group)
{
    return BCM_E_UNAVAIL; 
}

/* Function: bcm_esw_field_group_wlan_create_mode_id
 *     
 * Purpose:
 *     Create a wlan field group with a mode (single, double, etc.).
 *
 * Parameters:
 *     unit - BCM device number.
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - (OUT) field Group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_wlan_create_mode_id(int unit, bcm_field_qset_t qset, int pri,
                                        bcm_field_group_mode_t mode,
                                        bcm_field_group_t group)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlanId
 * Purpose:
 *       Set match criteria for bcmFieildQualifyOuterVlanId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    return BCM_E_UNAVAIL; 
}


/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlanPri
 * Purpose:
 *       Set match criteria for bcmFieildQualifyOuterVlanPri
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL; 
}


/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlanCfi
 * Purpose:
 *       Set match criteria for bcmFieildQualifyOuterVlanCfi
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlanId
 * Purpose:
 *       Set match criteria for bcmFieildQualifyInnerVlanId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    return BCM_E_UNAVAIL; 
}


/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlanPri
 * Purpose:
 *       Set match criteria for bcmFieildQualifyInnerVlanPri
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlanCfi
 * Purpose:
 *       Set match criteria for bcmFieildQualifyInnerVlanCfi
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyOuterVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL; 
}


/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlanPri_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyOuterVlanPri
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_OuterVlanCfi_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyOuterVlanCfi_get
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OuterVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyInnerVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL; 
}


/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlanPri_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyInnerVlanPri
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_InnerVlanCfi_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyInnerVlanCfi_get
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InnerVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstHiGig
 * Purpose:
 *      Qualify on HiGig destination packets.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstHiGig(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_DstHiGig_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstHiGig
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_DstHiGig_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_ForwardingVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyForwardingVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ForwardingVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_Vpn_get
 * Purpose:
 *       Get match criteria for bcmFieildQualifyVpn
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Vpn_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vpn_t *data, 
    bcm_vpn_t *mask)
{
    return BCM_E_UNAVAIL; 
}


/*
 * Function:
 *      bcm_esw_field_qualify_ForwardingVlanId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyForwardingVlanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_ForwardingVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    return BCM_E_UNAVAIL; 
}


/*
 * Function:
 *      bcm_esw_field_qualify_Vpn
 * Purpose:
 *      Set match criteria for bcmFieildQualifyVpn
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_Vpn(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vpn_t data, 
    bcm_vpn_t mask)
{
    return BCM_E_UNAVAIL; 
}
/*
 * Function:
 *      bcm_esw_field_qualify_FlowId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFlowId
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int 
bcm_esw_field_qualify_FlowId(int unit, bcm_field_entry_t entry,
                 uint16 data, uint16 mask)
{
    return BCM_E_UNAVAIL; 
}
/*
 * Function:
 *      bcm_esw_field_qualify_InVPort
 * Purpose:
 *      Set match criteria for bcmFieildQualifyInVPort
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int 
bcm_esw_field_qualify_InVPort(int unit, bcm_field_entry_t entry,
                 uint8 data, uint8 mask)
{
    return BCM_E_UNAVAIL; 
}
/*
 * Function:
 *      bcm_esw_field_qualify_OutVPort
 * Purpose:
 *      Set match criteria for bcmFieildQualifyOutVPort
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int 
bcm_esw_field_qualify_OutVPort(int unit, bcm_field_entry_t entry,
                 uint8 data, uint8 mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_FlowId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFlowId
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_FlowId_get(int unit, bcm_field_entry_t entry,
                 uint16 *data, uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_InVPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyInVPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_InVPort_get(int unit, bcm_field_entry_t entry,
                 uint8 *data, uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OutVPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyOutVPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_OutVPort_get(int unit, bcm_field_entry_t entry,
                 uint8 *data, uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IntCongestionNotification
 * Purpose:
 *      Set match criteria for IntCongestionNotification
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int 
bcm_esw_field_qualify_IntCongestionNotification(int unit, 
    bcm_field_entry_t entry, uint8 data, uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IntCongestionNotification_get
 * Purpose:
 *      Get match criteria for IntCongestionNotification
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int 
bcm_esw_field_qualify_IntCongestionNotification_get(int unit, 
    bcm_field_entry_t entry, uint8 *data, uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_action_class_add
 * Purpose:
 *      Add an action to a field class entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry Id.
 *      class_info - (IN) Field Class Info.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_action_class_add(
        int unit,
        bcm_field_entry_t entry,
        bcm_field_class_info_t *class_info)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_action_class_get
 * Purpose:
 *      Retrieve the parameters for an action previously added to a
 *      field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry Id.
 *      class_info - (INOUT) Field Class Info.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_action_class_get(
        int unit,
        bcm_field_entry_t entry,
        bcm_field_class_info_t *class_info)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_action_mac_add
 * Purpose:
 *      Add an action to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry Id.
 *      action - (IN) Field action id.
 *      mac - (IN) Field action parameter.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_action_mac_add(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    bcm_mac_t mac)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_action_mac_get
 * Purpose:
 *      Retrieve the parameters for an action previously added to a
 *      field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry Id.
 *      action - (IN) Field action id.
 *      mac - (IN) Field action argument.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_action_mac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    bcm_mac_t *mac)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_group_traverse
 * Purpose:
 *      Traverse all the fp groups in the system, calling a specified
 *      callback for each one
 * Parameters:
 *      unit - (IN) Unit number.
 *      callback - (IN) A pointer to the callback function to call for each fp group
 *      user_data - (IN) Pointer to user data to supply in the callback
 * Returns:
 *      BCM_E_xxx
 * Notes:
 */
int 
bcm_esw_field_group_traverse(int unit, bcm_field_group_traverse_cb callback,
                             void *user_data)
{
    return BCM_E_UNAVAIL; 
}

/* Function: bcm_esw_field_group_config_create
 *
 * Purpose:
 *     Create a group with a mode (single, double, etc.), a port bitmap,
 *     group size and a Group ID. 
 * Parameters:
 *     unit - BCM device number.
 *     group_config - Group create attributes namely:
 *          flags       - (IN) Bits indicate which parameters have been
 *                             passed to API and should be used during group
 *                             creation.
 *          qset        - (IN) Field qualifier set
 *          priority    - (IN) Priority within allowable range,
 *                             or BCM_FIELD_GROUP_PRIO_ANY to automatically
 *                             assign a priority; each priority value may be
 *                             used only once
 *          mode        - (IN) Group mode (single, double, triple or Auto-wide)
 *          ports       - (IN) Ports where group is defined
 *          group       - (IN/OUT) Requested Group ID. If Group ID is not set,
 *                              then API allocates and returns the created
 *                              Group ID.
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_esw_field_group_config_create(int unit,
                                  bcm_field_group_config_t *group_config)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_CpuQueue
 * Purpose:
 *      Get match criteria for bcmFieldQualifyCpuQueue 
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) CPU COS queue value.
 *      mask    - (IN) CPU COS match mask value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_CpuQueue(int unit,
                               bcm_field_entry_t entry,
                               uint8 data,
                               uint8 mask)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *      bcm_esw_field_qualify_CpuQueue_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyCpuQueue
 *      qualifier from the field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (OUT) CPU COS Queue matched value.
 *      mask  - (OUT) CPU COS Queue matched mask value.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_CpuQueue_get(int unit,
                                   bcm_field_entry_t entry,
                                   uint8 *data,
                                   uint8 *mask)
{
    return BCM_E_UNAVAIL; 
}

/* 
 * Set match criteria for RecoverableDrop
 *                qualifier.
 */
int bcm_esw_field_qualify_RecoverableDrop(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for RecoverableDrop
 *                qualifier.
 */
int bcm_esw_field_qualify_RecoverableDrop_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for RepCopy
 *                qualifier.
 */
int bcm_esw_field_qualify_RepCopy(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for RepCopy
 *                qualifier.
 */
int bcm_esw_field_qualify_RepCopy_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for IpTunnelHit
 *                qualifier.
 */
int bcm_esw_field_qualify_IpTunnelHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for IpTunnelHit
 *                qualifier.
 */
int bcm_esw_field_qualify_IpTunnelHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for MplsLabel1Hit
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsLabel1Hit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for MplsLabel1Hit
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsLabel1Hit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for TrillEgressRbridgeHit
 *                qualifier.
 */
int bcm_esw_field_qualify_TrillEgressRbridgeHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for TrillEgressRbridgeHit
 *                qualifier.
 */
int bcm_esw_field_qualify_TrillEgressRbridgeHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for L2GreSrcIpHit
 *                qualifier.
 */
int bcm_esw_field_qualify_L2GreSrcIpHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for L2GreSrcIpHit
 *                qualifier.
 */
int bcm_esw_field_qualify_L2GreSrcIpHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for MimSrcGportHit
 *                qualifier.
 */
int bcm_esw_field_qualify_MimSrcGportHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for MimSrcGportHit
 *                qualifier.
 */
int bcm_esw_field_qualify_MimSrcGportHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for MplsLabel2Hit
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsLabel2Hit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for MplsLabel2Hit
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsLabel2Hit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for TrillIngressRbridgeHit
 *                qualifier.
 */
int bcm_esw_field_qualify_TrillIngressRbridgeHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for TrillIngressRbridgeHit
 *                qualifier.
 */
int bcm_esw_field_qualify_TrillIngressRbridgeHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for L2GreVfiHit
 *                qualifier.
 */
int bcm_esw_field_qualify_L2GreVfiHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for L2GreVfiHit
 *                qualifier.
 */
int bcm_esw_field_qualify_L2GreVfiHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for MimVfiHit
 *                qualifier.
 */
int bcm_esw_field_qualify_MimVfiHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for MimVfiHit
 *                qualifier.
 */
int bcm_esw_field_qualify_MimVfiHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for GenericAssociatedChannelLabelValid
 *                qualifier.
 */
int bcm_esw_field_qualify_GenericAssociatedChannelLabelValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for GenericAssociatedChannelLabelValid
 *                qualifier.
 */
int bcm_esw_field_qualify_GenericAssociatedChannelLabelValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for RouterAlertLabelValid
 *                qualifier.
 */
int bcm_esw_field_qualify_RouterAlertLabelValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for RouterAlertLabelValid
 *                qualifier.
 */
int bcm_esw_field_qualify_RouterAlertLabelValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for DspIpLocal
 *                qualifier.
 */
int bcm_esw_field_qualify_DstIpLocal(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for DspIpLocal
 *                qualifier.
 */
int bcm_esw_field_qualify_DstIpLocal_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for IpAddrsNormalized
 *                qualifier.
 */
int bcm_esw_field_qualify_IpAddrsNormalized(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for IpAddrsNormalized
 *                qualifier.
 */
int bcm_esw_field_qualify_IpAddrsNormalized_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for MacAddrsNormalized
 *                qualifier.
 */
int bcm_esw_field_qualify_MacAddrsNormalized(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for MacAddrsNormalized
 *                qualifier.
 */
int bcm_esw_field_qualify_MacAddrsNormalized_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for MplsForwardingLabel
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsForwardingLabel(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for MplsForwardingLabel
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsForwardingLabel_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for MplsForwardingLabelTtl
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsForwardingLabelTtl(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for MplsForwardingLabelTtl
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsForwardingLabelTtl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for MplsForwardingLabelBos
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsForwardingLabelBos(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for MplsForwardingLabelBos
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsForwardingLabelBos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for MplsForwardingLabelExp
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsForwardingLabelExp(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for MplsForwardingLabelExp
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsForwardingLabelExp_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for MplsForwardingLabelId
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsForwardingLabelId(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for MplsForwardingLabelId
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsForwardingLabelId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for MplsControlWord
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsControlWord(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for MplsControlWord
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsControlWord_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for Rtag7AHashUpper
 *                qualifier.
 */
int bcm_esw_field_qualify_Rtag7AHashUpper(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for Rtag7AHashUpper
 *                qualifier.
 */
int bcm_esw_field_qualify_Rtag7AHashUpper_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for Rtag7AHashLower
 *                qualifier.
 */
int bcm_esw_field_qualify_Rtag7AHashLower(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for Rtag7AHashLower
 *                qualifier.
 */
int bcm_esw_field_qualify_Rtag7AHashLower_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for Rtag7BHashUpper
 *                qualifier.
 */
int bcm_esw_field_qualify_Rtag7BHashUpper(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for Rtag7BHashUpper
 *                qualifier.
 */
int bcm_esw_field_qualify_Rtag7BHashUpper_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for Rtag7BHashLower
 *                qualifier.
 */
int bcm_esw_field_qualify_Rtag7BHashLower(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for Rtag7BHashLower
 *                qualifier.
 */
int bcm_esw_field_qualify_Rtag7BHashLower_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for MplsForwardingLabelAction
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsForwardingLabelAction(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for MplsForwardingLabelAction
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsForwardingLabelAction_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for MplsControlWordValid
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsControlWordValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for MplsControlWordValid
 *                qualifier.
 */
int bcm_esw_field_qualify_MplsControlWordValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for EgressClass
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClass(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for EgressClass
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClass_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for EgressClassL3Interface
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassL3Interface(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for EgressClassL3Interface
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassL3Interface_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for EgressClassTrill
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassTrill(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for EgressClassTrill
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassTrill_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for EgressClassWlan
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassWlan(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for EgressClassWlan
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassWlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Set match criteria for EgressClassL2Gre
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassL2Gre(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for EgressClassL2Gre
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassL2Gre_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_SrcGport
 * Purpose:
 *     Add Source ModPort or MPLS/MiM/WLAN port qualification to a
 *     field entry.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field Entry id.
 *     port_id  - (IN) Source Generic Logical port or virtual port id.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_qualify_SrcGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t mpls_port_id)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *     bcm_esw_field_qualify_SrcGport_get
 * Purpose:
 *     Get Source ModPort or MPLS/MiM/WLAN gport value from a
 *     field entry.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field Entry id.
 *     port_id  - (OUT) ModPort Gport or MPLS/MiM/WLAN Gport ID.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_qualify_SrcGport_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_gport_t *port_id)
{
    return BCM_E_UNAVAIL; 
}


/*
 * Function:
 *     bcm_esw_field_qualify_DstGport
 * Purpose:
 *     Add Destination Niv port qualification to a
 *     field entry.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field Entry id.
 *     port_id  - (IN) Destination virtual port id.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_qualify_DstGport(int unit, 
                               bcm_field_entry_t entry, 
                               bcm_gport_t port_id)
{
    return BCM_E_UNAVAIL; 
}

/*
 * Function:
 *     bcm_esw_field_qualify_DstGport_get
 * Purpose:
 *     Get Destination NIV  gport value from a
 *     field entry.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field Entry id.
 *     port_id  - (OUT) Niv Gport ID.
 * Returns:
 *      BCM_E_XXX
 */
int 
bcm_esw_field_qualify_DstGport_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_gport_t *port_id)
{
    return BCM_E_UNAVAIL; 
}


/*
 * Function:
 *      bcm_esw_field_qualify_MplsOuterLabelPop
 * Purpose:
 *      Set match criteria for bcmFieildQualifyMplsOuterLabelPop
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MplsOuterLabelPop(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_MplsStationHitTunnelUnterminated
 * Purpose:
 *      Set match criteria for bcmFieildQualifyMplsStationHitTunnelUnterminated
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MplsStationHitTunnelUnterminated(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_MplsOuterLabelPop_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMplsOuterLabelPop
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MplsOuterLabelPop_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_MplsStationHitTunnelUnterminated_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyMplsStationHitTunnelUnterminated
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_MplsStationHitTunnelUnterminated_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressClassField
 * Purpose:
 *      Set match criteria for bcmFieildQualifyIngressClassField
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressClassField(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressClassField_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIngressClassField
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressClassField_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressInterfaceClassPort
 * Purpose:
 *      Set match criteria for bcmFieildQualifyIngressInterfaceClassPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IngressInterfaceClassPort(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) 
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressInterfaceClassPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIngressInterfaceClassPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressInterfaceClassPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanFlags
 * Purpose:
 *      Set match criteria for bcmFieildQualifyVxlanFlags
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanFlags(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanFlags_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVxlanFlags
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanFlags_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanNetworkId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyVxlanNetworkId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanNetworkId(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_VxlanNetworkId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyVxlanNetworkId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_VxlanNetworkId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_NatNeeded
 * Purpose:
 *      Set match criteria for bcmFieildQualifyNatNeeded
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_NatNeeded(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_NatNeeded_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyNatNeeded
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_NatNeeded_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_NatDstRealmId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyNatDstRealmId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_NatDstRealmId(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_NatDstRealmId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyNatDstRealmId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_NatDstRealmId_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_NatSrcRealmId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyNatSrcRealmId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_NatSrcRealmId(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_NatSrcRealmId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyNatSrcRealmId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_NatSrcRealmId_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IcmpError
 * Purpose:
 *      Set match criteria for bcmFieildQualifyIcmpError
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IcmpError(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IcmpError_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIcmpError
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IcmpError_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanRCtl
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanRCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanRCtl(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanRCtl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanRCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanRCtl_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanFCtl
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanFCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanFCtl(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanFCtl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanFCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanFCtl_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanCSCtl
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanCSCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanCSCtl(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanCSCtl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanCSCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanCSCtl_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDFCtl
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanDFCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDFCtl(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDFCtl_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanDFCtl
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDFCtl_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanType
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanType(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanType_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanSrcId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcId(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanSrcId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDstId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanDstId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDstId(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanDstId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanDstId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanDstId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanZoneCheck
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanZoneCheck
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanZoneCheck(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanZoneCheck_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanZoneCheck
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanZoneCheck_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcFpmaCheck
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanSrcFpmaCheck
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcFpmaCheck(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcFpmaCheck_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanSrcFpmaCheck
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcFpmaCheck_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcBindCheck
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanSrcBindCheck
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcBindCheck(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanSrcBindCheck_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanSrcBindCheck
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanSrcBindCheck_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTVersion
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTVersion
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTVersion(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTVersion_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTVersion
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTVersion_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTPri
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTPri
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTPri(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTPri_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTPri
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTPri_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTFabricId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTFabricId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTFabricId(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTFabricId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTFabricId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTFabricId_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTHopCount
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTHopCount
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTHopCount(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTHopCount_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTHopCount
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTHopCount_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTVsanId
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTVsanId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTVsanId(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTVsanId_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTVsanId
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTVsanId_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTVsanPri
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTVsanPri
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTVsanPri(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTVsanPri_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTVsanPri
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTVsanPri_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTValid
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFibreChanVFTValid
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTValid(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FibreChanVFTValid_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFibreChanVFTValid
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FibreChanVFTValid_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeSOF
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFcoeSOF
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeSOF(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeSOF_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFcoeSOF
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeSOF_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeVersionIsZero
 * Purpose:
 *      Set match criteria for bcmFieildQualifyFcoeVersionIsZero
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeVersionIsZero(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_FcoeVersionIsZero_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyFcoeVersionIsZero
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_FcoeVersionIsZero_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL ;
}

/*
 * Function:
 *     bcm_esw_field_entry_operation
 * Purpose:
 *     Perform entry backup, restore and backup copy free operations
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     entry_oper - (IN) Pointer to field entry operation structure
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_esw_field_entry_operation(int unit, bcm_field_entry_oper_t *entry_oper)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_OamMdl(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
}

int
bcm_esw_field_qualify_OamMdl_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status.      */
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressInterfaceClassVPort
 * Purpose:
 *      Set match criteria for bcmFieildQualifyIngressInterfaceClassVPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_esw_field_qualify_IngressInterfaceClassVPort(
    int unit, 
    bcm_field_entry_t entry,  
    uint32 data, 
    uint32 mask) 
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_IngressInterfaceClassVPort_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyIngressInterfaceClassVPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number. 
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_IngressInterfaceClassVPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}



/* bcm_esw_field_qualify_SrcVlanGports */
int bcm_esw_field_qualify_SrcVlanGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t vlan_port_id,
    bcm_gport_t vlan_port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_DstVlanGports */
int bcm_esw_field_qualify_DstVlanGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t vlan_port_id,
    bcm_gport_t vlan_port_mask)
{
    return BCM_E_UNAVAIL;
}
/*
 * Get match criteria for bcmFieldQualifySrcVlanGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_SrcVlanGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *vlan_port_id,
    bcm_gport_t *vlan_port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifyDstVlanGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_DstVlanGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *vlan_port_id,
    bcm_gport_t *vlan_port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_SrcVxlanGports */
int bcm_esw_field_qualify_SrcVxlanGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t vxlan_port_id,
    bcm_gport_t vxlan_port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_DstVxlanGports */
int bcm_esw_field_qualify_DstVxlanGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t vxlan_port_id,
    bcm_gport_t vxlan_port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifySrcVxlanGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_SrcVxlanGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *vxlan_port_id,
    bcm_gport_t *vxlan_port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifyDstVxlanGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_DstVxlanGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *vxlan_port_id,
    bcm_gport_t *vxlan_port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_SrcWlanGports */
int bcm_esw_field_qualify_SrcWlanGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t wlan_port_id,
    bcm_gport_t wlan_port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_DstWlanGports */
int bcm_esw_field_qualify_DstWlanGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t wlan_port_id,
    bcm_gport_t wlan_port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifySrcWlanGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_SrcWlanGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *wlan_port_id,
    bcm_gport_t *wlan_port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifyDstWlanGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_DstWlanGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *wlan_port_id,
    bcm_gport_t *wlan_port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_SrcMplsGports */
int bcm_esw_field_qualify_SrcMplsGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t mpls_port_id,
    bcm_gport_t mpls_port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_DstMplsGports */
int bcm_esw_field_qualify_DstMplsGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t mpls_port_id,
    bcm_gport_t mpls_port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifySrcMplsGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_SrcMplsGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mpls_port_id,
    bcm_gport_t *mpls_port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifyDstMplsGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_DstMplsGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mpls_port_id,
    bcm_gport_t *mpls_port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_SrcGports */
int bcm_esw_field_qualify_SrcGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t port_id,
    bcm_gport_t port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_DstGports */
int bcm_esw_field_qualify_DstGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t port_id,
    bcm_gport_t port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifySrcGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_SrcGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *port_id,
    bcm_gport_t *port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifyDstGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_DstGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *port_id,
    bcm_gport_t *port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_SrcMimGports */
int bcm_esw_field_qualify_SrcMimGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t mim_port_id,
    bcm_gport_t mim_port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_DstMimGports */
int bcm_esw_field_qualify_DstMimGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t mim_port_id,
    bcm_gport_t mim_port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifySrcMimGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_SrcMimGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mim_port_id,
    bcm_gport_t *mim_port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifyDstMimGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_DstMimGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mim_port_id,
    bcm_gport_t *mim_port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_SrcNivGports */
int bcm_esw_field_qualify_SrcNivGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t niv_port_id,
    bcm_gport_t niv_port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_DstNivGports */
int bcm_esw_field_qualify_DstNivGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t niv_port_id,
    bcm_gport_t niv_port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifySrcNivGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_SrcNivGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *niv_port_id,
    bcm_gport_t *niv_port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifyDstNivGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_DstNivGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *niv_port_id,
    bcm_gport_t *niv_port_mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_esw_field_qualify_SrcModPortGports */
int bcm_esw_field_qualify_SrcModPortGports(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t port_id,
    bcm_gport_t port_mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifySrcModPortGports
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_SrcModPortGports_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *port_id,
    bcm_gport_t *port_mask)
{
    return BCM_E_UNAVAIL;
}

/* Qualify Reserved_1 field in Vxlan Header */
int bcm_esw_field_qualify_VxlanHeaderBits8_31(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/* Get match criteria for Reserved_1 field in Vxlan Header */
int bcm_esw_field_qualify_VxlanHeaderBits8_31_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/* Qualify Reserved_2 field in Vxlan Header */
int bcm_esw_field_qualify_VxlanHeaderBits56_63(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* Get match criteria for Reserved_2 field in Vxlan Header */
int bcm_esw_field_qualify_VxlanHeaderBits56_63_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* Create a hint id. */
int bcm_esw_field_hints_create(int unit,
                           bcm_field_hintid_t *hint_id)
{
    return BCM_E_UNAVAIL;
}

/* Add bcm_field_hint_t structure to a hint_id */
int bcm_esw_field_hints_add(int unit,
                        bcm_field_hintid_t hint_id,
                        bcm_field_hint_t *hint)
{
    return BCM_E_UNAVAIL;
}

/* Delete bcm_field_hint_t structure from a hint_id */
int bcm_esw_field_hints_delete(int unit,
                           bcm_field_hintid_t hint_id,
                           bcm_field_hint_t *hint)
{
    return BCM_E_UNAVAIL;
}

/* Delete all the bcm_field_hint_t structures from a hint_id */
int bcm_esw_field_hints_delete_all(int unit,
                               bcm_field_hintid_t hint_id)
{
    return BCM_E_UNAVAIL;
}

/* Delete bcm_field_hint_t structure from a hint_id */
int bcm_esw_field_hints_get(int unit,
                        bcm_field_hintid_t hint_id,
                        bcm_field_hint_t *hint)
{
    return BCM_E_UNAVAIL;
}

/* Delete all the bcm_field_hint_t structures from a hint_id */
int bcm_esw_field_hints_destroy(int unit,
                            bcm_field_hintid_t hint_id)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamType
 * Purpose:
 *      Set match criteria for bcmFieildQualifyOamType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifier match data.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_type_t oam_type)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */
    return(rv);
}

/*
 * Function:
 *      bcm_esw_field_qualify_OamType_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyOamType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (OUT) Qualifier match data.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_type_t *oam_type)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */
    return(rv);
}



/*
 * Function:
 *     bcm_esw_field_qualify_OamHeaderBits0_31
 * Purpose:
 *      Set match criteria for bcmFieldQualifyOamHeaderBits0_31
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on First 4 Bytes of OAM Header
                       in Egress Pipeline.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamHeaderBits0_31(
    int unit, bcm_field_entry_t entry,
    uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}


/*
 * Function:
 *     bcm_esw_field_qualify_OamHeaderBits0_31_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamHeaderBits0_31
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) First 4 Bytes of OAM Header
                        in Egress Pipeline.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_OamHeaderBits0_31_get(
    int unit, bcm_field_entry_t entry, uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}


/*
 * Function:
 *     bcm_esw_field_qualify_OamHeaderBits32_63
 * Purpose:
 *      Set match criteria for bcmFieldQualifyOamHeaderBits32_63
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Second 4 Bytes of OAM Header
                       in Egress Pipeline.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_OamHeaderBits32_63(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_OamHeaderBits32_63_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamHeaderBits32_63
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Second 4 Bytes of OAM Header
                        in Egress Pipeline.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_OamHeaderBits32_63_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_OamEgressClassPort
 * Purpose:
 *      Set match criteria for bcmFieldQualifyOamEgressClassPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualify the OAM ClassId obtained from EGR_PORT table
                       in Egress Pipeline.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_OamEgressClassPort(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_OamEgressClassPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamEgressClassPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) OAM ClassId obtained from EGR_PORT table
                        in Egress Pipeline.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_OamEgressClassPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_OamEgressClassVxlt
 * Purpose:
 *      Set match criteria for bcmFieldQualifyOamEgressClassVxlt
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualify the OAM ClassId obtained from Vlan_Xlate table
                       in Egress Pipeline.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_OamEgressClassVxlt(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}
/*
 * Function:
 *     bcm_esw_field_qualify_OamEgressClassVxlt_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamEgressClassVxlt
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) OAM ClassId obtained from Vlan_Xlate table
                        in Egress Pipeline.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_OamEgressClassVxlt_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *    bcm_esw_field_qualify_EthernetOamHeaderBits0_31
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamHeaderBits0_31
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on First 4 Bytes of Ethernet OAM Header.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamHeaderBits0_31(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamHeaderBits0_31_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamHeaderBits0_31
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) First 4 Bytes of Ethernet OAM Header.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamHeaderBits0_31_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamHeaderBits32_63
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamHeaderBits32_63
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Second 4 Bytes of Ethernet OAM Header.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_EthernetOamHeaderBits32_63(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}
/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamHeaderBits32_63_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamHeaderBit32_63
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Second 4 Bytes of Ethernet OAM Header.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_EthernetOamHeaderBits32_63_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}
/*
 * Function:
 *     bcm_esw_field_qualifyEthernetOamDstClassL2
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamDstClassL2
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
                       DstMac lookup in L2 table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamDstClassL2(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamDstClassL2_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamDstClassL2
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from DstMac lookup in L2 table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamDstClassL2_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamTxPktUPMEP
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamTxPktUPMEP
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Ethernet OAM UP-MEP Tx Pkt.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamTxPktUPMEP(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamTxPktUPMEP_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamTxPktUPMEP
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Ethernet OAM UP-MEP Tx Pkt.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamTxPktUPMEP_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualifyEthernetOamInterfaceClassPort
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamInterfaceClassPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
                       Source trunk map table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassPort(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamInterfaceClassPort
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from Source trunk map table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeyFirst
 * Purpose:
 *      Set match criteria for
                     bcmFieldQualifyEthernetOamClassVlanTranslateKeyFirst
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
                       1st Lookup of Vlan_Xlate table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeyFirst(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeyFirst_get
 * Purpose:
 *      Get match criteria for
                  bcmFieldQualifyEthernetOamClassVlanTranslateKeyFirst
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from 1st Lookup of Vlan_Xlate table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeyFirst_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeySecond
 * Purpose:
 *      Set match criteria for
                   bcmFieldQualifyEthernetOamClassVlanTranslateKeySecond
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
                       2nd Lookup of Vlan_Xlate table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeySecond(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeySecond_get
 * Purpose:
 *      Get match criteria for
                  bcmFieldQualifyEthernetOamClassVlanTranslateKeySecond
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from 2nd Lookup of Vlan_Xlate table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamClassVlanTranslateKeySecond_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassVlan
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamInterfaceClassVlan
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
 SVP table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassVlan(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;   /* Operation return status. */
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassVlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamInterfaceClassVlan
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from SVP table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassVlan_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassVxlan
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamInterfaceClassVxlan
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
                       SVP table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassVxlan(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassVxlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamInterfaceClassVxlan
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from SVP table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassVxlan_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassMim
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamInterfaceClassMim
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
 SVP table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassMim(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;   /* Operation return status. */
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassMim_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamInterfaceClassMim
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from SVP table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassMim_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassNiv
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamInterfaceClassNiv
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
 SVP table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassNiv(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;   /* Operation return status. */
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassNiv_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamInterfaceClassNiv
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from SVP table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassNiv_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassMpls
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamInterfaceClassMpls
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
 SVP table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassMpls(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;   /* Operation return status. */
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamInterfaceClassMpls_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamInterfaceClassMpls
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from SVP table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamInterfaceClassMpls_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */
    return (rv);
}


/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamClassVpn
 * Purpose:
 *      Set match criteria for bcmFieldQualifyEthernetOamClassVpn
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
                       VFI table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_EthernetOamClassVpn(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_EthernetOamClassVpn_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEthernetOamClassVpn
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from VFI table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_EthernetOamClassVpn_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *    bcm_esw_field_qualify_MplsOamHeaderBits0_31
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamHeaderBits0_31
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on First 4 Bytes of MPLS OAM Header.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamHeaderBits0_31(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamHeaderBits0_31_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamHeaderBits0_31
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) First 4 Bytes of MPLS OAM Header.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamHeaderBits0_31_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}


/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamHeaderBits32_63
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamHeaderBits32_63
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Second 4 Bytes of MPLS OAM Header.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamHeaderBits32_63(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamHeaderBits32_63_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOamHeaderBits32_63
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Second 4 Bytes of MPLS OAM Header.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamHeaderBits32_63_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *    bcm_esw_field_qualify_MplsOamGALLabelOnly
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamGALLabelOnly
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies MPLS OAM packets with
                       single label only that is GAL label.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamGALLabelOnly(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamGALLabelOnly_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamGALLabelOnly
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) MPLS OAM packets with
                        single label only that is GAL label.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamGALLabelOnly_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *    bcm_esw_field_qualify_MplsOamGALExposed
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamGALExposed
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies MPLS OAM packets which has GAL Exposed.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamGALExposed(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamGALExposed_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamGALExposed
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) MPLS OAM packets which has GAL Exposed.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamGALExposed_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *    bcm_esw_field_qualify_MplsOamUpperLabelDataDrop 
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamUpperLabelDataDrop
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from
 SVP table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamUpperLabelDataDrop(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    int rv = BCM_E_UNAVAIL;   /* Operation return status. */
    return (rv);
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamUpperLabelDataDrop_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamUpperLabelDataDrop
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from SVP table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamUpperLabelDataDrop_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    int rv = BCM_E_UNAVAIL;  /* Operation return status. */
    return (rv);
}

/*
 * Function:
 *    bcm_esw_field_qualify_MplsOamACH
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamACH
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies MPLS OAM ACH Header.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamACH(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamACH_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamACH
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) MPLS OAM ACH Header.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamACH_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *    bcm_esw_field_qualify_MplsOamControlPktType
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamControlPktType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualify the MPLS OAM Control Packets
                       based on packet type.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamControlPktType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_MplsOam_Control_pktType_t data)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamControlPktType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamControlPktType
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) MPLS OAM Control Packets based on packet type.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int bcm_esw_field_qualify_MplsOamControlPktType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_MplsOam_Control_pktType_t *data)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamClassMplsSwitchLabel
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMplsOamClassMplsSwitchLabel
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN) Unit number.
 *      entry   - (IN) BCM field entry id.
 *      data    - (IN) Qualifies on Class Id obtained from 
                       MPLS_ENTRY table.
 *      mask    - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamClassMplsSwitchLabel(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_esw_field_qualify_MplsOamClassMplsSwitchLabel_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMplsOamClassMplsSwitchLabel
 *      qualifier from the field entry.
 * Parameters:
 *      unit    - (IN)  Unit number.
 *      entry   - (IN)  BCM field entry id.
 *      data    - (OUT) Class Id obtained from MPLS_ENTRY table.
 *      mask    - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_esw_field_qualify_MplsOamClassMplsSwitchLabel_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}


int 
bcm_esw_field_group_presel_get(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_presel_set_t *presel)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_group_presel_set(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_presel_set_t *presel)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_presel_create(
    int unit, 
    bcm_field_presel_t *presel_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_presel_create_id(
    int unit, 
    bcm_field_presel_t presel_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_presel_destroy(
    int unit, 
    bcm_field_presel_t presel_id)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DstMulticastGroups(
    int unit,
    bcm_field_entry_t entry,
    bcm_multicast_t group,
    bcm_multicast_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DstMulticastGroups_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_multicast_t *group,
    bcm_multicast_t *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Field Operation Mode Set
 */
int
bcm_esw_field_group_oper_mode_set(
    int unit,
    bcm_field_qualify_t stage,
    bcm_field_group_oper_mode_t mode)
{
    return BCM_E_UNAVAIL;
}

/*
 * Field Operation Mode Get
 */ 
int
bcm_esw_field_group_oper_mode_get(
    int unit,
    bcm_field_qualify_t stage,
    bcm_field_group_oper_mode_t *mode)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_DestVirtualPortValid(int unit,
                                           bcm_field_entry_t entry,
                                           uint8 data,
                                           uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int 
bcm_esw_field_qualify_DestVirtualPortValid_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 *data,
                                               uint8 *mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_FcoeOxID(int unit, bcm_field_entry_t entry,
        uint16 data, uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FcoeOxID_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FcoeRxID(int unit, bcm_field_entry_t entry,
        uint16 data, uint16 mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FcoeRxID_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_IpProtocolClass(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_IpProtocolClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_EtherTypeClass(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_EtherTypeClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_L4SrcPortClass(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_L4SrcPortClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_L4DstPortClass(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_L4DstPortClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIpClass(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIpClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIpClassMsbNibble(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIpClassMsbNibble_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIpClassLower(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIpClassLower_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIpClassUpper(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIpClassUpper_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIp6Class(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIp6Class_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIp6ClassMsbNibble(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIp6ClassMsbNibble_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIp6ClassLower(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIp6ClassLower_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIp6ClassUpper(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_SrcIp6ClassUpper_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FcoeOxIDClass(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FcoeOxIDClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIpClass(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIpClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIpClassMsbNibble(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIpClassMsbNibble_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIpClassLower(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIpClassLower_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIpClassUpper(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIpClassUpper_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIp6Class(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIp6Class_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIp6ClassMsbNibble(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIp6ClassMsbNibble_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIp6ClassLower(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIp6ClassLower_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIp6ClassUpper(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_DstIp6ClassUpper_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FcoeRxIDClass(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FcoeRxIDClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanSrcIdClass(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanSrcIdClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanSrcIdClassMsbNibble(int unit, 
        bcm_field_entry_t entry, bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanSrcIdClassMsbNibble_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanSrcIdClassLower(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanSrcIdClassLower_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanSrcIdClassUpper(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanSrcIdClassUpper_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanDstIdClass(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanDstIdClass_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanDstIdClassMsbNibble(int unit,
        bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanDstIdClassMsbNibble_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanDstIdClassLower(int unit,
        bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanDstIdClassLower_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanDstIdClassUpper(int unit, 
        bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_FibreChanDstIdClassUpper_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_TcpClassZero(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_TcpClassZero_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_TosClassZero(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_TosClassZero_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_TtlClassZero(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_TtlClassZero_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_TcpClassOne(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_TcpClassOne_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_TosClassOne(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_TosClassOne_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_TtlClassOne(int unit, bcm_field_entry_t entry,
        bcm_class_t data, bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

    int
bcm_esw_field_qualify_TtlClassOne_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_Stage(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_stage_t data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_Stage_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_stage_t *data)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IpFragNonOrFirst(
    int unit, bcm_field_entry_t entry,
    uint8 data, uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IpFragNonOrFirst_get(
    int unit, bcm_field_entry_t entry,
    uint8 *data, uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_PacketLength(
    int unit, bcm_field_entry_t entry,
    uint16 data, uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_PacketLength_get(
    int unit, bcm_field_entry_t entry,
    uint16 *data, uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GroupClass(
    int unit, bcm_field_entry_t entry,
    uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GroupClass_get(
    int unit, bcm_field_entry_t entry,
    uint32 *data, uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_UdfClass(
    int unit, bcm_field_entry_t entry,
    uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_UdfClass_get(
    int unit, bcm_field_entry_t entry,
    uint32 *data, uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InterfaceLookupClassPort(
    int unit, bcm_field_entry_t entry,
    uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InterfaceLookupClassPort_get(
    int unit, bcm_field_entry_t entry,
    uint32 *data, uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_ExactMatchHitStatus(int unit,
                                              bcm_field_entry_t entry,
                                              int group_pri,
                                              uint8 data,
                                              uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_ExactMatchHitStatus_get(int unit,
                                                  bcm_field_entry_t entry,
                                                  int group_pri,
                                                  uint8 *data,
                                                  uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_ExactMatchActionClassId(int unit,
                                                  bcm_field_entry_t entry,
                                                  int group_pri,
                                                  uint32 data,
                                                  uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_ExactMatchActionClassId_get(int unit,
                                                      bcm_field_entry_t entry,
                                                      int group_pri,
                                                      uint32 *data,
                                                      uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_ExactMatchGroupClassId(int unit,
                                                 bcm_field_entry_t entry,
                                                 int group_pri,
                                                 bcm_field_group_t group)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_ExactMatchGroupClassId_get(int unit,
                                                      bcm_field_entry_t entry,
                                                      int group_pri,
                                                      bcm_field_group_t *group)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstMulticast(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstMulticast_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstMulticastGroupId(int unit,
        bcm_field_entry_t entry,
        bcm_multicast_t group, 
        bcm_multicast_t mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstMulticastGroupId_get(int unit,
        bcm_field_entry_t entry,
        bcm_multicast_t *group,
        bcm_multicast_t *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigTrafficClass(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigTrafficClass_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstModuleGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstModuleGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstPortGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstPortGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstModPortGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstModPortGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigSrcModuleGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigSrcModuleGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigSrcPortGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigSrcPortGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigSrcModPortGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigSrcModPortGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigLoadBalanceID(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigLoadBalanceID_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigColor(int unit,
        bcm_field_entry_t entry,
        uint8 color)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigColor_get(int unit,
        bcm_field_entry_t entry,
        uint8 *color)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigIntCongestionNotification(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigIntCongestionNotification_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigIngressTagged(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigIngressTagged_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstTrunk(int unit
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstTrunk_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstTrunkId(int unit,
        bcm_field_entry_t entry,
        bcm_trunk_t data,
        bcm_trunk_t mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstTrunkId_get(int unit,
        bcm_field_entry_t entry,
        bcm_trunk_t *data,
        bcm_trunk_t *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigIngressL3SwitchPkt(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigIngressL3SwitchPkt_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigLabel(int unit,
        bcm_field_entry_t entry,
        uint32 data,
        uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigLabel_get(int unit,
        bcm_field_entry_t entry,
        uint32 *data,
        uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigReplicationId(int unit,
        bcm_field_entry_t entry,
        uint32 data,
        uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigReplicationId_get(int unit,
        bcm_field_entry_t entry,
        uint32 *data,
        uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigVlan(int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigVlan_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigPortFilteringMode(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigPortFilteringMode_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigSrcTrunk(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigSrcTrunk_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigIngressClassificationTag(int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigIngressClassificationTag_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigEgressMcast(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigEgressMcast_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigVni(int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigVni_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigMulticastIndex(int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigMulticastIndex_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigVpReplicationId(int unit,
        bcm_field_entry_t entry,
        uint32 data,
        uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigVpReplicationId_get(int unit,
        bcm_field_entry_t entry,
        uint32 *data,
        uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigSrcGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigSrcGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigProtectionSwitchingStatus(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigProtectionSwitchingStatus_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigMirrorToVp(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigMirrorToVp_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstType(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDstType_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigSrcType(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigSrcType_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEngineClassificationTag(int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEngineClassificationTag_get(int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEnginePktPriNew(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEnginePktPriNew_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEngineDscpNew(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEngineDscpNew_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_LoopBackQueue(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_LoopBackQueue_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_LoopBackSrcGport(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_LoopBackSrcGport_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_PktIsVisible(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_PktIsVisible_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_LoopBackCpuMasqueradePktProfile(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_LoopBackCpuMasqueradePktProfile_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_LoopBackColor(int unit,
        bcm_field_entry_t entry,
        uint8 color)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_LoopBackColor_get(int unit,
        bcm_field_entry_t entry,
        uint8 *color)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_LoopBackTrafficClass(int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_LoopBackTrafficClass_get(int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_LoopBackPacketProcessingPort(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t port_id,
        bcm_gport_t port_mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_LoopBackPacketProcessingPort_get(int unit,
        bcm_field_entry_t entry,
        bcm_gport_t *port_id,
        bcm_gport_t *port_mask)
{
    return BCM_E_UNAVAIL; 
}


int 
bcm_esw_field_qualify_CustomHeaderPkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_CustomHeaderPkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_CustomHeaderData(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_CustomHeaderData_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Set match criteria for bcmFieildQualifyMimlPkt
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_MimlPkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieildQualifyMiml
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_MimlPkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Set match criteria for bcmFieildQualifyMimlSrcMac
 *                qualifier from the field entry.
 */
int
bcm_esw_field_qualify_MimlSrcMac(int unit, bcm_field_entry_t entry,
                             bcm_mac_t data, bcm_mac_t mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Set match criteria for bcmFieildQualifyMimlDstMac
 *                qualifier from the field entry.
 */
int
bcm_esw_field_qualify_MimlDstMac(int unit, bcm_field_entry_t entry,
                             bcm_mac_t data, bcm_mac_t mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieildQualifyMimlSrcMac
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_MimlSrcMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieildQualifyMimlDstMac
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_MimlDstMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Set match criteria for bcmFieildQualifyMimlVlan
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_MimlVlan(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Set match criteria for bcmFieildQualifyMimlVlanId
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_MimlVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Set match criteria for bcmFieildQualifyMimlVlanPri
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_MimlVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/*
 * Set match criteria for bcmFieildQualifyMimlVlanCfi
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_MimlVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieildQualifyMimlVlan
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_MimlVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieildQualifyMimlVlanVid
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_MimlVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieildQualifyMimlVlanPri
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_MimlVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieildQualifyMimlVlanCfi_get
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_MimlVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Set match criteria for bcmFieildQualifyMimlInnerTag
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_MimlInnerTag(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieildQualifyMimlInnerTag_get
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_MimlInnerTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapHdrType
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapHdrType(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapHdrType
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapHdrType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapHdrRid
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapHdrRid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapHdrRid
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapHdrRid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadSOF
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadSOF(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadSOF
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadSOF_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadDstMac
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadDstMac(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for CapwapPayloadDstMac
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadDstMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadSrcMac
 *                qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadSrcMac(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadSrcMac
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadSrcMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Configure match criteria for bcmFieldQualifyCapwapPayloadEtherType
 *             qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadEtherType(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadEtherType
 *             qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadEtherType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadOuterVlan
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlan(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadOuterVlan
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadOuterVlanId
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadOuterVlanId
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadOuterVlanPri
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadOuterVlanPri
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadOuterVlanCfi
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadOuterVlanCfi_get
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadOuterVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadInnerVlan
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlan(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadInnerVlan
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadInnerVlanId
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadInnerVlanId
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadInnerVlanPri
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadInnerVlanPri
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadInnerVlanCfi
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadInnerVlanCfi_get
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadInnerVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadVlanFormat
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadVlanFormat(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadVlanFormat
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadVlanFormat_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_field_qualify_CapwapPayloadSip */
int 
bcm_esw_field_qualify_CapwapPayloadSip(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t data, 
    bcm_ip_t mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_field_qualify_CapwapPayloadDip */
int 
bcm_esw_field_qualify_CapwapPayloadDip(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t data, 
    bcm_ip_t mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadSip
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadSip_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadDip
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadDip_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_field_qualify_CapwapPayloadSip6 */
int 
bcm_esw_field_qualify_CapwapPayloadSip6(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_field_qualify_CapwapPayloadDip6 */
int 
bcm_esw_field_qualify_CapwapPayloadDip6(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadSip6
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadSip6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadDip6
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadDip6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadIpProtocol
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadIpProtocol(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadIpProtocol_get
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadIpProtocol_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadTos
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadTos(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadTos_get
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadTos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_field_qualify_CapwapPayloadL4SrcPort */
int 
bcm_esw_field_qualify_CapwapPayloadL4SrcPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t data, 
    bcm_l4_port_t mask)
{
    return BCM_E_UNAVAIL;
}

/* bcm_field_qualify_CapwapPayloadL4DstPort */
int 
bcm_esw_field_qualify_CapwapPayloadL4DstPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t data, 
    bcm_l4_port_t mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadL4SrcPort
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadL4SrcPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadL4DstPort
 *                qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadL4DstPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadL3HdrParseable
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadL3HdrParseable(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadL3HdrParseable_get
 *                  qualifier from the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadL3HdrParseable_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for bcmFieldQualifyCapwapPayloadL4HdrParseable
 *                  qualifier in the field entry.
 */
int 
bcm_esw_field_qualify_CapwapPayloadL4HdrParseable(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for bcmFieldQualifyCapwapPayloadL4HdrParseable_get
 *                  qualifier from the field entry.
 */
int
bcm_esw_field_qualify_CapwapPayloadL4HdrParseable_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InterfaceIngressKeySelectClassPort(
    int unit, bcm_field_entry_t entry,
    uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InterfaceIngressKeySelectClassPort_get(
    int unit, bcm_field_entry_t entry,
    uint32 *data, uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_ISid(
    int unit, bcm_field_entry_t entry,
    uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_ISid_get(
    int unit, bcm_field_entry_t entry,
    uint32 *data, uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_ITag(
    int unit, bcm_field_entry_t entry,
    uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_ITag_get(
    int unit, bcm_field_entry_t entry,
    uint32 *data, uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_BfdYourDiscriminator(
    int unit, bcm_field_entry_t entry,
    uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_BfdYourDiscriminator_get(
    int unit, bcm_field_entry_t entry,
    uint32 *data, uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_CpuVisibilityPacket(
    int unit, bcm_field_entry_t entry,
    uint8 data, uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_CpuVisibilityPacket_get(
    int unit, bcm_field_entry_t entry,
    uint8 *data, uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DstL2MulticastGroup(
    int unit, bcm_field_entry_t entry,
    bcm_multicast_t group, bcm_multicast_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DstL2MulticastGroup_get(
    int unit, bcm_field_entry_t entry,
    bcm_multicast_t *group, bcm_multicast_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DstL3MulticastGroup(
    int unit, bcm_field_entry_t entry,
    bcm_multicast_t group, bcm_multicast_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DstL3MulticastGroup_get(
    int unit, bcm_field_entry_t entry,
    bcm_multicast_t *group, bcm_multicast_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* Set match criteria to qualify Rx Down Mep SAT terminated hit status. */
int bcm_esw_field_qualify_DownMepSatTerminated(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* Get match criteria for Rx Down Mep SAT terminated hit status. */
int bcm_esw_field_qualify_DownMepSatTerminated_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}
/*
 * Function:
 *      bcm_esw_field_qualify_DstMultipathOverlay
 * Purpose:
 *      Set match criteria for bcmFieildQualifyDstMultipathOverlay
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) ECMP interface(s) with overlay flag
 *      mask  - (IN) corresponding mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMultipathOverlay(int unit, bcm_field_entry_t entry,
                                           bcm_if_t data, bcm_if_t mask) {
    return BCM_E_UNAVAIL;
}
 
 /*
 * Function:
 *      bcm_esw_field_qualify_DstMultipathOverlay_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMultipathOverlay
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (OUT) ECMP interface(s) with overlay flag
 *      mask  - (OUT) corresponding mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMultipathOverlay_get(int unit, bcm_field_entry_t entry,
                                               bcm_if_t *data, bcm_if_t *mask) {
    return BCM_E_UNAVAIL;
}
 /*
 * Function:
 *      bcm_esw_field_qualify_DstMultipathUnderlay
 * Purpose:
 *      Set match criteria for bcmFieildQualifyDstMultipathUnderlay
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (IN) ECMP interface(s) with Underlay flag
 *      mask  - (IN) corresponding mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMultipathUnderlay(int unit, bcm_field_entry_t entry,
                                           bcm_if_t data, bcm_if_t mask) {
        return BCM_E_UNAVAIL;
}
 /*
 * Function:
 *      bcm_esw_field_qualify_DstMultipathUnderlay_get
 * Purpose:
 *      Get match criteria for bcmFieildQualifyDstMultipathUnderlay
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data  - (OUT) ECMP interface(s) with Underlay flag
 *      mask  - (OUT) corresponding mask
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_esw_field_qualify_DstMultipathUnderlay_get(int unit, bcm_field_entry_t entry,
                                               bcm_if_t *data, bcm_if_t *mask) {
    return BCM_E_UNAVAIL;
}


int
bcm_esw_field_source_class_mode_set(
    int unit, bcm_field_stage_t stage,
    bcm_pbmp_t pbm,
    bcm_field_src_class_mode_t mode)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_source_class_mode_get(
    int unit, bcm_field_stage_t stage,
    bcm_pbmp_t pbm,
    bcm_field_src_class_mode_t *mode)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MixedSrcClassId(
    int unit, bcm_field_entry_t entry,
    bcm_pbmp_t pbm,
    bcm_field_src_class_t data,
    bcm_field_src_class_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MixedSrcClassId_get(
    int unit, bcm_field_entry_t entry,
    bcm_pbmp_t pbm,
    bcm_field_src_class_t *data,
    bcm_field_src_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_StpState(
    int unit, bcm_field_entry_t entry,
    uint8 data)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_StpState_get(
    int unit, bcm_field_entry_t entry,
    uint8 *data)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigMirrorOrSwitchPkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigMirrorOrSwitchPkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigMplsPkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigMplsPkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDoNotFlags(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigDoNotFlags_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigPreserveFlags(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigPreserveFlags_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigLabelType(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    return BCM_E_UNAVAIL;
}
int bcm_esw_field_qualify_HiGigLabelType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigVpPreserveFlags(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigVpPreserveFlags_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEnginePreserveDscp(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEnginePreserveDscp_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEnginePreserveDot1p(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEnginePreserveDot1p_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEngineSrcType(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEngineSrcType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigExtendedHeaderPresent(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigExtendedHeaderPresent_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigVpLagFailoverPacket(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigVpLagFailoverPacket_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigForwardingType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_HiGigForwardingType_t type) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigForwardingType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_HiGigForwardingType_t *type)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEngineDeferredFlags(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEngineDeferredFlags_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEngineVxltStatus(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) 
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_HiGigOffloadEngineVxltStatus_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}



int 
bcm_esw_field_qualify_DevicePortBitmap(
    int unit,
    bcm_field_entry_t entry,
    bcm_pbmp_t data,
    bcm_pbmp_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DevicePortBitmap_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_pbmp_t *data,
    bcm_pbmp_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_SystemPortBitmap(
    int unit,
    bcm_field_entry_t entry,
    bcm_pbmp_t data,
    bcm_pbmp_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_SystemPortBitmap_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_pbmp_t *data,
    bcm_pbmp_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_SourceGportBitmap(
    int unit,
    bcm_field_entry_t entry,
    bcm_pbmp_t data,
    bcm_pbmp_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_SourceGportBitmap_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_pbmp_t *data,
    bcm_pbmp_t *mask)
{
    return BCM_E_UNAVAIL;
}

/* Configure CopyToCpu action for the field entry. */
int bcm_esw_field_action_copytocpu_config_set(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_CopyToCpu_config_t CopyToCpu_config)
{
    return BCM_E_UNAVAIL;
}

/* Get CopyToCpu action from the field entry. */
int bcm_esw_field_action_copytocpu_config_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_CopyToCpu_config_t *CopyToCpu_config)
{
    return BCM_E_UNAVAIL;
}

/* Configure Redirect action for the field entry. */
int bcm_esw_field_action_redirect_config_set(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_redirect_config_t redirect_config)
{
    return BCM_E_UNAVAIL;
}

/* Get Redirect action from the field entry. */
int bcm_esw_field_action_redirect_config_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_redirect_config_t *redirect_config)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TosLower4Bits(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TosLower4Bits_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OamEgressClass2Vxlt(
        int unit,
        bcm_field_entry_t entry,
        uint32 data,
        uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OamEgressClass2Vxlt_get(
        int unit,
        bcm_field_entry_t entry,
        uint32 *data,
        uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OamEgressVxltFirstHit(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OamEgressVxltFirstHit_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OamEgressVxltSecondHit(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OamEgressVxltSecondHit_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OamDownMEPLoopbackPacket(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OamDownMEPLoopbackPacket_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OamEgressPortUnicastDstMacHit(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OamEgressPortUnicastDstMacHit_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_IngressDropEthernetOamControl(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t mep_type)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_IngressDropEthernetOamControl_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t *mep_type)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_IngressDropEthernetOamData(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t mep_type)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_IngressDropEthernetOamData_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t *mep_type)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_IngressDropMplsOamControl(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t mep_type)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_IngressDropMplsOamControl_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t *mep_type)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_IngressDropMplsOamData(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t mep_type)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_IngressDropMplsOamData_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_oam_drop_mep_type_t *mep_type)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for EgressClassVxlan
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassVxlan(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for EgressClassVxlan
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassVxlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Set match criteria for bcmFieldQualifyOamEgressEtherType
 *             qualifier in the field entry.
 */
int bcm_esw_field_qualify_OamEgressEtherType(
    int unit,
    bcm_field_entry_t entry,
    uint16 data)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifyOamEgressEtherType
 *             qualifier from the field entry.
 */
int bcm_esw_field_qualify_OamEgressEtherType_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data)
{
    return BCM_E_UNAVAIL;
}

/*
 * Set match criteria for bcmFieldQualifyOamEgressMulticastMacHit
 *             qualifier in the field entry.
 */
int bcm_esw_field_qualify_OamEgressMulticastMacHit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data)
{
    return BCM_E_UNAVAIL;
}

/*
 * Get match criteria for bcmFieldQualifyOamEgressMulticastMacHit
 *             qualifier from the field entry.
 */
int bcm_esw_field_qualify_OamEgressMulticastMacHit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_TrunkMemberSourceModuleId(
    int unit, 
    bcm_field_entry_t entry, 
    int modid, 
    int modid_mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_TrunkMemberSourceModuleId_get(
    int unit, 
    bcm_field_entry_t entry, 
    int *modid, 
    int *modid_mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OamEgressClassSrcMac(
        int unit,
        bcm_field_entry_t entry,
        uint32 data,
        uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OamEgressClassSrcMac_get(
        int unit,
        bcm_field_entry_t entry,
        uint32 *data,
        uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MyStation2Hit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MyStation2Hit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_VxlanClassValid(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_VxlanClassValid_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_VxlanPacket(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_VxlanPacket_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_VxlanVnidVlanTranslateHit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_VxlanVnidVlanTranslateHit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_VxlanPayloadVlanFormat(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_VxlanPayloadVlanFormat_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadDstMac(
    int unit,
    bcm_field_entry_t entry,
    bcm_mac_t  data,
    bcm_mac_t  mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadDstMac_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_mac_t  *data,
    bcm_mac_t  *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadSrcMac(
    int unit,
    bcm_field_entry_t entry,
    bcm_mac_t  data,
    bcm_mac_t  mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadSrcMac_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_mac_t  *data,
    bcm_mac_t  *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadEtherType(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadEtherType_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadOuterVlan(
    int unit,
    bcm_field_entry_t entry,
    bcm_vlan_t data,
    bcm_vlan_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadOuterVlan_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_vlan_t *data,
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadOuterVlanId(
    int unit,
    bcm_field_entry_t entry,
    bcm_vlan_t data,
    bcm_vlan_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadOuterVlanId_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_vlan_t *data,
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadOuterVlanPri(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadOuterVlanPri_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadOuterVlanCfi(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadOuterVlanCfi_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadSip(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip_t data,
    bcm_ip_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadDip(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip_t data,
    bcm_ip_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadSip_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip_t *data,
    bcm_ip_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadDip_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip_t *data,
    bcm_ip_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadSip6(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip6_t data,
    bcm_ip6_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadDip6(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip6_t data,
    bcm_ip6_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadSip6_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip6_t *data,
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadDip6_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_ip6_t *data,
    bcm_ip6_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadIpProtocol(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadIpProtocol_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadL4SrcPort(
    int unit,
    bcm_field_entry_t entry,
    bcm_l4_port_t data,
    bcm_l4_port_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadL4DstPort(
    int unit,
    bcm_field_entry_t entry,
    bcm_l4_port_t data,
    bcm_l4_port_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadL4SrcPort_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_l4_port_t *data,
    bcm_l4_port_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadL4DstPort_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_l4_port_t *data,
    bcm_l4_port_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_group_ports_add(
    int unit,
    bcm_field_group_t group,
    bcm_pbmp_t pbmp)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_group_ports_remove(
    int unit,
    bcm_field_group_t group,
    bcm_pbmp_t pbmp)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_group_config_validate(
                          int unit,
                          bcm_field_group_config_t *group_config,
                          bcm_field_group_mode_t *group_mode) {
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_group_ports_get(
    int unit,
    bcm_field_group_t group,
    bcm_pbmp_t *pbmp)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Set match criteria for EgressClassTunnel
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassTunnel(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * Get match criteria for EgressClassTunnel
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassTunnel_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}
/* 
 * Set match criteria for EgressClassL3InterfaceTunnel
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassL3InterfaceTunnel(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for EgressClassL3InterfaceTunnel
 *                qualifier.
 */
int bcm_esw_field_qualify_EgressClassL3InterfaceTunnel_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)

int bcm_esw_field_group_config_validate(
                          int unit,
                          bcm_field_group_config_t *group_config,
                          bcm_field_group_mode_t *group_mode) {
    return BCM_E_UNAVAIL;
}

bcm_error_t
bcm_esw_field_class_map_set(
        int unit, 
        bcm_field_stage_t stage,
        bcm_field_qualify_t qual, 
        uint32 num_entries,
        uint32 *orig_values_array,
        uint32 *map_values_array)
{
    return BCM_E_UNAVAIL;
}

/* Add VLAN actions to a field entry. */
int bcm_esw_field_action_vlan_actions_add(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_action_t action,
    bcm_vlan_action_set_t *vlan_action_set)
{
    return BCM_E_UNAVAIL;
}

/* Retrieve VLAN actions configured to a field entry. */
int bcm_esw_field_action_vlan_actions_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_action_t action,
    bcm_vlan_action_set_t *vlan_action_set)
{
    return BCM_E_UNAVAIL;
}

bcm_error_t
bcm_esw_field_class_map_get(
        int unit, 
        bcm_field_stage_t stage,
        bcm_field_qualify_t qual, 
        uint32 num_entries,
        uint32 *orig_values_array,
        uint32 *map_values_array)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_PreemptablePacket(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_PreemptablePacket_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_RoceBthOpcode(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_RoceBthOpcode_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_RoceBthPartitionKey(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_RoceBthPartitionKey_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_RoceBthDstQueuePair(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_RoceBthDstQueuePair_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_RoceBthFlags(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_RoceBthFlags_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_RoceVer1Pkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_RoceVer1Pkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_RoceVer2Pkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_RoceVer2Pkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_group_config_validate(
                          int unit,
                          bcm_field_group_config_t *group_config,
                          bcm_field_group_mode_t *group_mode) {
    return BCM_E_UNAVAIL;
}

bcm_error_t
bcm_esw_field_class_map_set(
        int unit, 
        bcm_field_stage_t stage,
        bcm_field_qualify_t qual, 
        uint32 num_entries,
        uint32 *orig_values_array,
        uint32 *map_values_array)
{
    return BCM_E_UNAVAIL;
}


bcm_error_t
bcm_esw_field_class_map_get(
        int unit, 
        bcm_field_stage_t stage,
        bcm_field_qualify_t qual, 
        uint32 num_entries,
        uint32 *orig_values_array,
        uint32 *map_values_array)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_MacSecTagPresent(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}


int
bcm_esw_field_qualify_MacSecTag(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}



int
bcm_esw_field_qualify_MacSecDstMacRangeHit_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_macsec_DstMacRange_set(
               int unit,
               bcm_mac_t lower_limit,
               bcm_mac_t upper_limit)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_macsec_DstMacRange_get(
               int unit,
               bcm_mac_t *lower_limit,
               bcm_mac_t *upper_limit)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FromMacSecPort(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FromMacSecPort_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MacSecFlow(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MacSecFlow_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_MacSecSecTagCbit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_MacSecSecTagCbit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}
int bcm_esw_field_qualify_MacSecSecTagEbit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_MacSecSecTagEbit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_MacSecControlPkt(
               int unit,
               bcm_field_entry_t entry_id,
               bcm_field_macsec_encrypt_decrypt_pkt_t data)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MacSecControlPkt_get(
               int unit,
               bcm_field_entry_t entry_id,
               bcm_field_macsec_encrypt_decrypt_pkt_t *data)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_SrcPortSRType(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_field_port_sr_type_t type)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SrcPortSRType_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_port_sr_type_t *type)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_DstPortSRType(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_field_port_sr_type_t type)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_DstPortSRType_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_port_sr_type_t *type)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SrcPortSRRoleInterlink(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 data)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SrcPortSRRoleInterlink_get(int unit,
                                                 bcm_field_entry_t entry,
                                                 uint8 *data)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_DstPortSRRoleInterlink(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 data)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_DstPortSRRoleInterlink_get(int unit,
                                                 bcm_field_entry_t entry,
                                                 uint8 *data)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SrcPortSRMode(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_field_sr_port_mode_t type,
                                    uint8 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SrcPortSRMode_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_sr_port_mode_t *type,
                                        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_DstPortSRMode(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_field_sr_port_mode_t type,
                                    uint8 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_DstPortSRMode_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_sr_port_mode_t *type,
                                        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SrcPortSRNetId(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 net_id, uint8 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SrcPortSRNetId_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *net_id, uint8 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_DstPortSRNetId(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 net_id, uint8 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_DstPortSRNetId_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *net_id, uint8 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SrcPortSRLanId(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 net_id)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SrcPortSRLanId_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *net_id)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_DstPortSRLanId(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 net_id)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_DstPortSRLanId_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *net_id)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRTagType(int unit, bcm_field_entry_t entry,
                                bcm_field_sr_tag_type_t type)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRTagType_get(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_field_sr_tag_type_t *type)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRLanId(int unit, bcm_field_entry_t entry,
                              int lan_id)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRLanId_get(int unit, bcm_field_entry_t entry,
                                  int *lan_id)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRNetId(int unit, bcm_field_entry_t entry,
                              int net_id)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRNetId_get(int unit, bcm_field_entry_t entry,
                                  int *net_id)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_VlanSREnable(int unit, bcm_field_entry_t entry,
                                   uint8 data)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_VlanSREnable_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 *data)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_VlanSRLanId(int unit, bcm_field_entry_t entry,
                                  uint8 lan_id)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_VlanSRLanId_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 *lan_id)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRFlowId(int unit, bcm_field_entry_t entry,
                               uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRFlowId_get(int unit, bcm_field_entry_t entry,
                                   uint32 *data, uint32 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_L2DestSRNodeType(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_field_sr_node_type_t type)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_L2DestSRNodeType_get(int unit,
                                           bcm_field_entry_t entry,
                                           bcm_field_sr_node_type_t *type)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRNetIdMatched(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRNetIdMatched_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRSrcNodeIsSan(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRSrcNodeIsSan_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRSupervisionType(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_sr_supervision_type_t type)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRSupervisionType_get(int unit,
                                            bcm_field_entry_t entry,
                                            bcm_field_sr_supervision_type_t *type)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRError(int unit, bcm_field_entry_t entry,
                              uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRError_get(int unit, bcm_field_entry_t entry,
                                  uint32 *data, uint32 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_L2SrcMulticastHit(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 data, uint8 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_L2SrcMulticastHit_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint8 *data, uint8 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_L2DstMulticastHit(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 data, uint8 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_L2DstMulticastHit_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint8 *data, uint8 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRDuplicate(int unit, bcm_field_entry_t entry,
                                  uint8 data)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SRDuplicate_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 *data)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_TsnFlowId(int unit, bcm_field_entry_t entry,
                                uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_TsnFlowId_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint32 *data, uint32 *mask)
{
    return BCM_E_UNAVAIL;
}
int 
bcm_esw_field_qualify_CnTagPresent(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_CnTagPresent_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_FrontPanelPkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_FrontPanelPkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_HiGigProxyTunnelType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_higig_proxy_tunnel_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_HiGigProxyTunnelType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_higig_proxy_tunnel_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_InterfaceClassL2Type(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_interface_class_l2_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_InterfaceClassL2Type_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_interface_class_l2_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IpChecksumOkPkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IpChecksumOkPkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IpFragPkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IpFragPkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IpInIpPkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IpInIpPkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

bcm_error_t
bcm_esw_field_class_map_get(
        int unit, 
        bcm_field_stage_t stage,
        bcm_field_qualify_t qual, 
        uint32 num_entries,
        uint32 *orig_values_array,
        uint32 *map_values_array)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IpTtlZeroPkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerGroupId(
               int unit,
               bcm_field_entry_t entry_id,
               int data,
               int mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerGroupId_get(
               int unit,
               bcm_field_entry_t entry_id,
               int *data,
               int *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerClassId(
               int unit,
               bcm_field_entry_t entry_id,
               int data,
               int mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerClassId_get(
               int unit,
               bcm_field_entry_t entry_id,
               int *data,
               int *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerGroupValid(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerGroupValid_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerDisabled(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerDisabled_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerMeteringExceeded(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerMeteringExceeded_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerCollectorCopy(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerCollectorCopy_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerFlowTableFull(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerFlowTableFull_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerGroupFlowExceeded(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerGroupFlowExceeded_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerExportQueueFull(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerExportQueueFull_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MacSecTagPresent(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MacSecTagPresent_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MacSecTag(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MacSecTag_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MacSecDstMacRangeHit(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MacSecDstMacRangeHit_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_macsec_DstMacRange_set(
               int unit,
               bcm_mac_t lower_limit,
               bcm_mac_t upper_limit)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_macsec_DstMacRange_get(
               int unit,
               bcm_mac_t *lower_limit,
               bcm_mac_t *upper_limit)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FromMacSecPort(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FromMacSecPort_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MacSecFlow(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MacSecFlow_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_SrcPortSRType(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_field_port_sr_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IpTtlZeroPkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IpmcV4Pkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IpmcV4Pkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IpmcV6Pkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IpmcV6Pkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_Ipv4OptionHdrType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ip_option_hdr_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_Ipv4OptionHdrType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ip_option_hdr_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_Ipv6ExtensionHdrType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ip_option_hdr_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_Ipv6ExtensionHdrType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ip_option_hdr_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_L2PayloadTypePkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_L2PayloadTypePkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_L2PktType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_l2_pkt_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_L2PktType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_l2_pkt_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_MplsCwPresent(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_MplsCwPresent_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_MplsMcastEthertypePresent(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_MplsMcastEthertypePresent_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


int 
bcm_esw_field_qualify_NetworkTagMulticastPkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_NetworkTagMulticastPkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_SrcPortSRLanId(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 lan_id)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_SrcPortSRLanId_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *lan_id)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_DstPortSRLanId(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 lan_id)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_DstPortSRLanId_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *lan_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_NetworkTagType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_network_tag_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_NetworkTagType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_network_tag_type_t *type)
{
    return BCM_E_UNAVAIL;
}


int 
bcm_esw_field_qualify_OuterPriTaggedPkt(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OuterPriTaggedPkt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


int 
bcm_esw_field_qualify_OverlayCnTagPresent(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlayCnTagPresent_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlayIpv4OptionHdrType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ip_option_hdr_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlayIpv4OptionHdrType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ip_option_hdr_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlayIpv6ExtensionHdrType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ip_option_hdr_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlayIpv6ExtensionHdrType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ip_option_hdr_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlayL2PktType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_l2_pkt_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlayL2PktType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_l2_pkt_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlayNetworkTagType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_network_tag_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlayNetworkTagType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_network_tag_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlayPktType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_pkt_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlayPktType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_pkt_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlaySubportTagPresent(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlaySubportTagPresent_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlayVlanFormat(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_OverlayVlanFormat_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_PimBidirDfStatus(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_PimBidirDfStatus_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}


int 
bcm_esw_field_qualify_PktType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_pkt_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_PktType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_pkt_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_SubportTagPresent(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_SubportTagPresent_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_SysHdrType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_sys_hdr_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_SysHdrType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_sys_hdr_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IntPktFinalHop(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IntPktFinalHop_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IntPktType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_int_pkt_type_t type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IntPktType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_int_pkt_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IntPktOverflowed(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IntPktOverflowed_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}
int 
bcm_esw_field_qualify_IntPktLengthValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IntPktLengthValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IntPktVersionOne(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IntPktVersionOne_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MplsTransit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MplsTransit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_NshServiceIndex(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_NshServiceIndex_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_NshServicePathId(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_NshServicePathId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_TunnelSubType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_TunnelSubType_t type)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelSubType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_TunnelSubType_t *type)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_BfdGoodPkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_BfdGoodPkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TafGateId(int unit, bcm_field_entry_t entry,
                                uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_TafGateId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data, uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TafEnable(int unit, bcm_field_entry_t entry,
                                uint8 enable)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TafEnable_get(
    int unit,
    bcm_field_entry_t entry,
    uint8* enable)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TafGateState(int unit, bcm_field_entry_t entry,
                                uint8 state)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TafGateState_get(
    int unit,
    bcm_field_entry_t entry,
    uint8* state)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TafCosProfile(int unit, bcm_field_entry_t entry,
                                uint32 data, uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TafCosProfile_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data, uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_BfdPktWithDstIpLoopbackAddr(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_BfdPktWithDstIpLoopbackAddr_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MplsControlPkt(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MplsControlPkt_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IpTunnelTtl_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)

{
    return BCM_E_UNAVAIL;

}

int
bcm_esw_field_qualify_IpTunnelTtl(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)

{
    return BCM_E_UNAVAIL;

}

int
bcm_esw_field_qualify_IpTunnelTtlClassZero(int unit,
        bcm_field_entry_t entry,
        bcm_class_t data,
        bcm_class_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InterfaceClassMplsLookup1_get(
                        int unit,
                        bcm_field_entry_t entry_id,
                        uint16 *data,
                        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InterfaceClassMplsLookup2_get(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InterfaceClassMplsLookup3_get(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InterfaceClassL3Tunnel_get(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InterfaceClassMplsLookup1(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InterfaceClassMplsLookup2(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InterfaceClassMplsLookup3(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InterfaceClassL3Tunnel(
        int unit,
        bcm_field_entry_t entry_id,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_BfdPktVersionOne(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_BfdPktVersionOne_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_GenevePktVersionZero(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GenevePktVersionZero_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GenevePktWithOam(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GenevePktWithOam_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GpePktVersionZero(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GpePktVersionZero_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GpePktWithOam(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GpePktWithOam_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IpTunnelTtlClassZero_get(int unit,
        bcm_field_entry_t entry,
        bcm_class_t *data,
        bcm_class_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_PktDstAddrType(
    int unit,
    bcm_field_entry_t entry,
    uint32 dst_addr_type)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_PktDstAddrType_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *dst_addr_type)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_PktInnerDstAddrType(
    int unit,
    bcm_field_entry_t entry,
    uint32 dst_addr_type)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_PktInnerDstAddrType_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *dst_addr_type)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerL4Ports(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerL4Ports_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_Ip6PktNextHeader(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_Ip6PktNextHeader_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_Ip6PktHopLimit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_Ip6PktHopLimit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_Ip6PktTrafficClass(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_Ip6PktTrafficClass_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerIp6PktNextHeader(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerIp6PktNextHeader_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerIp6PktHopLimit(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerIp6PktHopLimit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerIp6PktTrafficClass(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerIp6PktTrafficClass_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_action_config_info_add(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_action_t action,
    bcm_field_action_params_t *params,
    bcm_field_action_match_config_t *match_config)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_action_config_info_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_action_t action,
    bcm_field_action_params_t *params,
    bcm_field_action_match_config_t *match_config)
{
    return BCM_E_UNAVAIL;
}

 
/* 
 * Configure match criteria for bcmFieldQualifyRangeCheckGroup
 *         qualifier from the field entry.
 */
int bcm_esw_field_qualify_RangeCheckGroup(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}


/* 
 * Get match criteria for bcmFieldQualifyRangeCheckGroup
 *                qualifier from the field entry.
 */
int bcm_esw_field_qualify_RangeCheckGroup_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* Qualifies on the tag type configured for opaque tags. */
int bcm_esw_field_qualify_OpaqueTagType(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * To get the qualified inputs on the tag type configured for opaque
 * tags.
 */
int bcm_esw_field_qualify_OpaqueTagType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

/* Qualifies on the higher 32 bits of opaque tag allowed in the system */
int bcm_esw_field_qualify_OpaqueTagHigh(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * To get the qualified inputs on the higher 32 bits of opaque tag
 * allowed in the system.
 */
int bcm_esw_field_qualify_OpaqueTagHigh_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

/* Qualifies on the lower 32 bits of opaque tag allowed in the system */
int bcm_esw_field_qualify_OpaqueTagLow(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

/* 
 * To get the qualified inputs on the lower 32 bits of opaque tag allowed
 * in the system.
 */
int bcm_esw_field_qualify_OpaqueTagLow_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerDosAttack(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerDosAttack_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DosAttackEvents(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DosAttackEvents_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerDosAttackEvents(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerDosAttackEvents_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_EgressForwardingClassId(
        int unit,
        bcm_field_entry_t entry,
        int data,
        int mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_EgressForwardingClassId_get(
        int unit,
        bcm_field_entry_t entry,
        int *data,
        int *mask)
{
    return BCM_E_UNAVAIL;
}

/*
 * Set qualification to define packet flow for a given entry. This API is
 * normally used for preselectors.
 */
int bcm_esw_field_qualify_PktFlowType(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_pkt_flow_type_t type)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_PktFlowType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_pkt_flow_type_t *type)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_VlanTranslateClassId(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_VlanTranslateClassId_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IpIdentifier(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IpIdentifier_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_Ip4Length(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_Ip4Length_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_Ip6Length(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_Ip6Length_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadIp4Length(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadIp4Length_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadIp6Length(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TunnelPayloadIp6Length_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GbpPresent(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return  BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GbpPresent_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_HiGigGbpPresent(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return  BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_HiGigGbpPresent_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_VxlanGbpPresent(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return  BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_VxlanGbpPresent_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_HiGigGbpSrcId(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return  BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_HiGigGbpSrcId_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GbpSrcId(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return  BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GbpSrcId_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GbpDstId(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return  BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_GbpDstId_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerCheck(
        int unit,
        bcm_field_entry_t entry,
        bcm_flowtracker_group_t  flow_group_id,
        uint32 num_checks,
        bcm_field_flowtrackercheck_t *list_of_check_ids)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerCheck_get(
        int unit,
        bcm_field_entry_t entry,
        bcm_flowtracker_group_t  flow_group_id,
        uint32 num_checks,
        bcm_field_flowtrackercheck_t *list_of_check_ids,
        uint32 *actual_num_checks)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerLearn(
        int unit,
        bcm_field_entry_t entry,
        uint8 data,
        uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerLearn_get(
        int unit,
        bcm_field_entry_t entry,
        uint8 *data,
        uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_CosMapSelect(
        int unit,
        bcm_field_entry_t entry,
        bcm_field_cos_map_select_t cos_map_select)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_CosMapSelect_get(
        int unit,
        bcm_field_entry_t entry,
        bcm_field_cos_map_select_t *cos_map_select)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OpaqueObject1(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OpaqueObject1_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OpaqueObject2(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OpaqueObject2_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OpaqueObject3(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OpaqueObject3_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OpaqueObject4(
        int unit,
        bcm_field_entry_t entry,
        uint16 data,
        uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_OpaqueObject4_get(
        int unit,
        bcm_field_entry_t entry,
        uint16 *data,
        uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IncomingOuterVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IncomingOuterVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_LoopbackSubtype(
        int unit,
        bcm_field_entry_t entry, 
        bcm_field_loopback_subtype_t lb_subtype)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_LoopbackSubtype_get(
        int unit,
        bcm_field_entry_t entry,
        bcm_field_loopback_subtype_t *lb_subtype)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_MHPriority(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_PdelayReq(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_DstL3EgressUnderlay(int unit, 
                                        bcm_field_entry_t entry, 
                                        bcm_if_t if_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_DstL3EgressNextHopsUnderlay_get(int unit, 
                                        bcm_field_entry_t entry, 
                                        bcm_if_t *if_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_DstL3EgressNextHopsUnderlay(int unit, 
                                                bcm_field_entry_t entry, 
                                                uint32 data,
                                                uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_DstL3EgressNextHopsUnderlay_get(int unit, 
                                                bcm_field_entry_t entry, 
                                                uint32 *data,
                                                uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_EgressClassPort(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_MHPriority_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_PdelayReq_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int bcm_esw_field_qualify_EgressClassPort_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_INTProbeMarker1(int unit,
                                      bcm_field_entry_t entry,
                                      uint32 data,
                                      uint32 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_INTProbeMarker2(int unit,
                                      bcm_field_entry_t entry,
                                      uint32 data,
                                      uint32 mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_INTReserved4Bytes(int unit,
                                        bcm_field_entry_t entry,
                                        uint32 data,
                                        uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_INTProbeMarker1_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint32 *data,
                                          uint32 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_INTProbeMarker2_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint32 *data,
                                          uint32 *mask)
{
    return BCM_E_UNAVAIL;
}
int
bcm_esw_field_qualify_INTReserved4Bytes_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint32 *data,
                                          uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowControlType(
               int unit,
               bcm_field_entry_t entry_id,
               bcm_field_flow_control_pkt_type_t fc_type)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowControlType_get(
               int unit,
               bcm_field_entry_t entry_id,
               bcm_field_flow_control_pkt_type_t *fc_type)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_EgressPortCtrlType(
               int unit,
               bcm_field_entry_t entry_id,
               bcm_field_egress_port_ctrl_t ctrl_type)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TimeStampTxPktType(
               int unit,
               bcm_field_entry_t entry_id,
               bcm_field_timestamp_transmit_pkt_type_t ts_pkt_type)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_EgressPortCtrlType_get(
               int unit,
               bcm_field_entry_t entry_id,
               bcm_field_egress_port_ctrl_t *ctrl_type)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_TimeStampTxPktType_get(
               int unit,
               bcm_field_entry_t entry_id,
               bcm_field_timestamp_transmit_pkt_type_t *ts_pkt_type)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_SysHdrLocalDstport(int unit,
                             bcm_field_entry_t entry,
                             bcm_port_t data, bcm_port_t mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_SysHdrLocalDstport_get(int unit,
                             bcm_field_entry_t entry,
                             bcm_port_t *data, bcm_port_t *mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_SubportGroupIds(
                            int unit,
                            bcm_field_entry_t entry,
                            uint32 num_groups,
                            bcm_subport_port_group_t *subport_port_group_id)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_SubportGroupIds_get(
                            int unit,
                            bcm_field_entry_t entry,
                            uint32 num_groups,
                            bcm_subport_port_group_t *subport_port_group_id,
                            uint32 *actual_groups)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerAggregateClass(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerAggregateClass_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerClassIdSource1(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerClassIdSource1_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerClassIdSource2(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_FlowtrackerClassIdSource2_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_ApplSignatureId(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_ApplSignatureId_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerApplSignatureId(
    int unit,
    bcm_field_entry_t entry,
    uint16 data,
    uint16 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerApplSignatureId_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_CosQueueId(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t queue_gport)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_CosQueueId_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *queue_gport)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_CongestionExperienced(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_CongestionExperienced_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_CongestionMarked(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_CongestionMarked_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IsUcastCosQueue(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IsUcastCosQueue_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_EgressPortQueue(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_EgressPortQueue_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IOAMRemainingLenValid(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IOAMRemainingLenValid_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IOAMPktOverflowed(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IOAMPktOverflowed_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IOAMNameSpaceIdMatch(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 data,
               uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_IOAMNameSpaceIdMatch_get(
               int unit,
               bcm_field_entry_t entry_id,
               uint8 *data,
               uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaCurrentLength(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaRequestVector(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaRequestVector_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaCurrentLengthEqualToZero(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaCurrentLengthEqualToZero_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaCurrentLength_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaGlobalNameSpace(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaGlobalNameSpace_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaHopLimitEqualToZero(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaHopLimitEqualToZero_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaLocalNameSpace(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaLocalNameSpace_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaVersion2(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_esw_field_qualify_IfaVersion2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_InnerTcpControl(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_InnerTcpControl_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    return (BCM_E_UNAVAIL);
}

int
bcm_esw_field_qualify_DstMultipathLevel1(
    int unit,
    bcm_field_entry_t entry,
    bcm_if_t data,
    bcm_if_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DstMultipathLevel1_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_if_t *data,
    bcm_if_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DstMultipathLevel2(
    int unit,
    bcm_field_entry_t entry,
    bcm_if_t data,
    bcm_if_t mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DstMultipathLevel2_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_if_t *data,
    bcm_if_t *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_SrcCompressionClassId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_SrcCompressionClassId(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DstCompressionClassId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    return BCM_E_UNAVAIL;
}

int
bcm_esw_field_qualify_DstCompressionClassId(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}

#endif  /* !BCM_FIELD_SUPPORT */
#endif  /* !BCM_ESW_SUPPORT */
