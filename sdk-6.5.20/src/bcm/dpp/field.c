/*

 * 

 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * Module: Field Processor APIs
 *
 * Purpose:
 *     'Field Processor' (FP) API for Dune Soc_petra device using PPD
 */

#ifdef _ERR_MSG_MODULE_NAME
  #error "_ERR_MSG_MODULE_NAME redefined"
#endif

#define _ERR_MSG_MODULE_NAME BSL_BCM_FP

#include <shared/bsl.h>

#include "bcm_int/common/debug.h"

#include <bcm/types.h>
#include <bcm/debug.h>
#include <bcm/error.h>
#include <bcm/field.h>
#include <bcm/mirror.h>
#include <bcm/stack.h>
#include <bcm/switch.h>
#include <bcm/stg.h>

#include <soc/drv.h>
#include <bcm_int/dpp/alloc_mngr_utils.h>
#include <bcm_int/dpp/field_int.h>
#include <bcm_int/dpp/error.h>
#include <bcm_int/dpp/utils.h>
#include <bcm_int/dpp/gport_mgmt.h>
#include <bcm_int/dpp/counters.h>
#include <bcm_int/dpp/l3.h>
#include <bcm_int/dpp/rx.h>
#include <bcm_int/dpp/switch.h>
#include <soc/dpp/PPC/ppc_api_trap_mgmt.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_general.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_fp_key.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_dbal.h>
#include <soc/dpp/ARAD/arad_ports.h>
#include <soc/dpp/SAND/Management/sand_low_level.h>
#include <shared/bitop.h>
#include <sal/types.h>
#include <bcm_int/dpp/port.h>

#include <soc/dpp/port_sw_db.h>
#include <soc/dpp/mbcm.h>

#include <soc/dcmn/dcmn_wb.h>

#include <soc/dpp/mbcm_pp.h>

#include <shared/swstate/access/sw_state_access.h>
#include <shared/swstate/sw_state_sync_db.h>

/*
 *  For now, if _BCM_DPP_FIELD_WARM_BOOT_SUPPORT is FALSE, disable warm boot
 *  support here.
 */
#ifdef BCM_WARM_BOOT_SUPPORT
#if !_BCM_DPP_FIELD_WARM_BOOT_SUPPORT
#undef BCM_WARM_BOOT_SUPPORT
#endif  /* BCM_WARM_BOOT_SUPPORT */
#endif /* !_BCM_DPP_FIELD_WARM_BOOT_SUPPORT */

/*
 *  A note about locking:
 *
 *  This module uses one lock per unit (plus there is a lock used by the list
 *  manager when managing 'ranges', plus one lock that is only used to protect
 *  resources global to all units). This unit lock prevents multiple concurrent
 *  transactions against a specific unit. However, this granularity is possibly
 *  suboptimal in some cases (such as those cases where only a group or entry
 *  or range is being manipulated), though not in all (locks for range, entry,
 *  and group would have to be taken when committing changes to the hardware;
 *  for group and entry when inserting/removing entries; &c). It is possible
 *  that a finer granularity could be used, but this means more complicated
 *  locking process and additional resources per unit.  The lock per unit
 *  method was chosen primarily to control complexity, but it also has the
 *  advantage of not needing as many resources.
 */

/*
 *  Entry priority at the BCM layer is maintained strictly by the sort order of
 *  the entries in each group.  This means that the entries within a group at
 *  the BCM layer occur in exactly the order they must have in hardware.
 *  Hopefully this prevents certain sorting issues.  The BCM layer priority has
 *  its own quirks, though, such as the way multiple entries with the same
 *  priority are handled -- the last one to be added gets the lowest 'implied'
 *  priority, with the earlier entries above it (and so on).  This peculiarity
 *  only extends to entries, since the groups must all have unique priority...
 *
 *  However, the PPD has its own idea of priority, and unlike BCM, PPD requires
 *  a 'strict' priority order -- that is, no two entries can have the same
 *  priority.  While this is better as far as coding it (prevents such
 *  ambiguities as insertion order being used to decide relative priority), it
 *  means that we have to map the priorities between the layers.
 *
 *  So, in order to keep things 'simple', the BCM layer is limited to priority
 *  values 0..n where n is one lower than the maximum number of entries
 *  supported, while the PPD priority is mapped based upon a 'phase' plus the
 *  absolute position of the entry within the group.  This allows us to do an
 *  in-place update of an entire group with minimal compromise to the behaviour
 *  of the rules (since we can ripple update in either up or down direction
 *  according to the new phase).  It does, however, result in a rippled glitch
 *  where the currently updating rule will disappear from the hardware for a
 *  moment and then come back with its new priority.
 *
 *  When the phase is even, PPD layer priorities 0..8K-1 are used; when the
 *  phase is odd, PPD layer priorities 8K..16K-1 are used.  Basically this
 *  means that transition 0->1 means we ripple from low priority to high
 *  priority entries (lowest priority gets updated first); transition 1->0
 *  ripples from high to low priority (highest priority gets updated first).
 *  The ripple direction also allows entry priority to be maintained through
 *  the entire update process.
 *
 *  Phase transitions are required when entries are added, or when entries that
 *  are already in hardware reordered (BCM API allows entry priority to change
 *  after creation, something it does not allow for groups).  The phase
 *  transition is required because we will need to insert the entry to the
 *  position in hardware appropriate to its new position in the entry list.
 *
 *  When only committing a single entry, if that entry is NOT new (it was
 *  around during the last phase transition), we can use its existing priority
 *  value, and just write the entry.  But if the entry is new (was not around
 *  during the last phase transition), we must perform a phase transition to
 *  add the entry to hardware.  This means it can easily be an *extremely* time
 *  consuming process to add entries to hardware one at a time.  The group
 *  insert feature is intended for this.
 *
 *  Removing a single entry can always be done in-place, without a phase
 *  transition.  In addition, we can leave the entry priority alone if the
 *  entry is not also being destroyed, thus allowing in-place reinsertion at a
 *  later point without requiring a phase transition.
 */

/*
 *  The old 'counters' concept is pretty simple and does not expose much to the
 *  application layer -- counters are created and attached to an entry in a
 *  single act, they can be shared between entries by using the counter sharing
 *  functions, and counters can be removed from an entry by using the somewhat
 *  unintuitive counter destroy function (which actually only removes the entry
 *  from the list of entries using the counter and finally releases the counter
 *  when there are no more entries sharing it).  Also, counters are
 *  specifically defined as *not* automatically running; they require an
 *  explicit action be attached to entries before anything should happen.
 *
 *  The new 'stats' APIs are a little more interesting.  The application
 *  manages them, and so we can't so easily hide their management (at least in
 *  terms of alloc and free), but we have no need to muck about with the
 *  sharing chains or similar.  Also, there is no explicit action needed, so
 *  merely associating a stat set with an entry means it takes effect
 *  immediately.  Furthermore, the stats definition allows better exposure of
 *  certain aspects of the statistics.  The most obvious issue is that we now
 *  need to keep track of reference counts to stat sets, since the application
 *  can easily alloc/free them and arbitrarily shift associations of stat sets
 *  to entries, including having single or multiple entries for a single set.
 *
 *  Instead of tracking a reference count as such for the counters used for
 *  stats, we link them into lists like we do when sharing counters used for
 *  the counter action.  The counter action lists are only attached to entries,
 *  but we need a base table for the counters used for stats, since the stats
 *  are not implicitly attached to entries (must be explicitly attached by the
 *  application).  So, there is a table with one entry per counter set that
 *  points to the head of the list of entries that use that counter set for
 *  stats work.  In the case of counter sets not used for stats, the pointer in
 *  the table contains 'entries + 1' and for the case of a counter set that is
 *  allocated for stats but not yet joined to any entries, the table contains
 *  'entries' for this pointer (note it's not a literal pointer but an element
 *  ID in the entry table).
 */

/*
 *  Deletion of a qualifier is inferred by this code if the underlying hardware
 *  qualifier ends up with zero mask and zero data (so the qualifier does not
 *  matter).  In this case, the code will simply remove the qualifier from the
 *  BCM layer.
 *
 *  The bcm_petra_field_qualifier_delete function simply takes advantage of
 *  this feature for the standard qualifiers, but does not cover the
 *  programmable qualifiers.
 *
 *  The programmable qualifiers can still be removed by setting both their mask
 *  and data to all zeroes.
 *
 *  Note, that this is merely cosmetic and affects only the BCM layer; the PPD
 *  layer keeps track of all qualifiers for every entry -- even qualifiers
 *  whose mask and data are zero (so they do not matter) are maintained.
 */


/******************************************************************************
 *
 *  Configuration
 */


/******************************************************************************
 *
 *  Local functions and data
 */

/* Global lock, for protecting unit init and detach functions */
static volatile sal_mutex_t _bcm_dpp_field_glob_lock = NULL;

/*
 *  Group priority limit -- we limit group priority to the same range as the
 *  PPD, even though the meaning is inverted, so the mapping is simple.
 */
#define _BCM_PETRA_FIELD_GROUP_PRIOS 1024

/*
 *  Switches...
 *
 *  _BCM_DPP_FIELD_ENFORCE_WIDTH controls whether groups created with a 'width'
 *  will be constrained to the specified 'width'.  This needs to be FALSE for
 *  the purpose of the regressions, which assume far wider TCAMs than are used
 *  on Soc_petra (at least 96 trits per 'width' versus 72 on the Soc_petra), but maybe
 *  should be TRUE for normal operation?  Note the maximum width of 288 is
 *  still enforced by the code; only the width specified by the caller is
 *  ignored.
 *
 *  _BCM_PETRA_ALLOW_ACTIVE_STAT_DESTRUCTION controls whether active (in-use)
 *  stats sets can be destroyed.  If TRUE, they can be destroyed and the API
 *  will clean up references to them (but does not automatically commit the
 *  changed entries).  If FALSE, the API will refuse to destroy a set of stats
 *  to which any entry is referring.
 *
 *  _BCM_PETRA_ALLOW_CACHED_STAT_WRITE controls whether setting the field
 *  control bcmFieldControlStatSyncEnable to FALSE will switch to cached writes
 *  of statistics.  Cached read may lag behind real values but it is 'safe' in
 *  the sense that it provides coherent and expected values (at least up to the
 *  point of the last ejection of the requested counter); while cached read may
 *  not show traffic since the last ejection immediately, it will eventually
 *  show that traffic when the counter is ejected again later.  Cached write is
 *  not 'safe' in this sense because the write applies retroactively in cached
 *  mode, to the time of the last counter ejection, so this means frames that
 *  passed between the last counter ejection and the write will be counted as
 *  having occurred *after* the write instead of *before*.  The field control
 *  bcmFieldControlStatSyncEnable will always apply to reads.
 */
#define _BCM_DPP_FIELD_ENFORCE_WIDTH FALSE
#define _BCM_PETRA_ALLOW_CACHED_STAT_WRITE FALSE

bcm_dpp_field_info_OLD_t *_bcm_dpp_field_unit_info[BCM_MAX_NUM_UNITS];

/*
 *  For now, this is hardcoded.  Once traps are managed, need to update the
 *  init function to acquire a trap properly.
 */


/*
 * Qualifier info struct to use for bcmFieldQualifyL2Learn when 
 * Direct Extraction action required L2Learn qulifier for the action
 * must be 1b
 * SOC property custom_feature_l3_learn_force_in_fwd is set (==1). 
 * or 
 * SOC property custom_feature_IVL_inlif_profile is set (==1). 
 */
static const _bcm_arad_field_device_qual_info_layer_t restricted_l2_learn_type_qual_info = 
    { bcmFieldQualifyL2Learn, -1, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPC_FP_QUAL_INGRESS_LEARN_ENABLE,           SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_INGRESS_LEARN_ENABLE,           SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_INGRESS_LEARN_ENABLE,           SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_INGRESS_LEARN_ENABLE,           SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,

        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,

        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,

        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                      SOC_PPC_NOF_FP_QUAL_TYPES
    };
/*
 * Qualifier info struct to use for bcmFieldQualifyForwardingType when 
 * SOC property custom_feature_fp_restricted_forwarding_type is set. 
 */
static const _bcm_arad_field_device_qual_info_layer_t restricted_forwarding_type_qual_info = 
    { bcmFieldQualifyForwardingType, -1, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_HEADER_CODE,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_HEADER_CODE,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_HEADER_CODE,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_HEADER_CODE,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_HEADER_CODE,                      SOC_PPC_NOF_FP_QUAL_TYPES
    };

/*
 * Action info struct to use for bcmFieldActionClassDestSet when
 * SOC property custom_feature_IVL_inlif_profile is set (==1). 
 */
static const _bcm_arad_field_device_action_info_layer_t restricted_class_dest_set_action =
    { bcmFieldActionClassDestSet,
        SOC_PPC_FP_ACTION_TYPE_USER_HEADER_1,       SOC_PPC_FP_ACTION_TYPE_USER_HEADER_2,
        SOC_PPC_NOF_FP_ACTION_TYPES,                SOC_PPC_NOF_FP_ACTION_TYPES,
        SOC_PPC_NOF_FP_ACTION_TYPES,                SOC_PPC_NOF_FP_ACTION_TYPES,
        SOC_PPC_NOF_FP_ACTION_TYPES,                SOC_PPC_NOF_FP_ACTION_TYPES
    };

/*
 * Action info struct to use for bcmFieldActionForwardingTypeNew when
 * SOC property custom_feature_l3_uc_with_rpf_2pass_enabled is set.
 */
static const _bcm_arad_field_device_action_info_layer_t restricted_action_type_act_info =
    { bcmFieldActionForwardingTypeNew,
        SOC_PPC_FP_ACTION_TYPE_FWD_CODE,        SOC_PPC_NOF_FP_ACTION_TYPES,
        SOC_PPC_NOF_FP_ACTION_TYPES,            SOC_PPC_NOF_FP_ACTION_TYPES,
        SOC_PPC_NOF_FP_ACTION_TYPES,            SOC_PPC_NOF_FP_ACTION_TYPES,
        SOC_PPC_NOF_FP_ACTION_TYPES,            SOC_PPC_NOF_FP_ACTION_TYPES
    };

static const _bcm_arad_field_device_qual_info_layer_t classId_as_vlan_domain_qual_info = 
     { bcmFieldQualifyClassId, -1, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPC_FP_QUAL_VLAN_DOMAIN,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_DOMAIN,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_DOMAIN,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_DOMAIN,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_DOMAIN,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES
    };

static const _bcm_arad_field_device_qual_info_layer_t SrcClassField_as_vlan_domain_qual_info =
     { bcmFieldQualifySrcClassField, 8, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPC_FP_QUAL_VLAN_DOMAIN,            SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_DOMAIN,            SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_DOMAIN,            SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_DOMAIN,            SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_DOMAIN,            SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,              SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,              SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,              SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,              SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,              SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,              SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,              SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,              SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,              SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,              SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_SYS_VALUE2,        SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_SYS_VALUE2,        SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_SYS_VALUE2,        SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_SYS_VALUE2,        SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,              SOC_PPC_NOF_FP_QUAL_TYPES
    };

static const _bcm_arad_field_device_qual_info_layer_t OuterVlanActionRange_as_outer_vid_qual_info = 
    { bcmFieldQualifyOuterVlanActionRange, 12, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPC_FP_QUAL_CMPRSD_OUTER_VID,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_OUTER_VID,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_OUTER_VID,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_OUTER_VID,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_OUTER_VID,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES
    };

static const _bcm_arad_field_device_qual_info_layer_t TranslatedOuterVlanId_as_cmprsd_outer_vid_qual_info = 
    { bcmFieldQualifyTranslatedOuterVlanId, 12, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPC_FP_QUAL_CMPRSD_OUTER_VID,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_OUTER_VID,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_OUTER_VID,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_OUTER_VID,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_EDIT_CMD_VID1,                    SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_EDIT_CMD_VID1,                    SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_EDIT_CMD_VID1,                    SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_EDIT_CMD_VID1,                    SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_NWK_RCRD_FHEI_ETH_OUTER_TAG_ID,        SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_NWK_RCRD_FHEI_ETH_OUTER_TAG_ID,        SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_NWK_RCRD_FHEI_ETH_OUTER_TAG_ID,        SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_NWK_RCRD_FHEI_ETH_OUTER_TAG_ID,        SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES
    };

static const _bcm_arad_field_device_qual_info_layer_t OamInLifId_as_double_tag_hdr_ethertype_qual_info = 
    { bcmFieldQualifyOamInLifId, 16, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPC_FP_QUAL_DOUBLE_TAG_HDR_ETHERTYPE,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_DOUBLE_TAG_HDR_ETHERTYPE,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_DOUBLE_TAG_HDR_ETHERTYPE,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_DOUBLE_TAG_HDR_ETHERTYPE,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_DOUBLE_TAG_HDR_ETHERTYPE,   SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VTT_OAM_LIF,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VTT_OAM_LIF,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VTT_OAM_LIF,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VTT_OAM_LIF,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES
    };

static const _bcm_arad_field_device_qual_info_layer_t TranslatedInnerVlanId_as_cmprsd_inner_vid_qual_info = 
    { bcmFieldQualifyTranslatedInnerVlanId, 12, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPC_FP_QUAL_CMPRSD_INNER_VID,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_INNER_VID,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_INNER_VID,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_INNER_VID,                      SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_EDIT_CMD_VID2,                    SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_EDIT_CMD_VID2,                    SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_EDIT_CMD_VID2,                    SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_VLAN_EDIT_CMD_VID2,                    SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_NWK_RCRD_FHEI_ETH_INNER_TAG_ID,        SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_NWK_RCRD_FHEI_ETH_INNER_TAG_ID,        SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_NWK_RCRD_FHEI_ETH_INNER_TAG_ID,        SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_ERPP_NWK_RCRD_FHEI_ETH_INNER_TAG_ID,        SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,                             SOC_PPC_NOF_FP_QUAL_TYPES
    };

static const _bcm_arad_field_device_qual_info_layer_t InnerVlanActionRange_as_inner_vid_qual_info = 
    { bcmFieldQualifyInnerVlanActionRange, 12, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPC_FP_QUAL_CMPRSD_INNER_VID,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_INNER_VID,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_INNER_VID,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_INNER_VID,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_FP_QUAL_CMPRSD_INNER_VID,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES,
        SOC_PPC_NOF_FP_QUAL_TYPES,  SOC_PPC_NOF_FP_QUAL_TYPES
    };

static const _bcm_arad_field_device_action_info_layer_t Drop_Action_info =
    { bcmFieldActionDrop,
        SOC_PPC_FP_ACTION_TYPE_DEST_DROP,       SOC_PPC_NOF_FP_ACTION_TYPES,
        SOC_PPC_FP_ACTION_TYPE_EGR_TRAP,        SOC_PPC_NOF_FP_ACTION_TYPES,
        SOC_PPC_NOF_FP_ACTION_TYPES,            SOC_PPC_NOF_FP_ACTION_TYPES,
        SOC_PPC_NOF_FP_ACTION_TYPES,            SOC_PPC_NOF_FP_ACTION_TYPES
    };

static const _bcm_arad_field_device_action_info_layer_t Drop_Precedence_Action_info =

    { bcmFieldActionDropPrecedence,
        SOC_PPC_FP_ACTION_TYPE_DP,              SOC_PPC_NOF_FP_ACTION_TYPES,
        SOC_PPC_FP_ACTION_TYPE_DP,              SOC_PPC_NOF_FP_ACTION_TYPES,
        SOC_PPC_NOF_FP_ACTION_TYPES,            SOC_PPC_NOF_FP_ACTION_TYPES,
        SOC_PPC_NOF_FP_ACTION_TYPES,            SOC_PPC_NOF_FP_ACTION_TYPES
    };

static const SOC_PPC_FP_ACTION_TYPE    non_changeable_width_actions[] =

    {   SOC_PPC_FP_ACTION_TYPE_TRAP_REDUCED,
        SOC_PPC_FP_ACTION_TYPE_DEST_DROP,
        SOC_PPC_FP_ACTION_TYPE_UNKNOWN_ADDR,
        SOC_PPC_FP_ACTION_TYPE_INGRESS_LEARN_ENABLE,
        SOC_PPC_FP_ACTION_TYPE_EXC_SRC,
        SOC_PPC_FP_ACTION_TYPE_ORIENTATION_IS_HUB,
        SOC_PPC_FP_ACTION_TYPE_PACKET_IS_BOOTP_DHCP,
        SOC_PPC_FP_ACTION_TYPE_IGNORE_CP,
        SOC_PPC_FP_ACTION_TYPE_FWD_CODE,
        SOC_PPC_FP_ACTION_TYPE_MIR_DIS,
        SOC_PPC_FP_ACTION_TYPE_PPH_TYPE,
        SOC_PPC_FP_ACTION_TYPE_IEEE_1588,
        SOC_PPC_FP_ACTION_TYPE_SNOOP_AND_TRAP,
        SOC_PPC_NOF_FP_ACTION_TYPES,
    };
#define _BCM_DPP_FIELD_MAX_NOF_QUALS_IN_QSET                   (16)

/* predefined group status */
#define _BCM_DPP_PREDEF_GRP_STATUS_UNAVAILABLE     0
#define _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE    1
#define _BCM_DPP_PREDEF_GRP_STATUS_IN_USE          2


typedef struct _bcm_field_predefined_groups_info_s {
    uint32              table_type; /* defined in _bcm_field_vt_classification_table_type_t / _bcm_field_flp_classification_table_type_t */
    uint32              internal_table_id; /* the table ID used in the DBAL */
    uint8               group_id; /* BCM group ID if not -1, the required group ID to match (this way we can identify the group by ID and not by qset ) */
    uint8               nof_quals; /* num of quals in qset */    
    bcm_field_qualify_t bcmQual_array[_BCM_DPP_FIELD_MAX_NOF_QUALS_IN_QSET];   /* qualifiers in qset  */    
} _bcm_field_predefined_groups_info_t;


static 
_bcm_field_predefined_groups_info_t vt_predefined_groups_info[_BCM_DPP_VT_CLASS_COUNT] = {            
            /* type                                |table_id| grp_id |nof quals| qset */
        { _BCM_DPP_VT_CLASS_IPV4_MATCH          ,     SOC_DPP_DBAL_SW_TABLE_ID_5_TUPPLE_TCAM                ,      -1,        5,   {bcmFieldQualifySrcIp, bcmFieldQualifyDstIp, bcmFieldQualifyL4SrcPort, bcmFieldQualifyL4DstPort, bcmFieldQualifyIpProtocol } },
        { _BCM_DPP_VT_CLASS_EFP                 ,     SOC_DPP_DBAL_SW_TABLE_ID_TST1_TCAM_SKELETON           ,      -1,        8,   {bcmFieldQualifyOuterVlanId , bcmFieldQualifyInnerVlanId, bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanActionRange, bcmFieldQualifyInnerVlanActionRange, bcmFieldQualifyOuterVlanPri, bcmFieldQualifyOuterVlanCfi, bcmFieldQualifyEtherType }},
        { _BCM_DPP_VT_CLASS_VRRP                ,     SOC_DPP_DBAL_SW_TABLE_ID_DOUBLE_TAG_VRRP_TCAM         ,      -1,        5,   {bcmFieldQualifyTranslatedOuterVlanId, bcmFieldQualifySrcClassField, bcmFieldQualifyTranslatedInnerVlanId, bcmFieldQualifyDstMac,bcmFieldQualifyOamInLifId }},
        { _BCM_DPP_VT_QINQ_COMPRESSED_OUTER     ,     SOC_DPP_DBAL_SW_TABLE_ID_QINQ_COMPRESSED_TPID1_SEM_A  ,      -1,        3,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId, bcmFieldQualifyInnerVlanActionRange  }},
        { _BCM_DPP_VT_QINQ_COMPRESSED_INNER     ,     SOC_DPP_DBAL_SW_TABLE_ID_QINQ_COMPRESSED_TPID2_SEM_A  ,      -1,        3,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId, bcmFieldQualifyInnerVlanActionRange  }},
        { _BCM_DPP_VT_QINANY_OUTER              ,     SOC_DPP_DBAL_SW_TABLE_ID_QINANY_TPID1_SEM_B           ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId                                       }},
        { _BCM_DPP_VT_QINANY_INNER              ,     SOC_DPP_DBAL_SW_TABLE_ID_QINANY_TPID2_SEM_B           ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId                                       }},
        { _BCM_DPP_VT_QINANY_PCP_OUTER          ,     SOC_DPP_DBAL_SW_TABLE_ID_QINANY_PCP_TPID1_SEM_A       ,      -1,        3,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId, bcmFieldQualifyOuterVlanPriCfi          }},
        { _BCM_DPP_VT_QINANY_PCP_INNER          ,     SOC_DPP_DBAL_SW_TABLE_ID_QINANY_PCP_TPID2_SEM_A       ,      -1,        3,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId, bcmFieldQualifyOuterVlanPriCfi          }},
        { _BCM_DPP_VT_DOT1Q_OUTER               ,     SOC_DPP_DBAL_SW_TABLE_ID_1Q_TPID1_SEM_A               ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId                                       }},
        { _BCM_DPP_VT_DOT1Q_INNER               ,     SOC_DPP_DBAL_SW_TABLE_ID_1Q_TPID2_SEM_A               ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId                                       }},
        { _BCM_DPP_VT_DOT1Q_COMPRESSED_OUTER    ,     SOC_DPP_DBAL_SW_TABLE_ID_1Q_COMPRESSED_TPID1_SEM_B    ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanActionRange                              }},
        { _BCM_DPP_VT_DOT1Q_COMPRESSED_INNER    ,     SOC_DPP_DBAL_SW_TABLE_ID_1Q_COMPRESSED_TPID2_SEM_B    ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanActionRange                              }},
        { _BCM_DPP_VT_DOT1Q_COMPRESSED_PCP_OUTER,     SOC_DPP_DBAL_SW_TABLE_ID_1Q_PCP_COMPRESSED_TPID1_SEM_A,      -1,        3,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanPriCfi, bcmFieldQualifyOuterVlanActionRange }},
        { _BCM_DPP_VT_DOT1Q_COMPRESSED_PCP_INNER,     SOC_DPP_DBAL_SW_TABLE_ID_1Q_PCP_COMPRESSED_TPID2_SEM_A,      -1,        3,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanPriCfi, bcmFieldQualifyOuterVlanActionRange }},
        { _BCM_DPP_VT_UNTAGGED                  ,     SOC_DPP_DBAL_SW_TABLE_ID_UNTAGGED_SEM_A               ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId                                          }},
        { _BCM_DPP_VT_TST2                      ,     SOC_DPP_DBAL_SW_TABLE_ID_TST2_TCAM                    ,      -1,        5,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId, bcmFieldQualifyOuterVlanPriCfi, bcmFieldQualifyOuterTpid, bcmFieldQualifyInnerVlanId}},
        { _BCM_DPP_VT_TEST2                     ,     SOC_DPP_DBAL_SW_TABLE_ID_TEST2_TCAM                   ,      -1,        2,   {bcmFieldQualifyInPort,  bcmFieldQualifyDstMac                                         }},
        { _BCM_DPP_VT_PORT_DA                   ,     SOC_DPP_DBAL_SW_TABLE_ID_SRC_PORT_DA_OUTER_VID_TCAM   ,      -1,        3,   {bcmFieldQualifyOuterVlanId,  bcmFieldQualifyInPort , bcmFieldQualifyDstMac              }},
};

/* BCM layer action to define if it is valid or nor according to sys property */ 
uint8 vt_predefined_groups_status[BCM_MAX_NUM_UNITS][_BCM_DPP_VT_CLASS_COUNT] = {{_BCM_DPP_PREDEF_GRP_STATUS_UNAVAILABLE}};/* _BCM_DPP_PREDEF_GRP_STATUS_UNAVAILABLE must be 0*/   


static 
_bcm_field_predefined_groups_info_t flp_predefined_groups_info[_BCM_DPP_FLP_CLASS_COUNT] = {            
            /* type                               |table_id                                      |grp_id|nof quals| temporary qset */
        { _BCM_DPP_FLP_CLASS_IPV4_MPLS_EXTENDED,   _BCM_DPP_INTERNAL_TABLE_ID_EXTENDED_IPV4_MPLS,    -1,      6,   {bcmFieldQualifyStageExternal, bcmFieldQualifyMplsForwardingLabelExp, bcmFieldQualifyMplsForwardingLabelId, bcmFieldQualifyMplsForwardingLabelBos, bcmFieldQualifyVrf, bcmFieldQualifyDstIp }},
/*~key*/{ _BCM_DPP_FLP_CLASS_IPV6_EXTENDED,        _BCM_DPP_INTERNAL_TABLE_ID_EXTENDED_IPV6,         -1,      3,   {bcmFieldQualifyStageExternal, bcmFieldQualifyVrf, bcmFieldQualifyDstIp6}},
/*~key*/{ _BCM_DPP_FLP_CLASS_P2P_EXTENDED,         _BCM_DPP_INTERNAL_TABLE_ID_EXTENDED_P2P,          -1,      2,   {bcmFieldQualifyStageExternal, bcmFieldQualifyInVPort}},
        { _BCM_DPP_FLP_CLASS_IPV4_MC_FLEXIBLE,     _BCM_DPP_INTERNAL_TABLE_ID_EXTENDED_IPV4_MC,      -1,      5,   {bcmFieldQualifyStageExternal, bcmFieldQualifyVrf, bcmFieldQualifyL3Ingress,  bcmFieldQualifySrcIp, bcmFieldQualifyDstIp}},
        { _BCM_DPP_FLP_CLASS_INRIF_MAPPING,        _BCM_DPP_INTERNAL_TABLE_ID_INRIF_MAPPING,         -1,      2,   {bcmFieldQualifyStageExternal, bcmFieldQualifyL3Ingress}},
        { _BCM_DPP_FLP_CLASS_IVL_LEARN,            SOC_DPP_DBAL_SW_TABLE_ID_IVL_FWD_OUTER_LEARN_LEM,           -1,      3,   {bcmFieldQualifyForwardHdrSrcMac, bcmFieldQualifyForwardingVlanId, bcmFieldQualifyForwardHdrVlanId}},
        { _BCM_DPP_FLP_CLASS_IVL_INNER_LEARN,      SOC_DPP_DBAL_SW_TABLE_ID_IVL_FWD_OUTER_LEARN_LEM,           -1,      3,   {bcmFieldQualifyForwardHdrSrcMac, bcmFieldQualifyForwardingVlanId, bcmFieldQualifyForwardHdrVlanId}},
        { _BCM_DPP_FLP_CLASS_IVL_FWD_OUTER_LEARN,  SOC_DPP_DBAL_SW_TABLE_ID_IVL_FWD_OUTER_LEARN_LEM,           -1,      3,   {bcmFieldQualifyForwardHdrSrcMac, bcmFieldQualifyForwardingVlanId, bcmFieldQualifyForwardHdrVlanId}},
};

/* BCM layer action to define if it is valid or nor according to sys property */ 
uint8 flp_predefined_groups_status[BCM_MAX_NUM_UNITS][_BCM_DPP_FLP_CLASS_COUNT] = {{_BCM_DPP_PREDEF_GRP_STATUS_UNAVAILABLE}}; /* _BCM_DPP_PREDEF_GRP_STATUS_UNAVAILABLE must be 0*/


/* Max number of possible TCAM entries to configure before installing to HW.
   Limit applies to external TCAM only. */
#ifndef _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES
#define _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES(unit)     SOC_DPP_DEFS_GET_NOF_ENTRY_IDS(unit)
#endif


#define  _BCM_DPP_FIELD_FHEI_SIZE_0_BYTES (0)
#define  _BCM_DPP_FIELD_FHEI_SIZE_3_BYTES (3)
#define  _BCM_DPP_FIELD_FHEI_SIZE_5_BYTES (5)
#define  _BCM_DPP_FIELD_FHEI_SIZE_8_BYTES (8)

#define  _BCM_DPP_FIELD_FHEI_SIZE_VALID(size) ( (size == _BCM_DPP_FIELD_FHEI_SIZE_0_BYTES) || \
                                                (size == _BCM_DPP_FIELD_FHEI_SIZE_3_BYTES) || \
                                                (size == _BCM_DPP_FIELD_FHEI_SIZE_5_BYTES) || \
                                                (size == _BCM_DPP_FIELD_FHEI_SIZE_8_BYTES) )

#define _BCM_DPP_FIELD_LARGE_DIRECT_LOOKUP_KEY_MIN  (SOC_DPP_DEFS_GET(unit, field_large_direct_lu_key_min_length))
#define _BCM_DPP_FIELD_LARGE_DIRECT_LOOKUP_KEY_MAX  (SOC_DPP_DEFS_GET(unit, field_large_direct_lu_key_max_length))

#define _BCM_DPP_FIELD_LARGE_DIRECT_LOOKUP_KEY_SIZE_VALID(size) ( (size >= _BCM_DPP_FIELD_LARGE_DIRECT_LOOKUP_KEY_MIN) && \
                                                                  (size <= _BCM_DPP_FIELD_LARGE_DIRECT_LOOKUP_KEY_MAX) )



/******************************************************************************
 *
 *  Implementation exported functions and data
 */


extern int
_bcm_dpp_field_presel_alloc(bcm_dpp_field_info_OLD_t *unitData,
                            bcm_field_stage_t        stage,
                            _bcm_dpp_field_presel_alloc_flags_t flags,
                            bcm_field_presel_t *presel,
                            _bcm_dpp_field_program_idx_t program_id);

int _BCM_DPP_FIELD_ENT_IS_EXTTCAM(int unit, int _entry)
{
    _bcm_dpp_field_ent_idx_t entryExtTcLimit;
    BCMDNX_INIT_FUNC_DEFS;

     BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryExtTcLimit.get(unit, &entryExtTcLimit));
     return (((_BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam) <= _entry) && ((entryExtTcLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam)) > _entry))? TRUE: FALSE);
 exit:
     BCMDNX_FUNC_RETURN;

}

int _BCM_DPP_FIELD_ENT_IS_INTTCAM(int unit, int _entry)
{
    _bcm_dpp_field_ent_idx_t entryTcLimit;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryTcLimit.get(unit, &entryTcLimit));
    return ((/* causes CONSTANT_EXPRESSION_RESULT Coverity defect
        * because _bcmDppFieldEntryTypeInternalTcam is 0.
        * if in the feature this value is changed - reinsert it
      (_BCM_DPP_FIELD_ENT_BIAS(unit, InternalTcam) <= _entry) && */    ((entryTcLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, InternalTcam)) > _entry))? TRUE: FALSE);
exit:
    BCMDNX_FUNC_RETURN;

}

int _BCM_DPP_FIELD_ENT_IS_DIR_EXT(int unit, int _entry)
{
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));

    return (((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= _entry) && ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) > _entry))? TRUE: FALSE);
exit:
    BCMDNX_FUNC_RETURN;
}

int _BCM_DPP_FIELD_ENT_IS_KAPS_ADVANCED_MODE(int unit, _bcm_dpp_field_grp_idx_t entryGroup)
{
    uint32 groupD_groupFlags;
    bcm_field_group_mode_t groupD_grpMode;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, entryGroup, &groupD_groupFlags));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.get(unit, entryGroup, &groupD_grpMode));

    if (SOC_IS_JERICHO(unit) &&
        (SOC_DPP_JER_CONFIG(unit)->pp.kaps_mgmt_advanced_mode == TRUE) &&
        (groupD_groupFlags & _BCM_DPP_FIELD_GROUP_LARGE) &&
        (groupD_grpMode == bcmFieldGroupModeDirect)) {
        return TRUE;
    }

    return FALSE;

 exit:
     BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_proc_cntr_from_stat(int unit,
                             int stat,
                             unsigned int *proc,
                             unsigned int *cntr)
{
    unsigned int procs;
    unsigned int eproc;
    unsigned int ecntr;
    BCMDNX_INIT_FUNC_DEFS;


    ecntr = BCM_FIELD_STAT_ID_COUNTER_GET(stat);
    eproc = BCM_FIELD_STAT_ID_PROCESSOR_GET(stat);

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.counter.num_counter_procs.get(unit, &procs));

    if (eproc >= procs) 
        /* In Arad, possible Counter-Pointer size of 21b (for Stat-if) even if the Counter-Processor receives up to 15b */
        {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("unit %d stat %08X is not valid"),
                          unit,
                          stat));
    }
    *proc = eproc;
    *cntr = ecntr;
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function
 *      is_ppc_action_width_changeable
 * Purpose
 *     For the given ppc_action, returns FALSE if pcc_action is
 *     not of changeable width, or TRUE otherwise, depends on
 *     non_changeable_width_actions global array to determine
 *     which actions are changeable.
 * Parameters
 *      (in) SOC_PPC_FP_ACTION_TYPE  ppc_action = the action
 */
STATIC SOC_PPC_FP_ACTION_TYPE is_ppc_action_width_changeable(int ppc_action) {
    int action_ndx;
    for (action_ndx = 0; non_changeable_width_actions[action_ndx] != SOC_PPC_NOF_FP_ACTION_TYPES; action_ndx++) {
        if (non_changeable_width_actions[action_ndx] == ppc_action) {
            return FALSE;
        }
    }
    return TRUE;
}

/*
 *   Function
 *      _bcm_dpp_stat_from_proc_cntr
 *   Purpose
 *      encode stat id from proc and ctr
 *   Parameters
 *      (in) int            unit = the unit
 *      (in) unsigned int   proc = the processor
 *      (in) unsigned int   cntr = the cntr index
 *      (out)int            *stat
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if sccessful
 *                    BCM_E_* appropriately otherwise
 */
STATIC int
_bcm_dpp_stat_from_proc_cntr(int unit,
                             unsigned int proc,
                             unsigned int cntr,
                             uint32 *stat) {

    BCMDNX_INIT_FUNC_DEFS;
    
    BCM_FIELD_STAT_ID_SET(*stat, proc, cntr);

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_dpp_field_get_dev_info(int unit, const _bcm_dpp_field_device_info_t **devInfo)
{
    _bcm_dpp_field_device_info_t *tmp_dev_ptr;
    BCMDNX_INIT_FUNC_DEFS;
    if (!(SOC_DPP_IS_ELK_ENABLE(unit))) {
        tmp_dev_ptr = &_bcm_arad_field_device_info;
        /* Set max number of external entries like INCLUDE_KBP compilation flag is not defined */
        tmp_dev_ptr->stage[SOC_PPC_FP_DATABASE_STAGE_INGRESS_PMF].maxEntriesExternalTcam = 2;
    }
    if (SOC_IS_JERICHO(unit)) {
        tmp_dev_ptr = &_bcm_arad_field_device_info;
        tmp_dev_ptr->cascadeKeyLimit = 20;
    }
    *devInfo = &_bcm_arad_field_device_info;
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 *   Function
 *      _bcm_dpp_field_entry_ppd_to_bcm
 *   Purpose
 *      Given a PPD entry ID (hwHandle) find the corresponding BCM entry ID.
 *   Parameters
 *    (in) unitData = the unit information
 *    (in) hwHandle = the PPD entry ID
 *    (out) bcm_entry = the BCM entry ID
 *    (out) found = indication if entry was founds
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if successful
 *        BCM_E_* appropriately if not
 */
int
_bcm_dpp_field_entry_ppd_to_bcm(int unit,
                                uint32 hwHandle,
                                bcm_field_entry_t *bcm_entry,
                                uint8 *found)
{
    int ent_index;
    _bcm_dpp_field_ent_idx_t entryTcLimit;
    _DPP_FIELD_COMMON_LOCALS;
    int dpp_field_unit_lock_was_taken = 0;
    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    *found = FALSE;

    /* for each valid BCM entry, check if the corresponding
     * PPD entry is the one we're looking for
     */
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryTcLimit.get(unit, &entryTcLimit));
    for ( ent_index = 0;
          ent_index < entryTcLimit;
          ent_index++ )
    {
        if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, ent_index)
            && _BCM_DPP_FIELD_ENT_IS_INTTCAM(unit, ent_index))
        {
            uint32 localEntryFlags ;
            uint32 localHwHandle;                            /* entry handle in hardware */
            /*
             * was:
             *   if (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(FALSE, ent_index) & _BCM_DPP_FIELD_ENTRY_IN_USE)
             */
            BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit,FALSE, ent_index, localEntryFlags)) ;
            if (localEntryFlags & _BCM_DPP_FIELD_ENTRY_IN_USE)
            {
                BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_HW_HANDLE_GET(unit,FALSE, ent_index, localHwHandle)) ;
                /*
                 * Was:
                 *   if (_BCM_DPP_FIELD_TCAM_ENTRY_HW_HANDLE(FALSE, ent_index) == hwHandle)
                 */
                if (localHwHandle == hwHandle)
                {
                    *bcm_entry = ent_index;
                    *found = TRUE;
                    break;
                }
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}
/*
 *  The logic of using this procedure is changed to adapt to new sw state (NSS):
 *  A new parameter is added:
 *    int32 *entryCommonHandle,
 *  On this new parameter, memory pointed by 'entryCommonHandle' contains the 'index+1'
 *  to one of two arrays (specified by *entryType) as follows:
 *  For _bcmDppFieldEntryTypeInternalTcam: unitData->entryTc[index]
 *  For _bcmDppFieldEntryTypeExternalTcam: unitData->entryExtTc[index]
 *  For _bcmDppFieldEntryTypeDirExt      : unitData->entryDe[index]
 */
int
_bcm_dpp_field_entry_common_pointer(bcm_dpp_field_info_OLD_t *unitData,
                                    bcm_field_entry_t entry,
                                    _bcm_dpp_field_entry_type_t *entryType,
                                    int32 *entryCommonHandle)
{
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    
    unit = unitData->unit;
    if(entryCommonHandle) {
        *entryCommonHandle = 0 ;
    }
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));
    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        if(_BCM_DPP_FIELD_ENT_IS_INTTCAM(unit, entry)) {
            /*
             * Was:
             *   if (entryCommon) {
             *     *entryCommon = &(unitData->entryTc[_BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry)].entryCmn);
             */
            if (entryCommonHandle) {
                *entryCommonHandle = (int32)(_BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry) + 1) ;
            }
            if (entryType) {
                *entryType = _bcmDppFieldEntryTypeInternalTcam;
            }
        } else {
            /*
             * Was:
             *   if (entryCommon) {
             *     *entryExtCommon = &(unitData->entryExtTc[_BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry)].entryCmn);
             */
            if (entryCommonHandle) {
                *entryCommonHandle = (int32)(_BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry) + 1) ;
            }
            if (entryType) {
                *entryType = _bcmDppFieldEntryTypeExternalTcam;
            }
        }
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                  entry))  {
        if (entryCommonHandle) {
            *entryCommonHandle = entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) + 1;
        }
        /*
         * Was:
         *   if (entryCommon) {
         *       *entryCommon = &(unitData->entryDe[entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)].entryCmn);
         *   }
         */
        if (entryType) {
            *entryType = _bcmDppFieldEntryTypeDirExt;
        }
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d entry %d is not valid"),
                          unit,
                          entry));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_petra_field_unit_reset
 *   Purpose
 *      Reset the state of the unit at the PPD layer
 *   Parameters
 *      (in) int unit = the unit to reset
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if sccessful
 *                    BCM_E_* appropriately otherwise
 *   Notes
 *      This scans the PPD layer and frees resources.  It should not be used
 *      for detach, but must be used for cold init.
 *
 *      Assumes PPD sets up PFG 4 and DB 127 on Soc_petraB.
 *
 *      Only returns last error if more than one occurs.
 */
STATIC int
_bcm_petra_field_unit_reset(int unit)
{
    
    int result;
    int auxRes = BCM_E_NONE;
    uint32 handle;
    uint32 soc_sandResult;
    uint32 soc_sandIndex;
    uint32 soc_sandOffset;
    uint8 okay;
    SOC_PPC_FP_DATABASE_INFO dbInfo;
    SOC_PPC_FP_ENTRY_INFO entInfo;
    unsigned int entries;
    unsigned int groups;
    const _bcm_dpp_field_device_info_t *devInfo;
    BCMDNX_INIT_FUNC_DEFS;

    /* get the descriptor for this device */
    devInfo = &_bcm_arad_field_device_info;

    handle = (unit);
    entries = SOC_DPP_DEFS_GET_NOF_ENTRY_IDS(unit);
    groups = _BCM_PETRA_FIELD_GROUP_LIMIT(unit);
    /* walk the databases and destroy their entries, then the databases */
    for (soc_sandIndex = 0; soc_sandIndex < groups; soc_sandIndex++) {
        SOC_PPC_FP_DATABASE_INFO_clear(&dbInfo);
        soc_sandResult = soc_ppd_fp_database_get(handle,
                                                 soc_sandIndex,
                                                 &dbInfo);
        result = handle_sand_result(soc_sandResult);
        if (BCM_E_NONE == result) {
            if (SOC_PPC_NOF_FP_DATABASE_TYPES > dbInfo.db_type) {
                /* the type is valid, so it's in use[?] */
                if ((SOC_PPC_FP_DB_TYPE_TCAM == dbInfo.db_type) ||
                    (SOC_PPC_FP_DB_TYPE_EGRESS == dbInfo.db_type)) {
                    for (soc_sandOffset = 0;
                         soc_sandOffset < entries;
                         soc_sandOffset++) {
                        SOC_PPC_FP_ENTRY_INFO_clear(&entInfo);
                        soc_sandResult = soc_ppd_fp_entry_get(handle,
                                                              soc_sandIndex,
                                                              soc_sandOffset,
                                                              &okay,
                                                              &entInfo);
                        result = handle_sand_result(soc_sandResult);
                        if ((BCM_E_NONE == result) && okay) {
                            soc_sandResult = soc_ppd_fp_entry_remove(handle,
                                                                     soc_sandIndex,
                                                                     soc_sandOffset,
                                                                     0);
                            result = handle_sand_result(soc_sandResult);
                            if (BCM_E_NONE != result) {
                                LOG_ERROR(BSL_LS_BCM_FP,
                                          (BSL_META_U(unit,
                                                      "unable to destroy unit"
                                                      " %d database %d entry"
                                                      " %d: %d (%s)\n"),
                                           unit,
                                           soc_sandIndex,
                                           soc_sandOffset,
                                           result,
                                           _SHR_ERRMSG(result)));
                                auxRes = result;
                            }
                        } else { /* if ((BCM_E_NONE == result) && okay) */
                            LOG_ERROR(BSL_LS_BCM_FP,
                                      (BSL_META_U(unit,
                                                  "unable to get unit %d"
                                                  " database %d entry %d:"
                                                  " %d (%s)\n"),
                                       unit,
                                       soc_sandIndex,
                                       soc_sandOffset,
                                       result,
                                       _SHR_ERRMSG(result)));
                            auxRes = result;
                        } /* if ((BCM_E_NONE == result) && okay) */
                    } /* for (soc_sandOffset = 0; soc_sandOffset < 4K; soc_sandOffset++) */
                    soc_sandResult = soc_ppd_fp_database_destroy(handle,
                                                                 soc_sandIndex);
                    result = handle_sand_result(soc_sandResult);
                    if (BCM_E_NONE != result) {
                        LOG_ERROR(BSL_LS_BCM_FP,
                                  (BSL_META_U(unit,
                                              "unable to destroy unit %d"
                                              " database %d: %d (%s)\n"),
                                   unit,
                                   soc_sandIndex,
                                   result,
                                   _SHR_ERRMSG(result)));
                        auxRes = result;
                    }
                } else {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d database %d is unexpected"
                                          " type %d\n"),
                               unit,
                               soc_sandIndex,
                               dbInfo.db_type));
                    auxRes = BCM_E_INTERNAL;
                }
            } /* if (SOC_PPC_NOF_FP_DATABASE_TYPES > dbInfo.db_type) */
        } else { /* if (BCM_E_NONE == result) */
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unable to access unit %d database %d:"
                                  " %d (%s)\n"),
                       unit,
                       soc_sandIndex,
                       result,
                       _SHR_ERRMSG(result)));
            auxRes = result;
        } /* if (BCM_E_NONE == result) */
    } /* for (soc_sandIndex = 0; soc_sandIndex < 128; soc_sandIndex++) */
    /* clear data field qualifier definitions */
    result = _bcm_petra_field_data_qualifier_reset(unit);
    if (BCM_E_NONE != result) {
        auxRes = result;
    }
    /* clear range definitions */
    result = _bcm_dpp_field_range_reset(unit, handle, devInfo);
    if (BCM_E_NONE != result) {
        auxRes = result;
    }
    /* clear PFG definitions */
    result = _bcm_dpp_field_presel_reset(unit);
    if (BCM_E_NONE != result) {
        auxRes = result;
    }

    BCMDNX_IF_ERR_EXIT(auxRes);
exit:
    BCMDNX_FUNC_RETURN;
}

#if (0)
/* { */
This procedure is taken out for the sake of porting to new sw state. See below (in comments)

/*
 *  Function
 *     _bcm_dpp_field_entry_clear_quals
 *  Purpose
 *     Clear qualifiers from an entry.
 *  Parameters
 *     (in) unitData = the unit information
 *     (out) quals = pointer to the entry's quals array
 *  Returns
 *     nothing
 *  Notes
 *     If the entry is in use, marks the entry as changed and the entry's group
 *     as containing changed entry/entries.
 */
STATIC void
_bcm_dpp_field_entry_clear_quals(int unit,
                                 _bcm_dpp_field_qual_t *quals)
{
    unsigned int index;

    sal_memset(quals,
               0x00,
               sizeof(quals[0]) * SOC_PPC_FP_NOF_QUALS_PER_DB_MAX);
    for (index = 0; index < SOC_PPC_FP_NOF_QUALS_PER_DB_MAX; index++) {
        quals[index].qualType = BCM_FIELD_ENTRY_INVALID;
        quals[index].hwType = BCM_FIELD_ENTRY_INVALID;
    }
}
/* } */
#endif

/*
 *  Function
 *     _bcm_dpp_field_ext_info_entry_clear
 *  Purpose
 *     Clear external TCAM info entry.
 *  Parameters
 *     Was:
 *       (out) ext_entry = pointer to the info entry
 *     Changed to:
 *       (in)  = Index into corresponding tempUnit->extTcamInfo
 *  Returns
 *     nothing
 *  Notes
 */
/*
 * Was:
 *  void
 *  _bcm_dpp_field_ext_info_entry_clear(_bcm_dpp_field_entry_ext_info_t *ext_entry)
 */
void
   _bcm_dpp_field_ext_info_entry_clear(int unit, int32 extTcamInfoIndex)
{
    unsigned int index;
    _bcm_dpp_field_entry_ext_info_t field_entry_ext_info ;

    if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  Update sw-state resources */
        sal_memset(&field_entry_ext_info, 0, sizeof(field_entry_ext_info));
        FIELD_ACCESS_EXTTCAMINFO.set(unit,extTcamInfoIndex,&field_entry_ext_info) ;

        for (index = 0; index < SOC_PPC_FP_NOF_QUALS_PER_DB_MAX; index++) {
            /*
             * Was:
             * ext_entry->entryQual[index].qualType = bcmFieldQualifyCount;
             * ext_entry->entryQual[index].hwType = SOC_PPC_NOF_FP_QUAL_TYPES;
             */
            FIELD_ACCESS_EXTTCAMINFO.entryQual.qualType.set(unit,extTcamInfoIndex,index,BCM_FIELD_ENTRY_INVALID) ;
            FIELD_ACCESS_EXTTCAMINFO.entryQual.hwType.set(unit,extTcamInfoIndex,index,BCM_FIELD_ENTRY_INVALID) ;
        }
        for (index = 0; index < _BCM_DPP_NOF_BCM_ACTIONS_PER_DB_MAX; index++) {
            /*
             * Was:
             * ext_entry->tcActB[index].bcmType = bcmFieldActionCount;
             */
            FIELD_ACCESS_EXTTCAMINFO.tcActB.bcmType.set(unit,extTcamInfoIndex,index,BCM_FIELD_ENTRY_INVALID) ;
        }
        for (index = 0; index < SOC_PPC_FP_NOF_ACTIONS_PER_DB_MAX; index++) {
            /*
             * Was:
             * ext_entry->tcActP[index].hwType = SOC_PPC_FP_ACTION_TYPE_INVALID;
             */
            FIELD_ACCESS_EXTTCAMINFO.tcActP.hwType.set(unit,extTcamInfoIndex,index,SOC_PPC_FP_ACTION_TYPE_INVALID) ;
        }
    }
}

STATIC int
_bcm_dpp_field_group_get_presel_bitmap(int unit,
                            _bcm_dpp_field_stage_idx_t group_stage,
                            bcm_field_presel_t presel_id,
                            bcm_field_presel_t *presel_bitmap_id)
{
    uint8 bit_value;
    bcm_field_stage_t stage;
    bcm_field_presel_t bmp_index;
    uint8 is_second_pass = FALSE;
    int result = BCM_E_NONE;
    _bcm_dpp_field_stage_idx_t groupD_stage;

    BCMDNX_INIT_FUNC_DEFS;

    bmp_index = presel_id;

    if(soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE)) {
        /* Take the BCM stage from the stage index */
        switch (group_stage) {
            case _BCM_DPP_FIELD_STAGE_INDEX_INGRESS:
                stage = bcmFieldStageIngress;
                break;
            case _BCM_DPP_FIELD_STAGE_INDEX_EGRESS:
                stage = bcmFieldStageEgress;
                break;
            case _BCM_DPP_FIELD_STAGE_INDEX_ING_SLB:
                stage = bcmFieldStageHash;
                break;
            case _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL:
                stage = bcmFieldStageExternal;
                break;
            default:
                stage = bcmFieldStageIngress;
                break;
        }

        if (presel_id >= BCM_FIELD_PRESEL_STAGGERED) {
            is_second_pass = TRUE;
        }

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_to_bitmap(unit, presel_id, stage, is_second_pass,  &bmp_index, &groupD_stage));
    }

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_PRESELINUSE_W.bit_get(unit, bmp_index, &bit_value));
    if (!bit_value) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d wants to use presel"
                              " %d but it is not in use\n"),
                   unit, presel_id));
        result = BCM_E_CONFIG;
    }

    BCMDNX_IF_ERR_EXIT(result);

    *presel_bitmap_id = bmp_index;
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_group_hardware_remove
 *  Purpose
 *     Remove a group from hardware
 *  Parameters
 *     (in) unitData = unit information
 *     (in) group = group number
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if successful
 *        BCM_E_* appropriately if not
 *  Notes
 */
STATIC int
_bcm_dpp_field_group_hardware_remove(bcm_dpp_field_info_OLD_t *unitData,
                                     _bcm_dpp_field_grp_idx_t group)
{
    uint32 ppdr;
    uint8 pqset_bit;
    uint8 paset_bit;
    int result = BCM_E_NONE;
    unsigned int index;
    bcm_field_presel_t bmp_index;
    _bcm_dpp_field_stage_idx_t groupD_stage;
    _bcm_dpp_field_grp_idx_t groupLimit;
    uint32 groupFlags; 
    bcm_field_presel_set_t preselHw; 
    _bcm_dpp_field_grp_idx_t cascadePair;
    _bcm_dpp_field_ent_idx_t entryCount; 
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.preselHw.get(unit, group, &preselHw));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryCount.get(unit, group, &entryCount));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.cascadePair.get(unit, group, &cascadePair));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, group, &groupD_stage));
    
    if (0 == (groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u not in use"),
                          unit,
                          group));
    }
    if (0 == (groupFlags & _BCM_DPP_FIELD_GROUP_IN_HW)) {
        /* nothing to do; it's already not in hardware */
        BCM_EXIT;
    }

    if (entryCount) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u entries must be"
                                           " removed first"),
                          unit,
                          group));
    }
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.pqset.bit_get(unit, group, SOC_PPC_FP_QUAL_IRPP_KEY_CHANGED, &pqset_bit));
    if ((pqset_bit) &&
        (cascadePair < groupLimit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u is second in a"
                                           " cascade pair with group %u, which"
                                           " must be removed first"),
                          unit,
                          group,
                          cascadePair));
    }
    if (groupFlags & _BCM_DPP_FIELD_GROUP_IN_HW) {
        /* must destroy existing group first */
        {
            ppdr = soc_ppd_fp_database_destroy(unitData->unitHandle, group);
            result = handle_sand_result(ppdr);
        }
        if (BCM_E_NONE == result) {
            uint32 localGroupFlags ; 
            _bcm_dpp_field_presel_idx_t preselLimit;

            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.paset.bit_get(unit, group, SOC_PPC_FP_ACTION_TYPE_CHANGE_KEY, &paset_bit));
            if (paset_bit) {
                /* adjust cascade information for this group & its pair */
                if (cascadePair < groupLimit) {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.cascadePair.set(unit, cascadePair, groupLimit));
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, cascadePair, &localGroupFlags));
                    localGroupFlags &= (~_BCM_DPP_FIELD_GROUP_CASCADE);
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, cascadePair, localGroupFlags));
                }

                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.cascadePair.set(unit, group, groupLimit));
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
                groupFlags &= (~_BCM_DPP_FIELD_GROUP_CASCADE);
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupFlags));
            }
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
            groupFlags &= (~_BCM_DPP_FIELD_GROUP_IN_HW);
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupFlags));
#ifdef BCM_WARM_BOOT_SUPPORT
            /*_bcm_dpp_field_group_wb_save(unitData, group, NULL, NULL);*/
#endif /* def BCM_WARM_BOOT_SUPPORT */
            /* release reference to cascaded features */
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.pqset.bit_get(unit, group, SOC_PPC_FP_QUAL_IRPP_KEY_CHANGED, &pqset_bit));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.paset.bit_get(unit, group, SOC_PPC_FP_ACTION_TYPE_CHANGE_KEY, &paset_bit));
            if (pqset_bit ||
                paset_bit) {
				if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  allocate sw-state resources */
                    _bcm_dpp_field_grp_idx_t    groupCascaded ;
                    /*
                     * Was:
                     *   unitData->groupCascaded--;
                     */
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupCascaded.get(unit, &groupCascaded)) ;
                    groupCascaded-- ;
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupCascaded.set(unit, groupCascaded)) ;
                }
            }
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.preselLimit.get(unit, &preselLimit)) ;
            /* account for removing preselectors that were used before */
            if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  allocate sw-state resources */
                for (index = 0; index < preselLimit; index++) {
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.preselHw.get(unit, group, &preselHw));
                if (BCM_FIELD_PRESEL_TEST(preselHw, index)) {
                        unsigned int preselRefs_element ;
                        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_group_get_presel_bitmap(unit, groupD_stage, index, &bmp_index));
                        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_PRESELREFS.get(unit, bmp_index, &preselRefs_element)) ;
                        preselRefs_element-- ;
                        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_PRESELREFS.set(unit, bmp_index, preselRefs_element)) ;
                    }
                }
            }
            /* dispose of any preselectors no longer implied */
            /* called function displayed diagnostics */
#ifdef BCM_WARM_BOOT_SUPPORT
#if (0)
/* { */
    /*
     * All 'save' and 'sync' of old sw state are dropped.
     */
            _bcm_dpp_field_presel_all_wb_save(unitData, NULL, NULL);
/* } */
#endif
#endif /* def BCM_WARM_BOOT_SUPPORT */
        } else {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unable to remove unit %d group %d from"
                                  " hardware: %d (%s)\n"),
                       unit,
                       group,
                       result,
                       _SHR_ERRMSG(result)));
            BCMDNX_IF_ERR_EXIT(result);
        }
    } /* if (groupData->flags & _BCM_DPP_FIELD_GROUP_IN_HW) */
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_group_destroy
 *  Purpose
 *     Destroy a group, after destroying all its entries
 *  Parameters
 *     (in) unitData = unit information
 *     (in) group = group number
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if successful
 *        BCM_E_* appropriately if not
 *  Notes
 */
STATIC int
_bcm_dpp_field_group_destroy(bcm_dpp_field_info_OLD_t *unitData,
                             _bcm_dpp_field_grp_idx_t group)
{
    int result = BCM_E_NONE;
    _bcm_dpp_field_ent_idx_t entry;
    _bcm_dpp_field_ent_idx_t nextEntry;
    _bcm_dpp_field_ent_idx_t tcam_entry_limit;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    _bcm_dpp_field_entry_type_t entryType;    
    _bcm_dpp_field_stage_idx_t groupSh1;
    _bcm_dpp_field_grp_idx_t groupLimit;
    _bcm_dpp_field_dq_idx_t dqLimit;
    uint32 groupFlags;  
    _bcm_dpp_field_stage_idx_t stage; 
    bcm_field_group_mode_t grpMode; 
    _bcm_dpp_field_ent_idx_t entryHead;
    _bcm_dpp_field_grp_idx_t groupNext;
    _bcm_dpp_field_grp_idx_t groupPrev; 
    _bcm_dpp_field_grp_idx_t cascadePair;
    bcm_field_qset_t qset;
    int index;
    unsigned int dataFieldRefs;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;


    unit = unitData->unit;

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, group, &stage));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.get(unit, group, &grpMode));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryHead.get(unit, group, &entryHead));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.get(unit, group, &groupNext));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.get(unit, group, &groupPrev));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.qset.get(unit, group, &qset));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.cascadePair.get(unit, group, &cascadePair));

    
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d(%08X),%d) enter (%s,%s)\n"),
               unit,
               PTR_TO_INT(unitData),
               group,
               (groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE)?"+IN_USE":"-in_use",
               (groupFlags & _BCM_DPP_FIELD_GROUP_IN_HW)?"+IN_HW":"-in_hw"));
    if (groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.stageD.modeBits.entryType.get(unit, stage, grpMode, &entryType));
        /* remove this group's entries from the PPD */
        nextEntry = entryHead;
        switch (entryType) {
        case _bcmDppFieldEntryTypeDirExt:
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));
            while ((BCM_E_NONE == result) &&
                   (nextEntry < entryDeLimit)) {
                entry = nextEntry;
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryNext.get(unit, entry, &nextEntry));
                result = _bcm_dpp_field_dir_ext_entry_destroy(unitData, entry);
            }
            break;
		default:
			{
			    _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType);
				while ((BCM_E_NONE == result) &&
                       (nextEntry < tcam_entry_limit)) {
					entry = nextEntry;
					/*
                                         * Was:
                                         *   nextEntry = _BCM_DPP_FIELD_TCAM_ENTRY_NEXT(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry);
                                         */
					_BCM_DPP_FIELD_TCAM_ENTRY_NEXT_GET(unit,_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry, nextEntry);
					result = _bcm_dpp_field_tcam_entry_destroy(unitData, FALSE, _BCM_DPP_FIELD_TCAM_GLOBAL_ID(unit, entry, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)));
				}
			}
		}

        if (BCM_E_NONE != result) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unable to destroy all entries in unit"
                                  " %d group %d: %d (%s)\n"),
                       unit,
                       group,
                       result,
                       _SHR_ERRMSG(result)));
        } else { /* if (BCM_E_NONE != result) */
            result = _bcm_dpp_field_group_hardware_remove(unitData, group);
        } /* if (BCM_E_NONE != result) */
        if (BCM_E_NONE == result) {
            _bcm_dpp_field_grp_idx_t groupCount ;
            _bcm_dpp_field_grp_idx_t groupFree ;

            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.get(unit, group, &groupPrev));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.get(unit, group, &groupNext));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, group, &stage));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.get(unit, group, &grpMode));
            if (groupPrev < groupLimit) {
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.set(unit, groupPrev, groupNext));
            } else {
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupHead.set(unit, stage, groupNext));
            }
            if (groupNext < groupLimit) {
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.set(unit, groupNext, groupPrev));
            } else {
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupTail.set(unit, stage, groupPrev));
            }
            /*
             * Was:
             *   groupData->groupNext = unitData->groupFree ;
             */
            result = FIELD_ACCESS.groupFree.get(unit, &groupFree) ;
            if (BCM_E_NONE == result) {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.set(unit, group, groupFree));

            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.set(unit, group, groupLimit));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.cascadePair.set(unit, group, groupLimit));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, 0));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupCycle.set(unit, group, 0));

            if (groupFree < groupLimit) {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.set(unit, groupFree, group));
                }
                if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  allocate sw-state resources */
                    /*
                     * Was:
                     *   unitData->groupFree = group;
                     *   unitData->groupCount--;
                     */
                    result = FIELD_ACCESS.groupFree.set(unit, group) ;
                    if (result == BCM_E_NONE) {
                        result = FIELD_ACCESS.groupCount.get(unit, &groupCount) ;
                        if (result == BCM_E_NONE) {
                            groupCount-- ;
                            result = FIELD_ACCESS.groupCount.set(unit, groupCount) ;
                        }
                    }
                }
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, group, &stage));

                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.qset.get(unit, group, &qset));

               BCMDNX_IF_ERR_EXIT(  FIELD_ACCESS.stageD.groupSh1.get(unit, stage, &groupSh1));
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupCount.get(unit, groupSh1, &groupCount));
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupCount.set(unit, groupSh1, --groupCount));

                /* account for the group's references to programmable fields */
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.dqLimit.get(unit, &dqLimit));
                for (index = 0; index < dqLimit; index++) {
                if (SHR_BITGET(qset.udf_map, index)) {
                    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.dataFieldRefs.get(unit, index, &dataFieldRefs));
                    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.dataFieldRefs.set(unit, index, --dataFieldRefs));
                    }
                }
#ifdef BCM_WARM_BOOT_SUPPORT
#if (0)
/* { */
    /*
     * All 'save' and 'sync' of old sw state are dropped.
     */
                _bcm_dpp_field_datafield_all_wb_save(unitData, NULL, NULL);
/* } */
#endif
#endif /* def BCM_WARM_BOOT_SUPPORT */
            }
        } /* if (BCM_E_NONE == result) */
    } else { /* if (groupData->flags & _BCM_DPP_FIELD_GROUP_IN_USE) */
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    } /* if (groupData->flags & _BCM_DPP_FIELD_GROUP_IN_USE) */
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d(%08X),%d) return %d (%s)\n"),
               unit,
               PTR_TO_INT(unitData),
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_unit_destroy
 *  Purpose
 *     Destroy all resources used by a unit (except the unit descriptor)
 *  Parameters
 *     (in) unitData = unit information
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if successful
 *        BCM_E_* appropriately if not
 *  Notes
 *     Does not destroy the unit descriptor (caller must do that if success).
 */
STATIC int
_bcm_dpp_field_unit_destroy(bcm_dpp_field_info_OLD_t *unitData)
{
    int result = BCM_E_NONE;

/* writing to hw is not needed and not allowed during deinit */

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d(%08X)) enter\n"),
               unitData?unitData->unit:-1,
               PTR_TO_INT(unitData)));
    if (unitData) {
        unit = unitData->unit;

/* writing to hw is not needed and not allowed during deinit */
        /* destroy the lock */
        if (BCM_E_NONE == result) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "destroy lock\n")));
            sal_mutex_destroy(_DPP_FIELD_GET_UNIT_LOCK(unitData));
            _DPP_FIELD_SET_UNIT_LOCK(unitData,NULL) ;
        }
    } else { /* if (unitData) */
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit is not in use\n")));
        result = BCM_E_INIT;
    } /* if (unitData) */
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d(%08X)) return %d (%s)\n"),
               unitData?unitData->unit:-1,
               PTR_TO_INT(unitData),
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_detach
 *  Purpose
 *     Shut down the field APIs on the unit
 *  Parameters
 *     (in) int unit = the unit number
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if successful
 *        BCM_E_* appropriately if not
 *  Notes
 *     Assumes caller has already taken global lock
 */
STATIC int
_bcm_dpp_field_detach(int unit)
{
    int result;
    uint32 soc_sand_rv = SOC_SAND_OK;
    SOC_SAND_OCC_BM_PTR extTcamBmp;

    bcm_dpp_field_info_OLD_t *tempData = _bcm_dpp_field_unit_info[unit];

    BCMDNX_INIT_FUNC_DEFS;
    /* disconnect while trying to do this */
    _bcm_dpp_field_unit_info[unit] = NULL;

    if (tempData) {
        
        result = _bcm_dpp_field_unit_destroy(tempData);
        if (BCM_E_NONE != result) {
            /* failed to destroy this unit; link it back */
            _bcm_dpp_field_unit_info[unit] = tempData;
        } else {
            if (SOC_DPP_IS_ELK_ENABLE(unit)) {
                if (!SOC_IS_DETACHING(unit)) {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.extTcamBmp.get(unit, &extTcamBmp));
                    /* destroy only non-zero bitmap */
                    if(extTcamBmp != 0) {
                        /* don't release on detach due to warmboot reasons */
                        soc_sand_rv = soc_sand_occ_bm_destroy(unit, extTcamBmp);
                        result = handle_sand_result(soc_sand_rv);
                    }
                }                
                if (BCM_E_NONE != result) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_INIT, (_BSL_BCM_MSG("failed to destroy occupation bitmap")));
                }
            }
            /* free the memory from the unit information */
           BCM_FREE(tempData);
        }
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INIT, (_BSL_BCM_MSG("not initialised")));
    }

    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_quals_to_ppd
 *  Purpose
 *     Convert a BCM qset into a set of PPD qualifiers
 *  Parameters
 *     (in) unitData = unit information
 *     (in) stage = stage for the group
 *     (in) type = type for the group
 *     (in) qset = BCM qset
 *     (out) ppdqset = PPD qset
 *     (out) apisize = number of bits of qualifiers
 *     (out) hwsize = number of trits of TCAM space or similar
 *  Returns
 *     nothing
 *  Notes
 */
STATIC int
_bcm_dpp_field_quals_to_ppd(bcm_dpp_field_info_OLD_t *unitData,
                            _bcm_dpp_field_stage_idx_t stage,
                            uint32 types,
                            bcm_field_qset_t qset,
                            _bcm_dpp_field_qual_set_t *ppdqset,
                            unsigned int *apisize,
                            unsigned int *hwsize,
							int			 *kbp_sip_dip_sharing)
{
    bcm_field_qualify_t qualId;
    unsigned int index;
    unsigned int hwBits = 0;
    unsigned int apiBits = 0;
    unsigned int hwBitsTemp;
    unsigned int apiBitsTemp;
    SOC_PPC_FP_QUAL_TYPE *qualChain;
    SOC_PPC_FP_QUAL_TYPE qualType;
    int result = BCM_E_NONE;
    uint8 dataFieldInUse;
    _bcm_dpp_field_dq_idx_t dqLimit;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    /* scan qset and include PPD qset bits for each standard one */
    sal_memset(ppdqset, 0x00, sizeof(*ppdqset));
    for (qualId = 0;
         (BCM_E_NONE == result) && (qualId < bcmFieldQualifyCount);
         qualId++) {
        if (BCM_FIELD_QSET_TEST(qset, qualId)) {
            result = _bcm_dpp_ppd_qual_from_bcm_qual(unitData,
                                                     stage,
                                                     types,
                                                     qualId,
                                                     &qualChain);
            if (BCM_E_NONE == result) {
                for (index = 0;
                     index < unitData->devInfo->qualChain;
                     index++ ) {
                    if (_BCM_DPP_FIELD_PPD_QUAL_VALID(qualChain[index])) {
                        SHR_BITSET(*ppdqset, qualChain[index]);
                    }
                } /* for (all qualifiers in chain) */
            } /* if (BCM_E_NONE == result) */
        } /* if (BCM_FIELD_QSET_TEST(qset,  qualId)) */
    } /* for (all qualifiers in qset as long as no error) */

    /* scan qset and include PPD qset bits for each programmable one */
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.dqLimit.get(unit, &dqLimit));
    for (index = 0;
         (BCM_E_NONE == result) && (index < dqLimit);
         index++) {
        if (SHR_BITGET(qset.udf_map, index)) {
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.dataFieldInUse.bit_get(unit, index, &dataFieldInUse));
            if (!dataFieldInUse) {
                /*
                 *  This is not paranoia at this point, though it might seem to
                 *  be: it is possible that the data qualifier was created,
                 *  added to the QSET and then destroyed.  Since we can not
                 *  track references based upon QSET (the application can
                 *  create and destroy these at whim), the reference count is
                 *  based upon actual groups using the qualifier, and so a data
                 *  qualifier can be deleted as long as no group in hardware is
                 *  actually using it.
                 */
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d udf %d is not in use but"
                                      " qset tries to refer to it\n"),
                           unit,
                           index));
                result = BCM_E_CONFIG;
            }
            if (BCM_E_NONE == result) {
                result = _bcm_petra_field_map_bcm_udf_to_ppd(unitData,
                                                             index,
                                                             &qualType);
            }
            if (BCM_E_NONE == result) {
                SHR_BITSET(*ppdqset, qualType);
            }
        } /* if (SHR_BITGET(qset.udf_map, index)) */
    } /* for (all valid programmable qualifiers as long as no error) */

    if (BCM_E_NONE == result) {
        /* count bits based upon PPD qset sizes */
        for (qualType = 0; qualType < SOC_PPC_NOF_FP_QUAL_TYPES; qualType++) {
            if (SHR_BITGET((*ppdqset), qualType)) {
                result = _bcm_dpp_ppd_qual_bits(unit,
                                                stage,
                                                qualType,
                                                &apiBitsTemp,
                                                &hwBitsTemp,
                                                NULL);
                if (BCM_E_NONE == result) {
                    LOG_DEBUG(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "PPD qualifier ID %d (%s) in stage %u"
                                          " types %08X: %u API, %u hw\n"),
                               qualType,
                               SOC_PPC_FP_QUAL_TYPE_to_string(qualType),
                               stage,
                               types,
                               apiBitsTemp,
                               hwBitsTemp));
                    apiBits += apiBitsTemp;
                    hwBits += hwBitsTemp;
                    {
                        /*
                         * Was:
                         *   if (unitData->stageD[stage].devInfo->hwStageId == SOC_PPC_FP_DATABASE_STAGE_INGRESS_FLP)
                         * But was changed since, on current code, there is no such element:
                         *   unitData->stageD[stage].devInfo
                         */
                        if (_BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage).hwStageId == SOC_PPC_FP_DATABASE_STAGE_INGRESS_FLP) {
                            if((qualType == SOC_PPC_FP_QUAL_HDR_IPV6_DIP_HIGH) ||
                               (qualType == SOC_PPC_FP_QUAL_HDR_IPV6_DIP_LOW) ||
                               (qualType == SOC_PPC_FP_QUAL_HDR_IPV6_SIP_HIGH) ||
                               (qualType == SOC_PPC_FP_QUAL_HDR_IPV6_SIP_LOW) ||
                               (qualType == SOC_PPC_FP_QUAL_HDR_IPV4_DIP) ||
                               (qualType == SOC_PPC_FP_QUAL_HDR_IPV4_SIP) ||
                               (qualType == SOC_PPC_FP_QUAL_HDR_DA) ||
                               (qualType == SOC_PPC_FP_QUAL_HDR_SA)){
                                if (SOC_IS_JERICHO(unit)) {
                                    (hwBits) = (hwBits) - hwBitsTemp;
									if (kbp_sip_dip_sharing) {
										if (hwBits == 0) {
											*kbp_sip_dip_sharing = 1;
										}else{
											*kbp_sip_dip_sharing = 0;
										}
									}
                                }
                            }
                        }
                    }

                } else {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d unable to determine number"
                                          " of bits in PPD qualifier %d (%s) in"
                                          " stage %u types %08X: %d (%s)\n"),
                               unit,
                               qualType,
                               SOC_PPC_FP_QUAL_TYPE_to_string(qualType),
                               stage,
                               types,
                               result,
                               _SHR_ERRMSG(result)));
                }
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "include PPD qualifier %d (%s), bits ="
                                      " %u api, %u hw\n"),
                           qualType,
                           SOC_PPC_FP_QUAL_TYPE_to_string(qualType),
                           apiBitsTemp,
                           hwBitsTemp));
            } /* if (SHR_BITGET((*ppdqset), qualType)) */
        } /* for (all PPD layer qualifier types) */
    } /* if (BCM_E_NONE == result) */
    if (BCM_E_NONE == result) {
        if (apisize) {
            *apisize = apiBits;
        }
        if (hwsize) {
            *hwsize = hwBits;
        }
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "total size = %u api, %u hw\n"),
                   apiBits,
                   hwBits));
    }
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}
/*
 *  Function
 *     _bcm_dpp_field_ppd_to_bcm_actions
 *  Purpose
 *     Given a PPD action and stage, get the list of all BCM actions
 *     corresponding to it.
 *  Parameters
 *     (in)  int unit =
 *             The unit number
 *     (in)  SOC_PPC_FP_DATABASE_STAGE stage =
 *             Low level stage for BCM actions to search
 *     (in)  SOC_PPC_FP_ACTION_TYPE ppd_action =
 *             Low level action to search for on all BCM actions of specified stage.
 *     (in)  uint32 in_num_elements =
 *             Maximal number of BCM actions (elements) to load on '*bcm_action'.
 *     (out) bcm_field_action_t *bcm_action =
 *             Array of containing BCM actions to be loaded by this procedure.
 *     (out) uint32 *out_num_elements =
 *             Number of BCM actions (elements) actually loaded into '*bcm_action'.
 *  Returns
 *     BCM_E_NONE or BCM_E_* error code
 *  Notes
 *    See bcm_petra_field_internal_to_bcm_action_map(), See _bcm_arad_field_action_info[],
 *    _bcm_dpp_field_actions_to_ppd()
 */
STATIC int
_bcm_dpp_field_ppd_to_bcm_actions(
    bcm_dpp_field_info_OLD_t *unitData,
    SOC_PPC_FP_DATABASE_STAGE stage,
    SOC_PPC_FP_ACTION_TYPE ppd_action,
    uint32 in_num_elements,
    bcm_field_action_t *bcm_action,
    uint32 *out_num_elements)
{
    bcm_field_action_t actId ;
    SOC_PPC_FP_ACTION_TYPE *actChain ;
    unsigned int indx ;
    uint32 num_elements ;
    int result ;
    int32 actMaps_handle ;
    bcm_field_action_t *loc_bcm_action ;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT ;

    unit = unitData->unit;
    loc_bcm_action = bcm_action ;
    BCMDNX_NULL_CHECK(loc_bcm_action) ;
    BCMDNX_NULL_CHECK(out_num_elements) ;

    actChain = NULL ;
    num_elements = 0 ;
    /*
     * 'actId' is index running over all BCM actions.
     */
    for (actId = 0 ; (actId < bcmFieldActionCount) ; actId++) {
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ACTMAPS.get(unit, actId, &actMaps_handle)) ;
        /*
         * Try to convert only if this BCM action is supported on this unit.
         */
        if (actMaps_handle) {
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_ppd_act_from_bcm_act(unitData,stage,actId,&actChain)) ;
            for (indx = 0 ; indx < unitData->devInfo->actChain ; indx++ ) {
                if (_BCM_DPP_FIELD_PPD_ACTION_VALID(actChain[indx])) {
                    /*
                     * 'actChain' is now an array of PPD-level actions which correspond to specified
                     * stage and actId (bcm action). See _bcm_arad_field_action_info[].
                     */
                    if (actChain[indx] == ppd_action) {
                        if (num_elements >= in_num_elements) {
                            result = _SHR_E_RESOURCE ;
                            BCMDNX_ERR_EXIT_MSG(result,
                              (_BSL_BCM_MSG(
                                  "\r\n"
                                  " ==>Actual num_elements is larger than in_num_elements (%d) supplied by caller"),in_num_elements)) ;
                        }
                        *loc_bcm_action++ = actId ;
                        num_elements++ ;
                        /*
                         * We assume the same action will not appear twice on the same stage.
                         */
                        break ;
                    }
                }
            } /* for (all actions in chain) */
        } /* if (actMaps_handle) */
    }
    if (SOC_IS_JERICHO(unit)) {
        SOC_PPC_FP_ACTION_TYPE
            added_act ;
        unsigned int
            added_act_index ;
        /*
         * Scan _bcm_jericho_field_added_actions.added_actions to find out if there are actions
         * which should be added to this stage on specified bcm actions.
         * This is only done for Jericho.
         * See _bcm_jericho_field_added_actions and _bcm_jericho_field_added_action_arr
         */
        for (actId = 0; (actId < bcmFieldActionCount); actId++) {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ACTMAPS.get(unit, actId, &actMaps_handle)) ;
            /*
             * Try to convert only if this BCM action is supported on this unit.
             */
            if (actMaps_handle) {
                for (indx = 0 ; (_bcm_jericho_field_added_actions.added_actions_p[indx].bcmAction != bcmFieldActionCount) ; indx++ ) {
                    if (_bcm_jericho_field_added_actions.added_actions_p[indx].bcmAction == actId) {
                        if (stage < _bcm_jericho_field_added_actions.num_stages) {
                            for (added_act_index = 0 ; added_act_index < _bcm_jericho_field_added_actions.num_added_actions ; added_act_index++ ) {
                                added_act = _bcm_jericho_field_added_actions.added_actions_p[indx].added_actions[stage][added_act_index] ;
                                if (_BCM_DPP_FIELD_PPD_ACTION_VALID(added_act)) {
                                    if (added_act == ppd_action) {
                                        if (num_elements >= in_num_elements) {
                                            result = _SHR_E_RESOURCE ;
                                            BCMDNX_ERR_EXIT_MSG(result,
                                              (_BSL_BCM_MSG(
                                                  "\r\n"
                                                  " ==>Actual num_elements is larger than in_num_elements (%d) supplied by caller"),in_num_elements)) ;
                                        }
                                        *loc_bcm_action++ = actId ;
                                        num_elements++ ;
                                        /*
                                         * We assume the same action will not appear twice on the same stage.
                                         */
                                        break ;
                                    }
                                } else {
                                    /*
                                     * 'added_act' is not valid. Do not search this line any further.
                                     */
                                    break ;
                                }
                            }
                        }
                    }
                }
            }
        } /* for (all actions in aset as long as no error) */
    }
    *out_num_elements = num_elements ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "num_elements %d\n"), *out_num_elements));
exit:        
    BCMDNX_FUNC_RETURN ;
}
/*
 *  Function
 *     _bcm_dpp_field_actions_to_ppd
 *  Purpose
 *     Convert a BCM aset into a set of PPD actions
 *  Parameters
 *     (in) unitData = unit information
 *     (in) stage = stage for the group
 *     (in) type = type for the group
 *     (in) aset = BCM aset
 *     (out) ppdaset = PPD aset
 *     (out) size = number of actions included
 *  Returns
 *     nothing
 *  Notes
 */
STATIC void
_bcm_dpp_field_actions_to_ppd(bcm_dpp_field_info_OLD_t *unitData,
                              _bcm_dpp_field_stage_idx_t stage,
                              const bcm_field_aset_t *aset,
                              _bcm_dpp_field_action_set_t *ppdaset,
                              unsigned int *size)
{
    bcm_field_action_t actId;
    SOC_PPC_FP_ACTION_TYPE *actChain = NULL;
    SOC_PPC_FP_ACTION_TYPE ppdAct;
    unsigned int indx;
    int result = BCM_E_NONE;
    int unit;

    unit = unitData->unit;


    /* scan aset and include PPD aset bits for each one */
    sal_memset(ppdaset, 0x00, sizeof(*ppdaset));
    for (actId = 0;
         (BCM_E_NONE == result) && (actId < bcmFieldActionCount);
         actId++) {
        if (BCM_FIELD_ASET_TEST(*aset, actId)) {
            result = _bcm_dpp_ppd_act_from_bcm_act(unitData,
                                                   stage,
                                                   actId,
                                                   &actChain);
            if (BCM_E_NONE == result) {
                for (indx = 0;
                     indx < unitData->devInfo->actChain;
                     indx++ ) {
                    if (_BCM_DPP_FIELD_PPD_ACTION_VALID(actChain[indx])) {
                        SHR_BITSET(*ppdaset, actChain[indx]);
                    }
                } /* for (all actions in chain) */
            } else { /* if (BCM_E_NONE == result) */
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d stage %u unable to"
                                      " map action %d (%s) to PPD action:"
                                      " %d (%s); ignoring it\n"),
                           unit,
                           stage,
                           actId,
                           _bcm_dpp_field_action_name[actId],
                           result,
                           _SHR_ERRMSG(result)));
            } /* if (BCM_E_NONE == result) */
        } /* if (BCM_FIELD_ASET_TEST(*aset, actId)) */
    } /* for (all actions in aset as long as no error) */
    if (SOC_IS_JERICHO(unit)) {
        SOC_PPC_FP_ACTION_TYPE
            added_act ;
        unsigned int
            added_act_index ;
        /*
         * Scan _bcm_jericho_field_added_actions.added_actions to find out if there are actions
         * which should be added to this stage on specified bcm actions.
         * This is only done for Jericho.
         * See _bcm_jericho_field_added_actions and _bcm_jericho_field_added_action_arr
         */
        for (actId = 0; (actId < bcmFieldActionCount); actId++) {
            if (BCM_FIELD_ASET_TEST(*aset, actId)) {
                for (indx = 0 ; (_bcm_jericho_field_added_actions.added_actions_p[indx].bcmAction != bcmFieldActionCount) ; indx++ ) {
                    if (_bcm_jericho_field_added_actions.added_actions_p[indx].bcmAction == actId) {
                        if (stage < _bcm_jericho_field_added_actions.num_stages) {
                            for (added_act_index = 0 ; added_act_index < _bcm_jericho_field_added_actions.num_added_actions ; added_act_index++ ) {
                                added_act = _bcm_jericho_field_added_actions.added_actions_p[indx].added_actions[stage][added_act_index] ;
                                if (_BCM_DPP_FIELD_PPD_ACTION_VALID(added_act)) {
                                    SHR_BITSET(*ppdaset, added_act);
                                } else {
                                    break ;
                                }
                            }
                        }
                    }
                }
            }
        } /* for (all actions in aset as long as no error) */
    }
    /* count actions */
    *size = 0;
    for (ppdAct = 0; ppdAct < SOC_PPC_NOF_FP_ACTION_TYPES; ppdAct++) {
        if (SHR_BITGET((*ppdaset), ppdAct)) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "include PPD action %d (%s)\n"),
                       ppdAct,
                       SOC_PPC_FP_ACTION_TYPE_to_string(ppdAct)));
            (*size)++;
        }
    }
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "total actions %d\n"), *size));
}

/*
 *  Function
 *    _bcm_dpp_field_group_mode_from_size
 *  Purpose
 *    Figure out the mode according to the size of the qset in bits
 *  Parameters
 *    (in) unitData = unit information
 *    (in) stage = which stage to use
 *    (in) flags = flags to use
 *    (in) bits = number of pattern bits
 *    (out) mode = where to put the proper mode
 *  Returns
 *     (none)
 *  Notes
 *    Does not modify the value at mode unless autosize flag is set.
 */
STATIC void
_bcm_dpp_field_group_mode_from_size(int unit,
                                    _bcm_dpp_field_stage_idx_t stage,
                                    uint32 flags,
                                    unsigned int bits,
                                    bcm_field_group_mode_t *mode)
{
    bcm_field_group_mode_t index;
    uint8 is_allocated;
    _bcm_dpp_field_device_group_mode_bits_t modeBits;
BCMDNX_INIT_FUNC_DEFS;

    if (0 == (flags & _BCM_DPP_FIELD_GROUP_AUTO_SZ)) {
        return;
    }
    *mode = bcmFieldGroupModeAuto;
    for (index = 0; index < bcmFieldGroupModeCount; index++) {
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.is_allocated(unit, stage, index, &is_allocated));
        if (is_allocated)
        {
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.get(unit, stage, index, &modeBits));
            if ((_BCM_DPP_FIELD_ENT_TYPE_IS_TCAM(modeBits.entryType)) &&
                (bits <= modeBits.length)) {
                *mode = index;
                break;
            }
        }
    } /* for (index = 0; index < bcmfieldGroupModeCount; index++) */

exit:
    BCMDNX_FUNC_RETURN_VOID;

}

/*
 *  Function
 *     _bcm_dpp_field_group_vt_predefined_group_init
 *  Purpose
 *     Init the VT classification qset table according to classifications supported
 *  Parameters
 *     (in) qset = proposed group qset
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if the proposed qset is acceptable
 *        BCM_E_* appropriately if not
 *  Notes
 *     This is used by the group create and group set class functions.
 *
 *     Will clobber all out args even if error.
 */
STATIC void
_bcm_dpp_field_group_vt_predefined_group_init(int unit)
{
    if (soc_property_get(unit, spn_VLAN_TRANSLATION_MATCH_IPV4, FALSE) ) 
    {
		vt_predefined_groups_status[unit][_BCM_DPP_VT_CLASS_IPV4_MATCH] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vt_tst1", 0) ) 
    {
		vt_predefined_groups_status[unit][_BCM_DPP_VT_CLASS_EFP] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vrrp_scaling_tcam", 0) || SOC_DPP_CONFIG(unit)->pp.vrrp_scaling_tcam)
    {
		vt_predefined_groups_status[unit][_BCM_DPP_VT_CLASS_VRRP] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vt_tst2", 0) )
    {
        vt_predefined_groups_status[unit][_BCM_DPP_VT_QINQ_COMPRESSED_OUTER]      = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_QINQ_COMPRESSED_INNER]      = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_QINANY_OUTER]               = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_QINANY_INNER]               = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_QINANY_PCP_OUTER]           = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_QINANY_PCP_INNER]           = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_DOT1Q_OUTER]                = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_DOT1Q_INNER]                = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_DOT1Q_COMPRESSED_OUTER]     = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_DOT1Q_COMPRESSED_INNER]     = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_DOT1Q_COMPRESSED_PCP_OUTER] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_DOT1Q_COMPRESSED_PCP_INNER] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_UNTAGGED]                   = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_TST2]                       = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }

    if (SOC_DPP_CONFIG(unit)->pp.test2){
        vt_predefined_groups_status[unit][_BCM_DPP_VT_TEST2]                       = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }

    if (SOC_DPP_CONFIG(unit)->pp.ingress_full_mymac_1) {
        vt_predefined_groups_status[unit][_BCM_DPP_VT_PORT_DA]                       = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
}

STATIC void
_bcm_dpp_field_group_flp_predefined_group_init(int unit)
{
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "ext_ipv4_mpls_extended_fwd_table_size", 0)) {
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_IPV4_MPLS_EXTENDED] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "ext_ipv6_extended_fwd_table_size", 0)) {
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_IPV6_EXTENDED] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "ext_p2p_extended_fwd_table_size", 0)) {
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_P2P_EXTENDED] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "ext_ipv4_mc_flexible_fwd_table", 0)) {
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_IPV4_MC_FLEXIBLE] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "ext_inrif_mapping_table_size", 0)) {
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_INRIF_MAPPING] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "IVL_inlif_profile", 0)) {
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_IVL_LEARN] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_IVL_INNER_LEARN] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_IVL_FWD_OUTER_LEARN] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }

}


/*
 *  Function
 *     _bcm_dpp_field_group_verify_vt_classification_qset
 *  Purpose
 *     Verify the provided qset is acceptable for a 5-tuple group
 *  Parameters
 *     (in) qset = proposed group qset
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if the proposed qset is acceptable
 *        BCM_E_* appropriately if not
 *  Notes
 *     This is used by the group create and group set class functions.
 *
 *     Will clobber all out args even if error.
 */
STATIC int
_bcm_dpp_field_group_verify_vt_classification_qset(int unit, bcm_field_qset_t *qset, uint32 *vt_classification, uint8* found, uint32* flag)
{
    bcm_field_qset_t tqset;
    uint8 index , qual_index;
    int result = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    (*found) = FALSE;

    for (index = 0; index < _BCM_DPP_VT_CLASS_COUNT ; index++ ) {
        if ( vt_predefined_groups_status[unit][index] != _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE) {
            continue;
        }

        BCM_FIELD_QSET_INIT(tqset);

        for (qual_index = 0 ; qual_index < vt_predefined_groups_info[index].nof_quals ; qual_index++ ){
            BCM_FIELD_QSET_ADD(tqset, vt_predefined_groups_info[index].bcmQual_array[qual_index]);
        }

        result =  sal_memcmp(qset,&tqset,sizeof(bcm_field_qset_t));

        if ( BCM_E_NONE == result ) {
            (*found) = TRUE; /*qset is found*/
            (*vt_classification) = vt_predefined_groups_info[index].internal_table_id;
            (*flag) = _BCM_DPP_FIELD_GROUP_USE_DBAL;            
            vt_predefined_groups_status[unit][index] = _BCM_DPP_PREDEF_GRP_STATUS_IN_USE;
            break;
        }
    }
        
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_dpp_field_group_verify_flp_classification_qset(int unit, bcm_field_qset_t *qset, uint32 *internal_table_id, uint8* found, uint32* flag)
{
    bcm_field_qset_t tqset;
    uint8 index , qual_index;
    int result = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    (*found) = FALSE;

    for (index = 0; index < _BCM_DPP_FLP_CLASS_COUNT ; index++ ) {
        if ( flp_predefined_groups_status[unit][index] !=  _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE) {
            continue;
        }

        BCM_FIELD_QSET_INIT(tqset);

        for (qual_index = 0 ; qual_index < flp_predefined_groups_info[index].nof_quals ; qual_index++ ){
            BCM_FIELD_QSET_ADD(tqset, flp_predefined_groups_info[index].bcmQual_array[qual_index]);
        }

        result = sal_memcmp(qset, &tqset, sizeof(bcm_field_qset_t)); /* is qset identical*/

        if ( 0 == result ) {
            (*found) = TRUE; /*qset is found*/
            (*internal_table_id) = flp_predefined_groups_info[index].internal_table_id;
            flp_predefined_groups_status[unit][index] =  _BCM_DPP_PREDEF_GRP_STATUS_IN_USE;
            
            if ( (flp_predefined_groups_info[index].table_type == _BCM_DPP_FLP_CLASS_IPV4_MPLS_EXTENDED) || 
                  (flp_predefined_groups_info[index].table_type == _BCM_DPP_FLP_CLASS_IPV4_MC_FLEXIBLE) || 
                  (flp_predefined_groups_info[index].table_type == _BCM_DPP_FLP_CLASS_IPV6_EXTENDED) || 
                  (flp_predefined_groups_info[index].table_type == _BCM_DPP_FLP_CLASS_P2P_EXTENDED)  || 
				  (flp_predefined_groups_info[index].table_type == _BCM_DPP_FLP_CLASS_INRIF_MAPPING)) {
                (*flag) = _BCM_DPP_FIELD_GROUP_EXTENDED_DATABASES;
            } else {                       
                (*flag) = _BCM_DPP_FIELD_GROUP_USE_DBAL;
            }
            break;
        }
    }

    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_group_verify_qset
 *  Purpose
 *     Verify the provided qset is acceptable for a group
 *  Parameters
 *     (in) unitData = unit information
 *     (in) group = proposed group ID
 *     (in) qset = proposed group qset
 *     (in) mode = proposed group mode
 *     (out) tqset = where to put adjusted qset (if successful)
 *     (out) flags = where to put flags for the group (if successful)
 *     (out) stage = where to put stage for the group (if successful)
 *     (out) type = where to put type for the group (if successful)
 *     (out) predefKey = where to put predef key index (if successful)
 *     (out) apiWidth = where to put API width of group (if successful)
 *     (out) hwWidth = where to put HW width of group (if successful)
 *     (out) ppdqset = where to put PPD qset of group (if successful)
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if the proposed qset is acceptable
 *        BCM_E_* appropriately if not
 *  Notes
 *     This is used by the group create and group set class functions.
 *
 *     Will clobber all out args even if error.
 */
STATIC int
_bcm_dpp_field_group_verify_qset(bcm_dpp_field_info_OLD_t *unitData,
                                 _bcm_dpp_field_grp_idx_t group,
                                 bcm_field_qset_t qset,
                                 bcm_field_group_mode_t mode,
                                 bcm_field_qset_t *tqset,
                                 uint32 *flags,
                                 _bcm_dpp_field_stage_idx_t *stage,
                                 uint32 *types,
                                 SOC_PPC_FP_PREDEFINED_ACL_KEY *predefKey,
                                 unsigned int *apiWidth,
                                 unsigned int *hwWidth,
                                 _bcm_dpp_field_qual_set_t *ppdqset)
{
    SOC_PPC_FP_QUAL_TYPE tempPpdQuals[SOC_PPC_FP_NOF_QUALS_PER_DB_MAX];
    SOC_PPC_FP_QUAL_TYPE ppdQual;
    bcm_field_qset_t uqset;
    bcm_field_qset_t bqset;
    unsigned int uq0;
    unsigned int uq1;
    unsigned int uq2;
    unsigned int mapId;
    unsigned int index;
    unsigned int base;
    unsigned int awidth;
	int kbp_sip_dip_sharing=0;
    uint32 ftypes = 0;
    uint32 tflags;
    int result = 0;
    _bcm_dpp_field_type_idx_t type;
    bcm_field_data_qualifier_t qual;
    bcm_field_stage_t bcmStage;
    bcm_field_qset_t qsetType;
    bcm_field_qset_t stgQset;
    uint8 modeBits_is_allocated;
    unsigned int ltOffset;
    bcm_field_group_mode_t modBits_mode;
    unsigned int length;
    _bcm_dpp_field_entry_type_t entryType;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    /* find a stage that fits the qset and the mode */
    if ((0 > mode) || (bcmFieldGroupModeCount <= mode)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG_NO_UNIT("group mode %d is not valid"),
                          mode));
    }

    sal_memset(tempPpdQuals, 0x0, sizeof(tempPpdQuals));
    /*
     *  There are several types of groups here, based entriely upon the L3
     *  type implied by the qualifiers in the QSET, and the stage specified by
     *  the QSET (or assumed by the lack of such specification combined with
     *  the available qualifiers).
     *
     *  Unhappily, the mechanism is not so simple as to merely choose a type
     *  that is appropriate.  Types can be combined, except in cases where
     *  there are qualifier overlaps.  Right now, in BCM layer, the only
     *  qualifier overlaps of particular significance are between IPv4 and
     *  IPv6, specifically because these overlaps do not exist at PPD layer and
     *  so must be separated here.
     *
     *  In order to allow a single group to include qualifiers from more than
     *  one type, but not across stages or across, we need to be able to build
     *  supersets of the types, but avoid building supersets that span stages
     *  or that include both IPv4 and IPv6 qualifiers.
     *
     *  This is made more complicated by the fact that some stages have fixed
     *  qualifier sets and exactly one of those can be chosen for a group in
     *  such stages (types that can not be combined are noted in the hardware
     *  tables by having a predefined key specified -- those that can be
     *  combined specity SOC_PPC_NOF_FP_PREDEFINED_ACL_KEYS).
     */
    for (mapId = 0; mapId < unitData->devInfo->mappings; mapId++) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %u checking stage %u (%s) type"
                              " %u (%s) map %u to see if it fits here...\n"),
                   unit,
                   group,
                   unitData->devInfo->stMapInfo[mapId].stmStage,
                   unitData->devInfo->stage[unitData->devInfo->stMapInfo[mapId].stmStage].stageName,
                   unitData->devInfo->stMapInfo[mapId].stmType,
                   unitData->devInfo->typeNames[unitData->devInfo->stMapInfo[mapId].stmType],
                   mapId));
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.qsetType.get(unit, unitData->devInfo->stMapInfo[mapId].stmStage, unitData->devInfo->stMapInfo[mapId].stmType, &qsetType));
        result = _bcm_dpp_field_qset_subset(qsetType, qset);
        if (BCM_E_NONE == result) {
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.is_allocated(unit, unitData->devInfo->stMapInfo[mapId].stmStage, mode, &modeBits_is_allocated));
            if (bcmFieldGroupModeAuto == mode) {
                /* this one fits, and mode is auto; use this one */
                break;
            } else if (modeBits_is_allocated) {
                /* this one fits, and requested mode supported; use it */
                break;
            }
        }
    } /* for (index = 0; index < unitData->devInfo->mappings; index++) */
    if (mapId < unitData->devInfo->mappings) { 
        /*
         *  Found a stage+type mapping that covers the entire QSET; we don't
         *  need to try to combine things or look further than this; use it.
         */
        *stage = unitData->devInfo->stMapInfo[mapId].stmStage;
        *types = 1 << (unitData->devInfo->stMapInfo[mapId].stmType);
        *flags = unitData->devInfo->stMapInfo[mapId].stmFlags;
        (*flags) |= _BCM_DPP_FIELD_GROUP_IN_USE | _BCM_DPP_FIELD_GROUP_PHASE;
        *predefKey = unitData->devInfo->stMapInfo[mapId].predefKey;
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %u appears to fit in stage %u"
                              " (%s) as type %u (%s) -- map ID %u (%08X)\n"),
                   unit,
                   group,
                   *stage,
                   _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, *stage).stageName,
                   unitData->devInfo->stMapInfo[mapId].stmType,
                   unitData->devInfo->typeNames[unitData->devInfo->stMapInfo[mapId].stmType],
                   mapId,
                   *types));
    } else { /* if (mapId < unitData->devInfo->mappings) */
        /*
         *  The proposed QSET does not match a single stage/type mapping.
         *
         *  It is still possible to combine mappings, to a degree, to obtain a
         *  QSET that will cover the proposed QSET.
         *
         *  There are, however, limitations.
         *
         *  1: it is only possible to combine mappings within a single stage
         *
         *  2: it is not possible to combine mappings that use fixed QSETs
         *
         *  This is also a pretty rigorous check: it tries to verify every
         *  possible combination of types in every possible stage, skipping a
         *  combination only when a proposed combination of types is
         *  impossible for some reason (stage that can not possibly cover the
         *  proposed QSET, a type in a stage uses a fixed QSET, a type that is
         *  not used in a stage, or similar). Thankfully the number of stages
         *  is reasonable, and the number of types per stage is reasonable, so
         *  the procedure's O((#stages) * (2 ^ (#types))) behaviour is not
         *  quite as bad as it might seem.
         */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d unable to find a single stage+type"
                              " that covers proposed QSET; searching for"
                              " combinations of types within each stage\n"),
                   unit));
        *stage = unitData->devInfo->stages; /* best stage so far */
        *flags = 0; /* best flags so far */
        ftypes = 0; /* best stage bits so far (which types in stage) */
        awidth = ~0; /* smallest matching qset union so far (qual count) */
        sal_memset(&bqset, 0x00, sizeof(bqset)); /* best fit qset so far */
        *predefKey = SOC_PPC_NOF_FP_PREDEFINED_ACL_KEYS; /* no predef keys here */
        for (base = 0; base < unitData->devInfo->stages; base++) {
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.stgQset.get(unit, base, &stgQset));
            result =  _bcm_dpp_field_qset_subset(stgQset, qset);
            if (BCM_E_NONE != result) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d stage %u (%s) QSET does not"
                                      " cover all qualifiers in proposed"
                                      " QSET\n"),
                           unit,
                           base,
                           _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, base).stageName));
                continue;
            }
            if (0 == (_BCM_DPP_FIELD_STAGE_DEV_INFO(unit, base).stageFlags &
                      _BCM_DPP_FIELD_DEV_STAGE_FLAG_ALLOW_TYPE_MERGE)) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d stage %u (%s) does not allow"
                                      " qualifier types to be merged\n"),
                           unit,
                           base,
                           _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, base).stageName));
                continue;
            }
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d stage %u (%s) checking"
                                  " combinations of types to match proposed"
                                  " QSET (%u combinations to check)\n"),
                       unit,
                       base,
                       _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, base).stageName,
                       1 << unitData->devInfo->types));
            for (ftypes = 0;
                 ftypes < (1 << unitData->devInfo->types);
                 ftypes++) {
                /* for all possible combinations of types in this stage */
                tflags = 0;
                sal_memset(&uqset, 0x00, sizeof(uqset));
                result = BCM_E_NONE;
                type = unitData->devInfo->types;
                for (index = 0; index < unitData->devInfo->types; index++) {
                    /* for all types possible in this stage */
                    if (ftypes & (1 << index)) {
                        /* this type was selected */
                        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.ltOffset.get(unit, base, index, &ltOffset));
                        if (unitData->devInfo->mappings <= ltOffset) {
                            /* this type does not exist in this stage */
                            result = BCM_E_FAIL;
                            break;
                        }

                        if (SOC_PPC_NOF_FP_PREDEFINED_ACL_KEYS >
                            unitData->devInfo->stMapInfo[ltOffset].predefKey) {
                            /* uses predefined key; can not combine */
                            result = BCM_E_FAIL;
                            break;
                        }
                        if (((_BCM_DPP_FIELD_GROUP_IPV4 & (tflags)) &&
                             (_BCM_DPP_FIELD_GROUP_IPV6 & unitData->devInfo->stMapInfo[ltOffset].stmFlags)) ||
                            ((_BCM_DPP_FIELD_GROUP_IPV6 & (tflags)) &&
                             (_BCM_DPP_FIELD_GROUP_IPV4 & unitData->devInfo->stMapInfo[ltOffset].stmFlags))) {
                            /*
                             *  This type includes IPv6 when we already have
                             *  IPv4, or the type includes IPv4 when we already
                             *  have IPv6; can not combine
                             */
                            result = BCM_E_FAIL;
                            break;
                        }
                        /* merge this stage+type flags and qset */
                        type = index;
                        tflags |= unitData->devInfo->stMapInfo[ltOffset].stmFlags;
                        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.qsetType.get(unit, base, index, &qsetType));
                        _bcm_dpp_field_qset_union(&uqset,
                                                  &qsetType,
                                                  &uqset);
                    } /* if (types & (1 << index)) */
                } /* for (index = 0; index < unitData->devInfo->types; index++) */
                if (BCM_E_NONE == result) {
                    /* this combination of types was valid; check matching */
                    _bcm_dpp_field_qset_subset_count(&qset,
                                                     &uqset,
                                                     &uq0,
                                                     &uq1,
                                                     &uq2);
                    if ((uq0 <= uq1) && (uq0 == uq2)) {
                        LOG_DEBUG(BSL_LS_BCM_FP,
                                  (BSL_META_U(unit,
                                              "unit %d stage %d (%s) types"
                                              " %08X is a candidate for use"
                                              " in matching proposed QSET:"
                                              " %u quals proposed, %u"
                                              " quals in union, flags"
                                              " %08X\n"),
                                   unit,
                                   base,
                                   _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, base).stageName,
                                   ftypes,
                                   uq0,
                                   uq1,
                                   tflags));
                        /* this union covers it; see if it's best so far */
                        if (uq1 < awidth) {
                            /* this is more compact than prior best; keep it */
                            LOG_DEBUG(BSL_LS_BCM_FP,
                                      (BSL_META_U(unit,
                                                  "unit %d stage %d (%s)"
                                                  " types %08X is best"
                                                  " candidate so far for the"
                                                  " proposed QSET\n"),
                                       unit,
                                       base,
                                       _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, base).stageName,
                                       ftypes));
                            *stage = base;
                            *flags = tflags | (_BCM_DPP_FIELD_GROUP_IN_USE |
                                               _BCM_DPP_FIELD_GROUP_PHASE);
                            *types = ftypes;
                            awidth = uq1;
                            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.ltOffset.get(unit, *stage, type, &mapId));
                        }
                    } /* if ((uq0 <= uq1) && (uq0 == uq2)) */
                } /* if (BCM_E_NONE == result) */
            } /* for (all possible type combinations) */
        } /* for (base = 0; base < unitData->devInfo->stages; base++) */
    } /* if (mapId < unitData->devInfo->mappings) */

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.is_allocated(unit, *stage, mode, &modeBits_is_allocated));
    if (!modeBits_is_allocated) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
               (_BSL_BCM_MSG_NO_UNIT("The mode bits of specified qset is not allocated for specified mode %d (%s) on unit %d stage %u."),
               mode, _bcm_dpp_field_group_mode_name[mode], unit, *stage));
    }

    if (mapId >= unitData->devInfo->mappings) {
        /*
         *  At this point, mapId would either be the single mapping that covers
         *  the proposed QSET, or it would be the last one out of a set of
         *  them to cover the proposed QSET.  In either case, if it is still
         *  not inside the range of valid mappings, could not find any way to
         *  map the proposed QSET to a stage/type combination.
         */
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d does not support a stage"
                                           " and type that includes the"
                                           " requested qset and mode"),
                          unit));
    } /* if (mapId >= unitData->devInfo->mappings) */

    /* Check that all the UDF's stage is the same as the QSET stage */
    _bcm_dpp_bcm_stage_from_ppd_stage(unitData, *stage, &bcmStage);
    for (index = 0;
         (index < BCM_FIELD_USER_NUM_UDFS) && (BCM_E_NONE == result);
         index++) {
        if (SHR_BITGET(qset.udf_map, index)) {
            BCMDNX_IF_ERR_EXIT(_bcm_petra_field_data_qualifier_get(unitData, index, &qual));
            if (bcmStage != qual.stage) {
                result = BCM_E_FAIL;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "stage of data field qualifier %d is "
                                      "not consistent with the qset's stage\n"),
                           index));
                BCMDNX_IF_ERR_EXIT(result);
            }
        }
    }

    /* need to convert the BCM qset into a PPD qset */
    if (SOC_PPC_NOF_FP_PREDEFINED_ACL_KEYS <= (*predefKey)) {
        /* perform conversion based upon actual caller-provided qset */
        result = _bcm_dpp_field_quals_to_ppd(unitData,
                                             *stage,
                                             *types,
                                             qset,
                                             ppdqset,
                                             apiWidth,
                                             hwWidth,
											 &kbp_sip_dip_sharing);
        if (BCM_E_NONE == result) {
            for (ppdQual = 0, index = 0;
                 ppdQual < SOC_PPC_NOF_FP_QUAL_TYPES;
                 ppdQual++) {
                if (SHR_BITGET(*ppdqset, ppdQual)) {
                    if (unitData->devInfo->stage[*stage].entryMaxQuals >
                        index) {
                        tempPpdQuals[index] = ppdQual;
                    }
                    index++;
                }
            }
            if (unitData->devInfo->stage[*stage].entryMaxQuals <= index) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG_NO_UNIT("proposed qset will not fit"
                                                   " in unit %d stage %u: it"
                                                   " has more qualifiers %u"
                                                   " than allowed %u"),
                                  unit,
                                  *stage,
                                  index,
                                  unitData->devInfo->stage[*stage].entryMaxQuals));
            }
        } else { /* if (BCM_E_NONE == result) */
            BCMDNX_IF_ERR_EXIT_MSG(result,
                                (_BSL_BCM_MSG_NO_UNIT("unit %d unable to convert"
                                                  " qset to PPD: %d (%s)"),
                                 unit,
                                 result,
                                 _SHR_ERRMSG(result)));
        } /* if (BCM_E_NONE == result) */
    } else { /* if (SOC_PPC_NOF_FP_PREDEFINED_ACL_KEYS > (*predefKey)) */
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG_NO_UNIT("unit %d: unsupported device type."), unit));
    } /* if (SOC_PPC_NOF_FP_PREDEFINED_ACL_KEYS > (*predefKey)) */

    /*
     *  Now, the list of PPD qualifiers and the PPD qset are aligned, and we
     *  are sure that they amount to a superset of the BCM qualifiers.  In
     *  order to avoid gratuitous state, and allow easier recovery, we go ahead
     *  and assume any BCM qualifiers implied by the PPD qualifier set.  This
     *  means, for each member of the PPD qualifier list, scanning the
     *  qualifier table and adding any BCM qualifiers that refer to that PPD
     *  qualifier in the selected stage and type to the BCM qualifier set.
     */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_group_qset_recover(unitData,
                                                              *stage,
                                                              *types,
                                                              ppdqset,
                                                              tqset));

    /* make sure the width makes sense */
    if (0 == *hwWidth) {
		if (kbp_sip_dip_sharing == 0) {
			BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
								(_BSL_BCM_MSG_NO_UNIT("specified qset does not contain"
													  " any normal qualifiers")));
		} else {
			/* case of hwWidth == 0 and sip dip sharing is set is valid
			   do not need to do any futher length checking
			*/
			goto exit;
		}
    }
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.mode.get(unit, *stage, mode, &modBits_mode));
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.entryType.get(unit, *stage, mode, &entryType));
    if (bcmFieldGroupModeDirect == modBits_mode) {
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.length.get(unit, *stage, mode, &length));
        if (length < *hwWidth) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG_NO_UNIT("specified qset is too wide %u"
                                               " for specified mode %d (%s) on"
                                               " unit %d stage %u, max %u"),
                              *hwWidth,
                              mode,
                              _bcm_dpp_field_group_mode_name[mode],
                              unit,
                              *stage,
                              length));
        }
    }
    else if (_BCM_DPP_FIELD_ENT_TYPE_IS_TCAM(entryType)) {
        /* TCAM groups must always fit in stage worst case max width */
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.length.get(unit, *stage, bcmFieldGroupModeAuto, &length));
        if (length <
            *hwWidth) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG_NO_UNIT("specified qset is too wide %u"
                                               " for unit %d stage %u, max %u"),
                              *hwWidth,
                              unit,
                              *stage,
                              length));
        }
#if _BCM_DPP_FIELD_ENFORCE_WIDTH
        /* optional check to force TCAM groups into 'mode' specified width */
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.length.get(unit, *stage, mode, &length));
        if (length < *hwWidth) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG_NO_UNIT("specified qset is too wide %u"
                                               " for specified mode %d (%s) on"
                                               " unit %d stage %u, max %u"),
                              *hwWidth,
                              mode,
                              _bcm_dpp_field_group_mode_name[mode],
                              unit,
                              *stage,
                              length));
        }
#endif /* _BCM_DPP_FIELD_ENFORCE_WIDTH */
    } else {
        if (SOC_IS_ARADPLUS(unit) 
            && (SHR_BITGET(*ppdqset, SOC_PPC_FP_QUAL_IS_EQUAL)
                || SHR_BITGET(*ppdqset, SOC_PPC_FP_QUAL_KEY_AFTER_HASHING))
            ) 
        {
            /* In ARAD+, in case this field group is for Compare operation,
             * key length can be up to 80 bits (Direct Extraction is max of 
             * 32 bits and in for the second field group, is taken from the 
             * MSB bits [128:159]). 
             */
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.length.get(unit, *stage, bcmFieldGroupModeSingle, &length));
            if (length < *hwWidth)
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG_NO_UNIT("Specified qset is too wide %u "
                                                   "for specified mode %d (%s) when "
                                                   "flag IS_EQUAL is used on unit %d "
                                                   "stage %u, max %u"),
                                  *hwWidth,
                                  mode,
                                  _bcm_dpp_field_group_mode_name[mode],
                                  unit,
                                  *stage,
                                  length));
            }
        }
        else{ 
            /* other group modes must fit into their specified max widths */
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.length.get(unit, *stage, mode, &length));
            if (length < *hwWidth) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG_NO_UNIT("specified qset is too wide %u"
                                                   " for specified mode %d (%s) on"
                                                   " unit %d stage %u, max %u"),
                                  *hwWidth,
                                  mode,
                                  _bcm_dpp_field_group_mode_name[mode],
                                  unit,
                                  *stage,
                                  length));
            }
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_group_copy_aset
 *  Purpose
 *     Convert a BCM aset into a set of PPD actions
 *  Parameters
 *     (in) unitData = unit information
 *     (in) stage = stage for the group
 *     (in) type = type for the group
 *     (in) aset = BCM aset
 *     (out) taset = where to put adjusted aset
 *     (out) ppdaset = where to put PPD aset
 *     (out) size = number of actions included
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if the proposed qset is acceptable
 *        BCM_E_* appropriately if not
 *  Notes
 *     This is used by the group create and group set class functions.
 *
 *     Will clobber all out args even if error.
 */
STATIC int
_bcm_dpp_field_group_copy_aset(bcm_dpp_field_info_OLD_t *unitData,
                                 _bcm_dpp_field_grp_idx_t group,
                                 _bcm_dpp_field_stage_idx_t stage,
                                 const bcm_field_aset_t *aset,
                                 bcm_field_aset_t *taset,
                                 _bcm_dpp_field_action_set_t *ppdaset)
{
    bcm_field_aset_t xaset;
    int action_ndx;
    unsigned int size;
    uint32 action_width;
    uint32 action_lsb_egress;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    unit = unitData->unit;

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.stgAset.get(unit, stage, &xaset));

    if (_BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage).stageFlags &
        _BCM_DPP_FIELD_DEV_STAGE_FLAG_IMPLIED_ACTION) {
        _bcm_dpp_field_actions_to_ppd(unitData,
                                      stage,
                                      &xaset,
                                      ppdaset,
                                      &size);
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.stgAset.get(unit, stage, taset));
    } else { /* if (this stage has implied action set) */
        _bcm_dpp_field_actions_to_ppd(unitData,
                                      stage,
                                      aset,
                                      ppdaset,
                                      &size);
        if (0 == size) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG_NO_UNIT("at least one supported action"
                                               " must be included\n")));
        }
        /* now generate a BCM action set including the implied actions */
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_group_aset_recover(unitData,
                                                                  stage,
                                                                  ppdaset,
                                                                  taset));
    } /* if (this stage has implied action set) */

    /* At last, fill in all the relevant action width constrains (only for INGRESS stage)
     * This logic is required for valid_bits feature, so we do it starting JER+,
     * OR for UDH actions width trimming in all devices.
     */
    if (stage == _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
        for (action_ndx = 0; action_ndx < SOC_PPC_FP_NOF_ACTIONS_PER_DB_MAX; action_ndx++) {
            bcm_field_action_t action = aset->actions_width[action_ndx].action;
            SOC_PPC_FP_ACTION_TYPE *actChain = NULL;
            if ((SOC_IS_JERICHO_PLUS(unit) ||
                action == bcmFieldActionClassDestSet ||
                action == bcmFieldActionClassSourceSet) &&
                aset->actions_width[action_ndx].valid) {
                BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_ppd_act_from_bcm_act(unitData,
                                                           stage,
                                                           aset->actions_width[action_ndx].action,
                                                           &actChain),
                        (_BSL_BCM_MSG_NO_UNIT("Couldn't parse action %s!\n"),
                                 _bcm_dpp_field_action_name[aset->actions_width[action_ndx].action]));
                if (!is_ppc_action_width_changeable(actChain[0])) {
                     LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "Action %s can't have its width changed! Ignoring value.\n"),
                               SOC_PPC_FP_ACTION_TYPE_to_string(actChain[0])));
                     /* We're unforgiving, FAIL hard */
                     BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
                }
                /* Retrive action's max width */
                BCMDNX_IF_ERR_EXIT_MSG(arad_pmf_db_fes_action_size_get_unsafe(
                    unit,
                    actChain[0],
                    stage,
                    &action_width,
                    &action_lsb_egress),
                    (_BSL_BCM_MSG_NO_UNIT("Couldn't retrive action %s length\n"),
                             _bcm_dpp_field_action_name[aset->actions_width[action_ndx].action]));

                if (action_width < aset->actions_width[action_ndx].width) {
                     LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "Bad width - max width for action %s is %d. Requested %d\n"),
                           SOC_PPC_FP_ACTION_TYPE_to_string(actChain[0]), action_width, aset->actions_width[action_ndx].width));
                     /* Failing hard again this time it's bad width size */
                     BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
                }
                /* The bcm action is translated to ppd action before being assigned to
                 * taset.actions_width.action. This is because later on, the comparision
                 * is made against ppd actions, and it's better converted here than in
                 * later stage.
                 */
                taset->actions_width[action_ndx].action = actChain[0];
                taset->actions_width[action_ndx].valid = aset->actions_width[action_ndx].valid;
                taset->actions_width[action_ndx].width = aset->actions_width[action_ndx].width;
            }
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_group_verify_aset
 *  Purpose
 *     Verifies aset is correct
 *  Parameters
 *     (in) unitData = unit information
 *     (in) stage = stage for the group
 *     (in) aset = BCM aset
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if the proposed qset is acceptable
 *        BCM_E_* appropriately if not
 */
STATIC int
_bcm_dpp_field_group_verify_aset(bcm_dpp_field_info_OLD_t *unitData,
                                 _bcm_dpp_field_stage_idx_t stage,
                                 const bcm_field_aset_t *aset)
{
    bcm_field_aset_t xaset;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.stgAset.get(unit, stage, &xaset));

    if (_BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage).stageFlags &
        _BCM_DPP_FIELD_DEV_STAGE_FLAG_IMPLIED_ACTION) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d stage %u flags %d uses implied action set;"
                              " action set will reflect hardware\n"),
                   unit,
                   stage,
                   _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage).stageFlags));
    } else { /* if (this stage has implied action set) */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d stage %u allows configurable action"
                              " set; building action set\n"),
                   unit,
                   stage));
    } /* if (this stage has implied action set) */
    BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_aset_subset(&xaset,
                                                   (bcm_field_aset_t*) aset),
                        (_BSL_BCM_MSG_NO_UNIT("specified action set is not"
                                          " supported by unit %d stage %u"),
                         unit,
                         stage));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_group_action_set
 *  Purpose
 *     Set the action set for a group
 *   Parameters
 *     (in) unitData = unit information
 *     (in) group = group number
 *     (in) aset = group aset
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
STATIC int
_bcm_dpp_field_group_action_set(bcm_dpp_field_info_OLD_t *unitData,
                                _bcm_dpp_field_grp_idx_t group,
                                const bcm_field_aset_t *aset,
                                uint32 pgm_bmp)
{
    _bcm_dpp_field_group_t newGroupData;
    _bcm_dpp_field_stage_idx_t stage;
    uint32 groupFlags;
    int result;
    bcm_field_aset_t aset_tmp;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;
    /* set for keep location mode */
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.num_entry_in_keep_location.set(unit, group, 0));

    sal_memcpy(&aset_tmp, aset, sizeof(aset_tmp));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, group, &stage));
    /*
     * For QAX and Jericho+, Redirect and Drop actions are different in hardware. 
     * In order to support priority of FG, reset of Drop action is added together with Redirect action by sofeware. 
     */
    if (SOC_IS_JERICHO_PLUS(unit) && (SOC_PPC_FP_DATABASE_STAGE_INGRESS_PMF == _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage).hwStageId)) {
        if (!BCM_FIELD_ASET_TEST(*aset, bcmFieldActionDrop) && 
                (BCM_FIELD_ASET_TEST(*aset, bcmFieldActionRedirect)
                || BCM_FIELD_ASET_TEST(*aset, bcmFieldActionL3Switch)
                || BCM_FIELD_ASET_TEST(*aset, bcmFieldActionRedirectTrunk)
                || BCM_FIELD_ASET_TEST(*aset, bcmFieldActionRedirectIpmc)
                || BCM_FIELD_ASET_TEST(*aset, bcmFieldActionRedirectMcast)
                || BCM_FIELD_ASET_TEST(*aset, bcmFieldActionForward)
                || BCM_FIELD_ASET_TEST(*aset, bcmFieldActionTrapCodeQualifier))) {
            if (!soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "field_action_redirect_jer_style", 0)) {
                BCM_FIELD_ASET_ADD(aset_tmp, bcmFieldActionDrop);
            }
        }
    }

    if (SOC_IS_QAX(unit) && BCM_FIELD_ASET_TEST(*aset, bcmFieldActionStatTag)) {
        LOG_WARN(BSL_LS_BCM_FP,
                 (BSL_META_U(unit, 
                             "bcmFieldActionStatTag has no effect on BCM88470 and above.\n"
                             "Use bcmFieldActionStatisticPtr0/bcmFieldActionStatisticPtr1 instead")));
    }

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
    if (0 == (groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u is not in use"),
                          unit,
                          group));
    }
    /* make a copy of current group state */
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.get(unit, group, &newGroupData));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_group_verify_aset(unitData,
                                                             newGroupData.stage,
                                                             &aset_tmp));

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_group_copy_aset(unitData,group,
                                                             newGroupData.stage,
                                                             &aset_tmp,
                                                             &(newGroupData.aset),
                                                             &(newGroupData.paset)));
    /*
     *  Keep a copy of the 'original' (caller's) ASET because if the group is
     *  moved between stages or types (due to changes in the QSET), we want to
     *  recalculate the ASET without including whatever was implied by the
     *  current stage/type (so with only the actions the caller originally
     *  specified when setting the group's ASET).
     */
    sal_memcpy(&(newGroupData.oaset),
               &aset_tmp,
               sizeof(newGroupData.oaset));

    /* if field grop was created with program ID copy variables*/
    if (groupFlags & _BCM_DPP_FIELD_GROUP_WITH_PROGRAM_ID) {
            newGroupData.pgm_bmp = pgm_bmp;
    }

    result = _bcm_dpp_field_group_hardware_install(unitData,
                                                   group,
                                                   &newGroupData);
    BCMDNX_IF_ERR_EXIT_MSG(result,
                        (_BSL_BCM_MSG_NO_UNIT("unable to set unit %d group %u to"
                                          " hardware: %d (%s)"),
                         unit,
                         group,
                         result,
                         _SHR_ERRMSG(result)));
    /* we can commit the changes to the state for the group */
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.set(unit, group, &newGroupData));
#ifdef BCM_WARM_BOOT_SUPPORT
    /*_bcm_dpp_field_group_wb_save(unitData, group, NULL, NULL);*/
#endif /* def BCM_WARM_BOOT_SUPPORT */

exit:
    BCMDNX_FUNC_RETURN;
}



/*
 *  Function
 *     _bcm_dpp_field_group_hw_info_reset
 *  Purpose: Reset the HW ID info per given field group
 *  Parameters
 *     (in) unitData = unit information
 *     (in) group = group number
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if successful
 *  Notes
 *     This call is used by all of the group create functions.
 *     This function was created in order to byppass the coverity "big stack issue"
 */

STATIC int
_bcm_dpp_field_group_hw_info_reset(
                                    int unit,
                                    _bcm_dpp_field_grp_idx_t group)
{
    int ii;
    /*
     * Set narrow scope to large local variables to save stack.
     */
    bcm_field_group_presel_info_t presel_info;
    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&presel_info, 0x00, sizeof(presel_info));
    for (ii = 0; ii < BCM_FIELD_NOF_PRESEL_PER_FG; ii++)
    {
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupHwInfo.presel_info.set(unit, group, ii, &presel_info));
    }
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupHwInfo.nof_presel_info.set(unit, group, 0));

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_group_create_mode_id
 *  Purpose
 *     Create a group with the specified mode and ID
 *  Parameters
 *     (in) unitData = unit information
 *     (in) group = group number
 *     (in) qset = Pointer to group qset
 *     (in) mode = group mode
 *     (in) priority = group priority
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if successful
 *        BCM_E_* appropriately if not
 *  Notes
 *     This call is used by all of the group create functions.  It is not
 *     permitted to have two groups of same priority or with same qset.
 *
 *     We only allow priority values 0..127, and they are exactly reversed
 *     between BCM and DPP layers (BCM lower number is lower priority, DPP
 *     higher number is lower priority).
 */
STATIC int
_bcm_dpp_field_group_create_mode_id(bcm_dpp_field_info_OLD_t *unitData,
                                    _bcm_dpp_field_grp_idx_t group,
                                    bcm_field_qset_t *qset,
                                    int priority,
                                    uint32 group_config_flags,
                                    bcm_field_group_mode_t mode,
                                    int max_entry_priorities)
{
    int result;
    int auxRes;
    unsigned int apiSize = 0;
    unsigned int hwSize = 0;
    unsigned int index;
    uint32 flags = 0;
    uint32 flags_vt_hs = 0; /*added flags for vlan translation and header selection*/
    uint32 types;
    uint32 internal_table_id = 0;
    _bcm_dpp_field_grp_idx_t currGroup;
    _bcm_dpp_field_grp_idx_t nextGroup;
    _bcm_dpp_field_stage_idx_t stage = unitData->devInfo->stages;
    _bcm_dpp_field_type_idx_t type;
    _bcm_dpp_field_qual_set_t ppdqset;
    uint32 ppd_qaul_adjust = FALSE;
/*    uint32 ppdqset[_SHR_BITDCLSIZE(SOC_PPC_NOF_FP_QUAL_TYPES)];*/

/*	    SHR_BITDCL ppdqset[_SHR_BITDCLSIZE(SOC_PPC_NOF_FP_QUAL_TYPES)];*/

    SOC_PPC_FP_PREDEFINED_ACL_KEY predefKey = SOC_PPC_NOF_FP_PREDEFINED_ACL_KEYS;
    bcm_field_qset_t tqset;
    int use_small_banks = (group_config_flags & BCM_FIELD_GROUP_CREATE_SMALL)? 1: 0;
    int use_single_bank = (group_config_flags & BCM_FIELD_GROUP_CREATE_SINGLE)? 1: 0;
    int no_insertion_priority_order = (group_config_flags & BCM_FIELD_GROUP_CREATE_INSERTION_ORDER_LOOSE)? 1: 0;
    int sparse_priorities = (group_config_flags & BCM_FIELD_GROUP_CREATE_SPARSE_ENTRY_PRIORITIES)? 1: 0;
    int ignore_implied_indicator = (group_config_flags & BCM_FIELD_GROUP_CREATE_WITH_PRESELSET) ? 1 : 0;
    int is_equal = (group_config_flags & BCM_FIELD_GROUP_CREATE_IS_EQUAL)? 1: 0;
    SOC_DPP_DBAL_PHYSICAL_DB_TYPES physicalDB = SOC_DPP_DBAL_PHYSICAL_DB_TYPE_LEM;
    unsigned int dataFieldRefs;
    _bcm_dpp_field_entry_type_t entryType;
    _bcm_dpp_field_grp_idx_t groupTail;
    _bcm_dpp_field_grp_idx_t groupCount;
    _bcm_dpp_field_stage_idx_t groupSh1;
    _bcm_dpp_field_dq_idx_t dqLimit;
    _bcm_dpp_field_ent_idx_t limit;
    _bcm_dpp_field_grp_idx_t groupLimit;
    _bcm_dpp_field_ent_idx_t entryHead;
    _bcm_dpp_field_grp_idx_t groupNext;
    _bcm_dpp_field_grp_idx_t groupPrev; 
    int groupD_priority; 
    uint32 groupD_groupFlags;
    _bcm_dpp_field_stage_idx_t groupD_stage; 
     bcm_field_group_mode_t groupD_grpMode;
     _bcm_dpp_field_grp_idx_t groupD_groupPrev;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryHead.get(unit, group, &entryHead));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.get(unit, group, &groupNext));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.get(unit, group, &groupPrev));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupD_groupFlags));

    /* Useless. was:
         BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.get(unit, group, &groupInfo));
     */
    if (groupD_groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_EXISTS,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %d already exists"),
                          unit,
                          group));
    }

    /* if bcmFieldQualifyStageIngressVlanTranslation is in the qset, the qset must belong to one of the predefined groups of the VT stage. */
    if ((BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyStageIngressVlanTranslation)) || (BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyStageIngressTunnelTerminated)))
    {
        uint32 flag = 0;
        uint8 found;
        BCM_FIELD_QSET_REMOVE(*qset,bcmFieldQualifyStageIngressVlanTranslation);
        BCM_FIELD_QSET_REMOVE(*qset,bcmFieldQualifyStageIngressTunnelTerminated);

        /*Validate QSET is as expected.*/
        _bcm_dpp_field_group_verify_vt_classification_qset(unit, qset, &internal_table_id, &found, &flag);

        if ( found && (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vt_tst2", 0)) )
        {
            ppd_qaul_adjust = TRUE;
        }

        if (!found) {
            flag = _BCM_DPP_FIELD_GROUP_USE_DBAL;
            internal_table_id = 0;
        }

        BCM_FIELD_QSET_ADD(*qset,bcmFieldQualifyStageIngress);
        flags_vt_hs |= flag;

        if(mode == bcmFieldGroupModeExactMatch) {
            mode = bcmFieldGroupModeAuto;
            physicalDB = SOC_DPP_DBAL_PHYSICAL_DB_TYPE_SEM_A;
        }else{
            physicalDB = SOC_DPP_DBAL_PHYSICAL_DB_TYPE_TCAM;
        }
    }

    
    if ((BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyStageLookup)) || (BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyStageExternal))){
        uint8 found = 0;
        uint32 flag = 0;
        uint32 is_stage_lookup = 0;

        if(BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyStageLookup)) {
            is_stage_lookup = 1;
        }

        BCM_FIELD_QSET_REMOVE(*qset,bcmFieldQualifyStageLookup);
        _bcm_dpp_field_group_verify_flp_classification_qset(unit,qset, &internal_table_id, &found, &flag);

        if (found) {
            flags_vt_hs |= flag;
            if(is_stage_lookup){
                /* stage look is equal to egress by supported qualifiers and actions, the only different is the physical DB the stage external is
                   already implemented so we use it for validations. */
                BCM_FIELD_QSET_ADD(*qset,bcmFieldQualifyStageIngress);
            }

        } else {
            if(is_stage_lookup){
                flags_vt_hs |= _BCM_DPP_FIELD_GROUP_USE_DBAL; 
                internal_table_id = 0;
            }
        }

        if(mode == bcmFieldGroupModeExactMatch) {
            mode = bcmFieldGroupModeAuto;
            physicalDB = SOC_DPP_DBAL_PHYSICAL_DB_TYPE_LEM; /* LEM */
        }else{
            physicalDB = SOC_DPP_DBAL_PHYSICAL_DB_TYPE_TCAM; /* TCAM */
        }
    }


    /*Inner MAC qualifiers requires header selection*/
    if ( ( BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyInnerSrcMac) ) || ( BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyInnerDstMac) ) )
    {
        if ( (BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyIp4)) || 
             (BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyIp6)) ||
             (BCM_FIELD_QSET_TEST(*qset, bcmFieldQualifyMpls)) )
        {
            flags_vt_hs |= _BCM_DPP_FIELD_GROUP_WITH_HEADER_SELECTION ; /*header selction required - take 3rd header for inspection*/
        }
    }

    /* verify qset and related parameters */
    result = _bcm_dpp_field_group_verify_qset(unitData,
                                              group,
                                              *qset,
                                              mode,
                                              &tqset,
                                              &flags,
                                              &stage,
                                              &types,
                                              &predefKey,
                                              &apiSize,
                                              &hwSize,
                                              &ppdqset);
    BCMDNX_IF_ERR_EXIT_MSG(result,
                        (_BSL_BCM_MSG_NO_UNIT("unit %d failed to verify group %u"
                                          " qset and related parameters:"
                                          " %d (%s)"),
                         unit,
                         group,
                         result,
                         _SHR_ERRMSG(result)));

    flags |= flags_vt_hs; /*Here we add the vt and header selection flag to the group flags received after field_group_verify_qset*/

    if (ppd_qaul_adjust)
    {
        if (SHR_BITGET(ppdqset, SOC_PPC_FP_QUAL_HDR_VLAN_TAG_ID) )
        {
            SHR_BITCLR(ppdqset, SOC_PPC_FP_QUAL_HDR_VLAN_TAG_ID);
            SHR_BITSET(ppdqset, SOC_PPC_FP_QUAL_INITIAL_VID);
        }
        flags |= _BCM_DPP_FIELD_GROUP_VT_CLASSIFICATION;
    }

    /* verify (or select) priority */
    if ((BCM_FIELD_GROUP_PRIO_ANY != priority) &&
        ((0 > priority) || (_BCM_PETRA_FIELD_GROUP_PRIOS <= priority))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d only supports priority"
                                           " 0..1023 or"
                                           " BCM_FIELD_GROUP_PRIO_ANY"),
                          unit));
    }
    if ((max_entry_priorities != 0) && (stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d only supports max_entry_priorities"
                                           " parameter for external stage"),
                          unit));
    }
    /* Verify for IsEqual field groups that the right mode is being used */
    if (SOC_IS_ARADPLUS(unit)
        && is_equal)
    {
        if(SHR_BITGET(ppdqset, SOC_PPC_FP_QUAL_IS_EQUAL)) 
        {
            if (mode != bcmFieldGroupModeDirectExtraction) 
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u must be "
                                           "of type Direct Extraction "
                                           "for the specified set of "
                                           "qualifiers\n"),
                          unit,
                          group));
            }
            /* create second database for compare */
            flags |= _BCM_DPP_FIELD_GROUP_IS_EQUAL_MSB;
        }
        else 
        {
            if (mode == bcmFieldGroupModeDirectExtraction) 
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u cannot be "
                                           "of type Direct Extraction "
                                           "for the specified set of "
                                           "qualifiers\n"),
                          unit,
                          group));
            }
            /* create first database for compare */
            flags |= _BCM_DPP_FIELD_GROUP_IS_EQUAL_LSB;
        }
    }
    else 
    {
        if (SHR_BITGET(ppdqset, SOC_PPC_FP_QUAL_IS_EQUAL)) {
            /* Qualifier SOC_PPC_FP_QUAL_IS_EQUAL is only allowed
             * in Arad Plus devices and only in case the relevant 
             * flag is set, indicating this database is for Compare. 
             */
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                             (_BSL_BCM_MSG_NO_UNIT("bcmFieldQualifyIsEqualValue "
                                               "cannot be used in this mode")));
        }
    }

    /*
     *  BCM API definition does not want multiple groups at same priority or
     *  with same qset.  However, BCM_FIELD_GROUP_PRIO_ANY means that the API
     *  is expected to assign the priority value.  Amusingly, regression tests
     *  expect to be able to have groups with same qset, but also not to be
     *  able to have groups at the same priority.
     */
    {
        SHR_BITDCL priorities[_SHR_BITDCLSIZE(_BCM_PETRA_FIELD_GROUP_PRIOS)];

        sal_memset(&(priorities[0]), 0x00, sizeof(priorities));
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupHead.get(unit, stage, &nextGroup));
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));

        while (nextGroup < groupLimit) {
            currGroup = nextGroup;
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.get(unit, currGroup, &nextGroup));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.priority.get(unit, currGroup, &groupD_priority));
            SHR_BITSET(priorities, groupD_priority);
        } /* while (nextGroup < groupLimit) */
        if (BCM_FIELD_GROUP_PRIO_ANY == priority) {
            /* find the first free priority */
            for (priority = 0;
                 (priority < _BCM_PETRA_FIELD_GROUP_PRIOS) &&
                 (SHR_BITGET(priorities, priority));
                 priority++) {
                /* just iterate... */
            }
            if (_BCM_PETRA_FIELD_GROUP_PRIOS <= priority) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                                 (_BSL_BCM_MSG_NO_UNIT("unable to decide upon unit %d"
                                                   " group %d priority"),
                                  unit,
                                  group));
            }
        } else { /* if (BCM_FIELD_GROUP_PRIO_ANY == priority) */
            if (SHR_BITGET(priorities, priority)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                                 (_BSL_BCM_MSG_NO_UNIT("unit %d already has a group"
                                                   " in stage %u at priority %d"),
                                  unit,
                                  stage,
                                  priority));
            }
        } /* if (BCM_FIELD_GROUP_PRIO_ANY == priority) */
    }
    /* initial checks okay, allocate and fill in the group */
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.get(unit, group, &groupPrev));
    if (groupPrev < groupLimit) {
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.get(unit, group, &groupPrev));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.get(unit, group, &groupNext));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.set(unit, groupPrev, groupNext));
    } else {
        
        if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  allocate sw-state resources */
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.get(unit, group, &groupNext));
            result = FIELD_ACCESS.groupFree.set(unit, groupNext) ;
         }
    }
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.get(unit, group, &groupNext));
    if (groupNext < groupLimit) {
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.get(unit, group, &groupPrev));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.get(unit, group, &groupNext));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.set(unit, groupNext, groupPrev));
    }

    if (group_config_flags & BCM_FIELD_GROUP_CREATE_HANDLE_ENTRIES_BY_KEY) {
        flags |= _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY;
    }
        
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.get(unit, group, &currGroup));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.get(unit, group, &nextGroup));
    {
        /*
         * Set narrow scope to large local variables to save stack.
         */
        _bcm_dpp_field_group_t groupInfo;

        sal_memset(&groupInfo, 0x00, sizeof(groupInfo));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.set(unit, group, &groupInfo));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_group_hw_info_reset(unit, group));

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.physicalDB.set(unit, group, physicalDB));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.set(unit, group, currGroup));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.set(unit, group, nextGroup));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.cascadePair.set(unit, group, groupLimit));
    groupD_groupFlags = flags | _BCM_DPP_FIELD_GROUP_PHASE;
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupD_groupFlags));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.qset.set(unit, group, &tqset));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.pqset.bit_range_write(unit, group, 0, 0, _SHR_BITDCLSIZE(SOC_PPC_NOF_FP_QUAL_TYPES) * (8 * sizeof(int))/*32bits in int*/, ppdqset));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.priority.set(unit, group, priority));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.predefKey.set(unit, group, predefKey));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.set(unit, group, stage));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupTypes.set(unit, group, types));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.maxEntryPriorities.set(unit, group, max_entry_priorities));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.internal_table_id.set(unit, group, internal_table_id));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.handle_by_key_entry_id.set(unit, group, _BCM_DPP_FIELD_GROUP_ENTRY_BY_KEY_EMPTY));

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.get(unit, group, &groupD_grpMode));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupD_groupFlags));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, group, &groupD_stage));

    if (bcmFieldGroupModeAuto == mode) {
        
        groupD_groupFlags |= _BCM_DPP_FIELD_GROUP_AUTO_SZ;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupD_groupFlags));

        _bcm_dpp_field_group_mode_from_size(unit,
                                            groupD_stage,
                                            groupD_groupFlags,
                                            hwSize,
                                            &(groupD_grpMode));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.set(unit, group, groupD_grpMode));
    } else { /* if (bcmFieldGroupModeAuto == mode) */
        groupD_grpMode = mode;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.set(unit, group, groupD_grpMode));
    } /* if (bcmFieldGroupModeAuto == mode) */
    if (use_small_banks) {
        /* Use the small TCAM banks */
        groupD_groupFlags |= _BCM_DPP_FIELD_GROUP_SMALL;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupD_groupFlags));
    }
    if (use_single_bank) {
        /* Use single bank */
        groupD_groupFlags |= _BCM_DPP_FIELD_GROUP_SINGLE_BANK;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupD_groupFlags));
    }
    if (no_insertion_priority_order) {
        /* Cancel the insertion priority order rule */
        groupD_groupFlags |= _BCM_DPP_FIELD_GROUP_LOOSE;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupD_groupFlags));
    }
    if (sparse_priorities) {
        /* Use the TCAM method with only few priorities */
        groupD_groupFlags |= _BCM_DPP_FIELD_GROUP_SPARSE_PRIO;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupD_groupFlags));
    }
    


    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.entryType.get(unit, stage, mode, &entryType));
    switch (entryType) {
    case _bcmDppFieldEntryTypeDirExt:
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &limit));
        break;
    case _bcmDppFieldEntryTypeExternalTcam:
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryExtTcLimit.get(unit, &limit));
        break;
    default:
        /* default is TCAM */
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryTcLimit.get(unit, &limit));
    }
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryHead.set(unit, group, limit));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryTail.set(unit, group, limit));

    /*
     *  Scan the existing groups and place this one in strict priority order.
     */
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupHead.get(unit, stage, &currGroup));

    while (currGroup < groupLimit) {
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.priority.get(unit, currGroup, &groupD_priority));
        if (groupD_priority < priority) {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.get(unit, currGroup, &currGroup));
        } else {
            break ;
        }
    }
    /* add the group into the used group list */
    if (currGroup < groupLimit) {
        /* index points to the group before which to insert new group */
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.set(unit, group, currGroup));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.get(unit, currGroup, &groupD_groupPrev));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.set(unit, group, groupD_groupPrev));
        if (groupD_groupPrev < groupLimit) {
            /* not at head of list */
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.get(unit, group, &groupD_groupPrev));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.set(unit, groupD_groupPrev, group));
        } else {
            /* at head of list */
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupHead.set(unit, stage, group));
        }
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.set(unit, currGroup, group));
    } else { /* if (currGroup < groupLimit) */
        /* fell off the list; tack on as tail */
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.set(unit, group, groupLimit));
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupTail.get(unit, stage, &groupTail));

        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.set(unit, group, groupTail));
        if (groupTail < groupLimit) {
            /* there is a list already, link into it */
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.set(unit, groupTail, group));
        } else {
            /* no list, so this is also head */
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupHead.set(unit, stage, group));
        }
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupTail.set(unit, stage, group));
    } /* if (currGroup < groupLimit) */
    /* account for the group being in use */
    if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  allocate sw-state resources */
        /*
         * Was:
         *   unitData->groupCount++;
         */
        _bcm_dpp_field_grp_idx_t groupCount ;

        result = FIELD_ACCESS.groupCount.get(unit, &groupCount) ;
        if (result == BCM_E_NONE) {
            groupCount++ ;
            result = FIELD_ACCESS.groupCount.set(unit, groupCount) ;
        }
    }

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupSh1.get(unit, stage, &groupSh1));
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupCount.get(unit, groupSh1, &groupCount));
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupCount.set(unit, groupSh1, ++groupCount));

    /* account for the group's references to programmable fields */
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.dqLimit.get(unit, &dqLimit));
    for (index = 0; index < dqLimit; index++) {
        if (SHR_BITGET(tqset.udf_map, index)) {
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.dataFieldRefs.get(unit, index, &dataFieldRefs));
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.dataFieldRefs.set(unit, index, ++dataFieldRefs));
        }
    }
#ifdef BCM_WARM_BOOT_SUPPORT
#if (0)
/* { */
    /*
     * All 'save' and 'sync' of old sw state are dropped.
     */
    _bcm_dpp_field_datafield_all_wb_save(unitData, NULL, NULL);
/* } */
#endif
#endif /* def BCM_WARM_BOOT_SUPPORT */

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupD_groupFlags));
    if (ignore_implied_indicator 
        && (_BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage).stageFlags & _BCM_DPP_FIELD_DEV_STAGE_FLAG_IMPLIED_ACTION))
    {
        
       
        groupD_groupFlags |= _BCM_DPP_FIELD_GROUP_WITH_PRESEL;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupD_groupFlags));

    }

    if (_BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage).stageFlags &
        _BCM_DPP_FIELD_DEV_STAGE_FLAG_IMPLIED_ACTION) {
        if (!(groupD_groupFlags & _BCM_DPP_FIELD_GROUP_WITH_PRESEL)) {

            type = unitData->devInfo->types;
            while ((0 == (types & (1 << type))) && (type > 0)) {
                type--;
            }
            /*
             *  This group is in a stage that support implied action sets; go ahead
             *  and assume the action set for the stage and type.
             */
            {
                bcm_field_aset_t stgAset;

                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.stgAset.get(unit, stage, &stgAset));
                result = _bcm_dpp_field_group_action_set(unitData,
                                                     group,
                                                     &stgAset,
                                                     0);
/*Review again*/
/*                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.stgAset.set(unit, stage, &stgAset);*/
            }
            if (BCM_E_NONE != result) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d group %u implied action set failed;"
                                      " backing out group: %d (%s)\n"),
                           unit,
                           group,
                           result,
                           _SHR_ERRMSG(result)));
                auxRes = _bcm_dpp_field_group_destroy(unitData, group);
                if (BCM_E_NONE != result) {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d unable to back out group %u"
                                          " after error setting implied action"
                                          " set: %d (%s)\n"),
                               unit,
                               group,
                               auxRes,
                               _SHR_ERRMSG(auxRes)));
                }
            }
        }
    } /* if (stageInfo->devInfo->impliedActionSet) */
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_field_group_hardware_install(bcm_dpp_field_info_OLD_t *unitData,
                                      _bcm_dpp_field_grp_idx_t group,
                                      _bcm_dpp_field_group_t *newGroupData)
{
    /* coverity[stack_use_overflow:FALSE] */
    SOC_PPC_FP_DATABASE_INFO dbInfo;
    SOC_PPC_FP_QUAL_TYPE qualType;
    SOC_PPC_FP_ACTION_TYPE actionType;
    uint32 action_ndx;
    uint32 ppdr;
    SOC_SAND_SUCCESS_FAILURE success;
    unsigned int index, idx;
    unsigned int offset;
    int result = BCM_E_NONE;
    int auxRes;
    _bcm_dpp_field_grp_idx_t groupLimit;
    _bcm_dpp_field_presel_idx_t preselLimit;
    uint32 groupD_groupFlags;
    _bcm_dpp_field_ent_idx_t groupD_entryCount;
    uint8 pqset_bit;
    _bcm_dpp_field_stage_idx_t groupD_stage; 
    uint8 is_new_fg_presel_set_void;
    bcm_field_presel_set_t preselSet;
    bcm_field_presel_t bmp_index;
    _bcm_dpp_field_qual_t preselQual[SOC_PPC_FP_NOF_QUALS_PER_DB_MAX];
    int stagered_idx=0;
    unsigned int preselRefs_element;
    bcm_field_group_cycle_t groupD_cycle;
    SOC_TMC_TCAM_ACTION_SIZE action_bitmap_ndx = SOC_TMC_NOF_TCAM_ACTION_SIZES;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_FIELD_QUAL_WB_TEST_MODE_CONTINUE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupD_groupFlags));
    if (0 == (groupD_groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u not in use"),
                          unit,
                          group));
    }
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryCount.get(unit, group, &groupD_entryCount));
    if (groupD_entryCount > 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u can not be"
                                           " changed while it has entries"),
                          unit,
                          group));
    }
    /* fill in the group information */
    SOC_PPC_FP_DATABASE_INFO_clear(&dbInfo);
    dbInfo.sw_db_id = group;
    dbInfo.strength = newGroupData->priority;
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.hwType.get(unit, newGroupData->stage, newGroupData->grpMode, &(dbInfo.db_type)));
    if (newGroupData->maxEntryPriorities == 0){
        /* invalid value */
        dbInfo.min_priority = -1;
    }
    else {
        dbInfo.min_priority = newGroupData->maxEntryPriorities;
    }

    if (groupD_groupFlags & _BCM_DPP_FIELD_GROUP_WITH_CYCLE) {
        if (newGroupData->stage != _BCM_DPP_FIELD_STAGE_INDEX_INGRESS) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u cycle set only support in ingress."),
                          unit, group));
        }

        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_WITH_CYCLE;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupCycle.get(unit, group, &groupD_cycle));
        dbInfo.cycle = groupD_cycle;
    }

    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_SMALL) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_USE_SMALL_BANKS;
    }
    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_SINGLE_BANK) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_USE_SINGLE_BANK;
    }
    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_LOOSE) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_NO_INSERTION_PRIORITY_ORDER;
    }
    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_SPARSE_PRIO) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_SPARSE_PRIORITIES;
    }

    if (SOC_IS_ARADPLUS(unit))
    {
        if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_IS_EQUAL_LSB) {
            dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_IS_EQUAL_LSB;
        }
        if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_IS_EQUAL_MSB) {
            dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_IS_EQUAL_MSB;
        }
    }
    
    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_USE_DBAL) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_USE_DBAL;
        dbInfo.internal_table_id = newGroupData->internal_table_id;
        dbInfo.physicalDB = newGroupData->physicalDB;
    }

    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_HANDLE_ENTRIES_BY_KEY;
    }    

    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_WITH_HEADER_SELECTION) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_HEADER_SELECTION;
    }


    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_EXTENDED_DATABASES) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_EXTENDED_DATABASES;
        dbInfo.internal_table_id = newGroupData->internal_table_id;        
    }    

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));

    newGroupData->cascadePair = groupLimit;
    if (SHR_BITGET(newGroupData->pqset, SOC_PPC_FP_QUAL_IRPP_KEY_CHANGED) &&
        SHR_BITGET(newGroupData->paset, SOC_PPC_FP_ACTION_TYPE_CHANGE_KEY)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u tries to be both"
                                           " ends of a cascade pair"),
                          unit,
                          group));
    }
    if ((SHR_BITGET(newGroupData->pqset, SOC_PPC_FP_QUAL_IRPP_KEY_CHANGED)) ||
        (SHR_BITGET(newGroupData->paset, SOC_PPC_FP_ACTION_TYPE_CHANGE_KEY))) {
        if (0 == (_BCM_DPP_FIELD_STAGE_DEV_INFO(unit, newGroupData->stage).stageFlags &
                  _BCM_DPP_FIELD_DEV_STAGE_FLAG_ALLOW_CASCADE)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d group %u tries to use"
                                               " cascading features in stage"
                                               " %u, which does not support"
                                               " cascading"),
                              unit,
                              group,
                              newGroupData->stage));
        }
        newGroupData->groupFlags |= _BCM_DPP_FIELD_GROUP_CASCADE;
    }
    if (SHR_BITGET(newGroupData->pqset, SOC_PPC_FP_QUAL_IRPP_KEY_CHANGED)) {
        /*
         *  This group uses the cascaded key qualifier; make sure no other
         *  group in this stage using the cascaded key qualifier also uses any
         *  of the same preselector(s) as this group.
         */
        for (index = 0; index < groupLimit; index++) {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, index, &groupD_groupFlags));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, index, &groupD_stage));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.pqset.bit_get(unit, index, SOC_PPC_FP_QUAL_IRPP_KEY_CHANGED, &pqset_bit));
            if (((_BCM_DPP_FIELD_GROUP_IN_USE | _BCM_DPP_FIELD_GROUP_IN_HW) ==
                 (groupD_groupFlags &
                  (_BCM_DPP_FIELD_GROUP_IN_USE | _BCM_DPP_FIELD_GROUP_IN_HW))) &&
                (newGroupData->stage == groupD_stage) &&
                pqset_bit) {
                for (offset = 0; offset < BCM_FIELD_PRESEL_SEL_MAX; offset++) {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.preselSet.get(unit, index, &preselSet));
                    if (BCM_FIELD_PRESEL_TEST(preselSet,
                                              offset) &&
                        BCM_FIELD_PRESEL_TEST(newGroupData->preselSet,
                                              offset)) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u"
                                                           " uses cascade"
                                                           " qualifier but"
                                                           " shares preselector"
                                                           " %u with group %u"),
                                          unit,
                                          group,
                                          offset,
                                          index));
                    }
                } /* for (all possible preselectors) */
            } /* if (group exists, is in hw, same stage, has cascade qual) */
        } /* for (index = 0; index < groupLimit; index++) */
    } /* if (SHR_BITGET(newGroupData->pqset, SOC_PPC_FP_QUAL_IRPP_KEY_CHANGED)) */
    if (SHR_BITGET(newGroupData->paset, SOC_PPC_FP_ACTION_TYPE_CHANGE_KEY)) {
        /*
         *  This group uses the cascaded key action; make sure no other group
         *  in this stage using the cascaded key action also uses any of the
         *  same preselector(s) as this group.  Also find the group using the
         *  cascaded key qualifier that uses the same preselector(s) and keep
         *  track of it.
         */
        for (index = 0; index < groupLimit; index++) {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, index, &groupD_groupFlags));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, index, &groupD_stage));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.pqset.bit_get(unit, index, SOC_PPC_FP_QUAL_IRPP_KEY_CHANGED, &pqset_bit));
            if (((_BCM_DPP_FIELD_GROUP_IN_USE | _BCM_DPP_FIELD_GROUP_IN_HW) ==
                 (groupD_groupFlags &
                  (_BCM_DPP_FIELD_GROUP_IN_USE | _BCM_DPP_FIELD_GROUP_IN_HW))) &&
                (newGroupData->stage == groupD_stage) &&
                pqset_bit) {
                 /* this group should be the pair for the new one */
                auxRes = BCM_E_NOT_FOUND;
                /* Look if there is a common preselector if the presel-set is not void */
                is_new_fg_presel_set_void = TRUE;
                for (offset = 0; offset < BCM_FIELD_PRESEL_SEL_MAX; offset++) {
                    if (BCM_FIELD_PRESEL_TEST(newGroupData->preselSet,
                                              offset)) {
                        is_new_fg_presel_set_void = FALSE;
                        /* this preselector is in use on new group */
                        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.preselSet.get(unit, index, &preselSet));
                        if (BCM_FIELD_PRESEL_TEST(preselSet,
                                                  offset)) {
                            /* the other group shares this preselector */
                            auxRes = BCM_E_EXISTS;
                            break; /* enough to find one common preselector */
                        }
                    }
                }
                if (is_new_fg_presel_set_void) {
                    auxRes = BCM_E_EXISTS;
                }

                /* If an existing group with a cascaded key has been not found with a preselector in common, continue searching */
                if (BCM_E_EXISTS != auxRes) {
                    continue;
                }

                if (BCM_E_CONFIG == auxRes) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                                     (_BSL_BCM_MSG_NO_UNIT("unit %d group %u has"
                                                       " at least one"
                                                       " preselector in common"
                                                       " with group %u, but"
                                                       " the preselector sets"
                                                       " are not equal"),
                                      unit,
                                      index,
                                      group));
                }
                /* this group should be the pair for the new one */
                if (groupLimit <= newGroupData->cascadePair) {
                    LOG_DEBUG(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d group %u will use group"
                                          " %u as its cascade pair\n"),
                               unit,
                               group,
                               index));
                    newGroupData->cascadePair = index;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                                     (_BSL_BCM_MSG_NO_UNIT("unit %d group %u"
                                                       " wants more than one"
                                                       " group as its cascade"
                                                       " pair: %u, %u"),
                                      unit,
                                      group,
                                      newGroupData->cascadePair,
                                      index));
                }
            } /* if (group exists, is in hw, same stage, has cascade action) */
        } /* for (index = 0; index < groupLimit; index++) */
    } /* if (SHR_BITGET(newGroupData->paset, SOC_PPC_FP_ACTION_TYPE_CHANGE_KEY)) */
    if (SOC_PPC_NOF_FP_PREDEFINED_ACL_KEYS != newGroupData->predefKey) {
        /* using predefined key; fetch it from the driver */
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG_NO_UNIT("unit %d: unsupported device type."), unit));
    } else { /* if (SOC_PPC_NOF_FP_PREDEFINED_ACL_KEYS != groupData->predefKey) */
        /* using versatile key */
        index = 0;
        /* must include cascade key first if it is present */
        if (SHR_BITGET(newGroupData->pqset, SOC_PPC_FP_QUAL_IRPP_KEY_CHANGED)) {
            dbInfo.qual_types[index] = SOC_PPC_FP_QUAL_IRPP_KEY_CHANGED;
            index++;
        }
        /* build qualifier list from qset */
        for (qualType = 0;
             qualType < SOC_PPC_NOF_FP_QUAL_TYPES;
             qualType++) {
            /* collect qualifiers */
            if (SHR_BITGET(newGroupData->pqset, qualType) &&
                (qualType != SOC_PPC_FP_QUAL_IRPP_KEY_CHANGED)) {
                /* this qualifier is selected */
                if (index < SOC_PPC_FP_NOF_QUALS_PER_DB_MAX) {
                    dbInfo.qual_types[index] = qualType;
                }
                index++;
            }
        }
        /* replace external range qualifiers with their respective regular ones */
        if(BCM_FIELD_QSET_TEST(newGroupData->qset, bcmFieldQualifyStageExternal) && BCM_FIELD_QSET_TEST(newGroupData->qset, bcmFieldQualifyL4PortRangeCheck)) {
            BCM_FIELD_QSET_REMOVE(newGroupData->qset, bcmFieldQualifyL4PortRangeCheck);
            BCM_FIELD_QSET_ADD(newGroupData->qset, bcmFieldQualifyElkRangeL4DstPort);
            BCM_FIELD_QSET_ADD(newGroupData->qset, bcmFieldQualifyElkRangeL4SrcPort);
        }

        if (index >= SOC_PPC_FP_NOF_QUALS_PER_DB_MAX) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d group %d has too many"
                                               " qualifiers (%d, max %d)"),
                              unit,
                              group,
                              index,
                              SOC_PPC_FP_NOF_QUALS_PER_DB_MAX));
        }

        /* split range Qual into two for KBP */
        if (dbInfo.db_type == SOC_PPC_FP_DB_TYPE_FLP) {
            int split_location,j;
            SOC_PPC_FP_QUAL_TYPE qual_types_tmp[SOC_PPC_FP_NOF_QUALS_PER_DB_MAX];
            split_location = -1;
            for (qualType = 0; qualType < SOC_PPC_FP_NOF_QUALS_PER_DB_MAX; qualType++) {
                qual_types_tmp[qualType] = BCM_FIELD_ENTRY_INVALID;
            }

            for (qualType = 0, j = 0; qualType < SOC_PPC_FP_NOF_QUALS_PER_DB_MAX; qualType++) {
                if (dbInfo.qual_types[qualType] == SOC_PPC_FP_QUAL_HDR_IPV6_L4OPS) {
                    if (index > (SOC_PPC_FP_NOF_QUALS_PER_DB_MAX - 1)) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %d has too many"
                                                           " qualifiers (%d, max %d) to split into two qualifiers "),
                                          unit,
                                          group,
                                          index,
                                          SOC_PPC_FP_NOF_QUALS_PER_DB_MAX-1));
                    } else {
                        split_location = qualType;
                    }
                } else if ((dbInfo.qual_types[qualType] != SOC_PPC_NOF_FP_QUAL_TYPES) && (dbInfo.qual_types[qualType] != BCM_FIELD_ENTRY_INVALID)) {
                    qual_types_tmp[j++] = dbInfo.qual_types[qualType];
                }
            }
            /*put splited new quals into tmp buffer*/
            if (split_location >= 0) {
                dbInfo.qual_types[0] = SOC_PPC_FP_QUAL_HDR_ELK_RANGE_IPV4_DEST_PORT;
                dbInfo.qual_types[1] = SOC_PPC_FP_QUAL_HDR_ELK_RANGE_IPV4_SRC_PORT;
                sal_memcpy(&dbInfo.qual_types[2], qual_types_tmp, sizeof(SOC_PPC_FP_QUAL_TYPE) * (SOC_PPC_FP_NOF_QUALS_PER_DB_MAX-2));
                /*set flag for DB*/
                dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_ELK_RANGE;
            } else {
                sal_memcpy(dbInfo.qual_types, qual_types_tmp, sizeof(SOC_PPC_FP_QUAL_TYPE) * SOC_PPC_FP_NOF_QUALS_PER_DB_MAX);
            }
        }
    } /* if (SOC_PPC_NOF_FP_PREDEFINED_ACL_KEYS != groupData->predefKey) */

    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_LARGE) {
        if (newGroupData->grpMode == bcmFieldGroupModeDirect) {
            /* if DB has more than one qualifier, than those qualifiers need to be ordered */
            if ((dbInfo.qual_types[1] != SOC_PPC_NOF_FP_QUAL_TYPES) && (dbInfo.qual_types[1] != BCM_FIELD_ENTRY_INVALID)) {
                dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_ALLOCATE_FES;
            }
            dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_USE_KAPS;
        }
        else {
            dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_ALLOCATE_FES;
        }
    }

    index = 0;
    /* must include cascade action as first if it is present */
    if (SHR_BITGET(newGroupData->paset, SOC_PPC_FP_ACTION_TYPE_CHANGE_KEY)) {
        dbInfo.action_types[index] = SOC_PPC_FP_ACTION_TYPE_CHANGE_KEY;
        index++;
    }
    for (actionType = 0;
         actionType < SOC_PPC_NOF_FP_ACTION_TYPES;
         actionType++) {
        if (SHR_BITGET(newGroupData->paset, actionType) &&
            (actionType != SOC_PPC_FP_ACTION_TYPE_CHANGE_KEY)) {
            /* this action is selected */
            if (index < SOC_PPC_FP_NOF_ACTIONS_PER_DB_MAX) {
                dbInfo.action_types[index] = actionType;
                dbInfo.action_widths[index] = 0;
                for (action_ndx = 0; action_ndx < SOC_PPC_FP_NOF_ACTIONS_PER_DB_MAX; action_ndx++) {
                    if ((newGroupData->aset.actions_width[action_ndx].action) == actionType &&
                            (newGroupData->aset.actions_width[action_ndx].valid)) {
                        dbInfo.action_widths[index] = (newGroupData->aset.actions_width[action_ndx].width);
                        break;
                    }
                }
            }
            index++;
        }
    }
    if (index > SOC_PPC_FP_NOF_ACTIONS_PER_DB_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %d has too many"
                                           " actions (%d, max %d)"),
                          unit,
                          group,
                          index,
                          SOC_PPC_FP_NOF_ACTIONS_PER_DB_MAX));
    }
    /* must not 'early exit' from here onward */
    /* get implied preselector (based upon qset) if applicable */
    /* set up PPD layer PFG bit map from preselector set */
    dbInfo.supported_pfgs = 0;
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.preselLimit.get(unit, &preselLimit)) ;
    for (index = 0; index < preselLimit; index++) {
        if (BCM_FIELD_PRESEL_TEST(newGroupData->preselSet, index)) {
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_group_get_presel_bitmap(unit, newGroupData->stage, index, &bmp_index));
            if (index >= BCM_FIELD_PRESEL_STAGGERED) {
                 dbInfo.db_staggered_info[stagered_idx].second_pass_presel_id = index;
                 BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_info_get(unitData,
                                    bmp_index,
                                    SOC_PPC_FP_NOF_QUALS_PER_DB_MAX,
                                    _BCM_DPP_PRESEL_ALLOC_WITH_STAGE,
                                    &(newGroupData->stage),
                                    &(preselQual[0])));
                 for (idx = 0; idx < SOC_PPC_FP_NOF_QUALS_PER_DB_MAX && preselQual[idx].qualType != -1 ; idx++ )
                 {
                     if (preselQual[idx].qualType == bcmFieldQaulifyPreselId)
                     {
                         COMPILER_64_TO_32_LO(dbInfo.db_staggered_info[stagered_idx].first_pass_presel_id,(preselQual[idx].qualData)) ;
                         dbInfo.db_staggered_info[stagered_idx].valid = TRUE;
                     }
                 }
                 stagered_idx++;
            }

            /* set PFG membership - different method between Petra-B and Arad */
            if ((index >> 5) < SOC_PPC_FP_NOF_PFGS_IN_LONGS_ARAD) {
                dbInfo.supported_pfgs_arad[index >> 5] |= (1 << (index & 0x1F));
            }
            if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  allocate sw-state resources */
                /*
                 *  Was:
                 *    unitData->preselRefs[index]++;
                 */
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_PRESELREFS.get(unit, bmp_index, &preselRefs_element)) ;
                preselRefs_element++ ;
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_PRESELREFS.set(unit, bmp_index, preselRefs_element)) ;
            }
        }
    }
    /* Fill in the cascaded group indicator for PPD layer */
    if (groupLimit > newGroupData->cascadePair) {
        dbInfo.cascaded_coupled_db_id = newGroupData->cascadePair;
    }

    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_WITH_PROGRAM_ID) {
        dbInfo.pgm_bmp = newGroupData->pgm_bmp;
    }

    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_WITH_CE_ID) {
         dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_WITH_CE_ID;
    }

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.share_id.get(unit, group, &dbInfo.share_id));

    /*
     *  There are no entries in this group; removing it then replacing it
     *  (instead of creating a new one and then destroying the old one) will
     *  not have any effect on traffic.
     */
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_group_hardware_remove(unitData, group);
    }
    { 
        if (BCM_E_NONE == result) {
            ppdr = soc_ppd_fp_database_create(unitData->unitHandle,
                                          group,
                                          &dbInfo,
                                          &success);
            result = handle_sand_result(ppdr);
            if (BCM_E_NONE == result) {
                result = translate_sand_success_failure(success);
            }
            if (BCM_E_NONE != result) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unable to create unit %d group %d in"
                                      " hardware: %d (%s)\n"),
                           unit,
                           group,
                           result,
                           _SHR_ERRMSG(result)));
            } else {
                BCMDNX_IF_ERR_EXIT(arad_pp_fp_action_bitmap_ndx_get_unsafe(unit, group, &action_bitmap_ndx));

                /* Update group mode */
                if (groupD_groupFlags & _BCM_DPP_FIELD_GROUP_AUTO_SZ) {
                    if ((action_bitmap_ndx & (SOC_TMC_TCAM_ACTION_SIZE_THIRD_20_BITS | SOC_TMC_TCAM_ACTION_SIZE_FORTH_20_BITS)) &&
                        (newGroupData->grpMode < bcmFieldGroupModeQuad)) {
                        newGroupData->grpMode = bcmFieldGroupModeQuad;
                    } else if ((action_bitmap_ndx & SOC_TMC_TCAM_ACTION_SIZE_SECOND_20_BITS) &&
                               (newGroupData->grpMode == bcmFieldGroupModeSingle)) {
                        newGroupData->grpMode = bcmFieldGroupModeDouble;
                    }
                }
            }
        } /* if (BCM_E_NONE == result) */
    } /* if (custom_feature == 0) */
    if (BCM_E_NONE == result) {
        newGroupData->groupFlags |= _BCM_DPP_FIELD_GROUP_IN_HW;
        /* mark the group's preselectors as being in hardware */
        sal_memcpy(&(newGroupData->preselHw),
                   &(newGroupData->preselSet),
                   sizeof(newGroupData->preselHw));
        /* claim cascading features use if any are used */
        if ((SHR_BITGET(newGroupData->pqset, SOC_PPC_FP_QUAL_IRPP_KEY_CHANGED)) ||
            (SHR_BITGET(newGroupData->paset, SOC_PPC_FP_ACTION_TYPE_CHANGE_KEY))) {
            if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  allocate sw-state resources */
                _bcm_dpp_field_grp_idx_t    groupCascaded ;
                /*
                 * Was:
                 *   unitData->groupCascaded++;
                 */
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupCascaded.get(unit, &groupCascaded)) ;
                groupCascaded++ ;
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupCascaded.set(unit, groupCascaded)) ;

                if (groupLimit > newGroupData->cascadePair) {

                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.cascadePair.set(unit, newGroupData->cascadePair, group));

                }

            }
        }
#ifdef BCM_WARM_BOOT_SUPPORT
#if (0)
/* { */
    /*
     * All 'save' and 'sync' of old sw state are dropped.
     */
        /* ensure presel reference counts are committed to backing store */
        _bcm_dpp_field_presel_all_wb_save(unitData, NULL, NULL);
/* } */
#endif
#endif /* def BCM_WARM_BOOT_SUPPORT */
    } else { /* if (BCM_E_NONE == result) */
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.preselLimit.get(unit, &preselLimit)) ;
        /* release the preselectors we put in use before */
        if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  allocate sw-state resources */
            for (index = 0; index < preselLimit; index++) {
                if (BCM_FIELD_PRESEL_TEST(newGroupData->preselSet, index)) {
                    /*
                     *  Was:
                     *    unitData->preselRefs[index]--;
                     */
                    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_group_get_presel_bitmap(unit, newGroupData->stage, index, &bmp_index));
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_PRESELREFS.get(unit, bmp_index, &preselRefs_element)) ;
                    preselRefs_element-- ;
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_PRESELREFS.set(unit, bmp_index, preselRefs_element)) ;
                }
            }
        }
        /* dispose of any preselectors no longer implied */
        /* called function displayed diagnostic */
    } /* if (BCM_E_NONE == result) */
    BCMDNX_IF_ERR_EXIT(result);

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_field_entry_exists(bcm_dpp_field_info_OLD_t *unitData,
                            bcm_field_entry_t entry)
{
    int32 commonHandle ;
    _bcm_dpp_field_entry_type_t entryType;
    uint32 entryFlags;
    bcm_field_entry_t ent;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;
    
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_common_pointer(unitData,
                                                                entry,
                                                                &entryType,&commonHandle));
    ent = commonHandle - 1;
    if (entryType == _bcmDppFieldEntryTypeExternalTcam) {
        /* External TCAM */
        /*
         * Was:
         *   entryFlags = extCommon->entryFlags;
         */
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYEXTTC.entryCmn.entryFlags.get(unit,ent,&entryFlags)) ;
    }
    else if (entryType == _bcmDppFieldEntryTypeDirExt) {
        /* direct extraction  */
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryFlags.get(unit, ent, &entryFlags));
    }
    else {
        /* internal TCAM */
        /*
         * Was:
         *   entryFlags = common->entryFlags;
         */
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYTC.entryCmn.entryFlags.get(unit,ent,&entryFlags)) ;
    }

    if (0 == (entryFlags & _BCM_DPP_FIELD_ENTRY_IN_USE)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d entry %d not in use"),
                          unit,
                          entry));
    } /* if (0 == (entryData->flags & _BCM_DPP_FIELD_ENTRY_IN_USE)) */

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualifier_general_set
 *  Purpose
 *     Set a qualifier for an entry
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) count = number of octbytes of data/mask
 *     (in) data = pointer to the data values
 *     (in) mask = pointer to the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 *
 *     Only checks entries for validity.  Other objects (currently only
 *     preselectors) are checked by their own setup code.
 */
STATIC int
_bcm_dpp_field_entry_qualifier_general_set(int unit,
                                           bcm_field_entry_t entry,
                                           bcm_field_qualify_t type,
                                           unsigned int count,
                                           const uint64 *data,
                                           const uint64 *mask)
{
    _DPP_FIELD_COMMON_LOCALS;
    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);
    result = _bcm_dpp_field_entry_qualifier_general_set_int(unitData,
                                                            entry,
                                                            type,
                                                            count,
                                                            data,
                                                            mask);
    _DPP_FIELD_UNIT_UNLOCK(unitData);
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualifier_general_get
 *  Purpose
 *     Get a qualifier for an entry
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) count = number of octbytes of data/mask
 *     (in) data = pointer to the data values
 *     (in) mask = pointer to the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 *
 *     Only checks entries for validity.  Other objects (currently only
 *     preselectors) are checked by their own setup code.
 */
STATIC int
_bcm_dpp_field_entry_qualifier_general_get(int unit,
                                           bcm_field_entry_t entry,
                                           bcm_field_qualify_t type,
                                           unsigned int count,
                                           uint64 *data,
                                           uint64 *mask)
{
    _DPP_FIELD_COMMON_LOCALS;
    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);
    result = _bcm_dpp_field_entry_qualifier_general_get_int(unitData,
                                                            entry,
                                                            type,
                                                            count,
                                                            data,
                                                            mask);
    _DPP_FIELD_UNIT_UNLOCK(unitData);
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_macaddr_set
 *  Purpose
 *     Set a qualifier that is based upon MAC address on an entry
 *  Parameters
 *     (in) unit = the unit number
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = the data value
 *     (in) mask = the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held.
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
STATIC int
_bcm_dpp_field_entry_qualify_macaddr_set(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_field_qualify_t type,
                                         const bcm_mac_t data,
                                         const bcm_mac_t mask)
{
    uint64 edata;
    uint64 emask;
    uint64 temp;
    unsigned int index;

    BCMDNX_INIT_FUNC_DEFS;
    COMPILER_64_ZERO(edata);
    COMPILER_64_ZERO(emask);
    for (index = 0; index < 6; index++) {
        COMPILER_64_SHL(edata, 8);
        COMPILER_64_SHL(emask, 8);
        COMPILER_64_SET(temp, 0, data[index]);
        COMPILER_64_OR(edata, temp);
        COMPILER_64_SET(temp, 0, mask[index]);
        COMPILER_64_OR(emask, temp);
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               type,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_macaddr_get
 *  Purpose
 *     Get a qualifier that is based upon MAC address from an entry
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = where to put the data value
 *     (in) mask = where to put the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
STATIC int
_bcm_dpp_field_entry_qualify_macaddr_get(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_field_qualify_t type,
                                         bcm_mac_t *data,
                                         bcm_mac_t *mask)
{
    uint64 edata;
    uint64 emask;
    unsigned int index;

    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               1 /* buffers */,
                                                               &edata,
                                                               &emask));
    for (index = 0; index < 6; index++) {
        (*data)[5 - index] = COMPILER_64_LO(edata) & 0xFF;
        (*mask)[5 - index] = COMPILER_64_LO(emask) & 0xFF;
        COMPILER_64_SHR(edata, 8);
        COMPILER_64_SHR(emask, 8);
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_ipv6addr_set
 *  Purpose
 *     Set a qualifier that is based upon IPv6 address on an entry
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = the data value
 *     (in) mask = the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 *
 *     If one of the qualifier types is BCM_FIELD_ENTRY_INVALID, it will not set
 *     that part of the address, but if both are, it is BCM_E_PARAM.
 */
STATIC int
_bcm_dpp_field_entry_qualify_ipv6addr_set(int unit,
                                          bcm_field_entry_t entry,
                                          bcm_field_qualify_t type,
                                          const bcm_ip6_t data,
                                          const bcm_ip6_t mask)
{
    uint64 edata[2];
    uint64 emask[2];
    uint64 temp;
    unsigned int index;

    BCMDNX_INIT_FUNC_DEFS;
    for (index = 0; index < 2; index++) {
        COMPILER_64_ZERO(edata[index]);
        COMPILER_64_ZERO(emask[index]);
    }
    for (index = 0; index < 8; index++) {
        COMPILER_64_SHL(edata[0], 8);
        COMPILER_64_SHL(emask[0], 8);
        COMPILER_64_SHL(edata[1], 8);
        COMPILER_64_SHL(emask[1], 8);
        COMPILER_64_SET(temp, 0, data[index]);
        COMPILER_64_OR(edata[1], temp);
        COMPILER_64_SET(temp, 0, mask[index]);
        COMPILER_64_OR(emask[1], temp);
        COMPILER_64_SET(temp, 0, data[8 + index]);
        COMPILER_64_OR(edata[0], temp);
        COMPILER_64_SET(temp, 0, mask[8 + index]);
        COMPILER_64_OR(emask[0], temp);
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               type,
                                                               2 /* count */,
                                                               &(edata[0]),
                                                               &(emask[0])));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_ipv6addr_get
 *  Purpose
 *     Get a qualifier that is based upon IPv6 address from an entry
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = the data value
 *     (in) mask = the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 *
 *     If one of the qualifier types is BCM_FIELD_ENTRY_INVALID, it will not set
 *     that part of the address, but if both are, it is BCM_E_PARAM.
 */
STATIC int
_bcm_dpp_field_entry_qualify_ipv6addr_get(int unit,
                                          bcm_field_entry_t entry,
                                          bcm_field_qualify_t type,
                                          bcm_ip6_t *data,
                                          bcm_ip6_t *mask)
{
    uint64 edata[2];
    uint64 emask[2];
    unsigned int index;

    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               2 /* buffers */,
                                                               &(edata[0]),
                                                               &(emask[0])));

    for (index = 0; index < 8; index++) {
        if (type == bcmFieldQualifySrcIp6High || type == bcmFieldQualifyDstIp6High) {
            (*data)[7 - index] = COMPILER_64_LO(edata[0]) & 0xFF;
            (*mask)[7 - index] = COMPILER_64_LO(emask[0]) & 0xFF;
            (*data)[15 - index] = COMPILER_64_LO(edata[1]) & 0xFF;
            (*mask)[15 - index] = COMPILER_64_LO(emask[1]) & 0xFF;
        } else {
            (*data)[15 - index] = COMPILER_64_LO(edata[0]) & 0xFF;
            (*mask)[15 - index] = COMPILER_64_LO(emask[0]) & 0xFF;
            (*data)[7 - index] = COMPILER_64_LO(edata[1]) & 0xFF;
            (*mask)[7 - index] = COMPILER_64_LO(emask[1]) & 0xFF;
        }
        COMPILER_64_SHR(edata[0], 8);
        COMPILER_64_SHR(emask[0], 8);
        COMPILER_64_SHR(edata[1], 8);
        COMPILER_64_SHR(emask[1], 8);
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_uint32_get
 *  Purpose
 *     Get a qualifier that is based upon uint32 type
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = where to put the data value
 *     (in) mask = where to put the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
int
_bcm_dpp_field_entry_qualify_uint32_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_qualify_t type,
                                        uint32 *data,
                                        uint32 *mask)
{
    uint64 edata;
    uint64 emask;

    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               1 /* buffers */,
                                                               &edata,
                                                               &emask));
    *data = COMPILER_64_LO(edata);
    *mask = COMPILER_64_LO(emask);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_uint64_get
 *  Purpose
 *     Get a qualifier that is based upon uint64 type
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = where to put the data value
 *     (in) mask = where to put the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
STATIC int
_bcm_dpp_field_entry_qualify_uint64_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_qualify_t type,
                                        uint64 *data,
                                        uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               1 /* buffers */,
                                                               data,
                                                               mask));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_uint16_get
 *  Purpose
 *     Get a qualifier that is based upon uint16 type
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = where to put the data value
 *     (in) mask = where to put the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
STATIC int
_bcm_dpp_field_entry_qualify_uint16_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_qualify_t type,
                                        uint16 *data,
                                        uint16 *mask)
{
    uint64 edata;
    uint64 emask;

    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               1 /* buffers */,
                                                               &edata,
                                                               &emask));
    *data = COMPILER_64_LO(edata) & 0xFFFF;
    *mask = COMPILER_64_LO(emask) & 0xFFFF;
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_uint8_get
 *  Purpose
 *     Get a qualifier that is based upon uint8 type
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = where to put the data value
 *     (in) mask = where to put the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
STATIC int
_bcm_dpp_field_entry_qualify_uint8_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_field_qualify_t type,
                                       uint8 *data,
                                       uint8 *mask)
{
    uint64 edata;
    uint64 emask;

    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               1 /* buffers */,
                                                               &edata,
                                                               &emask));
    *data = COMPILER_64_LO(edata) & 0xFF;
    *mask = COMPILER_64_LO(emask) & 0xFF;
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_int32_get
 *  Purpose
 *     Get a qualifier that is based upon (signed) int32 type
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = where to put the data value
 *     (in) mask = where to put the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
STATIC int
_bcm_dpp_field_entry_qualify_int32_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_field_qualify_t type,
                                       int32 *data,
                                       int32 *mask)
{
    uint64 edata;
    uint64 emask;

    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               1 /* buffers */,
                                                               &edata,
                                                               &emask));
    *data = (int32)COMPILER_64_LO(edata);
    *mask = (int32)COMPILER_64_LO(emask);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_group_all_hw_set
 *   Purpose
 *      Set whether all entries in a group should (not) be in hardware, then
 *      update the hardware state for all of the entries.
 *   Parameters
 *      (in) _bcm_petra_field_info_t *unitData = unit info pointer
 *      (in) bcm_field_group_t group = which group ID to use
 *      (in) int hw_state = TRUE if in hardware, FALSE if not
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
STATIC int
_bcm_dpp_field_group_all_hw_set(bcm_dpp_field_info_OLD_t *unitData,
                                bcm_field_group_t group,
                                int hw_state)
{
    _bcm_dpp_field_ent_idx_t entry;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    unsigned int already;
    unsigned int added;
    uint32 state;
    _bcm_dpp_field_entry_type_t entryType; 
    _bcm_dpp_field_ent_idx_t tcam_entry_limit;
    uint32 groupFlags;   
    _bcm_dpp_field_ent_idx_t entryHead;
    _bcm_dpp_field_stage_idx_t stage;  
    bcm_field_group_mode_t grpMode;
    uint32 entryDe_entryFlags;
    _bcm_dpp_field_ent_idx_t  entryDe_entryNext; 

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));

    if (groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,(_BSL_BCM_MSG_NO_UNIT("unit %d group %d not available for groups that handles entries by key"),unit,group));
    }

    if (groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, group, &stage));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.get(unit, group, &grpMode));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryHead.get(unit, group, &entryHead));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.stageD.modeBits.entryType.get(unit, stage, grpMode, &entryType));
        if (groupFlags & _BCM_DPP_FIELD_GROUP_IN_HW) {
            /* update whether entries want to be in hardware */
            if (hw_state) {
                state = _BCM_DPP_FIELD_ENTRY_WANT_HW;
            } else {
                state = 0;
            }
            switch (entryType) {
            case _bcmDppFieldEntryTypeDirExt:
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));
                if (entryHead < entryDeLimit) {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryNext.get(unit, entryHead, &entryDe_entryNext));
                }
                for (entry = entryHead, added = 0, already = 0;
                     entry < entryDeLimit;
                     entry = entryDe_entryNext) {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryFlags.get(unit, entry, &entryDe_entryFlags));
                    if ((entryDe_entryFlags &
                         _BCM_DPP_FIELD_ENTRY_WANT_HW) == state) {
                        already++;
                    } else {
                        added++;
                    }
                    entryDe_entryFlags &= (~_BCM_DPP_FIELD_ENTRY_WANT_HW);
                    entryDe_entryFlags |= state;
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryFlags.set(unit, entry, entryDe_entryFlags));
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryNext.get(unit, entry, &entryDe_entryNext));
                }
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d group %d, updated %d entries,"
                                      " %d already %sIN_HW\n"),
                           unit,
                           group,
                           added,
                           already,
                           hw_state?"":"not "));
                BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_dir_ext_group_hw_refresh(unitData,
                                                                                group,
                                                                                FALSE));
                break;
            default:
                /* default is TCAM */
                for (entry = entryHead, added = 0, already = 0, _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType);
                        (entry < tcam_entry_limit);
                     /*
                      * Was:
                      *   entry = _BCM_DPP_FIELD_TCAM_ENTRY_NEXT(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry)
                      */
                    _BCM_DPP_FIELD_TCAM_ENTRY_NEXT_GET(unit,_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry, entry) ) {
                    uint32 localEntryFlags;                       /* entry flags */

                    BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit,_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry, localEntryFlags)) ;
                    /*
                     * Was:
                     *   if ((_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry) ))
                     */
                    if ((localEntryFlags &
                         _BCM_DPP_FIELD_ENTRY_WANT_HW) == state) {
                        already++;
                    } else {
                        added++;
                    }
                    if(hw_state) {
                        if(!(localEntryFlags & _BCM_DPP_FIELD_ENTRY_IN_HW) ||
                            ((localEntryFlags & _BCM_DPP_FIELD_ENTRY_IN_HW) &&
                             (localEntryFlags & _BCM_DPP_FIELD_ENTRY_CHANGED))) {
                            /* ARAD Only:
                             * This indicates to the driver that the group_install method was called.
                             * In that case the driver will insert the entries from top to bottom in
                             * the HW tables, instead of in the middle. This is done since when calling
                             * group install, there is hte assumption that the group's entries were
                             * already created, and they are ordered in the SW according to their
                             * priority, and so it should be faster to insert top-to-bottom.
                             */
                            /*
                             * Was:
                             *   entryFlags = _BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_PTR(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry);
                             *   *entryFlags |= _BCM_DPP_FIELD_GROUP_INSTALL;
                             */
                            localEntryFlags |= _BCM_DPP_FIELD_GROUP_INSTALL ;
                            BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_SET(unit,_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry, localEntryFlags)) ;

                            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_tcam_entry_install(unitData, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry, NULL));
                        }
                    }
                    else {
                        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_tcam_entry_remove(unitData, FALSE, _BCM_DPP_FIELD_TCAM_GLOBAL_ID(unit, entry, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType))));
                    }
                }
            } /* switch (entry type for this group) */
        } else { /* if (groupData->flags & _BCM_DPP_fIELD_GROUP_IN_HW) */
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d group %d is not"
                                               " in hardware"),
                              unit,
                              group));
        } /* if (groupData->flags & _BCM_DPP_fIELD_GROUP_IN_HW) */
    } else { /* if (groupData->flags & _BCM_DPP_FIELD_GROUP_IN_USE) */
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %d not in use"),
                          unit,
                          group));
    } /* if (groupData->flags & _BCM_DPP_FIELD_GROUP_IN_USE) */
exit:
      BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_stat_unmap
 *   Purpose
 *      Convert a bcm_dpp_counter_t into a bcm_field_stat_t
 *   Parameters
 *      (in) bcm_dpp_counter_t type = counter type desired
 *      (out) bcm_field_stat_t *stat = which stat is desired
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      There are DPP layer stats (or emulated stats) that do not map to BCM
 *      field stat types; trying to map one of these will result in the
 *      BCM_E_EMPTY error.  Any invalid input will result in BCM_E_PARAM.
 */
STATIC int
_bcm_dpp_field_stat_unmap(bcm_dpp_counter_t type,
                          bcm_field_stat_t *stat)
{
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    switch (type) {
    case bcm_dpp_counter_pkts:
        *stat = bcmFieldStatPackets;
        break;
    case bcm_dpp_counter_bytes:
        *stat = bcmFieldStatBytes;
        break;
    case bcm_dpp_counter_green_pkts:
        *stat = bcmFieldStatGreenPackets;
        break;
    case bcm_dpp_counter_green_bytes:
        *stat = bcmFieldStatGreenBytes;
        break;
    case bcm_dpp_counter_not_green_pkts:
        *stat = bcmFieldStatNotGreenPackets;
        break;
    case bcm_dpp_counter_not_green_bytes:
        *stat = bcmFieldStatNotGreenBytes;
        break;
    case bcm_dpp_counter_yellow_pkts:
        *stat = bcmFieldStatYellowPackets;
        break;
    case bcm_dpp_counter_yellow_bytes:
        *stat = bcmFieldStatYellowBytes;
        break;
    case bcm_dpp_counter_not_yellow_pkts:
        *stat = bcmFieldStatNotYellowPackets;
        break;
    case bcm_dpp_counter_not_yellow_bytes:
        *stat = bcmFieldStatNotYellowBytes;
        break;
    case bcm_dpp_counter_red_pkts:
        *stat = bcmFieldStatRedPackets;
        break;
    case bcm_dpp_counter_red_bytes:
        *stat = bcmFieldStatRedBytes;
        break;
    case bcm_dpp_counter_not_red_pkts:
        *stat = bcmFieldStatNotRedPackets;
        break;
    case bcm_dpp_counter_not_red_bytes:
        *stat = bcmFieldStatNotRedBytes;
        break;
    case bcm_dpp_counter_fwd_pkts:
        *stat = bcmFieldStatAcceptedPackets;
        break;
    case bcm_dpp_counter_fwd_bytes:
        *stat = bcmFieldStatAcceptedBytes;
        break;
    case bcm_dpp_counter_fwd_green_pkts:
        *stat = bcmFieldStatAcceptedGreenPackets;
        break;
    case bcm_dpp_counter_fwd_green_bytes:
        *stat = bcmFieldStatAcceptedGreenBytes;
        break;
    case bcm_dpp_counter_fwd_not_green_pkts:
        *stat = bcmFieldStatAcceptedNotGreenPackets;
        break;
    case bcm_dpp_counter_fwd_not_green_bytes:
        *stat = bcmFieldStatAcceptedNotGreenBytes;
        break;
    case bcm_dpp_counter_fwd_yellow_pkts:
        *stat = bcmFieldStatAcceptedYellowPackets;
        break;
    case bcm_dpp_counter_fwd_yellow_bytes:
        *stat = bcmFieldStatAcceptedYellowBytes;
        break;
    case bcm_dpp_counter_fwd_not_yellow_pkts:
        *stat = bcmFieldStatAcceptedNotYellowPackets;
        break;
    case bcm_dpp_counter_fwd_not_yellow_bytes:
        *stat = bcmFieldStatAcceptedNotYellowBytes;
        break;
    case bcm_dpp_counter_fwd_red_pkts:
        *stat = bcmFieldStatAcceptedRedPackets;
        break;
    case bcm_dpp_counter_fwd_red_bytes:
        *stat = bcmFieldStatAcceptedRedBytes;
        break;
    case bcm_dpp_counter_fwd_not_red_pkts:
        *stat = bcmFieldStatAcceptedNotRedPackets;
        break;
    case bcm_dpp_counter_fwd_not_red_bytes:
        *stat = bcmFieldStatAcceptedNotRedBytes;
        break;
    case bcm_dpp_counter_drop_pkts:
        *stat = bcmFieldStatDroppedPackets;
        break;
    case bcm_dpp_counter_drop_bytes:
        *stat = bcmFieldStatDroppedBytes;;
        break;
    case bcm_dpp_counter_drop_green_pkts:
        *stat = bcmFieldStatDroppedGreenPackets;
        break;
    case bcm_dpp_counter_drop_green_bytes:
        *stat = bcmFieldStatDroppedGreenBytes;
        break;
    case bcm_dpp_counter_drop_not_green_pkts:
        *stat = bcmFieldStatDroppedNotGreenPackets;
        break;
    case bcm_dpp_counter_drop_not_green_bytes:
        *stat = bcmFieldStatDroppedNotGreenBytes;
        break;
    case bcm_dpp_counter_drop_yellow_pkts:
        *stat = bcmFieldStatDroppedYellowPackets;
        break;
    case bcm_dpp_counter_drop_yellow_bytes:
        *stat = bcmFieldStatDroppedYellowBytes;
        break;
    case bcm_dpp_counter_drop_not_yellow_pkts:
        *stat = bcmFieldStatDroppedNotYellowPackets;
        break;
    case bcm_dpp_counter_drop_not_yellow_bytes:
        *stat = bcmFieldStatDroppedNotYellowBytes;
        break;
    case bcm_dpp_counter_drop_red_pkts:
        *stat = bcmFieldStatDroppedRedPackets;
        break;
    case bcm_dpp_counter_drop_red_bytes:
        *stat = bcmFieldStatDroppedRedBytes;
        break;
    case bcm_dpp_counter_drop_not_red_pkts:
        *stat = bcmFieldStatDroppedNotRedPackets;
        break;
    case bcm_dpp_counter_drop_not_red_bytes:
        *stat = bcmFieldStatDroppedNotRedBytes;
        break;
    case bcm_dpp_counter_offset0_pkts:
        *stat = bcmFieldStatOffset0Packets;
        break;
    case bcm_dpp_counter_offset0_bytes:
        *stat = bcmFieldStatOffset0Bytes;
        break;
    case bcm_dpp_counter_offset1_pkts:
        *stat = bcmFieldStatOffset1Packets;
        break;
    case bcm_dpp_counter_offset1_bytes:
        *stat = bcmFieldStatOffset1Bytes;
        break;
    case bcm_dpp_counter_offset2_pkts:
        *stat = bcmFieldStatOffset2Packets;
        break;
    case bcm_dpp_counter_offset2_bytes:
        *stat = bcmFieldStatOffset2Bytes;
        break;
    case bcm_dpp_counter_offset3_pkts:
        *stat = bcmFieldStatOffset3Packets;
        break;
    case bcm_dpp_counter_offset3_bytes:
        *stat = bcmFieldStatOffset3Bytes;
        break;
    case bcm_dpp_counter_offset4_pkts:
        *stat = bcmFieldStatOffset4Packets;
        break;
    case bcm_dpp_counter_offset4_bytes:
        *stat = bcmFieldStatOffset4Bytes;
        break;
    case bcm_dpp_counter_offset5_pkts:
        *stat = bcmFieldStatOffset5Packets;
        break;
    case bcm_dpp_counter_offset5_bytes:
        *stat = bcmFieldStatOffset5Bytes;
        break;
    case bcm_dpp_counter_offset6_pkts:
        *stat = bcmFieldStatOffset6Packets;
        break;
    case bcm_dpp_counter_offset6_bytes:
        *stat = bcmFieldStatOffset6Bytes;
        break;
    case bcm_dpp_counter_offset7_pkts:
        *stat = bcmFieldStatOffset7Packets;
        break;
    case bcm_dpp_counter_offset7_bytes:
        *stat = bcmFieldStatOffset7Bytes;
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG_NO_UNIT("invalid counter type %d"), type));
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_stat_map
 *   Purpose
 *      Convert a bcm_field_stat_t into a bcm_dpp_counter_t.
 *   Parameters
 *      (in) bcm_field_stat_t stat = which stat is desired
 *      (out) bcm_dpp_counter_t *type = counter type to request
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
STATIC int
_bcm_dpp_field_stat_map(bcm_field_stat_t stat,
                        bcm_dpp_counter_t *type)
{
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    switch (stat) {
    case bcmFieldStatBytes:
        *type = bcm_dpp_counter_bytes;
        break;
    case bcmFieldStatPackets:
        *type = bcm_dpp_counter_pkts;
        break;
    case bcmFieldStatGreenBytes:
        *type = bcm_dpp_counter_green_bytes;
        break;
    case bcmFieldStatGreenPackets:
        *type = bcm_dpp_counter_green_pkts;
        break;
    case bcmFieldStatYellowBytes:
        *type = bcm_dpp_counter_yellow_bytes;
        break;
    case bcmFieldStatYellowPackets:
        *type = bcm_dpp_counter_yellow_pkts;
        break;
    case bcmFieldStatRedBytes:
        *type = bcm_dpp_counter_red_bytes;
        break;
    case bcmFieldStatRedPackets:
        *type = bcm_dpp_counter_red_pkts;
        break;
    case bcmFieldStatNotGreenBytes:
        *type = bcm_dpp_counter_not_green_bytes;
        break;
    case bcmFieldStatNotGreenPackets:
        *type = bcm_dpp_counter_not_green_pkts;
        break;
    case bcmFieldStatNotYellowBytes:
        *type = bcm_dpp_counter_not_yellow_bytes;
        break;
    case bcmFieldStatNotYellowPackets:
        *type = bcm_dpp_counter_not_yellow_pkts;
        break;
    case bcmFieldStatNotRedBytes:
        *type = bcm_dpp_counter_not_red_bytes;
        break;
    case bcmFieldStatNotRedPackets:
        *type = bcm_dpp_counter_not_red_pkts;
        break;
    case bcmFieldStatAcceptedBytes:
        *type = bcm_dpp_counter_fwd_bytes;
        break;
    case bcmFieldStatAcceptedPackets:
        *type = bcm_dpp_counter_fwd_pkts;
        break;
    case bcmFieldStatAcceptedGreenBytes:
        *type = bcm_dpp_counter_fwd_green_bytes;
        break;
    case bcmFieldStatAcceptedGreenPackets:
        *type = bcm_dpp_counter_fwd_green_pkts;
        break;
    case bcmFieldStatAcceptedNotGreenBytes:
        *type = bcm_dpp_counter_fwd_not_green_bytes;
        break;
    case bcmFieldStatAcceptedNotGreenPackets:
        *type = bcm_dpp_counter_fwd_not_green_pkts;
        break;
    case bcmFieldStatAcceptedYellowBytes:
        *type = bcm_dpp_counter_fwd_yellow_bytes;
        break;
    case bcmFieldStatAcceptedYellowPackets:
        *type = bcm_dpp_counter_fwd_yellow_pkts;
        break;
    case bcmFieldStatAcceptedNotYellowBytes:
        *type = bcm_dpp_counter_fwd_not_yellow_bytes;
        break;
    case bcmFieldStatAcceptedNotYellowPackets:
        *type = bcm_dpp_counter_fwd_not_yellow_pkts;
        break;
    case bcmFieldStatAcceptedRedBytes:
        *type = bcm_dpp_counter_fwd_red_bytes;
        break;
    case bcmFieldStatAcceptedRedPackets:
        *type = bcm_dpp_counter_fwd_red_pkts;
        break;
    case bcmFieldStatAcceptedNotRedBytes:
        *type = bcm_dpp_counter_fwd_not_red_bytes;
        break;
    case bcmFieldStatAcceptedNotRedPackets:
        *type = bcm_dpp_counter_fwd_not_red_pkts;
       break;
    case bcmFieldStatDroppedBytes:
        *type = bcm_dpp_counter_drop_bytes;
        break;
    case bcmFieldStatDroppedPackets:
        *type = bcm_dpp_counter_drop_pkts;
        break;
    case bcmFieldStatDroppedGreenBytes:
        *type = bcm_dpp_counter_drop_green_bytes;
        break;
    case bcmFieldStatDroppedGreenPackets:
        *type = bcm_dpp_counter_drop_green_pkts;
        break;
    case bcmFieldStatDroppedNotGreenBytes:
        *type = bcm_dpp_counter_drop_not_green_bytes;
        break;
    case bcmFieldStatDroppedNotGreenPackets:
        *type = bcm_dpp_counter_drop_not_green_pkts;
        break;
    case bcmFieldStatDroppedYellowBytes:
        *type = bcm_dpp_counter_drop_yellow_bytes;
        break;
    case bcmFieldStatDroppedYellowPackets:
        *type = bcm_dpp_counter_drop_yellow_pkts;
        break;
    case bcmFieldStatDroppedNotYellowBytes:
        *type = bcm_dpp_counter_drop_not_yellow_bytes;
        break;
    case bcmFieldStatDroppedNotYellowPackets:
        *type = bcm_dpp_counter_drop_not_yellow_pkts;
        break;
    case bcmFieldStatDroppedRedBytes:
        *type = bcm_dpp_counter_drop_red_bytes;
        break;
    case bcmFieldStatDroppedRedPackets:
        *type = bcm_dpp_counter_drop_red_pkts;
        break;
    case bcmFieldStatDroppedNotRedBytes:
        *type = bcm_dpp_counter_drop_not_red_bytes;
        break;
    case bcmFieldStatDroppedNotRedPackets:
        *type = bcm_dpp_counter_drop_not_red_pkts;
        break;
    case bcmFieldStatOffset0Bytes:
        *type = bcm_dpp_counter_offset0_bytes;
        break;
    case bcmFieldStatOffset0Packets:
        *type = bcm_dpp_counter_offset0_pkts;
        break;
    case bcmFieldStatOffset1Bytes:
        *type = bcm_dpp_counter_offset1_bytes;
        break;
    case bcmFieldStatOffset1Packets:
        *type = bcm_dpp_counter_offset1_pkts;
        break;
    case bcmFieldStatOffset2Bytes:
        *type = bcm_dpp_counter_offset2_bytes;
        break;
    case bcmFieldStatOffset2Packets:
        *type = bcm_dpp_counter_offset2_pkts;
        break;
    case bcmFieldStatOffset3Bytes:
        *type = bcm_dpp_counter_offset3_bytes;
        break;
    case bcmFieldStatOffset3Packets:
        *type = bcm_dpp_counter_offset3_pkts;
        break;
    case bcmFieldStatOffset4Bytes:
        *type = bcm_dpp_counter_offset4_bytes;
        break;
    case bcmFieldStatOffset4Packets:
        *type = bcm_dpp_counter_offset4_pkts;
        break;
    case bcmFieldStatOffset5Bytes:
        *type = bcm_dpp_counter_offset5_bytes;
        break;
    case bcmFieldStatOffset5Packets:
        *type = bcm_dpp_counter_offset5_pkts;
        break;
    case bcmFieldStatOffset6Bytes:
        *type = bcm_dpp_counter_offset6_bytes;
        break;
    case bcmFieldStatOffset6Packets:
        *type = bcm_dpp_counter_offset6_pkts;
        break;
    case bcmFieldStatOffset7Bytes:
        *type = bcm_dpp_counter_offset7_bytes;
        break;
    case bcmFieldStatOffset7Packets:
        *type = bcm_dpp_counter_offset7_pkts;
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG_NO_UNIT("invalid statistics type %d"),
                          stat));
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_stat_proc_counter_check
 *   Purpose
 *      See if a particular counter processor is in the correct mode and
 *      supports the requested statistics.
 *   Parameters
 *      (in) _bcm_petra_field_info_t *unitData = pointer to unit information
 *      (in) unsigned int stage = the stage for the group being considered
 *      (in) unsigned int proc = the counter processor number
 *      (in) int nstat = number of desired statistics
 *      (in) with_id - with_id or not. if with_id=FALSE, no need to retrun error
 *      (in) bcm_field_stat_t stat_arr = array of desired statistics
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_CONFIG if wrong mode or requested stat not offered
 *                    BCM_E_* appropriately otherwise
 *   Notes
 */
STATIC int
_bcm_dpp_field_stat_proc_counter_check(bcm_dpp_field_info_OLD_t *unitData,
                                       unsigned int stage,
                                       unsigned int proc,
                                       int nstat,
                                       int with_id,
                                       bcm_field_stat_t *stat_arr)
{
    int result = BCM_E_NONE;
    unsigned int index;
    bcm_dpp_counter_t stat;
    bcm_dpp_counter_set_t counterSet;
    unsigned int procs;
    unsigned int source;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    BCMDNX_IF_ERR_EXIT_MSG(bcm_dpp_counter_diag_info_get(unit,
                                                      bcm_dpp_counter_diag_info_num_proc,
                                                      0,
                                                      &procs),
                        (_BSL_BCM_MSG_NO_UNIT("unit %d unable to get number of"
                                          " counter processors"),
                         unit));
    if (proc >= procs) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d counter processor %u"
                                           " is invalid"),
                          unit,
                          proc));
    }
    BCMDNX_IF_ERR_EXIT_MSG(bcm_dpp_counter_diag_info_get(unit,
                                                      bcm_dpp_counter_diag_info_source,
                                                      proc,
                                                      &source),
                        (_BSL_BCM_MSG_NO_UNIT("unit %d unable to get source for"
                                          " counter processor %u"),
                         unit,
                         proc));
    switch (_BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage).hwStageId) {
    case SOC_PPC_FP_DATABASE_STAGE_INGRESS_PMF:
        if (SOC_TMC_CNT_SRC_TYPE_ING_PP != source) {
            if (with_id == TRUE)
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG_NO_UNIT("unit %d counter processor %u source %s not correct source %s for stage %u"),
                                  unit, proc, SOC_TMC_CNT_SRC_TYPE_to_string(source), SOC_TMC_CNT_SRC_TYPE_to_string(SOC_TMC_CNT_SRC_TYPE_ING_PP), stage));
            }
            else /* case with_id=FALSE, no need to return error, because it is part of loop which search match proc */
            {
                BCMDNX_ERR_EXIT_VERB_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG_NO_UNIT("unit %d counter processor %u source %s not correct source %s for stage %u"),
                                  unit, proc, SOC_TMC_CNT_SRC_TYPE_to_string(source), SOC_TMC_CNT_SRC_TYPE_to_string(SOC_TMC_CNT_SRC_TYPE_ING_PP), stage));
            }
        }

        break;
    case SOC_PPC_FP_DATABASE_STAGE_EGRESS:
        if (SOC_TMC_CNT_SRC_TYPE_EGR_PP != source) {
            if(with_id ==TRUE)
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG_NO_UNIT("unit %d counter processor %u source %s not correct source %s for stage %u"),
                        unit, proc, SOC_TMC_CNT_SRC_TYPE_to_string(source), SOC_TMC_CNT_SRC_TYPE_to_string(SOC_TMC_CNT_SRC_TYPE_EGR_PP), stage));
            }
            else /* case with_id=FALSE, no need to return error, because it is part of loop which search match proc */
            {
                BCMDNX_ERR_EXIT_VERB_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG_NO_UNIT("unit %d counter processor %u source %s not correct source %s for stage %u"),
                        unit, proc, SOC_TMC_CNT_SRC_TYPE_to_string(source), SOC_TMC_CNT_SRC_TYPE_to_string(SOC_TMC_CNT_SRC_TYPE_EGR_PP), stage));
            }
        }
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d stage %d does not support"
                                           " counter manipulation"),
                          unit,
                          stage));
    } /* switch (unitData->stage[stage].devInfo->hwStageId) */
    BCMDNX_IF_ERR_EXIT_MSG(bcm_dpp_counter_avail_get(unit,
                                                  proc,
                                                  &counterSet,
                                                  NULL),
                        (_BSL_BCM_MSG_NO_UNIT("unit %d unable to get stats for"
                                          " counter processor %u"),
                         unit,
                         proc));;
    for (index = 0;
         (BCM_E_NONE == result) && (index < nstat);
         index++) {

        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "checking stat %d (%s)\n"),
                   stat_arr[index],
                   _bcm_dpp_field_stats_names[stat_arr[index]]));

        result = _bcm_dpp_field_stat_map(stat_arr[index], &stat);
        if (BCM_E_NONE == result) {
            if (!SHR_BITGET(counterSet, stat)) {
                if(with_id ==TRUE)
                {
                    /* this statistic is not offered */
                    BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG_NO_UNIT("requested statistic %d no offered by unit %d counter processor %u"),
                                      stat, unit, proc));
                }
                else /* case with_id=FALSE, no need to return error, because it is part of loop which search match proc */
                {
                    BCMDNX_ERR_EXIT_VERB_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG_NO_UNIT("requested statistic %d no offered by unit %d counter processor %u"),
                          stat, unit, proc));
                }
            }
        }
    }
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_stat_create
 *   Purpose
 *      Create a statistics set (allocate a counter set)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int with_id = TRUE if WITH_ID, else FALSE
 *      (in) bcm_field_group_t group = the group for which it is to be created
 *      (in) int nstat = number of desired statistics
 *      (in) bcm_field_stat_t stat_arr = array of desired statistics
 *      (in/out) int *stat_id = where to find/put the stat ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Meant to be called without the lock being held
 *
 *      If WITH_ID, this will try to allocate a counter set as specified (note
 *      the specification has the counter processor ID in bits above the
 *      counter set ID, and so if used across units, all units must have the
 *      same configuration for the counter processors that can be used here).
 *      If the specified counter processor does not offer the requested
 *      statistics, or is not in a mode that can be used here, this will return
 *      BCM_E_CONFIG. If the specified counter set is already in use, it will
 *      return BCM_E_RESOURCE.  Per BCM API tradition, a bogus counter
 *      processor ID or counter set that does not exist in the current mode
 *      will return BCM_E_NOT_FOUND.
 *
 *      If not WITH_ID, this will look for a counter processor that is in a
 *      mode that can be used here and offers the requested statistics.  If it
 *      can not find such a counter processor, it will return BCM_E_CONFIG.  If
 *      it finds such a counter processor (or more than one) and is unable to
 *      allocate a counter set from any such counter processor, it will return
 *      BCM_E_RESOURCE.  This will allocate from the first counter processor
 *      that offers the requested statistics, so the configuration should have
 *      limited statistics format counter processors first, before fuller
 *      statistics format counter processors.
 */
STATIC int
_bcm_dpp_field_stat_create(int unit,
                           int with_id,
                           bcm_field_group_t group,
                           int nstat,
                           bcm_field_stat_t *stat_arr,
                           uint32 *stat_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;
    unsigned int procs;
    int found;
    int dpp_field_unit_lock_was_taken ;
    _bcm_dpp_field_grp_idx_t groupLimit;
    uint32 groupFlags;   
    _bcm_dpp_field_stage_idx_t stage;  

    BCMDNX_INIT_FUNC_DEFS;
    dpp_field_unit_lock_was_taken = 0 ;
    FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags);
    FIELD_ACCESS.groupD.stage.get(unit, group, &stage);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%s,%d,%d,*,*) enter\n"),
               unit,
               with_id?"with_id":"avail",
               group,
               nstat));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    if (0 >= nstat) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("number of statistics %d must be positive"),
                          nstat));
    }
    if (!stat_arr) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory in pointer must not be NULL")));
    }
    if (!stat_id) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out arg must not be NULL")));
    }
    if (with_id && (0 == (*stat_id))) {
        
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("with_id stat ID %d is not valid"),
                          *stat_id));
    }
    BCMDNX_IF_ERR_EXIT_MSG(bcm_dpp_counter_diag_info_get(unit,
                                                      bcm_dpp_counter_diag_info_num_proc,
                                                      0,
                                                      &procs),
                        (_BSL_BCM_MSG_NO_UNIT("unit %d unable to get number of"
                                          " counter processors"),
                         unit));
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1 ;

    if (groupFlags & _BCM_DPP_FIELD_GROUP_EGRESS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("bcm_petra_field_entry_stat_create "
                                   "is only supported for Ingress")));
    }

    if (groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        if (with_id) {
            result = _bcm_dpp_proc_cntr_from_stat(unit,
                                                  *stat_id,
                                                  &proc,
                                                  &cntr);
            if (BCM_E_NONE == result) {
                result = _bcm_dpp_field_stat_proc_counter_check(unitData,
                                                                stage,
                                                                proc,
                                                                nstat,
                                                                with_id,
                                                                stat_arr);
                if (BCM_E_NONE == result) {
                    result = bcm_dpp_counter_alloc(unit,
                                                   BCM_DPP_COUNTER_WITH_ID,
                                                   (groupFlags & _BCM_DPP_FIELD_GROUP_EGRESS)?
                                                   SOC_TMC_CNT_SRC_TYPE_EGR_PP:SOC_TMC_CNT_SRC_TYPE_ING_PP,
                                                   &proc,
                                                   &cntr);
                    if (BCM_E_NONE != result) {
                        LOG_ERROR(BSL_LS_BCM_FP,
                                  (BSL_META_U(unit,
                                              "unable to allocate unit %d stat"
                                              " ID %08X counter processor %u"
                                              " set %u: %d (%s)\n"),
                                   unit,
                                   *stat_id,
                                   proc,
                                   cntr,
                                   result,
                                   _SHR_ERRMSG(result)));
                    }
                }
            }
        } else { /* if (with_id) */
            found = FALSE;
            for (proc = 0; proc < procs; proc++) {
                result = _bcm_dpp_field_stat_proc_counter_check(unitData,
                                                                stage,
                                                                proc,
                                                                nstat,
                                                                with_id,
                                                                stat_arr);
                if (BCM_E_NONE == result) {
                    found = TRUE;
                    result = bcm_dpp_counter_alloc(unit,
                                                   BCM_DPP_COUNTER_WITH_PROC,
                                                   SOC_TMC_CNT_SRC_TYPE_ING_PP,
                                                   &proc,
                                                   &cntr);
                    if (BCM_E_NONE == result) {
                        /* got one; stop looking now */
                        break;
                    }
                }
            }
            if (BCM_E_NONE != result) {
                if (found) {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d has no available counter"
                                          " sets that contain the requested"
                                          " statistics\n"),
                               unit));
                    result = BCM_E_RESOURCE;
                } else {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d has no counter processor"
                                          " configured to provide the"
                                          " requested statistics\n"),
                               unit));
                    result = BCM_E_CONFIG;
                }
            } else {
                /* report ID back to caller */
                result = _bcm_dpp_stat_from_proc_cntr(unit,
                                                      proc,
                                                      cntr,
                                                      stat_id);
            }
        } /* if (with_id) */
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    dpp_field_unit_lock_was_taken = 0 ;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%s,%d,%d,*,&(%08X)) return %d (%s)\n"),
               unit,
               with_id?"with_id":"avail",
               group,
               nstat,
               *stat_id,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken)
    {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_stat_access_single
 *   Purpose
 *      Manipulate a single stat from a set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) unsigned int proc = the counter processor
 *      (in) unsigned int cntr = the counter set
 *      (in) bcm_field_stat_t stat = which statistic to get
 *      (in) int write = TRUE to write, FALSE to read
 *      (in/out) uint64 *value = where to get/put the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 */
STATIC int
_bcm_dpp_field_stat_access_single(bcm_dpp_field_info_OLD_t *unitData,
                                  int stat_id,
                                  unsigned int proc,
                                  unsigned int cntr,
                                  bcm_field_stat_t stat,
                                  int write,
                                  uint64 *value)
{
    int result;
    bcm_dpp_counter_t type;
    uint8 stats_cached;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;
    result = _bcm_dpp_field_stat_map(stat, &type);
    if (BCM_E_NONE == result) {
        result = bcm_dpp_counter_cache_only_get(unit, &stats_cached);
        BCMDNX_IF_ERR_EXIT(result);

        if (write) {
#if _BCM_PETRA_ALLOW_CACHED_STAT_WRITE
            if (stats_cached) {
                result = bcm_dpp_counter_set_cached(unit,
                                                    proc,
                                                    cntr,
                                                    type,
                                                    *value);
            } else {
#endif /* _BCM_PETRA_ALLOW_CACHED_STAT_WRITE */
                result = bcm_dpp_counter_set(unit,
                                             proc,
                                             cntr,
                                             type,
                                             *value);
#if _BCM_PETRA_ALLOW_CACHED_STAT_WRITE
            }
#endif /* _BCM_PETRA_ALLOW_CACHED_STAT_WRITE */
        } else { /* if (write) */
            if (stats_cached) {
                result = bcm_dpp_counter_get_cached(unit,
                                                    proc,
                                                    cntr,
                                                    type,
                                                    value);
            } else {
                result = bcm_dpp_counter_get(unit,
                                             proc,
                                             cntr,
                                             type,
                                             value);
            }
        } /* if (write) */
        if (BCM_E_NONE != result) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unable to %s unit %d stat %08X proc"
                                  " %u set %u stat %s type %d: %d (%s)\n"),
                       write?"write":"read",
                       unit,
                       stat_id,
                       proc,
                       cntr,
                       _bcm_dpp_field_stats_names[stat],
                       type,
                       result,
                       _SHR_ERRMSG(result)));
        }
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unable to map stat %d to internal type:"
                              " %d (%s)\n"),
                   stat,
                   result,
                   _SHR_ERRMSG(result)));
    }
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_stat_access_multi
 *   Purpose
 *      Manipulate multi stats from a set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) unsigned int proc = the counter processor
 *      (in) unsigned int cntr = the counter set
 *      (in) unsigned int nstat - number of stats to get
 *      (in) bcm_field_stat_t *stat_arr = which statistics to get
 *      (in) int write = TRUE to write, FALSE to read
 *      (in/out) uint64 * value_arr = where to get/put the stats values
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created. 
 */
STATIC int
_bcm_dpp_field_stat_access_multi(bcm_dpp_field_info_OLD_t *unitData,
                                  int stat_id,
                                  unsigned int proc,
                                  unsigned int cntr,
                                  unsigned int nstat,
                                  bcm_field_stat_t *stat_arr,
                                  int write,
                                  uint64 *value_arr)
{
    int result = BCM_E_NONE;
    int index;
    bcm_dpp_counter_t type;
    uint8 stats_cached;
    bcm_dpp_counter_t counters_stat_arr[bcm_dpp_counter_count];
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;
    result = bcm_dpp_counter_cache_only_get(unit, &stats_cached);
    BCMDNX_IF_ERR_EXIT(result);    
    
    /* write will be made one stat each time */
    if (write) 
    {
        for (index = 0;index < nstat;index++) 
        {
            if ((0 > stat_arr[index]) || (bcmFieldStatCount <= stat_arr[index])) {
                LOG_ERROR(BSL_LS_BCM_FP,(BSL_META_U(unit,"invalid statistic %d\n"), stat_arr[index]));
                BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
            } 
            else 
            {
                BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_stat_map(stat_arr[index], &type));
#if _BCM_PETRA_ALLOW_CACHED_STAT_WRITE
                if (stats_cached) 
                {
                    BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_set_cached(unit, proc, cntr, type, value_arr[index]));
                } 
                else 
                {
#endif /* _BCM_PETRA_ALLOW_CACHED_STAT_WRITE */
                    BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_set(unit, proc, cntr, type, value_arr[index]));
#if _BCM_PETRA_ALLOW_CACHED_STAT_WRITE
                }
#endif /* _BCM_PETRA_ALLOW_CACHED_STAT_WRITE */
                
           }
        }
    }
    else  /* if (write) */
    { 
        if(nstat > bcm_dpp_counter_count)
        {
            LOG_ERROR(BSL_LS_BCM_FP,(BSL_META_U(unit,"too many stats: (%d)\n"), nstat));
            BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);            
        }
        /*convert to internal type*/    
        for ( index = 0 ; index < nstat; index++)
        {            
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_stat_map(stat_arr[index], &counters_stat_arr[index]));
        }    
        if (stats_cached) 
        {
            BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_multi_get_cached(unit, proc, cntr, nstat, counters_stat_arr, value_arr)); 

        } 
        else 
        {
            BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_multi_get(unit, proc,cntr, nstat, counters_stat_arr, value_arr));             
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}


/******************************************************************************
 *
 *  API exported functions and data
 */

/*
 *  Function
 *     bcm_petra_field_init
 *  Purpose
 *     Initialise the field APIs.
 *  Parameters
 *     (in) int unit = the unit number
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 */
int
bcm_petra_field_init(int unit)
{
    sal_mutex_t tempLock;
    int result = BCM_E_NONE;
    int index;
    bcm_dpp_field_info_OLD_t *tempUnit = NULL;
    _bcm_dpp_field_grp_idx_t groups = 0;
    _bcm_dpp_field_ent_idx_t entriesIntTcam = 0;
    _bcm_dpp_field_ent_idx_t entriesExtTcam = 0;
    _bcm_dpp_field_ent_idx_t entriesDe = 0;
    _bcm_dpp_field_ent_idx_t nofEntriesExtTcamInfo = 0;
    uint32 ppdr;
    SOC_SAND_SUCCESS_FAILURE success;
    SOC_PPC_FP_CONTROL_INDEX control_ndx;
    SOC_PPC_FP_CONTROL_INFO control_info;
    unsigned int allocSize=0;

    _bcm_dpp_field_stage_idx_t stage;
    int grpResCount = 0;
    int entResCount = 0;
    int entDeResCount = 0;
    int entDeCount;
    uint32 entCount;
    uint32 kaps_large_db_bits = 0;
    int grpCount;
    int type;
    int offset;
    int adjust;
    int found;
    int bcmQualSize;
    int32 flags;
    unsigned int ppdQualSize;
    unsigned int tempQualSize;
    unsigned int rangeQualTypes;
    const _bcm_dpp_field_device_info_t *devInfo;
    bcm_field_qualify_t qual;
    bcm_field_action_t action;
    bcm_field_qset_t rangeQual;
    SOC_SAND_OCC_BM_INIT_INFO bmp_init_info; 
    uint32 soc_sand_rv;

    _bcm_dpp_field_ent_idx_t entryTcLimit;      /* max internal TCAM entries */
    _bcm_dpp_field_ent_idx_t entryExtTcLimit;   /* max external TCAM entries */
    _bcm_dpp_field_grp_idx_t groupLimit;        /* max groups */
    _bcm_dpp_field_ent_idx_t entryDeLimit;      /* max dir ext entries */
/*
    _bcm_dpp_field_dq_idx_t dqLimit;             max data qualifier
    _bcm_dpp_field_presel_idx_t preselLimit;     max preselectors
*/
    unsigned int ltOffset;
    bcm_field_qset_t qsetType;
    _bcm_dpp_field_device_group_mode_bits_t modeBits;
    SHR_BITDCL ppqset[_SHR_BITDCLSIZE(SOC_PPC_NOF_FP_QUAL_TYPES)];
    uint8 is_allocated;
    /*
     * This is a flag to indicate, at exit, that _bcm_dpp_field_unit_info[unit] was loaded
     * by meaningful info (tempUnit was fully initialized by meaningful info).
     * If not all_went_well then _bcm_dpp_field_unit_info[unit] needs to be zeroed.
     * This flag allows early loading of _bcm_dpp_field_unit_info[unit] which is
     * required by SOC_SAND_QUALMAPS_CONVERT_HANDLE_TO_ELEMENT
     */
    int all_went_well = 0;
    SOC_SAND_OCC_BM_PTR extTcamBmp;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d) enter\n"), unit));
    if (SOC_IS_JERICHO(unit)) {
        uint32
            num_elements, num_stages, num_added_actions ;
        num_elements = 
            (sizeof(_bcm_jericho_field_added_actions.added_actions_p[0].added_actions) /
                sizeof(_bcm_jericho_field_added_actions.added_actions_p[0].added_actions[0][0])) ;
        num_stages =
            (sizeof(_bcm_jericho_field_added_actions.added_actions_p[0].added_actions) /
                sizeof(_bcm_jericho_field_added_actions.added_actions_p[0].added_actions[0])) ;
        num_added_actions = num_elements / num_stages ;
        if (_bcm_jericho_field_added_actions.num_stages != num_stages ) {
            /*
             * Number of elements (on first index) in 'added_actions' must be equal to
             * the specified number of stages (num_stages). One or the other need
             * to be modified.
             */
            BCMDNX_ERR_EXIT_MSG(
                BCM_E_INTERNAL,
                (_BSL_BCM_MSG("%s(): Specified number of stages (%d) NE to size of first index on array added_actions (%d). Modify either one."),
                __func__,_bcm_jericho_field_added_actions.num_stages,
                num_stages ) ) ;
        }
        if (_bcm_jericho_field_added_actions.num_added_actions != num_added_actions ) {
            /*
             * Number of elements (on second index) in 'added_actions' must be equal to
             * the specified number of potential added actions (num_added_actions). One
             * or the other need to be modified.
             */
            BCMDNX_ERR_EXIT_MSG(
                BCM_E_INTERNAL,
                (_BSL_BCM_MSG("%s(): Specified number of added actions (%d) NE to size of second index on array added_actions (%d). Modify either one."),
                __func__,_bcm_jericho_field_added_actions.num_added_actions,
                num_added_actions ) ) ;
        }
    }
    SHR_BITCLR_RANGE( ppqset, 0, (_SHR_BITDCLSIZE(SOC_PPC_NOF_FP_QUAL_TYPES) * SHR_BITWID));

    /* Check TCAM bank block owner SOC properties */
    for (index = 0; index < 16; index++) {
      char *tcam_bank_block_owner;
      tcam_bank_block_owner = soc_property_port_num_get_str(unit, index, spn_TCAM_BANK_BLOCK_OWNER);
      if (tcam_bank_block_owner != NULL) {
          if ((sal_strcmp(tcam_bank_block_owner, "FLP_0") != 0)
           && (sal_strcmp(tcam_bank_block_owner, "FLP_1") != 0)
           && (sal_strcmp(tcam_bank_block_owner, "VTT_0") != 0)
           && (sal_strcmp(tcam_bank_block_owner, "VTT_1") != 0)
           && (sal_strcmp(tcam_bank_block_owner, "IPMF_0") != 0)
           && (sal_strcmp(tcam_bank_block_owner, "IPMF_1") != 0)
           && (sal_strcmp(tcam_bank_block_owner, "EPMF") != 0)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                          (_BSL_BCM_MSG(
        "Unit %d: Unexpected property value (\"%s\") for tcam_bank_block_owner_%d"), unit, tcam_bank_block_owner, index));
          }
      }
    }

    /* get the descriptor for this device */
    BCMDNX_IF_ERR_EXIT(bcm_dpp_field_get_dev_info(unit, &devInfo));

    if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  allocate sw-state resources */
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.alloc(unit));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.stageD.alloc(unit, devInfo->stages));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_QUALMAPS.alloc(unit, bcmFieldQualifyCount));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ACTMAPS.alloc(unit, bcmFieldActionCount));
        for (stage = 0; stage < devInfo->stages; stage++) {
                groups += devInfo->stage[stage].maxGroups;
                entriesIntTcam += devInfo->stage[stage].maxEntriesInternalTcam;
                entriesExtTcam += devInfo->stage[stage].maxEntriesExternalTcam;
                entriesDe += devInfo->stage[stage].maxEntriesDe;
        }
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.alloc(unit, groups));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupHwInfo.alloc(unit, groups));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYTC.alloc(unit, entriesIntTcam));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYEXTTC.alloc(unit, entriesExtTcam));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.alloc(unit, entriesDe));
        /* TBD: Some qualifiers' input data is kept in etryTc and entryDe,
         * initialize entryCmn.entryBcmQual with bcmFieldQualifyCount instead of 0
         * in case the qualifier bcmFieldQualifySrcIp6 (0 in enum) needs to be added too.
         */
        groups = 0;
        entriesDe = 0;
    }

    SAL_GLOBAL_LOCK;

    /* Make sure the global lock exists */
    if (!_bcm_dpp_field_glob_lock) {
        /* Global lock does not exist */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "create global lock\n")));
        tempLock = sal_mutex_create("soc_petra_field_global_lock");
        if (!tempLock) {
            SAL_GLOBAL_UNLOCK;
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE,
                             (_BSL_BCM_MSG("unable to create global lock")));
        }
        /* Claim the global lock before exposing it */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "claim global lock\n")));
        if (sal_mutex_take(tempLock, sal_mutex_FOREVER)) {
            /* something went wrong claiming the lock */
            /* free the working lock even though it's defective */
            sal_mutex_destroy(tempLock);
            SAL_GLOBAL_UNLOCK;
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                             (_BSL_BCM_MSG("unable to claim global lock in create")));
        }
        /* Set the global lock to the one we now own, if it's still none */
        if (!_bcm_dpp_field_glob_lock) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set global lock\n")));
            _bcm_dpp_field_glob_lock = tempLock;
        }
        /* Let everybody else catch up */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "give up timeslice\n")));
        sal_thread_yield();
        /* Check for race condition and compensate if needed */
        if (_bcm_dpp_field_glob_lock != tempLock) {
            /* somebody came along during the race hole; yield to them */
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "detected race condition on field init for"
                                  " unit %d: trying to compensate\n"),
                       unit));
            /*
             *  We encountered a race condition during the hole beteen testing
             *  whether there was a global lock and setting it.  This hole
             *  seems to be impossible to avoid using C (and may be impossible
             *  to avoid in assembly on any platform that does not support a
             *  move-if-destination-is-zero type of instruction).
             *
             *  We compensate for this condition by destroying the losing copy
             *  of the primary lock (ours, since the other thread stomped ours)
             *  and going on.  We'll pick up the winning copy later (before
             *  filling in the unit data), so there should not be an error here
             *  (though the diagnostic may be useful and we definitely do need
             *  to free our lock in order to avoid leaking it).
             *
             *  If another thread is already waiting on our lock instead of the
             *  winner, it should receive an error during its next timeslice at
             *  the point of the wait, and that will propagate back to the
             *  caller as BCM_E_INTERNAL (there doesn't seem to be anything
             *  better for it).
             *
             *  This is a Bad Thing, but it is not, in itself, unrecoverable.
             *  We therefore continue without any error indication other than
             *  the diagnostic message (and any thread that was waiting on our
             *  lock can retry and should be okay, since it will also pick up
             *  the new global lock).
             *
             *  Unhappily, the race condition check is itself susceptible to
             *  the same condition for which it checks, so there's still a
             *  possibility of leaks and contention here.  Hopefully nobody's
             *  doing parallelised inits of the same subsystem on true parallel
             *  hardware or preemptive timesharing systems...
             */
            sal_mutex_destroy(tempLock);
        } else { /* if (_bcm_dpp_field_glob_lock != tempLock) */
            /* no obvious race condition or we won it */
            /* Clear the global resources */
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "clear global unit information\n")));
            sal_memset(&(_bcm_dpp_field_unit_info),
                       0x00,
                       sizeof(_bcm_dpp_field_unit_info[0]) * BCM_MAX_NUM_UNITS);
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set up global mapping tables\n")));
            /* release the global lock */
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "release global lock\n")));
            if (sal_mutex_give(tempLock)) {
                /* something went wrong */
                SAL_GLOBAL_UNLOCK;
                BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                                 (_BSL_BCM_MSG("unable to release global lock"
                                           " in create")));
            }
        } /* if (_bcm_dpp_field_glob_lock != tempLock) */
    } /* if (!_bcm_dpp_field_glob_lock) */

    SAL_GLOBAL_UNLOCK;

    /* Take the global lock */
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "take global lock\n")));
    if (sal_mutex_take(_bcm_dpp_field_glob_lock, sal_mutex_FOREVER)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("unable to take global lock")));
    }

    /* FIXME: want a way to detect this at compile time!!! */
    if (sizeof(SOC_PPC_FP_QUAL_TYPE) != sizeof(devInfo->qualMap[0])) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("unexpected difference in table sizes;"
                                   " must ensure SOC_PPC_FP_QUAL_TYPE is same"
                                   " size as _bcm_dpp_field_device_info_t"
                                   ".qualMaps[0]")));
    }

    /* If the unit is already initialised, tear it down */
    if (_bcm_dpp_field_unit_info[unit]) {
        result = _bcm_dpp_field_detach(unit);
    }
    /* reset the device */
    if (BCM_E_NONE == result) {
#ifdef BCM_WARM_BOOT_SUPPORT
        if (!SOC_WARM_BOOT(unit)) {
#endif /* def BCM_WARM_BOOT_SUPPORT */
            result = _bcm_petra_field_unit_reset(unit);
#ifdef BCM_WARM_BOOT_SUPPORT
        } /* if (!SOC_WARM_BOOT(unit)) */
#endif /* def BCM_WARM_BOOT_SUPPORT */
    } /* if (BCM_E_NONE == result) */

    /* sanity check limits */
    if (devInfo->types > _BCM_DPP_FIELD_MAX_GROUP_TYPES) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d requires adjustment to the"
                              " _BCM_DPP_FIELD_MAX_GROUP_TYPES setting:"
                              " it wants %d but current limit is %d\n"),
                   unit,
                   devInfo->types,
                   _BCM_DPP_FIELD_MAX_GROUP_TYPES));
    }
    if (devInfo->actChain > _BCM_DPP_FIELD_ACTION_CHAIN_MAX) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d requires adjustment to the"
                              " _BCM_DPP_FIELD_ACTION_CHAIN_MAX setting:"
                              " it wants %d but current limit is %d\n"),
                   unit,
                   devInfo->actChain,
                   _BCM_DPP_FIELD_ACTION_CHAIN_MAX));
    }
    if (devInfo->qualChain > _BCM_DPP_FIELD_QUAL_CHAIN_MAX) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d requires adjustment to the"
                              " _BCM_DPP_FIELD_QUAL_CHAIN_MAX setting:"
                              " it wants %d but current limit is %d\n"),
                   unit,
                   devInfo->qualChain,
                   _BCM_DPP_FIELD_QUAL_CHAIN_MAX));
    }

    /* compute certain changeable memory needs up front */
    for (rangeQualTypes = 0;
         (BCM_E_NONE == result) &&
         (bcmFieldQualifyCount > devInfo->ranges[rangeQualTypes].qualifier) &&
         (0 <= devInfo->ranges[rangeQualTypes].qualifier);
         rangeQualTypes++) {
        /* simply count the elements in this table; check details later */
    }

    /* allocate static resources up front */
    if (BCM_E_NONE == result) {
        /* determine number of entries and groups maximum */
        groups = 0;
        entriesIntTcam = 0;
        entriesExtTcam = 0;
        entriesDe = 0;
        {
            for (stage = 0; stage < devInfo->stages; stage++) {
                groups += devInfo->stage[stage].maxGroups;
                entriesIntTcam += devInfo->stage[stage].maxEntriesInternalTcam;
                entriesExtTcam += devInfo->stage[stage].maxEntriesExternalTcam;
                entriesDe += devInfo->stage[stage].maxEntriesDe;
            }
            nofEntriesExtTcamInfo = SOC_SAND_MIN(entriesExtTcam, _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES(unit));
            if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "unbound_uninstalled_external_tcam_entries_number", 0)){                
                nofEntriesExtTcamInfo = entriesExtTcam;/* in this case the SW state will be equal to actual number of entries */
            }
            if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  allocate sw-state resources */
                if (nofEntriesExtTcamInfo) {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_EXTTCAMINFO.alloc(unit, nofEntriesExtTcamInfo));
                }
            }     
        }
        /* allocate memory for the unit description, groups, entries */
        allocSize = (sizeof(*tempUnit)
#if (0)
/* { */
                     /*
                      * This dynamic memory block is now allocated via the new sw
                      * state for 'rangeInUse'
                      */
                     +
                     + sizeof(_bcm_dpp_field_entry_t) * entriesIntTcam
                     + sizeof(_bcm_dpp_field_entry_ext_t) * entriesExtTcam
                     + sizeof(_bcm_dpp_field_entry_ext_info_t) * nofEntriesExtTcamInfo
                     + sizeof(_bcm_dpp_field_entry_dir_ext_t) * entriesDe
                     + sizeof(_bcm_dpp_field_stage_t) * devInfo->stages
                     /*
                      * This dynamic memory block is now allocated via the new sw
                      * state for 'rangeInUse'
                      */
                     + sizeof(SHR_BITDCL*) * rangeQualTypes
                     + SHR_BITALLOCSIZE(_BCM_DPP_RANGE_MAX_COUNT) * rangeQualTypes
/* } */
#endif
                    ) ;
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "allocate unit %d memory: %u stages,"
                              ", %u entries internal, %u entries external, "
                              "%u preselectors, %d range types;"
                              " %u bytes total\n"),
                   unit,
                   (unsigned int)devInfo->stages,
                   (unsigned int)entriesIntTcam,
                   (unsigned int)entriesExtTcam,
                   (unsigned int)devInfo->presels,
                   rangeQualTypes,
                   allocSize));
        BCMDNX_ALLOC(tempUnit, allocSize, "BCM Soc_petra field unit info");
        if (!tempUnit) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unable to allocate %u bytes for unit %d"
                                  " information\n"),
                       allocSize,
                       unit));
            result = BCM_E_MEMORY;
        }
        /*
         * Load _bcm_dpp_field_unit_info[unit] here but set back to zero at exit
         * if NOT all_went_well.
         */
        _bcm_dpp_field_unit_info[unit] = tempUnit ;
    } /* if (BCM_E_NONE == result) */
    if (BCM_E_NONE == result) {
        /* Initialize allocated memory */
        sal_memset(tempUnit, 0x00, allocSize);
        tempUnit->unit = unit;
        tempUnit->unitHandle = (unit);
/*        tempUnit->totalSize = allocSize;*/
        tempUnit->devInfo = devInfo;
        /* set up partitions within the alloc cell */
/*        tempUnit->stageD = (_bcm_dpp_field_stage_t*)(&(tempUnit[1]));         */
/*        tempUnit->groupD =  (_bcm_dpp_field_group_t*)(&(tempUnit[1]));        */
/*        (_bcm_dpp_field_group_t*)(&(tempUnit->stageD[devInfo->stages]));      */
/*        tempUnit->entryTc = (_bcm_dpp_field_entry_t*)(&(tempUnit[1]));        */
/*        tempUnit->entryExtTc = (_bcm_dpp_field_entry_ext_t*)(&(tempUnit[1])); */
/*        tempUnit->extTcamInfo = (_bcm_dpp_field_entry_ext_info_t *)(&(tempUnit[1])); */
/*        tempUnit->entryDe = (_bcm_dpp_field_entry_dir_ext_t*)(&(tempUnit->extTcamInfo[nofEntriesExtTcamInfo]));*/
        if (!SOC_WARM_BOOT(unit))   /*Cold boot -  Update sw-state resources */
        {
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.rangeQualTypes.set(unit, rangeQualTypes));
        }
        /* create unit lock */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "create unit %d lock\n"), unit));
        _DPP_FIELD_SET_UNIT_LOCK(tempUnit,sal_mutex_create("BCM Petra Field unit lock")) ;
        if (!(_DPP_FIELD_GET_UNIT_LOCK(tempUnit))) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unable to create unit %d lock\n"), unit));
            result = BCM_E_RESOURCE;
        }
    } /* if (BCM_E_NONE == result) */

    if (SOC_IS_JERICHO(unit)) {
        if (!SOC_WARM_BOOT(unit)) {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.kaps_large_db_bits.set(unit, SOC_DPP_DEFS_GET(unit, field_large_direct_lu_key_min_length)));
            SOC_DPP_JER_CONFIG(unit)->pp.kaps_large_db_bits = SOC_DPP_DEFS_GET(unit, field_large_direct_lu_key_min_length);
        } else {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.kaps_large_db_bits.get(unit, &kaps_large_db_bits));
            SOC_DPP_JER_CONFIG(unit)->pp.kaps_large_db_bits = kaps_large_db_bits;
        }
    }

    if (SOC_DPP_IS_ELK_ENABLE(unit)) {
        if (BCM_E_NONE == result) {
            /* initialize external TCAM info table */
            for(index = 0; index < nofEntriesExtTcamInfo; index++) {
                _bcm_dpp_field_ext_info_entry_clear(unit,index);
            }

            /* allocate external TCAM information occupation bitmap */
            soc_sand_SAND_OCC_BM_INIT_INFO_clear(&bmp_init_info);
            bmp_init_info.size = nofEntriesExtTcamInfo;            
            if (!SOC_WARM_BOOT(unit))   /*Cold boot -  update sw-state resources */
            {
                soc_sand_rv = soc_sand_occ_bm_create(
                            unit,
                            &bmp_init_info,
                            &extTcamBmp);
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.extTcamBmp.set(unit, extTcamBmp));
                result = handle_sand_result(soc_sand_rv);
            }            
        }/* if (BCM_E_NONE == result) */
    }/* if (SOC_DPP_IS_ELK_ENABLE(unit)) */

    /* compute resource tracking needs */
    if (BCM_E_NONE == result) {
        for (stage = 0;
             (BCM_E_NONE == result) && (stage < devInfo->stages);
             stage++) {
            if (!SOC_WARM_BOOT(unit))   /*Cold boot -  update sw-state resources */
            {
                /* include this stage in global limits */
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.set(unit, (groupLimit + devInfo->stage[stage].maxGroups)));
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryTcLimit.get(unit, &entryTcLimit));
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryTcLimit.set(unit, (entryTcLimit + devInfo->stage[stage].maxEntriesInternalTcam)));
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryExtTcLimit.get(unit, &entryExtTcLimit));
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryExtTcLimit.set(unit, (entryExtTcLimit + devInfo->stage[stage].maxEntriesExternalTcam)));
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.set(unit, (entryDeLimit + devInfo->stage[stage].maxEntriesDe)));
            }

            /* validate shared hardware ID ranges */
            if (devInfo->stage[stage].sharesEntriesTc >= stage) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d stage %u shares entry space"
                                      " with not-yet-seen stage %d\n"),
                           unit,
                           stage,
                           devInfo->stage[stage].sharesEntriesTc));
            }
            if (devInfo->stage[stage].sharesGroups >= stage) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d stage %u shares group space"
                                      " with not-yet-seen stage %d\n"),
                           unit,
                           stage,
                           devInfo->stage[stage].sharesGroups));
            }
            if (devInfo->stage[stage].sharesEntriesDe >= stage) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d stage %u shares dir ext entry"
                                      " space with not-yet-seen stage %d\n"),
                           unit,
                           stage,
                           devInfo->stage[stage].sharesEntriesDe));
            }
            if (BCM_E_NONE == result)  
            {
                if (0 > devInfo->stage[stage].sharesGroups) {
                    grpResCount++; /* another group ID pool is needed */
                }
                if (0 > devInfo->stage[stage].sharesEntriesTc) {
                    entResCount++; /* another entry ID pool is needed */
                }
                if ((0 > devInfo->stage[stage].sharesEntriesDe) &&
                    (0 < devInfo->stage[stage].maxEntriesDe)) {
                    entDeResCount++; /* another dir ext ent ID pool needed */
                }
                entCount = 0;
                grpCount = 0;
                entDeCount = 0;
                /* compute limit for possibly shared hardware entry IDs */
                for (offset = stage;
                     0 <= offset;
                     offset = devInfo->stage[offset].sharesEntriesTc) {
                    entCount += devInfo->stage[offset].maxEntriesInternalTcam;
                    entCount += devInfo->stage[offset].maxEntriesExternalTcam;
                }
                if (!entCount) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d stage %u claims to support"
                                          " zero entries\n"),
                               unit,
                               stage));
                }
                for (offset = stage;
                     0 <= offset;
                     offset = devInfo->stage[offset].sharesEntriesTc) {
                    if(!SOC_WARM_BOOT(unit))  /*Cold boot -  update sw-state resources */
                    {
                        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.entryTcSh1.set(unit, stage, offset));
                        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.hwEntryLimit.set(unit, offset, entCount));
                    }
                }
                /* compute limit for possibly shared hardware group IDs */
                for (offset = stage;
                     0 <= offset;
                     offset = devInfo->stage[offset].sharesGroups) {
                    grpCount += devInfo->stage[offset].maxGroups;
                }
                if (!grpCount) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d stage %u claims to support"
                                          " zero groups\n"),
                               unit,
                               stage));
                }
                for (offset = stage;
                     0 <= offset;
                     offset = devInfo->stage[offset].sharesGroups) {
                    if(!SOC_WARM_BOOT(unit)) /*Cold boot -  update sw-state resources */
                    {
                        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupSh1.set(unit, stage, offset));
                        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.hwGroupLimit.set(unit, offset, grpCount));
                    }
                }
                /* compute limit for possibly shared HW dir ext ent IDs */
                for (offset = stage;
                      0 <= offset;
                      offset = devInfo->stage[offset].sharesEntriesDe) {
                    entDeCount += devInfo->stage[offset].maxEntriesDe;
                }
                /* it is not an error for a stage to not support dir ext */
                for (offset = stage;
                     0 <= offset;
                     offset = devInfo->stage[offset].sharesEntriesDe) {
                    if(!SOC_WARM_BOOT(unit))  /*Cold boot -  update sw-state resources */
                    {
                        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.entryDeSh1.set(unit, stage, offset));
                        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.hwEntryDeLimit.set(unit, offset, entDeCount));
                    }
                }
            } /* if (BCM_E_NONE == result) */
        } /* for (index = 0; index < devInfo->stages; index++) */
    } /* if (BCM_E_NONE == result) */
    if (BCM_E_NONE == result)
    {
        /*
         *  Set up boundaries and build lists for resources that need to be
         *  kept in lists.
         */
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryTcLimit.get(unit, &entryTcLimit));
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryExtTcLimit.get(unit, &entryExtTcLimit));
        if (!SOC_WARM_BOOT(unit))   /*Cold boot -  update sw-state resources */
        {
            for (stage = 0; stage < devInfo->stages; stage++) {
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupHead.set(unit, stage, groupLimit));
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupTail.set(unit, stage, groupLimit));
            }
            /*
             * Was:
             *   tempUnit->rangeInUse = (SHR_BITDCL**)(&(tempUnit->entryDe[entriesDe]));
             * Allocate memory for 'rangeQualTypes' pointers to bit-arrays.
             */
            result = FIELD_ACCESS_RANGEINUSE.ptr_alloc(unit,rangeQualTypes) ;
            if (result == BCM_E_NONE) {
                if (rangeQualTypes) {
                    /*
                     * Was:
                     *   tempUnit->rangeInUse[0] = (SHR_BITDCL*)(&(tempUnit->rangeInUse[rangeQualTypes]));
                     * This was meant to point, beyond array of pointers, to array of bit-arrays.
                     * Since this is done automatically by new sw state (NSS), take it out.
                     */
                    /*
                     * Was:
                     *   for (index = 1; index < rangeQualTypes; index++) {
                     *       tempUnit->rangeInUse[index] = &(tempUnit->rangeInUse[index - 1][_SHR_BITDCLSIZE(_BCM_DPP_RANGE_MAX_COUNT)]);
                     *   }
                     * However, the shtick on starting at index '1' is not necessary in NSS.
                     */
                     for (index = 0; index < rangeQualTypes; index++) {
                        result = FIELD_ACCESS_RANGEINUSE.alloc_bitmap(unit,index,_BCM_DPP_RANGE_MAX_COUNT) ;
                        if (result != BCM_E_NONE) {
                            break ;
                        }
                    }
                }
            }
        }
       
        if (!SOC_WARM_BOOT(unit)) {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.set(unit, 0, groups));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.set(unit, 0, devInfo->stages));
            for (index = 1; index < groups; index++) {
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.set(unit, index - 1, index));
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupPrev.set(unit, index , index - 1));
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.set(unit, index , devInfo->stages));
            }
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.set(unit, groups - 1, groups));
        }
#if (0)
/* { */
        /*
         * The code taken out here is translated, just below, to new sw state
         * 'language'.
         */
        tempUnit->entryTc[0].entryCmn.entryPrev = entriesIntTcam;
        tempUnit->entryTc[0].entryCmn.entryGroup = groupLimit;
        for (index = 1; index < entriesIntTcam; index++) {
            tempUnit->entryTc[index - 1].entryCmn.entryNext = index;
            tempUnit->entryTc[index].entryCmn.entryPrev = index - 1;
            tempUnit->entryTc[index].entryCmn.entryGroup = groupLimit;
        }
        tempUnit->entryTc[entriesIntTcam - 1].entryCmn.entryNext = entriesIntTcam;
/* } */
#endif
        if (!SOC_WARM_BOOT(unit)) {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYTC.entryCmn.entryPrev.set(unit,0,entriesIntTcam)) ;
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYTC.entryCmn.entryGroup.set(unit,0,groupLimit)) ;
            for (index = 1; index < entriesIntTcam; index++) {
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYTC.entryCmn.entryNext.set(unit,(index - 1),index)) ;
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYTC.entryCmn.entryPrev.set(unit,index,(index - 1))) ;
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYTC.entryCmn.entryGroup.set(unit,index,groupLimit)) ;
            }
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYTC.entryCmn.entryNext.set(unit,(entriesIntTcam - 1),entriesIntTcam)) ;
        }
#if (0)
/* { */
        /*
         * The code taken out here is translated, just below, to new sw state
         * 'language'.
         */
        tempUnit->entryExtTc[0].entryCmn.entryPrev = entriesExtTcam;
        tempUnit->entryExtTc[0].entryCmn.entryGroup = groupLimit;
        for (index = 1; index < entriesExtTcam; index++) {
            tempUnit->entryExtTc[index - 1].entryCmn.entryNext = index;
            tempUnit->entryExtTc[index].entryCmn.entryPrev = index - 1;
            tempUnit->entryExtTc[index].entryCmn.entryGroup = groupLimit;
        }
        tempUnit->entryExtTc[entriesExtTcam - 1].entryCmn.entryNext = entriesExtTcam;
/* } */
#endif
        if (!SOC_WARM_BOOT(unit)) {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYEXTTC.entryCmn.entryPrev.set(unit,0,entriesExtTcam)) ;
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYEXTTC.entryCmn.entryGroup.set(unit,0,groupLimit)) ;
            for (index = 1; index < entriesExtTcam; index++) {
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYEXTTC.entryCmn.entryNext.set(unit,(index - 1),index)) ;
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYEXTTC.entryCmn.entryPrev.set(unit,index,(index - 1))) ;
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYEXTTC.entryCmn.entryGroup.set(unit,index,groupLimit)) ;
            }
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYEXTTC.entryCmn.entryNext.set(unit,(entriesExtTcam - 1),entriesExtTcam)) ;
        }

        if (!SOC_WARM_BOOT(unit)) {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryPrev.set(unit, 0, entriesDe));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryGroup.set(unit, 0, groupLimit));
            for (index = 1; index < entriesDe; index++) {
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryNext.set(unit, index - 1, index));
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryPrev.set(unit, index, index - 1));
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryGroup.set(unit, index, groupLimit));
            }
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryNext.set(unit, entriesDe - 1, entriesDe));
            for (index = 0; index < SOC_PPC_NOF_FP_QUAL_TYPES; index++) {
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.ppdQual.set(unit, index, BCM_FIELD_ENTRY_INVALID));
            }
        }
        if (groupLimit != groups) {
            result = BCM_E_INTERNAL;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unexpected difference between computed"
                                  " maximum group counts: %d versus %d\n"),
                       groupLimit,
                       groups));
        }
        if (entryTcLimit != entriesIntTcam) {
            result = BCM_E_INTERNAL;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unexpected difference between computed"
                                  " maximum entry counts: internal-%d, external-%d, versus %d\n"),
                       entryTcLimit,
                       entryExtTcLimit,
                       entriesIntTcam));
        }
        if (entryExtTcLimit != entriesExtTcam) {
            result = BCM_E_INTERNAL;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unexpected difference between computed"
                                  " maximum entry counts: internal-%d, external-%d, versus %d\n"),
                       entryTcLimit,
                       entryExtTcLimit,
                       entriesExtTcam));
        }
    }

    if(!SOC_WARM_BOOT(unit)) {
        /* set default cascaded key length */
        if (BCM_E_NONE == result) {
            SOC_PPC_FP_CONTROL_INDEX_clear(&control_ndx);
            SOC_PPC_FP_CONTROL_INFO_clear(&control_info);
            control_ndx.type = SOC_PPC_FP_CONTROL_TYPE_KEY_CHANGE_SIZE;
            control_ndx.val_ndx = 0;
            control_info.val[0] = 12;
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set cascaded key length %d\n"),
                       control_info.val[0]));
            ppdr = soc_ppd_fp_control_set(tempUnit->unitHandle,
                                          SOC_CORE_INVALID,
                                          &control_ndx,
                                          &control_info,
                                          &success);
            result = handle_sand_result(ppdr);
            if (BCM_E_NONE == result) {
                result = translate_sand_success_failure(success);
            }
            if (BCM_E_NONE == result) {
                /*
                 * Was:
                 *   tempUnit->cascadedKeyLen = control_info.val[0];
                 */
                if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  allocate sw-state resources */
                    result = FIELD_ACCESS.cascadedKeyLen.set(unit, control_info.val[0]);
                }
            }
        }
    }

    /* parse the bits per group mode table */
    for (index = 0;
         (BCM_E_NONE == result) &&
         (bcmFieldGroupModeCount > devInfo->modeBits[index].mode);
         index++) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "scanning unit %d group mode table at %d\n"),
                   unit,
                   index));
        /* validate the settings in the table */
        if (devInfo->modeBits[index].stage >= devInfo->stages) {
            result = BCM_E_CONFIG;

            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d mode bits tries to set bit width %d"
                                  " for mode %d (%s) in invalid stage %d\n"),
                       unit,
                       devInfo->modeBits[index].length,
                       devInfo->modeBits[index].mode,
                       _bcm_dpp_field_group_mode_name[devInfo->modeBits[index].mode],
                       devInfo->modeBits[index].stage));
        }
        if (devInfo->modeBits[index].length <= 0) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d mode bits tries to set invalid"
                                  " length %d for mode %d (%s) in stage %d"
                                  " (%s)\n"),
                       unit,
                       devInfo->modeBits[index].length,
                       devInfo->modeBits[index].mode,
                       _bcm_dpp_field_group_mode_name[devInfo->modeBits[index].mode],
                       devInfo->modeBits[index].stage,
                       devInfo->stage[devInfo->modeBits[index].stage].stageName));
        }
        if (bcmFieldGroupModeAuto == devInfo->modeBits[index].mode) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d mode bits tries to set width %d for"
                                  " mode %d (%s) in stage %d (%s), but this is"
                                  " done automatically\n"),
                       unit,
                       devInfo->modeBits[index].length,
                       devInfo->modeBits[index].mode,
                       _bcm_dpp_field_group_mode_name[devInfo->modeBits[index].mode],
                       devInfo->modeBits[index].stage,
                       devInfo->stage[devInfo->modeBits[index].stage].stageName));
        }

        if  (!SOC_WARM_BOOT(unit))       /*Cold boot -  update sw-state resources . Skip if WarmBoot*/
        {
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.is_allocated(unit, devInfo->modeBits[index].stage, devInfo->modeBits[index].mode, &is_allocated));
            if (is_allocated) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d mode bits tries to set data for"
                                      " mode %d (%s) in stage %d (%s) after it was"
                                      " already set\n"),
                           unit,
                           devInfo->modeBits[index].mode,
                           _bcm_dpp_field_group_mode_name[devInfo->modeBits[index].mode],
                           devInfo->modeBits[index].stage,
                           devInfo->stage[devInfo->modeBits[index].stage].stageName));
            }
            if (BCM_E_NONE == result) 
            {
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.alloc(unit, devInfo->modeBits[index].stage, devInfo->modeBits[index].mode));
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.set(unit, devInfo->modeBits[index].stage, devInfo->modeBits[index].mode, &(devInfo->modeBits[index])));
            }
        }
    } /* for (all entries in modeBits table) */
    if ((BCM_E_NONE == result) &&
        (devInfo->modeBits[index].mode > bcmFieldGroupModeCount)) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d mode bits contains entry setting stage"
                              " %d and invalid mode %d to width %d; is the end"
                              " of list entry correct?\n"),
                   unit,
                   devInfo->modeBits[index].stage,
                   devInfo->modeBits[index].mode,
                   devInfo->modeBits[index].length));
    }
    /* find the maximum number of bits for a group and keep as 'Auto' */
    for (stage = 0;
         (BCM_E_NONE == result) && (stage < devInfo->stages);
         stage++) {
        offset = 0;
        for (index = 0; index < bcmFieldGroupModeCount; index++) {
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.is_allocated(unit, stage, index, &is_allocated));
            if (is_allocated)
            {
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.get(unit, stage, index, &modeBits));
                if ((bcmFieldGroupModeAuto != index) &&
                    (_BCM_DPP_FIELD_ENT_TYPE_IS_TCAM(modeBits.entryType)) &&
                    (offset < modeBits.length)) {
                        /* this is TCAM and not auto and longer than seen so far */
                        offset = modeBits.length;
                        if (!SOC_WARM_BOOT(unit))   /*Cold boot -  update sw-state resources */
                        {
                            /* Check if ModeAuto was allocated already, if not them alloc it before setting */
                            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.is_allocated(unit, stage, bcmFieldGroupModeAuto, &is_allocated));

                            if (!is_allocated)
                                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.alloc(unit, stage, bcmFieldGroupModeAuto));
                            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.modeBits.set(unit, stage, bcmFieldGroupModeAuto, &modeBits));
                        }
                    }
            }
        }
        if (0 == offset) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d stage %u includes no supported"
                                  " group modes\n"),
                       unit,
                       stage));
        }
    }
    /* make sure the stage maps point to end of table if not valid */
    for (stage = 0;
         (BCM_E_NONE == result) && (stage < devInfo->stages);
         stage++) {
        for (type = 0;
             type < (_BCM_DPP_FIELD_MAX_GROUP_TYPES + 1);
             type++) {
            if (!SOC_WARM_BOOT(unit))   /*Cold boot -  update sw-state resources */
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.ltOffset.set(unit, stage, type, devInfo->mappings));
        }
    }

    /* make sure the mapping table does not exceed expected parameters */
    for (index = 0;
         (BCM_E_NONE == result) && (index < devInfo->mappings);
         index++) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "scanning unit %d mapping table at %d\n"),
                   unit,
                   index));
        if (devInfo->stMapInfo[index].stmStage >= devInfo->stages) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d cell mapping contains entry"
                                  " referring to stage %d, but only %d"
                                  " valid stages\n"),
                       unit,
                       devInfo->stMapInfo[index].stmStage,
                       devInfo->stages));
        }
        if (0 == (devInfo->stMapInfo[index].stmFlags &
                  _BCM_DPP_FIELD_GROUP_PRESEL)) {
            /* only check this if not preselector definition */
            if (devInfo->types <= devInfo->stMapInfo[index].stmType) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d cell mapping contains entry"
                                      " referring to group type %d, but only"
                                      " %d are valid\n"),
                           unit,
                           devInfo->stMapInfo[index].stmType,
                           devInfo->types));
            }
        }
        if ((SOC_PPC_NOF_FP_PREDEFINED_ACL_KEYS < devInfo->stMapInfo[index].predefKey) ||
            (0 > devInfo->stMapInfo[index].predefKey)) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d cell mapping contains entry"
                                  " referring to predefined key %d, but"
                                  " only 0..%d valid\n"),
                       unit,
                       devInfo->stMapInfo[index].predefKey,
                       SOC_PPC_NOF_FP_PREDEFINED_ACL_KEYS));
        }
        if (!SOC_WARM_BOOT(unit))   /*Cold boot -  update sw-state resources */
        {

            if (0 == (devInfo->stMapInfo[index].stmFlags & _BCM_DPP_FIELD_GROUP_PRESEL)) {
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.ltOffset.get(unit, devInfo->stMapInfo[index].stmStage, devInfo->stMapInfo[index].stmType, &ltOffset));

                if (devInfo->mappings <= ltOffset ) {
                    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.ltOffset.set(unit, devInfo->stMapInfo[index].stmStage, devInfo->stMapInfo[index].stmType, index));
                } else {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d cell mapping contains entry %d"
                                          " referring to stage %d group type %d but"
                                          " entry %d is already used for that, mapping %d\n"),
                               unit,
                               index,
                               devInfo->stMapInfo[index].stmStage,
                               devInfo->stMapInfo[index].stmType,
                               ltOffset,
                               devInfo->mappings));
                }
            } else { /* if (mapping is not for preselectors) */
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.ltOffset.get(unit, devInfo->stMapInfo[index].stmStage, _BCM_DPP_FIELD_MAX_GROUP_TYPES, &ltOffset));
                if (devInfo->mappings <= ltOffset) {
                    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.ltOffset.set(unit, devInfo->stMapInfo[index].stmStage, _BCM_DPP_FIELD_MAX_GROUP_TYPES, index));
                } else {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d cell mapping contains entry %d"
                                          " referring to stage %d preselector but"
                                          " entry %d is already used for that\n"),
                               unit,
                               index,
                               devInfo->stMapInfo[index].stmStage,
                               ltOffset));
                }
            } /* if (mapping is not for preselectors) */
        } /* if (!SOC_WARM_BOOT(unit))*/
    } /* for (index = 0; index < devInfo->mappings; index++) */

    /* set bcmFieldQualifyL2Learn PPD qualifiers according to soc property */
    if((soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "l3_learn_force_in_fwd", 0)) || (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "IVL_inlif_profile", 0))) {
        for (index = 0; devInfo->qualMap[index] < bcmFieldQualifyCount; ) {
            if (devInfo->qualMap[index] == bcmFieldQualifyL2Learn) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &restricted_l2_learn_type_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }
            index += sizeof(_bcm_arad_field_device_qual_info_layer_t)/sizeof(int32);  
        }
    }
    if ( soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "IVL_inlif_profile", 0))
    {
        for (index = 0; devInfo->actMap[index] < bcmFieldActionCount; ) {
            if (devInfo->actMap[index] == bcmFieldActionClassDestSet) {
                sal_memcpy(&devInfo->actMap[index],
                           &restricted_class_dest_set_action,
                           sizeof(_bcm_arad_field_device_action_info_layer_t));
            }
            index += sizeof(_bcm_arad_field_device_action_info_layer_t)/sizeof(int32);
        }
    }
    /* set forwardingType PPD qualifiers according to soc property */
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "fp_restricted_forwarding_type", 0)) {
        for (index = 0; devInfo->qualMap[index] < bcmFieldQualifyCount; ) {
            if (devInfo->qualMap[index] == bcmFieldQualifyForwardingType) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &restricted_forwarding_type_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }
            index += sizeof(_bcm_arad_field_device_qual_info_layer_t)/sizeof(int32);  
        }
    }
    if ( soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, CF_IPV6_UC_WITH_RPF_2PASS_ENABLED, 0))
    {
        for (index = 0; devInfo->actMap[index] < bcmFieldActionCount; ) {
            if (devInfo->actMap[index] == bcmFieldActionForwardingTypeNew) {
                sal_memcpy(&devInfo->actMap[index],
                           &restricted_action_type_act_info,
                           sizeof(_bcm_arad_field_device_action_info_layer_t));
            }
            index += sizeof(_bcm_arad_field_device_action_info_layer_t)/sizeof(int32);
        }
    }

    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vt_tst1", 0)) {
        for (index = 0; devInfo->qualMap[index] < bcmFieldQualifyCount; ) {
            if (devInfo->qualMap[index] == bcmFieldQualifyClassId) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &classId_as_vlan_domain_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }
            else if (devInfo->qualMap[index] == bcmFieldQualifyOuterVlanActionRange) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &OuterVlanActionRange_as_outer_vid_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }
            else if (devInfo->qualMap[index] == bcmFieldQualifyInnerVlanActionRange) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &InnerVlanActionRange_as_inner_vid_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }
            index += sizeof(_bcm_arad_field_device_qual_info_layer_t)/sizeof(int32);  
        }
    }

    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vt_tst2", 0)  ) {
        for (index = 0; devInfo->qualMap[index] < bcmFieldQualifyCount; ) {
            if (devInfo->qualMap[index] == bcmFieldQualifyClassId) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &classId_as_vlan_domain_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }else if (devInfo->qualMap[index] == bcmFieldQualifyInnerVlanActionRange) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &InnerVlanActionRange_as_inner_vid_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }else if (devInfo->qualMap[index] == bcmFieldQualifyOuterVlanActionRange) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &OuterVlanActionRange_as_outer_vid_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }
            index += sizeof(_bcm_arad_field_device_qual_info_layer_t)/sizeof(int32);  
        }
    }
    
      
    if (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vrrp_scaling_tcam", 0) || SOC_DPP_CONFIG(unit)->pp.vrrp_scaling_tcam) {
        for (index = 0; devInfo->qualMap[index] < bcmFieldQualifyCount; ) {
            if (devInfo->qualMap[index] == bcmFieldQualifySrcClassField) {/*VD*/
                sal_memcpy(&devInfo->qualMap[index], 
                           &SrcClassField_as_vlan_domain_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }else if (devInfo->qualMap[index] == bcmFieldQualifyTranslatedInnerVlanId ) {/* CMPRSD inner */
                sal_memcpy(&devInfo->qualMap[index], 
                           &TranslatedInnerVlanId_as_cmprsd_inner_vid_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }else if (devInfo->qualMap[index] == bcmFieldQualifyTranslatedOuterVlanId) {/* CMPRSD outer */
                sal_memcpy(&devInfo->qualMap[index],
                           &TranslatedOuterVlanId_as_cmprsd_outer_vid_qual_info,
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            } else if (devInfo->qualMap[index] == bcmFieldQualifyOamInLifId) { /* EtherType */
                sal_memcpy(&devInfo->qualMap[index],
                           &OamInLifId_as_double_tag_hdr_ethertype_qual_info,
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }
            index += sizeof(_bcm_arad_field_device_qual_info_layer_t) / sizeof(int32);  
        }
    }

    /*For QAX and above re-define the drop action*/
    if (SOC_IS_JERICHO_PLUS(unit)) {
        for (index = 0; devInfo->actMap[index] < bcmFieldActionCount; ) {
            if (devInfo->actMap[index] == bcmFieldActionDrop) {
                sal_memcpy(&devInfo->actMap[index], 
                           &Drop_Action_info, 
                           sizeof(_bcm_arad_field_device_action_info_layer_t));
            }
            index += sizeof(_bcm_arad_field_device_action_info_layer_t)/sizeof(int32);
        }
    }

    /*For Jericho and above re-define bcmFieldActionDropPrecedence, can use DP from signal and not use egress trap */
    if (SOC_IS_JERICHO(unit))
    {
        for (index = 0; devInfo->actMap[index] < bcmFieldActionCount; ) {
            if (devInfo->actMap[index] == bcmFieldActionDropPrecedence) {
                sal_memcpy(&devInfo->actMap[index], 
                           &Drop_Precedence_Action_info, 
                           sizeof(_bcm_arad_field_device_action_info_layer_t));
            }
            index += sizeof(_bcm_arad_field_device_action_info_layer_t)/sizeof(int32);
        }
    }

    /* build the stage qualifier set bitmaps and reverse mapping */
    BCM_FIELD_QSET_INIT(rangeQual);
    for (index = 0;
         (BCM_E_NONE == result) &&
         (bcmFieldQualifyCount > devInfo->qualMap[index]) &&
         (0 <= devInfo->qualMap[index]);
         /* increment is performed inline */) {
        int32 qualMaps_handle ;

        /* consider this map layer */
        qual = devInfo->qualMap[index + _BCM_DPP_FIELD_QUALMAP_OFFSET_QUAL];
        if (!SOC_WARM_BOOT(unit))
        {
            /*Cold boot -  update sw-state resources */
            unsigned int qualMapCount ;

            /*
             * Was:
             *   tempUnit->qualMapCount++;
             */
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.qualMapCount.get(unit, &qualMapCount)) ;
            qualMapCount++ ;
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.qualMapCount.set(unit, qualMapCount)) ;
            /*
             * ensure each qualifier is included only once
             */
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_QUALMAPS.get(unit, qual, &qualMaps_handle)) ;
            /*
             * Note that a zero handle indicates: not loaded. Otherwise, it is loaded by
             * some meaningful value.
             */
            if (qualMaps_handle) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d qualifier maps try to set qualifier"
                                      " %d (%s) but it was already set\n"),
                           unit,
                           qual,
                           _bcm_dpp_field_qual_name[qual]));
            }
            /* keep track of this qualifier's description */
            /*
             * Was:
             *   tempUnit->qualMaps[qual] = &(devInfo->qualMap[index + _BCM_DPP_FIELD_QUALMAP_OFFSET_QUAL]) ;
             */
            SOC_SAND_QUALMAPS_CONVERT_QUALMAPS_INDEX_TO_HANDLE(qualMaps_handle,(index + _BCM_DPP_FIELD_QUALMAP_OFFSET_QUAL)) ;
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_QUALMAPS.set(unit, qual, qualMaps_handle)) ;
        }
        /* ensure this qualifier has a sensible number of significant bits */
        bcmQualSize = devInfo->qualMap[index + _BCM_DPP_FIELD_QUALMAP_OFFSET_LENGTH];
        if (bcmQualSize < -1) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d qualifier maps try to set qualifier"
                                  " %d (%s) with an unexpected number of bits"
                                  " %d\n"),
                       unit,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       bcmQualSize));
        }
        offset = devInfo->qualMap[index + _BCM_DPP_FIELD_QUALMAP_OFFSET_SHIFT];
        /* ensure this qualifier's shift distance is reasonable */
        if (offset > 255) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d qualifier maps try to set qualifier"
                                  " %d (%s) with unexpectedly large right shift"
                                  " distance in excess of 255 bits (%d)\n"),
                       unit,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       offset));
        }
        if (offset < -63) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d qualifier maps try to set qualifier"
                                  " %d (%s) with a left shift distance in"
                                  " excess of 63 bits (%d); just skip initial"
                                  " chain members until shift distance is less"
                                  " than 64 bits\n"),
                       unit,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       offset));
        }
        /* verify the qualifier's flags */
        flags = devInfo->qualMap[index + _BCM_DPP_FIELD_QUALMAP_OFFSET_FLAGS];
        if (TRUE == flags) /* this equality comparison is deliberate */ {
            /*
             *  Special case: since older versions of the tables used this
             *  element as a TRUE/FALSE value, we do not want to accidentally
             *  have an update use this element incorrectly.  While FALSE is
             *  okay (no flags set), TRUE should have been converted to a
             *  particular flag.
             *
             *  Note this is a deliberate and explicit equality comparison to
             *  TRUE, which is a specific value (almost universally it
             *  inovolves bit 0 being set, which is not a valid flag) rather
             *  than a 'not FALSE' type of comparison, which would usually
             *  trigger for any nonzero value.
             */
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d qualifier maps not current; flags"
                                  " value is using boolean TRUE value for"
                                  " qualifier %d (%s) where such should have"
                                  " been a specific flag\n"),
                       unit,
                       qual,
                       _bcm_dpp_field_qual_name[qual]));
        }
        if (flags & (~_BCM_DPP_QUAL_FLAGS_ALL_VALID_BITS)) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d qualifier maps try to set invalid"
                                  " flags %08X for qualifier %d (%s)\n"),
                       unit,
                       flags & (~_BCM_DPP_QUAL_FLAGS_ALL_VALID_BITS),
                       qual,
                       _bcm_dpp_field_qual_name[qual]));
        }
        if (flags & (_BCM_DPP_QUAL_RANGE_BITMAP | _BCM_DPP_QUAL_RANGE_INDEX)) {
            /* this is a range qualifier of some kind */
            BCM_FIELD_QSET_ADD(rangeQual, qual);
            if ((_BCM_DPP_QUAL_RANGE_BITMAP | _BCM_DPP_QUAL_RANGE_INDEX) ==
                (flags & (_BCM_DPP_QUAL_RANGE_BITMAP |
                          _BCM_DPP_QUAL_RANGE_INDEX))) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d qualifier %d (%s) claims to be"
                                      " both bitmap and index type range\n"),
                           unit,
                           qual,
                           _bcm_dpp_field_qual_name[qual]));
            }
        }
        /* display diagnostic indicating parsing progress */
        if (0 < bcmQualSize) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d scanning qualifier map table at"
                                  " %d, %d %s: %d bits, %d offset, flags"
                                  " %08X\n"),
                       unit,
                       index,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       bcmQualSize,
                       offset,
                       flags));
        } else if (0 == bcmQualSize) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d scanning qualifier map table at"
                                  " %d, %d %s: special/translated, flags"
                                  " %08X\n"),
                       unit,
                       index,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       flags));
        } else if (-1 == bcmQualSize) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d scanning qualifier map table at"
                                  " %d, %d %s: (variable) length from"
                                  " hardware, flags %08X\n"),
                       unit,
                       index,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       flags));
        } else {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d qualifier map table at %d, %d (%s)"
                                  " has invalid length setting %d\n"),
                       unit,
                       index,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       bcmQualSize));
        }
        /* point to the PPD layer qualifier chains */
        index += _BCM_DPP_FIELD_QUALMAP_OFFSET_MAPS;
        /* ensure all of the maps for this qualifier look reasonable */
        for (offset = 0; offset < devInfo->mappings; offset++) {
            /* determine stage and type for each map */
            stage = devInfo->stMapInfo[offset].stmStage;
            if (devInfo->stMapInfo[offset].stmFlags & _BCM_DPP_FIELD_GROUP_PRESEL) {
                type = _BCM_DPP_FIELD_MAX_GROUP_TYPES;
            } else {
                type = devInfo->stMapInfo[offset].stmType;
            }
            /* make sure no doubled qualifiers except invalid */
            for (adjust = 0;
                 adjust < devInfo->qualChain;
                 adjust++) {
                for (found = adjust + 1;
                     found < devInfo->qualChain;
                     found++) {
                    if (_BCM_DPP_FIELD_PPD_QUAL_VALID(devInfo->qualMap[index + adjust]) &&
                        _BCM_DPP_FIELD_PPD_QUAL_VALID(devInfo->qualMap[index + found]) &&
                        (devInfo->qualMap[index + adjust] == devInfo->qualMap[index + found])) {
                        result = BCM_E_CONFIG;
                        LOG_ERROR(BSL_LS_BCM_FP,
                                  (BSL_META_U(unit,
                                              "unit %d qualifier map table at"
                                              " %d, %s (%d): duplicated PPD"
                                              " layer qualifier %s (%d)\n"),
                                   unit,
                                   index + found,
                                   _bcm_dpp_field_qual_name[qual],
                                   qual,
                                   SOC_PPC_FP_QUAL_TYPE_to_string(devInfo->qualMap[index + found]),
                                   devInfo->qualMap[index + found]));
                    }
                }
            }
            /* check each possible map in the chain, build reverse map */
            for (adjust = 0, found = FALSE, ppdQualSize = 0;
                 adjust < devInfo->qualChain;
                 adjust++, index++) {
                /* ensure chain PPD qualifier is valid */
                if (((SOC_PPC_NOF_FP_QUAL_TYPES + 1) < devInfo->qualMap[index]) ||
                    (0 > devInfo->qualMap[index])||
                    (BCM_FIELD_ENTRY_INVALID == devInfo->qualMap[index])) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d qualifier map for qual %d"
                                          " (%s) stage %u (%s) type %d (%s)"
                                          " chain %d tries to set invalid PPD"
                                          " qualifier %d (min 0, max %d)\n"),
                               unit,
                               qual,
                               _bcm_dpp_field_qual_name[qual],
                               stage,
                               devInfo->stage[stage].stageName,
                               type,
                               devInfo->typeNames[type],
                               adjust,
                               devInfo->qualMap[index],
                               SOC_PPC_NOF_FP_QUAL_TYPES + 1));
                }
                /* ensure chains are contiguously populated */
                if ((!found) && (0 != adjust) &&
                    (_BCM_DPP_FIELD_PPD_QUAL_VALID(devInfo->qualMap[index]))) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d qualifier map %d (%s) stage"
                                          " %u (%s) type %d (%s) has a gap"
                                          " before chain %d\n"),
                               unit,
                               qual,
                               _bcm_dpp_field_qual_name[qual],
                               stage,
                               devInfo->stage[stage].stageName,
                               type,
                               devInfo->typeNames[type],
                               adjust));
                }
                if ((BCM_E_NONE == result) &&
                    (SOC_PPC_NOF_FP_QUAL_TYPES != devInfo->qualMap[index]) &&
                    (SOC_PPC_FP_QUAL_IRPP_INVALID != devInfo->qualMap[index]) &&
                    (BCM_FIELD_ENTRY_INVALID != devInfo->qualMap[index]) ) {
                    /* no error and not filler */
                    /* found a mapping or a flag for this qualifier */
                    found = TRUE;
                    if (!SOC_WARM_BOOT(unit))   /*Cold boot -  update sw-state resources */
                    {
                        /* add this qualifier to the unit's qset */
                        /*
                         * Was:
                         *   BCM_FIELD_QSET_ADD(tempUnit->unitQset, qual);
                         * which was equivalent to:
                         *   SHR_BITSET((tempUnit->unitQset.w), qual)
                         */
                        result = FIELD_ACCESS_UNITQSET_W.bit_set(unit,qual) ;
                        if (BCM_E_NONE == result) {
                            /* add this qualifier to the stage's qset */
                        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.stgQset.w.bit_set(unit, stage, qual));
                        /* add this qualifier to type's qset in this stage */
                        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.qsetType.w.bit_set(unit, stage, type, qual));
                        }
                    }
                    if ((SOC_PPC_NOF_FP_QUAL_TYPES > devInfo->qualMap[index]) &&
                         (BCM_FIELD_ENTRY_INVALID != devInfo->qualMap[index])) {
                        /* not a flag */
                        if (flags & _BCM_DPP_QUAL_REVERSE_LOOKUP) {
                            if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  update sw-state resources */
                                /* keep track for reverse mapping */
                                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.ppdQual.set(unit, devInfo->qualMap[index], qual));
                                LOG_DEBUG(BSL_LS_BCM_FP,
                                          (BSL_META_U(unit,
                                                      "unit %d qualifier %s (%d)"
                                                      " is used for mapping"
                                                      " PPD qual %s (%d)\n"),
                                           unit,
                                           _bcm_dpp_field_qual_name[qual],
                                           qual,
                                           SOC_PPC_FP_QUAL_TYPE_to_string(devInfo->qualMap[index]),
                                           devInfo->qualMap[index]));
                            }
                        }

                        /* adjust PPD layer size */ 
                        result = _bcm_dpp_ppd_qual_bits(unit,
                                                        tempUnit->devInfo->stMapInfo[offset].stmStage,
                                                        devInfo->qualMap[index],
                                                        &tempQualSize,
                                                        NULL,
                                                        NULL);
                        if (BCM_E_NONE == result) {
                            ppdQualSize += tempQualSize;
                        }
                    }
                } else {
                    found = FALSE;
                }
            } /* for (all chained qualifiers) */
            if (BCM_E_NONE == result) {
                if ((ppdQualSize) &&
                    (0 < bcmQualSize) &&
                    (bcmQualSize > ppdQualSize)) {
                    /*
                     *  PPD qualifier must at least cover the BCM qualifier.
                     *  There are some special cases where the qualifiers
                     *  require mapping or other extra treatment; the BCM size
                     *  is said to be zero for these and so they will not
                     *  trigger this.
                     */
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d qualifier map %d (%s) stage"
                                          " %u (%s) type %d (%s) PPD size %u"
                                          " does not match BCM size %u\n"),
                               unit,
                               qual,
                               _bcm_dpp_field_qual_name[qual],
                               stage,
                               devInfo->stage[stage].stageName,
                               type,
                               devInfo->typeNames[type],
                               ppdQualSize,
                               bcmQualSize));
                } else if (ppdQualSize) {
                    LOG_DEBUG(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d qualifier map %d (%s)"
                                          " stage %u (%s) type %d (%s) PPD"
                                          " size %u\n"),
                               unit,
                               qual,
                               _bcm_dpp_field_qual_name[qual],
                               stage,
                               devInfo->stage[stage].stageName,
                               type,
                               devInfo->typeNames[type],
                               ppdQualSize));
                }
            } /* if (BCM_E_NONE == result) */
        } /* for (offset = 0; offset < devInfo->mappings; offset++) */
    } /* for (all entries in elements table) */
    if ((0 > devInfo->qualMap[index]) ||
        (bcmFieldQualifyCount < devInfo->qualMap[index])) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d qualifier map at %d tries to define"
                              " invalid qualifier %d\n"),
                   unit,
                   index,
                   devInfo->qualMap[index]));
    }
    /* compute stage preselector PPD qualifier sets */
    for (index = 0;
         (BCM_E_NONE == result) &&
         (index < devInfo->stages);
         index++) {
        if (devInfo->stage[index].stageFlags &
            _BCM_DPP_FIELD_DEV_STAGE_USES_PRESELECTORS) {
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.qsetType.get(unit, index, _BCM_DPP_FIELD_MAX_GROUP_TYPES, &qsetType));
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.ppqset.bit_range_read(unit, index, 0, 0, _SHR_BITDCLSIZE(SOC_PPC_NOF_FP_QUAL_TYPES) * (8 * sizeof(int))/*32bits in int*/, ppqset));
            result = _bcm_dpp_field_quals_to_ppd(tempUnit,
                                                 index,
                                                 1 << _BCM_DPP_FIELD_MAX_GROUP_TYPES,
                                                 qsetType,
                                                 &ppqset,
                                                 NULL,
                                                 NULL,
                                                 NULL);
            if (!SOC_WARM_BOOT(unit))   /*Cold boot -  update sw-state resources */
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.ppqset.bit_range_write(unit, index, 0, 0, _SHR_BITDCLSIZE(SOC_PPC_NOF_FP_QUAL_TYPES) * (8 * sizeof(int))/*32bits in int*/, ppqset));

            if (BCM_E_NONE != result) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d unable to map stage %s (%d)"
                                      " preselector qualifier set to PPD:"
                                      " %d (%s)\n"),
                           unit,
                           devInfo->stage[index].stageName,
                           index,
                           result,
                           _SHR_ERRMSG(result)));
            }
        } /* if (this stage uses preselectors) */
    } /* for (all stages as long as no errors) */

    /* scan the range table */
    for (index = 0;
         (BCM_E_NONE == result) &&
         (bcmFieldQualifyCount > devInfo->ranges[index].qualifier) &&
         (0 <= devInfo->ranges[index].qualifier);
         index++) {
        if (BCM_FIELD_QSET_TEST(rangeQual, devInfo->ranges[index].qualifier)) {
            if (0 == devInfo->ranges[index].rangeFlags) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d range table at %d type %s (%d)"
                                      " does not specify any range flags\n"),
                           unit,
                           index,
                           _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                           devInfo->ranges[index].qualifier));
            }
            if (devInfo->ranges[index].rangeFlags & BCM_FIELD_RANGE_INVERT) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d range table at %d type %s (%d)"
                                      " tries to use modifier flags %08X as"
                                      " part of its type flags\n"),
                           unit,
                           index,
                           _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                           devInfo->ranges[index].qualifier,
                           devInfo->ranges[index].rangeFlags & BCM_FIELD_RANGE_INVERT));
            }
            if (devInfo->ranges[index].rangeBase < 1) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d range table at %d type %s (%d)"
                                      " tries to start range IDs below 1\n"),
                           unit,
                           index,
                           _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                           devInfo->ranges[index].qualifier));
            }
            if (devInfo->ranges[index].count < 1) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d range table at %d type %s (%d)"
                                      " tries to specify fewer than 1 ranges"
                                      " of the type\n"),
                           unit,
                           index,
                           _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                           devInfo->ranges[index].qualifier));
            }
            if (devInfo->ranges[index].count > _BCM_DPP_RANGE_MAX_COUNT) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d range table at %d type %s (%d)"
                                      " specifies %d ranges, but the range"
                                      " module supports max %d of one type\n"),
                           unit,
                           index,
                           _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                           devInfo->ranges[index].qualifier,
                           devInfo->ranges[index].count,
                           _BCM_DPP_RANGE_MAX_COUNT));
            }
            for (offset = 0; offset < index; offset++) {
                if (((devInfo->ranges[index].rangeBase >=
                      devInfo->ranges[offset].rangeBase) &&
                     (devInfo->ranges[index].rangeBase <
                      (devInfo->ranges[offset].rangeBase +
                       devInfo->ranges[offset].count))) ||
                    (((devInfo->ranges[index].rangeBase +
                       devInfo->ranges[index].count) >
                      devInfo->ranges[offset].rangeBase) &&
                     ((devInfo->ranges[index].rangeBase +
                       devInfo->ranges[index].count) <=
                      (devInfo->ranges[offset].rangeBase +
                       devInfo->ranges[offset].count)))) {
                    /*
                     *  Basically, at least one of these conditions is true:
                     *
                     *    The base ID of this range is within the IDs that
                     *    are used by a range already configured
                     *
                     *    The last ID of this range is within the IDs that
                     *    are used by a range already configured
                     *
                     *  Either of these conditions is sufficient to know that
                     *  this range type's ID space overlaps some other range
                     *  type's ID space, and that's just not acceptable.
                     */
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d range table at %d type %s"
                                          " (%d) tries to define range type"
                                          " whose ID space overlaps existing"
                                          " range type %s %d at %d\n"),
                               unit,
                               index,
                               _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                               devInfo->ranges[index].qualifier,
                               _bcm_dpp_field_qual_name[devInfo->ranges[offset].qualifier],
                               devInfo->ranges[offset].qualifier,
                               offset));
                } /* if (range ID space overlaps) */
                if (devInfo->ranges[index].rangeFlags &
                    devInfo->ranges[offset].rangeFlags) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d range table at %d type %s"
                                          " (%d) range flags %08X overlap"
                                          " type %s (%d) at %d\n"),
                               unit,
                               index,
                               _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                               devInfo->ranges[index].qualifier,
                               devInfo->ranges[index].rangeFlags &
                               devInfo->ranges[offset].rangeFlags,
                               _bcm_dpp_field_qual_name[devInfo->ranges[offset].qualifier],
                               devInfo->ranges[offset].qualifier,
                               offset));
                }
            } /* for (offset = 0; offset < index; offset++) */
            BCM_FIELD_QSET_REMOVE(rangeQual, devInfo->ranges[index].qualifier);
        } else { /* if (SHR_BITGET(rangeQual, devInfo->ranges[index].qualifier)) */
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d range map at %d tries to define"
                                  " range type %s (%d) but it is either not a"
                                  " range type in the qualifier table or it"
                                  " has already been defined (earlier in the"
                                  " range table)\n"),
                       unit,
                       index,
                       _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                       devInfo->ranges[index].qualifier));
        } /* if (SHR_BITGET(rangeQual, devInfo->ranges[index].qualifier)) */
    } /* for (range info table) */
    if ((0 > devInfo->ranges[index].qualifier) ||
        (bcmFieldQualifyCount < devInfo->ranges[index].qualifier)) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d range table at %d tries to define"
                              " invalid range qualifier %d\n"),
                   unit,
                   index,
                   devInfo->qualMap[index]));
    }
    for (qual = 0; bcmFieldQualifyCount > qual; qual++) {
        if (BCM_FIELD_QSET_TEST(rangeQual, qual)) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d range table does not include %s"
                                  " (%d), which was indicated to be a range"
                                  " in the qualifier table\n"),
                       unit,
                       _bcm_dpp_field_qual_name[qual],
                       qual));
        } /* if (BCM_FIELD_QSET_TEST(rangeQual, qual) */
    } /* for (qual = 0; bcmFieldQualifyCount > qual; qual++) */

    /* build the stage action bitmaps */
    for (index = 0;
         (BCM_E_NONE == result) &&
         (bcmFieldActionCount > devInfo->actMap[index]);
         /* increment is performed inline */) {
         int32 actMaps_handle ;

        /* consider this map layer */
        action = devInfo->actMap[index];

        if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  update sw-state resources */
            unsigned int actMapCount ;

            /*
             * Was:
             *   tempUnit->actMapCount++;
             */
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.actMapCount.get(unit, &actMapCount)) ;
            actMapCount++ ;
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.actMapCount.set(unit, actMapCount)) ;

            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ACTMAPS.get(unit, action, &actMaps_handle)) ;
            /*
             * Note that a zero handle indicates: not loaded. Otherwise, it is loaded by
             * some meaningful value.
             */
            /* ensure each action is included only once */
            if (actMaps_handle) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d action maps try to set actionr"
                                      " %d (%s) but it was already set\n"),
                           unit,
                           action,
                           _bcm_dpp_field_action_name[action]));
            }
            /* keep track of this action's description */
            /*
             * Was:
             *   tempUnit->actMaps[action] = &(devInfo->actMap[index]);
             */
            SOC_SAND_ACTMAPS_CONVERT_ACTMAPS_INDEX_TO_HANDLE(actMaps_handle,index) ;
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ACTMAPS.set(unit, action, actMaps_handle)) ;
        }
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d scanning action map table at %d,"
                              " %d %s\n"),
                   unit,
                   index,
                   action,
                   _bcm_dpp_field_action_name[action]));
        index++;
        /* ensure all of the maps for this action look reasonable */
        for (stage = 0; stage < devInfo->stages; stage++) {
            /* check each possible map in the chain, build reverse map */
            for (adjust = 0, found = FALSE;
                 adjust < devInfo->actChain;
                 adjust++, index++) {
                /* ensure chain PPD action is valid */
                if ((SOC_PPC_NOF_FP_ACTION_TYPES < devInfo->actMap[index]) ||
                    (0 > devInfo->actMap[index])) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d action map for action %d"
                                          " (%s) stage %u (%s)"
                                          " chain %d tries to set invalid PPD"
                                          " action %d (min 0, max %d)\n"),
                               unit,
                               action,
                               _bcm_dpp_field_action_name[action],
                               stage,
                               devInfo->stage[stage].stageName,
                               adjust,
                               devInfo->actMap[index],
                               SOC_PPC_NOF_FP_QUAL_TYPES + 1));
                }
                /* ensure chains are contiguously populated */
                if ((!found) &&
                    (0 != adjust) &&
                    (_BCM_DPP_FIELD_PPD_ACTION_VALID(devInfo->actMap[index]))) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d action map %d (%s) stage"
                                          " %u (%s) has a gap"
                                          " before chain %d\n"),
                               unit,
                               action,
                               _bcm_dpp_field_action_name[action],
                               stage,
                               devInfo->stage[stage].stageName,
                               adjust));
                }
                if ((BCM_E_NONE == result) &&
                    (_BCM_DPP_FIELD_PPD_ACTION_VALID(devInfo->actMap[index]))) {
                    found = TRUE;
		    if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  update sw-state resources */
                        /* add this action to the unit's capabilities */
                        /*
                         * Was:
                         *   BCM_FIELD_ASET_ADD(tempUnit->unitAset,  action);
                         * which was equivalent to:
                         *   SHR_BITSET((tempUnit->unitAset.w), action)
                         */
                        result = FIELD_ACCESS_UNITASET_W.bit_set(unit,action) ;
                        if (BCM_E_NONE == result) {
                            /* add this action to the stage's aset */
                        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.stgAset.w.bit_set(unit, stage, action));
                        }
                        /* add this action to the type's aset in this stage */
                    }
                } else {
                    found = FALSE;
                }
            } /* for (all chained actions) */
        } /* for (offset = 0; offset < devInfo->mappings; offset++) */
    } /* for (all entries in elements table) */
    if (BCM_FIELD_ENTRY_INVALID == devInfo->actMap[index]) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d action map at %d tries to define"
                              " invalid action %d\n"),
                   unit,
                   index,
                   devInfo->actMap[index]));
    }
    /* init ranges (ranges only apply to ingress FP stage) */
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_range_init(tempUnit);
    }
    /* init preselectors */
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_presel_init(tempUnit);
    }

    
    /* init data qualifiers */
    if (BCM_E_NONE == result) {
        result = _bcm_petra_field_data_qualifier_init(tempUnit);
    }

    if(!SOC_WARM_BOOT(unit)) {
        for (index = 0;
             (index < 2) && (BCM_E_NONE == result);
             index++) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set up egress DP indirection %d\n"), index));
            SOC_PPC_FP_CONTROL_INDEX_clear(&control_ndx);
            SOC_PPC_FP_CONTROL_INFO_clear(&control_info);
            control_ndx.type = SOC_PPC_FP_CONTROL_TYPE_EGRESS_DP;
            control_ndx.val_ndx = index;
            switch (index) {
            case 0: /* green */
                control_info.val[0] = 0;
                break;
            case 1: /* yellow */
                control_info.val[0] = 1;
                break;
            default:
                /* should never see this */
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unexpected DP index %d setting egress DP\n"),
                           index));
                result = BCM_E_INTERNAL;
            }
            if (BCM_E_NONE == result) {
                ppdr = soc_ppd_fp_control_set(tempUnit->unitHandle,
                                              SOC_CORE_INVALID,
                                              &control_ndx,
                                              &control_info,
                                              &success);
                result = handle_sand_result(ppdr);
                if (BCM_E_NONE == result) {
                    result = translate_sand_success_failure(success);
                }
            } /* if (BCM_E_NONE == result) */
        } /* for each of the egress DP settings */
    }/* if !SOC_WARM_BOOT(unit) */
#ifdef BCM_WARM_BOOT_SUPPORT
#if (0)
/* { */
    /*
     * All 'save' and 'sync' of old sw state are dropped.
     */
    if (BCM_E_NONE == result) {
        /*
         *  This function will either set up warm boot support (when in cold
         *  boot mode) or it will load the warm boot data and then scan
         *  hardware to fill in the gaps (when in warm boot mode).
         */
        result = _bcm_dpp_wb_field_state_init(tempUnit);
    }
/* } */
#endif
#endif /* def BCM_WARM_BOOT_SUPPORT */

    if (BCM_E_NONE == result) {
        /* all went well, expose the unit */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d ready\n"), unit));
        _bcm_dpp_field_unit_info[unit] = tempUnit;
        all_went_well = 1 ;
    } else { /* if (BCM_E_NONE == result) */
        /* something went wrong, dispose of resources */
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d init failed: %d (%s)\n"),
                   unit,
                   result,
                   _SHR_ERRMSG(result)));
        if (tempUnit) {
            if (_DPP_FIELD_GET_UNIT_LOCK(tempUnit)) {
                sal_mutex_destroy(_DPP_FIELD_GET_UNIT_LOCK(tempUnit));
            }
            BCM_FREE(tempUnit);
            tempUnit = NULL;
        }
    } /* if (BCM_E_NONE == result) */

    _bcm_dpp_field_group_vt_predefined_group_init(unit);

    _bcm_dpp_field_group_flp_predefined_group_init(unit);


    /* Release the global lock */
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "release global lock\n")));
    if (sal_mutex_give(_bcm_dpp_field_glob_lock)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("unable to release global lock")));
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d) return %d (%s)\n"),
               unit,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);

exit:
    if (!all_went_well)
    {
        /*
         * If some initializations failed, do not expose this unit.
         */
        _bcm_dpp_field_unit_info[unit] = NULL ;
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_detach
 *   Purpose
 *      Shut down the field APIs.
 *   Parameters
 *      (in) int unit = the unit number
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_detach(int unit)
{
    int result;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d)\n"), unit));

    BCM_DPP_UNIT_CHECK(unit);

    /* check the global lock */
    if (!_bcm_dpp_field_glob_lock) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INIT,
                         (_BSL_BCM_MSG("no Soc_petra field units initialized")));
    }
    if (sal_mutex_take(_bcm_dpp_field_glob_lock, sal_mutex_FOREVER)) {
        /* unable to take the global lock */
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("unable to take Soc_petra field global lock")));
    }
    if (!(_bcm_dpp_field_unit_info[unit])) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INIT,
                         (_BSL_BCM_MSG("not initialised")));
    }

    /* detach unit */
    result = _bcm_dpp_field_detach(unit);

    if (sal_mutex_give(_bcm_dpp_field_glob_lock)) {
        /* unable to release the global lock */
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("unable to release Soc_petra field"
                                   " global lock")));
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d) = %d (%s)\n"),
               unit,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

#ifdef BROADCOM_DEBUG
/*
 *   Function
 *      bcm_petra_field_show
 *   Purpose
 *      Dump all field information for the unit
 *   Parameters
 *      (in) int unit = the unit number
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_show(int unit,
                     const char *pfx)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*) enter\n"), unit));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_unit_dump(unitData,
                                      pfx?pfx:"",
                                      TRUE,
                                      TRUE,
                                      TRUE);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*) return %d (%s)\n"),
               unit,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}
#endif /* def BROADCOM_DEBUG */

#ifdef BROADCOM_DEBUG
/*
 *   Function
 *      bcm_petra_field_entry_dump
 *   Purpose
 *      Dump information about the specified entry to debug output
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_entry_dump(int unit,
                           bcm_field_entry_t entry)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, entry));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        result = _bcm_dpp_field_tcam_entry_dump(unitData,
                                                _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                "");
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                entry))  {
        result = _bcm_dpp_field_dir_ext_entry_dump(unitData,
                                                   entry -
                                                   _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt),
                                                   "");
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),  unit,  entry));
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}
#endif /* def BROADCOM_DEBUG */

#ifdef BROADCOM_DEBUG
/*
 *   Function
 *      bcm_petra_field_group_dump
 *   Purpose
 *      Dump information about the specified group to debug output
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = the group ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_dump(int unit,
                           bcm_field_group_t group)
{
    _bcm_dpp_field_grp_idx_t groupLimit;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_group_dump(unitData, group, "", TRUE);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}
#endif /* def BROADCOM_DEBUG */

/*
 * Function:
 *      bcm_petra_field_group_traverse
 * Purpose:
 *      Traverse all the fp groups in the system, calling a specified
 *      callback for each one
 * Parameters:
 *      unit - (IN) Unit number.
 *      callback - (IN) A pointer to the callback function to call for each fp group
 *      user_data - (IN) Pointer to user data to supply in the callback
 * Returns:
 *      BCM_E_xxx
 * Notes:
 *      There probably should be an entry traverse...?
 */
int
bcm_petra_field_group_traverse(int unit,
                               bcm_field_group_traverse_cb callback,
                               void *user_data)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_stage_idx_t stage;
    _bcm_dpp_field_grp_idx_t group;
    _bcm_dpp_field_grp_idx_t next;
    _bcm_dpp_field_grp_idx_t groupLimit;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,*) enter\n"), unit));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!callback) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory pointer argument is NULL")));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    for (stage = 0; stage < unitData->devInfo->stages; stage++) {
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupHead.get(unit, stage, &next));
        while ((BCM_E_NONE == result) &&
               (next < groupLimit)) {
            group = next;
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.get(unit, group, &next));
            result = (*callback)(unit, group, user_data);
            if (BCM_E_NONE != result) {
                LOG_WARN(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "exiting unit %d group traverse because"
                                     " callback function returned %d (%s)\n"),
                          unit,
                          result,
                          _SHR_ERRMSG(result)));
            }
        } /* while (no error and not to end of stage group list) */
    } /* for (stage = 0; stage < unitData->devInfo->stages; stage++) */

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,*) return %d (%s)\n"),
               unit,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_create
 *   Purpose
 *      Create a new group that has the specified qualifier set and priority.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (out) _field_group_index *group = where to put the group ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 */
int
bcm_petra_field_group_create(int unit,
                             bcm_field_qset_t qset,
                             int pri,
                             bcm_field_group_t *group)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_grp_idx_t next;
    _bcm_dpp_field_grp_idx_t groupLimit;
    _bcm_dpp_field_grp_idx_t groupFree;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,*) enter\n"), unit, pri));

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!group) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out arg must not be NULL")));
    }
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupFree.get(unit, &groupFree));
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    /* just grab the next free one */
    /*
     * Was:
     *   next = unitData->groupFree;
     */
    next = groupFree ;

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if (next < groupLimit) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d next free group is %d\n"),
                   unit,
                   next));
        result = _bcm_dpp_field_group_create_mode_id(unitData,
                                                     next,
                                                     &qset,
                                                     pri,
                                                     0, /* group_config_flags */
                                                     bcmFieldGroupModeAuto,
                                                     0);
        if (BCM_E_NONE == result) {
            *group = next;
        }
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "no available groups on unit %d\n"), unit));
        result = BCM_E_FULL;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,&(%d)) return %d (%s)\n"),
               unit,
               pri,
               *group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_create_id
 *   Purpose
 *      Create a new group with the specified ID that has the specified
 *      qualifier set and priority.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 */
int
bcm_petra_field_group_create_id(int unit,
                                bcm_field_qset_t qset,
                                int pri,
                                bcm_field_group_t group)
{
    _bcm_dpp_field_grp_idx_t groupLimit;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,%d) enter\n"), unit, pri, group));

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_group_create_mode_id(unitData,
                                                 group,
                                                 &qset,
                                                 pri,
                                                 0, /* group_config_flags */
                                                 bcmFieldGroupModeAuto,
                                                 0);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,%d) return %d (%s)\n"),
               unit,
               pri,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_create_mode
 *   Purpose
 *      Create a new group spanning the specified width, that has the specified
 *      qualifier set and priority.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_mode_t mode = the mode (width) of the group
 *      (out) bcm_field_group_t *group = where to put the group ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 */
int
bcm_petra_field_group_create_mode(int unit,
                                  bcm_field_qset_t qset,
                                  int pri,
                                  bcm_field_group_mode_t mode,
                                  bcm_field_group_t *group)
{
    _bcm_dpp_field_grp_idx_t next;
    _bcm_dpp_field_grp_idx_t groupLimit;
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_grp_idx_t groupFree;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,%s,*) enter\n"),
               unit,
               pri,
               ((0 <= mode) && (bcmFieldGroupModeCount > mode))?_bcm_dpp_field_group_mode_name[mode]:"unknown"));

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!group) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out arg must not be NULL")));
    }
    result = FIELD_ACCESS.groupFree.get(unit, &groupFree) ;
    BCMDNX_IF_ERR_EXIT(result);
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    /* just grab the next free one */
    /*
     * Was:
     *   next = unitData->groupFree;
     */
    next = groupFree ;

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if (next < groupLimit) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d next free group is %d\n"),
                   unit,
                   next));
        result = _bcm_dpp_field_group_create_mode_id(unitData,
                                                     next,
                                                     &qset,
                                                     pri,
                                                     0, /* group_config_flags */
                                                     mode,
                                                     0);
        if (BCM_E_NONE == result) {
            *group = next;
        }
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "no available groups on unit %d\n"), unit));
        result = BCM_E_FULL;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,%s,&(%d)) return %d (%s)\n"),
               unit,
               pri,
               ((0 <= mode) && (bcmFieldGroupModeCount > mode))?_bcm_dpp_field_group_mode_name[mode]:"unknown",
               *group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_create_mode_id
 *   Purpose
 *      Create a new group using the specified ID, spanning the specified
 *      width, that has the specified qualifier set and priority.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_mode_t mode = the mode (width) of the group
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 */
int
bcm_petra_field_group_create_mode_id(int unit,
                                     bcm_field_qset_t qset,
                                     int pri,
                                     bcm_field_group_mode_t mode,
                                     bcm_field_group_t group)
{
    _bcm_dpp_field_grp_idx_t groupLimit;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,%s,%d) enter\n"),
               unit,
               pri,
               ((0 <= mode) && (bcmFieldGroupModeCount > mode))?_bcm_dpp_field_group_mode_name[mode]:"unknown",
               group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_group_create_mode_id(unitData,
                                                 group,
                                                 &qset,
                                                 pri,
                                                 0, /* group_config_flags */
                                                 mode,
                                                 0);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,%s,%d) return %d (%s)\n"),
               unit,
               pri,
               ((0 <= mode) && (bcmFieldGroupModeCount > mode))?_bcm_dpp_field_group_mode_name[mode]:"unknown",
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 *   Function
 *      bcm_petra_field_group_config_with_ce_id_verify
 *   Purpose
 *      Validate input parameters for field group created with BCM_FIELD_GROUP_CREATE_WITH_CE_ID flag
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (in) bcm_field_group_config_extension_t *group_config = the config info for the given field group
 *      (in) bcm_field_group_mode_t mode = the mode (width) of the group
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_config_with_ce_id_verify(int unit, bcm_field_group_t group,
        bcm_field_group_config_extension_t *group_config, bcm_field_group_mode_t mode)
{

    BCMDNX_INIT_FUNC_DEFS;

    /* The WITH_CE_ID flag should always combined with ADVANCED_MODE soc properties */
    if(!(soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE)))
    {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "Group %d: The BCM_FIELD_GROUP_CREATE_WITH_CE_ID flag should always combined with ADVANCED_MODE management soc property\n"),
                          group));
        BCMDNX_IF_ERR_EXIT (BCM_E_PARAM);
    }
    /* The WITH_CE_ID flag should always combined with WITH_CYCLE flags. Verify that. */
    if (!(group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_CYCLE))
    {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "Group %d: The BCM_FIELD_GROUP_CREATE_WITH_CE_ID flag should always combined with BCM_FIELD_GROUP_CREATE_WITH_CYCLE flag\n"),
                          group));
        BCMDNX_IF_ERR_EXIT (BCM_E_PARAM);
    }
    /* The WITH_CE_ID flag should always combined with WITH_MODE flags. Verify that. */
    if (!(group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_MODE))
    {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "Group %d: The BCM_FIELD_GROUP_CREATE_WITH_CE_ID flag should always combined with BCM_FIELD_GROUP_CREATE_WITH_MODE flag\n"),
                          group));
        BCMDNX_IF_ERR_EXIT (BCM_E_PARAM);
    }
    /* Allowed are ONLY TCAM field groups, with key size 90/16/320 (half/single/double). */
    if ((mode != bcmFieldGroupModeSingle) &&
            (mode != bcmFieldGroupModeDouble) &&
            (mode != bcmFieldGroupModeTriple) &&
            (mode != bcmFieldGroupModeQuad))
    {
        const static char *modes[] = BCM_FIELD_GROUP_MODE_STRINGS;

        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                          "Group %d: The allowed values for group mode are : bcmFieldGroupModeSingle, bcmFieldGroupModeDouble, bcmFieldGroupModeTriple, bcmFieldGroupModeQuad. Received group mode is %s\n"),
                          group, modes[mode]));
        BCMDNX_IF_ERR_EXIT (BCM_E_PARAM);
    }

    /* The WITH_CE_ID group is allowed only on Ingress stage. Verify that. */
    if (!(BCM_FIELD_QSET_TEST(group_config->qset,bcmFieldQualifyStageIngress)))
    {
        LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                              "Group %d: The allowed stage for group is : bcmFieldQualifyStageIngress\n"),
                              group));
        BCMDNX_IF_ERR_EXIT (BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;


}
/*
 *   Function
 *      bcm_petra_field_group_config_create
 *   Purpose
 *      Create a new group using a configuration structure to specify the
 *      parameters for the group.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in/out) bcm_field_group_config_t = pointer to group config info
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 */
int
bcm_petra_field_group_config_create(int unit,
                                    bcm_field_group_config_t *group_config)
{
    _DPP_FIELD_COMMON_LOCALS;
    bcm_field_group_t group;
    bcm_field_group_mode_t mode;
    _bcm_dpp_field_grp_idx_t groupLimit;
    bcm_field_aset_t stgAset;
    int destroy = FALSE;
    _bcm_dpp_field_grp_idx_t groupFree;
    uint32 groupFlags; 
    int dpp_field_unit_lock_was_taken = 0;
    int i;
    uint32 pgm_bmp;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*) enter\n"),
               unit));
    if (!group_config) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory IN/OUT argument must not"
                                   " be NULL")));
    }
    result = FIELD_ACCESS.groupFree.get(unit, &groupFree) ;
    BCMDNX_IF_ERR_EXIT(result);
    if (group_config->flags & (~(BCM_FIELD_GROUP_CREATE_WITH_ID |
                                 BCM_FIELD_GROUP_CREATE_WITH_MODE |
                                 BCM_FIELD_GROUP_CREATE_WITH_PRESELSET |
                                 BCM_FIELD_GROUP_CREATE_WITH_ASET |
                                 BCM_FIELD_GROUP_CREATE_SMALL |
                                 BCM_FIELD_GROUP_CREATE_LARGE |
                                 BCM_FIELD_GROUP_CREATE_INSERTION_ORDER_LOOSE |
                                 BCM_FIELD_GROUP_CREATE_SPARSE_ENTRY_PRIORITIES | 
                                 BCM_FIELD_GROUP_CREATE_IS_EQUAL | 
                                 BCM_FIELD_GROUP_CREATE_SINGLE | 
                                 BCM_FIELD_GROUP_CREATE_HANDLE_ENTRIES_BY_KEY |
                                 BCM_FIELD_GROUP_CREATE_WITH_CYCLE |
                                 BCM_FIELD_GROUP_CREATE_WITH_PROGRAMS |
                                 BCM_FIELD_GROUP_CREATE_WITH_CE_ID))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,
                         (_BSL_BCM_MSG("unsupported flags %08X specified\n"),
                          group_config->flags &
                          (~(BCM_FIELD_GROUP_CREATE_WITH_ID |
                             BCM_FIELD_GROUP_CREATE_WITH_MODE |
                             BCM_FIELD_GROUP_CREATE_WITH_PRESELSET |
                             BCM_FIELD_GROUP_CREATE_WITH_ASET |
                             BCM_FIELD_GROUP_CREATE_SMALL |
                             BCM_FIELD_GROUP_CREATE_LARGE |
                             BCM_FIELD_GROUP_CREATE_INSERTION_ORDER_LOOSE |
                             BCM_FIELD_GROUP_CREATE_SPARSE_ENTRY_PRIORITIES | 
                             BCM_FIELD_GROUP_CREATE_IS_EQUAL | 
                             BCM_FIELD_GROUP_CREATE_SINGLE | 
                             BCM_FIELD_GROUP_CREATE_HANDLE_ENTRIES_BY_KEY |
                             BCM_FIELD_GROUP_CREATE_WITH_CYCLE |
                             BCM_FIELD_GROUP_CREATE_WITH_PROGRAMS |
                             BCM_FIELD_GROUP_CREATE_WITH_CE_ID))));
    }
    if (!SOC_IS_ARADPLUS(unit) && 
        (group_config->flags & BCM_FIELD_GROUP_CREATE_IS_EQUAL)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,
                         (_BSL_BCM_MSG("unsupported flags %08X specified\n"),
                          group_config->flags & BCM_FIELD_GROUP_CREATE_IS_EQUAL));
    }


    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;


    
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_ID) {
        group = group_config->group;

        if ((0 > group) || (groupLimit <= group)) {
            result = BCM_E_NOT_FOUND;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d group %d is not valid\n"),
                       unit,
                       group));
        }
    } else { 
        group = groupFree ;
        if (group < groupLimit) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d next free group is %d\n"),
                       unit,
                       group));
        } else {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "no available groups on unit %d\n"), unit));
            result = BCM_E_FULL;
        }
    }
    if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_MODE) {
        /* this value will be checked by the group create function */
        mode = group_config->mode;
    } else {
        /* let the group create function decide (use auto mode) */
        mode = bcmFieldGroupModeAuto;
    }
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_group_create_mode_id(unitData,
                                                     group,
                                                     &(group_config->qset),
                                                     group_config->priority,
                                                     group_config->flags,
                                                     mode,
                                                     group_config->max_entry_priorities);
        if (BCM_E_NONE == result) {
            destroy = TRUE;
            result = FIELD_ACCESS.groupD.share_id.set(unit, group, group_config->share_id);
        }
    }

    /* if field group was created with program ID set a flag */
    if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_PROGRAMS) {
        pgm_bmp = group_config->pgm_bmp;

        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
        groupFlags |= _BCM_DPP_FIELD_GROUP_WITH_PROGRAM_ID;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupFlags));

    } else {
        pgm_bmp = 0;
    }
    if ((BCM_E_NONE == result) &&
        (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_PRESELSET)) {

        result = _bcm_dpp_field_group_presel_set(unitData,
                                                 group,
                                                 &(group_config->preselset),
                                                 pgm_bmp);

    }

    if ((BCM_E_NONE == result) &&
        (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_CYCLE)) {

        if (group_config->cycle >= bcmFieldGroupCycleCount) {
            result = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d cycle %d is not valid\n"),
                       unit, group_config->cycle));
        }

        if (BCM_E_NONE == result) {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
            groupFlags |= _BCM_DPP_FIELD_GROUP_WITH_CYCLE;
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupFlags));

            result = FIELD_ACCESS.groupD.groupCycle.set(unit, group, group_config->cycle);
        }
    }

    if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_CE_ID) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                (_BSL_BCM_MSG("Flag only supported in API bcm_field_group_config_extension_create()\n")));
    }

    if (BCM_E_NONE == result) {
        FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags); 

        if (group_config->flags & BCM_FIELD_GROUP_CREATE_LARGE) {
            groupFlags |= _BCM_DPP_FIELD_GROUP_LARGE;
        }

        
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupFlags));

        if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_ASET) {
            result = _bcm_dpp_field_group_action_set(unitData,
                                                     group,
                                                     &(group_config->aset),
                                                     pgm_bmp);
        }
        else if (groupFlags & _BCM_DPP_FIELD_GROUP_WITH_PRESEL) {
            /* use the Egress stage ASET */
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.stgAset.get(unit, _BCM_DPP_FIELD_STAGE_INDEX_EGRESS, &stgAset ));
            result = _bcm_dpp_field_group_action_set(unitData,
                                                     group,
                                                     &stgAset,
                                                     pgm_bmp);
/* Required????
 * BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.stgAset.set(unit, _BCM_DPP_FIELD_STAGE_INDEX_EGRESS, stgAset );*/
        }
    }


    if (BCM_E_NONE == result) {
        group_config->group = group;        

        /* Map between id and name*/
        for (i=0; i<BCM_FIELD_MAX_NAME_LEN; ++i ) {
            result = FIELD_ACCESS.groupConfigNames.set(unit, group_config->group, i,  (group_config->name[i])); 
            if ((result != BCM_E_NONE)) break;
        }
    }

    if (!(BCM_E_NONE == result) && destroy) {
        /* something created but an error occurred afterward */
        destroy = _bcm_dpp_field_group_destroy(unitData, group);
        if (BCM_E_NONE != destroy) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d unable to remove group %d after"
                                  " error %d (%s), group is partially"
                                  "constructed: %d (%s)\n"),
                       unit,
                       group,
                       result,
                       _SHR_ERRMSG(result),
                       destroy,
                       _SHR_ERRMSG(destroy)));
        }
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*) return %d (%s)\n"),
               unit,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 *   Function
 *      bcm_petra_field_group_config_create
 *   Purpose
 *      Create a new group using a configuration structure to specify the
 *      parameters for the group.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in/out) bcm_field_group_config_t = pointer to group config info
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 */
int
bcm_petra_field_group_config_extension_create(int unit,
                                    bcm_field_group_config_extension_t *group_config)
{
    _DPP_FIELD_COMMON_LOCALS;
    bcm_field_group_t group;
    bcm_field_group_mode_t mode;
    _bcm_dpp_field_grp_idx_t groupLimit;
    bcm_field_aset_t stgAset;
    int destroy = FALSE;
    _bcm_dpp_field_grp_idx_t groupFree;
    uint32 groupFlags;
    int dpp_field_unit_lock_was_taken = 0;
    int i;
    uint32 pgm_bmp;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*) enter\n"),
               unit));
    if (!group_config) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory IN/OUT argument must not"
                                   " be NULL")));
    }
    result = FIELD_ACCESS.groupFree.get(unit, &groupFree) ;
    BCMDNX_IF_ERR_EXIT(result);
    if (group_config->flags & (~(BCM_FIELD_GROUP_CREATE_WITH_ID |
                                 BCM_FIELD_GROUP_CREATE_WITH_MODE |
                                 BCM_FIELD_GROUP_CREATE_WITH_PRESELSET |
                                 BCM_FIELD_GROUP_CREATE_WITH_ASET |
                                 BCM_FIELD_GROUP_CREATE_SMALL |
                                 BCM_FIELD_GROUP_CREATE_LARGE |
                                 BCM_FIELD_GROUP_CREATE_INSERTION_ORDER_LOOSE |
                                 BCM_FIELD_GROUP_CREATE_SPARSE_ENTRY_PRIORITIES |
                                 BCM_FIELD_GROUP_CREATE_IS_EQUAL |
                                 BCM_FIELD_GROUP_CREATE_SINGLE |
                                 BCM_FIELD_GROUP_CREATE_HANDLE_ENTRIES_BY_KEY |
                                 BCM_FIELD_GROUP_CREATE_WITH_CYCLE |
                                 BCM_FIELD_GROUP_CREATE_WITH_PROGRAMS |
                                 BCM_FIELD_GROUP_CREATE_WITH_CE_ID))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,
                         (_BSL_BCM_MSG("unsupported flags %08X specified\n"),
                          group_config->flags &
                          (~(BCM_FIELD_GROUP_CREATE_WITH_ID |
                             BCM_FIELD_GROUP_CREATE_WITH_MODE |
                             BCM_FIELD_GROUP_CREATE_WITH_PRESELSET |
                             BCM_FIELD_GROUP_CREATE_WITH_ASET |
                             BCM_FIELD_GROUP_CREATE_SMALL |
                             BCM_FIELD_GROUP_CREATE_LARGE |
                             BCM_FIELD_GROUP_CREATE_INSERTION_ORDER_LOOSE |
                             BCM_FIELD_GROUP_CREATE_SPARSE_ENTRY_PRIORITIES |
                             BCM_FIELD_GROUP_CREATE_IS_EQUAL |
                             BCM_FIELD_GROUP_CREATE_SINGLE |
                             BCM_FIELD_GROUP_CREATE_HANDLE_ENTRIES_BY_KEY |
                             BCM_FIELD_GROUP_CREATE_WITH_CYCLE |
                             BCM_FIELD_GROUP_CREATE_WITH_PROGRAMS |
                             BCM_FIELD_GROUP_CREATE_WITH_CE_ID))));
    }
    if (!SOC_IS_ARADPLUS(unit) &&
        (group_config->flags & BCM_FIELD_GROUP_CREATE_IS_EQUAL)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,
                         (_BSL_BCM_MSG("unsupported flags %08X specified\n"),
                          group_config->flags & BCM_FIELD_GROUP_CREATE_IS_EQUAL));
    }


    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;



    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_ID) {
        group = group_config->group;

        if ((0 > group) || (groupLimit <= group)) {
            result = BCM_E_NOT_FOUND;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d group %d is not valid\n"),
                       unit,
                       group));
        }
    } else {
        group = groupFree ;
        if (group < groupLimit) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d next free group is %d\n"),
                       unit,
                       group));
        } else {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "no available groups on unit %d\n"), unit));
            result = BCM_E_FULL;
        }
    }
    if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_MODE) {
        /* this value will be checked by the group create function */
        mode = group_config->mode;
    } else {
        /* let the group create function decide (use auto mode) */
        mode = bcmFieldGroupModeAuto;
    }
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_group_create_mode_id(unitData,
                                                     group,
                                                     &(group_config->qset),
                                                     group_config->priority,
                                                     group_config->flags,
                                                     mode,
                                                     group_config->max_entry_priorities);
        if (BCM_E_NONE == result) {
            destroy = TRUE;
            result = FIELD_ACCESS.groupD.share_id.set(unit, group, group_config->share_id);
        }
    }

    /* if field group was created with program ID set a flag */
    if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_PROGRAMS) {
        pgm_bmp = group_config->pgm_bmp;

        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
        groupFlags |= _BCM_DPP_FIELD_GROUP_WITH_PROGRAM_ID;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupFlags));

    } else {
        pgm_bmp = 0;
    }
    if ((BCM_E_NONE == result) &&
        (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_PRESELSET)) {

        result = _bcm_dpp_field_group_presel_set(unitData,
                                                 group,
                                                 &(group_config->preselset),
                                                 pgm_bmp);

    }

    if ((BCM_E_NONE == result) &&
        (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_CYCLE)) {

        if (group_config->cycle >= bcmFieldGroupCycleCount) {
            result = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d cycle %d is not valid\n"),
                       unit, group_config->cycle));
        }

        if (BCM_E_NONE == result) {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
            groupFlags |= _BCM_DPP_FIELD_GROUP_WITH_CYCLE;
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupFlags));

            result = FIELD_ACCESS.groupD.groupCycle.set(unit, group, group_config->cycle);
        }
    }

    if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_CE_ID) {
        bcm_field_presel_t presel_id;

        result = bcm_petra_field_group_config_with_ce_id_verify(unit, group, group_config, mode);
        BCMDNX_IF_ERR_EXIT (result);

        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
        groupFlags |= _BCM_DPP_FIELD_GROUP_WITH_CE_ID;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupFlags));

        for(presel_id = 0; (presel_id < BCM_FIELD_NOF_PRESEL_PER_FG) && (presel_id < group_config->nof_presel_info); presel_id++)
        {
            if (group_config->presel_info[presel_id].presel_id != BCM_FIELD_ENTRY_INVALID)
            {
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupHwInfo.presel_info.set(unit, group, group_config->presel_info[presel_id].presel_id, &group_config->presel_info[presel_id]));
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "set  unit %d group %d is group_config->qual_info[%d].presel_id %d\n"),
                           unit,
                           group,
                           presel_id,
                           group_config->presel_info[presel_id].presel_id));

            }
        }
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupHwInfo.nof_presel_info.set(unit, group, group_config->nof_presel_info));
    }

    if (BCM_E_NONE == result) {
        FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags);

        if (group_config->flags & BCM_FIELD_GROUP_CREATE_LARGE) {
            groupFlags |= _BCM_DPP_FIELD_GROUP_LARGE;
        }


        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupFlags));

        if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_ASET) {
            result = _bcm_dpp_field_group_action_set(unitData,
                                                     group,
                                                     &(group_config->aset),
                                                     pgm_bmp);
        }
        else if (groupFlags & _BCM_DPP_FIELD_GROUP_WITH_PRESEL) {
            /* use the Egress stage ASET */
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.stgAset.get(unit, _BCM_DPP_FIELD_STAGE_INDEX_EGRESS, &stgAset ));
            result = _bcm_dpp_field_group_action_set(unitData,
                                                     group,
                                                     &stgAset,
                                                     pgm_bmp);
        }
    }


    if (BCM_E_NONE == result) {
        group_config->group = group;

        /* Map between id and name*/
        for (i=0; i<BCM_FIELD_MAX_NAME_LEN; ++i ) {
            result = FIELD_ACCESS.groupConfigNames.set(unit, group_config->group, i,  (group_config->name[i]));
            if ((result != BCM_E_NONE)) break;
        }
    }

    if (!(BCM_E_NONE == result) && destroy) {
        /* something created but an error occurred afterward */
        destroy = _bcm_dpp_field_group_destroy(unitData, group);
        if (BCM_E_NONE != destroy) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d unable to remove group %d after"
                                  " error %d (%s), group is partially"
                                  "constructed: %d (%s)\n"),
                       unit,
                       group,
                       result,
                       _SHR_ERRMSG(result),
                       destroy,
                       _SHR_ERRMSG(destroy)));
        }
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*) return %d (%s)\n"),
               unit,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}
/*
 *   Function
 *      bcm_petra_field_group_action_set
 *   Purpose
 *      Associate a set of actions with a group, to establish which actions can
 *      be used by entries in that group.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (in) bcm_field_aset_t aset = action set to associate with group
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      It is only after this is done that we can create a group in PPD.
 *
 *      Since the group would have to be destroyed and recreated if this
 *      changes, we only support changing it on empty groups (no entries).
 *
 *      If the group is in hardware, this will destroy and recreate the group.
 *      If the group is not in hardware, this will try to create the group.
 */
int
bcm_petra_field_group_action_set(int unit,
                                 bcm_field_group_t group,
                                 bcm_field_aset_t aset)
{
    _bcm_dpp_field_grp_idx_t groupLimit;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) enter\n"), unit, group));

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_group_action_set(unitData, group, &aset,0);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_action_get
 *   Purpose
 *      Get the set of actions associated with a group.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (out) bcm_field_aset_t *aset = where to put the group's aset
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_action_get(int unit,
                                 bcm_field_group_t group,
                                 bcm_field_aset_t *aset)
{
    _bcm_dpp_field_grp_idx_t groupLimit;
    uint32 groupFlags;  
    _DPP_FIELD_COMMON_LOCALS;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags);
    if (groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.aset.get(unit, group, aset));
        result = BCM_E_NONE;
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_install
 *   Purpose
 *      Insert all of a group's entries from the hardware.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      This inserts and updates all of the groups entries to the hardware as
 *      appropriate.  No error is asserted for entries already in hardware,
 *      even if the entire group is already in hardware.
 */
int
bcm_petra_field_group_install(int unit,
                              bcm_field_group_t group)
{
    _bcm_dpp_field_grp_idx_t groupLimit;
    uint32 groupD_groupFlags;
    _DPP_FIELD_COMMON_LOCALS;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    if (_BCM_DPP_FIELD_ENT_IS_KAPS_ADVANCED_MODE(unit, group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG("This API is not supportd by large direct lookup advanced mode.")));
    }

    result = _bcm_dpp_field_group_all_hw_set(unitData, group, TRUE);
    if (BCM_E_NONE == result) {
        /* the group no longer has changed entries (all committed now) */
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupD_groupFlags));
        groupD_groupFlags &= (~_BCM_DPP_FIELD_GROUP_CHG_ENT);
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.set(unit, group, groupD_groupFlags));
#ifdef BCM_WARM_BOOT_SUPPORT
        /*_bcm_dpp_field_group_wb_save(unitData, group, NULL, NULL);*/
#endif /* def BCM_WARM_BOOT_SUPPORT */
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_remove
 *   Purpose
 *      Remove all of a group's entries from the hardware, but do not remove
 *      the entries from the software table.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      This removes the group's entries from the hardware, marking them so,
 *      and commits the changes to the hardware.
 */
int
bcm_petra_field_group_remove(int unit,
                             bcm_field_group_t group)
{
    _bcm_dpp_field_grp_idx_t groupLimit;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"), unit, group));

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_group_all_hw_set(unitData, group, FALSE);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_flush
 *   Purpose
 *      Remove all of a group's entries from the hardware, remove the group
 *      from the hardware, remove the group's entries from the software, and
 *      remove the group from the software.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      This will destroy the field group and all its entries.  No mention is
 *      made that it affects ranges, so they aren't destroyed.  This also
 *      destroys the field group and its entries in hardware.
 */
int
bcm_petra_field_group_flush(int unit,
                            bcm_field_group_t group)
{
    _bcm_dpp_field_grp_idx_t groupLimit;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_group_destroy(unitData, group);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_set
 *   Purpose
 *      This changes the group's qualifier set so it is the specified set.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (in) bcm_field_qset_t qset = new qset
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      For Dune device, if there are any entries, this will result in an
 *      error.  It can only be called as long as there are no entries.
 *
 *      If the group has been set up in hardware, this will destroy the group,
 *      and then create a new instance of it.  Since there are no entries, this
 *      does not result in any effect for traffic flow.  If the group is not
 *      yet in hardware this merely edits the group.
 */
int
bcm_petra_field_group_set(int unit,
                          bcm_field_group_t group,
                          bcm_field_qset_t qset)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_grp_idx_t groupLimit;
    _bcm_dpp_field_group_t newGroupData;
    _bcm_dpp_field_group_t groupData;
    unsigned int index;
    unsigned int apiWidth;
    unsigned int hwWidth;
    int dpp_field_unit_lock_was_taken ;
    unsigned int dataFieldRefs;
    _bcm_dpp_field_dq_idx_t dqLimit;
    uint8 qset_res;
    BCMDNX_INIT_FUNC_DEFS;

    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, group));

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1 ;

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.get(unit, group, &groupData));

    if (groupData.groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,(_BSL_BCM_MSG_NO_UNIT("unit %d group %d unavailable for groups that hanles entries by key "),unit,group));
    }
    if (groupData.groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        /* build a new group descriptor */
        sal_memcpy(&newGroupData, &groupData, sizeof(newGroupData));
        result = _bcm_dpp_field_group_verify_qset(unitData,
                                                  group,
                                                  qset,
                                                  (groupData.groupFlags & _BCM_DPP_FIELD_GROUP_AUTO_SZ)?bcmFieldGroupModeAuto:groupData.grpMode,
                                                  &(newGroupData.qset),
                                                  &(newGroupData.groupFlags),
                                                  &(newGroupData.stage),
                                                  &(newGroupData.groupTypes),
                                                  &(newGroupData.predefKey),
                                                  &apiWidth,
                                                  &hwWidth,
                                                  &(newGroupData.pqset));
        if (newGroupData.groupFlags & (~_BCM_DPP_FIELD_GROUP_TINFO)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d unexpected flags %08X set while"
                                  " verifying new group %d configuration\n"),
                       unit,
                       newGroupData.groupFlags & (~_BCM_DPP_FIELD_GROUP_TINFO),
                       group));
            result = BCM_E_INTERNAL;
        }
        if ((BCM_E_NONE == result) &&
            (groupData.groupFlags & _BCM_DPP_FIELD_GROUP_IN_HW)) {
            /*
             *  A change in stage or type may have occurred, since these can
             *  change according to the group's QSET.  We need to make sure the
             *  group's ASET is still valid and can be used with the updated
             *  stage and type.  Note we use the *original* ASET, not the
             *  computed one, since the computed one may contain actions
             *  implied by the actions in the original stage/type, and we do
             *  not want action creep to expand the ASET unexpectedly.
             */

            result = _bcm_dpp_field_group_verify_aset(unitData,
                                                      newGroupData.stage,
                                                      &(newGroupData.oaset));

            result = _bcm_dpp_field_group_copy_aset(unitData,
                                                      group,
                                                      newGroupData.stage,
                                                      &(newGroupData.oaset),
                                                      &(newGroupData.aset),
                                                      &(newGroupData.paset));
        } /* if (no error and group is in hardware) */
        if (BCM_E_NONE == result) {
            /* get new mode if applicable */
            _bcm_dpp_field_group_mode_from_size(unit,
                                                groupData.groupFlags,
                                                groupData.stage,
                                                hwWidth,
                                                &(newGroupData.grpMode));
            if (groupData.groupFlags & _BCM_DPP_FIELD_GROUP_IN_HW) {
                /* it was in hardware, so update hardware */
                result = _bcm_dpp_field_group_hardware_install(unitData,
                                                               group,
                                                               &newGroupData);
            }
        }
        if (BCM_E_NONE == result) {
            /* update refcounts for programmable fields */
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.dqLimit.get(unit, &dqLimit));
            for (index = 0; index < dqLimit; index++) {
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.dataFieldRefs.get(unit, index, &dataFieldRefs));
                if (SHR_BITGET(newGroupData.qset.udf_map, index)) {
                    dataFieldRefs++;
                }
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.qset.udf_map.bit_get(unit, group, index, &qset_res));
                if (qset_res) {
                    dataFieldRefs--;
                }
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.dataFieldRefs.set(unit, index, dataFieldRefs));
            }
            /* update the group information */
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.set(unit, group, &newGroupData));
#ifdef BCM_WARM_BOOT_SUPPORT
#if (0)
/* { */
    /*
     * All 'save' and 'sync' of old sw state are dropped.
     */
            _bcm_dpp_field_datafield_all_wb_save(unitData, NULL, NULL);
            /*_bcm_dpp_field_group_wb_save(unitData, group, NULL, NULL);*/
/* } */
#endif
#endif /* def BCM_WARM_BOOT_SUPPORT */
        }
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken)
    {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_get
 *   Purpose
 *      Gets the group's qualifier set.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (out) bcm_field_qset_t *qset = where to put the current qset
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_get(int unit,
                          bcm_field_group_t group,
                          bcm_field_qset_t *qset)
{
    _bcm_dpp_field_grp_idx_t groupLimit;
    uint32 groupD_groupFlags;
    _DPP_FIELD_COMMON_LOCALS;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!qset) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("Obligatory out argument is NULL")));
    }

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupD_groupFlags));
    if (groupD_groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.qset.get(unit, group, qset));
    } else {
        LOG_VERBOSE(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_NOT_E_NOT_FOUND_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_destroy
 *   Purpose
 *      Destroys a group.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      There must be no entries in this group when calling this function.
 */
int
bcm_petra_field_group_destroy(int unit,
                              bcm_field_group_t group)
{
    _bcm_dpp_field_grp_idx_t groupLimit;
    uint32 groupD_groupFlags;
    _bcm_dpp_field_ent_idx_t groupD_entryCount;
    _DPP_FIELD_COMMON_LOCALS;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_VERB_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid, group limit %d"), group, groupLimit ));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupD_groupFlags));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryCount.get(unit, group, &groupD_entryCount));
    if ((groupD_groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) &&
        (groupD_entryCount)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d has %d entries but must be"
                              " empty before it can be destroyed\n"),
                   unit,
                   group,
                   groupD_entryCount));
        result = BCM_E_CONFIG;
    } else {
        result = _bcm_dpp_field_group_destroy(unitData, group);
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_status_get
 *   Purpose
 *      Gets the group's status.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (out) bcm_field_group_status_t *status = where to put the status
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_status_get(int unit,
                                 bcm_field_group_t group,
                                 bcm_field_group_status_t *status)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t entry;
    _bcm_dpp_field_entry_type_t entryType;    
    _bcm_dpp_field_stage_idx_t entryTcSh1;
    _bcm_dpp_field_stage_idx_t entryDeSh1;
    _bcm_dpp_field_ent_idx_t entryElems;
    _bcm_dpp_field_ent_idx_t entryDeElems;
    _bcm_dpp_field_ent_idx_t tcam_entry_limit;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    _bcm_dpp_field_grp_idx_t groupLimit;
    _bcm_dpp_field_stage_idx_t stage;  
    bcm_field_group_mode_t grpMode; 
    _bcm_dpp_field_ent_idx_t groupD_entryCount;
    uint32 groupD_groupFlags;
    uint32 hwEntryDeLimit;
    uint32 hwEntryLimit;
    _bcm_dpp_field_ent_idx_t  entryDe_entryNext;
    int entryDe_entryPriority;
    _bcm_dpp_field_ent_idx_t groupD_entryHead;
    unsigned int entryCount;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, group, &stage));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.get(unit, group, &grpMode));
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!status) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("Obligatory out argument is NULL")));
    }

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupD_groupFlags));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryCount.get(unit, group, &groupD_entryCount));
    if (groupD_groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.stageD.modeBits.entryType.get(unit, stage, grpMode, &entryType));
        sal_memset(status, 0x00, sizeof(*status));
        status->prio_max = BCM_FIELD_ENTRY_PRIO_LOWEST;
        status->prio_min = BCM_FIELD_ENTRY_PRIO_HIGHEST;
        status->entry_count = groupD_entryCount;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.stageD.entryDeSh1.get(unit, stage, &entryDeSh1));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.stageD.modeBits.entryCount.get(unit, stage, grpMode, &entryCount));
        switch (entryType) {
            case _bcmDppFieldEntryTypeDirExt:
            {
                /* capacity lookups always from first sharing member */
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.hwEntryDeLimit.get(unit, entryDeSh1, &hwEntryDeLimit));
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.entryDeElems.get(unit, entryDeSh1, &entryDeElems));

                status->entries_total = hwEntryDeLimit / entryCount;
                status->entries_free = (hwEntryDeLimit - entryDeElems) / entryCount;

                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryHead.get(unit, group, &groupD_entryHead));
                if (groupD_entryHead < entryDeLimit) {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryNext.get(unit, groupD_entryHead, &entryDe_entryNext));
                }
                for (entry = groupD_entryHead;
                     entry < entryDeLimit;
                     entry = entryDe_entryNext) {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryPriority.get(unit, entry, &entryDe_entryPriority));
                    if (entryDe_entryPriority > status->prio_max) {
                        status->prio_max = entryDe_entryPriority;
                    }
                    if (entryDe_entryPriority < status->prio_min) {
                        status->prio_min = entryDe_entryPriority;
                    }
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryNext.get(unit, entry, &entryDe_entryNext));
                }
                break;
            }
            default:
            {
                /* default is TCAM */
                int entryPriority;                          /* entry priority */

                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.stageD.entryTcSh1.get(unit, stage, &entryTcSh1));
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.hwEntryLimit.get(unit, entryTcSh1, &hwEntryLimit));
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.entryElems.get(unit, entryTcSh1, &entryElems));
                status->entries_total = hwEntryLimit / entryCount;
                status->entries_free = (hwEntryLimit - entryElems) / entryCount;
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryHead.get(unit, group, &groupD_entryHead));
                for (entry = groupD_entryHead, _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType);
                     entry < tcam_entry_limit;
                     /*
                      * Was:
                      *   entry = _BCM_DPP_FIELD_TCAM_ENTRY_NEXT(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry)
                      */
                     _BCM_DPP_FIELD_TCAM_ENTRY_NEXT_GET(unit,_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry, entry)) {
                    /*
                     * Was:
                     *   if (_BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry) > status->prio_max)
                     */
                    _BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY_GET(unit,_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry, entryPriority) ;
                    if (entryPriority > status->prio_max) {
                        /*
                         * Was:
                         *   status->prio_max = _BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry);
                         */
                        status->prio_max = entryPriority ;
                    }
                    if (entryPriority < status->prio_min) {
                        /*
                         * Was:
                         *   status->prio_min = _BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry);
                         */
                        status->prio_min = entryPriority ;
                    }
                }
            }
        }
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_create
 *   Purpose
 *      Create an empty field entry based upon the specified grup
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = the group ID to use
 *      (out) bcm_field_entry_t *entry = where to put the entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      'The field entry identifier is the priority of the entry in the group.'
 *      Yeah, right.  Where's that deed to the oceanfront property within easy
 *      walking distance of Des Moines?
 *
 *      Actually, the field entry identifier has nothing whatsoever to do with
 *      the priority, which is set separately.  Annoyingly, this function can
 *      only insert the entry into the group based upon a priority setting of
 *      BCM_FIELD_ENTRY_PRIO_DEFAULT, and it will be moved later if the user
 *      actually bothers to set the priority.
 */
int
bcm_petra_field_entry_create(int unit,
                             bcm_field_group_t group,
                             bcm_field_entry_t *entry)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t next;
    _bcm_dpp_field_entry_type_t entryType;
    uint8 found;   
    uint32 soc_sand_rv; 
    uint32 entryUninstalledTcLimit;
    int dpp_field_unit_lock_was_taken ;
    _bcm_dpp_field_ent_idx_t tcam_entry_limit;
    _bcm_dpp_field_grp_idx_t groupLimit;
    _bcm_dpp_field_ent_idx_t entryUninstalledTcCount;
    uint32 groupFlags;
    bcm_field_group_mode_t grpMode; 
    uint32          handle_by_key_entry_id; 
    _bcm_dpp_field_stage_idx_t stage;
    SOC_SAND_OCC_BM_PTR extTcamBmp;

    BCMDNX_INIT_FUNC_DEFS;

    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,*) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    if (!entry) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out arg must not be NULL")));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1 ;
    /* just grab the next free one */
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.handle_by_key_entry_id.get(unit, group, &handle_by_key_entry_id));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, group, &stage));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.get(unit, group, &grpMode));
    if (groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        if (handle_by_key_entry_id != _BCM_DPP_FIELD_GROUP_ENTRY_BY_KEY_EMPTY) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("only one entry can be created for group that handled by key")));
        }
    }
    if (groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.stageD.modeBits.entryType.get(unit, stage, grpMode,  &entryType ));
        switch (entryType) {
        case _bcmDppFieldEntryTypeDirExt:
            result = _bcm_dpp_field_dir_ext_entry_alloc(unitData,
                                                        group,
                                                        FALSE,
                                                        &next);
            if (BCM_E_NONE == result) {
                _bcm_dpp_field_dir_ext_entry_clear(unitData, next);
                result = _bcm_dpp_field_dir_ext_entry_add_to_group(unitData,
                                                                   group,
                                                                   next);
            }
            if (BCM_E_NONE == result) {
                *entry = next + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
            }
            break;
        default:
            /* default is TCAM */
            _BCM_DPP_FIELD_TCAM_ENTRY_TC_FREE(entryType);
            {
                entryUninstalledTcLimit = (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)) ?
                                            _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES(unit) : SOC_DPP_DEFS_GET_NOF_ENTRY_IDS(unit);
                result = FIELD_ACCESS.entryUninstalledTcCount.get(unit, &entryUninstalledTcCount);
                if (BCM_E_NONE == result) {
                    if (entryUninstalledTcCount < entryUninstalledTcLimit) {
                        _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType);
                        if (next < tcam_entry_limit) {
                            LOG_DEBUG(BSL_LS_BCM_FP,
                                      (BSL_META_U(unit,
                                                  "unit %d next free entry is %d\n"),
                                       unit,
                                       next));
                            if (SOC_DPP_IS_ELK_ENABLE(unit)) {
                                if (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)) {
                                    uint32 ext_info_idx ;
                                    int result1 ;

                                    result1 = BCM_E_NONE ;
                                    /* External TCAM entry. Allocate an entry in the external TCAM info table. */
                                    result = FIELD_ACCESS.extTcamBmp.get(unit, &extTcamBmp);
                                    if(BCM_E_NONE == result) {
                                        /*
                                         * Was:
                                         *   soc_sand_rv = soc_sand_occ_bm_alloc_next(unitData->unit, extTcamBmp, &(unitData->entryExtTc[next].ext_info_idx), &found);
                                         */
                                        soc_sand_rv = soc_sand_occ_bm_alloc_next(unitData->unit, extTcamBmp, &(ext_info_idx), &found);
                                        result = handle_sand_result(soc_sand_rv);
                                        if(!SOC_WARM_BOOT(unit)) {
                                            result1 = FIELD_ACCESS_ENTRYEXTTC.ext_info_idx.set(unit,next,ext_info_idx) ;
                                        }
                                        if ((BCM_E_NONE == result) && (BCM_E_NONE == result1)) {
                                            if (!found) {
                                                LOG_ERROR(BSL_LS_BCM_FP,
                                                          (BSL_META_U(unit,
                                                                      "unit %d reached max external TCAM entries before HW install\n"), unit));
                                                result = BCM_E_FULL;
                                            }
                                        }
                                    }
                                }
                            }
                            _bcm_dpp_field_tcam_entry_clear(unitData, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), next);   
                            if(BCM_E_NONE == result){
                                result = _bcm_dpp_field_tcam_entry_add_to_group(unitData,
                                                                                group,
                                                                                next);
                            }
                        } else {
                            LOG_ERROR(BSL_LS_BCM_FP,
                                      (BSL_META_U(unit,
                                                  "unit %d has no free entries\n"), unit));
                            result = BCM_E_FULL;
                        }
                    } else {
                        LOG_ERROR(BSL_LS_BCM_FP,
                                  (BSL_META_U(unit,
                                              "unit %d has exceeded number of uninstalled TCAM entries\n"), unit));
                        result = BCM_E_FULL;
                    }
                }
                if (BCM_E_NONE == result) {
                    *entry = _BCM_DPP_FIELD_TCAM_GLOBAL_ID(unit, next, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType));
                }
            }
        } /* switch (group entry type) */
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    if (groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        handle_by_key_entry_id = (*entry);
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,&(%d)) return %d (%s)\n"),
               unit,
               group,
               *entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken)
    {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_create_id
 *   Purpose
 *      Create an empty field entry based upon the specified grup
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = the group ID to use
 *      (in) bcm_field_entry_t entry = the entry ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      'The field entry identifier is the priority of the entry in the group.'
 *      Yeah, right.  Where's that deed to the oceanfront property within easy
 *      walking distance of Des Moines?
 *
 *      Actually, the field entry identifier has nothing whatsoever to do with
 *      the priority, which is set separately.  Annoyingly, this function can
 *      only insert the entry into the group based upon a priority setting of
 *      BCM_FIELD_ENTRY_PRIO_DEFAULT, and it will be moved later if the user
 *      actually bothers to set the priority.
 */
int
bcm_petra_field_entry_create_id(int unit,
                                bcm_field_group_t group,
                                bcm_field_entry_t entry)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t next;
    _bcm_dpp_field_entry_type_t entryType;  
    _bcm_dpp_field_grp_idx_t groupLimit;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    uint8 found;   
    uint32 soc_sand_rv; 
    uint32 entryUninstalledTcLimit;
    int dpp_field_unit_lock_was_taken ;
    _bcm_dpp_field_ent_idx_t entryUninstalledTcCount;
    uint32 groupFlags;
    bcm_field_group_mode_t grpMode; 
    uint32          handle_by_key_entry_id; 
    _bcm_dpp_field_stage_idx_t stage;
    SOC_SAND_OCC_BM_PTR extTcamBmp;

    BCMDNX_INIT_FUNC_DEFS;

    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%d) enter\n"), unit, group, entry));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1 ;
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
    if ((groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) == 0) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                   (_BSL_BCM_MSG("unit %d group %d is not in use\n"), unit, group));
    }

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.handle_by_key_entry_id.get(unit, group, &handle_by_key_entry_id));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, group, &stage));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.get(unit, group, &grpMode));
    if (groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        if (handle_by_key_entry_id != _BCM_DPP_FIELD_GROUP_ENTRY_BY_KEY_EMPTY) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("only one entry can be created for group that handled by key")));
        }
    }
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.stageD.modeBits.entryType.get(unit, stage, grpMode,  &entryType ));
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));
    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        if (_BCM_DPP_FIELD_ENT_TYPE_IS_TCAM(entryType)) {
            uint32 entryFlags;

            /* Check the entry-id is of same type than field group */
            if ((_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType) && _BCM_DPP_FIELD_ENT_IS_INTTCAM(unit, entry))
                || (_BCM_DPP_FIELD_ENT_TYPE_IS_INTTCAM(entryType) && _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry))) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d can not be used with"
                                      " group %d because group TCAM type is (0-int, 1-ext) "
                                      " %d whereas entry type (according to id) is"
                                      " (0-int, 1-ext) %d\n"),
                           unit,
                           entry,
                           group,
                           _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType),
                           _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)));
            }
            next = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry);
            /*
             * Was:
             *   if (0 == (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), next) ))
             */
            result = _BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit,_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), next, entryFlags) ;
            if (BCM_E_NONE == result) {

                if (0 == (entryFlags  &
                          _BCM_DPP_FIELD_ENTRY_IN_USE)) {
                    entryUninstalledTcLimit = (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)) ?
                                                _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES(unit) : SOC_DPP_DEFS_GET_NOF_ENTRY_IDS(unit);
    		result = FIELD_ACCESS.entryUninstalledTcCount.get(unit, &entryUninstalledTcCount);
    		if (BCM_E_NONE == result) {
                        if (entryUninstalledTcCount < entryUninstalledTcLimit) {
                            _bcm_dpp_field_tcam_entry_clear(unitData, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), next);                
                            if (SOC_DPP_IS_ELK_ENABLE(unit)) {
                                if (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)) {
                                    uint32 ext_info_idx ;
                                    int result1 ;

                                    result1 = BCM_E_NONE ;
                                    /* External TCAM entry. Allocate an entry in the external TCAM info table. */
                                    result = FIELD_ACCESS.extTcamBmp.get(unit, &extTcamBmp);
                                    if (BCM_E_NONE == result) {
                                        /*
                                         * Was:
                                         *    soc_sand_rv = soc_sand_occ_bm_alloc_next(unitData->unit, extTcamBmp, &(unitData->entryExtTc[next].ext_info_idx), &found);
                                         */
                                        soc_sand_rv = soc_sand_occ_bm_alloc_next(unitData->unit, extTcamBmp, &(ext_info_idx), &found);
                                        result = handle_sand_result(soc_sand_rv);
                                        if(!SOC_WARM_BOOT(unit)) {
                                            result1 = FIELD_ACCESS_ENTRYEXTTC.ext_info_idx.set(unit,next,ext_info_idx) ;
                                        }
                                        if ((BCM_E_NONE == result) && (BCM_E_NONE == result1)) {
                                            if (!found) {
                                                LOG_ERROR(BSL_LS_BCM_FP,
                                                          (BSL_META_U(unit,
                                                                      "unit %d reached max external TCAM entries before HW install\n"), unit));
                                                result = BCM_E_FULL;
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            LOG_ERROR(BSL_LS_BCM_FP,
                                      (BSL_META_U(unit,
                                                  "unit %d has exceeded number of uninstalled TCAM entries\n"), unit));
                            result = BCM_E_FULL;
                        }
                    }
                    if (BCM_E_NONE == result) {
                        result = _bcm_dpp_field_tcam_entry_add_to_group(unitData,
                                                                        group,
                                                                        next);
                    }
                } else {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d entry %d is already in use\n"),
                               unit,
                               entry));
                    result = BCM_E_EXISTS;
                }
            }
        } else { /* if (group entry type is TCAM) */
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d can not be used with"
                                  " group %d because group %d is direct"
                                  " extraction and entry %d is not\n"),
                       unit,
                       entry,
                       group,
                       group,
                       entry));
        } /* if (group entry type is TCAM) */
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                entry)) {
        next = entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
        result = _bcm_dpp_field_dir_ext_entry_alloc(unitData,
                                                    group,
                                                    TRUE,
                                                    &next);
        if (BCM_E_NONE == result) {
            _bcm_dpp_field_dir_ext_entry_clear(unitData, next);
            result = _bcm_dpp_field_dir_ext_entry_add_to_group(unitData,
                                                               group,
                                                               next);
        }
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),  unit,  entry));
    }
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
    if (groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.handle_by_key_entry_id.set(unit, group, entry));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%d) return %d (%s)\n"),
               unit,
               group,
               entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken)
    {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function: bcm_petra_field_entry_multi_get
 *
 * Purpose:
 *     Gets an array of a group's entry IDs
 *
 * Parameters:
 *     unit -  (IN) BCM device number.
 *     group - (IN) Field group ID.
 *     entry_size - (IN) Maximum number of entries to return.  Set to 0
 *                       to get the number of entries available
 *     entry_array - (OUT) Pointer to a buffer to fill with the array of
 *                         entry IDs.  Ignored if entry_size is 0
 *     entry_count - (OUT) Returns the number of entries returned in the
 *                         array, or if entry_size was 0, the number of
 *                         entries available
 * Returns:
 *     BCM_E_INIT      - unit not initialized
 *     BCM_E_NOT_FOUND - Group ID not found in unit
 *     BCM_E_NONE      - Success
 */
int
bcm_petra_field_entry_multi_get(int unit,
                                bcm_field_group_t group,
                                int entry_size,
                                bcm_field_entry_t *entry_array,
                                int *entry_count)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t entry;
    int index;
    _bcm_dpp_field_entry_type_t entryType;    
    _bcm_dpp_field_grp_idx_t groupLimit;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    _bcm_dpp_field_ent_idx_t tcam_entry_limit;
    uint32 groupFlags;
    bcm_field_group_mode_t grpMode; 
    _bcm_dpp_field_stage_idx_t stage; 
    _bcm_dpp_field_ent_idx_t entryCount;
    _bcm_dpp_field_ent_idx_t entryHead;
    _bcm_dpp_field_ent_idx_t  entryDe_entryNext;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, %d, *, *) enter\n"),
               unit,
               group,
               entry_size));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!entry_count) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("Obligatory out argument is NULL")));
    }
    if ((0 != entry_size) && (!entry_array)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "obligatory out argument is NULL\n")));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }    
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, group, &stage));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.get(unit, group, &grpMode));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryCount.get(unit, group, &entryCount));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryHead.get(unit, group, &entryHead));
    if (groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,(_BSL_BCM_MSG_NO_UNIT("unit %d group %d for this type of groups"),unit,group));
    }    
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;
    if (groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.stageD.modeBits.entryType.get(unit, stage, grpMode,  &entryType ));
        if (0 == entry_size) {
            *entry_count = entryCount;
        } else {
            switch (entryType) {
            case _bcmDppFieldEntryTypeDirExt:
                BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));
                if (entryHead < entryDeLimit) {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryNext.get(unit, entryHead, &entryDe_entryNext));
                }
                for (index = 0,
                     entry = entryHead;
                     (entry < entryDeLimit) &&
                     (index < entry_size);
                     index++,
                     entry = entryDe_entryNext) {
                    entry_array[index] = entry +
                                         _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryNext.get(unit, entry, &entryDe_entryNext));
                }
                break;
            default:
                /* default is TCAM */
                for (index = 0,
                     entry = entryHead, 
					 _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType);
                        (entry < tcam_entry_limit)
                      && (index < entry_size);
                     index++,
                     /*
                      * Was:
                      *   entry = _BCM_DPP_FIELD_TCAM_ENTRY_NEXT(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry) 
                      */
                     _BCM_DPP_FIELD_TCAM_ENTRY_NEXT_GET(unit,_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry, entry) ) {
                    entry_array[index] = _BCM_DPP_FIELD_TCAM_GLOBAL_ID(unit, entry, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)); 
                }
            }
            *entry_count = index;
        }
        result = BCM_E_NONE;
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_dpp_petra_field_entry_group(int unit,
                                       bcm_field_entry_t entry,
                                       _bcm_dpp_field_grp_idx_t *entryGroup)
{
    bcm_dpp_field_info_OLD_t *unitData;
    _bcm_dpp_field_ent_idx_t entryTcLimit;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    _bcm_dpp_field_grp_idx_t localEntryGroup ;
    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        /*
         * Was:
         *   *entryGroup = _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry) );
         */
        BCMDNX_IF_ERR_EXIT(
            _BCM_DPP_FIELD_TCAM_ENTRY_GROUP_GET(
                unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry), localEntryGroup)) ;
        *entryGroup = localEntryGroup ;
    } 
    else {
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryTcLimit.get(unit, &entryTcLimit));
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));

        if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry) &&
            ((entryTcLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, InternalTcam)) > _BCM_DPP_FIELD_PRESEL_FROM_ENTRY(entry))) {
            /*
             * Was:
             *   entryCommon = &(unitData->entryTc[_BCM_DPP_FIELD_PRESEL_FROM_ENTRY(entry) - _BCM_DPP_FIELD_ENT_BIAS(unit, InternalTcam)].entryCmn);
             *   *entryGroup = entryCommon->entryGroup;
             */
            BCMDNX_IF_ERR_EXIT( 
                FIELD_ACCESS_ENTRYTC.entryCmn.entryGroup.get(
                    unit,(_BCM_DPP_FIELD_PRESEL_FROM_ENTRY(entry) - _BCM_DPP_FIELD_ENT_BIAS(unit, InternalTcam)),entryGroup)) ;
        } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
                   ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                      entry))  {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryGroup.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), entryGroup));
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d entry %d is not valid"),
                              unit,
                              entry));
        }

        
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_destroy
 *   Purpose
 *      Destroy a field entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID to destroy
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      BCM spec says that this does not remove any associated entries from the
 *      hardware, but since we have no way to reset underlying driver, that is
 *      not safe; we therefore destroy hardware copy as well if it exists.
 */
int
bcm_petra_field_entry_destroy(int unit,
                              bcm_field_entry_t entry)
{
    _bcm_dpp_field_grp_idx_t entryGroup;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    uint32 groupFlags;
    uint8 is_second_pass;
    uint32          handle_by_key_entry_id;     
    bcm_field_qset_t qset;
    _bcm_dpp_field_entry_t entryD;
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
    _bcm_dpp_field_entry_ext_t entryExtD;
#endif
    _bcm_dpp_field_entry_dir_ext_t *entryDe = NULL;
    _bcm_dpp_field_b_qual_t qualD;
    int index;
    uint32 entryFlags;
    _bcm_dpp_field_ent_idx_t new_entry;

    int dpp_field_unit_lock_was_taken ;
    _DPP_FIELD_COMMON_LOCALS;
    BCMDNX_INIT_FUNC_DEFS;

    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, entry));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1 ;

    if ((_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)) && (soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE))) {
        is_second_pass = _BCM_DPP_FIELD_ENTRY_IS_PRESEL_STAGGERED(entry);
        result = _bcm_dpp_field_presel_destroy(unitData, entry, is_second_pass);
    } else {
        if (_BCM_DPP_FIELD_ENTRY_IS_LARGE_DIRECT_LOOKUP(entry)) {
            BCM_FIELD_LARGE_DIRECT_ENTRY_ID_UNPACK(entry, entryGroup, new_entry);
            if (!_BCM_DPP_FIELD_ENT_IS_KAPS_ADVANCED_MODE(unit, entryGroup)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG("This entry 0x%x group %d key 0x%x should work in large direct lookup advanced mode."), entry, entryGroup, new_entry));
            }
        }

        /* For group entries */
        if(_BCM_DPP_FIELD_ENT_IS_INTTCAM(unit, entry)){
            /* Entry existence check for Internal TCAM  */
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryTc.entryCmn.entryFlags.get(unit,_BCM_DPP_FIELD_INTTCAM_LOCAL_ID(unit, entry),&entryFlags));
               if(entryFlags == 0){
                   BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                                        (_BSL_BCM_MSG("unit %d entry %d does not exist\n"),
                                         unit,
                                         entry));
               }
         }
         else if (_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)){
             /* Entry existence check for External TCAM  */
               BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryExtTc.entryCmn.entryFlags.get(unit,_BCM_DPP_FIELD_EXTTCAM_LOCAL_ID(unit, entry),&entryFlags));
               if(entryFlags == 0){
                   BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                                        (_BSL_BCM_MSG("unit %d entry %d does not exist\n"),
                                         unit,
                                         entry));
                }
         }
        /* Clean-up profile properties */
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_petra_field_entry_group(unit, entry, &entryGroup));

        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, entryGroup, &groupFlags));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.handle_by_key_entry_id.get(unit, entryGroup, &handle_by_key_entry_id));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.qset.get(unit, entryGroup, &qset));

        if (groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
            handle_by_key_entry_id = _BCM_DPP_FIELD_GROUP_ENTRY_BY_KEY_EMPTY;
        } else {    

            if (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyAppType)) {
                /* If port profiles are defined - clear them */
                BCMDNX_IF_ERR_EXIT(
                    _bcm_dpp_field_presel_port_profile_clear_type(unitData,
                                                                  _bcmDppFieldProfileTypeFlpProgramProfile,
                                                                  entry));
            }
            BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));
            if (_BCM_DPP_FIELD_ENTRY_IS_LARGE_DIRECT_LOOKUP(entry)) {
                result = _bcm_dpp_field_tcam_entry_destroy(unitData,
                                                           FALSE,
                                                           entry);
            } else if (_BCM_DPP_FIELD_ENT_IS_INTTCAM(unit, entry)) {
                result = _bcm_dpp_field_tcam_entry_destroy(unitData,
                                                           FALSE,
                                                           entry);
                BCMDNX_IF_ERR_EXIT(
                sw_state_access[unit].dpp.bcm.field.entryTc.get(unit, entry, &entryD));
                for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
                    qualD = entryD.entryCmn.entryBcmQual[index];
                    if(_BCM_DPP_QUALIFIER_IS_KEPT_IN_SW_STATE(qualD.qualType)) 
                    {
                        qualD.qualType = bcmFieldQualifyCount;
                        qualD.bcmParam0 = 0;
                        qualD.bcmMask0 = 0;
                        qualD.bcmParam1 = 0;
                        qualD.bcmMask1 = 0;
                        entryD.entryCmn.entryBcmQual[index] = qualD;
                    }
                }
                BCMDNX_IF_ERR_EXIT(
                    sw_state_access[unit].dpp.bcm.field.entryTc.set(unit, entry, &entryD));
            } else if (_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)) {
                result = _bcm_dpp_field_tcam_entry_destroy(unitData,
                                                           FALSE,
                                                           entry);
    #if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
                BCMDNX_IF_ERR_EXIT(
                sw_state_access[unit].dpp.bcm.field.entryExtTc.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam), &entryExtD));
                for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
                    qualD = entryExtD.entryCmn.entryBcmQual[index];
                    if(_BCM_DPP_QUALIFIER_IS_KEPT_IN_SW_STATE(qualD.qualType)) 
                    {
                        qualD.qualType = bcmFieldQualifyCount;
                        qualD.bcmParam0 = 0;
                        qualD.bcmMask0 = 0;
                        qualD.bcmParam1 = 0;
                        qualD.bcmMask1 = 0;
                        entryExtD.entryCmn.entryBcmQual[index] = qualD;
                    }
                }
                BCMDNX_IF_ERR_EXIT(
                    sw_state_access[unit].dpp.bcm.field.entryExtTc.set(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam), &entryExtD));
    #endif
            } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
                       ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                        entry))  {
                result = _bcm_dpp_field_dir_ext_entry_destroy(unitData,
                                                              entry -
                                                              _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt));
                BCMDNX_ALLOC_AND_CLEAR(entryDe, sizeof(*entryDe), "bcm_petra_field_entry_destroy.entryDe");
                BCMDNX_IF_ERR_EXIT(
                sw_state_access[unit].dpp.bcm.field.entryDe.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), entryDe));
                for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
                    qualD = entryDe->entryCmn.entryBcmQual[index];
                    if(_BCM_DPP_QUALIFIER_IS_KEPT_IN_SW_STATE(qualD.qualType)) 
                    {
                        qualD.qualType = bcmFieldQualifyCount;
                        qualD.bcmParam0 = 0;
                        qualD.bcmMask0 = 0;
                        qualD.bcmParam1 = 0;
                        qualD.bcmMask1 = 0;
                        entryDe->entryCmn.entryBcmQual[index] = qualD;
                    }
                }
                BCMDNX_IF_ERR_EXIT(
                    sw_state_access[unit].dpp.bcm.field.entryDe.set(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), entryDe));
            } else {
                result = BCM_E_NOT_FOUND;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d is not valid\n"), unit, entry));
            }
        }

        _DPP_FIELD_UNIT_UNLOCK(unitData);
        dpp_field_unit_lock_was_taken = 0 ;
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "(%d, %d) return %d (%s)\n"),
                   unit,
                   entry,
                   result,
                   _SHR_ERRMSG(result)));
        BCMDNX_IF_ERR_EXIT(result);
    }
exit:
    BCM_FREE(entryDe);
    if (dpp_field_unit_lock_was_taken)
    {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_destroy_all
 *   Purpose
 *      Destroy all field entries
 *   Parameters
 *      (in) int unit = the unit number
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      BCM spec says that this does not remove any associated entries from the
 *      hardware, but since we have no way to reset underlying driver, that is
 *      not safe; we therefore destroy hardware copy as well if it exists.
 *
 *      This does not destroy the groups; only their entries.
 */
int
bcm_petra_field_entry_destroy_all(int unit)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_grp_idx_t currGroup;
    _bcm_dpp_field_grp_idx_t nextGroup;
    _bcm_dpp_field_grp_idx_t groupLimit;
    _bcm_dpp_field_ent_idx_t currEntry;
    _bcm_dpp_field_ent_idx_t nextEntry;
    _bcm_dpp_field_ent_idx_t tcam_entry_limit;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    _bcm_dpp_field_stage_idx_t stage;
    _bcm_dpp_field_entry_type_t entryType;  
    _bcm_dpp_field_ent_idx_t entryHead;
    _bcm_dpp_field_grp_idx_t groupNext;
    bcm_field_group_mode_t grpMode; 
    _bcm_dpp_field_stage_idx_t groupD_stage;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,*) enter\n"), unit));

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    for (stage = 0;
         (BCM_E_NONE == result) &&
         (stage < unitData->devInfo->stages);
         stage++) {
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.stageD.groupHead.get(unit, stage, &nextGroup ));
        while ((BCM_E_NONE == result) &&
               (nextGroup < groupLimit)) {
            currGroup = nextGroup;
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, currGroup, &groupD_stage));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.get(unit, currGroup, &grpMode));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupNext.get(unit, currGroup, &groupNext));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.entryHead.get(unit, currGroup, &entryHead));

            if (_BCM_DPP_FIELD_ENT_IS_KAPS_ADVANCED_MODE(unit, currGroup)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG("This API is not supportd by large direct lookup advanced mode.")));
            }

            nextGroup = groupNext;
            nextEntry = entryHead;
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.stageD.modeBits.entryType.get(unit, stage, grpMode,  &entryType ));
            switch (entryType) {
            case _bcmDppFieldEntryTypeDirExt:
                while ((BCM_E_NONE == result) &&
                       (nextEntry < entryDeLimit)) {
                    currEntry = nextEntry;
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryNext.get(unit, currEntry, &nextEntry));
                    result = _bcm_dpp_field_dir_ext_entry_destroy(unitData,
                                                                  currEntry);
                }
                break;
            default:
                /* default is TCAM */
                _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType);
                while ((BCM_E_NONE == result) &&
                       (nextEntry < tcam_entry_limit)) {
                    currEntry = nextEntry;
                    /*
                     * Was:
                     *   nextEntry = _BCM_DPP_FIELD_TCAM_ENTRY_NEXT(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), currEntry);
                     */
                    BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_NEXT_GET(unit,_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), currEntry, nextEntry)) ;
                    result = _bcm_dpp_field_tcam_entry_destroy(unitData,
                                                               FALSE,
                                                               _BCM_DPP_FIELD_TCAM_GLOBAL_ID(unit, currEntry, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)));
                }
            } /* switch (group's entry type) */
        } /* while (no errors and more groups to scan) */
    } /* for (all stages as long as no errors) */
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,*) return %d (%s)\n"),
               unit,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_copy
 *   Purpose
 *      Copy an existing field entry to another one
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t src_entry = the original entry ID
 *      (out) bcm_field_entry_t *dst_entry = where to put the copy entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      'The field entry identifier is the priority of the entry in the group.'
 *      Yeah, right.  Where's that deed to the oceanfront property within easy
 *      walking distance of Des Moines?
 *
 *      Actually, the field entry identifier has nothing whatsoever to do with
 *      the priority, which is set separately.  Annoyingly, this function will
 *      insert the entry into the group based upon a priority setting of
 *      BCM_FIELD_ENTRY_PRIO_DEFAULT, and it will be moved later if the user
 *      actually bothers to set the priority.
 *
 *      This can only copy the entry within its group, and the copy will be
 *      inserted as the last entry.  If the
 *      original entry is participating in counter sharing, so is the copy; if
 *      not, neither is the copy (but if the original had a counter allocated,
 *      so will the copy, though it will be a *different* counter).
 */
int
bcm_petra_field_entry_copy(int unit,
                           bcm_field_entry_t src_entry,
                           bcm_field_entry_t *dst_entry)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t next;
    _bcm_dpp_field_ent_idx_t curr;
    _bcm_dpp_field_ent_idx_t tcam_entry_limit;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    _bcm_dpp_field_grp_idx_t group;
    _bcm_dpp_field_entry_type_t entryType; 
    uint8 found;   
    uint32 soc_sand_rv; 
    uint32 entryUninstalledTcLimit;
    _bcm_dpp_field_ent_idx_t entryUninstalledTcCount;
    bcm_field_group_mode_t grpMode; 
    _bcm_dpp_field_stage_idx_t stage;
    uint32 entryDe_entryFlags;
    _bcm_dpp_field_grp_idx_t entryDe_entryGroup;
    SOC_SAND_OCC_BM_PTR extTcamBmp;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,*) enter\n"), unit, src_entry));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!dst_entry) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out arg must not be NULL")));
    }
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));

    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, src_entry)) {
        uint32 flags;

        curr = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, src_entry);

        BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit, _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), curr, flags)) ;
        if (!(flags & _BCM_DPP_FIELD_ENTRY_IN_USE)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is not in use\n"),
                       unit,
                       src_entry));
            result = BCM_E_NOT_FOUND;
            BCMDNX_IF_ERR_EXIT(result);
        }

        BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_GROUP_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), curr, group)) ;

        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, group, &stage));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.get(unit, group, &grpMode));
        FIELD_ACCESS.stageD.modeBits.entryType.get(unit, stage, grpMode,  &entryType );
        BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit,_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), curr, flags)) ;

        entryUninstalledTcLimit = (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)) ?
                                    _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES(unit) : SOC_DPP_DEFS_GET_NOF_ENTRY_IDS(unit);
        result = FIELD_ACCESS.entryUninstalledTcCount.get(unit, &entryUninstalledTcCount);
        if (BCM_E_NONE == result) {
            if (entryUninstalledTcCount < entryUninstalledTcLimit) {
                _BCM_DPP_FIELD_TCAM_ENTRY_TC_FREE(entryType);   /* sets 'next' variable with the next free entry */
                _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType);     /* sets 'tcam_entry_limit' variable with the tcam limit */
                if (next < tcam_entry_limit) {
                    LOG_DEBUG(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d next free entry is %d\n"),
                               unit,
                               next));
                    _bcm_dpp_field_tcam_entry_copy_id(unitData, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), next, curr);
                    if (SOC_DPP_IS_ELK_ENABLE(unit)) {
                        if (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)) {
                            uint32 ext_info_idx ;
                            int result1 ;

                            result1 = BCM_E_NONE ;
                            /* External TCAM entry. Allocate an entry in the external TCAM info table. */
                            result = FIELD_ACCESS.extTcamBmp.get(unit, &extTcamBmp);
                            if (BCM_E_NONE == result) {
                                /*
                                 * was:
                                 *   soc_sand_rv = soc_sand_occ_bm_alloc_next(unitData->unit, extTcamBmp, &(unitData->entryExtTc[next].ext_info_idx), &found);
                                 */
                                soc_sand_rv = soc_sand_occ_bm_alloc_next(unitData->unit, extTcamBmp, &(ext_info_idx), &found);
                                result = handle_sand_result(soc_sand_rv);
                                if(!SOC_WARM_BOOT(unit)) {
                                    result1 = FIELD_ACCESS_ENTRYEXTTC.ext_info_idx.set(unit,next,ext_info_idx) ;
                                }
                                if ((BCM_E_NONE == result) && (BCM_E_NONE == result1)) {
                                    if (!found) {
                                        LOG_ERROR(BSL_LS_BCM_FP,
                                                  (BSL_META_U(unit,
                                                              "unit %d reached max external TCAM entries before HW install\n"), unit));
                                        result = BCM_E_FULL;
                                    }
                                    /* copy the src entry info to the dst entry info */
                                    /*
                                     * was:
                                     *   sal_memcpy(&(unitData->extTcamInfo[unitData->entryExtTc[next].ext_info_idx]),
                                     *         &(unitData->extTcamInfo[unitData->entryExtTc[curr].ext_info_idx]),
                                     *         sizeof(_bcm_dpp_field_entry_ext_info_t));
                                     */
                                    if(!SOC_WARM_BOOT(unit)) {
                                        _bcm_dpp_field_entry_ext_info_t field_entry_ext_info ;
                                        uint32 ext_info_idx ;

                                        FIELD_ACCESS_ENTRYEXTTC.ext_info_idx.get(unit,curr,&ext_info_idx) ;
                                        FIELD_ACCESS_EXTTCAMINFO.get(unit,ext_info_idx,&field_entry_ext_info) ;
                                        FIELD_ACCESS_ENTRYEXTTC.ext_info_idx.get(unit,next,&ext_info_idx) ;
                                        FIELD_ACCESS_EXTTCAMINFO.set(unit,ext_info_idx,&field_entry_ext_info) ;
                                    }
                                }
                            }
                        }
                    }
                    if (BCM_E_NONE == result) {
                        _bcm_dpp_field_grp_idx_t loc_group ;
                        /*
                         * Was:
                         *   result = _bcm_dpp_field_tcam_entry_add_to_group(unitData,
                         *            _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), curr),
                         *             next);
                         */
                        BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_GROUP_GET(unit,_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), curr, loc_group)) ;
                        result = _bcm_dpp_field_tcam_entry_add_to_group(unitData,
                                      loc_group,
                                      next);
                    }
                } else {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d has no free entries\n"), unit));
                    result = BCM_E_FULL;
                }
            } else {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d has exceeded number of uninstalled TCAM entries\n"), unit));
                result = BCM_E_FULL;
            }
        }
        if (BCM_E_NONE == result) {
            *dst_entry = _BCM_DPP_FIELD_TCAM_GLOBAL_ID(unit, next, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType));
        }
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= src_entry) &&
               ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                src_entry)) {
        curr = src_entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryFlags.get(unit, curr, &entryDe_entryFlags));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryGroup.get(unit, curr, &entryDe_entryGroup));
        if (entryDe_entryFlags & _BCM_DPP_FIELD_ENTRY_IN_USE) {
            result = _bcm_dpp_field_dir_ext_entry_alloc(unitData,
                                                        entryDe_entryGroup,
                                                        FALSE,
                                                        &next);
            if (BCM_E_NONE == result) {
                _bcm_dpp_field_dir_ext_entry_copy_id(unitData, next, curr);
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryGroup.get(unit, curr, &entryDe_entryGroup));
                result = _bcm_dpp_field_dir_ext_entry_add_to_group(unitData,
                                                                   entryDe_entryGroup,
                                                                   next);
            }
            if (BCM_E_NONE == result) {
                *dst_entry = next + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
            }
        } else { /* if (source entry is in use) */
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is not in use\n"),
                       unit,
                       src_entry));
            result = BCM_E_NOT_FOUND;
        } /* if (source entry is in use) */
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit,
                   src_entry));
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,&(%d)) return %d (%s)\n"),
               unit,
               src_entry,
               *dst_entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_copy_id
 *   Purpose
 *      Copy an existing field entry to a specific one
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t src_entry = the original entry ID
 *      (in) bcm_field_entry_t dst_entry = the copy entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      'The field entry identifier is the priority of the entry in the group.'
 *      Yeah, right.  Where's that deed to the oceanfront property within easy
 *      walking distance of Des Moines?
 *
 *      Actually, the field entry identifier has nothing whatsoever to do with
 *      the priority, which is set separately.  Annoyingly, this function will
 *      insert the entry into the group based upon a priority setting of
 *      BCM_FIELD_ENTRY_PRIO_DEFAULT, and it will be moved later if the user
 *      actually bothers to set the priority.
 *
 *      This can only copy the entry within its group, and the copy will be
 *      inserted as the last entry.  If the original entry is
 *      participating in counter sharing, so is the copy; if not, neither is
 *      the copy (but if the original had a counter allocated, so will the
 *      copy, though it will be a different counter).
 */
int
bcm_petra_field_entry_copy_id(int unit,
                              bcm_field_entry_t src_entry,
                              bcm_field_entry_t dst_entry)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t src;
    _bcm_dpp_field_ent_idx_t dst;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    _bcm_dpp_field_ent_idx_t entryUninstalledTcCount;
    uint32 entryDe_entryFlags;
    _bcm_dpp_field_grp_idx_t entryDe_entryGroup;
    uint32 flags;

    uint8 found;   
    uint32 soc_sand_rv; 
    uint32 entryUninstalledTcLimit;
    SOC_SAND_OCC_BM_PTR extTcamBmp;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%d) enter\n"), unit, src_entry, dst_entry));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, src_entry)) {
        if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, dst_entry)) {
            src = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, src_entry);
            dst = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, dst_entry);
            BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), dst, flags)) ;
            /*
             * was:
             *   if (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), dst) & _BCM_DPP_FIELD_ENTRY_IN_USE) 
             */
            if (flags  & _BCM_DPP_FIELD_ENTRY_IN_USE) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d is already in use\n"),
                           unit,
                           dst_entry));
                result = BCM_E_EXISTS;
            }
            /*
             * Was:
             *   if (0 == (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), src) ))
             */
            BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), src, flags)) ;
            if (0 == (flags  &
                      _BCM_DPP_FIELD_ENTRY_IN_USE)) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d is not in use\n"),
                           unit,
                           src_entry));
                result = BCM_E_NOT_FOUND;
            }
            if (BCM_E_NONE == result) {
                entryUninstalledTcLimit = (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(src_entry)) ?
                                            _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES(unit) : SOC_DPP_DEFS_GET_NOF_ENTRY_IDS(unit);
                result = FIELD_ACCESS.entryUninstalledTcCount.get(unit, &entryUninstalledTcCount);
                if (BCM_E_NONE == result) {
                    if (entryUninstalledTcCount < entryUninstalledTcLimit) {
                        _bcm_dpp_field_tcam_entry_copy_id(unitData, _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), dst, src);               
                        if (SOC_DPP_IS_ELK_ENABLE(unit)) {
                            if (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(src_entry)) {
                                uint32 ext_info_idx ;
                                /* External TCAM entry. Allocate an entry in the external TCAM info table. */
                                result = FIELD_ACCESS.extTcamBmp.get(unit, &extTcamBmp);
                                if (BCM_E_NONE == result) {
                                    /*
                                     * Was:
                                     *   soc_sand_rv = soc_sand_occ_bm_alloc_next(unitData->unit, unitData->extTcamBmp, &(unitData->entryExtTc[dst].ext_info_idx), &found);
                                     */
                                    soc_sand_rv = soc_sand_occ_bm_alloc_next(unitData->unit, extTcamBmp, &ext_info_idx, &found);
                                    result = handle_sand_result(soc_sand_rv);
                                    if (BCM_E_NONE == result) {
                                        FIELD_ACCESS_ENTRYEXTTC.ext_info_idx.set(unit,dst,ext_info_idx) ;
                                        if (!found) {
                                            LOG_ERROR(BSL_LS_BCM_FP,
                                                      (BSL_META_U(unit,
                                                                  "unit %d reached max external TCAM entries before HW install\n"), unit));
                                            result = BCM_E_FULL;
                                        }
                                        /* copy the src entry info to the dst entry info */
                                        /*
                                         * Was:
                                         *   sal_memcpy(&(unitData->extTcamInfo[unitData->entryExtTc[dst].ext_info_idx]),
                                         *         &(unitData->extTcamInfo[unitData->entryExtTc[src].ext_info_idx]),
                                         *         sizeof(_bcm_dpp_field_entry_ext_info_t));
                                         */
                                        if(!SOC_WARM_BOOT(unit)) {
                                            _bcm_dpp_field_entry_ext_info_t field_entry_ext_info ;
                                            uint32 ext_info_idx ;

                                            FIELD_ACCESS_ENTRYEXTTC.ext_info_idx.get(unit,src,&ext_info_idx) ;
                                            FIELD_ACCESS_EXTTCAMINFO.get(unit,ext_info_idx,&field_entry_ext_info) ;
                                            FIELD_ACCESS_ENTRYEXTTC.ext_info_idx.get(unit,dst,&ext_info_idx) ;
                                            FIELD_ACCESS_EXTTCAMINFO.set(unit,ext_info_idx,&field_entry_ext_info) ;
                                        }
                                    }
                                }
                            }
                        }
                        if (BCM_E_NONE == result) {
                            _bcm_dpp_field_grp_idx_t loc_group ;
                            /*
                             * Was:
                             * result = _bcm_dpp_field_tcam_entry_add_to_group(unitData,
                             *                                               _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), src),
                             *                                               dst_entry);
                             */
                            BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_GROUP_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), src, loc_group)) ;
                            result = _bcm_dpp_field_tcam_entry_add_to_group(unitData,
                                                                            loc_group,
                                                                            dst_entry);
                        }
                    } else {
                        LOG_ERROR(BSL_LS_BCM_FP,
                                  (BSL_META_U(unit,
                                              "unit %d has exceeded number of uninstalled TCAM entries\n"), unit));
                        result = BCM_E_FULL;
                    }
                }
            }
        } else { /* if (dst_entry is a TCAM entry) */
            result = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is TCAM but entry %d is"
                                  " not TCAM\n"),
                       unit,
                       src_entry,
                       dst_entry));
        } /* if (dst_entry is a TCAM entry) */
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= src_entry) &&
               ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                src_entry)) {
        if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= dst_entry) &&
            ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
             dst_entry)) {
            src = src_entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
            dst = dst_entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryFlags.get(unit, src, &entryDe_entryFlags));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryGroup.get(unit, src, &entryDe_entryGroup));
            if (entryDe_entryFlags & _BCM_DPP_FIELD_ENTRY_IN_USE) {
                result = _bcm_dpp_field_dir_ext_entry_alloc(unitData,
                                                            entryDe_entryGroup,
                                                            TRUE,
                                                            &dst);
                if (BCM_E_NONE == result) {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryGroup.get(unit, src, &entryDe_entryGroup));
                    _bcm_dpp_field_dir_ext_entry_copy_id(unitData, dst, src);
                    result = _bcm_dpp_field_dir_ext_entry_add_to_group(unitData,
                                                                       entryDe_entryGroup,
                                                                       dst);
                }
            } else { /* if (source entry is in use) */
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d is not in use\n"),
                           unit,
                           src_entry));
                result = BCM_E_NOT_FOUND;
            } /* if (source entry is in use) */
        } else { /* if (dst_entry is a DirExt entry) */
            result = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is Direct Extraction but"
                                  " entry %d is not Direct Extraction\n"),
                       unit,
                       src_entry,
                       dst_entry));
        } /* if (dst_entry is a DirExt entry) */
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit,
                   src_entry));
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%d) return %d (%s)\n"),
               unit,
               src_entry,
               dst_entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_install
 *   Purpose
 *      Install a field entry to the hardware
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID to destroy
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      This causes an error if the entry is already in hardware.
 *
 *      If the entry does not yet have a hardware priority (this is not a BCM
 *      layer priority) assigned, the entire group hardware priorities will be
 *      recalculated and new values assigned, and all entries in hardware
 *      already will be adjusted approprately.
 */
int
bcm_petra_field_entry_install(int unit,
                              bcm_field_entry_t entry)
{
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    _DPP_FIELD_COMMON_LOCALS;
    uint8 is_second_pass;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"), unit, entry));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));

    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;
    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry) && (soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE))) {
        is_second_pass = _BCM_DPP_FIELD_ENTRY_IS_PRESEL_STAGGERED(entry);
        result = _bcm_dpp_field_presel_install(unitData, entry, is_second_pass);
    } else if (_BCM_DPP_FIELD_ENTRY_IS_LARGE_DIRECT_LOOKUP(entry)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                        (_BSL_BCM_MSG("This API is not supportd by large direct lookup advanced mode.")));
    } else if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        /*
         * ARAD Only: 
         * The entry_install method determines the order of the entries in the 
         * HW in case of similar priorities. 
         * Since there is no priority management in the SW, if several entries 
         * are created and then installed in different order of their creation, 
         * then the installation order will be the one to determine which is first. 
         * Same goes for prio_set - if the same priority is configured for several 
         * entries, in an order that's different than the order of their creation, 
         * then the new order will be according to the prio_set order, and the 
         * order in the HW will be according to the order the entry_install 
         * was called. 
         */ 
        result = _bcm_dpp_field_tcam_entry_install(unitData,
                                                   _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                   _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                   NULL);
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                entry))  {
        result = _bcm_dpp_field_dir_ext_entry_install(unitData,
                                                      entry -
                                                      _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt));
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"), unit, entry));
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_install_and_handler_update
 *   Purpose
 *      Install a field entry to the large direct hardware
 *   Parameters
 *      (in)  int unit = the unit number
 *      (in)  bcm_field_entry_t entry = the entry ID to install
 *      (out) bcm_field_entry_t large_dt_entry = large direct lookup entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      This causes an error if the entry is already in hardware.
 *
 *      If the entry does not yet have a hardware priority (this is not a BCM
 *      layer priority) assigned, the entire group hardware priorities will be
 *      recalculated and new values assigned, and all entries in hardware
 *      already will be adjusted approprately.
 */
int
bcm_petra_field_entry_install_and_handler_update(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_entry_t *large_dt_entry)
{
    _DPP_FIELD_COMMON_LOCALS;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit, "(%d,%d) enter\n"), unit, entry));

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    if (!SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("This API is valid only for Jericho and above")));
    }

    if (!large_dt_entry) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Obligatory out argument is NULL")));
    }

    if (SOC_DPP_JER_CONFIG(unit)->pp.kaps_mgmt_advanced_mode == FALSE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("This API is valid only for large direct lookup advanced mode")));
    }

    if (_BCM_DPP_FIELD_ENT_IS_INTTCAM(unit, entry)) {
        result = _bcm_dpp_field_tcam_entry_install(unitData,
                                           _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry),
                                           _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                           large_dt_entry);
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP, (BSL_META_U(unit, "unit %d entry %d is not valid\n"), unit, entry));
    }

    LOG_DEBUG(BSL_LS_BCM_FP, (BSL_META_U(unit, "(%d,%d) return %d (%s)\n"), unit, entry, result, _SHR_ERRMSG(result)));

    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_reinstall
 *   Purpose
 *      Reinstall a field entry to the hardware
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID to destroy
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      This does the same thing as entry install.  Somewhere in the API docs
 *      it claims this behaves differently (this should fail if the entry is
 *      not installed; install should fail if the entry is already installed),
 *      but the DVAPI tests steadfastly insist that both install and reinstall
 *      can be used successfully in either situation.
 */
int
bcm_petra_field_entry_reinstall(int unit,
                                bcm_field_entry_t entry)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(bcm_petra_field_entry_install(unit, entry));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_remove
 *   Purpose
 *      Remove a field entry from the hardware
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID to destroy
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      The API doc indicates that this can only be used against an entry that
 *      is already in hardware, but the regression tests require that it work
 *      even if the entry isn't in hardware.
 */
int
bcm_petra_field_entry_remove(int unit,
                             bcm_field_entry_t entry)
{
    int dpp_field_unit_lock_was_taken ;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    bcm_field_entry_t entry_input;
    uint32 entryFlags;
    _bcm_dpp_field_grp_idx_t group, groupLimit;
    _bcm_dpp_field_ent_idx_t new_entry;
    uint32 num;
    
    _DPP_FIELD_COMMON_LOCALS;
    BCMDNX_INIT_FUNC_DEFS;

    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"), unit, entry));

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupLimit.get(unit, &groupLimit));

    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1 ;
    
    entry_input = entry & (~BCM_FIELD_ENTRY_KEEP_LOCATION);

    if (_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_input)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API is not supported for External TCAM")));
    }
        if (_BCM_DPP_FIELD_ENTRY_IS_LARGE_DIRECT_LOOKUP(entry_input)) {
            BCM_FIELD_LARGE_DIRECT_ENTRY_ID_UNPACK(entry_input, group, new_entry);

            if (!_BCM_DPP_FIELD_ENT_IS_KAPS_ADVANCED_MODE(unit, group)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG("This entry 0x%x group %d key 0x%x should work in large direct lookup advanced mode."), entry_input, group, new_entry));
            }
            result = _bcm_dpp_field_tcam_entry_remove(unitData,
                                                      FALSE,
                                                      entry_input);
        } else if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry_input)) {
        /*
         * support TCAM entry keep hardware location mode.
         */
        if (entry & BCM_FIELD_ENTRY_KEEP_LOCATION) {
            _BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit, _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_input), entry_input, entryFlags);
            entryFlags |= _BCM_DPP_FIELD_ENTRY_KEEP_LOCATION;
            _BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_SET(unit, _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_input), entry_input, entryFlags);
            
            BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_GROUP_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_input), entry_input, group)) ;
            if (groupLimit <= group) {
                BCMDNX_ERR_EXIT_VERB_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG("Error: entry doesn't belong to any group")));
            }

            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.num_entry_in_keep_location.get(unit, group, &num));
            num = num + 1;
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.num_entry_in_keep_location.set(unit, group, num));            
        }
        
        result = _bcm_dpp_field_tcam_entry_remove(unitData,
                                                  FALSE,
                                                  entry_input);
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry_input) &&
               ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                 entry_input))  {
        result = _bcm_dpp_field_dir_ext_entry_remove(unitData,
                                                     entry_input -
                                                     _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt));
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"), unit, entry_input));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               entry_input,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken)
    {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_prio_get
 *   Purpose
 *      Get the priority of a specific entry (within its group)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (out) int *prio = where to put the entry's priority
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      The field entry identifier is NOT the priority of the entry in the
 *      group on in the system.
 *      Priority is signed; nonnegative numbers are priority order; negative
 *      numbers have special meanings.
 *      Overall sort is:
 *          highest >= numbered >= dontcare >= lowest
 */
int
bcm_petra_field_entry_prio_get(int unit,
                               bcm_field_entry_t entry,
                               int *prio)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t ent = 0;
    _bcm_dpp_field_ent_idx_t entryDeLimit;

    uint32 flags = 0;
    int entPrio = 0;
    SOC_PPC_FP_ENTRY_INFO entInfo;
    uint8 found = 0;
    uint32 soc_sand_rv = 0;
    _bcm_dpp_field_grp_idx_t groupLimit;
    int dpp_field_unit_lock_was_taken  = 0;
    _bcm_dpp_field_grp_idx_t group;
    uint32 groupFlags;
    bcm_field_group_mode_t grpMode; 
    BCMDNX_INIT_FUNC_DEFS;

    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) enter\n"), unit, entry));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!prio) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("Obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));

    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1 ;

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        ent = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry);
        /*
         * Was:
         *   flags = _BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent);
         *   group = _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent);
         */
        BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent, flags)) ;
        BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_GROUP_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent, group)) ;
        BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));

        if (group >= groupLimit) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d: Entry with ID=%d is not installed.\n"), unit, entry));
            BCM_RETURN_VAL_EXIT(BCM_E_NOT_FOUND);
        }
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.get(unit, group, &grpMode));
        if (groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,(_BSL_BCM_MSG_NO_UNIT("unit %d group %d entries by key doesn't have priority "),unit,
            /*
             * Was:
             *                                 _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent) ;
             */
                                               group ));
        }
        /* if entry is in HW, get priority from SOC level. otherwise from SW state (also for Direct table entries in HW). */
        if ((flags & _BCM_DPP_FIELD_ENTRY_IN_HW) && (grpMode != bcmFieldGroupModeDirect)) {
            uint32 locHwHandle ;  /* entry handle in hardware */

            SOC_PPC_FP_ENTRY_INFO_clear(&entInfo);
            BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_HW_HANDLE_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent, locHwHandle)) ;
            soc_sand_rv = soc_ppd_fp_entry_get(unitData->unitHandle,
                                               group,
                                               /*
                                                * Was:
                                                *   _BCM_DPP_FIELD_TCAM_ENTRY_HW_HANDLE(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent),
                                                */
                                               locHwHandle,
                                               &found,
                                               &entInfo);
            result = handle_sand_result(soc_sand_rv);
            if (BCM_E_NONE == result) {
                if (found) {
                    entPrio = BCM_FIELD_ENTRY_BCM_PRIO_TO_DPP_PRIO(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), entInfo.priority);
                }
                else {
                    result = BCM_E_NOT_FOUND;
                    LOG_VERBOSE(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d entry %d not valid\n"), unit, entry));
                }
            }
        }
        else {
            /*
             * Was:
             *   entPrio = _BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent);
             */
            _BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent, entPrio) ;
        }
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                 entry))  {
        ent = entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryFlags.get(unit, ent, &flags));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryPriority.get(unit, ent, &entPrio));
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_VERBOSE(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d not valid\n"), unit, entry));
    }
    if (BCM_E_NONE == result) {
        if (flags & _BCM_DPP_FIELD_ENTRY_IN_USE) {
            *prio = entPrio;
        } else {
            result = BCM_E_NOT_FOUND;
            LOG_VERBOSE(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d not in use\n"),
                       unit,
                       entry));
        }
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, &(%d)) return %d (%s)\n"),
               unit,
               entry,
               *prio,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_VERB_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken)
    {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_prio_set
 *   Purpose
 *      Set the priority of a specific entry (within its group)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) int prio = the entry's new priority
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      The field entry identifier is NOT the priority of the entry in the
 *      group on in the system.
 *      Priority is signed; nonnegative numbers are priority order; negative
 *      numbers have special meanings. Overall sort is:
 *          highest >= numbered >= dontcare >= lowest
 *
 *      This will invalidate the hardware priority assigned to the entry (if
 *      one has been assigned already) and mark the group as containing 'new'
 *      entries, and so will eventually cause a phase change and refresh for
 *      the group.
 */
int
bcm_petra_field_entry_prio_set(int unit,
                                bcm_field_entry_t entry,
                                int prio)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t ent;
    int max_entry_priorities;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    int dpp_field_unit_lock_was_taken ;
    _bcm_dpp_field_grp_idx_t group, groupLimit;
    int maxEntryPriorities;
    uint32 groupFlags;
    uint32 entryDe_entryFlags;
    _bcm_dpp_field_grp_idx_t entryDe_entryGroup;
    uint32 num;
    uint32 hwPriority;

    BCMDNX_INIT_FUNC_DEFS;

    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, %d) enter\n"), unit, entry, prio));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (0 > prio) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("negative priority is not supported")));
    }
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1 ;

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        uint32 flags;

        ent = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry);   
        /* 
        * Was:
        *   group = _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent);
        */
        BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_GROUP_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent, group)) ;
        if (groupLimit <= group) {
            BCMDNX_ERR_EXIT_VERB_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("Error: entry doesn't belong to any group")));
        }

        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.maxEntryPriorities.get(unit, group, &maxEntryPriorities));
        if (groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,(_BSL_BCM_MSG_NO_UNIT("unit %d group %d entries by key doesn't have priority "),unit,
            /*
             * Was:
             *                                    _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent)
             */
                                               group));
        }
        max_entry_priorities = maxEntryPriorities;
        
        /*
         * Check all entries of this group, exit if any entry set _BCM_DPP_FIELD_ENTRY_KEEP_LOCATION flag.
         * Do not support this operation for field group after removing entry with keep_location.
         */
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.num_entry_in_keep_location.get(unit, group, &num));
        if (num > 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Setting entry priority when one or more field group's entries in keep_location mode is not supported")));
        }

        BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent, flags)) ;
        if (flags & _BCM_DPP_FIELD_ENTRY_KEEP_LOCATION) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Setting entry priority in keep_location mode is not supported")));
        }

        /*
         * was:
         *   if (_BCM_DPP_FIELD_ENTRY_IN_USE & _BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent))
        */
        if (_BCM_DPP_FIELD_ENTRY_IN_USE & flags) {
            if (_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry) && (max_entry_priorities > 0)) {
                if (prio > max_entry_priorities) {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d entry %d priority is out of group's priority range\n"),
                               unit,
                               entry));
                    result = BCM_E_PARAM;
                }
            }
            if (result == BCM_E_NONE) {
                _bcm_dpp_field_grp_idx_t entryGroup;        /* this entry's group */

                /*
                 * was:
                 *   priority = _BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY_PTR(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent);
                 *   *priority = prio;
                 */
                if (!SOC_WARM_BOOT(unit)) {  /*Warm boot -  Do not allocate sw-state resources */
                    _BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY_SET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent, prio) ;
                    /* Set for hardware priority */                    
                    if (_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry) && (max_entry_priorities > 0)) {
                        hwPriority = max_entry_priorities - prio ;
                        _BCM_DPP_FIELD_TCAM_ENTRY_HW_PRIORITY_SET(unit, _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent, hwPriority) ;
                    } else {
                        hwPriority = BCM_FIELD_ENTRY_BCM_PRIO_TO_DPP_PRIO(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), prio);
                        _BCM_DPP_FIELD_TCAM_ENTRY_HW_PRIORITY_SET(unit, _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent, hwPriority) ;
                    }
                }
                BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_GROUP_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent, entryGroup)) ;
                result = _bcm_dpp_field_tcam_entry_add_to_group(unitData,
                                                                /*
                                                                 * Was:
                                                                 *   _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent),
                                                                 */
                                                                entryGroup,
                                                                ent);
            }
        } else {
            LOG_VERBOSE(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is not in use\n"),
                       unit,
                       entry));
            result = BCM_E_NOT_FOUND;
        }
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                entry))  {
        ent = entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryFlags.get(unit, ent, &entryDe_entryFlags));
        if (_BCM_DPP_FIELD_ENTRY_IN_USE & entryDe_entryFlags) {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryPriority.set(unit, ent, prio));
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryGroup.get(unit, ent, &entryDe_entryGroup));
            if (groupLimit <= entryDe_entryGroup) {
                BCMDNX_ERR_EXIT_VERB_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG("Error: entry doesn't belong to any group")));
            }

            result = _bcm_dpp_field_dir_ext_entry_add_to_group(unitData,
                                                               entryDe_entryGroup,
                                                               ent);
        } else {
            LOG_VERBOSE(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is not in use\n"),
                       unit,
                       entry));
            result = BCM_E_NOT_FOUND;
        }
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_VERBOSE(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d not valid\n"), unit, entry));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, %d) return %d (%s)\n"),
               unit,
               entry,
               prio,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken)
    {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 *   Function
 *      bcm_petra_field_action_config_add
 *   Purpose
 *      Add action core specific parameters to a specified entry. 
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_field_action_t action = the action to add
 *      (in) int action_key =  action key for additional configuration
 *      (in) int core_config_arr_len = num of elements in core_config
 *      (in) bcm_field_action_core_config_t core_config = action per core configurations
 *
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes:
 *     The following actions are NOT supported on this procedure, on egress,
 *     for ARAD:
 *       bcmFieldActionStat
 *     For ARAD, use bcm_field_action_add() instead.
 */
int
   bcm_petra_field_action_config_add(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    int core_config_arr_len, 
    bcm_field_action_core_config_t *core_config_arr)
{

    _DPP_FIELD_COMMON_LOCALS;

    int core_iter;
    int core_id;
    uint8 isExternalTcam ;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),%d) enter\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               core_config_arr_len));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    isExternalTcam = _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry) ;
    /*
     * The following actions are not supported on this utility for ARAD (on egress):
     *   bcmFieldActionStat
     * User should use the older interface - bcm_petra_field_action_add()
     *
     * This is so because of new capabilities added to PPDB_A_TCAM_ACTION on JERICHO.
     * See corresponding actions on _bcm_dpp_field_tcam_entry_action_update()
     */
    if ((SOC_IS_ARADPLUS_AND_BELOW(unit))) {
        _bcm_dpp_field_grp_idx_t entryGroup ;
        _bcm_dpp_field_stage_idx_t stage ;
        SOC_PPC_FP_DATABASE_STAGE soc_stage;

        BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_GROUP_GET(unit,isExternalTcam, entry, entryGroup)) ;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, entryGroup, &stage)) ;
        soc_stage = _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage).hwStageId ;
        if (SOC_PPC_FP_DATABASE_STAGE_EGRESS == soc_stage) {
            if (action == bcmFieldActionStat) {
                LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                              "unit %d - This action %d (%s) is not supported on this utility (%s) on egress\r\n"
                              "Use bcm_field_action_add()\r\n"),
                     unit,
                     action,_bcm_dpp_field_action_name[action],__func__
                )) ;
                result = BCM_E_PARAM ;
            }
        }
    }
    if (result == BCM_E_NONE) {
        _DPP_FIELD_UNIT_LOCK(unitData);
        dpp_field_unit_lock_was_taken = 1;

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_action_config_add_verify_params(unit, entry, action, core_config_arr_len, core_config_arr));

        if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) 
        {
                for (core_iter = 0 ; core_iter < core_config_arr_len; core_iter++)
                {
                    /* If core_config_arr_len == 1 - we configure all the cores in the same way */
                    core_id = (core_config_arr_len == 1) ?  SOC_CORE_INVALID : core_iter ; 
 
                    result = _bcm_dpp_field_tcam_entry_action_set(unitData,
                                                                  isExternalTcam, 
                                                                  core_id,
                                                                  _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                                  action,
                                                                  core_config_arr[core_iter].param0,
                                                                  core_config_arr[core_iter].param1,
                                                                  core_config_arr[core_iter].param2,
                                                                  core_config_arr[core_iter].param3);
                    BCMDNX_IF_ERR_EXIT(result);
                }
        } else {
            result = BCM_E_NOT_FOUND;
            LOG_VERBOSE(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d not valid for this function\n"),
                       unit,
                       entry));
        }

    }
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),%d) return %d (%s)\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               core_config_arr_len,
               result,
               _SHR_ERRMSG(result)));
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_action_config_get
 *   Purpose
 *      Get action core specific parameters from a specified entry.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_field_action_t action = the action to add
 *      (in) int action_key =  action key for additional configuration
 *      (in) int core_config_arr_len = num of elements in core_config
 *      (in) bcm_field_action_core_config_t core_config = action per core configurations
 *
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 */
int
   bcm_petra_field_action_config_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_action_t action,
    int core_config_arr_len,
    bcm_field_action_core_config_t *core_config_arr)
{
    int dpp_field_unit_lock_was_taken = 0;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    if ((SOC_IS_ARADPLUS_AND_BELOW(unit))) {
        _bcm_dpp_field_grp_idx_t entryGroup ;
        _bcm_dpp_field_stage_idx_t stage ;
        SOC_PPC_FP_DATABASE_STAGE soc_stage;

        BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_GROUP_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), entry, entryGroup)) ;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, entryGroup, &stage)) ;
        soc_stage = _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage).hwStageId ;
        if (SOC_PPC_FP_DATABASE_STAGE_EGRESS == soc_stage) {
            if (action == bcmFieldActionStat) {
                LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                              "unit %d - This action %d (%s) is not supported on this utility (%s) on egress\r\n"
                              "Use bcm_field_action_add()\r\n"),
                     unit,
                     action,_bcm_dpp_field_action_name[action],__func__
                )) ;
                result = BCM_E_PARAM ;
            }
        }
    }

    if (result == BCM_E_NONE) {
        _DPP_FIELD_UNIT_LOCK(unitData);
        dpp_field_unit_lock_was_taken = 1;

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_action_config_add_verify_params(unit, entry, action, core_config_arr_len, core_config_arr));

        if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry))
        {
            result = _bcm_dpp_field_tcam_entry_action_get(unitData,
                                                          entry,
                                                          action,
                                                          (uint32 *)&core_config_arr[0].param0,
                                                          (uint32 *)&core_config_arr[0].param1,
                                                          (uint32 *)&core_config_arr[0].param2,
                                                          (uint32 *)&core_config_arr[0].param3);
            BCMDNX_IF_ERR_EXIT(result);

        } else {
            result = BCM_E_NOT_FOUND;
            LOG_VERBOSE(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d not valid for this function\n"),
                       unit,
                       entry));
        }

    }

exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }

#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif

    BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_field_action_config_add_verify_params(int unit, 
                                               bcm_field_entry_t entry, 
                                               bcm_field_action_t action, 
                                               int core_config_arr_len, 
                                               bcm_field_action_core_config_t *core_config_arr)

{


    int cores_num;
    int i;
    int stat_id;
    uint32 stat_id_mask, ace_pointer_prge_var_nof_bits=10,ace_pointer_prge_var_in_stat_id_lsb;

    BCMDNX_INIT_FUNC_DEFS;

    cores_num = SOC_DPP_DEFS_GET(unit, nof_cores);

    if (!core_config_arr)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("core_config_arr is NULL")));
    }
    if (core_config_arr_len < 1)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("core_config_arr_len has to be greater than 0")));
    }


    if (core_config_arr_len > 1 && cores_num != core_config_arr_len)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("core_config_arr_len can not be greater than one and not equal to the device core's number")));
    }


    /* actions with special care */
    switch (action)
    {
        case bcmFieldActionStat:
                if (core_config_arr_len != cores_num)
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("bcmFieldActionStat requires params to be core specific")));
                }
                stat_id = core_config_arr[0].param0;
                for ( i = 1; i< cores_num; i++) 
                {
                    ace_pointer_prge_var_in_stat_id_lsb = (_SHR_FIELD_CTR_PROC_SHIFT_GET(core_config_arr[i].param0) - ace_pointer_prge_var_nof_bits);
                    SHR_BITSET_RANGE(&stat_id_mask, ace_pointer_prge_var_in_stat_id_lsb, ace_pointer_prge_var_nof_bits);
                    if ((core_config_arr[i].param0 & (~stat_id_mask)) != (stat_id & (~stat_id_mask)))
                    {
                                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("bcmFieldActionStat requires param0 to be the same value in all cores")));
                    }
                }
                break; 
        case bcmFieldActionForwardingTypeNew:
                if (core_config_arr_len != 1)
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("Only one core should be configured, params are copied to any others")));
                }
                break;
        default:
            return BCM_E_NONE;
    }

    exit:
    #if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
        _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    #endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
        BCMDNX_FUNC_RETURN;
}
/*
 * API utilities related to control of action width
 * {
 */
/*
 * Convert PPD-level (internal) stage to BCM stage.
 * Note that, currently, it works only for 4 internal stages:
 *   SOC_PPC_FP_DATABASE_STAGE_INGRESS_PMF
 *   SOC_PPC_FP_DATABASE_STAGE_EGRESS
 *   SOC_PPC_FP_DATABASE_STAGE_INGRESS_FLP
 *   SOC_PPC_FP_DATABASE_STAGE_INGRESS_SLB
 * See:
 *   _bcm_arad_field_stage_info[], bcm_petra_field_stage_info_get(),
 *   _bcm_arad_field_device_info
 */
/* static */
  int 
    _bcm_dpp_field_internal_stage_to_bcm_stage(
      int unit,
      SOC_PPC_FP_DATABASE_STAGE internal_stage,
      bcm_field_stage_t         *bcm_stage) 
{
    _DPP_FIELD_COMMON_LOCALS;
    int
      stage_idx,
      found,
      num_bcm_stages ;
  
    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    LOG_DEBUG(
      BSL_LS_BCM_FP,
      (BSL_META_U(
        unit,
        "(%d, *) enter\n"), unit)
    ) ;
    BCM_DPP_UNIT_CHECK(unit) ;
    BCMDNX_NULL_CHECK(bcm_stage) ;
    found = FALSE ;
    /*
     * Get maximal number of stages supported by this system. See _bcm_arad_field_device_info
     * and _bcm_arad_field_stage_info[]
     */
    num_bcm_stages = _bcm_arad_field_get_num_stages() ;
    if (num_bcm_stages > bcmFieldStageCount) {
        num_bcm_stages = bcmFieldStageCount ;
    }
    /*
     * Note that, actually, the loop shopuld run till 'bcmFieldStageCount' but
     * info is really supplied only till 'num_bcm_stages'.
     */
    for (stage_idx = 0 ; stage_idx < num_bcm_stages ; stage_idx++) {
      if (internal_stage == _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage_idx).hwStageId) {
        found = TRUE ;
        break ;
      }
    }
    if (!found) {
      result = _SHR_E_NOT_FOUND ;
      BCMDNX_IF_ERR_EXIT(result) ;
    }
    *bcm_stage = _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage_idx).bcmStage ;

exit:
    BCMDNX_FUNC_RETURN ;
}
/*
 *   Function
 *      bcm_petra_field_internal_to_bcm_action_map
 *   Purpose
 *      Given low level action, get the BCM actions and stages which use it.
 *   Parameters
 *      (in)  int unit =
 *              The unit number
 *      (in)  uint32 flags =
 *              Control flags.
 *                Currently not in use.
 *      (in)  int internal_action =
 *              Identifier of the low level action to get corresponding
 *              list of BCM actions which use it.
 *      (in)  uint32 bcm_action_size =
 *              Maximal number of array elements in '*bcm_action_stage'.
 *      (out) bcm_field_internal_to_bcm_map_t *bcm_action_stage =
 *              Array of corresponding BCM actions and stages. To be filled by this
 *              procedure.
 *      (out) uint32 *bcm_action_size_actual =
 *              To be loaded by this procedure by the actual number of
 *              valid elements loaded into '*bcm_action_stage'. If 'bcm_action_size'
 *              is too small to load all relevant BCM actions and stages, then
 *              '*bcm_action_size_actual' is loaded by '-1' (INTERNAL_TO_BCM_ACTION_NO_SPACE).
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *     No direct hardware changes.
 *
 *     Note that input 'internal_action' is of the lower level type, SOC_PPC_FP_ACTION_TYPE,
 *     closer to HW. Each such action may be used for implementation of
 *     many BCM level action (bcm_field_action_t, which is more of a 'logical'
 *     type). SOC_PPC_FP_ACTION_TYPE is documented in the User's Manual.
 *     Values may differ from one device to another.
 *
 *     See _bcm_dpp_field_ppd_to_bcm_actions(), _bcm_dpp_field_internal_stage_to_bcm_stage(),
 *     _bcm_arad_field_action_info[]
 */
int
bcm_petra_field_internal_to_bcm_action_map(
  int unit,
  uint32 flags,
  int    internal_action, 
  uint32 bcm_action_size,
  bcm_field_internal_to_bcm_map_t *bcm_action_stage,
  uint32 *bcm_action_size_actual)
{
    _DPP_FIELD_COMMON_LOCALS;
    bcm_field_stage_t
      bcm_stage ;
    bcm_field_internal_to_bcm_map_t
      *loc_bcm_action_stage ;
    SOC_PPC_FP_DATABASE_STAGE
      ppd_stage ;
    int
      element,
      num_loaded_bcm_action_stage,
      num_elements,
      out_num_elements=0 ;
    bcm_field_action_t
      *bcm_action ;
    bcm_field_action_t
      *loc_bcm_action ;

    BCMDNX_INIT_FUNC_DEFS ;
    bcm_action = NULL ;
    _DPP_FIELD_UNIT_CHECK(unit, unitData) ;
    *bcm_action_size_actual = 0 ;
    BCMDNX_ALLOC(bcm_action,(sizeof(*bcm_action) * bcm_action_size),"BCM actions temporary container") ;
    if (!bcm_action) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY,(_BSL_BCM_MSG("No available workspace memory\r\n"))) ;
    }
    loc_bcm_action = bcm_action ;
    loc_bcm_action_stage = bcm_action_stage ;
    num_loaded_bcm_action_stage = 0 ;
    for (ppd_stage = SOC_PPC_FP_DATABASE_STAGE_INGRESS_PMF ; ppd_stage < SOC_PPC_NOF_FP_DATABASE_STAGES_ARAD ; ppd_stage++) {
      /*
       * Get BCM stage related to ppd_stage.
       */
      BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_internal_stage_to_bcm_stage(unit,ppd_stage,&bcm_stage)) ;
      num_elements = (int)bcm_action_size - num_loaded_bcm_action_stage ;
      BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_ppd_to_bcm_actions(
            unitData,ppd_stage,internal_action,
            num_elements,loc_bcm_action,(uint32 *)&out_num_elements),
            (_BSL_BCM_MSG(
                "\r\n"
                " ==>Probably, too few array elements (bcm_action_size %d) supplied by caller\r\n"),bcm_action_size)) ;
      /*
       * At this point, all corresponding BCM action are loaded into bcm_action[]
       */
      if ((num_loaded_bcm_action_stage + out_num_elements) > bcm_action_size) {
        /*
         * There is no space on input 'bcm_action_stage' for the new pack of BCM actions.
         * Quit with error.
         */
        *bcm_action_size_actual = INTERNAL_TO_BCM_ACTION_NO_SPACE ;
        BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE,
            (_BSL_BCM_MSG(
                "\r\n"
                "No workspace on input memory. Too few array elements (bcm_action_size %d) supplied by caller\r\n"),bcm_action_size)) ;
      }
      /*
       * At this point, there is space for new BCM actions to be loaded into bcm_action[]
       * Now fill bcm_action_stage[]
       */
      for (element = 0 ; element < out_num_elements ; element++) {
        loc_bcm_action_stage->bcm_action = *loc_bcm_action++ ;
        loc_bcm_action_stage->bcm_stage = bcm_stage ;
        loc_bcm_action_stage++ ;
      }
      num_loaded_bcm_action_stage += out_num_elements ;
    }
    *bcm_action_size_actual = num_loaded_bcm_action_stage ;
    LOG_DEBUG(
      BSL_LS_BCM_FP,
        (BSL_META_U(
          unit,
          "(%d,%s(%d),%d) return %d (%s)\n"),
          unit,
          ((0 <= internal_action) && (SOC_PPC_NOF_FP_ACTION_TYPES > internal_action))?SOC_PPC_FP_ACTION_TYPE_to_string(internal_action):"???",
          internal_action,
          bcm_action_size,
          result,
          _SHR_ERRMSG(result)
    )) ;
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCM_FREE(bcm_action) ;
    BCMDNX_FUNC_RETURN;
}
/*
 *   Function
 *      bcm_petra_field_action_width_set
 *   Purpose
 *      Set new width (in bits) to a specific action. Width
 *      may be required to be the default value.
 *   Parameters
 *      (in) int unit =
 *             The unit number
 *      (in) uint32 flags =
 *             Control flags.
 *               If BIT(bcm_default_action_width) is set then
 *               ignore 'width' and set action runtime width to its
 *               default value.
 *               See bcm_field_action_width_t. See SAL_BIT().
 *      (in) int internal_action =
 *             Identifier of the action to change the width of.
 *      (in) uint32 width =
 *             Number of bits to assign to specified 'internal_action'.
 *             See 'Notes' below. See 'flags'.
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *     No direct hardware changes.
 *
 *     Width may not exceed the inital (default) value. It
 *     may only be set smaller than initial value. See
 *     bcm_field_action_width_get() on how to get the initial/deafult
 *     value.
 *     Initial values are in:
 *       Jericho_pmf_fem_action_type_encoding
 *       Arad_plus_pmf_fem_action_type_encoding
 *       Arad_pmf_fem_action_type_encoding
 *
 *     Setting a new width to an action which is already in use in
 *     any data base will be refused by this procedure (unless the new
 *     width is equal to the one currently being used). All data bases
 *     containing this action must first be destroyed before action
 *     width is changed.
 *
 *     Note that 'internal_action' is of the lower level type, SOC_PPC_FP_ACTION_TYPE,
 *     closer to HW, rather than BCM level action (bcm_field_action_t) which
 *     is more of a 'logical' type It is documented in the User's Manual.
 *     Values may differ from one device to another so not all actions are
 *     legitimate input: Action must be on one of the three 'initial values'
 *     tables above.
 *
 *     See:
 *       arad_pmf_fem_action_type_array_size_get_unsafe(),
 *       arad_pmf_fem_action_type_array_element_default_get_unsafe(),
 *       arad_pmf_fem_action_type_array_element_get_unsafe(),
 *       arad_pmf_fem_action_width_set_unsafe()
 */
int
bcm_petra_field_action_width_set(
  int unit,
  uint32 flags,
  int internal_action, 
  uint32 width)
{
  uint32 db_identifier ;
  uint32 default_width ;
  BCMDNX_INIT_FUNC_DEFS;

  /*
   * This API is not supported for devices below Jericho Plus
   */
  if ((!SOC_IS_JERICHO_PLUS(unit) || SOC_IS_QAX(unit)) 
    && !soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "reduced_action_support", 0)) {
    LOG_WARN(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "Unit %d : bcm_field_action_width_set is "
                                 " not supported for the current device \n"),
                      unit));
    return BCM_E_UNAVAIL;
  }
  /*
   * Get the DEFAULT value and make sure requested 'width' is not larger than default value.
   */
  BCMDNX_IF_ERR_EXIT_MSG(
    arad_pmf_fem_action_width_default_get(unit,internal_action,&default_width),
    (_BSL_BCM_MSG(
      "\r\n"
      " ==> Unable to get default action_width for action %s\r\n"
      " ==> Failed on arad_pmf_fem_action_width_default_get()"),
      SOC_PPC_FP_ACTION_TYPE_to_string(internal_action))) ;
  if ((int)default_width < 0) {
    BCMDNX_ERR_EXIT_MSG(
      BCM_E_PARAM,
      (_BSL_BCM_MSG(
        "\r\n"
        "Input internal_action (%d) is could not be found on default table. Quit with error.\r\n"),internal_action)
    ) ;
  }
  if (width > default_width) {
    BCMDNX_ERR_EXIT_MSG(
      BCM_E_PARAM,
      (_BSL_BCM_MSG(
        "\r\n"
        "Input width (%d) is larger than default width (%d). Quit with error.\r\n"),width,default_width)
    ) ;
  }
  if (flags & SAL_BIT(bcm_default_action_width)) {
    /*
     * If 'flag' so indicates, set DEFAULT width and ignore original input 'width'.
     */ 
    width = default_width ;
  }
  BCMDNX_IF_ERR_EXIT_MSG(
    arad_pmf_fem_action_width_set_unsafe(unit,internal_action,width,&db_identifier),
    (_BSL_BCM_MSG(
      "\r\n"
      " ==> unable to set new action_width for action %s probably because it already resides on DB %d\r\n"
      " ==> Failed on arad_pmf_fem_action_width_set_unsafe()"),
      SOC_PPC_FP_ACTION_TYPE_to_string(internal_action),db_identifier)) ;
exit:
  BCMDNX_FUNC_RETURN;
}
/*
 *   Function
 *      bcm_petra_field_action_width_get
 *   Purpose
 *      Get current width (in bits) set to a specific action
 *      or
 *      Get default width (in bits) of a specific action
 *   Parameters
 *      (in)  int unit =
 *              The unit number
 *      (in)  uint32 flags =
 *              Control flags.
 *                If BIT(bcm_default_action_width) is set then load
 *                '*width' by the default value for that 'internal_action'.
 *                See bcm_field_action_width_t. See SAL_BIT().
 *      (in)  int internal_action =
 *              Identifier of the action to get the width of. See Notes.
 *      (out) uint32 *width_p =
 *              '*width_p' is loaded by the  number of bits currently
 *              assigned to specified 'internal_action' (= runtime value).
 *              See 'flags' above.
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *     No direct hardware changes.
 *
 *     Width may not exceed the inital (default) value. It
 *     may only be set smaller than initial value.
 *
 *     See also  bcm_petra_field_action_width_set()
 *
 *     Initial values are in:
 *       Jericho_pmf_fem_action_type_encoding
 *       Arad_plus_pmf_fem_action_type_encoding
 *       Arad_pmf_fem_action_type_encoding
 *     
 *     Note that 'internal_action' is of the lower level type, SOC_PPC_FP_ACTION_TYPE,
 *     closer to HW, rather than BCM level action (bcm_field_action_t) which
 *     is more of a 'logical' type. It is documented in the User's Manual.
 *     Values may differ from one device to another so not all actions are
 *     legitimate input: Action must be on one of the three 'initial values'
 *     tables above.
 *
 *     See:
 *       arad_pmf_fem_action_type_array_size_get_unsafe(),
 *       arad_pmf_fem_action_type_array_element_default_get_unsafe(),
 *       arad_pmf_fem_action_type_array_element_get_unsafe(),
 *       arad_pmf_fem_action_width_set_unsafe()
 */
int
bcm_petra_field_action_width_get(
  int unit, 
  uint32 flags,
  int internal_action, 
  uint32 *width_p)
{
    uint32 loc_hw_id ;
    BCMDNX_INIT_FUNC_DEFS;
   /*
   * This API is not supported for devices below Jericho Plus
   */
    if ((!SOC_IS_JERICHO_PLUS(unit) || SOC_IS_QAX(unit))
     && !soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "reduced_action_support", 0)) {
        LOG_WARN(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "Unit %d : bcm_field_action_width_get is "
                                     " not supported for the current device \n"),
                          unit));
        return BCM_E_UNAVAIL;
    }
    
    if (flags & SAL_BIT(bcm_default_action_width)) {
      /*
       * If 'flag' so indicates, set DEFAULT width.
       */ 
      BCMDNX_IF_ERR_EXIT_MSG(arad_pmf_fem_action_width_default_get(unit,internal_action,width_p),
                        (_BSL_BCM_MSG("unable to get action_width - arad_pmf_fem_action_width_default_get"))) ;
    } else {
      BCMDNX_IF_ERR_EXIT_MSG(arad_pmf_fem_action_width_get_unsafe(unit,internal_action,width_p,&loc_hw_id),
                        (_BSL_BCM_MSG("unable to get action_width - arad_pmf_fem_action_width_get_unsafe"))) ;
    }
    if ((int)(*width_p) < 0) {
      BCMDNX_ERR_EXIT_MSG(
        BCM_E_PARAM,
        (_BSL_BCM_MSG(
          "\r\n"
          "Input internal_action (%d) could not be found on table. Quit with error.\r\n"),internal_action)
      ) ;
    }
exit:
    BCMDNX_FUNC_RETURN;
}
/*
 * }
 */
/*
 * API utilities related to ACE tables setup
 * {
 */
/*
 *   Function
 *     bcm_petra_field_ace_entry_add
 *   Purpose
 *     Load ACE tables as per input parameters:
 *       EPNI_ACE_TO_OUT_PP_PORT
 *       EPNI_ACE_TABLE
 *       EPNI_ACE_TO_OUT_LIF
 *     Note that this procedure's input parameters are mostly not used.
 *     This is because the template is taken from JER2's code, to save
 *     a new BCM API.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) uint32 flags = Ignore
 *      (in) bcm_field_ace_format_t ace_format_id = Ignore
 *      (in) bcm_field_ace_entry_info_t * entry_info =
 *             Structure containing array of actions plus parameters.
 *             Currenly, only one element is allowed and it must be
 *             'bcmFieldActionStat'.
 *             So, we expect:
 *               entry_info->nof_entry_actions = 1
 *               entry_info->entry_action->type = bcmFieldActionStat
 *               entry_info->entry_action[0].value[0] = stat_id.
 *                 The format of 'stat_id' is:
 *                   Ace pointer on LS 17 bits (bits 0 to 16) or LS 19 bits.
 *                   The former case is valid if BIT31 of stat_id is set and
 *                   the latter, if BIT31 is zero. (If these  bits are all zero,
 *                   'Ace pointer' is assumed illegal).
 *                   PRGE on bits 17/19 -> 26/28
 *                   See _SHR_FIELD_CTR_PROC_SHIFT.
 *               entry_info->entry_action[0].value[1] = gport.
 *                 This gport MUST be valid and represents 'TM-Port and PP-Port'.
 *               entry_info->entry_action[0].value[2] = outlif
 *                 This is a 'replacor' outlif to be loaded into corresponding
 *                 ACE table.
 *               entry_info->entry_action[0].value[3] = Core(s) to apply specified parameters to.
 *                 Caller may specify core id or BCM_CORE_ALL to request update
 *                 for all cores.
 *             Any of the 'value's above (indices 0 - 2) is considred 'illegal' if it
 *             is 'BCM_ILLEGAL_ACTION_PARAMETER'
 *      (in) uint32 *entry_handle = Ignore
 *   Returns
 *     int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *     This procedure has indirect output:
 *     Updates ACE HW tables:
 *       EPNI_ACE_TO_OUT_PP_PORT
 *       EPNI_ACE_TABLE
 *       EPNI_ACE_TO_OUT_LIF
 *       (EPNI_ACE_TO_FHEI is, currently, not handled)
 *
 *     This procedure is for JERICHO/JERICHO_PLUS only.
 *
 *     The required operation is carried out for all cores.
 */
int
bcm_petra_field_ace_entry_add(
    int unit,
    uint32 flags,
    bcm_field_ace_format_t ace_format_id,
    bcm_field_ace_entry_info_t * entry_info,
    uint32 *entry_handle)
{
    /*
     * We do not need that many elements on this array but, in this procedure, we use
     * the services of _bcm_dpp_field_ace_entry_add() which is imported from 'field tcam'
     * services. So we are trying to simulate a similar environment.
     */
    _bcm_dpp_field_tc_b_act_t prop_acts[_BCM_DPP_NOF_BCM_ACTIONS_PER_DB_MAX];
    _bcm_dpp_field_tc_p_act_t hw_act[SOC_PPC_FP_NOF_ACTIONS_PER_DB_MAX];
    int core_id, core;
    unsigned int ppd_index;
    unsigned int act_count;

    BCMDNX_INIT_FUNC_DEFS;
    if ((unsigned int)unit >= BCM_MAX_NUM_UNITS)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT, (_BSL_BCM_MSG("invalid unit")));
    }
    if (!SOC_IS_JERICHO(unit)) {
        LOG_ERROR(BSL_LS_BCM_FP,
            (BSL_META_U(unit,
                      "unit %d - This operation is only supported for Jericho\r\n"),
             unit
        )) ;
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM) ;
    }
    /*
     * Verifications.
     */
    BCMDNX_NULL_CHECK(entry_info);
    core = (int)(entry_info->entry_action[0].value[3]);
    if (core != BCM_CORE_ALL)
    {
        int num_cores;

        BCMDNX_IF_ERR_EXIT(bcm_stk_modid_count(unit, &num_cores));
        if ((unsigned int)core >= (unsigned int)num_cores)
        {
            LOG_ERROR(BSL_LS_BCM_FP,
                (BSL_META_U(unit,
                      "unit %d - specified core (0x%08X) is larger than max allowed (0x%08X)\r\n"),
                 unit, core, (num_cores - 1)
            )) ;
            BCMDNX_IF_ERR_EXIT(BCM_E_PARAM) ;
        }
    }
    if (entry_info->nof_entry_actions != 1)
    {
        LOG_ERROR(BSL_LS_BCM_FP,
            (BSL_META_U(unit,
                      "unit %d - 'nof_entry_actions' MUST be '1' but it is %d. Quit.\r\n"),
             unit,entry_info->nof_entry_actions
        )) ;
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM) ;
    }
    if (entry_info->nof_entry_actions != 1)
    {
        LOG_ERROR(BSL_LS_BCM_FP,
            (BSL_META_U(unit,
                      "unit %d - 'nof_entry_actions' MUST be '1' but it is %d. Quit.\r\n"),
             unit,entry_info->nof_entry_actions
        )) ;
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM) ;
    }
    prop_acts[0].bcmType = (bcm_field_action_t)(entry_info->entry_action[0].type);
    prop_acts[0].bcmParam0 = (uint32)(entry_info->entry_action[0].value[0]);
    prop_acts[0].bcmParam1 = (uint32)(entry_info->entry_action[0].value[1]);
    prop_acts[0].bcmParam2 = (uint32)(entry_info->entry_action[0].value[2]);
    prop_acts[0].bcmParam3 = 0;
    if (prop_acts[0].bcmType != bcmFieldActionStat)
    {
        LOG_ERROR(BSL_LS_BCM_FP,
            (BSL_META_U(unit,
                      "unit %d - Input 'type' MUST be 'bcmFieldActionStat' (%d) but it is %d. Quit.\r\n"),
             unit,bcmFieldActionStat,entry_info->entry_action[0].type
        )) ;
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM) ;
    }
    if ((!BCM_GPORT_IS_SET(prop_acts[0].bcmParam1)) || (prop_acts[0].bcmParam1 == BCM_ILLEGAL_ACTION_PARAMETER))
    {
        LOG_ERROR(BSL_LS_BCM_FP,
            (BSL_META_U(unit,
                      "unit %d - Input 'value[1]' MUST be a legal gport but it is 0x%08X. Quit.\r\n"),
             unit,prop_acts[0].bcmParam1
        )) ;
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM) ;
    }
    /*
     * Functional
     */
    ppd_index = 0;
    BCM_DPP_CORES_ITER(core, core_id)
    {
        BCMDNX_IF_ERR_EXIT(
            _bcm_dpp_field_ace_entry_add(unit,prop_acts,core_id,ppd_index,hw_act,&act_count)) ;
    }
exit:
    BCMDNX_FUNC_RETURN;
}
/*
 * }
 */
/*
 *   Function
 *      bcm_petra_field_action_add
 *   Purpose
 *      Add a specific action to a specific entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_field_action_t action = the action to add
 *      (in) uint32 param0 = action parameter 0 (some actions)
 *      (in) uint32 param1 = action parameter 1 (some actions)
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      No hardware changes; only software state.
 *
 *   The following actions are NOT supported on this procedure
 *   for JERICHO, on egress:
 *     bcmFieldActionStat
 *     bcmFieldActionVportNew
 *   For JERICHO, use bcm_field_action_config_add() instead.
 */
int
bcm_petra_field_action_add(int unit,
                            bcm_field_entry_t entry,
                            bcm_field_action_t action,
                            uint32 param0,
                            uint32 param1)
{
    _DPP_FIELD_COMMON_LOCALS;
    uint8 isExternalTcam ;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),%d,%d) enter\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               param0,
               param1));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    isExternalTcam = _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry) ;
    /*
     * The following actions are not supported on this utility for JERICHO:
     *   bcmFieldActionStat
     * User should use a new interface - bcm_petra_field_action_config_add()
     *
     * This is so because of new capabilities added to PPDB_A_TCAM_ACTION on JERICHO.
     * See corresponding actions on _bcm_dpp_field_tcam_entry_action_update()
     */
    if (SOC_IS_JERICHO(unit)) {
        _bcm_dpp_field_grp_idx_t entryGroup, groupLimit;
        _bcm_dpp_field_stage_idx_t stage ;
        SOC_PPC_FP_DATABASE_STAGE soc_stage;

        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
        BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_GROUP_GET(unit,isExternalTcam, _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry), entryGroup));
        if (groupLimit <= entryGroup) {
            BCMDNX_ERR_EXIT_VERB_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("Error: entry doesn't belong to any group")));
        }

        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.stage.get(unit, entryGroup, &stage)) ;
        soc_stage = _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage).hwStageId ;
        if (SOC_PPC_FP_DATABASE_STAGE_EGRESS == soc_stage) {
            if (action == bcmFieldActionStat) {
                LOG_ERROR(BSL_LS_BCM_FP,
                    (BSL_META_U(unit,
                              "unit %d - This action %d (%s) is not supported on this utility (%s)\r\n"
                              "Use bcm_field_action_config_add()\r\n"),
                     unit,
                     action,_bcm_dpp_field_action_name[action],__func__
                )) ;
                result = BCM_E_PARAM ;
            }
        }
    }
    if (result == BCM_E_NONE) {
        _DPP_FIELD_UNIT_LOCK(unitData);
        dpp_field_unit_lock_was_taken = 1;

        if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
            {
                result = _bcm_dpp_field_tcam_entry_action_set(unitData,
                                                              isExternalTcam, 
                                                              SOC_CORE_INVALID,
                                                              _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                              action,
                                                              param0,
                                                              param1,
                                                              BCM_ILLEGAL_ACTION_PARAMETER,
                                                              BCM_ILLEGAL_ACTION_PARAMETER);
            }
        } else {
            result = BCM_E_NOT_FOUND;
        LOG_VERBOSE(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d not valid for this function\n"),
                       unit,
                       entry));
        }

    }
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),%d,%d) return %d (%s)\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               param0,
               param1,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_action_get
 *   Purpose
 *      Get a specific action from a specific entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_field_action_t action = the action to get
 *      (out) uint32 *param0 = action parameter 0 (some actions)
 *      (out) uint32 *param1 = action parameter 1 (some actions)
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      No hardware changes; only software state.
 */
int
bcm_petra_field_action_get(int unit,
                            bcm_field_entry_t entry,
                            bcm_field_action_t action,
                            uint32 *param0,
                            uint32 *param1)
{
    _bcm_dpp_field_ent_idx_t new_entry;
    _bcm_dpp_field_grp_idx_t group;
    _DPP_FIELD_COMMON_LOCALS;
    int dpp_field_unit_lock_was_taken = 0;
    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),*%08X,%08X) enter\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               PTR_TO_INT(param0),
               PTR_TO_INT(param1)));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((!param0) || (!param1)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory outbound argument is NULL")));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    if (_BCM_DPP_FIELD_ENTRY_IS_LARGE_DIRECT_LOOKUP(entry)) {
        BCM_FIELD_LARGE_DIRECT_ENTRY_ID_UNPACK(entry, group, new_entry);
        if (!_BCM_DPP_FIELD_ENT_IS_KAPS_ADVANCED_MODE(unit, group)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                     (_BSL_BCM_MSG("This entry 0x%x group %d key 0x%x should work in large direct lookup advanced mode."), entry, group, new_entry));
        }
        result = _bcm_dpp_field_tcam_entry_action_get(unitData,
                                                      entry,
                                                      action,
                                                      param0,
                                                      param1,
                                                      NULL,
                                                      NULL);
    } else if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
            result = _bcm_dpp_field_tcam_entry_action_get(unitData,
                                                          entry,
                                                          action,
                                                          param0,
                                                          param1,
                                                          NULL,
                                                          NULL);
        } else {
            result = BCM_E_NOT_FOUND;
            LOG_VERBOSE(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d not valid for this function\n"),
                       unit,
                       entry));
        }
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),&(%d),&(%d)) return %d (%s)\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               *param0,
               *param1,
               result,
               _SHR_ERRMSG(result)));

    BCMDNX_IF_ERR_NOT_E_NOT_FOUND_EXIT(result);

exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_action_remove
 *   Purpose
 *      Remove a specific action from a specific entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_field_action_t action = the action to remove
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      No hardware changes; only software state.
 */
int
bcm_petra_field_action_remove(int unit,
                               bcm_field_entry_t entry,
                               bcm_field_action_t action)
{
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    _DPP_FIELD_COMMON_LOCALS;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d)) enter\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > action) || (bcmFieldActionCount <= action)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("action %d is not valid"), action));
    }
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));

    if (_BCM_DPP_FIELD_ENTRY_IS_LARGE_DIRECT_LOOKUP(entry)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                     (_BSL_BCM_MSG("This API is not supportd by large direct lookup advanced mode.")));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        {
            result = _bcm_dpp_field_tcam_entry_action_clear(unitData,
                                                            _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                            _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                            action);
        }
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                entry))  {
        result = BCM_E_UNAVAIL;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "bcm_field_action_remove does not support for direct extractin entries\n")));
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"), unit, entry));
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d)) return %d (%s)\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_action_delete
 *   Purpose
 *      Remove a specific action from a specific entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_field_action_t action = the action to remove
 *      (in) param0 = parameter 0 for the action to remove
 *      (in) param1 = parameter 1 for the action to remove
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      It's an error (BCM_E_NOT_FOUND) to try to remove an action that exists
 *      byt whose param0,param1 is not equal to the specifications here.
 */
int
bcm_petra_field_action_delete(int unit,
                               bcm_field_entry_t entry,
                               bcm_field_action_t action,
                               uint32 param0,
                               uint32 param1)
{
    _DPP_FIELD_COMMON_LOCALS;
    uint32 lparam0;
    uint32 lparam1;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),%d,%d) enter\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               param0,
               param1));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > action) || (bcmFieldActionCount <= action)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("action %d is not valid"), action));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        result = _bcm_dpp_field_tcam_entry_action_get(unitData,
                                                      entry,
                                                      action,
                                                      &lparam0,
                                                      &lparam1,
                                                      NULL,
                                                      NULL);
        if (BCM_E_NONE == result) {
            if ((lparam0 == param0) && (lparam1 == param1)) {
                /* exact match found, remove it */
                result = _bcm_dpp_field_tcam_entry_action_clear(unitData,
                                                                _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                                _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                                action);
            } else { /* if ((lparam0 == param0) && (lparam1 == param1)) */
                /* at least one of param0, param1 is not as before */
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d has action %d (%s) but"
                                      " param0 %d(%08X) or param1 %d(%08X) was"
                                      " not same as specified param0 %d(%08X)"
                                      " or param1 %d(%08X\n"),
                           unit,
                           entry,
                           action,
                           ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
                           lparam0,
                           lparam0,
                           lparam1,
                           lparam1,
                           param0,
                           param0,
                           param1,
                           param1));
                result = BCM_E_PARAM; 
            } /* if ((lparam0 == param0) && (lparam1 == param1)) */
        } /* if (BCM_E_NONE == result) */
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"), unit, entry));
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),%d,%d) return %d (%s)\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               param0,
               param1,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_action_remove_all
 *   Purpose
 *      Remove all actions from a specific entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      No hardware changes; only software state.
 */
int
bcm_petra_field_action_remove_all(int unit,
                                  bcm_field_entry_t entry)
{
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    _DPP_FIELD_COMMON_LOCALS;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"), unit, entry));

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        result = _bcm_dpp_field_tcam_entry_clear_acts(unitData,
                                                      _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                      _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry));
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) > entry))  {
        result = _bcm_dpp_field_dir_ext_entry_clear_acts(unitData,
                                                         entry -
                                                         _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt));
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"), unit, entry));
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 *   Function
 *      bcm_petra_field_qualify_clear
 *   Purpose
 *      Clear all qualifiers for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_clear(int unit,
                              bcm_field_entry_t entry)
{
    uint32 flags;
    _bcm_dpp_field_qual_t quals;
    _bcm_dpp_field_ent_idx_t ent;
    _bcm_dpp_field_ent_idx_t entryDeLimit;
    uint32 entryDe_entryFlags;
    int dpp_field_unit_lock_was_taken = 0;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"), unit, entry));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (SOC_WARM_BOOT(unit)) {  /*Warm boot -  Do not allocate sw-state resources */
        goto exit ;
    }
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.entryDeLimit.get(unit, &entryDeLimit));

    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        ent = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry);
        /*
         * Was:
         *   flags = _BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_PTR(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent);
         */
        BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry),ent,flags)) ;
        if ((flags) & _BCM_DPP_FIELD_ENTRY_IN_USE) {
            /*
             * Was:
             *   _bcm_dpp_field_entry_clear_quals(unit, quals);
             */
            {
                unsigned int index;

                quals.qualType = BCM_FIELD_ENTRY_INVALID;
                quals.hwType = BCM_FIELD_ENTRY_INVALID;
                for (index = 0; index < SOC_PPC_FP_NOF_QUALS_PER_DB_MAX; index++) {
                    _BCM_DPP_FIELD_TCAM_ENTRY_QUALS_SET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent, index, quals) ;
                }
            }
            /*
             * was:
             *   *flags |= (_BCM_DPP_FIELD_ENTRY_CHANGED);
             */
            flags |= (_BCM_DPP_FIELD_ENTRY_CHANGED);
            BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_SET(unit,_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry),ent,flags)) ;
        } else {
            result = BCM_E_NOT_FOUND;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is not in use\n"),
                       unit,
                       entry));
        }
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                entry))  {
        ent = entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryFlags.get(unit, ent, &entryDe_entryFlags));
        if (entryDe_entryFlags & _BCM_DPP_FIELD_ENTRY_IN_USE) {
            /*
              * Was:
             *  _bcm_dpp_field_entry_clear_quals(unit, &entryDe_entryQual);
             */
            {
                unsigned int index;

                for (index = 0; index < SOC_PPC_FP_NOF_QUALS_PER_DB_MAX; index++) {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryQual.qualType.set(unit, ent, index, BCM_FIELD_ENTRY_INVALID)); 
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryQual.hwType.set(unit, ent, index, BCM_FIELD_ENTRY_INVALID)); 
                }
            }
            entryDe_entryFlags |= (_BCM_DPP_FIELD_ENTRY_CHANGED);
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryFlags.set(unit, ent, entryDe_entryFlags));
        } else {
            result = BCM_E_NOT_FOUND;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is not in use\n"),
                       unit,
                       entry));
        }
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),  unit,  entry));
    }


    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp6
 * Purpose:
 *      Set match criteria for bcmFieldQualifySrcIp6
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp6(int unit,
                               bcm_field_entry_t entry,
                               bcm_ip6_t data,
                               bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifySrcIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp6_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp6_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip6_t *data,
                                   bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifySrcIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp6
 * Purpose:
 *      Set match criteria for bcmFieldQualifyDstIp6
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp6(int unit,
                               bcm_field_entry_t entry,
                               bcm_ip6_t data,
                               bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyDstIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp6_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp6_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip6_t *data,
                                   bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyDstIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp6High
 * Purpose:
 *      Set match criteria for bcmFieldQualifySrcIp6High
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp6High(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip6_t data,
                                   bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifySrcIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp6High_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_ip6_t *data,
                                       bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifySrcIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp6High
 * Purpose:
 *      Set match criteria for bcmFieldQualifyDstIp6High
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp6High(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip6_t data,
                                   bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyDstIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp6High_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_ip6_t *data,
                                       bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyDstIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp6Low
 * Purpose:
 *      Set match criteria for bcmFieldQualifySrcIp6Low
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp6Low(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_ip6_t data,
                                  bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifySrcIp6Low,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp6Low_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIp6Low
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp6Low_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_ip6_t *data,
                                      bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifySrcIp6Low,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp6Low
 * Purpose:
 *      Set match criteria for bcmFieldQualifyDstIp6Low
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp6Low(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_ip6_t data,
                                  bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyDstIp6Low,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp6Low_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIp6Low
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp6Low_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_ip6_t *data,
                                      bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyDstIp6Low,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_SrcMac
 *   Purpose
 *      Set expected source MAC address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which source MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_SrcMac(int unit,
                               bcm_field_entry_t entry,
                               bcm_mac_t data,
                               bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifySrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcMac_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_mac_t *data,
                                   bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifySrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_DstMac
 *   Purpose
 *      Set expected destination MAC address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which destination MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_DstMac(int unit,
                               bcm_field_entry_t entry,
                               bcm_mac_t data,
                               bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifyDstMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstMac_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_mac_t *data,
                                   bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifyDstMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_SrcIp
 *   Purpose
 *      Set expected source IPv4 address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_ip_t data = which source IPv4 address
 *      (in) bcm_ip_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_SrcIp(int unit,
                               bcm_field_entry_t entry,
                               bcm_ip_t data,
                               bcm_ip_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifySrcIp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp_get(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_ip_t *data,
                                  bcm_ip_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifySrcIp,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_DstIp
 *   Purpose
 *      Set expected destination IPv4 address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_ip_t data = which destination IPv4 address
 *      (in) bcm_ip_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_DstIp(int unit,
                               bcm_field_entry_t entry,
                               bcm_ip_t data,
                               bcm_ip_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstIp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp_get(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_ip_t *data,
                                  bcm_ip_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyDstIp,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_KeyGenVar(int unit,
                               bcm_field_entry_t entry,
                               uint32 data,
                               uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyKeyGenVar,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_SrcTMPort(int unit,
                               bcm_field_entry_t entry,
                               bcm_port_t data,
                               bcm_port_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, (data&0xff));
    COMPILER_64_SET(emask, 0, (mask&0xff));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifySrcTMPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_SrcTMPort_get(int unit,
                               bcm_field_entry_t entry,
                               bcm_port_t *data,
                               bcm_port_t *mask)
{
    uint32 edata, emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifySrcTMPort,
                                                            &edata,
                                                            &emask));
    *data = edata;
    *mask = emask;

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
        _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
        BCMDNX_FUNC_RETURN;

}



int
_bcm_dpp_field_gport_to_pp_port_tm_port_convert(int unit,
                                                bcm_port_t data,
                                                uint32 *pp_port,
                                                uint32 *tm_port,
                                                int *core)
{
    bcm_port_t local_port = -1;
	bcm_gport_t gport_mod_port = 0;
    uint32 pp_port_res;
    uint32 tm_port_res;
    int core_res;
    uint8 nof_cores = 1;
    BCMDNX_INIT_FUNC_DEFS;

    nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);
    /* Retrieve local_port value of local port type*/
    if (BCM_GPORT_IS_SET(data)) {
        if (BCM_GPORT_IS_LOCAL(data)) {
            local_port = BCM_GPORT_LOCAL_GET(data);
        } else if (BCM_GPORT_IS_SYSTEM_PORT(data) || BCM_GPORT_IS_MODPORT(data)) {
			if (BCM_GPORT_IS_SYSTEM_PORT(data)) {
				BCMDNX_IF_ERR_EXIT_MSG(bcm_petra_stk_sysport_gport_get(unit, data, &gport_mod_port), 
									(_BSL_BCM_MSG("unable to get gport mod-port ID")));
			} else {
				gport_mod_port = data;
			}
            tm_port_res = BCM_GPORT_MODPORT_PORT_GET(gport_mod_port);
            /*Local modID starts from device modID for core 0 and increments for each core. Device modID is divisible by nof_cores.*/
            core_res = BCM_GPORT_MODPORT_MODID_GET(gport_mod_port) % nof_cores;
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_tm_to_local_port_get, (unit, core_res, tm_port_res, &local_port)));

        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("only support SYSTEM, MODPORT and LOCAL type"
                                       " GPORTS; 0x%X it not supported"),
                              data));
        }

    } else { /* if (BCM_GPORT_IS_SET(data)) */
        local_port = data;
    } /* if (BCM_GPORT_IS_SET(data)) */

    /* map local port to PP port */
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, local_port, &pp_port_res, &core_res)));
    /* map local port to TM port and core*/
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_tm_port_get, (unit, local_port, &tm_port_res, &core_res)));
    *core = core_res;
    if (_BCM_DPP_NOF_LOCAL_PORTS(unit) <= pp_port_res) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,
                         (_BSL_BCM_MSG_NO_UNIT("PP port: unit %d port %d(%08X)"
                                           " is not a valid local"
                                           " port number"),
                          unit,
                          *pp_port,
                          *pp_port));
    } /* if (resulting port number is not valid) */
    *pp_port = pp_port_res;
    if (_BCM_DPP_NOF_LOCAL_PORTS(unit) <= tm_port_res) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,
                         (_BSL_BCM_MSG_NO_UNIT("TM port: unit %d port %d(%08X)"
                                           " is not a valid local"
                                           " port number"),
                          unit,
                          *tm_port,
                          *tm_port));
    } /* if (resulting port number is not valid) */
    *tm_port = tm_port_res;

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_field_qualify_pp_port_convert(int unit,
                               bcm_port_t data,
                               bcm_port_t mask,
                               uint64 *edata,
                               uint64 *emask,
                               int is_inport)
{
    uint32 pp_port, tm_port, data_to_write;
	bcm_gport_t gport_mod_port = 0;
    bcm_module_t myModule, portModule;
    int core;
    int nof_cores = 1;
    uint8 field_port_mask_support;
    BCMDNX_INIT_FUNC_DEFS;

    nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);
    field_port_mask_support = soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "field_port_mask_support", 0);
    if(field_port_mask_support == 0) {                          /* Port Masking is disabled */
        if ((0 != mask) && ((~0) != mask)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                       " bits set or all bits clear clear)")));
        }
    }

    
    BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_gport_to_pp_port_tm_port_convert(unit, data, &pp_port, &tm_port, &core),
                    (_BSL_BCM_MSG("unable to get the TM or PP port with gport %d"), data));
    if (is_inport) {
        data_to_write = ((core << 8) | pp_port);
        /* Check if the in-port is in the local module ID(s) range*/
        if (BCM_GPORT_IS_SYSTEM_PORT(data) || BCM_GPORT_IS_MODPORT(data)) {
			if (BCM_GPORT_IS_SYSTEM_PORT(data)) {
				BCMDNX_IF_ERR_EXIT_MSG(bcm_petra_stk_sysport_gport_get(unit, data, &gport_mod_port),
									(_BSL_BCM_MSG("unable to get gport mod-port ID")));
			} else {
				gport_mod_port = data;
			}
            portModule = BCM_GPORT_MODPORT_MODID_GET(gport_mod_port);
            BCMDNX_IF_ERR_EXIT_MSG(bcm_petra_stk_my_modid_get(unit, &myModule),
                                (_BSL_BCM_MSG("unable to get local module ID")));
            if (portModule < myModule || portModule >= myModule + nof_cores) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG("only supports local ports for"
                                           " InPort qualifier")));
            }
        }
    } else {
        data_to_write = pp_port;
    }
    COMPILER_64_SET(*edata, 0, data_to_write);

    if (0 == mask) {
        COMPILER_64_ZERO(*emask);
    } else {
        if (SOC_IS_JERICHO(unit) && is_inport) {
            /* InPort is encoded in 9 bits in JER */
            if(field_port_mask_support == 0)                    /* Port Masking is disabled */
                COMPILER_64_SET(*emask, 0, 0x1FF);
            else                                                /* Port Masking is enabled */
                COMPILER_64_SET(*emask, 0, mask & 0x1FF);
        } else {
            /* InPort encoded in 8 bits in Arad */
            if(field_port_mask_support == 0)                    /* Port Masking is disabled */
                COMPILER_64_SET(*emask, 0, 0xFF);
            else                                                /* Port Masking is enabled */
                COMPILER_64_SET(*emask, 0, mask & 0xFF);
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_dpp_field_qualify_fwd_decision_from_hw_convert(int unit,
                                                    uint8 is_for_destination,
                                                    uint32 data_in,
                                                    uint32 flags,
                                                    SOC_PPC_FRWRD_DECISION_INFO   *fwdDecision)
{
    uint32 ppdr;
    int result;
    BCMDNX_INIT_FUNC_DEFS;

    SOC_PPC_FRWRD_DECISION_INFO_clear(fwdDecision);

    /* Get the HW Destination from the Forward decision */
    /* Decode the Destination to flow */
    ppdr = arad_pp_fwd_decision_in_buffer_parse((unit),
                                                (is_for_destination?data_in:0),
                                                (is_for_destination?0:data_in),
                                                flags,
                                                fwdDecision);

    result = handle_sand_result(ppdr);
    if (BCM_E_NONE != result) {
        BCMDNX_ERR_EXIT_MSG(result, (_BSL_BCM_MSG("Incorrect nickname during decoding operation with PPD HW value %d\n"), data_in));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* Get the LAG default mask where the LAG member id is removed */
STATIC int
_bcm_dpp_field_qualify_lag_mask_get(int unit,
                                    uint32 *mask_requirement)
{
    uint32 ppdr;
    int result;
    ARAD_PORT_LAG_MODE lag_mode;
    uint32  sys_lag_port_id_nof_bits;
    BCMDNX_INIT_FUNC_DEFS;

    *mask_requirement = 0;
    /* In case of Trunk-LAG, unmask the member-id part */
    /* Decode the Destination to flow */
    ppdr = arad_ports_lag_mode_get_unsafe((unit),
                                          &lag_mode,
                                          &sys_lag_port_id_nof_bits);

    result = handle_sand_result(ppdr);
    if (BCM_E_NONE != result) {
        BCMDNX_ERR_EXIT_MSG(result, (_BSL_BCM_MSG("Incorrect get of the LAG mode \n")));
    }
    /* LAG mask LSB is the LAG group, MSB is the encoding */
    *mask_requirement = 0xFFFF8000 | ((1 << sys_lag_port_id_nof_bits) - 1);

exit:
    BCMDNX_FUNC_RETURN;
}



int
_bcm_dpp_field_qualify_fwd_decision_to_hw_destination_convert(int unit,
                                                              SOC_PPC_FRWRD_DECISION_INFO   *fwdDecision,
                                                              uint8 is_for_destination,
                                                              uint8 is_for_action,
                                                              uint64 *edata,
                                                              uint64 *emask)
{
    uint32 mask_requirement= ~0;
    uint32 mask_proposed;
    uint32 ppdr, dest_buf = 0, asd_buf = 0;
    int result;
    BCMDNX_INIT_FUNC_DEFS;

    /* Init the values */
    mask_proposed = COMPILER_64_LO(*emask);
    COMPILER_64_SET(*edata, 0, 0);
    COMPILER_64_SET(*emask, 0, 0);

    /* Get the HW Destination from the Forward decision */
    ppdr = arad_pp_fwd_decision_in_buffer_build((unit),
                                                0,
                                                fwdDecision,
                                                &dest_buf,
                                                &asd_buf);
    result = handle_sand_result(ppdr);
    if (BCM_E_NONE != result) {
        BCMDNX_ERR_EXIT_MSG(result, (_BSL_BCM_MSG("Incorrect nickname during"
                                           " encoding operation\n")));
    }
    COMPILER_64_SET(*edata, 0, (is_for_destination? dest_buf: asd_buf));
    
    switch (fwdDecision->type) {
    case SOC_PPC_FRWRD_DECISION_TYPE_UC_FLOW:
        mask_requirement = ((~0) << 15);
        break;
    case SOC_PPC_FRWRD_DECISION_TYPE_MC:
        mask_requirement = ((~0) << 14);
        break;
    case SOC_PPC_FRWRD_DECISION_TYPE_UC_LAG:
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_lag_mask_get(unit,&mask_requirement),
                            (_BSL_BCM_MSG("unable to get the lag data mask")));
        break;
    /* all remaining types must be exact match */
    default:
        mask_requirement = ~0;
    }

    
    if (mask_proposed) {
        /* the mask is not all zeroes (so not match anything) */
        if ((mask_proposed & mask_requirement) != mask_requirement) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("unit %d forwarding decision %s (%d)"
                                       " requires mask (%08X) either be all"
                                       " zeroes or have bits %08X set"),
                              unit,
                              SOC_PPC_FRWRD_DECISION_TYPE_to_string(fwdDecision->type),
                              fwdDecision->type,
                              mask_proposed,
                              mask_requirement));
        } /* if ((mask_proposed && mask_requirement) != mask_requirement) */
        COMPILER_64_SET(*emask, 0, mask_proposed);
    } /* if (mask_proposed) */

exit:
    BCMDNX_FUNC_RETURN;
}



STATIC int
_bcm_dpp_field_qualify_gport_to_hw_destination_convert(int unit,
                                                       bcm_gport_t   data_port,
                                                       bcm_gport_t   mask_port,
                                                       uint64 *edata,
                                                       uint64 *emask)
{
    SOC_PPC_FRWRD_DECISION_INFO  fwdDecision;
    bcm_gport_t   mask_port_lcl = mask_port;
    uint32 mask_requirement;

    BCMDNX_INIT_FUNC_DEFS;

    /* Init the values */
    COMPILER_64_SET(*edata, 0, 0);
    COMPILER_64_SET(*emask, 0, 0);

    switch ((data_port >> _SHR_GPORT_TYPE_SHIFT) & _SHR_GPORT_TYPE_MASK) {
    case _SHR_GPORT_TYPE_MCAST:
        if (~(mask_port | (_SHR_GPORT_MCAST_MASK <<
                           _SHR_GPORT_MCAST_SHIFT))) {
            /* mask bits are clear that are not in the variable space */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("gport %08X mask must have all bits"
                                       " clear, or bits %08X must be set"),
                              data_port,
                              ~(_SHR_GPORT_MCAST_MASK <<
                                _SHR_GPORT_MCAST_SHIFT)));
        }
        break;
    case _SHR_GPORT_TYPE_SCHEDULER:
        if (~(mask_port | (_SHR_GPORT_SCHEDULER_MASK <<
                           _SHR_GPORT_SCHEDULER_SHIFT))) {
            /* mask bits are clear that are not in the variable space */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("gport %08X mask must have all bits"
                                       " clear, or bits %08X must be set"),
                              data_port,
                              ~(_SHR_GPORT_SCHEDULER_MASK <<
                                _SHR_GPORT_SCHEDULER_SHIFT)));
        }
        break;
    case _SHR_GPORT_TYPE_UCAST_QUEUE_GROUP:
        if (~(mask_port | (_SHR_GPORT_UCAST_QUEUE_GROUP_QID_MASK <<
                           _SHR_GPORT_UCAST_QUEUE_GROUP_QID_SHIFT))) {
            /* mask bits are clear that are not in the variable space */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("gport %08X mask must have all bits"
                                       " clear, or bits %08X must be set"),
                              data_port,
                              ~(_SHR_GPORT_UCAST_QUEUE_GROUP_QID_MASK <<
                                _SHR_GPORT_UCAST_QUEUE_GROUP_QID_SHIFT)));
        }
        break;
    case _SHR_GPORT_TYPE_TRUNK:
        if (~(mask_port | (_SHR_GPORT_TRUNK_MASK <<
                           _SHR_GPORT_TRUNK_SHIFT))) {
            /* mask bits are clear that are not in the variable space */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("gport %08X mask must have all bits"
                                       " clear, or bits %08X must be set"),
                              data_port,
                              ~(_SHR_GPORT_TRUNK_MASK <<
                                _SHR_GPORT_TRUNK_SHIFT)));
        }
        /* Set the correct mask - mask the LAG-Member-Id part */
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_lag_mask_get(unit,&mask_requirement),
                            (_BSL_BCM_MSG("unable to get the lag data mask")));
        mask_port_lcl &= mask_requirement;
        break;
    default:
        /* other GPORT types must be exact match or ignore */
        if ((0 != mask_port)  && ((~0) != mask_port)) {
            /* neither ignore nor exact match */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("gport %08X only supports all or"
                                       " nothing mask (all bits set or all"
                                       " bits clear clear)"),
                              data_port));
        }
    } /* switch ((data_port >> _SHR_GPORT_TYPE_SHIFT) & _SHR_GPORT_TYPE_MASK) */

    /* now we know the mask is acceptable for the type of GPORT */
    /* The data port must be gport */
    if (BCM_GPORT_IS_SET(data_port) && mask_port_lcl) {
        /* Find the Forward destination */
        SOC_PPC_FRWRD_DECISION_INFO_clear(&fwdDecision);
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_gport_to_fwd_decision(unit,
                                                           data_port,
                                                           &fwdDecision),
                            (_BSL_BCM_MSG("unable to get the forward decision"
                                      " with gport %08X"),
                             data_port));
        /* propose using the caller's mask request */
        COMPILER_64_SET(*emask, 0, mask_port_lcl);
        /* Get the HW Destination from the Forward decision */
        BCMDNX_IF_ERR_EXIT_MSG(
            _bcm_dpp_field_qualify_fwd_decision_to_hw_destination_convert(unit,
                                                                          &fwdDecision,
                                                                          TRUE, /* is_for_destination */
                                                                          FALSE, /* is_for_action */
                                                                          edata,
                                                                          emask),
            (_BSL_BCM_MSG("unable to get from the forward decision the HW data")));

    } /* if (BCM_GPORT_IS_SET(data_port)) */

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_field_qualify_gport_from_hw_destination_convert(int unit,
                                                         uint32 ppdHwDest,
                                                         bcm_gport_t   *gport)
{
    SOC_PPC_FRWRD_DECISION_INFO fwdDecision;

    BCMDNX_INIT_FUNC_DEFS;

    /* Init the values */
    *gport = 0;
    SOC_PPC_FRWRD_DECISION_INFO_clear(&fwdDecision);

    /* Decode the Destination to flow */
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_fwd_decision_from_hw_convert(unit,
                                                            TRUE, /* is_for_destination */
                                                            ppdHwDest,
                                                            ARAD_PP_FWD_DECISION_PARSE_DEST,
                                                            &fwdDecision));

    BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_gport_and_encap_from_fwd_decision(unit, gport, NULL, &fwdDecision, -1/*encap_usage*/,0/*force_destination*/),
                        (_BSL_BCM_MSG("unable to get the gport from the forward decision with PPD HW value %d\n"), ppdHwDest));
    goto exit;

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_field_qualify_mod_port_to_gport_convert(int unit,
                                                 bcm_module_t data_modid,
                                                 bcm_module_t mask_modid,
                                                 bcm_port_t   data_port,
                                                 bcm_port_t   mask_port,
                                                 bcm_gport_t *data,
                                                 bcm_gport_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    *data = 0;
    *mask = 0;
    if (mask_port) {
        if (BCM_GPORT_IS_SET(data_port)) {
            /* GPORT conversion will verify mask later */
            *data = data_port;
            *mask = mask_port;
        } else { /* if (BCM_GPORT_IS_SET(data_port)) */
            /* mod,port -- verify mask now */
            if (((0 != mask_modid) && ((~0) != mask_modid))
                || ((0 != mask_port) && ((~0) != mask_port))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG("only supports all or nothing mask"
                                           " (all bits set or all bits clear)")));
            }
            /* now build GPORT for it */
            BCM_GPORT_MODPORT_SET(*data, data_modid, data_port);
            *mask = ~0;
        } /* if (BCM_GPORT_IS_SET(data_port)) */
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* Convert from gport of type LIF to global LIF-Id */
int
_bcm_dpp_field_gport_to_global_lif_convert(int unit,
                                           bcm_gport_t  lif_gport,
                                           uint8       is_inlif,
                                           uint32      *lif)
{
    int global_out_lif_id, global_in_lif_id;
    int result;
    _bcm_dpp_gport_hw_resources gport_hw_resources;

    BCMDNX_INIT_FUNC_DEFS;

    result = _bcm_dpp_gport_to_hw_resources(unit, lif_gport, _BCM_DPP_GPORT_HW_RESOURCES_GLOBAL_LIF_INGRESS|_BCM_DPP_GPORT_HW_RESOURCES_GLOBAL_LIF_EGRESS, &gport_hw_resources);
    global_in_lif_id = gport_hw_resources.global_in_lif;
    global_out_lif_id = gport_hw_resources.global_out_lif;

    *lif = (is_inlif) ? global_in_lif_id : global_out_lif_id;

    if ((BCM_E_NONE != result) || (*lif == _BCM_GPORT_ENCAP_ID_LIF_INVALID)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unable to compute lif for unit"
                              " %d GPORT %08X: %d (%s)\n"),
                   unit,
                   lif_gport,
                   result,
                   _SHR_ERRMSG(result)));
        BCMDNX_IF_ERR_EXIT(result);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* Convert from gport of type LIF to local LIF-Id */
int
_bcm_dpp_field_gport_to_local_lif_convert(int unit,
                                          bcm_gport_t  lif_gport,
                                          uint8       is_inlif,
                                          uint32      *lif)
{
    int local_out_lif_id, local_in_lif_id;
    int result;
    _bcm_dpp_gport_hw_resources gport_hw_resources;

    BCMDNX_INIT_FUNC_DEFS;

    result = _bcm_dpp_gport_to_hw_resources(unit, lif_gport, _BCM_DPP_GPORT_HW_RESOURCES_LOCAL_LIF_INGRESS|_BCM_DPP_GPORT_HW_RESOURCES_LOCAL_LIF_EGRESS, &gport_hw_resources);
    local_in_lif_id  = gport_hw_resources.local_in_lif;
    local_out_lif_id = gport_hw_resources.local_out_lif;

    *lif = (is_inlif) ? local_in_lif_id : local_out_lif_id;

    if ((BCM_E_NONE != result) || (*lif == _BCM_GPORT_ENCAP_ID_LIF_INVALID)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unable to compute lif for unit"
                              " %d GPORT %08X: %d (%s)\n"),
                   unit,
                   lif_gport,
                   result,
                   _SHR_ERRMSG(result)));
        BCMDNX_IF_ERR_EXIT(result);
    }


exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_InPort
 *   Purpose
 *      Set allowed ingress port for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_port_t data = allowed port
 *      (in) bcm_port_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Supports GPORTs of various types and will map back to phys port.
 */
int
bcm_petra_field_qualify_InPort(int unit,
                               bcm_field_entry_t entry,
                               bcm_port_t data,
                               bcm_port_t mask)
{
    uint64 edata;
    uint64 emask;
    uint32 pp_port;
    _bcm_dpp_core_ports_bitmap_t port_bitmap[MAX_NUM_OF_CORES]; 
    int    core, nof_cores;
    uint32 max_port =  _BCM_DPP_NOF_LOCAL_PORTS(unit);

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        _bcm_dpp_clear_core_ports(nof_cores, port_bitmap);

        if(data < 0 || data >= max_port)
        {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("Port value is out of range, "
                                       "Value is %d range is [0, %d]\n"), 
                              data, max_port-1));
        }
        if ((0 != mask) && ((~0) != mask)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                       " bits set or all bits clear)")));
        }
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, data, &pp_port, &core)));

        COMPILER_64_SET(emask,0, 0x7);
        SHR_BITSET(port_bitmap[core], pp_port);

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_set(unit,
                                                               _bcmDppFieldProfileTypeInPort,
                                                               nof_cores,
                                                               port_bitmap,
                                                               &edata));
    }
    else {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_qualify_pp_port_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask,
                                                               TRUE /* is_inport */));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      This version always returns local port, not GPORT, even thoguh the set
 *      function allows certain GPORT types.
 */
int
bcm_petra_field_qualify_InPort_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_port_t *data,
                                   bcm_port_t *mask)
{
    uint32 tdata;
    uint32 tmask;
    bcm_port_t port;
    uint32 
        port_id;
    _bcm_dpp_core_ports_bitmap_t  port_bitmap[MAX_NUM_OF_CORES];
    int    nof_cores, core; 
    uint32 pp_port;
    uint32 max_port =  _BCM_DPP_NOF_LOCAL_PORTS(unit);
	uint32 is_valid;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInPort,
                                                            &tdata,
                                                            &tmask));
    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                               _bcmDppFieldProfileTypeInPort,
                                                               tdata,
                                                               &nof_cores,
                                                               port_bitmap));
        port = max_port;
        for (port_id = 0; port_id < max_port; port_id++) {
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

            if (is_valid) {

                BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));

                if(SHR_BITGET(port_bitmap[core], pp_port) > 0) {
                    if(port != max_port) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                     (_BSL_BCM_MSG("Presel was defined"
                                               " for multiple ports")));
                    }
                    port = port_id;
                }
            }
        }
    }
    else {
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_pp_to_local_port_get, (unit, (tdata >> 8) & 0x1, tdata & 0xFF, &port)));
    }

    *data = port;
    if (tmask) {
        *mask = (~0);
    } else {
        *mask = 0;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ip6FlowLabel
 * Purpose:
 *      Set match criteria for bcmFieldQualifyIp6FlowLabel
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ip6FlowLabel(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 data,
                                     uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIp6FlowLabel,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ip6FlowLabel_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIp6FlowLabel
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ip6FlowLabel_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 *data,
                                         uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyIp6FlowLabel,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_OuterVlan
 *   Purpose
 *      Set expected outer VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which VLAN tag (16 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      BCM API docs neglect to metion that this function applies to the entire
 *      tag, rather than just the VID.
 */
int
bcm_petra_field_qualify_OuterVlan(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_vlan_t data,
                                  bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterVlan,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterVlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOuterVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterVlan_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_vlan_t *data,
                                      bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyOuterVlan,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_OuterVlanId
 *   Purpose
 *      Set expected outer VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which VID (12 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_OuterVlanId(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_vlan_t data,
                                    bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterVlanId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyOuterVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterVlanId_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_vlan_t *data,
                                        bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyOuterVlanId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_OuterVlanPri
 *   Purpose
 *      Set expected outer VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which Pri (3 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_OuterVlanPri(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterVlanPri,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterVlanPri_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyOuterVlanPri
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterVlanPri_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOuterVlanPri,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterVlanCfi
 * Purpose:
 *       Set match criteria for bcmFieldQualifyOuterVlanCfi
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterVlanCfi(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterVlanCfi,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterVlanCfi_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyOuterVlanCfi_get
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterVlanCfi_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOuterVlanCfi,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlan
 * Purpose:
 *      Set match criteria for bcmFieldQualifyInnerVlan
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlan(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_vlan_t data,
                                  bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerVlan,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlan_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_vlan_t *data,
                                      bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerVlan,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlanId
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInnerVlanId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlanId(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_vlan_t data,
                                    bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerVlanId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInnerVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlanId_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_vlan_t *data,
                                        bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerVlanId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlanPri
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInnerVlanPri
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlanPri(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerVlanPri,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlanPri_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInnerVlanPri
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlanPri_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerVlanPri,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlanCfi
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInnerVlanCfi
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlanCfi(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerVlanCfi,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlanCfi_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInnerVlanCfi_get
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlanCfi_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerVlanCfi,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L4SrcPort
 * Purpose:
 *      Set match criteria for bcmFieldQualifyL4SrcPort
 *                     qualifier to the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L4SrcPort(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_l4_port_t data,
                                  bcm_l4_port_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL4SrcPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L4SrcPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL4SrcPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L4SrcPort_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_l4_port_t *data,
                                      bcm_l4_port_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL4SrcPort,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L4DstPort
 * Purpose:
 *      Set match criteria for bcmFieldQualifyL4DstPort
 *                     qualifier to the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L4DstPort(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_l4_port_t data,
                                  bcm_l4_port_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL4DstPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L4DstPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL4DstPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L4DstPort_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_l4_port_t *data,
                                      bcm_l4_port_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL4DstPort,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_EtherType
 *   Purpose
 *      Set expected ethernet type for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) uint16 data = which ethertype
 *      (in) uint16 mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_EtherType(int unit,
                                  bcm_field_entry_t entry,
                                  uint16 data,
                                  uint16 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyEtherType,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_EtherType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEtherType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_EtherType_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint16 *data,
                                      uint16 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyEtherType,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_IpProtocol
 *   Purpose
 *      Set expected IPv4 protocol type type for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) uint16 data = which ethertype
 *      (in) uint16 mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_IpProtocol(int unit,
                                   bcm_field_entry_t entry,
                                   uint8 data,
                                   uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpProtocol,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpProtocol_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpProtocol
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpProtocol_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 *data,
                                       uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpProtocol,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Ip6NextHeader(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 data,
                                       uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIp6NextHeader,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ip6NextHeader_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIp6NextHeader
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ip6NextHeader_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIp6NextHeader,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_DSCP
 *   Purpose
 *      Set expected IPv4 DSCP for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) uint8 data = which DSCP
 *      (in) uint8 mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_DSCP(int unit,
                             bcm_field_entry_t entry,
                             uint8 data,
                             uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDSCP,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DSCP_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDSCP
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DSCP_get(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 *data,
                                 uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyDSCP,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_Tos
 *   Purpose
 *      Set expected IPv4 ToS for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) uint8 data = which ToS
 *      (in) uint8 mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_Tos(int unit,
                            bcm_field_entry_t entry,
                            uint8 data,
                            uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Tos_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTos
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Tos_get(int unit,
                                bcm_field_entry_t entry,
                                uint8 *data,
                                uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Ip6TrafficClass(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 data,
                                         uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIp6TrafficClass,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ip6TrafficClass_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIp6TrafficClass
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ip6TrafficClass_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint8 *data,
                                            uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIp6TrafficClass,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Ttl(int unit,
                             bcm_field_entry_t entry,
                             uint8 data,
                             uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTtl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ttl_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTtl
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ttl_get(int unit,
                                bcm_field_entry_t entry,
                                uint8 *data,
                                uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTtl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ip6HopLimit
 * Purpose:
 *      Set match criteria for bcmFieldQualifyIp6HopLimit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ip6HopLimit(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 data,
                                    uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIp6HopLimit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ip6HopLimit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIp6HopLimit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ip6HopLimit_get(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 *data,
                                        uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIp6HopLimit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_TcpControl
 *   Purpose
 *      Set expected TCP control flags for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) uint8 data = which TCP control bits
 *      (in) uint8 mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Also implies TCP as protocol.
 */
int
bcm_petra_field_qualify_TcpControl(int unit,
                                   bcm_field_entry_t entry,
                                   uint8 data,
                                   uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTcpControl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TcpControl_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTcpControl
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TcpControl_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 *data,
                                       uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTcpControl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_dpp_petra_field_entry_group_flags(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 *group_flags)
{
    bcm_dpp_field_info_OLD_t *unitData;
    _bcm_dpp_field_grp_idx_t entryGroup;
    bcm_field_stage_t stage;
    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)) {

        BCMDNX_IF_ERR_EXIT(bcm_petra_field_qualify_Stage_get(unit, entry, &stage));
        *group_flags |= (stage == bcmFieldStageEgress) ? _BCM_DPP_FIELD_GROUP_EGRESS : _BCM_DPP_FIELD_GROUP_INGRESS;
    }
    else 
    {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_petra_field_entry_group(unit, entry, &entryGroup));

        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, entryGroup, group_flags));
    }

exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_ForwardingType(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_field_ForwardingType_t data)
{
    uint64 edata;
    uint64 emask;
    SOC_TMC_PKT_FRWRD_TYPE ppdForwardingType;
    uint32 group_flags = 0;
    uint8 is_ingress;
    uint32 ppdOffsetExtData = 0, ppdOffsetExtMask = 0, ppdMask = 0;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));
    is_ingress = (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS)?1:0;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_forwarding_type_bcm_to_ppd(data, &ppdForwardingType, &ppdMask));
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "fp_restricted_forwarding_type", 0) == 0) {
        if (is_ingress) {
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_offset_ext_bcm_to_ppd(data, &ppdOffsetExtData, &ppdOffsetExtMask));
        }
    }
    else {
        /* No need to set the forwarding extension */
        ppdOffsetExtMask = 0;
    }
    COMPILER_64_SET(edata, 0, ppdForwardingType + (ppdOffsetExtData << 4));
    COMPILER_64_SET(emask, 0, ppdMask + (ppdOffsetExtMask << 4)); /* 4 bits signal */


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyForwardingType,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardingType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyForwardingType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Qualifier match forwarding type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardingType_get(int unit,
                                           bcm_field_entry_t entry,
                                           bcm_field_ForwardingType_t *type)
{
    int32 ppd;
    bcm_field_ForwardingType_t bcm;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyForwardingType,
                                                           &ppd,
                                                           &emask));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_forwarding_type_ppd_to_bcm(unit, (ppd & 0xF), (emask & 0xF), &bcm));
    *type = bcmFieldForwardingTypeAny;
    if ((emask & 0xF)) {
        if (bcm == bcmFieldForwardingTypeMpls) {
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_offset_ext_ppd_to_bcm(((ppd >> 4) & 0x3), ((emask >> 4) & 0x3), &bcm));
        }
        *type = bcm;
    }


exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Vrf(int unit,
                            bcm_field_entry_t entry,
                            uint32 data,
                            uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyVrf,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Vrf_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyVrf
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Vrf_get(int unit,
                                bcm_field_entry_t entry,
                                uint32 *data,
                                uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyVrf,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VlanFormat
 * Purpose:
 *       Set match criteria for bcmFieldQualifyVlanFormat
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VlanFormat(int unit,
                                   bcm_field_entry_t entry,
                                   uint8 data,
                                   uint8 mask)
{
    uint64 edata;
    uint64 emask;
    uint8 is_egress;
    uint32 group_flags = 0;
    SOC_SAND_PP_ETHERNET_FRAME_VLAN_FORMAT ppdVlanFormat;

    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));
    is_egress = (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS)?1:0;

    /* The value of  the 4-bit VLAN-Tag-format is controlled by user in API in advanced vlan-translation mode */
    if (is_egress || SOC_DPP_IS_VLAN_TRANSLATE_MODE_ADVANCED(unit)) {
        COMPILER_64_SET(edata, 0, data);
        COMPILER_64_SET(emask, 0, mask);
    } else {
        if ((0 != mask) && (0xF != (mask & 0xF))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                       " bits set or all bits clear clear)")));
        }
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_vlan_format_bcm_to_ppd(data, &ppdVlanFormat));

        COMPILER_64_SET(edata, 0, ppdVlanFormat);
        if (mask) {
            COMPILER_64_SET(emask, ~0, ~0);
        } else {
            COMPILER_64_ZERO(emask);
        }
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyVlanFormat,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VlanFormat_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyVlanFormat
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VlanFormat_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 *data,
                                       uint8 *mask)
{
    int32 ppd;
    uint8 bcm;
    int32 emask;
    uint8 is_egress;
    uint32 group_flags = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyVlanFormat,
                                                           &ppd,
                                                           &emask));
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));
    is_egress = (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS)?1:0;

    /* The value of  the 4-bit VLAN-Tag-format is controlled by user in API in advanced vlan-translation mode */
    if (is_egress || SOC_DPP_IS_VLAN_TRANSLATE_MODE_ADVANCED(unit)) {
        *data = ppd;
        *mask = emask;
    } else {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_vlan_format_ppd_to_bcm(ppd, &bcm));
        *data = bcm;
        *mask = emask? 0xF:0;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerSrcIp(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip_t data,
                                   bcm_ip_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerSrcIp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerSrcIp_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerSrcIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerSrcIp_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_ip_t *data,
                                       bcm_ip_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerSrcIp,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerDstIp(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip_t data,
                                   bcm_ip_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerDstIp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDstIp_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerDstIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDstIp_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_ip_t *data,
                                       bcm_ip_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerDstIp,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerTos(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerTos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerTos_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerDSCP
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerTos_get(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 *data,
                                     uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerTos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerDSCP(int unit,
                                  bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerDSCP,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDSCP_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerDSCP
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDSCP_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 *data,
                                      uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerDSCP,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerIpProtocol(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 data,
                                        uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerIpProtocol,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerIpProtocol_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerIpProtocol
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerIpProtocol_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint8 *data,
                                            uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerIpProtocol,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IngressStpState(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 data,
                                        uint8 mask)
{
    uint64 edata;
    uint64 emask;
    SOC_PPC_PORT_STP_STATE_FLD_VAL state;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    if ((0 != mask) && (0x7 != (mask & 0x7))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                   " bits set or all bits clear clear)")));
    }
    if (mask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_stp_state_bcm_to_ppd(data, &state));
        COMPILER_64_SET(edata, 0, state);
        COMPILER_64_SET(emask, ~0, ~0);
    } else {
        COMPILER_64_ZERO(edata);
        COMPILER_64_ZERO(emask);
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIngressStpState,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IngressStpState_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIngressStpState
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IngressStpState_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint8 *data,
                                            uint8 *mask)
{
    int32 ppd;
    bcm_stg_stp_t bcm;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIngressStpState,
                                                           &ppd,
                                                           &emask));
    if(emask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_stp_state_ppd_to_bcm(ppd, &bcm));
        *data = bcm;
        *mask = 0x7;
    } else {
        *data = 0;
        *mask = 0;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerL4SrcPort(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_l4_port_t data,
                                       bcm_l4_port_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerL4SrcPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerL4SrcPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerL4SrcPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerL4SrcPort_get(int unit,
                                           bcm_field_entry_t entry,
                                           bcm_l4_port_t *data,
                                           bcm_l4_port_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerL4SrcPort,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerL4DstPort(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_l4_port_t data,
                                       bcm_l4_port_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerL4DstPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerL4DstPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerL4DstPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerL4DstPort_get(int unit,
                                           bcm_field_entry_t entry,
                                           bcm_l4_port_t *data,
                                           bcm_l4_port_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerL4DstPort,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Color
 * Purpose:
 *      Set match criteria for bcmFieldQualifyColor
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      color - (IN) Qualifier match color.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Color(int unit,
                              bcm_field_entry_t entry,
                              uint8 color)
{
    uint64 edata;
    uint64 emask;
    uint32 ppdCol;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_color_bcm_to_ppd(color, &ppdCol));
    COMPILER_64_SET(edata, 0, ppdCol);
    COMPILER_64_SET(emask, ~0, ~0);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyColor,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Color_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyColor
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      color - (OUT) Qualifier match color.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Color_get(int unit,
                                  bcm_field_entry_t entry,
                                  uint8 *color)
{
    int32 temp;
    int32 mask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyColor,
                                                           &temp,
                                                           &mask));
    if (mask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_color_ppd_to_bcm(temp,
                                                        &mask));
        *color = mask;
    }
    else {
        *color = -1;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IntPriority
 * Purpose:
 *      Set match criteria for bcmFieldQualifyIntPriority
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IntPriority(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 data,
                                    uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIntPriority,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IntPriority_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIntPriority
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IntPriority_get(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 *data,
                                        uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIntPriority,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardingVlanId
 * Purpose:
 *      Set match criteria for bcmFieldQualifyForwardingVlanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardingVlanId(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_vlan_t data,
                                         bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyForwardingVlanId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE_NO_SANITY_CHECK(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardingVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyForwardingVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardingVlanId_get(int unit,
                                             bcm_field_entry_t entry,
                                             bcm_vlan_t *data,
                                             bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyForwardingVlanId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/* 
 * Function:
 *      bcm_petra_field_qualify_ForwardHdrVlanId
 * Purpose:
 *      Set match criteria for bcmFieldQualifyForwardHdrVlanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardHdrVlanId(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_vlan_t data,
                                         bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyForwardHdrVlanId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardHdrVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyForwardHdrVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardHdrVlanId_get(int unit,
                                             bcm_field_entry_t entry,
                                             bcm_vlan_t *data,
                                             bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyForwardHdrVlanId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Vpn
 * Purpose:
 *      Set match criteria for bcmFieldQualifyVpn
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Vpn(int unit,
                            bcm_field_entry_t entry,
                            bcm_vpn_t data,
                            bcm_vpn_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyVpn,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Vpn_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyVpn
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Vpn_get(int unit,
                                bcm_field_entry_t entry,
                                bcm_vpn_t *data,
                                bcm_vpn_t *mask)
{
    int32 edata;
    int32 emask;
    int result;

    BCMDNX_INIT_FUNC_DEFS;

    result = _bcm_dpp_field_entry_qualify_int32_get(unit,
                                                    entry,
                                                    bcmFieldQualifyVpn,
                                                    &edata,
                                                    &emask);
    if (BCM_E_NONE == result) {
        *data = edata;
        *mask = emask;
    }
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabel(int unit,
                                            bcm_field_entry_t entry,
                                            uint32 data,
                                            uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsForwardingLabel,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabel_get(int unit,
                                                bcm_field_entry_t entry,
                                                uint32 *data,
                                                uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsForwardingLabel,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabelTtl(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsForwardingLabelTtl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabelTtl_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsForwardingLabelTtl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabelBos(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsForwardingLabelBos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabelBos_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsForwardingLabelBos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabelExp(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsForwardingLabelExp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabelExp_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsForwardingLabelExp,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_create_id
 *   Purpose
 *      Create a statistics set with a specific ID
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = the group number
 *      (in) int nstat = number of statistics requested
 *      (in) bcm_field_stat_t *stat_arr = array of statistics requested
 *      (in) int stat_id = statistics ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      See description of _bcm_petra_field_stat_create.
 */
int
bcm_petra_field_stat_create_id(int unit,
                               bcm_field_group_t group,
                               int nstat,
                               bcm_field_stat_t *stat_arr,
                               int stat_id)
{
    uint32 stat_id_uint;

    BCMDNX_INIT_FUNC_DEFS;

    stat_id_uint = (uint32)stat_id;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_stat_create(unit,
                                               TRUE,
                                               group,
                                               nstat,
                                               stat_arr,
                                               &stat_id_uint));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_create
 *   Purpose
 *      Create a statistics set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = the group number
 *      (in) int nstat = number of statistics requested
 *      (in) bcm_field_stat_t *stat_arr = array of statistics requested
 *      (out) int *stat_id = where to put statistics ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      See description of _bcm_petra_field_stat_create.
 */
int
bcm_petra_field_stat_create(int unit,
                             bcm_field_group_t group,
                             int nstat,
                             bcm_field_stat_t *stat_arr,
                             int *stat_id)
{
    uint32* stat_id_uint;

    BCMDNX_INIT_FUNC_DEFS;

    stat_id_uint = (uint32*)(stat_id);
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_stat_create(unit,
                                               FALSE,
                                               group,
                                               nstat,
                                               stat_arr,
                                               stat_id_uint));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_destroy
 *   Purpose
 *      Destroy a statistics set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = statistics ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 */
int
bcm_petra_field_stat_destroy(int unit,
                             int stat_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X) enter\n"), unit, stat_id));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    result = _bcm_dpp_proc_cntr_from_stat(unit, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);

    _DPP_FIELD_UNIT_LOCK(unitData);

    result = bcm_dpp_counter_free(unit, proc, cntr);
    if (BCM_E_NONE != result) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unable to free unit %d proc %u set %u:"
                              " %d (%s)\n"),
                   unit,
                   proc,
                   cntr,
                   result,
                   _SHR_ERRMSG(result)));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X) return %d (%s)\n"),
               unit,
               stat_id,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_stat_attach
 *   Purpose
 *      Attach a statistics set to an entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry number
 *      (in) int stat_id = statistics ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      A single statistics set can be attached to a number of entries.
 *
 *      This only supports bcmFieldActionStat as the statistics action;
 *      application must use bcm_field_action_{set|get|delete|remove} to
 *      support more than one statistics action on an entry.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_stat_attach(int unit,
                                  bcm_field_entry_t entry,
                                  int stat_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    uint32 param0;
    uint32 param1;
    uint32 groupFlags;
    _bcm_dpp_field_grp_idx_t group;
    int dpp_field_unit_lock_was_taken ;
    int isExternalTcam ;
    uint32 entryFlags;

    BCMDNX_INIT_FUNC_DEFS;
    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%08X) enter\n"), unit, entry, stat_id));

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!(_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("entry %d is not valid for this function"),
                          entry));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1 ;

    /*
     * Was:
     *   group = _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry),_BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry));
     */
    isExternalTcam = _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry) ;
    BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_GROUP_GET(unit,isExternalTcam, _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry), group)) ;
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));
    if (groupFlags & _BCM_DPP_FIELD_GROUP_EGRESS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("bcm_petra_field_entry_stat_attach "
                                   "is only supported for Ingress")));
    }

    isExternalTcam = _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry) ;
    BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit,isExternalTcam,_BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),entryFlags)) ;
    /*
     * Was:
     *   if (0 == (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry)) ))
     */
    if (0 == (entryFlags 
               & _BCM_DPP_FIELD_ENTRY_IN_USE)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not in use\n"),
                   unit,
                   entry));
        result = BCM_E_NOT_FOUND;
    }
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_tcam_entry_action_get(unitData,
                                                      entry,
                                                      bcmFieldActionStat,
                                                      &param0,
                                                      &param1,
                                                      NULL,
                                                      NULL);
        if (BCM_E_NONE == result) {
            /* already has stat action */
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d already has stats %08X;"
                                  " must remove existing stats before"
                                  " replacing\n"),
                       unit,
                       entry,
                       param0));
            result = BCM_E_EXISTS;
        } else if (BCM_E_NOT_FOUND == result) {
            /* does not have stat action, so this is the okay condition */
            result = BCM_E_NONE;
        }
        /* but anything else is an error and left untouched */
    }
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_tcam_entry_action_set(unitData,
                                                      _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                      SOC_CORE_INVALID,
                                                      _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                      bcmFieldActionStat,
                                                      stat_id,
                                                      BCM_ILLEGAL_ACTION_PARAMETER,
                                                      BCM_ILLEGAL_ACTION_PARAMETER,
                                                      BCM_ILLEGAL_ACTION_PARAMETER);
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    dpp_field_unit_lock_was_taken = 0 ;
    
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%08X) return %d (%s)\n"),
               unit,
               entry,
               stat_id,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken)
    {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_stat_detach
 *   Purpose
 *      Detach a statistics set from an entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry number
 *      (in) int stat_id = statistics ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      A single statistics set can be attached to a number of entries, but all
 *      of them must be in the group for which the statistics set was created.
 *
 *      This only supports bcmFieldActionStat as the statistics action;
 *      application must use bcm_field_action_{set|get|delete|remove} to
 *      support more than one statistics action on an entry.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_stat_detach(int unit,
                                  bcm_field_entry_t entry,
                                  int stat_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    uint32 lparam0;
    uint32 lparam1;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%08X) enter\n"),
               unit,
               entry,
               stat_id));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!(_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("entry %d is not valid for this function"),
                          entry));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;

    /* get the action of this sort */
    result = _bcm_dpp_field_tcam_entry_action_get(unitData,
                                                  entry,
                                                  bcmFieldActionStat,
                                                  &lparam0,
                                                  &lparam1,
                                                  NULL,
                                                  NULL);
    if (BCM_E_NONE == result) {
        /* there is a stat action */
        if (lparam0 == stat_id) {
            /* entry's stat is the one we want to detach */
            result = _bcm_dpp_field_tcam_entry_action_clear(unitData,
                                                            _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                            _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                            bcmFieldActionStat);
        } else {
            /* entry's stat is not the one we want to detach */
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d can not detach stat %08X"
                                  " because stat %08X is attached instead\n"),
                       unit,
                       entry,
                       stat_id,
                       lparam0));
            result = BCM_E_PARAM;
        }
    } else if (BCM_E_NOT_FOUND == result) {
        /* there is no stat action on this entry */
        result = BCM_E_EMPTY;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%08X) return %d (%s)\n"),
               unit,
               entry,
               stat_id,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_stat_get
 *   Purpose
 *      Get the statistics set that is attached to an entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry number
 *      (out) int *stat_id = where to put the statistics ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      This only supports bcmFieldActionStat as the statistics action;
 *      application must use bcm_field_action_{set|get|delete|remove} to
 *      support more than one statistics action on an entry.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_stat_get(int unit,
                               bcm_field_entry_t entry,
                               int *stat_id)
{
    int result;
    uint32 param0;
    uint32 param1;

    BCMDNX_INIT_FUNC_DEFS;
    result = bcm_petra_field_action_get(unit,
                                        entry,
                                        bcmFieldActionStat,
                                        &param0,
                                        &param1);
    if (BCM_E_NONE == result) {
        *stat_id = param0;
    }

    BCMDNX_IF_ERR_NOT_E_NOT_FOUND_EXIT(result);

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_config_get
 *   Purpose
 *      Get the specific statistics supported by a set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) int nstat = number of elements in stat_arr
 *      (out) bcm_field_stat_t *stat_arr = where to put list of stats
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Returns actual capabilities of stats on the counter processor for the
 *      specified stat_id, instead of tracking the 'requested' stats.
 */
int
bcm_petra_field_stat_config_get(int unit,
                                int stat_id,
                                int nstat,
                                bcm_field_stat_t *stat_arr)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;
    unsigned int count;
    unsigned int index;
    bcm_dpp_counter_set_t avail;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%d,*) enter\n"), unit, stat_id, nstat));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    result = _bcm_dpp_proc_cntr_from_stat(unit, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);


    if (0 > nstat) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("umber of stats %d must be non-negative"),
                          nstat));
    }
    if (nstat && (!stat_arr)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory OUT arg must not be NULL")));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    result = bcm_dpp_counter_avail_get(unit, proc, &avail, NULL);
    if (BCM_E_NONE == result) {
        for (count = 0, index = 0;
             (index < bcm_dpp_counter_count) &&
             (count < nstat);
             index++) {
            if (SHR_BITGET(avail, index)) {
                if (BCM_E_NONE ==
                    _bcm_dpp_field_stat_unmap(index, &(stat_arr[count]))) {
                    count++;
                }
            }
        }
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%d,*) return %d (%s)\n"),
               unit,
               stat_id,
               nstat,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_size
 *   Purpose
 *      Get the number of statistics in a set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (out) int *stat_size = where to put number of supported stats
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Returns actual capabilities of stats on the counter processor for the
 *      specified stat_id, instead of tracking the 'requested' stats.
 */
int
bcm_petra_field_stat_size(int unit,
                          int stat_id,
                          int *stat_size)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;
    int count;
    unsigned int index;
    bcm_dpp_counter_set_t avail;
    bcm_field_stat_t stat;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,*) enter\n"), unit, stat_id));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!stat_size) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory OUT arg must not be NULL")));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_proc_cntr_from_stat(unit, stat_id, &proc, &cntr);

    result = bcm_dpp_counter_avail_get(unit, proc, &avail, NULL);
    if (BCM_E_NONE == result) {
        for (count = 0, index = 0;
             index < bcm_dpp_counter_count;
             index++) {
            if (SHR_BITGET(avail, index)) {
                if (BCM_E_NONE ==
                    _bcm_dpp_field_stat_unmap(index, &stat)) {
                    count++;
                }
            }
        }
    }
    if (BCM_E_NONE == result) {
        *stat_size = count;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,&(%d)) return %d (%s)\n"),
               unit,
               stat_id,
               *stat_size,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_get
 *   Purpose
 *      Read a specific statistic from a set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) bcm_field_stat_t stat = which statistic to get
 *      (out) uint64 *value = where to put the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 */
int
bcm_petra_field_stat_get(int unit,
                         int stat_id,
                         bcm_field_stat_t stat,
                         uint64 *value)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%s,*) enter\n"),
               unit,
               stat_id,
               ((0 <= stat) && (stat < bcmFieldStatCount))?_bcm_dpp_field_stats_names[stat]:"???"));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!value) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory OUT arg must not be NULL")));
    }
    result = _bcm_dpp_proc_cntr_from_stat(unit, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);


    if ((0 > stat) || (bcmFieldStatCount <= stat)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("invalid statistic %d"), stat));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    result = _bcm_dpp_field_stat_access_single(unitData,
                                               stat_id,
                                               proc,
                                               cntr,
                                               stat,
                                               FALSE,
                                               value);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%s,&(%08X%08X)) return %d (%s)\n"),
               unit,
               stat_id,
               ((0 <= stat) && (stat < bcmFieldStatCount))?_bcm_dpp_field_stats_names[stat]:"???",
               COMPILER_64_HI(*value),
               COMPILER_64_LO(*value),
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
   BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_get32
 *   Purpose
 *      Read a specific statistic from a set (32b)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) bcm_field_stat_t stat = which statistic to get
 *      (out) uint32 *value = where to put the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 *
 *      Saturates the returned value if actual is too large.
 */
int
bcm_petra_field_stat_get32(int unit,
                           int stat_id,
                           bcm_field_stat_t stat,
                           uint32 *value)
{
    uint64 temp, temp1;
    int result;

    BCMDNX_INIT_FUNC_DEFS;
    result = bcm_petra_field_stat_get(unit, stat_id, stat, &temp);
    if (BCM_E_NONE == result) {
        COMPILER_64_SET(temp1, 0xFFFFFFFF, 0xFFFFFFFF);
        if (COMPILER_64_LT(temp , temp1)) {
            COMPILER_64_TO_32_LO(*value, temp);
        } else {
            *value = 0xFFFFFFFF;
        }
    }
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_multi_get
 *   Purpose
 *      Read a number of statistics from a set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) int nstat = number of statistics to get
 *      (in) bcm_field_stat_t *stat_Arr = which statistics to get
 *      (out) uint64 *value_arr = where to put the values
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 */
int
bcm_petra_field_stat_multi_get(int unit,
                               int stat_id,
                               int nstat,
                               /* const */ bcm_field_stat_t *stat_arr,
                               uint64 *value_arr)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%d,*) enter\n"),
               unit,
               stat_id,
               nstat));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (0 > nstat) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("nstat must not be negative")));
    }
    if (nstat && (!stat_arr)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("stat_arr must not be NULL if nstat > 0")));
    }
    if (nstat && (!value_arr)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("value_arr must not be NULL if nstat > 0")));
    }
    result = _bcm_dpp_proc_cntr_from_stat(unit, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);

    _DPP_FIELD_UNIT_LOCK(unitData);
    result = _bcm_dpp_field_stat_access_multi(unitData,
                                               stat_id,
                                               proc,
                                               cntr,
                                               nstat,
                                               stat_arr,
                                               FALSE,
                                               value_arr);

 
    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%d,*) return %d (%s)\n"),
               unit,
               stat_id,
               nstat,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_multi_get32
 *   Purpose
 *      Read a number of statistics from a set (32b)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) int nstat = number of statistics to get
 *      (in) bcm_field_stat_t *stat_Arr = which statistics to get
 *      (in) int nvalue = number of places for values
 *      (out) uint32 *value_arr = where to put the values
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 *
 *      Saturates the returned values if actual are too large.
 */
int
bcm_petra_field_stat_multi_get32(int unit,
                                  int stat_id,
                                  int nstat,
                                  bcm_field_stat_t *stat_arr,
                                  uint32 *value_arr)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;
    unsigned int index;
    uint64 temp1;
    uint64 value_arr_64_bits[bcmFieldStatCount];
    

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%d,*) enter\n"),
               unit,
               stat_id,
               nstat));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (0 > nstat) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("nstat must not be negative")));
    }
    if (nstat && (!stat_arr)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("stat_arr must not be NULL if nstat > 0")));
    }
    if (!value_arr) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("value_arr must not be NULL")));
    }

    result = _bcm_dpp_proc_cntr_from_stat(unit, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);


    _DPP_FIELD_UNIT_LOCK(unitData);
    result = _bcm_dpp_field_stat_access_multi(unitData,
                                               stat_id,
                                               proc,
                                               cntr,
                                               nstat,
                                               stat_arr,
                                               FALSE,
                                               value_arr_64_bits);    
    for (index = 0; index < nstat; index++)
    {
        COMPILER_64_SET(temp1,0xFFFFFFFF,0xFFFFFFFF);
        if (COMPILER_64_LT(value_arr_64_bits[index] ,temp1)) {
            COMPILER_64_TO_32_LO(value_arr[index], value_arr_64_bits[index]);
        } else {
            value_arr[index] = 0xFFFFFFFF;
        }
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%d,*) return %d (%s)\n"),
               unit,
               stat_id,
               nstat,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_set
 *   Purpose
 *      Set a specific statistic in a set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) bcm_field_stat_t stat = which statistic to get
 *      (in) uint64 value = the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 */
int
bcm_petra_field_stat_set(int unit,
                         int stat_id,
                         bcm_field_stat_t stat,
                         uint64 value)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%s,%08X%08X) enter\n"),
               unit,
               stat_id,
               ((0 <= stat) && (stat < bcmFieldStatCount))?_bcm_dpp_field_stats_names[stat]:"???",
               COMPILER_64_HI(value),
               COMPILER_64_LO(value)));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    result = _bcm_dpp_proc_cntr_from_stat(unit, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);

    if ((0 > stat) || (bcmFieldStatCount <= stat)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("invalid statistic %d"), stat));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    result = _bcm_dpp_field_stat_access_single(unitData,
                                               stat_id,
                                               proc,
                                               cntr,
                                               stat,
                                               TRUE,
                                               &value);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%s,%08X%08X) return %d (%s)\n"),
               unit,
               stat_id,
               ((0 <= stat) && (stat < bcmFieldStatCount))?_bcm_dpp_field_stats_names[stat]:"???",
               COMPILER_64_HI(value),
               COMPILER_64_LO(value),
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_set32
 *   Purpose
 *      Set a specific statistic in a set (32b)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) bcm_field_stat_t stat = which statistic to get
 *      (in) uint32 value = the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 *
 *      Upper 32b of the statistic will be zero after the write.
 */
int
bcm_petra_field_stat_set32(int unit,
                           int stat_id,
                           bcm_field_stat_t stat,
                           uint32 value)
{
    uint64 temp;

    BCMDNX_INIT_FUNC_DEFS;
    COMPILER_64_SET(temp, 0, value);
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(bcm_petra_field_stat_set(unit, stat_id, stat, temp));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_all_set
 *   Purpose
 *      Set all statistics in a set (to the same value)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) uint64 value = the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Note the 'get' version has something that individually retrieves the
 *      member statistics from a set, but this writes the same value to all.
 *
 *      This only sets values for 'native' statistics.  All statistics derived
 *      from the native statistics will have their relative derivations left
 *      unaffected (so, for example, if the hardware has native support for
 *      red and green and blue, and emulated support for all, the value will be
 *      written to each of red and green and blue, causing the emulated all
 *      counter to contain red+gree+blue, or 3 * the written value).
 *
 *      Probably this function has little real use outside of clearing, where
 *      zero is written to all counters.  In this special case, the native
 *      counters being cleared will also implicitly clear the emulated ones.
 */
int
bcm_petra_field_stat_all_set(int unit,
                             int stat_id,
                             uint64 value)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;
    unsigned int index;
    bcm_dpp_counter_set_t native;
    uint8 stats_cached;
    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%08X%08X) enter\n"),
               unit,
               stat_id,
               COMPILER_64_HI(value),
               COMPILER_64_LO(value)));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    result = _bcm_dpp_proc_cntr_from_stat(unit, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);

    result = bcm_dpp_counter_cache_only_get(unit, &stats_cached);
    BCMDNX_IF_ERR_EXIT(result);

    _DPP_FIELD_UNIT_LOCK(unitData);

    result = bcm_dpp_counter_avail_get(unit, proc, NULL, &native);
    for (index = 0;
         (BCM_E_NONE == result) && (index < bcm_dpp_counter_count);
         index++) {
        if (SHR_BITGET(native, index)) {
#if _BCM_PETRA_ALLOW_CACHED_STAT_WRITE
            if (stats_cached) {
                result = bcm_dpp_counter_set_cached(unit, proc, cntr, index, value);
            } else {
#endif /* _BCM_PETRA_ALLOW_CACHED_STAT_WRITE */
                result = bcm_dpp_counter_set(unit, proc, cntr, index, value);
#if _BCM_PETRA_ALLOW_CACHED_STAT_WRITE
            }
#endif /* _BCM_PETRA_ALLOW_CACHED_STAT_WRITE */
        } /* if (SHR_BITGET(native, index)) */
    } /* for (all counters as long as no error) */

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%08X%08X) return %d (%s)\n"),
               unit,
               stat_id,
               COMPILER_64_HI(value),
               COMPILER_64_LO(value),
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_all_set32
 *   Purpose
 *      Set all statistics in a set (to the same 32b value)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) uint32 value = the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Note the 'get' version has something that individually retrieves the
 *      member statistics from a set, but this writes the same value to all.
 *
 *      This only sets values for 'native' statistics.  All statistics derived
 *      from the native statistics will have their relative derivations left
 *      unaffected (so, for example, if the hardware has native support for
 *      red and green and blue, and emulated support for all, the value will be
 *      written to each of red and green and blue, causing the emulated all
 *      counter to contain red+gree+blue, or 3 * the written value).
 *
 *      Probably this function has little real use outside of clearing, where
 *      zero is written to all counters.  In this special case, the native
 *      counters being cleared will also implicitly clear the emulated ones.
 */
int
bcm_petra_field_stat_all_set32(int unit,
                               int stat_id,
                               uint32 value)
{
    uint64 temp;

    BCMDNX_INIT_FUNC_DEFS;
    COMPILER_64_SET(temp, 0, value);
    BCMDNX_IF_ERR_EXIT(bcm_petra_field_stat_all_set(unit, stat_id, temp));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_policer_attach
 *   Purpose
 *      Attach a policer to a specified entry, at the given heirarchical level
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) int level = level (for heirarchical policing)
 *      (in) bcm_policer_t policer = which policer to attach to the entry
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Policers are managed through the bcm_policer_* APIs.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_policer_attach(int unit,
                                      bcm_field_entry_t entry_id,
                                      int level,
                                      bcm_policer_t policer_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    uint32 param0;
    uint32 param1;
    uint32 entryFlags ;
    int isExternalTcam ;
    int entry ;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%d,%08X) enter\n"),
               unit,
               entry_id,
               level,
               policer_id));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!(_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry_id))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("entry %d is not valid for this function"),
                          entry_id));
    }
    if ((0 > level) || (1 < level)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("invalid policer level %d"),
                          level));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;
    isExternalTcam = _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_id) ;
    entry = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry_id) ;
    BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit,isExternalTcam, entry, entryFlags)) ;
    /*
     * Was:
     *   if (0 == (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_id), _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry_id)) ))
     */
    if (0 == (entryFlags 
              & _BCM_DPP_FIELD_ENTRY_IN_USE)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not in use\n"),
                   unit,
                   entry_id));
        result = BCM_E_NOT_FOUND;
    }
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_tcam_entry_action_get(unitData,
                                                      entry_id,
                                                      level?
                                                      bcmFieldActionPolicerLevel1:
                                                      bcmFieldActionPolicerLevel0,
                                                      &param0,
                                                      &param1,
                                                      NULL,
                                                      NULL);
        if (BCM_E_NONE == result) {
            /* already has stat action */
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d already has policer %08X"
                                  " at level %d; must remove existing policer"
                                  " before replacing\n"),
                       unit,
                       entry_id,
                       level,
                       param0));
            result = BCM_E_EXISTS;
        } else if (BCM_E_NOT_FOUND == result) {
            /* does not have stat action, so this is the okay condition */
            result = BCM_E_NONE;
        }
        /* but anything else is an error and left untouched */
    }
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_tcam_entry_action_set(unitData,
                                                      _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_id), 
                                                      SOC_CORE_INVALID,
                                                      _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry_id),
                                                      level?
                                                      bcmFieldActionPolicerLevel1:
                                                      bcmFieldActionPolicerLevel0,
                                                      policer_id,
                                                      BCM_ILLEGAL_ACTION_PARAMETER,
                                                      BCM_ILLEGAL_ACTION_PARAMETER,
                                                      BCM_ILLEGAL_ACTION_PARAMETER);
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%d,%08X) return %d (%s)\n"),
               unit,
               entry_id,
               level,
               policer_id,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_policer_detach
 *   Purpose
 *      Remove the policer used by the specified entry at the given level
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) int level = level (for heirarchical policing)
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Policers are managed through the bcm_policer_* APIs.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_policer_detach(int unit,
                                      bcm_field_entry_t entry_id,
                                      int level)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    if ((0 > level) || (1 < level)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("level %d is not valid"),
                          level));
    }
    BCMDNX_IF_ERR_EXIT(bcm_petra_field_action_remove(unit,
                                                  entry_id,
                                                  level?
                                                  bcmFieldActionPolicerLevel1:
                                                  bcmFieldActionPolicerLevel0));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_policer_detach_all
 *   Purpose
 *      Remove all policers used by the specified entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Does not return an error if a level has no policer.
 *
 *      Policers are managed through the bcm_policer_* APIs.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_policer_detach_all(int unit,
                                          bcm_field_entry_t entry_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    int index;
    uint32 entryFlags ;
    int isExternalTcam ;
    int entry ;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"),
               unit,
               entry_id));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!(_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry_id))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("entry %d is not valid for this function"),
                          entry_id));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;
    isExternalTcam = _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_id) ;
    entry = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry_id) ;
    BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_GET(unit,isExternalTcam, entry, entryFlags)) ;
    /*
     * Was:
     *   if (0 == (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_id), _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry_id)) ) )
     */
    if (0 == (entryFlags &
              _BCM_DPP_FIELD_ENTRY_IN_USE)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not in use\n"),
                   unit,
                   entry_id));
        result = BCM_E_NOT_FOUND;
    } else { /* if (entry is not in use) */
        for (index = 0;
             (BCM_E_NONE == result) && (index < 2);
             index++) {
            result = _bcm_dpp_field_tcam_entry_action_clear(unitData,
                                                            _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_id), 
                                                            _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry_id),
                                                            index?
                                                            bcmFieldActionPolicerLevel1:
                                                            bcmFieldActionPolicerLevel0);
            if ((BCM_E_NOT_FOUND == result) ||
                (BCM_E_CONFIG == result) ||
                (BCM_E_UNAVAIL == result)) {
                /*
                 *  For BCM_E_NOT_FOUND, we know the entry exists but policer
                 *  action was not found, but this should not result in an error
                 *  from this function.
                 *
                 *  For BCM_E_CONFIG, this occurs if the group does not have
                 *  the policer specified in its ASET, so safe to say the entry
                 *  does not have this policer.
                 *
                 *  For BCM_E_UNAVAIL, this occurs if the unit does not support
                 *  this policer on this stage, so safe to say the entry does not
                 *  have this policer.
                 */
                result = BCM_E_NONE;
            }
        } /* for (all supported policer 'levels') */
    } /* if (entry is not in use) */

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               entry_id,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_policer_get
 *   Purpose
 *      Get the policer used by the specified entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (out) bcm_policer_t *policer = where to put the policer ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Policers are managed through the bcm_policer_* APIs.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_policer_get(int unit,
                                   bcm_field_entry_t entry_id,
                                   int level,
                                   bcm_policer_t *policer_id)
{
    int result;
    uint32 param0;
    uint32 param1;

    BCMDNX_INIT_FUNC_DEFS;
    if ((0 > level) || (1 < level)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("level %d is not valid"),
                          level));
    }
    result = bcm_petra_field_action_get(unit,
                                        entry_id,
                                        level?
                                        bcmFieldActionPolicerLevel1:
                                        bcmFieldActionPolicerLevel0,
                                        &param0,
                                        &param1);
    if (BCM_E_NONE == result) {
        *policer_id = param0;
    }
    BCMDNX_IF_ERR_NOT_E_NOT_FOUND_EXIT(result);

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_control_get
 *   Purpose
 *      Get the value of a unit-wide field control.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_control_t control = the control to be read
 *      (out) uint32 *state = pointer to where to put the state
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_control_get(int unit,
                             bcm_field_control_t control,
                             uint32 *state)
{
    uint8 stats_cached;
    uint32 large_direct_lu_key_length = 0;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%s,*) enter\n"),
               unit,
               ((0 <= control) && (bcmFieldControlCount > control))?_bcm_dpp_field_control_names[control]:"???"));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > control) || (bcmFieldControlCount <= control)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("invalid field control %d"), control));
    }
    if (!state) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory OUT arg must not be NULL")));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    result = BCM_E_NONE;
    switch (control) {
    case bcmFieldControlStatSyncEnable:
        /* allow control over whether using 'cached' or 'direct' stats */
        result = bcm_dpp_counter_cache_only_get(unit, &stats_cached);
        *state = !stats_cached;
        break;
    case bcmFieldControlCascadedKeyWidth:
    {
        /* just get the cached copy */
        uint8 cascadedKeyLen ; 
        /*
         * Was:
         *   *state = unitData->cascadedKeyLen;
         */
        result = FIELD_ACCESS.cascadedKeyLen.get(unit, &cascadedKeyLen) ;
        if (result == BCM_E_NONE) {
            *state = cascadedKeyLen ;
        }
        break;
    }
    case bcmFieldControlKeyGenVar:
        result = FIELD_ACCESS.keyGenVar.get(unit, state);
        if (result != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Get KeyGenVar failed!")));
        }
        break;
    case bcmFieldControlLargeDirectLuKeyLength:
        large_direct_lu_key_length = SOC_DPP_JER_CONFIG(unit)->pp.kaps_large_db_bits;
        if (!_BCM_DPP_FIELD_LARGE_DIRECT_LOOKUP_KEY_SIZE_VALID(large_direct_lu_key_length)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,
                         (_BSL_BCM_MSG("invalid large direct lookup key length %d."), large_direct_lu_key_length));
        }

        *state = large_direct_lu_key_length;
        break;
    default:
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d unsupported field control %s\n"),
                   unit,
                   _bcm_dpp_field_control_names[control]));
        result = BCM_E_UNAVAIL;
    }
    _DPP_FIELD_UNIT_UNLOCK(unitData);

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%s,&(%08X)) return %d (%s)\n"),
               unit,
               ((0 <= control) && (bcmFieldControlCount > control))?_bcm_dpp_field_control_names[control]:"???",
               *state,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_control_set
 *   Purpose
 *      Set the status of the field APIs.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_control_t control = the control to be written
 *      (in) uint32 *state = new state
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_control_set(int unit,
                             bcm_field_control_t control,
                             uint32 state)
{
    _DPP_FIELD_COMMON_LOCALS;
    SOC_PPC_FP_CONTROL_INDEX control_ndx;
    SOC_PPC_FP_CONTROL_INFO control_info;
    uint32 soc_sand_rv;
    uint32 success;
    _bcm_dpp_field_grp_idx_t groupCascaded ;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%s,%08X) enter\n"),
               unit,
               ((0 <= control) && (bcmFieldControlCount > control))?_bcm_dpp_field_control_names[control]:"???",
               state));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > control) || (bcmFieldControlCount <= control)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("invalid field control %d"), control));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;
    result = BCM_E_NONE;
    switch (control) {
    case bcmFieldControlStatSyncEnable:
        /* allow control over whether using 'cached' or 'direct' stats */
        result = bcm_dpp_counter_cache_only_set(unit, state ? FALSE : TRUE);

#ifdef BCM_WARM_BOOT_SUPPORT
#if (0)
/* { */
    /*
     * All 'save' and 'sync' of old sw state are dropped.
     */
        _bcm_dpp_field_unit_wb_save(unitData, NULL, NULL);
/* } */
#endif
#endif /* def BCM_WARM_BOOT_SUPPORT */
        break;
    case bcmFieldControlCascadedKeyWidth:
        SOC_PPC_FP_CONTROL_INDEX_clear(&control_ndx);
        SOC_PPC_FP_CONTROL_INFO_clear(&control_info);
        control_ndx.type = SOC_PPC_FP_CONTROL_TYPE_KEY_CHANGE_SIZE;
        control_ndx.val_ndx = 0;
        control_info.val[0] = state;
        if ((0 >= state) || (unitData->devInfo->cascadeKeyLimit < state)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d only supports %s values in the"
                                  " range 1..%u\n"),
                       unit,
                       _bcm_dpp_field_control_names[control],
                       unitData->devInfo->cascadeKeyLimit));
            result = BCM_E_PARAM;
        }
        if (BCM_E_NONE == FIELD_ACCESS.groupCascaded.get(unit, &groupCascaded)) {
            if (groupCascaded) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d requires %s be set before any"
                                      " groups use the cascading features\n"),
                           unit,
                           _bcm_dpp_field_control_names[control]));
                result = BCM_E_CONFIG;
            }
        }
        if (BCM_E_NONE == result) {
            soc_sand_rv = soc_ppd_fp_control_set(unitData->unitHandle,
                                                 SOC_CORE_INVALID,
                                                 &control_ndx,
                                                 &control_info,
                                                 &success);
            result = handle_sand_result(soc_sand_rv);
            if (BCM_E_NONE == result) {
                result = translate_sand_success_failure(success);
            }
            if (BCM_E_NONE == result) {
                /*
                 * Was:
                 *   unitData->cascadedKeyLen = state;
                 */
                if (!SOC_WARM_BOOT(unit)) {  /*Cold boot -  allocate sw-state resources */
                    result = FIELD_ACCESS.cascadedKeyLen.set(unit, state);
                }
            }
        }
        break;
    case bcmFieldControlKeyGenVar:
        result = FIELD_ACCESS.keyGenVar.set(unit, state) ;
        if (result != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Set KeyGenVar failed!")));
        }
        break;
    
    case bcmFieldControlExternalUdfEnable:
    case bcmFieldControlIntraDoubleEnable:
        break;
    /*Field processor large direct lookup key length. valid values are 14,15,16,17 18*/
    case bcmFieldControlLargeDirectLuKeyLength:
        if (_BCM_DPP_FIELD_LARGE_DIRECT_LOOKUP_KEY_SIZE_VALID(state))
        {
            BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.kaps_large_db_bits.set(unit, state));
            SOC_DPP_JER_CONFIG(unit)->pp.kaps_large_db_bits = state; 
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("invalid large direct lookup key length %d"), state));
        }  
        break;
    default:
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d unsupported field control %s\n"),
                   unit,
                   _bcm_dpp_field_control_names[control]));
        result = BCM_E_UNAVAIL;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%s,%08X) return %d (%s)\n"),
               unit,
               ((0 <= control) && (bcmFieldControlCount > control))?_bcm_dpp_field_control_names[control]:"???",
               state,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_stage_info_get
 * Purpose:
 *     Get field information 
 * Parameters:
 *      unit - (IN) Unit number.
 *      stage - (IN) field stage.
 *      info - (OUT) field information .
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_stage_info_get(
        int unit, 
        bcm_field_stage_t      stage,
        bcm_field_stage_info_t *info) 
{
    _DPP_FIELD_COMMON_LOCALS;
    int stage_idx;
    SOC_PPC_FP_DATABASE_STAGE soc_stage;
    int num_bcm_stages ;
    int found ;
  
    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, *) enter\n"), unit));
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(info);

    info->field_presel_advanced_mode = (soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE) );
    /*
     * Get maximal number of stages supported by this system. See _bcm_arad_field_device_info
     * and _bcm_arad_field_stage_info[]
     */
    num_bcm_stages = _bcm_arad_field_get_num_stages() ;
    if (num_bcm_stages > bcmFieldStageCount) {
        num_bcm_stages = bcmFieldStageCount ;
    }

    found = FALSE ;
    for (stage_idx=0 ; stage_idx < num_bcm_stages ; stage_idx++) 
    {
        if (stage == _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage_idx).bcmStage )
        {
            found = TRUE ;
            break;
        }
    }
    if (!found) {
      result = _SHR_E_NOT_FOUND ;
      BCMDNX_IF_ERR_EXIT(result) ;
    }
    soc_stage = _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage_idx).hwStageId;
    
    result = MBCM_PP_DRIVER_CALL(unit,mbcm_pp_presel_max_id_get,(unit,soc_stage,&(info->field_presel_max_id)));
    BCMDNX_IF_ERR_EXIT(result);

    info->field_presel_staggered_max_id = ( soc_stage == SOC_PPC_FP_DATABASE_STAGE_INGRESS_PMF ) ? SOC_DPP_DEFS_GET(unit, nof_ingress_pmf_program_selection_lines) : -1;

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_mode_get
 *   Purpose
 *      Get the mode (width) of a group.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (out) bcm_mode_t *mode = the mode (width) of the group
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_mode_get(int unit,
                               bcm_field_group_t group,
                               bcm_field_group_mode_t *mode)
{
    _bcm_dpp_field_grp_idx_t groupLimit;
    uint32 groupD_groupFlags;
    bcm_field_group_mode_t groupD_grpMode;
    _DPP_FIELD_COMMON_LOCALS;
    int dpp_field_unit_lock_was_taken = 0;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!mode) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("Obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1;
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupD_groupFlags));
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.grpMode.get(unit, group, &groupD_grpMode));
    if (groupD_groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        *mode = groupD_grpMode;
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, &(%s(%d))) return %d (%s)\n"),
               unit,
               group,
               _bcm_dpp_field_group_mode_name[*mode],
               *mode,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_compress
 *   Purpose
 *      Compress a group
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Does not really do anything.
 */
int
bcm_petra_field_group_compress(int unit, bcm_field_group_t group)
{
    uint32 soc_sand_rv;
    unsigned int soc_sand_dev_id;
    int dpp_field_unit_lock_was_taken ;
    _bcm_dpp_field_grp_idx_t groupLimit;
    uint32 groupD_groupFlags;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    dpp_field_unit_lock_was_taken = 0 ;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1 ;
    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupD_groupFlags));
    if (groupD_groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        soc_sand_dev_id = (unit);
        soc_sand_rv = soc_ppd_fp_database_compress(soc_sand_dev_id, group);
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    dpp_field_unit_lock_was_taken = 0 ;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (dpp_field_unit_lock_was_taken)
    {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualifier_delete
 * Purpose:
 *      Remove match criteria from a field processor entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      qual_id - (IN) BCM field qualifier id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualifier_delete(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_field_qualify_t qual_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    uint64 *edata = NULL;
    _bcm_dpp_field_b_qual_t qualD;
    int index = 0;
    bcm_field_qualify_t qualType;

    BCMDNX_INIT_FUNC_DEFS;
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    edata = sal_alloc(sizeof(*edata) * unitData->devInfo->qualChain,
                      "qualifier delete buffer");
    if (!edata) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY,
                         (_BSL_BCM_MSG("unable to allocate %u bytes for"
                                   " qualifier delete buffer"),
                          (uint32)sizeof(*edata) * unitData->devInfo->qualChain));
    }
    sal_memset(edata,
               0x00,
               sizeof(*edata) * unitData->devInfo->qualChain);
    result = _bcm_dpp_field_entry_qualifier_general_set(unit,
                                                        entry,
                                                        qual_id,
                                                        unitData->devInfo->qualChain,
                                                        edata,
                                                        edata);
    if(_BCM_DPP_QUALIFIER_IS_KEPT_IN_SW_STATE(qual_id))
    {
        /* Initialize the qualifier data kept in SW state for this qualifier entry */
        qualD.qualType = bcmFieldQualifyCount;
        qualD.bcmParam0 = 0;
        qualD.bcmMask0 = 0;
        qualD.bcmParam1 = 0;
        qualD.bcmMask1 = 0;

        if (_BCM_DPP_FIELD_ENT_IS_INTTCAM(unit, entry))
        {
            for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++)
            {
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYTC.entryCmn.entryBcmQual.qualType.get(unit, _BCM_DPP_FIELD_INTTCAM_LOCAL_ID(unit, entry), index, &qualType));
                if(qualType == qual_id)
                {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYTC.entryCmn.entryBcmQual.set(unit, _BCM_DPP_FIELD_INTTCAM_LOCAL_ID(unit, entry), index, &qualD));
                }
            }
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
        } else if (_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry))
        {
            for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++)
            {
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYEXTTC.entryCmn.entryBcmQual.qualType.get(unit, _BCM_DPP_FIELD_EXTTCAM_LOCAL_ID(unit, entry), index, &qualType))
                if(qualType == qual_id)
                {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_ENTRYEXTTC.entryCmn.entryBcmQual.set(unit, _BCM_DPP_FIELD_EXTTCAM_LOCAL_ID(unit, entry), index, &qualD));
                }
            }
#endif
        } else if (_BCM_DPP_FIELD_ENT_IS_DIR_EXT(unit, entry))
        {
            for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++)
            {
                BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryBcmQual.qualType.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), index, &qualType));
                if(qualType == qual_id)
                {
                    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.entryDe.entryCmn.entryBcmQual.set(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), index, &qualD));
                }
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(result);
exit:
    if (edata) {
        sal_free(edata);
    }

    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_HeaderFormatExtension(int unit,
                                     bcm_field_entry_t entry,
                                     bcm_field_header_format_extension_t header_format_extension)
{
    bcm_field_header_format_t header_format ;
    int loc_err ;
    DPP_PFC_E pfc_sw ;
    DPP_PLC_E plc_sw ;
    uint32 plc_hw, plc_hw_mask ;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    header_format = bcmFieldHeaderFormatCount ;
    /*
     * First check whether PFC (headerFormat) qualifier has been assigned to
     * this entry.
     * If so, this procedure retrieves a specific SW PLC (See DPP_PFC_E) together with
     * the value/mask pair that is currently stored in HW.
     * If no PFC (headerFormat) qualifier has been assigned to this entry, then SW PLC
     * is assumed, by default, to be DPP_PFC_ANY.
     */
    loc_err = bcm_petra_field_qualify_HeaderFormat_get(unit,entry,&header_format) ;
    if (loc_err == BCM_E_NONE)
    {
        if (header_format == bcmFieldHeaderFormatCount)
        {
            /*
             * BCM level PFC (headerFormat) qualifier is not effective on this entry.
             * Assume that PFC qualifier is not there. In that case, use DPP_PFC_ANY.
             */
            pfc_sw = DPP_PFC_ANY ;
        }
        else
        {
            uint32 pfc_pmf, pfc_pmf_mask ;
            /*
             * BCM level PFC (headerFormat) qualifier has been found.
             * Now find its corresponding SW PFC (See DPP_PFC_E).
             */
            /*
             * Convert it to low level (PPD) sw equivalent.
             */
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_HeaderFormat_bcm_to_ppd(unit, header_format,&pfc_sw,&pfc_pmf,&pfc_pmf_mask)) ;
            /*
             * At this point, 'pfc_sw' contains a legitimate value (otherwise, procedure above would
             * have returned an error code).
             */
        }
    }
    else if (loc_err == BCM_E_CONFIG)
    {
        /*
         * BCM level PFC (headerFormat) qualifier has not been specified on this entry.
         * In that case, use DPP_PFC_ANY.
         */
        pfc_sw = DPP_PFC_ANY ;
    }
    else
    {
        BCMDNX_IF_ERR_EXIT(loc_err) ;
    }
    /*
     * At this point, 'pfc_sw' contains a legitimate value.
     *
     * Now make sure specified 'header_format_extension' is part of it:
     *   a. Convert BCM level 'header_format_extension' to low level (PLC) value of type DPP_PLC_E
     *   b. Check whether the PFC-PLC is acceptable on this system. If it is not then return
     *      to caller with 'fail' (BCM_E_NOT_FOUND) indication.
     */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_HeaderFormatExtension_bcm_to_ppd(header_format_extension,&plc_sw) ) ;
    /*
     * Note that on ACL HW, an all-ones mask means that the qualifier is ignored.
     */
    loc_err = dpp_parser_plc_acl_by_sw(unit, pfc_sw, plc_sw, &plc_hw, &plc_hw_mask) ;
    if (loc_err != SOC_E_NONE)
    {
        /*
         * Note that a return value of error from dpp_parser_plc_acl_by_sw() indicates
         * that input PLC (header_format_extension) could not be found on SW PFC deduced from
         * PFC stored on specified entry.
         */
        if (header_format < bcmFieldHeaderFormatCount)
        {
            /*
             * Enter if SW PFC was deduced from a legitimate header format (PFC)
             */
            BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("\r\n"
                              "Entry 0x%08lX has BCM level Header Format %d (%s).\r\n"
                              "Corresponding low level PFC %d (%s) does NOT support low level PLC %d. Quit."),
                              (uint32)entry, header_format,_bcm_dpp_field_header_format_names[header_format],
                              pfc_sw,dpp_parser_pfc_string_by_sw(unit, pfc_sw),
                              plc_sw));
        }
        else
        {
            /*
             * Enter if SW PFC has not been deduced from stored PFC and was taken as default.
             */
            BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("\r\n"
                              "Entry 0x%08lX has no BCM level Header Format.\r\n"
                              "Default low level PFC %d (%s) does not contain low level PLC %d. Quit."),
                              (uint32)entry,
                              pfc_sw,dpp_parser_pfc_string_by_sw(unit, pfc_sw),
                              plc_sw));
        }
    }
    {
        /*
         * At this point, input PLC is OK and may be added, as qualifier, to input entry.
         * HW values (PLC and its MASK) are in: plc_hw, plc_hw_mask
         */
        uint64 edata;
        uint64 emask;
        uint32 data;
        uint32 mask;

        data = plc_hw ;
	mask = plc_hw_mask ;

        COMPILER_64_SET(edata, 0, data);
        COMPILER_64_SET(emask, 0, mask);
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyHeaderFormatExtension,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
/* { */
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
/* } */
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * a.
 *   If this procedure returns with an error code then it may either be
 *   a true error or it may, simply, be that HeaderFormatExtension qualifier
 *   is not specified (or can not be specified) for this entry. 
 * b.
 *   If this procedure loads '*header_format_extension' by 'bcmFieldHeaderFormatExtensionCount'
 *   then either the mask of this qualifier is zero or it was not found (See
 *   _bcm_dpp_field_qualifier_get_int()). In both cases, it is not active.
 */
int
bcm_petra_field_qualify_HeaderFormatExtension_get(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_field_header_format_extension_t *header_format_extension_p)
{
    bcm_field_header_format_t header_format ;
    int loc_err ;
    DPP_PFC_E pfc_sw ;

    BCMDNX_INIT_FUNC_DEFS;

    /*
     * First check whether PFC (headerFormat) qualifier has been assigned to
     * this entry.
     * If so, this procedure retrieves a specific SW PLC (See DPP_PFC_E) together with
     * the value/mask pair that is currently stored in HW.
     * If no PFC (headerFormat) qualifier has been assigned to this entry, then SW PLC
     * is assumed, by default, to be DPP_PFC_ANY.
     */
    loc_err = bcm_petra_field_qualify_HeaderFormat_get(unit,entry,&header_format) ;
    if (loc_err == BCM_E_NONE)
    {
        if (header_format == bcmFieldHeaderFormatCount)
        {
            /*
             * BCM level PFC (headerFormat) qualifier has not been found to be effective (mask is zero).
             * Assume that PFC qualifier is not there. In that case, use DPP_PFC_ANY.
             */
            pfc_sw = DPP_PFC_ANY ;
        }
        else
        {
            uint32 pfc_pmf, pfc_pmf_mask ;
            /*
             * BCM level PFC (headerFormat) qualifier has been found.
             * Now find its corresponding SW PLC (See DPP_PFC_E).
             */
            /*
             * Convert it to low level (PPD) sw equivalent.
             */
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_HeaderFormat_bcm_to_ppd(unit, header_format,&pfc_sw,&pfc_pmf,&pfc_pmf_mask)) ;
            /*
             * Now 'pfc_sw' contains a valid value.
             */
        }
    }
    else if (loc_err == BCM_E_CONFIG)
    {
        /*
         * BCM level PFC (headerFormat) qualifier has not been specified on this entry.
         * In that case, use DPP_PFC_ANY.
         */
        pfc_sw = DPP_PFC_ANY ;
    }
    else
    {
        BCMDNX_IF_ERR_EXIT(loc_err) ;
    }
    {
        /*
         * At this point, 'pfc_sw' contains a legitimate value. Note the special case of DPP_PFC_ANY
         * above.
         * pfc_sw is used, together with current HW values (value and mask of PLC) to extract
         * low level (PPD-level) sw PLC.
         */
        uint32 plc_hw, plc_hw_mask ;
        DPP_PLC_E plc_sw ;
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                                entry,
                                                                bcmFieldQualifyHeaderFormatExtension,
                                                                &plc_hw,
                                                                &plc_hw_mask));
        /*
         * The following procedure retrieves unique PLC SW identifier given the pair value/mask
         */
        BCMDNX_IF_ERR_EXIT(dpp_parser_plc_sw_by_acl(unit, pfc_sw,plc_hw,plc_hw_mask,&plc_sw) ) ;

        if (plc_hw_mask)
        {
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_HeaderFormatExtension_ppd_to_bcm(plc_sw,header_format_extension_p) );
        }
        else
        {
            /*
             * A NULL mask, at this point, indicates this qualifier is masked and has no
             * effect on the operation of this entry.
             * Note that the value of the mask is not as it is on ACL HW (where bits are exactly reversed):
             * It is reversed in the conversion procedure above.
             */
            *header_format_extension_p = bcmFieldHeaderFormatExtensionCount;
        }

    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_HeaderFormat(int unit,
                                     bcm_field_entry_t entry,
                                     bcm_field_header_format_t header_format)
{
    uint64 edata;
    uint64 emask;
    uint32 data;
    uint32 mask;
    int loc_err ;
    DPP_PFC_E pfc_sw ;
    bcm_field_header_format_extension_t header_format_extension ;
    _bcm_dpp_field_grp_idx_t group;
    int isExternalTcam;
    bcm_field_qset_t qset;


    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /*
     * Get low level representation (pfc_sw) of header_format.
     */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_HeaderFormat_bcm_to_ppd(unit,
                                                           header_format,
                                                           &pfc_sw,
                                                           &data,
                                                           &mask));
    /*
     * Now check whether PLC (headerFormatExtension) qualifier has been assigned to
     * this entry.
     * If so, verify that the new 'header_format' (PFC) is consistent. That is, check that
     * 'plc_sw' is within the selection supported by 'pfc_sw' which is the low level
     * one-to-one representation of the BCM-level 'header_format'.
     */
    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        isExternalTcam = _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry);
        BCMDNX_IF_ERR_EXIT(_BCM_DPP_FIELD_TCAM_ENTRY_GROUP_GET(unit,isExternalTcam, _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry), group)) ;
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.qset.get(unit, group, &qset));
        if (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyHeaderFormatExtension)) {    
            loc_err = bcm_petra_field_qualify_HeaderFormatExtension_get(unit,entry,&header_format_extension);
        } else {
            /* if QualifyHeaderFormatExtension is not set in QSET*/
            loc_err = BCM_E_CONFIG;
        }
    } else {
        loc_err = bcm_petra_field_qualify_HeaderFormatExtension_get(unit,entry,&header_format_extension) ;
    }

    if (loc_err == BCM_E_NONE)
    {
        if (header_format_extension == bcmFieldHeaderFormatExtensionCount)
        {
            /*
             *PLC qualifier is not active (mask is zero).
             */
        }
        else
        {
            uint32 plc_hw, plc_hw_mask ;
            DPP_PLC_E plc_sw ;
    
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_HeaderFormatExtension_bcm_to_ppd(header_format_extension,&plc_sw) ) ;
            /*
             * Check whether the pair pfc_sw/plc_sw is legitimate
             */
            loc_err = dpp_parser_plc_acl_by_sw(unit, pfc_sw, plc_sw, &plc_hw, &plc_hw_mask) ;
            if (loc_err == SOC_SAND_ERR)
            {
                /*
                 * Note that a return value of error from dpp_parser_plc_acl_by_sw() indicates
                 * that the PLC (header_format_extension), which is on this entry, does not match
                 * the newly requested PFC.
                 */
                BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                                 (_BSL_BCM_MSG_NO_UNIT("\r\n"
                                      "Entry 0x%08lX has BCM level Header Format extension %d (%s) correspopnding to low level PLC %d.\r\n"
                                      "Newly requested low level PFC %d (%s) does NOT support low level PLC %d. Quit."),
                                      (uint32)entry, header_format_extension,
                                      _bcm_dpp_field_header_format_extension_names[header_format_extension],
                                      plc_sw,
                                      pfc_sw,dpp_parser_pfc_string_by_sw(unit, pfc_sw),
                                      plc_sw));
            }
        }
    }
    else if (loc_err == BCM_E_CONFIG)
    {
        /*
         * BCM level PLC (header_format_extension) qualifier has not been specified on this entry.
         * Do nothing.
         */
    }
    else
    {
        BCMDNX_IF_ERR_EXIT(loc_err) ;
    }
    /*
     * At this point, either there is no PLC or it matches the newly requested PFC.
     * In both cases, we can go ahead and store this PFC in HW.
     */
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyHeaderFormat,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}
/*
 * a.
 *   If this procedure returns with an error code then it may either be
 *   a true error or it may, simply, be that HeaderFormat qualifier is not
 *   specified (or can not be specified) for this entry. 
 * b.
 *   If this procedure loads '*header_format' by 'bcmFieldHeaderFormatCount' then
 *   either the mask of this qualifier is zero or it was not found (See
 *   _bcm_dpp_field_qualifier_get_int()). In both cases, it is not active.
 */
int
bcm_petra_field_qualify_HeaderFormat_get(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_field_header_format_t *header_format)
{
    uint32 data;
    uint32 mask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyHeaderFormat,
                                                            &data,
                                                            &mask));
    if (mask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_HeaderFormat_ppd_to_bcm(unit,
                                                               data,
                                                               mask,
                                                               header_format));
    }
    else {
        *header_format = bcmFieldHeaderFormatCount;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_HeaderFormatSet(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_header_format_set_t header_format_set)
{
    return BCM_E_UNAVAIL;
}

int
bcm_petra_field_qualify_HeaderFormatSet_get(int unit,
                                            bcm_field_entry_t entry,
                                            bcm_field_header_format_set_t *header_format_set)
{
    return BCM_E_UNAVAIL;
}

int
bcm_petra_field_qualify_L3DestHostHit(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL3DestHostHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3DestHostHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL3DestHostHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3DestHostHit_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL3DestHostHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_CascadedKeyValue(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 data,
                                         uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyCascadedKeyValue,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_CascadedKeyValue_get(int unit,
                                             bcm_field_entry_t entry,
                                             uint32 *data,
                                             uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyCascadedKeyValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IsEqualValue(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIsEqualValue,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IsEqualValue_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 *data,
                                    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIsEqualValue,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_OutPort
 *   Purpose
 *      Set allowed egress port for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_port_t data = allowed port
 *      (in) bcm_port_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Supports GPORTs of various types and will map back to phys port.
 */
int
bcm_petra_field_qualify_OutPort(int unit,
                                bcm_field_entry_t entry,
                                bcm_port_t data,
                                bcm_port_t mask)
{
    uint64 edata;
    uint64 emask;
    _bcm_dpp_core_ports_bitmap_t  port_bitmap[MAX_NUM_OF_CORES];
    int    nof_cores, core; 
    uint32 pp_port;
    uint32 max_port =  _BCM_DPP_NOF_LOCAL_PORTS(unit);
    uint32 is_valid;
    int result;

    BCMDNX_INIT_FUNC_DEFS;
    nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);
    BCM_DPP_UNIT_CHECK(unit);

    if (SOC_IS_JERICHO(unit) && !_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)) {
        result = BCM_E_PARAM ;
        BCMDNX_ERR_EXIT_MSG(result,
            (_BSL_BCM_MSG(
                "\r\n"
                " ==> Setting this qualifier (bcmFieldQualifyOutPort, %d) is not allowed on"
                " ==> Jericho because there is no 'core' indication. Use bcmFieldQualifyDstPort (%d) instead"),
                (int)bcmFieldQualifyOutPort,(int)bcmFieldQualifyDstPort
            )
        ) ;
    }

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        _bcm_dpp_clear_core_ports(nof_cores, port_bitmap);


        if(data < 0 || data >= max_port)
        {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("Port value is out of range, "
                                       "Value is %d range is [0,255]\n"), 
                              data));
        }
        if ((0 != mask) && ((~0) != mask)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                       " bits set or all bits clear)")));
        }


        COMPILER_64_SET(emask, 0, 0x7);
		BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, data, &is_valid));

		if (is_valid) {
			BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, data, &pp_port, &core)));
			SHR_BITSET(port_bitmap[core], pp_port);
		} else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("Port %d is not valid"),
                              data));
        }

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_set(unit,
                                                               _bcmDppFieldProfileTypeOutPort,
                                                               nof_cores,
                                                               port_bitmap, 
                                                               &edata));
    }
    else {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_qualify_pp_port_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask,
                                                               FALSE /* is_inport */));

    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOutPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_InPorts
 *   Purpose
 *      Set allowed ingress ports for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_pbmp_t data = allowed ports
 *      (in) bcm_pbmp_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_InPorts(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_pbmp_t data,
                                 bcm_pbmp_t mask)
{
    uint64 edata;
    uint64 emask;

    uint32
        port_id,
        fld_val;
    uint32 pp_port;
    _bcm_dpp_core_ports_bitmap_t port_bitmap[MAX_NUM_OF_CORES]; 
    int    core, nof_cores;
    uint32 is_valid;
    uint32 max_port = SOC_DPP_DEFS_GET(unit, nof_local_ports);
        
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);
    _bcm_dpp_clear_core_ports(nof_cores, port_bitmap);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        if (BCM_PBMP_IS_NULL(data)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("There is no port used")));
        }

        /*
         * Check all the ports are masked and copy their
         * membership in data to the array
         */
        for (port_id = 0; port_id < max_port ; port_id++) {
            if (!BCM_PBMP_MEMBER(mask, port_id)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG("only supports all masked (all"
                                           " bits set in mask)")));
            }

            /* Copy the port bit */
            fld_val = BCM_PBMP_MEMBER(data, port_id);

            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

            if (fld_val) {
                if (is_valid) {
                    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));
                    SHR_BITCOPY_RANGE(port_bitmap[core], pp_port, &fld_val, 0, 1);
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Invalid port")));
                }
            }
        }

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_set(unit,
                                                               _bcmDppFieldProfileTypeInPort,
                                                               nof_cores,
                                                               port_bitmap, 
                                                               &edata));
        COMPILER_64_SET(emask, 0, 0x7);
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                                   entry,
                                                                   bcmFieldQualifyInPorts,
                                                                   1 /* count */,
                                                                   &edata,
                                                                   &emask));
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_OutPorts
 *   Purpose
 *      Set allowed egress ports for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_pbmp_t data = allowed ports
 *      (in) bcm_pbmp_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_OutPorts(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_pbmp_t data,
                                  bcm_pbmp_t mask)
{
    uint64 edata;
    uint64 emask;

    uint32
        port_id,
        fld_val;
    int core, nof_cores;
    _bcm_dpp_core_ports_bitmap_t port_bitmap[MAX_NUM_OF_CORES]; 

    uint32     pp_port;
    uint32     max_port = _BCM_DPP_NOF_LOCAL_PORTS(unit);
    uint32     is_valid;
    uint32     is_data_valid = FALSE; /*In case all port in data are not valid*/

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);
    _bcm_dpp_clear_core_ports(nof_cores, port_bitmap);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        if (BCM_PBMP_IS_NULL(data)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("There is no port used")));
        }

        /*
         * Check all the ports are masked and copy their
         * membership in data to the array
         */
        for (port_id = 0; port_id < max_port; port_id++) {
            if (!BCM_PBMP_MEMBER(mask, port_id)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG("only supports all masked (all"
                                           " bits set in mask)")));
            }
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

            if (is_valid) {
                BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));
                /* Copy the port bit */
                fld_val = BCM_PBMP_MEMBER(data, port_id);
                SHR_BITCOPY_RANGE(port_bitmap[core], pp_port, &fld_val, 0, 1);
                if(fld_val){
                    is_data_valid = TRUE; /*At least one port was valid and set in input data*/
                }
            }
        }

        /*In case that none of the input port were valid return an error*/
        if(is_data_valid == FALSE){
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("None of the input port are supported")));
        }
        
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_set(unit,
                                                               _bcmDppFieldProfileTypeOutPort,
                                                               nof_cores,
                                                               port_bitmap, 
                                                               &edata));
        COMPILER_64_SET(emask, 0, 0x7);
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                                   entry,
                                                                   bcmFieldQualifyOutPorts,
                                                                   1 /* count */,
                                                                   &edata,
                                                                   &emask));
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InPorts_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInPorts
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InPorts_get(int unit,
                                     bcm_field_entry_t entry,
                                     bcm_pbmp_t *data,
                                     bcm_pbmp_t *mask)
{
    uint32 tdata;
    uint32 tmask;
    uint32 
        port_id, pp_port;
    _bcm_dpp_core_ports_bitmap_t  port_bitmap[MAX_NUM_OF_CORES];
    int                   core, nof_cores; 
    uint32                is_valid;
    uint32                max_port = _BCM_DPP_NOF_LOCAL_PORTS(unit);

    BCMDNX_INIT_FUNC_DEFS;

    _bcm_dpp_clear_core_ports(MAX_NUM_OF_CORES, port_bitmap);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                                entry,
                                                                bcmFieldQualifyInPorts,
                                                                &tdata,
                                                                &tmask));

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                               _bcmDppFieldProfileTypeInPort,
                                                               tdata,
                                                               &nof_cores,
                                                               port_bitmap));
        BCM_PBMP_CLEAR(*data);
        BCM_PBMP_CLEAR(*mask);
        for (port_id = 0; port_id < max_port; port_id++) {
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

			if (is_valid) {

				BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));

				if(SHR_BITGET(port_bitmap[core], pp_port) > 0) {
                    BCM_PBMP_PORT_ADD(*data, port_id);
				}

			}
            /* Mask is expected to be all 1*/
            BCM_PBMP_PORT_ADD(*mask, port_id);

        }
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OutPorts_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOutPorts
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OutPorts_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_pbmp_t *data,
                                      bcm_pbmp_t *mask)
{
    uint32 tdata;
    uint32 tmask;
    uint32 port_id, pp_port;
    _bcm_dpp_core_ports_bitmap_t port_bitmap[MAX_NUM_OF_CORES]; 
    int    core, nof_cores;
    uint32          max_port = _BCM_DPP_NOF_LOCAL_PORTS(unit);
    uint32          is_valid;

    BCMDNX_INIT_FUNC_DEFS;


    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                                entry,
                                                                bcmFieldQualifyOutPorts,
                                                                &tdata,
                                                                &tmask));

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                               _bcmDppFieldProfileTypeOutPort,
                                                               tdata,
                                                               &nof_cores,
                                                               port_bitmap));
        BCM_PBMP_CLEAR(*data);
        BCM_PBMP_CLEAR(*mask);
        for (port_id = 0; port_id < max_port; port_id++) {
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

            if (is_valid) {
                BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));

                if(SHR_BITGET(port_bitmap[core], pp_port) > 0) {
                    BCM_PBMP_PORT_ADD(*data, port_id);
                }
            }
            BCM_PBMP_PORT_ADD(*mask, port_id);
        }
    } 
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_Llc
 *   Purpose
 *      Set expected LLC header information for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_field_llc_header_t data = which LLC header information
 *      (in) bcm_field_llc_header_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_Llc(int unit,
                             bcm_field_entry_t entry,
                             bcm_field_llc_header_t data,
                             bcm_field_llc_header_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_ports_create_mode
 *   Purpose
 *      Create a new group spanning the specified width, that has the specified
 *      qualifier set and priority, and affects only the specified ports.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_pbmp_t port = the ports
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_mode_t mode = the mode (width) of the group
 *      (out) bcm_field_group_t *group = where to put the group ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 *      Can not specify a qualifier that another group in the same stage has.
 *      If no stage qualifier, it is assumed to be bcmFieldQualifyStageIngress.
 */
int
bcm_petra_field_group_ports_create_mode(int unit,
                                         bcm_pbmp_t pbmp,
                                         bcm_field_qset_t qset,
                                         int pri,
                                         bcm_field_group_mode_t mode,
                                         bcm_field_group_t *group)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_ports_create_mode_id
 *   Purpose
 *      Create a new group using the specified ID, spanning the specified
 *      width, that has the specified qualifier set and priority, and affects
 *      only the specified ports.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_pbmp_t port = the ports
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_mode_t mode = the mode (width) of the group
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 *      Can not specify a qualifier that another group in the same stage has.
 *      If no stage qualifier, it is assumed to be bcmFieldQualifyStageIngress.
 */
int
bcm_petra_field_group_ports_create_mode_id(int unit,
                                            bcm_pbmp_t pbmp,
                                            bcm_field_qset_t qset,
                                            int pri,
                                            bcm_field_group_mode_t mode,
                                            bcm_field_group_t group)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_enable_set
 *   Purpose
 *      This turns a group on or off.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (in) int enable = new enable state
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_enable_set(int unit,
                                  bcm_field_group_t group,
                                  int enable)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_enable_get
 *   Purpose
 *      This gets whether a group is on or off.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (in) int *enable = where to put current enable state
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_enable_get(int unit,
                                  bcm_field_group_t group,
                                  int *enable)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_resync
 *   Purpose
 *      Purge hardware of all field entries not replayed after 'warm boot'.
 *   Parameters
 *      (in) int unit = the unit number
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_resync(int unit)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OutPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOutPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      This version always returns local port, not GPORT, even thoguh the set
 *      function allows certain GPORT types.
 */
int
bcm_petra_field_qualify_OutPort_get(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_port_t *data,
                                    bcm_port_t *mask)
{
    uint32 tdata;
    uint32 tmask;
    bcm_port_t port;
    uint32 
        port_id, pp_port;
    _bcm_dpp_core_ports_bitmap_t    port_bitmap[MAX_NUM_OF_CORES];
    int                     core, nof_cores;
    uint32 max_port = _BCM_DPP_NOF_LOCAL_PORTS(unit);
    uint32 is_valid;
    int result;

    BCMDNX_INIT_FUNC_DEFS;

    if (SOC_IS_JERICHO(unit)) {
        result = BCM_E_PARAM ;
        BCMDNX_ERR_EXIT_MSG(result,
            (_BSL_BCM_MSG(
                "\r\n"
                " ==> This qualifier (bcmFieldQualifyOutPort, %d) is not operational on"
                " ==> Jericho because there is no 'core' indication. Use bcmFieldQualifyDstPort (%d) instead"),
                (int)bcmFieldQualifyOutPort,(int)bcmFieldQualifyDstPort
            )
        ) ;
    }


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyOutPort,
                                                            &tdata,
                                                            &tmask));

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                               _bcmDppFieldProfileTypeOutPort,
                                                               tdata,
                                                               &nof_cores,
                                                               port_bitmap));
        port = max_port;
        for (port_id = 0; port_id < max_port; port_id++) {
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

            if (is_valid) {
                BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));

                if(SHR_BITGET(port_bitmap[core], pp_port) > 0) {
                    if(port != max_port) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                     (_BSL_BCM_MSG("Presel was defined"
                                               " for multiple ports")));
                    }
                    port = port_id;
                }
            }
        }
    }
    else {
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_pp_to_local_port_get, (unit, core, tdata, &port)));
    }

    *data = port;
    if (tmask) {
        *mask = (~0);
    } else {
        *mask = 0;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Drop(int unit,
                              bcm_field_entry_t entry,
                              uint8 data,
                              uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    /* Limit to 19b at ingress */
    if (SOC_IS_JERICHO_PLUS(unit)) {        
        COMPILER_64_SET(edata, 0, (data? 0x7FFFF:0));
        COMPILER_64_SET(emask, 0, (mask? 0x7FFFF:0));
    } else {
        COMPILER_64_SET(edata, 0, (data? _BCM_DPP_FIELD_DROP_DEST(unit):0));
        COMPILER_64_SET(emask, 0, (mask? _BCM_DPP_FIELD_DROP_DEST(unit) /* all ones */ :0));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDrop,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_SrcPort(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_module_t data_modid,
                                 bcm_module_t mask_modid,
                                 bcm_port_t   data_port,
                                 bcm_port_t   mask_port)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t data, mask;
    _bcm_dpp_field_entry_t *entryD = NULL;
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
    _bcm_dpp_field_entry_ext_t *entryExtD = NULL;
#endif
    _bcm_dpp_field_entry_dir_ext_t *entryDe = NULL;
    _bcm_dpp_field_b_qual_t qualD;
    int index = 0;
    int update = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_mod_port_to_gport_convert(unit,
                                                         data_modid,
                                                         mask_modid,
                                                         data_port,
                                                         mask_port,
                                                         &data,
                                                         &mask));

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask));

    /* Limit to 16 bits since it is only Source-System-Port */
    COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) & 0xFFFF);
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0xFFFF);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifySrcPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
    /* Update SW state */
    if(_BCM_DPP_FIELD_ENT_IS_DIR_EXT(unit, entry)) {
        BCMDNX_ALLOC_AND_CLEAR(entryDe, sizeof(*entryDe), "bcm_petra_field_qualify_SrcPort.entryDe");
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryDe.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), entryDe));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryDe->entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifyCount || qualD.qualType == 0 /*second condition needed due to init to 0 instead of default*/) {
                break;
            }
            else if (qualD.qualType == bcmFieldQualifySrcPort)
            {
                update = 1;
                break;
            }
        }
    } else if(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)) {
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
        BCMDNX_ALLOC_AND_CLEAR(entryExtD, sizeof(*entryExtD), "bcm_petra_field_qualify_SrcPort.entryExtD");
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryExtTc.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam), entryExtD));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryExtD->entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifyCount || qualD.qualType == 0/*second condition needed due to init to 0 instead of default*/) {
                break;
            }
            else if (qualD.qualType == bcmFieldQualifySrcPort)
            {
                update = 1;
                break;
            }
        }
#endif
    } else {
        BCMDNX_ALLOC_AND_CLEAR(entryD, sizeof(*entryD), "bcm_petra_field_qualify_SrcPort.entryD");

        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryTc.get(unit, entry, entryD));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryD->entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifyCount || qualD.qualType == 0/*second condition needed due to init to 0 instead of default*/) {
                break;
            }
            else if (qualD.qualType == bcmFieldQualifySrcPort)
            {
                update = 1;
                break;
            }
        }
    }
    if (index == _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("no free slots for BCM Qualifier in SW state for entry %d"), entry));
    }
    qualD.qualType = bcmFieldQualifySrcPort;
    qualD.bcmParam0 = data_modid;
    qualD.bcmMask0 = mask_modid;
    qualD.bcmParam1 = data_port;
    qualD.bcmMask1 = mask_port;
    if(_BCM_DPP_FIELD_ENT_IS_DIR_EXT(unit, entry)) {
        entryDe->entryCmn.entryBcmQual[index] = qualD;
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryDe.set(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), entryDe));
            
        if (update)
        {
            LOG_DEBUG(BSL_LS_BCM_COMMON,
                (BSL_META_U(unit,
                            "bcmFieldQualifySrcPort new values: Data_modid = %d, Mask ModID = %d, Data Port = %d, Mask Port = %d \n"),
                data_modid, mask_modid, data_port, mask_port));
        }
    } else if(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)) {
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
        entryExtD->entryCmn.entryBcmQual[index] = qualD;
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryExtTc.set(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam), entryExtD));

        if (update)
        {
            LOG_DEBUG(BSL_LS_BCM_COMMON,
                (BSL_META_U(unit,
                            "bcmFieldQualifySrcPort new values: Data_modid = %d, Mask ModID = %d, Data Port = %d, Mask Port = %d \n"),
                data_modid, mask_modid, data_port, mask_port));
        }
#endif
    } else {
        entryD->entryCmn.entryBcmQual[index] = qualD;
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryTc.set(unit, entry, entryD));
			
		if (update) 
        {
			LOG_DEBUG(BSL_LS_BCM_COMMON,
                (BSL_META_U(unit,
                            "bcmFieldQualifySrcPort new values: Data_modid = %d, Mask ModID = %d, Data Port = %d, Mask Port = %d \n"),
                data_modid, mask_modid, data_port, mask_port));
        }
    }
exit:
    BCM_FREE(entryD);    
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
    BCM_FREE(entryExtD);
#endif    
    BCM_FREE(entryDe);
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_SrcTrunk(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_trunk_t data,
                                  bcm_trunk_t mask)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t data_gport, mask_gport;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    BCM_GPORT_TRUNK_SET(data_gport, data);
    BCM_GPORT_TRUNK_SET(mask_gport, mask);
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data_gport,
                                                               mask_gport,
                                                               &edata,
                                                               &emask));

    /* Limit to 16 bits since it is only Source-System-Port */
    COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) & 0xFFFF);
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0xFFFF);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifySrcTrunk,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_DstPort(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_module_t data_modid,
                                 bcm_module_t mask_modid,
                                 bcm_port_t   data_port,
                                 bcm_port_t   mask_port)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t data, mask;
    uint32 group_flags = 0;
    _bcm_dpp_field_entry_t *entryD = NULL;
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
    _bcm_dpp_field_entry_ext_t *entryExtD = NULL;
#endif
    _bcm_dpp_field_entry_dir_ext_t *entryDe = NULL;
    _bcm_dpp_field_b_qual_t qualD;
    int index = 0;
    int update = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_mod_port_to_gport_convert(unit,
                                                         data_modid,
                                                         mask_modid,
                                                         data_port,
                                                         mask_port,
                                                         &data,
                                                         &mask));

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask));

    /* If Egress, limit to 16b - only System-Port */
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));

    /* Limit to 19b at ingress */
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0x7FFFF);
    if (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS) {
        /* Limit to 16 bits since it is only Source-System-Port */
        COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) & 0xFFFF);
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0xFFFF);
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
    /* Update SW state */
    if(_BCM_DPP_FIELD_ENT_IS_DIR_EXT(unit, entry)) {
        BCMDNX_ALLOC_AND_CLEAR(entryDe, sizeof(*entryDe), "bcm_petra_field_qualify_DstPort.entryDe");
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryDe.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), entryDe));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryDe->entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifyCount || qualD.qualType == 0 /*second condition needed due to init to 0 instead of default*/) {
                break;
            }
            else if (qualD.qualType == bcmFieldQualifyDstPort) 
            {
                update = 1;
                break;
            }
        }
    } else if(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)) {
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
        BCMDNX_ALLOC_AND_CLEAR(entryExtD, sizeof(*entryExtD), "bcm_petra_field_qualify_DstPort.entryExtD");
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryExtTc.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam), entryExtD));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryExtD->entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifyCount || qualD.qualType == 0 /*second condition needed due to init to 0 instead of default*/) 
            {
                break;
            }
            else if (qualD.qualType == bcmFieldQualifyDstPort) 
            {
                    update = 1;
                    break;
            }
        }
#endif
    } else {
        BCMDNX_ALLOC_AND_CLEAR(entryD, sizeof(*entryD), "bcm_petra_field_qualify_DstPort.entryD");
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryTc.get(unit, entry, entryD));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryD->entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifyCount || qualD.qualType == 0 /*second condition needed due to init to 0 instead of default*/) 
            {
                break;
            }
            else if (qualD.qualType == bcmFieldQualifyDstPort) 
            {
                    update = 1;
                    break;
            }
        }
    }
    if (index == _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("no free slots for BCM Qualifier in SW state for entry %d"), entry));
    }
    qualD.qualType = bcmFieldQualifyDstPort;
    qualD.bcmParam0 = data_modid;
    qualD.bcmMask0 = mask_modid;
    qualD.bcmParam1 = data_port;
    qualD.bcmMask1 = mask_port;
    if(_BCM_DPP_FIELD_ENT_IS_DIR_EXT(unit, entry)) {
        entryDe->entryCmn.entryBcmQual[index] = qualD;
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryDe.set(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), entryDe));
        if (update) 
        {
            LOG_DEBUG(BSL_LS_BCM_COMMON,
                (BSL_META_U(unit,
                            "bcmFieldQualifyDstPort new values: Data_modid = %d, Mask ModID = %d, Data Port = %d, Mask Port = %d \n"),
                data_modid, mask_modid, data_port, mask_port));
        }
    } else if(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)) {
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
        entryExtD->entryCmn.entryBcmQual[index] = qualD;
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryExtTc.set(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam), entryExtD));
        if (update) 
        {
            LOG_DEBUG(BSL_LS_BCM_COMMON,
                (BSL_META_U(unit,
                            "bcmFieldQualifyDstPort new values: Data_modid = %d, Mask ModID = %d, Data Port = %d, Mask Port = %d \n"),
                data_modid, mask_modid, data_port, mask_port));
        }
#endif
    } else {
        entryD->entryCmn.entryBcmQual[index] = qualD;
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryTc.set(unit, entry, entryD));
        if (update) 
        {
            LOG_DEBUG(BSL_LS_BCM_COMMON,
                (BSL_META_U(unit,
                            "bcmFieldQualifyDstPort new values: Data_modid = %d, Mask ModID = %d, Data Port = %d, Mask Port = %d \n"),
                data_modid, mask_modid, data_port, mask_port));
        }
    }
exit:
    BCM_FREE(entryD);
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
    BCM_FREE(entryExtD);
#endif
    BCM_FREE(entryDe);

#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_DstTrunk(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_trunk_t data,
                                  bcm_trunk_t mask)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t data_gport, mask_gport;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    BCM_GPORT_TRUNK_SET(data_gport, data);
    BCM_GPORT_TRUNK_SET(mask_gport, mask);
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data_gport,
                                                               mask_gport,
                                                               &edata,
                                                               &emask));
    /* Limit to 19b at ingress */
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0x7FFFF);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstTrunk,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_ExtensionHeaderSubCode(int unit,
                                                bcm_field_entry_t entry,
                                                uint8 i,uint8 j)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_ExtensionHeaderType(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 data,uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExtensionHeaderType,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_ExtensionHeader2Type(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 i,uint8 j)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerSrcIp6
 * Purpose:
 *      Set match criteria for bcmFieldQualifyInnerSrcIp6
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerSrcIp6(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_ip6_t data,
                                    bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerSrcIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDstIp6
 * Purpose:
 *      Set match criteria for bcmFieldQualifyInnerDstIp6
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDstIp6(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_ip6_t data,
                                    bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerDstIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerSrcIp6High
 * Purpose:
 *      Set match criteria for bcmFieldQualifyInnerSrcIp6High
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerSrcIp6High(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_ip6_t data,
                                        bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerSrcIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDstIp6High
 * Purpose:
 *      Set match criteria for bcmFieldQualifyInnerDstIp6High
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDstIp6High(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_ip6_t data,
                                        bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerDstIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerIpFrag(int unit,
                                     bcm_field_entry_t entry,
                                     bcm_field_IpFrag_t frag_info)
{
    uint64 edata;
    uint64 emask;
    uint8 ip_fragmented;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_frag_bcm_to_ppd(unit,frag_info, &ip_fragmented));
    COMPILER_64_SET(edata, 0, ip_fragmented);

    /* All masked */
    COMPILER_64_SET(emask, ~0, ~0);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerIpFrag,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerTtl
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInnerTtl
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerTtl(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerTtl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_DosAttack(int unit,
                                   bcm_field_entry_t entry,
                                   uint8 data,
                                   uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IpmcStarGroupHit(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 data,
                                          uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3DestRouteHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL3DestRouteHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3DestRouteHit(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 data,
                                       uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL3DestRouteHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_L3SrcHostHit(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_L2CacheHit(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2StationMove
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL2StationMove
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2StationMove(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2StationMove,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2DestHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL2DestHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2DestHit(int unit,
                                  bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2DestHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_L2SrcStatic(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2SrcHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL2SrcHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2SrcHit(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2SrcHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_ForwardingVlanValid(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 data,
                                             uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VlanTranslationHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyVlanTranslationHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VlanTranslationHit(int unit,
                                           bcm_field_entry_t entry,
                                           uint8 data,
                                           uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyVlanTranslationHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpInfo
 * Purpose:
 *       Set match criteria for bcmFieldQualifyIpInfo
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpInfo(int unit,
                               bcm_field_entry_t entry,
                               uint32 data,
                               uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, 0);

    /* bit 0 for Version-Error, bit 1 for Checksum-error */
    if (mask & BCM_FIELD_IP_VERSION_ERR) {
        if (data & BCM_FIELD_IP_VERSION_ERR) {
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (0x1 << 0));
        }
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 0));
    }

    if (mask & BCM_FIELD_IP_CHECKSUM_OK) {
        if ((data & BCM_FIELD_IP_CHECKSUM_OK) == 0) {
            /* Check-error in HW, invert the bit meaning */
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (0x1 << 1));
        }
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 1));
    }


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpInfo,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PacketRes
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPacketRes
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PacketRes(int unit,
                                  bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    bcm_dpp_field_info_OLD_t *unitData;
    uint64 edata; /* 0 - unknown, 1 - bpdu */
    uint64 emask;

    _bcm_dpp_field_entry_t entryD;
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
    _bcm_dpp_field_entry_ext_t entryExtD;
#endif
    _bcm_dpp_field_entry_dir_ext_t *entryDe = NULL;
    _bcm_dpp_field_b_qual_t qualD;
    int index = 0;
	int update = 0;
    BCMDNX_INIT_FUNC_DEFS;


    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    /* Init to zero */
    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, 0);

    /* The data values are not bitmap as expected - allow only full mask */
    if ((0 != mask) && (0x1F != (mask & 0x1F))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                   " bits set or all bits clear clear)")));
    }

    if (data == BCM_FIELD_PKT_RES_UNKNOWN) {
        COMPILER_64_SET(edata, 0, 1);
        COMPILER_64_SET(emask, 0, 1);
    }
    else if (data == BCM_FIELD_PKT_RES_BPDU) {
        COMPILER_64_SET(edata, 0, (1 << 1));
        COMPILER_64_SET(emask, 0, (1 << 1));
    }
    else if (mask == 0) {
        /* Nothing to do */
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("only supports nothing or supported values masks ("
                                   "BCM_FIELD_PKT_RES_UNKNOWN, BCM_FIELD_PKT_RES_BPDU)")));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPacketRes,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));

    if(_BCM_DPP_QUALIFIER_IS_KEPT_IN_SW_STATE(bcmFieldQualifyPacketRes)) 
    {
        

        if(_BCM_DPP_FIELD_ENT_IS_DIR_EXT(unit, entry)) {
            BCMDNX_ALLOC_AND_CLEAR(entryDe, sizeof(*entryDe), "bcm_petra_field_qualify_PacketRes.entryDe");
            BCMDNX_IF_ERR_EXIT(
                sw_state_access[unit].dpp.bcm.field.entryDe.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), entryDe));
            for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
                qualD = entryDe->entryCmn.entryBcmQual[index];
                if(qualD.qualType == bcmFieldQualifyCount || qualD.qualType == 0 /*second condition needed due to init to 0 instead of default*/) {
                    break;
                } else if (qualD.qualType == bcmFieldQualifyPacketRes) {
					update = 1;
					break;
				}
            }
        } else if(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)){
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
            BCMDNX_IF_ERR_EXIT(
                sw_state_access[unit].dpp.bcm.field.entryExtTc.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam), &entryExtD));
            for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
                qualD = entryExtD.entryCmn.entryBcmQual[index];
                if(qualD.qualType == bcmFieldQualifyCount || qualD.qualType == 0/*second condition needed due to init to 0 instead of default*/) {
                    break;
                } else if (qualD.qualType == bcmFieldQualifyPacketRes) {
					update = 1;
					break;
				}
            }
#endif
        } else {
            BCMDNX_IF_ERR_EXIT(
                sw_state_access[unit].dpp.bcm.field.entryTc.get(unit, entry, &entryD));
            for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
                qualD = entryD.entryCmn.entryBcmQual[index];
                if(qualD.qualType == bcmFieldQualifyCount || qualD.qualType == 0/*second condition needed due to init to 0 instead of default*/) {
                    break;
                } else if (qualD.qualType == bcmFieldQualifyPacketRes) {
					update = 1;
					break;
				}
            }
        }
        if (index == _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("no free slots for BCM Qualifier in SW state for entry %d"), entry));
        }

        qualD.qualType = bcmFieldQualifyPacketRes;
        qualD.bcmParam0 = data;
        qualD.bcmMask0 = mask;
        qualD.bcmParam1 = 0;
        qualD.bcmMask1 = 0;

        if(_BCM_DPP_FIELD_ENT_IS_DIR_EXT(unit, entry)) {
            entryDe->entryCmn.entryBcmQual[index] = qualD;
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.field.entryDe.set(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), entryDe));
			if (update) 
			{
                LOG_DEBUG(BSL_LS_BCM_COMMON,
                (BSL_META_U(unit,
                            "bcmFieldQualifyPacketRes new values: Data = %d, Mask = %d \n"),
                data, mask));
			}
        } else if(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)){
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
            entryExtD.entryCmn.entryBcmQual[index] = qualD;
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.field.entryExtTc.set(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam), &entryExtD));
			if (update) 
			{
				LOG_DEBUG(BSL_LS_BCM_COMMON,
                (BSL_META_U(unit,
                            "bcmFieldQualifyPacketRes new values: Data = %d, Mask = %d \n"),
                data, mask));
			}
#endif
        } else {
            entryD.entryCmn.entryBcmQual[index] = qualD;
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.field.entryTc.set(unit, entry, &entryD));
			if (update) 
			{
				LOG_DEBUG(BSL_LS_BCM_COMMON,
                (BSL_META_U(unit,
                            "bcmFieldQualifyPacketRes new values: Data = %d, Mask = %d \n"),
                data, mask));
			}
        }


    }

    
exit:
    BCM_FREE(entryDe);
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpFlags
 * Purpose:
 *       Set match criteria for bcmFieldQualifyIpFlags
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpFlags(int unit,
                                bcm_field_entry_t entry,
                                uint8 data,
                                uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpFlags,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_TcpSequenceZero(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 flag)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_TcpHeaderSize(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 data,
                                       uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IpType(int unit,
                                bcm_field_entry_t entry,
                                bcm_field_IpType_t type)
{
    uint64 edata;
    uint64 emask;
    SOC_PPC_FP_PARSED_ETHERTYPE ppdIpType;
    uint32 group_flags = 0;
    uint8 is_egress;
    unsigned int count = 1;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));
    is_egress = (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS)?1:0;
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_type_bcm_to_ppd(type, is_egress, &ppdIpType));
    COMPILER_64_SET(edata, 0, ppdIpType);
    /* Fully masked - 4 bits */
    COMPILER_64_SET(emask, 0, 0xF);

    /* 
     * In case of we use NoOpts or WithOpts the qual value and mask are 5 bits,
     * because we are checking another HW field. NOTE that in case of those two
     * types are used, they are relevant only for IPv4 FWD layer and in the qualifier
     * set we should indicate that using: bcmFieldQualifyIp4.
     */
    if ((type == bcmFieldIpTypeIpv4NoOpts)
        || (type == bcmFieldIpTypeIpv4WithOpts)) {
        COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (type == bcmFieldIpTypeIpv4WithOpts) << 4);
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 4));
    }

    /* 
     * In case of we use NoExtHdr or OneExtHdr the qual value and mask are 5 bits,
     * because we are checking another HW field. NOTE that in case of those two
     * types are used, they are relevant only for IPv6 FWD layer and in the qualifier
     * set we should indicate that using: bcmFieldQualifyIp6.
     */
    if ((type == bcmFieldIpTypeIpv6NoExtHdr)
        || (type == bcmFieldIpTypeIpv6OneExtHdr))
    {
        COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (!(type == bcmFieldIpTypeIpv6NoExtHdr)) << 4);
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 4));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpType,
                                                               count,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_L2Format(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_field_L2Format_t type)
{
    uint64 edata;
    uint64 emask;
    SOC_PPC_FP_ETH_ENCAPSULATION ppdL2Format;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_l2_eth_format_bcm_to_ppd(type, &ppdL2Format));
    COMPILER_64_SET(edata, 0, ppdL2Format);
    COMPILER_64_SET(emask, ~0, ~0);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2Format,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MHOpcode(int unit,
                                  bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Decap(int unit,
                               bcm_field_entry_t entry,
                               bcm_field_decap_t decap)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_HiGig(int unit,
                               bcm_field_entry_t entry,
                               uint8 data,
                               uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstHiGig
 * Purpose:
 *      Qualify on HiGig destination packets.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstHiGig(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstHiGig_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstHiGig
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstHiGig_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassL2
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInterfaceClassL2
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassL2(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 data,
                                         uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInterfaceClassL2,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InterfaceClassL3(int unit, bcm_field_entry_t entry,
                                        uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassPort
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInterfaceClassPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassPort(int unit,
                                           bcm_field_entry_t entry,
                                           uint32 data,
                                           uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInterfaceClassPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_SrcClassL2(int unit, bcm_field_entry_t entry,
                                  uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_SrcClassL3(int unit, bcm_field_entry_t entry,
                                  uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_SrcClassField(int unit, bcm_field_entry_t entry,
                                  uint32 data, uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifySrcClassField,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_DstClassL2(int unit, bcm_field_entry_t entry,
                                  uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_DstClassL3(int unit, bcm_field_entry_t entry,
                                  uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_DstClassField(int unit, bcm_field_entry_t entry,
                                  uint32 data, uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstClassField,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_IpProtocolCommon(int unit,
                                          bcm_field_entry_t entry,
                                          bcm_field_IpProtocolCommon_t protocol)
{
    uint64 edata;
    uint64 emask;
    SOC_PPC_FP_PARSED_IP_NEXT_PROTOCOL ppdIpNextProtocol;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_next_protocol_bcm_to_ppd(protocol, &ppdIpNextProtocol, &emask));
    COMPILER_64_SET(edata, 0, ppdIpNextProtocol);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpProtocolCommon,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Snap(int unit,
                              bcm_field_entry_t entry,
                              bcm_field_snap_header_t data,
                              bcm_field_snap_header_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerTpid
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInnerTpid
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      tpid - (IN) Qualifier tpid.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerTpid(int unit,
                                   bcm_field_entry_t entry,
                                   uint16 tpid)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, tpid);
    COMPILER_64_SET(emask, 0, 0xffff);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerTpid,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterTpid
 * Purpose:
 *       Set match criteria for bcmFieldQualifyOuterTpid
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      tpid - (IN) Qualifier tpid.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterTpid(int unit,
                                  bcm_field_entry_t entry,
                                  uint16 tpid)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, tpid);
    COMPILER_64_SET(emask, 0, 0xffff);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterTpid,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_L3Routable(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 data,
                                    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IpFrag(int unit,
                                bcm_field_entry_t entry,
                                bcm_field_IpFrag_t frag_info)
{
    uint64 edata;
    uint64 emask;
    uint8 ip_fragmented;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_frag_bcm_to_ppd(unit,frag_info, &ip_fragmented));
    COMPILER_64_SET(edata, 0, ip_fragmented);

    /* All masked */
    COMPILER_64_SET(emask, ~0, ~0);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpFrag,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_L3Ingress
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL3Ingress
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3Ingress(int unit,
                                  bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);

    
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL3Ingress,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_L4Ports(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MirrorCopy
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMirrorCopy
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MirrorCopy(int unit,
                                   bcm_field_entry_t entry,
                                   uint8 data,
                                   uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, 2); /* 2 - encoding in FTMH.TM-Action-Type for Mirror */
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMirrorCopy,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_PphType
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPphType
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PphType(int unit,
                                   bcm_field_entry_t entry,
                                   uint8 data,
                                   uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPphType,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelTerminated
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTunnelTerminated
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelTerminated(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 data,
                                         uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTunnelTerminated,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsTerminated
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsTerminated
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsTerminated(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 data,
                                       uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsTerminated,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_action_ports_add(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_field_action_t action,
                                  bcm_pbmp_t pbmp)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_action_ports_get(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_field_action_t action,
                                  bcm_pbmp_t *pbmp)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_group_priority_set(int unit, bcm_field_group_t group,
                                 int priority)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_group_priority_get(int unit, bcm_field_group_t group,
                                 int *priority)
{
    bcm_dpp_field_info_OLD_t *unitData = NULL;
    _bcm_dpp_field_grp_idx_t groupLimit;
    int dpp_field_unit_lock_was_taken ;
    uint32 groupFlags;
  
    BCMDNX_INIT_FUNC_DEFS;

    dpp_field_unit_lock_was_taken = 0 ;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT( FIELD_ACCESS.groupLimit.get(unit, &groupLimit));
    if ((0 > group) || (groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    dpp_field_unit_lock_was_taken = 1 ;

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.groupFlags.get(unit, group, &groupFlags));

    if ((groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) == 0) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
        dpp_field_unit_lock_was_taken = 0;
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("unit %d group %d doesn\'t exist"),
                          unit,
                          group));
    }

    BCMDNX_IF_ERR_EXIT(FIELD_ACCESS.groupD.priority.get(unit, group, priority));


    _DPP_FIELD_UNIT_UNLOCK(unitData);
    dpp_field_unit_lock_was_taken = 0 ;

exit:
    if (dpp_field_unit_lock_was_taken)
    {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
    }
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IcmpTypeCode(int unit,
                                      bcm_field_entry_t entry,
                                      uint16 data,
                                      uint16 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerIpType(int unit, bcm_field_entry_t entry,
                             bcm_field_IpType_t type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerIpProtocolCommon(int unit, bcm_field_entry_t entry,
                                       bcm_field_IpProtocolCommon_t protocol)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerIp6FlowLabel
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInnerIp6FlowLabel
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerIp6FlowLabel(int unit,
                                          bcm_field_entry_t entry,
                                          uint32 data,
                                          uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerIp6FlowLabel,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstL3Egress
 * Purpose:
 *       Set match criteria for bcmFieldQualifyDstL3Egress
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      if_id - (IN) L3 forwarding object.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstL3Egress(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_if_t if_id)
{
    uint64 edata;
    uint64 emask;
    SOC_PPC_FEC_ID fec_id;
    SOC_PPC_FRWRD_DECISION_INFO   fwdDecision;
    uint32 soc_sand_rv;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, if_id);
    COMPILER_64_SET(emask, 0, ~0);

    SOC_PPC_FRWRD_DECISION_INFO_clear(&fwdDecision);

    /* Set the Forward decision */
    if(BCM_L3_ITF_TYPE_IS_FEC(if_id)) {
        _bcm_l3_intf_to_fec(unit, if_id, &fec_id);
        SOC_PPD_FRWRD_DECISION_FEC_SET((unit), &fwdDecision, fec_id, soc_sand_rv);
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d entry %d has an invalid Interface ID type, "
                                           "expected: FEC-Pointer\n"),
                          unit,
                          entry));
    }


    /* Get the HW Destination from the Forward decision */
    BCMDNX_IF_ERR_EXIT_MSG(
        _bcm_dpp_field_qualify_fwd_decision_to_hw_destination_convert(unit,
                                                                      &fwdDecision,
                                                                      TRUE, /* is_for_destination */
                                                                      FALSE, /* is_for_action */
                                                                      &edata,
                                                                      &emask),
                        (_BSL_BCM_MSG("unable to get from the forward decision the HW data")));

    COMPILER_64_SET(emask, 0, 0x7FFFF);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstL3Egress,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstMulticastGroup
 * Purpose:
 *       Set match criteria for bcmFieldQualifyDstMulticastGroup
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      group - (IN) Multicast group id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstMulticastGroup(int unit,
                                          bcm_field_entry_t entry,
                                          bcm_gport_t group)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t mask = ~0;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);

    if (0 == BCM_GPORT_IS_MCAST(group)) {
        return BCM_E_PARAM;
    }

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               group,
                                                               mask,
                                                               &edata,
                                                               &emask));

    /* Limit to 19b at ingress */
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0x7FFFF);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstMulticastGroup,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_SrcMplsGport(int unit,
                               bcm_field_entry_t entry,
                               bcm_gport_t mpls_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_DstMplsGport(int unit,
                               bcm_field_entry_t entry,
                               bcm_gport_t mpls_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_SrcMimGport(int unit,
                              bcm_field_entry_t entry,
                              bcm_gport_t mim_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_DstMimGport(int unit,
                              bcm_field_entry_t entry,
                              bcm_gport_t mim_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}



int
bcm_petra_field_qualify_SrcWlanGport(int unit,
                               bcm_field_entry_t entry,
                               bcm_gport_t wlan_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_DstWlanGport(int unit,
                               bcm_field_entry_t entry,
                               bcm_gport_t wlan_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_Loopback(int unit,
                               bcm_field_entry_t entry,
                               uint8 data,
                               uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}



int
bcm_petra_field_qualify_LoopbackType(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_field_LoopbackType_t loopback_type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_TunnelType(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_field_TunnelType_t tunnel_type)
{
    uint64 edata;
    uint64 emask;
    SOC_PPC_PKT_TERM_TYPE ppdTerminationType;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_termination_type_bcm_to_ppd(tunnel_type, &ppdTerminationType));

    COMPILER_64_SET(edata, 0, ppdTerminationType);
    COMPILER_64_SET(emask, ~0, ~0);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTunnelType,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_petra_field_qualify_LoopbackType_get
 * Purpose:
 *      Get loopback type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      loopback_type - (OUT) Loopback type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LoopbackType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_LoopbackType_t *loopback_type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelType_get
 * Purpose:
 *      Get tunnel type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      tunnel_type - (OUT) Tunnel type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_TunnelType_t *tunnel_type)
{
    int32 ppd;
    bcm_field_TunnelType_t bcm;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTunnelType,
                                                           &ppd,
                                                           &emask));
    if (emask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_termination_type_ppd_to_bcm(ppd, &bcm));
        *tunnel_type = bcm;
    }
    else {
        /* Special value for don't care */
        *tunnel_type = bcmFieldTunnelTypeAny;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstL3Egress_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyDstL3Egress
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      if_id - (OUT) L3 forwarding object.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstL3Egress_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_if_t *if_id)
{
    uint32 data_lcl;
    uint32 mask;
    SOC_PPC_FRWRD_DECISION_INFO   fwdDecision;
    BCMDNX_INIT_FUNC_DEFS;



    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyDstL3Egress,
                                                            &data_lcl,
                                                            &mask));

    *if_id = 0;
    if (mask) {
        /* Decode the Destination to FEC */
        BCMDNX_IF_ERR_EXIT_MSG(
            _bcm_dpp_field_qualify_fwd_decision_from_hw_convert(unit,
                                                                TRUE, /* is_for_destination */
                                                                data_lcl,
                                                                ARAD_PP_FWD_DECISION_PARSE_DEST,
                                                                &fwdDecision),
                            (_BSL_BCM_MSG("unable to get the Forward-Decision with HW Destination %d"), data_lcl));

        /* Set the Forward decision */
        if(fwdDecision.type == SOC_PPC_FRWRD_DECISION_TYPE_FEC) {
            BCM_L3_ITF_SET(*if_id, BCM_L3_ITF_TYPE_FEC, fwdDecision.dest_id);
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d entry %d has an invalid Interface ID type, "
                                               "expected: FEC-Pointer\n"),
                              unit,
                              entry));
        }
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstMulticastGroup_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyDstMulticastGroup
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      group - (OUT) Multicast group id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstMulticastGroup_get(int unit,
                                              bcm_field_entry_t entry,
                                              bcm_gport_t *group)
{
    uint32 data_lcl;
    uint32 mask;
    bcm_gport_t gport;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyDstMulticastGroup,
                                                            &data_lcl,
                                                            &mask));
    *group = 0;

    if (mask) {
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, data_lcl, &gport),
                            (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), data_lcl));

        BCM_GPORT_MCAST_SET(*group, gport);
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcMplsGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcMplsGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mpls_port_id - (OUT) Mpls port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcMplsGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mpls_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstMplsGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstMplsGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mpls_port_id - (OUT) Mpls port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstMplsGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mpls_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcMimGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcMimGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mim_port_id - (OUT) Mim port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcMimGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mim_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstMimGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstMimGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mim_port_id - (OUT) Mim port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstMimGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mim_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcWlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcWlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      wlan_port_id - (OUT) Wlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcWlanGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *wlan_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstWlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstWlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      wlan_port_id - (OUT) Wlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstWlanGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *wlan_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Loopback_get
 * Purpose:
 *      Get loopback field qualification from  a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data - (OUT) Data to qualify with.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Loopback_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Drop_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDrop
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Drop_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    uint32 tdata;
    uint32 tmask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyDrop,
                                                            &tdata,
                                                            &tmask));

    *data = 0;
    *mask = 0;
    if (SOC_IS_JERICHO_PLUS(unit)) {
        if (tmask == 0x7ffff) {
            *mask = 1;
        }
        if (tdata == 0x7ffff) {
            *data = 1;
        }
    } else {        
        if (tmask == _BCM_DPP_FIELD_DROP_DEST(unit)) {
            *mask = 1;
            *data = (tdata == _BCM_DPP_FIELD_DROP_DEST(unit))? 1: 0;
        }
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_SrcPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data_modid - (OUT) Qualifier module id.
 *      mask_modid - (OUT) Qualifier module id mask.
 *      data_port - (OUT) Qualifier port id.
 *      mask_port - (OUT) Qualifier port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcPort_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_module_t *data_modid,
    bcm_module_t *mask_modid,
    bcm_port_t *data_port,
    bcm_port_t *mask_port)
{
    _bcm_dpp_field_entry_t entryD;
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
    _bcm_dpp_field_entry_ext_t entryExtD;
#endif
    _bcm_dpp_field_entry_dir_ext_t *entryDe = NULL;
    _bcm_dpp_field_b_qual_t qualD;
    int index = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    *data_modid = 0;
    *data_port = 0;
    *mask_modid = 0;
    *mask_port = 0;

    /* Use SW state to obtain parameters, as they were limited to 16 LSB by set*/
    if(_BCM_DPP_FIELD_ENT_IS_DIR_EXT(unit, entry)) {
        BCMDNX_ALLOC_AND_CLEAR(entryDe, sizeof(*entryDe), "bcm_petra_field_qualify_SrcPort_get.entryDe");
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryDe.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), entryDe));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryDe->entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifySrcPort) {
                break;
            }
        }
    } else if (_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)){
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryExtTc.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam), &entryExtD));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryExtD.entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifySrcPort) {
                break;
            }
        }
#else /* non sw_state implementation */
        uint32 tdata;
        uint32 tmask;
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                                entry,
                                                                bcmFieldQualifySrcPort,
                                                                &tdata,
                                                                &tmask));
        qualD.bcmParam0 = 0;
        qualD.bcmMask0 = 0;
        qualD.bcmParam1 = 0;
        qualD.bcmMask1 = 0;

        if(tmask) {
            /* Insert the 19b encoding for the Source-Port */
            tdata |= (1 << 18);
            BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, tdata, (int*)&(qualD.bcmParam1)),
                                (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), tdata));
            qualD.bcmMask1 = tmask;

            /* Take only the 16b of the Queue-ID */
            if(BCM_GPORT_IS_MODPORT(qualD.bcmParam1)) {
                qualD.bcmParam0 = BCM_GPORT_MODPORT_MODID_GET(qualD.bcmParam1);
                qualD.bcmParam1 = BCM_GPORT_MODPORT_PORT_GET(qualD.bcmParam1);
                qualD.bcmMask0 = (~0);
                qualD.bcmMask1 = (~0);
            }
        }
#endif
    } else {
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryTc.get(unit, entry, &entryD));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryD.entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifySrcPort) {
                break;
            }
        }
    }
    
    if (index == _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("no data for bcmFieldQualifySrcPort found in SW state for entry %d"), entry));
    }
    *data_modid = qualD.bcmParam0;
    *mask_modid = qualD.bcmMask0;
    *data_port = qualD.bcmParam1;
    *mask_port = qualD.bcmMask1;

exit:
    BCM_FREE(entryDe);
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcTrunk_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcTrunk
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcTrunk_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_trunk_t *data,
    bcm_trunk_t *mask)
{
    uint32 data_lcl;
    uint32 mask_lcl;
    bcm_gport_t gport;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifySrcTrunk,
                                                            &data_lcl,
                                                            &mask_lcl));
    *data = 0;
    *mask = 0;

    if (mask_lcl) {
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, data_lcl, &gport),
                            (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), data_lcl));

        if (BCM_GPORT_IS_TRUNK(gport)) {
            *data = BCM_GPORT_TRUNK_GET(gport);
            *mask = (~0);
        }
    }


exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data_modid - (OUT) Qualifier module id.
 *      mask_modid - (OUT) Qualifier module id mask.
 *      data_port - (OUT) Qualifier port id.
 *      mask_port - (OUT) Qualifier port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstPort_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_module_t *data_modid,
    bcm_module_t *mask_modid,
    bcm_port_t *data_port,
    bcm_port_t *mask_port)
{
    _bcm_dpp_field_entry_t entryD;
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
    _bcm_dpp_field_entry_ext_t entryExtD;
#endif
    _bcm_dpp_field_entry_dir_ext_t *entryDe=NULL;
    _bcm_dpp_field_b_qual_t qualD;
    int index = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    *data_modid = 0;
    *data_port = 0;
    *mask_modid = 0;
    *mask_port = 0;

    /* Use SW state to obtain parameters*/
    if(_BCM_DPP_FIELD_ENT_IS_DIR_EXT(unit, entry)) {
        BCMDNX_ALLOC_AND_CLEAR(entryDe, sizeof(*entryDe), "bcm_petra_field_qualify_DstPort_get.entryDe");
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryDe.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), entryDe));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryDe->entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifyDstPort) {
                break;
            }
        }
    } else if (_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)){
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryExtTc.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam), &entryExtD));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryExtD.entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifyDstPort) {
                break;
            }
        }
#else /* non sw_state implementation */
        uint32 tdata;
        uint32 tmask;
        uint32 group_flags = 0;
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                                entry,
                                                                bcmFieldQualifyDstPort,
                                                                &tdata,
                                                                &tmask));
        qualD.bcmParam0 = 0;
        qualD.bcmMask0 = 0;
        qualD.bcmParam1 = 0;
        qualD.bcmMask1 = 0;

        if(tmask) {
            /* If Egress, limit to 16b - only System-Port */
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_petra_field_entry_group_flags(unit,
                                                                    entry,
                                                                    &group_flags));
            if((group_flags & _BCM_DPP_FIELD_GROUP_EGRESS)) {
                /* Insert the 19b encoding */
                tdata |= (1 << 18);
            }

            BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, tdata, (int*)&(qualD.bcmParam1)),
                                (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), tdata));
            qualD.bcmMask1 = tmask;

            /* Take only the 16b of the Queue-ID */
            if(BCM_GPORT_IS_MODPORT(qualD.bcmParam1)) {
                qualD.bcmParam0 = BCM_GPORT_MODPORT_MODID_GET(qualD.bcmParam1);
                qualD.bcmParam1 = BCM_GPORT_MODPORT_PORT_GET(qualD.bcmParam1);
                qualD.bcmMask0 = (~0);
                qualD.bcmMask1 = (~0);
            }
        }
#endif
    } else {
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryTc.get(unit, entry, &entryD)); 
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryD.entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifyDstPort) {
                break;
            }
        }
    }
    if (index == _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("no data for bcmFieldQualifyDstPort found in SW state for entry %d"), entry));
    }
    *data_modid = qualD.bcmParam0;
    *mask_modid = qualD.bcmMask0;
    *data_port = qualD.bcmParam1;
    *mask_port = qualD.bcmMask1;

exit:
    BCM_FREE(entryDe);
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstTrunk_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstTrunk
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstTrunk_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_trunk_t *data,
    bcm_trunk_t *mask)
{
    uint32 data_lcl;
    uint32 mask_lcl;
    bcm_gport_t gport;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyDstTrunk,
                                                            &data_lcl,
                                                            &mask_lcl));
    *data = 0;
    *mask = 0;

    if (mask_lcl) {
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, data_lcl, &gport),
                            (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), data_lcl));

        if (BCM_GPORT_IS_TRUNK(gport)) {
            *data = BCM_GPORT_TRUNK_GET(gport);
            *mask = (~0);
        }
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpInfo_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyIpInfo
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpInfo_get(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 *data,
                                   uint32 *mask)
{
    uint32 edata, emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyIpInfo,
                                                            &edata,
                                                            &emask));

    *data = 0;
    *mask = 0;

    /* bit 0 for all filtering, bit 1 for exclude source only */
    if (emask & 0x1) {
        if (edata & 0x1) {
            *data += BCM_FIELD_IP_VERSION_ERR;
        }
        *mask += BCM_FIELD_IP_VERSION_ERR;
    }

    if (emask & (0x1 << 1)) {
        if ((edata & (0x1 << 1)) == 0) {
            /* Check-error in HW, invert the bit meaning */
            *data += BCM_FIELD_IP_CHECKSUM_OK;
        }
        *mask += BCM_FIELD_IP_CHECKSUM_OK;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PacketRes_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPacketRes
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PacketRes_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint32 *data,
                                      uint32 *mask)
{
    _bcm_dpp_field_entry_t entryD;
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
    _bcm_dpp_field_entry_ext_t entryExtD;
#endif
    _bcm_dpp_field_entry_dir_ext_t *entryDe=NULL;
    _bcm_dpp_field_b_qual_t qualD;
    int index = 0;
    BCMDNX_INIT_FUNC_DEFS;

    /* Use SW state to obtain parameters, as they were limited to 16 LSB by set*/
    if(_BCM_DPP_FIELD_ENT_IS_DIR_EXT(unit, entry)) {
        BCMDNX_ALLOC_AND_CLEAR(entryDe, sizeof(*entryDe), "bcm_petra_field_qualify_PacketRes_get.entryDe");
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryDe.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt), entryDe));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryDe->entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifyPacketRes) {
                break;
            }
        }
    } else if (_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)){
#if _BCM_DPP_EXT_TCAM_ENTRIES_IN_SW_STATE
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryExtTc.get(unit, entry - _BCM_DPP_FIELD_ENT_BIAS(unit, ExternalTcam), &entryExtD));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryExtD.entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifyPacketRes) {
                break;
            }
        }
#else /* non sw_state implementation */
        uint64 edata; /* 0 - unknown, 1 - bpdu */
        uint64 emask;
        bcm_dpp_field_info_OLD_t *unitData;

        _DPP_FIELD_UNIT_CHECK(unit, unitData);
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                                   entry,
                                                                   bcmFieldQualifyPacketRes,
                                                                   1, /* count*/
                                                                   &edata,
                                                                   &emask));
        qualD.bcmParam0 = 0;
        qualD.bcmMask0 = 0;
        if (COMPILER_64_LO(emask) & 0x1) {
            qualD.bcmMask0 = 0x1F;
            qualD.bcmParam0 = BCM_FIELD_PKT_RES_UNKNOWN;
        }
        else if (COMPILER_64_LO(emask) & (0x1 << 1)) {
            qualD.bcmMask0 = 0x1F;
            qualD.bcmParam0 = BCM_FIELD_PKT_RES_BPDU;
        }
#endif
    } else {
        BCMDNX_IF_ERR_EXIT(
            sw_state_access[unit].dpp.bcm.field.entryTc.get(unit, entry, &entryD));
        for(index = 0; index < _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP; index++) {
            qualD = entryD.entryCmn.entryBcmQual[index];
            if(qualD.qualType == bcmFieldQualifyPacketRes) {
                break;
            }
        }
    }
    
    if (index == _BCM_DPP_NOF_BCM_QUALIFIERS_PER_ENTRY_TO_KEEP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("no data for bcmFieldQualifyPacketRes found in SW state for entry %d"), entry));
    }

    *data = qualD.bcmParam0;
    *mask = qualD.bcmMask0;
    
exit:
    BCM_FREE(entryDe);
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpFlags_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyIpFlags
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpFlags_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 *data,
                                    uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpFlags,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TcpSequenceZero_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTcpSequenceZero
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      flag - (OUT) Qualifier match flags.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TcpSequenceZero_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *flag)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TcpHeaderSize_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTcpHeaderSize
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TcpHeaderSize_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerIp6FlowLabel_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInnerIp6FlowLabel
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerIp6FlowLabel_get(int unit,
                                              bcm_field_entry_t entry,
                                              uint32 *data,
                                              uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerIp6FlowLabel,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_petra_field_qualify_InnerIpType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerIpType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Inner ip header ip type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerIpType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IpType_t *type)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Qualifier match ip type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IpType_t *type)
{
    bcm_dpp_field_info_OLD_t *unitData;
    int32 ppdIpType;
    int32 emask;
    uint8 is_egress;
    uint32 group_flags = 0;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));
    is_egress = (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS)?1:0;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpType,
                                                           &ppdIpType,
                                                           &emask));
    if (emask) {
        /* Only 4 bits for the enum */
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_type_ppd_to_bcm((ppdIpType & 0xF), is_egress, type));
        /* At egress, check if options */
        if (*type == bcmFieldIpTypeIpv4Any) {
            _DPP_FIELD_UNIT_CHECK(unit, unitData);
            if (emask >> 4) {
                if (ppdIpType >> 4) {
                    *type = bcmFieldIpTypeIpv4WithOpts;
                }
                else {
                    *type = bcmFieldIpTypeIpv4NoOpts;
                }
            }
        }
        if (*type == bcmFieldIpTypeIpv6) {
            _DPP_FIELD_UNIT_CHECK(unit, unitData);
            if (emask >> 4) {
                if (ppdIpType >> 4) {
                    *type = bcmFieldIpTypeIpv6NoExtHdr;
                }
                else {
                    *type = bcmFieldIpTypeIpv6OneExtHdr;
                }
            }
        }
    }
    else {
        /* Not valid */
        *type = bcmFieldIpTypeCount;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2Format_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL2Format
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Qualifier match l2 format.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2Format_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_L2Format_t *type)
{
    int32 ppd;
    bcm_field_L2Format_t bcm;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL2Format,
                                                           &ppd,
                                                           &emask));

    if (emask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_l2_eth_format_ppd_to_bcm(ppd, &bcm));
        *type = bcm;
    }
    else {
        /* Not valid */
        *type = bcmFieldL2FormatCount;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MHOpcode_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMHOpcode
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MHOpcode_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_HiGig_get
 * Purpose:
 *      Qualify on HiGig packets.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_HiGig_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassPort_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInterfaceClassPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassPort_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInterfaceClassPort,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassL2_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInterfaceClassL2
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassL2_get(int unit,
                                             bcm_field_entry_t entry,
                                             uint32 *data,
                                             uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInterfaceClassL2,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassL3_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInterfaceClassL3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassL3_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcClassL2_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcClassL2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcClassL2_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcClassL3_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcClassL3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcClassL3_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcClassField_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcClassField
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcClassField_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifySrcClassField,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstClassL2_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstClassL2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstClassL2_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstClassL3_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstClassL3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstClassL3_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstClassField_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstClassField
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstClassField_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyDstClassField,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_IpProtocolCommon_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpProtocolCommon
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      protocol - (OUT) Qualifier protocol encoding.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpProtocolCommon_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IpProtocolCommon_t *protocol)
{
    int32 ppd;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpProtocolCommon,
                                                           &ppd,
                                                           &emask));

    if (emask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_next_protocol_ppd_to_bcm(ppd, protocol, emask));
    }
    else {
        *protocol = bcmFieldIpProtocolCommonCount;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerIpProtocolCommon_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerIpProtocolCommon
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      protocol - (OUT) Qualifier inner ip protocol encodnig.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerIpProtocolCommon_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IpProtocolCommon_t *protocol)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Snap_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySnap
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Snap_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_snap_header_t *data,
    bcm_field_snap_header_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Llc_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyLlc
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Llc_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_llc_header_t *data,
    bcm_field_llc_header_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerTpid_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerTpid
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      tpid - (OUT) Qualifier tpid.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerTpid_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *tpid)
{/* Created automatically by script */
    uint16 mask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerTpid,
                                                            tpid,
                                                            &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterTpid_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOuterTpid
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      tpid - (OUT) Qualifier tpid.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterTpid_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *tpid)
{/* Created automatically by script */
    uint16 mask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyOuterTpid,
                                                            tpid,
                                                            &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3Routable_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL3Routable
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3Routable_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpFrag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpFrag
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      frag_info - (OUT) Qualifier ip framentation encoding.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpFrag_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IpFrag_t *frag_info)
{
    int32 ppd;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpFrag,
                                                           &ppd,
                                                           &emask));

    if (emask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_frag_ppd_to_bcm(unit, ppd, frag_info));
    }
    else {
        *frag_info = bcmFieldIpFragCount;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3Ingress_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL3Ingress
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3Ingress_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint32 *data,
                                      uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyL3Ingress,
                                                            data,
                                                            mask));
    

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ExtensionHeaderType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExtensionHeaderType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExtensionHeaderType_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExtensionHeaderType,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ExtensionHeaderSubCode_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExtensionHeaderSubCode
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExtensionHeaderSubCode_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ExtensionHeader2Type_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExtensionHeaderType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExtensionHeader2Type_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L4Ports_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL4Ports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L4Ports_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MirrorCopy_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMirrorCopy
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MirrorCopy_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 *data,
                                       uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMirrorCopy,
                                                           data,
                                                           mask));
    *data = (*mask)? 1: 0;
    *mask = (*mask)? 1: 0;
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_petra_field_qualify_PphType_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPphType
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PphType_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 *data,
                                       uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyPphType,
                                                           data,
                                                           mask));

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelTerminated_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTunnelTerminated
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelTerminated_get(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 *data,
                                             uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTunnelTerminated,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsTerminated_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsTerminated
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsTerminated_get(int unit,
                                           bcm_field_entry_t entry,
                                           uint8 *data,
                                           uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsTerminated,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerSrcIp6_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerSrcIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerSrcIp6_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip6_t *data,
                                   bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerSrcIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDstIp6_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerDstIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDstIp6_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip6_t *data,
                                   bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerDstIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerSrcIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerSrcIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerSrcIp6High_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_ip6_t *data,
                                       bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerSrcIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDstIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerDstIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDstIp6High_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_ip6_t *data,
                                       bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerDstIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerTtl_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInnerTtl
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerTtl_get(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 *data,
                                     uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerTtl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerIpFrag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerIpFrag
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      frag_info - (OUT) Inner ip header fragmentation info.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerIpFrag_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IpFrag_t *frag_info)
{
    int32 ppd;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerIpFrag,
                                                           &ppd,
                                                           &emask));

    if (emask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_frag_ppd_to_bcm(unit, ppd, frag_info));
    }
    else {
        *frag_info = bcmFieldIpFragCount;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DosAttack_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDosAttack
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DosAttack_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpmcStarGroupHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpmcStarGroupHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpmcStarGroupHit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3DestRouteHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL3DestRouteHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3DestRouteHit_get(int unit,
                                           bcm_field_entry_t entry,
                                           uint8 *data,
                                           uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL3DestRouteHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3SrcHostHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL3SrcHostHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3SrcHostHit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2CacheHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL2CacheHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2CacheHit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2StationMove_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL2StationMove
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2StationMove_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL2StationMove,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2DestHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL2DestHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2DestHit_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 *data,
                                      uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL2DestHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2SrcStatic_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL2SrcStatic
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2SrcStatic_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2SrcHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL2SrcHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2SrcHit_get(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 *data,
                                     uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL2SrcHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardingVlanValid_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyForwardingVlanValid
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardingVlanValid_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VlanTranslationHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyVlanTranslationHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VlanTranslationHit_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 *data,
                                               uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyVlanTranslationHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IcmpTypeCode_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIcmpTypeCode
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IcmpTypeCode_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedVlanFormat
 * Purpose:
 *      Set match criteria for bcmFieldQualifyTranslatedVlanFormat
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedVlanFormat(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FibreChanOuter
 * Purpose:
 *      Add Fibre Channel outer header type field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (IN) Data to qualify with.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FibreChanOuter(int unit,
                             bcm_field_entry_t entry,
                             bcm_field_FibreChan_t fibre_chan_type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FibreChanInner
 * Purpose:
 *      Add Fibre Channel inner header type field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (IN) Data to qualify with.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FibreChanInner(int unit,
                             bcm_field_entry_t entry,
                             bcm_field_FibreChan_t fibre_chan_type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VnTag
 * Purpose:
 *      Add NIV VN tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VnTag(int unit, bcm_field_entry_t entry,
                            uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_CnTag
 * Purpose:
 *      Add QCN CN tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_CnTag(int unit, bcm_field_entry_t entry,
                            uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FabricQueueTag
 * Purpose:
 *      Add Fabric Queue tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FabricQueueTag(int unit, bcm_field_entry_t entry,
                                     uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcModPortGport
 * Purpose:
 *       Set match criteria for bcmFieldQualifySrcModPortGport
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcModPortGport(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_gport_t data)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t mask = ~0;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask));

    /* Limit to 16 bits since it is only Source-System-Port */
    COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) & 0xFFFF);
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0xFFFF);


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifySrcModPortGport,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcModuleGport
 * Purpose:
 *      Set match criteria for bcmFieldQualifySrcModuleGport
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcModuleGport(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t data)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedVlanFormat_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTranslatedVlanFormat
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedVlanFormat_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FibreChannOuter_get
 * Purpose:
 *      Get Fibre Channel outer header type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (OUT) Fibre Channel header type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FibreChanOuter_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_FibreChan_t *fibre_chan_type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FibreChannInner_get
 * Purpose:
 *      Get Fibre Channel inner header type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (OUT) Fibre Channel header type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FibreChanInner_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_FibreChan_t *fibre_chan_type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VnTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyVnTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VnTag_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_CnTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyCnTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_CnTag_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FabricQueueTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFabricQueueTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FabricQueueTag_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcModPortGport_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifySrcModPortGport
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcModPortGport_get(int unit,
                                            bcm_field_entry_t entry,
                                            bcm_gport_t *data)
{
    uint32 data_lcl;
    uint32 mask;
    bcm_module_t modid;
    bcm_port_t mode_port;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifySrcModPortGport,
                                                            &data_lcl,
                                                            &mask));
    *data = 0;

    if (mask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_port_mod_port_from_sys_port(unit, &modid, &mode_port, data_lcl));

        BCM_GPORT_MODPORT_SET(*data, modid, mode_port);
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcModuleGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcModuleGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcModuleGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *data)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_port_create_mode
 *   Purpose
 *      Create a new group that has the specified qualifier set and priority,
 *      and applies only to the specified port.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_port_t port = the port to which the group is to apply
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_field_group_mode_t mode = the group mode
 *      (out) bcm_field_group_t *group = where to put the group ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group (does
 *      this mean globally or within just the single stage?)
 *      Can not specify a qualifier that another group in the same stage has.
 *      If no stage qualifier, it is assumed to be ingress stage.
 *      Only supports mode bcmFieldGroupModeAuto.
 */
int
bcm_petra_field_group_port_create_mode(int unit,
                                        bcm_port_t port,
                                        bcm_field_qset_t qset,
                                        int pri,
                                        bcm_field_group_mode_t mode,
                                        bcm_field_group_t *group)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_port_create_mode_id
 *   Purpose
 *      Create a new group with the specified ID that has the specified
 *      qualifier set and priority, and applies only to the specified port.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_port_t port = the port to which the group is to apply
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_field_group_mode_t mode = the group mode
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 *      Can not specify a qualifier that another group in the same stage has.
 *      If no stage qualifier, it is assumed to be bcmFieldQualifyStageIngress.
 *      Only supports mode bcmFieldGroupModeAuto.
 */
int
bcm_petra_field_group_port_create_mode_id(int unit,
                                           bcm_port_t port,
                                           bcm_field_qset_t qset,
                                           int pri,
                                           bcm_field_group_mode_t mode,
                                           bcm_field_group_t group)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/* Function: bcm_petra_field_group_wlan_create_mode
 *
 * Purpose:
 *     Create a wlan field group with a mode (single, double, etc.).
 *
 * Parameters:
 *     unit - BCM device number.
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - (OUT) field Group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_petra_field_group_wlan_create_mode(int unit, bcm_field_qset_t qset, int pri,
                                     bcm_field_group_mode_t mode,
                                     bcm_field_group_t *group)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/* Function: bcm_petra_field_group_wlan_create_mode_id
 *
 * Purpose:
 *     Create a wlan field group with a mode (single, double, etc.).
 *
 * Parameters:
 *     unit - BCM device number.
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - (OUT) field Group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_petra_field_group_wlan_create_mode_id(int unit, bcm_field_qset_t qset, int pri,
                                        bcm_field_group_mode_t mode,
                                        bcm_field_group_t group)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_action_mac_add
 * Purpose:
 *      Add an action to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry Id.
 *      action - (IN) Field action id.
 *      mac - (IN) Field action parameter.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_action_mac_add(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_action_t action,
    bcm_mac_t mac)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_action_mac_get
 * Purpose:
 *      Retrieve the parameters for an action previously added to a
 *      field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry Id.
 *      action - (IN) Field action id.
 *      mac - (IN) Field action argument.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_action_mac_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_action_t action,
    bcm_mac_t *mac)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FlowId
 * Purpose:
 *       Set match criteria for bcmFieldQualifyFlowId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FlowId(int unit,
                               bcm_field_entry_t entry,
                               uint16 data,
                               uint16 mask)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t data_port, mask_port;

    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);

    /* Get the encoding of Flow-Id 0*/
    BCM_GPORT_UNICAST_QUEUE_GROUP_SET(data_port, 0);
    mask_port = mask? (~0) : 0;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data_port,
                                                               mask_port,
                                                               &edata,
                                                               &emask));
    COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | data);
    /* Use the mask parameter for the 16 LSBs, emask for the rest */
    /* Limit to 19b at ingress */
    COMPILER_64_SET(emask, 0, (COMPILER_64_LO(emask) & 0x60000) | mask);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyFlowId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InVPort
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInVPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InVPort(int unit,
                                bcm_field_entry_t entry,
                                uint8 data,
                                uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported - Use bcm_petra_field_qualify_InVPort32 instead of.\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OutVPort
 * Purpose:
 *       Set match criteria for bcmFieldQualifyOutVPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OutVPort(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported - Use bcm_petra_field_qualify_OutVPort32 instead of.\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FlowId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyFlowId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FlowId_get(int unit,
                                   bcm_field_entry_t entry,
                                   uint16 *data,
                                   uint16 *mask)
{
    uint32 edata, emask;
    bcm_gport_t   gport;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyFlowId,
                                                            &edata,
                                                            &emask));
    *data = 0;
    *mask = 0;
    if (emask) {
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, edata, &gport),
                            (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), edata));

        /* Take only the 16b of the Queue-ID */
        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
            *data = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport) & 0xFFFF;
            *mask = emask & 0xFFFF;
        }
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InVPort_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInVPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InVPort_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 *data,
                                    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported - Use bcm_petra_field_qualify_InVPort32_get instead of.\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OutVPort_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyOutVPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OutVPort_get(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 *data,
                                     uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported - Use bcm_petra_field_qualify_OutVPort32_get instead of.\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelId
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTunnelId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelId(int unit,
                                 bcm_field_entry_t entry,
                                 uint32 data,
                                 uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTunnelId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTunnelId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelId_get(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 *data,
                                     uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTunnelId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_petra_field_qualify_MplsForwardingLabelAction32
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsForwardingLabelAction
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsForwardingLabelAction32(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint32 data,
                                                   uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsForwardingLabelAction,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsForwardingLabelAction32_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsForwardingLabelAction
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsForwardingLabelAction32_get(int unit,
                                                       bcm_field_entry_t entry,
                                                       uint32 *data,
                                                       uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsForwardingLabelAction,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsForwardingLabelId
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsForwardingLabelId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsForwardingLabelId(int unit,
                                              bcm_field_entry_t entry,
                                              uint32 data,
                                              uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsForwardingLabelId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsForwardingLabelId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsForwardingLabelId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsForwardingLabelId_get(int unit,
                                                  bcm_field_entry_t entry,
                                                  uint32 *data,
                                                  uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsForwardingLabelId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *     bcm_petra_field_qualify_SrcGport
 * Purpose:
 *     Add Source ModPort or MPLS/MiM/WLAN port qualification to a
 *     field entry.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field Entry id.
 *     port_id  - (IN) Source Generic Logical port or virtual port id.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_petra_field_qualify_SrcGport(int unit,
                               bcm_field_entry_t entry,
                               bcm_gport_t mpls_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *     bcm_petra_field_qualify_SrcGport_get
 * Purpose:
 *     Get Source ModPort or MPLS/MiM/WLAN gport value from a
 *     field entry.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field Entry id.
 *     port_id  - (OUT) ModPort Gport or MPLS/MiM/WLAN Gport ID.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_petra_field_qualify_SrcGport_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_gport_t *port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *     bcm_petra_field_entry_operation
 * Purpose:
 *     Perform entry backup, restore and backup copy free operations
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     entry_oper - (IN) Pointer to field entry operation structure
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_petra_field_entry_operation(int unit, bcm_field_entry_oper_t *entry_oper)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PolicerIntPrio
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPolicerIntPrio
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PolicerIntPrio(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 data,
                                       uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPolicerIntPrio,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PolicerIntPrio_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPolicerIntPrio
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PolicerIntPrio_get(int unit,
                                           bcm_field_entry_t entry,
                                           uint8 *data,
                                           uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyPolicerIntPrio,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ptch
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPtch
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ptch(int unit,
                             bcm_field_entry_t entry,
                             uint8 data,
                             uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPtch,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ptch_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPtch
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ptch_get(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 *data,
                                 uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyPtch,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2Learn
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL2Learn
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2Learn(int unit,
                                bcm_field_entry_t entry,
                                uint8 data,
                                uint8 mask)
{
    uint64 edata;
    uint64 emask;
    uint32 group_flags = 0;
    uint8 l2_learn_allowed = 0; /* Different values according to the stage */
    int L2LearnMode = 0;

    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);

    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, 0);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));

    if (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS) {
        /* Only egress learning */
        l2_learn_allowed = 0x1;
    }
    else if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) {
        /* At ingress, retrieve if ingress or egress learning */
        BCMDNX_IF_ERR_EXIT(bcm_switch_control_get(unit, bcmSwitchL2LearnMode, &L2LearnMode)); 
        L2LearnMode &= ~BCM_L2_LEARN_DISABLE;
        if ((L2LearnMode & BCM_L2_INGRESS_CENT)
            || (L2LearnMode & BCM_L2_INGRESS_DIST)) {
            /* Ingress learning, bit 0 up, bit 1 down */
            l2_learn_allowed = 0x1;
        }
        else if ((L2LearnMode & BCM_L2_EGRESS_DIST)
                 || (L2LearnMode & BCM_L2_EGRESS_CENT)
                 || (L2LearnMode & BCM_L2_EGRESS_INDEPENDENT)) {
            /* Egress learning, bit 1 up, bit 0 down */
            l2_learn_allowed = 0x1 << 1;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                             (_BSL_BCM_MSG("The L2 learning mode get returned incoherent value %d \n"),
                              L2LearnMode));
        }
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("Non-supported Field group stage with Field group flags %d \n"),
                          group_flags));
    }

    if (mask) {
        COMPILER_64_SET(emask, 0, l2_learn_allowed);
        COMPILER_64_SET(edata, 0, (data? l2_learn_allowed:0));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2Learn,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2Learn_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL2Learn
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2Learn_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 *data,
                                    uint8 *mask)
{
    uint8 data_lcl;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL2Learn,
                                                           &data_lcl,
                                                           mask));
    *data = 0;
    if (*mask) {
        /* Data can be either 0x1 or 0x0 whether it was enable at some stage */
        *data = (data_lcl)? 0x1 : 0x0;
        *mask = 0x1;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PortOrientation
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPortOrientation
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PortOrientation(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 data,
                                        uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, 0);

    if (mask) {
        /* 0 for network-oriented, 1 for hub-oriented */
        COMPILER_64_SET(edata, 0, (data == bcmFieldOrientationNetwork));
        COMPILER_64_SET(emask, 0, 1);
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPortOrientation,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PortOrientation_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPortOrientation
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PortOrientation_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint8 *data,
                                            uint8 *mask)
{
    uint8 edata, emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyPortOrientation,
                                                           &edata,
                                                           &emask));
    if (emask) {
        *mask = 0x1;
        *data = (edata)?bcmFieldOrientationNetwork:bcmFieldOrientationAccess;
    }
    else {
        *mask = 0;
        *data = 0;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsBos
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsBos
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsBos(int unit,
                                bcm_field_entry_t entry,
                                uint8 data,
                                uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsBos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsBos_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsBos
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsBos_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 *data,
                                    uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsBos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Dhcp
 * Purpose:
 *       Set match criteria for bcmFieldQualifyDhcp
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Dhcp(int unit,
                             bcm_field_entry_t entry,
                             uint8 data,
                             uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDhcp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Dhcp_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyDhcp
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Dhcp_get(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 *data,
                                 uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyDhcp,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_EcnValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyEcnValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_EcnValue(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{
    uint64 edata;
    uint64 emask;
    uint8 is_cni, ecn_capable;
    uint32 group_flags = 0;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);

    if ((0 != mask) && (0x3 != (mask & 0x3))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                   " bits set or all bits clear clear)")));
    }

    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, 0);

    /*
     * ECN values: 0 - not supported, 1/2 - not congested, 3 - congested
     */
    if (mask) {
        is_cni = (data == 0x3);
        ecn_capable = (data)?0x1:0x0;
        BCMDNX_IF_ERR_EXIT(
            _bcm_dpp_petra_field_entry_group_flags(unit,
                                                   entry,
                                                   &group_flags));

        if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) {
            /* At ingress: bit 0 for ECN-Capable, bit 1 for CNI */
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (ecn_capable << 0));
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (is_cni << 1));
            COMPILER_64_SET(emask, 0, 0x3);
        }
        else if (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS) {
            /* At egress: bit 0 for CNI */
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (is_cni << 0));
            COMPILER_64_SET(emask, 0, 0x1);
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                             (_BSL_BCM_MSG("Non-supported Field group stage with Field group flags %d \n"),
                              group_flags));
        }
    }


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyEcnValue,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_EcnValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyEcnValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_EcnValue_get(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 *data,
                                     uint8 *mask)
{
    uint8 edata;
    uint8 emask;
    uint32 group_flags = 0;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyEcnValue,
                                                           &edata,
                                                           &emask));

    *data = 0;
    *mask = 0;

    /*
     * ECN values: 0 - not supported, 1/2 - not congested, 3 - congested
     */
    if (emask) {
        *mask = 0x3;
        BCMDNX_IF_ERR_EXIT(
            _bcm_dpp_petra_field_entry_group_flags(unit,
                                                   entry,
                                                   &group_flags));

        if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) {
            /* At ingress: bit 0 for ECN-Capable, bit 1 for CNI */
            if ((edata & 0x1) == 0) {
                *data = 0;
            }
            else if (edata & (0x1 << 1)) {
                *data = 3;
            }
            else {
                *data = 1;
            }
        }
        else if (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS) {
            /* When no congestion (no CNI), not clear how to interpret the data value whether ECN-Capable */
            *data = (edata & 0x1)?3:1;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                             (_BSL_BCM_MSG("Non-supported Field group stage with Field group flags %d \n"),
                              group_flags));
        }
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpTunnelHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyIpTunnelHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpTunnelHit(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 data,
                                    uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpTunnelHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpTunnelHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyIpTunnelHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpTunnelHit_get(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 *data,
                                        uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpTunnelHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3SrcRouteHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL3SrcRouteHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3SrcRouteHit(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL3SrcRouteHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3SrcRouteHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL3SrcRouteHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3SrcRouteHit_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL3SrcRouteHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpmcHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyIpmcHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpmcHit(int unit,
                                bcm_field_entry_t entry,
                                uint8 data,
                                uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpmcHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpmcHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyIpmcHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpmcHit_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 *data,
                                    uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpmcHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SnoopCopy
 * Purpose:
 *       Set match criteria for bcmFieldQualifySnoopCopy
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SnoopCopy(int unit,
                                  bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, 1); /* 1 - encoding in FTMH.TM-Action-Type for Snoop */
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifySnoopCopy,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SnoopCopy_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifySnoopCopy
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SnoopCopy_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 *data,
                                      uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifySnoopCopy,
                                                           data,
                                                           mask));
    *data = (*mask)? 1: 0;
    *mask = (*mask)? 1: 0;
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardCopy
 * Purpose:
 *       Set match criteria for bcmFieldQualifyForwardCopy
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardCopy(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 data,
                                    uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, 0); /* 0 - encoding in FTMH.TM-Action-Type for Forwarding */
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyForwardCopy,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardCopy_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyForwardCopy
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardCopy_get(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 *data,
                                        uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyForwardCopy,
                                                           data,
                                                           mask));
    *data = (*mask)? 1: 0;
    *mask = (*mask)? 1: 0;

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_BypassFilter
 * Purpose:
 *       Set match criteria for bcmFieldQualifyBypassFilter
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_BypassFilter(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyBypassFilter,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_BypassFilter_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyBypassFilter
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_BypassFilter_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyBypassFilter,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ReplicantAny
 * Purpose:
 *       Set match criteria for bcmFieldQualifyReplicantAny
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ReplicantAny(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyReplicantAny,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ReplicantAny_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyReplicantAny
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ReplicantAny_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyReplicantAny,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ReplicantFirst
 * Purpose:
 *       Set match criteria for bcmFieldQualifyReplicantFirst
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ReplicantFirst(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 data,
                                       uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyReplicantFirst,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ReplicantFirst_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyReplicantFirst
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ReplicantFirst_get(int unit,
                                           bcm_field_entry_t entry,
                                           uint8 *data,
                                           uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyReplicantFirst,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassVPort
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInterfaceClassVPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassVPort(int unit,
                                            bcm_field_entry_t entry,
                                            uint32 data,
                                            uint32 mask)
{
    uint64 edata;
    uint64 emask;
    uint32 mapped_data = 0;
    uint32 mapped_mask = 0;
    uint32 soc_sand_rv;
    uint32 group_flags = 0;
    uint8  is_egress;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    soc_sand_rv = _bcm_dpp_petra_field_entry_group_flags(unit, entry, &group_flags);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
    is_egress = (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS)? 1 : 0;
    if (is_egress) {
        /* At egress stage, this qualifier points to a different signal (in_lif_orientation
         * instead of in_lif_profile), therefore an occupational mamangement mapping is no
         * longer required, value is treated as is */
        COMPILER_64_SET(edata, 0, data);
        COMPILER_64_SET(emask, 0, mask);
    } else {
        /* Set the free bits in inlif profile to given values */
        soc_sand_rv = MBCM_PP_DRIVER_CALL(unit,mbcm_pp_occ_mgmt_app_set,(unit, SOC_OCC_MGMT_TYPE_INLIF, SOC_OCC_MGMT_APP_USER, data, &mapped_data));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

        soc_sand_rv = MBCM_PP_DRIVER_CALL(unit,mbcm_pp_occ_mgmt_app_set,(unit, SOC_OCC_MGMT_TYPE_INLIF, SOC_OCC_MGMT_APP_USER, mask, &mapped_mask));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

        COMPILER_64_SET(edata, 0, mapped_data);
        COMPILER_64_SET(emask, 0, mapped_mask);
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInterfaceClassVPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassVPort_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInterfaceClassVPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassVPort_get(int unit,
                                                bcm_field_entry_t entry,
                                                uint32 *data,
                                                uint32 *mask)
{
    uint32 mapped_data;
    uint32 mapped_mask;
    uint32 soc_sand_rv;
    uint32 group_flags = 0;
    uint8  is_egress;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInterfaceClassVPort,
                                                            &mapped_data,
                                                            &mapped_mask));

    soc_sand_rv = _bcm_dpp_petra_field_entry_group_flags(unit, entry, &group_flags);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
    is_egress = (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS)? 1 : 0;

    if (is_egress) {
        /* At egress stage, this qualifier points to a different signal (in_lif_orientation
         * instead of in_lif_profile), therefore an occupational mamangement mapping is no
         * longer required, value is treated as is */
        *data = mapped_data;
        *mask = mapped_mask;
    } else {
        /* Set the free bits in inlif profile to given values */
        soc_sand_rv = MBCM_PP_DRIVER_CALL(unit,mbcm_pp_occ_mgmt_app_get,(unit, SOC_OCC_MGMT_TYPE_INLIF, SOC_OCC_MGMT_APP_USER, &mapped_data, data));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

        soc_sand_rv = MBCM_PP_DRIVER_CALL(unit,mbcm_pp_occ_mgmt_app_get,(unit, SOC_OCC_MGMT_TYPE_INLIF, SOC_OCC_MGMT_APP_USER, &mapped_mask, mask));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ISid
 * Purpose:
 *       Set match criteria for bcmFieldQualifyISid
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ISid(int unit,
                             bcm_field_entry_t entry,
                             uint32 data,
                             uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, ~0);

    if (mask) {
        SOC_PPC_FRWRD_DECISION_INFO fwdDecision;

        /* Build the EEI encoding: Trill unicast nickname */
        SOC_PPC_FRWRD_DECISION_INFO_clear(&fwdDecision);
        fwdDecision.type = SOC_PPC_FRWRD_DECISION_TYPE_UC_FLOW;
        fwdDecision.dest_id = 0;
        fwdDecision.additional_info.outlif.type = SOC_PPC_OUTLIF_ENCODE_TYPE_NONE;
        fwdDecision.additional_info.eei.type = SOC_PPC_EEI_TYPE_MIM;
        fwdDecision.additional_info.eei.val.isid = data;

        /* Encode the Nickname into EEI */
        /* Get the HW Destination from the Forward decision */
        BCMDNX_IF_ERR_EXIT_MSG(
            _bcm_dpp_field_qualify_fwd_decision_to_hw_destination_convert(unit,
                                                                          &fwdDecision,
                                                                          FALSE, /* is_for_destination */
                                                                          FALSE, /* is_for_action */
                                                                          &edata,
                                                                          &emask),
                            (_BSL_BCM_MSG("unable to get from the forward decision the HW data")));
        /* All the MSBs are significant, only the 16 LSBs can be masked */
        COMPILER_64_SET(emask, 0, (0xFF << 16) | mask);
    }


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyISid,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ISid_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyISid
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ISid_get(int unit,
                                 bcm_field_entry_t entry,
                                 uint32 *data,
                                 uint32 *mask)
{
    uint32 edata, emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyISid,
                                                            &edata,
                                                            &emask));

    *data = 0;
    *mask = 0;

    if (emask) {
        SOC_PPC_FRWRD_DECISION_INFO fwdDecision;

        /* Decode the EEI to nickname */
        SOC_PPC_FRWRD_DECISION_INFO_clear(&fwdDecision);
        BCMDNX_IF_ERR_EXIT(
            _bcm_dpp_field_qualify_fwd_decision_from_hw_convert(unit,
                                                                FALSE, /* is_for_destination */
                                                                edata,
                                                                ARAD_PP_FWD_DECISION_PARSE_DEST | ARAD_PP_FWD_DECISION_PARSE_EEI | ARAD_PP_FWD_DECISION_PARSE_EEI_MIM,
                                                                &fwdDecision));

        if (fwdDecision.additional_info.eei.type == SOC_PPC_EEI_TYPE_MIM) {
            *data = fwdDecision.additional_info.eei.val.isid;
            /* Return only the Nickname mask */
            *mask = emask & ((1 << 16) - 1);
        }
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TrillEgressRbridge
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTrillEgressRbridge
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TrillEgressRbridge(int unit,
                                           bcm_field_entry_t entry,
                                           uint32 data,
                                           uint32 mask)
{
    uint64 edata;
    uint64 emask;

    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, ~0);


    if (mask) {
        SOC_PPC_FRWRD_DECISION_INFO fwdDecision;

        /* Build the EEI encoding: Trill unicast nickname */
        SOC_PPC_FRWRD_DECISION_INFO_clear(&fwdDecision);
        fwdDecision.type = SOC_PPC_FRWRD_DECISION_TYPE_UC_FLOW;
        fwdDecision.dest_id = 0;
        fwdDecision.additional_info.outlif.type = SOC_PPC_OUTLIF_ENCODE_TYPE_NONE;
        fwdDecision.additional_info.eei.type = SOC_PPC_EEI_TYPE_TRILL;
        fwdDecision.additional_info.eei.val.trill_dest.is_multicast = 0;
        fwdDecision.additional_info.eei.val.trill_dest.dest_nick = data;

        /* Encode the Nickname into EEI */
        /* Get the HW Destination from the Forward decision */
        BCMDNX_IF_ERR_EXIT_MSG(
            _bcm_dpp_field_qualify_fwd_decision_to_hw_destination_convert(unit,
                                                                          &fwdDecision,
                                                                          FALSE, /* is_for_destination */
                                                                          FALSE, /* is_for_action */
                                                                          &edata,
                                                                          &emask),
                            (_BSL_BCM_MSG("unable to get from the forward decision the HW data")));
        /* All the 8 MSBs are significant, only the 16 LSBs can be masked */
        COMPILER_64_SET(emask, 0, (0xFF << ARAD_PP_ASD_NOF_BITS_TRILL_NICK) | mask);
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTrillEgressRbridge,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TrillEgressRbridge_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTrillEgressRbridge
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TrillEgressRbridge_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
    uint32 edata, emask;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTrillEgressRbridge,
                                                            &edata,
                                                            &emask));

    *data = 0;
    *mask = 0;

    if (emask) {
        SOC_PPC_FRWRD_DECISION_INFO fwdDecision;

        /* Decode the EEI to nickname */
        SOC_PPC_FRWRD_DECISION_INFO_clear(&fwdDecision);
        BCMDNX_IF_ERR_EXIT(
            _bcm_dpp_field_qualify_fwd_decision_from_hw_convert(unit,
                                                                FALSE, /* is_for_destination */
                                                                edata,
                                                                ARAD_PP_FWD_DECISION_PARSE_DEST | ARAD_PP_FWD_DECISION_PARSE_EEI,
                                                                &fwdDecision));

        if (fwdDecision.additional_info.eei.type == SOC_PPC_EEI_TYPE_TRILL) {
            *data = fwdDecision.additional_info.eei.val.trill_dest.dest_nick;
            /* Return only the Nickname mask */
            *mask = emask & ((1 << ARAD_PP_ASD_NOF_BITS_TRILL_NICK) - 1);
        }
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PacketTerminatedBytes
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPacketTerminatedBytes
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PacketTerminatedBytes(int unit,
                                              bcm_field_entry_t entry,
                                              uint32 data,
                                              uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPacketTerminatedBytes,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PacketTerminatedBytes_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPacketTerminatedBytes
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PacketTerminatedBytes_get(int unit,
                                                  bcm_field_entry_t entry,
                                                  uint32 *data,
                                                  uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyPacketTerminatedBytes,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TrunkHashResult
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTrunkHashResult
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TrunkHashResult(int unit,
                                        bcm_field_entry_t entry,
                                        uint32 data,
                                        uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTrunkHashResult,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TrunkHashResult_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTrunkHashResult
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TrunkHashResult_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint32 *data,
                                            uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTrunkHashResult,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PacketSize
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPacketSize
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PacketSize(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 data,
                                   uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPacketSize,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PacketSize_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPacketSize
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PacketSize_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint32 *data,
                                            uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyPacketSize,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassProcessingPort
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInterfaceClassProcessingPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassProcessingPort(int unit,
                                                     bcm_field_entry_t entry,
                                                     uint64 data,
                                                     uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInterfaceClassProcessingPort,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassProcessingPort_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInterfaceClassProcessingPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassProcessingPort_get(int unit,
                                                         bcm_field_entry_t entry,
                                                         uint64 *data,
                                                         uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInterfaceClassProcessingPort,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_Container
 * Purpose:
 *       Set match criteria for bcmFieldQualifyContainer
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

int
bcm_petra_field_qualify_Container(int unit,
                                  bcm_field_entry_t entry,
                                  uint64 data,
                                  uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_QUX(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Set bcmFieldQualifyContainer supported only on QUX!!")));
    }

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyContainer,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Container_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInterfaceClassProcessingPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Container_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint64 *data,
                                      uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_QUX(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Get bcmFieldQualifyContainer supported  only on QUX!!")));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyContainer,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_VlanTranslationValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyVlanTranslationValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VlanTranslationValue(int unit,
                                             bcm_field_entry_t entry,
                                             uint64 data,
                                             uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyVlanTranslationValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VlanTranslationValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyVlanTranslationValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VlanTranslationValue_get(int unit,
                                                 bcm_field_entry_t entry,
                                                 uint64 *data,
                                                 uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyVlanTranslationValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelTerminatedValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTunnelTerminatedValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelTerminatedValue(int unit,
                                              bcm_field_entry_t entry,
                                              uint64 data,
                                              uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTunnelTerminatedValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelTerminatedValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTunnelTerminatedValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelTerminatedValue_get(int unit,
                                                  bcm_field_entry_t entry,
                                                  uint64 *data,
                                                  uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTunnelTerminatedValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsTerminatedValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsTerminatedValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsTerminatedValue(int unit,
                                            bcm_field_entry_t entry,
                                            uint64 data,
                                            uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsTerminatedValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsTerminatedValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsTerminatedValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsTerminatedValue_get(int unit,
                                                bcm_field_entry_t entry,
                                                uint64 *data,
                                                uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsTerminatedValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpTunnelValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyIpTunnelValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpTunnelValue(int unit,
                                      bcm_field_entry_t entry,
                                      uint64 data,
                                      uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpTunnelValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpTunnelValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyIpTunnelValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpTunnelValue_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint64 *data,
                                          uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyIpTunnelValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2DestValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL2DestValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2DestValue(int unit,
                                    bcm_field_entry_t entry,
                                    uint64 data,
                                    uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2DestValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2DestValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL2DestValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2DestValue_get(int unit,
                                        bcm_field_entry_t entry,
                                        uint64 *data,
                                        uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyL2DestValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2SrcValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL2SrcValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2SrcValue(int unit,
                                   bcm_field_entry_t entry,
                                   uint64 data,
                                   uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2SrcValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2SrcValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL2SrcValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2SrcValue_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint64 *data,
                                       uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyL2SrcValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3DestRouteValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL3DestRouteValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3DestRouteValue(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 data,
                                         uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL3DestRouteValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3DestRouteValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL3DestRouteValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3DestRouteValue_get(int unit,
                                             bcm_field_entry_t entry,
                                             uint64 *data,
                                             uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyL3DestRouteValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3SrcRouteValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL3SrcRouteValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3SrcRouteValue(int unit,
                                        bcm_field_entry_t entry,
                                        uint64 data,
                                        uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL3SrcRouteValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3SrcRouteValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL3SrcRouteValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3SrcRouteValue_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint64 *data,
                                            uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyL3SrcRouteValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpmcValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyIpmcValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpmcValue(int unit,
                                  bcm_field_entry_t entry,
                                  uint64 data,
                                  uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpmcValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpmcValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyIpmcValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpmcValue_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint64 *data,
                                      uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyIpmcValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstRpfGport
 * Purpose:
 *       Set match criteria for bcmFieldQualifyDstRpfGport
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstRpfGport(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_gport_t data)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t mask = ~0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask));
    /* Limit to 19b at ingress */
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0x7FFFF);

    /* Indicate this port is valid */
    if ( !COMPILER_64_IS_ZERO(edata) ) {
        COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | 0x80000);
    }
    if ( !COMPILER_64_IS_ZERO(emask) ) {
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | 0x80000);
    }


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstRpfGport,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstRpfGport_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyDstRpfGport
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstRpfGport_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_gport_t *data)
{
    uint64 data_lcl, mask;
    bcm_dpp_field_info_OLD_t *unitData;

    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               bcmFieldQualifyDstRpfGport,
                                                               1, /* count*/
                                                               &data_lcl,
                                                               &mask));
    *data = 0;
    if ((COMPILER_64_LO(mask) & 0x80000) & (COMPILER_64_LO(data_lcl) & 0x80000)) {
        /* RPF destination valid */
        if (COMPILER_64_LO(mask)) {
            BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, COMPILER_64_LO(data_lcl) & 0x7FFFF, data),
                                (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), COMPILER_64_LO(data_lcl)));
        }

    }


exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_RxTrapCode
 * Purpose:
 *       Set match criteria for bcmFieldQualifyRxTrapCode
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_RxTrapCode(int unit,
                                     bcm_field_entry_t entry,
                                     bcm_rx_trap_t data)
{
    uint64 edata;
    uint64 emask;
    uint32 hwTrapId = ~0; /* invalid by default */
    uint32 hwTrapMask[1] = {0xFF}; /* single trap by default */
    int soc_ppd_trap_id;
    uint32 group_flags = 0;
    unsigned int soc_sand_dev_id;
    uint32 soc_sand_rv;
    uint32 soc_ppd_trap_bitmap_id;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);

    /* Do not support User-define traps, since the ID is unknown */
    if (data == bcmRxTrapUserDefine) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_BADID, (_BSL_BCM_MSG_NO_UNIT("the BCM Trap type User-define is not supported since its ID is unknown")));
    }

    /*
     * Get the conversion from BCM trap type to the PPD trap id
     * Then from the PPD Trap Id to HW Trap Id
     */

    /* 
     * Special case for L2CP virtual traps: can be Reserve-Multicast 
     * (8 traps) or programmable-traps (4 traps). 
     * Since the ID is not input of the function, mask all the relevant 
     * traps using the TCAM mask. 
     * Give a SOC property to indicate which one to mask. 
     */
    if (data == bcmRxTrapL2Cache) {
        if (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "trap_l2_cache_field_reserve_mc_hit", 0)) {
            soc_ppd_trap_id = SOC_PPC_TRAP_CODE_RESERVED_MC_0;
            SHR_BITCLR_RANGE(hwTrapMask, 0, 3); /* 8 traps */
        }
        else {
            soc_ppd_trap_id = SOC_PPC_TRAP_CODE_PROG_TRAP_0;
            /* 
             * There are 4 programmable traps, but they are not aligned to 0x4 to allow a decent masking 
             * Thus, mask only on the 2 first  programmable traps. 
             */ 
            SHR_BITCLR_RANGE(hwTrapMask, 0, 1); 
        }
    }
    else {
        /* BCM to PPD trap */
        _bcm_dpp_rx_ppd_trap_get(unit, data, &soc_ppd_trap_id);
    }

    /*
     * Different mapping between Ingress and Egress
     */
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));
    if (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS) {
        /* At egress, get the action profile ID */
        soc_sand_dev_id = (unit);
        /* since soc_ppd_trap_to_eg_action_map_get expects the trap bitmap value, we convert the egress ppd trap id to it's bitmap value */
        soc_ppd_trap_bitmap_id = _bcm_dpp_rx_trap_id_to_egress(soc_ppd_trap_id);
        soc_sand_rv = soc_ppd_trap_to_eg_action_map_get(soc_sand_dev_id, soc_ppd_trap_bitmap_id, &hwTrapId);
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
        
        if (hwTrapId == SOC_PPC_TRAP_EG_NO_ACTION) {
            /* Error - trap not configured */
           BCMDNX_ERR_EXIT_MSG(BCM_E_BADID,
                          ( _BSL_BCM_MSG_NO_UNIT("unable to get a valid egress action profile from the PPD trap Code")));

        }
        hwTrapId = (1<<3)|(hwTrapId); /*{ Action-Profile-Index (1b), Action-Profile-Valid (3b) }*/
        hwTrapMask[0] = 0xF; /* 4 bits for { Action-Profile-Index (1b), Action-Profile-Valid (3b) }*/
    }
    if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) {
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_trap_ppd_to_hw(unit, soc_ppd_trap_id, &hwTrapId),
                                (_BSL_BCM_MSG_NO_UNIT("unable to get from the HW Trap Id for PPD trap Id %d (%s)"),
                                 soc_ppd_trap_id,
                                 SOC_PPC_TRAP_CODE_to_string(soc_ppd_trap_id)));
    }
    COMPILER_64_SET(edata, 0, hwTrapId);
    COMPILER_64_SET(emask, 0, *hwTrapMask);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyRxTrapCode,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_RxTrapCode_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyRxTrapCode
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_RxTrapCode_get(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_rx_trap_t *data)
{
    uint32 hwTrap;
    uint32 mask;
    uint8 found;
    uint32 ppdTrapCode = 0;
    uint32 group_flags = 0;
    unsigned int soc_sand_dev_id;
    uint32 soc_sand_rv;
    uint32 hwTrapId = ~0;
    SOC_PPC_TRAP_EG_TYPE ppdTrapCode_next;
    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyRxTrapCode,
                                                            &hwTrap,
                                                            &mask));
    *data = bcmRxTrapCount;

    if (mask) {
        /*
         * Get the conversion to BCM trap type from the PPD trap id
         * after to the PPD Trap Id from HW Trap Id
         */
        /*
         * Different mapping between Ingress and Egress
         */
        BCMDNX_IF_ERR_EXIT(
            _bcm_dpp_petra_field_entry_group_flags(unit,
                                                   entry,
                                                   &group_flags));
        if (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS) {
            /* At egress, get the action profile ID */
            soc_sand_dev_id = (unit);
            hwTrap = hwTrap & 0x7; /*  The 4th bit is the valid bit : { Action-Profile-Index (1b), Action-Profile-Valid (3b) } */
            for (ppdTrapCode = 0; ppdTrapCode < SOC_PPC_TRAP_EG_TYPE_HIGHEST_ARAD ;) {
                soc_sand_rv = soc_ppd_trap_to_eg_action_map_get(soc_sand_dev_id, ppdTrapCode, &hwTrapId);
                BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
                if (hwTrapId == hwTrap) {
                    break;
                }

                /* increase statement */
                 BCMDNX_IF_ERR_EXIT(_bcm_dpp_rx_get_next_eg_soc_ppc_trap((SOC_PPC_TRAP_EG_TYPE)ppdTrapCode,&ppdTrapCode_next));
                 ppdTrapCode = ppdTrapCode_next;
 
            }
            if (hwTrapId != hwTrap) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d has a HW Trap ID %d not valid\n"),  unit,  entry, hwTrap));
            }

            /* converting the ppdTrapCode to it's egress trap id */
            ppdTrapCode = _bcm_dpp_rx_egress_to_trap_id(ppdTrapCode);
        }

        if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) {
            BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_trap_ppd_from_hw(unit, hwTrap, &ppdTrapCode),
                                (_BSL_BCM_MSG_NO_UNIT("unable to get from the HW Trap Id %d the PPD trap Id"),
                                 hwTrap));
        }
        _bcm_dpp_rx_trap_type_get(unit, FALSE, ppdTrapCode, &found, data);
        if (!found) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_BADID,
                             (_BSL_BCM_MSG_NO_UNIT("unable to get from the PPD trap Code %d (%s) the BCM Trap type"),
                             ppdTrapCode,
                              SOC_PPC_TRAP_CODE_to_string(ppdTrapCode)));
        }
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_LearnSrcMac
 *   Purpose
 *      Set learnt MAC address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which source MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_LearnSrcMac(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_mac_t data,
                                    bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifyLearnSrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_LearnSrcMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyLearnSrcMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LearnSrcMac_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_mac_t *data,
                                        bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifyLearnSrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_ForwardHdrSrcMac
 * Purpose:
 *      Set match criteria for bcmFieldQualifyForwardHdrSrcMac
 *              qualifier in the field entry.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which source MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_ForwardHdrSrcMac(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_mac_t data,
                                    bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifyForwardHdrSrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardHdrSrcMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyForwardHdrSrcMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardHdrSrcMac_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_mac_t *data,
                                        bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifyForwardHdrSrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_ForwardHdrDstMac
 * Purpose:
 *      Set match criteria for bcmFieldQualifyForwardHdrDstMac
 *              qualifier in the field entry.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which source MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_ForwardHdrDstMac(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_mac_t data,
                                    bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifyForwardHdrDstMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}
/*
 * Function:
 *      bcm_petra_field_qualify_ForwardHdrDstMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyForwardHdrDstMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardHdrDstMac_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_mac_t *data,
                                        bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifyForwardHdrDstMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}
/*
 *   Function
 *      bcm_petra_field_qualify_LearnVlan
 *   Purpose
 *      Set learnt VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which VLAN tag (16 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      BCM API docs neglect to metion that this function applies to the entire
 *      tag, rather than just the VID.
 */
int
bcm_petra_field_qualify_LearnVlan(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_vlan_t data,
                                  bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyLearnVlan,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_LearnVlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyLearnVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LearnVlan_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_vlan_t *data,
                                      bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyLearnVlan,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_LearnSrcPort
 * Purpose:
 *       Set match criteria for bcmFieldQualifyLearnSrcPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LearnSrcPort(int unit,
                                     bcm_field_entry_t entry,
                                     bcm_gport_t data)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t mask = ~0;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask));

    /*
     * Limit to 16 bits since it is only Source-System-Port
     * In Jericho, the learn-data has the Arad encoding. Thus edata[18:16] is not correct
     * However, only the 16b of the Source-System-Port are qualified and these bits are not used.
     */
    COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) & 0xFFFF);
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0xFFFF);


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyLearnSrcPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_LearnSrcPort_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyLearnSrcPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LearnSrcPort_get(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_gport_t *data)
{
    uint32 data_lcl;
    uint32 mask;
    bcm_gport_t gport;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyLearnSrcPort,
                                                            &data_lcl,
                                                            &mask));
    *data = 0;

    if (mask) {
        /* Add to data_lcl DSPA encoding per device [18:16]. Under ARAD_SUPPORT*/
        if (SOC_IS_JERICHO(unit))
            data_lcl += ARAD_PP_DEST_ENCODED_PREFIX_TYPE_0001 << 16;
        else
            data_lcl += ARAD_PP_DEST_ENCODED_PREFIX_TYPE_0100 << 16;

        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, data_lcl, &gport),
                            (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), data_lcl));

        *data = gport;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_BypassFilter32
 * Purpose:
 *       Set match criteria for bcmFieldQualifyBypassFilter
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_BypassFilter32(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 data,
                                       uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);

    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, 0);

    /* bit 0 for bypass all, bit 1 for exclude source only */
    if ((mask & BCM_FIELD_FILTER_ALL) == BCM_FIELD_FILTER_ALL) {
        if ((data & BCM_FIELD_FILTER_ALL) == BCM_FIELD_FILTER_ALL) {
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (0x1 << 0));
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (0x1 << 1));
        }
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 0));
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 1));
    }
    if ((mask & BCM_FIELD_FILTER_BYPASS_ALL) == BCM_FIELD_FILTER_BYPASS_ALL) {
        if ((data & BCM_FIELD_FILTER_BYPASS_ALL) == BCM_FIELD_FILTER_BYPASS_ALL) {
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (0x1 << 0));
        }
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 0));
    }
    if ((mask & BCM_FIELD_FILTER_SA_DISABLED) == BCM_FIELD_FILTER_SA_DISABLED) {
        if ((data & BCM_FIELD_FILTER_SA_DISABLED) == BCM_FIELD_FILTER_SA_DISABLED) {
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (0x1 << 1));
        }
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 1));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyBypassFilter,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_BypassFilter32_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyBypassFilter
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_BypassFilter32_get(int unit,
                                           bcm_field_entry_t entry,
                                           uint32 *data,
                                           uint32 *mask)
{
    uint8 edata, emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyBypassFilter,
                                                           &edata,
                                                           &emask));
    *data = 0;
    *mask = 0;

    /* bit 0 for bypass all , bit 1 for exclude source only */
    if (emask & 0x1) {
        if (edata & 0x1) {
            *data += BCM_FIELD_FILTER_BYPASS_ALL;
        }
        *mask += BCM_FIELD_FILTER_BYPASS_ALL;
    }

    if (emask & (0x1 << 1)) {
        if (edata & (0x1 << 1)) {
            *data += BCM_FIELD_FILTER_SA_DISABLED;
        }
        *mask += BCM_FIELD_FILTER_SA_DISABLED;
    }

    if ((emask & 0x1) && (emask & (0x1 << 1))) {
        if ((edata & 0x1) && (edata & (0x1 << 1))) {
            *data += BCM_FIELD_FILTER_ALL;
        }
        *mask += BCM_FIELD_FILTER_ALL;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InVPort32
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInVPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InVPort32(int unit,
                                  bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    uint32 lif;
    int result;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);

    /* Verify if data is in a gport form */
    if (BCM_GPORT_IS_SET(data)) {
        result = _bcm_dpp_field_gport_to_global_lif_convert(unit,
                                                     data,
                                                     TRUE,
                                                     &lif);
        BCMDNX_IF_ERR_EXIT(result);
        COMPILER_64_SET(edata, 0, lif);
    }
    else {
        COMPILER_64_SET(edata, 0, data);
    }
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInVPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OutVPort32
 * Purpose:
 *       Set match criteria for bcmFieldQualifyOutVPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OutVPort32(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 data,
                                   uint32 mask)
{
    uint64 edata;
    uint64 emask;
    uint32 lif;
    int result;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);

    /* Verify if data is in a gport form */
    if (BCM_GPORT_IS_SET(data)) {
        result = _bcm_dpp_field_gport_to_global_lif_convert(unit,
                                                     data,
                                                     FALSE,
                                                     &lif);
        BCMDNX_IF_ERR_EXIT(result);
        COMPILER_64_SET(edata, 0, lif);
    }
    else {
        COMPILER_64_SET(edata, 0, data);
    }

    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOutVPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InVPort32_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInVPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InVPort32_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint32 *data,
                                      uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInVPort,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OutVPort32_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyOutVPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OutVPort32_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 *data,
                                       uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyOutVPort,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_RxTrapData
 * Purpose:
 *       Set match criteria for bcmFieldQualifyRxTrapData
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_RxTrapData(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 data,
                                   uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyRxTrapData,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_RxTrapData_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyRxTrapData
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_RxTrapData_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 *data,
                                       uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyRxTrapData,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_InnerDstMac
 *   Purpose
 *      Set expected inner destination MAC address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which inner destination MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_InnerDstMac(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_mac_t data,
                                    bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifyInnerDstMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDstMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerDstMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDstMac_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_mac_t *data,
                                        bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifyInnerDstMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_InnerSrcMac
 *   Purpose
 *      Set expected inner source MAC address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which inner source MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_InnerSrcMac(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_mac_t data,
                                    bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifyInnerSrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerSrcMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerSrcMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerSrcMac_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_mac_t *data,
                                        bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifyInnerSrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_InnerEtherType
 *   Purpose
 *      Set expected inner ethernet type for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) uint16 data = which ethertype
 *      (in) uint16 mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_InnerEtherType(int unit,
                                       bcm_field_entry_t entry,
                                       uint16 data,
                                       uint16 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerEtherType,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerEtherType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerEtherType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerEtherType_get(int unit,
                                           bcm_field_entry_t entry,
                                           uint16 *data,
                                           uint16 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerEtherType,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 data,
                                   uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel1,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 *data,
                                       uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsLabel1,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1Ttl(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel1Ttl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1Ttl_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel1Ttl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1Bos(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel1Bos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1Bos_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel1Bos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1Exp(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel1Exp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1Exp_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel1Exp,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsLabel1Id
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsForwardingLabelId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsLabel1Id(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 data,
                                     uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel1Id,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsLabel1Id_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsLabel1Id
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsLabel1Id_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 *data,
                                         uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsLabel1Id,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 data,
                                   uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel2,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 *data,
                                       uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsLabel2,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2Ttl(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel2Ttl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2Ttl_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel2Ttl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2Bos(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel2Bos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2Bos_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel2Bos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2Exp(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel2Exp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2Exp_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel2Exp,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsLabel2Id
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsForwardingLabelId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsLabel2Id(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 data,
                                     uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel2Id,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsLabel2Id_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsLabel2Id
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsLabel2Id_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 *data,
                                         uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsLabel2Id,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 data,
                                   uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel3,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 *data,
                                       uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsLabel3,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3Ttl(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel3Ttl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3Ttl_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel3Ttl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3Bos(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel3Bos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3Bos_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel3Bos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3Exp(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel3Exp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3Exp_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel3Exp,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsLabel3Id
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsForwardingLabelId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsLabel3Id(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 data,
                                     uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel3Id,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsLabel3Id_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsLabel3Id
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsLabel3Id_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 *data,
                                         uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsLabel3Id,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Stage
 * Purpose:
 *       Set match criteria for bcmFieldQualifyStage
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *   Internally, the stage value is the index of the proper stage.  It is
 *   converted to the PPD value when committed to the PPD; it is converted to
 *   the BCM value on read from BCM layer.
 */
int
bcm_petra_field_qualify_Stage(int unit,
                              bcm_field_entry_t entry,
                              bcm_field_stage_t data)
{
    bcm_dpp_field_info_OLD_t *unitData;
    uint64 edata;
    uint64 emask;
    unsigned int stage;
    BCMDNX_INIT_FUNC_DEFS;


    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    /* look for a stage that meets the caller's criterion */
    for (stage = 0;
         stage < unitData->devInfo->stages;
         stage++) {
        if (data == _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, stage).bcmStage) {
            /* found the stage the caller wants */
            break;
        }
    }
    if (stage < unitData->devInfo->stages) {
        /* found the expected stage; use it */
        COMPILER_64_SET(edata, 0, stage);
        COMPILER_64_SET(emask, ~0, ~0);
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                                   entry,
                                                                   bcmFieldQualifyStage,
                                                                   1 /* count */,
                                                                   &edata,
                                                                   &emask));
    } else { /* if (stage < unitData->devInfo->stages) */
        /* was unable to find a matching stage */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("stage %s (%d) is not supported"),
                          ((0 < data) && (bcmFieldStageCount > data))?_bcm_dpp_field_stage_name[data]:"-",
                          data));
    } /* if (stage < unitData->devInfo->stages) */
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Stage_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyStage
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *   Internally, the stage value is the index of the proper stage.  It is
 *   converted to the PPD value when committed to the PPD; it is converted to
 *   the BCM value on read from BCM layer.
 */
int
bcm_petra_field_qualify_Stage_get(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_field_stage_t *stage)
{
    bcm_dpp_field_info_OLD_t *unitData;
    uint32 edata;
    uint32 emask;
    BCMDNX_INIT_FUNC_DEFS;


    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!stage) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory OUT argument must not be NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyStage,
                                                            &edata,
                                                            &emask));
    if (!emask) {
        /* the stage qualifier is only valid if it matters, else claim none */
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("entry %d does not have %s (%d) qualifier"),
                          entry,
                          _bcm_dpp_field_qual_name[bcmFieldQualifyStage],
                          bcmFieldQualifyStage));
    }
    if (unitData->devInfo->stages <= edata) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("entry %d stage value inconsistent: %d but"
                                   " max internally allowed value is %d"),
                          entry,
                          edata,
                          unitData->devInfo->stages));
    }
    *stage = _BCM_DPP_FIELD_STAGE_DEV_INFO(unit, edata).bcmStage;
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ArpSenderIp4
 * Purpose:
 *       Set match criteria for bcmFieldQualifyArpSenderIp4
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ArpSenderIp4(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 data,
                                     uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyArpSenderIp4,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ArpSenderIp4_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyArpSenderIp4
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ArpSenderIp4_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 *data,
                                         uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyArpSenderIp4,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ArpTargetIp4
 * Purpose:
 *       Set match criteria for bcmFieldQualifyArpTargetIp4
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ArpTargetIp4(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 data,
                                     uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyArpTargetIp4,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ArpTargetIp4_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyArpTargetIp4
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ArpTargetIp4_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 *data,
                                         uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyArpTargetIp4,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ArpOpcode
 * Purpose:
 *       Set match criteria for bcmFieldQualifyArpOpcode
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ArpOpcode(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_field_ArpOpcode_t data)
{
    uint64 edata;
    uint64 emask;
    uint32 ppdData, mask = (1 << 16) - 1;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_arp_opcode_bcm_to_ppd(data, &ppdData));
    COMPILER_64_SET(edata, 0, ppdData);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyArpOpcode,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ArpOpcode_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyArpOpcode
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ArpOpcode_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_field_ArpOpcode_t *data)
{
    uint32 emask, edata;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyArpOpcode,
                                                            &edata,
                                                            &emask));
    *data = bcmFieldArpOpcodeCount;
    if (emask) {
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_arp_opcode_ppd_to_bcm(edata, data));
    }
    
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_TranslatedOuterVlan
 *   Purpose
 *      Set expected outer VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which VLAN tag (16 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      BCM API docs neglect to metion that this function applies to the entire
 *      tag, rather than just the VID.
 */
int
bcm_petra_field_qualify_TranslatedOuterVlan(int unit,
                                            bcm_field_entry_t entry,
                                            bcm_vlan_t data,
                                            bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedOuterVlan,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedOuterVlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTranslatedOuterVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedOuterVlan_get(int unit,
                                                bcm_field_entry_t entry,
                                                bcm_vlan_t *data,
                                                bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTranslatedOuterVlan,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_TranslatedOuterVlanId
 *   Purpose
 *      Set expected outer VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which VID (12 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_TranslatedOuterVlanId(int unit,
                                              bcm_field_entry_t entry,
                                              bcm_vlan_t data,
                                              bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedOuterVlanId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedOuterVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTranslatedOuterVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedOuterVlanId_get(int unit,
                                                  bcm_field_entry_t entry,
                                                  bcm_vlan_t *data,
                                                  bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTranslatedOuterVlanId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


int bcm_petra_field_qualify_OuterVlanPriCfi(
      int unit,
      bcm_field_entry_t entry,
      uint8 data,
      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterVlanPriCfi,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_field_qualify_OuterVlanPriCfi_get(
      int unit,
      bcm_field_entry_t entry,
      uint8 *data,
      uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOuterVlanPriCfi,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 *   Function
 *      bcm_petra_field_qualify_TranslatedOuterVlanPri
 *   Purpose
 *      Set expected outer VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which Pri (3 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_TranslatedOuterVlanPri(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedOuterVlanPri,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedOuterVlanPri_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTranslatedOuterVlanPri
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedOuterVlanPri_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTranslatedOuterVlanPri,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedOuterVlanCfi
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTranslatedOuterVlanCfi
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedOuterVlanCfi(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedOuterVlanCfi,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedOuterVlanCfi_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTranslatedOuterVlanCfi_get
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedOuterVlanCfi_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTranslatedOuterVlanCfi,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlan
 * Purpose:
 *      Set match criteria for bcmFieldQualifyTranslatedInnerVlan
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlan(int unit,
                                            bcm_field_entry_t entry,
                                            bcm_vlan_t data,
                                            bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedInnerVlan,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTranslatedInnerVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlan_get(int unit,
                                                bcm_field_entry_t entry,
                                                bcm_vlan_t *data,
                                                bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTranslatedInnerVlan,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlanId
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTranslatedInnerVlanId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlanId(int unit,
                                              bcm_field_entry_t entry,
                                              bcm_vlan_t data,
                                              bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedInnerVlanId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTranslatedInnerVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlanId_get(int unit,
                                                  bcm_field_entry_t entry,
                                                  bcm_vlan_t *data,
                                                  bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTranslatedInnerVlanId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlanPri
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTranslatedInnerVlanPri
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlanPri(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedInnerVlanPri,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlanPri_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTranslatedInnerVlanPri
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlanPri_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTranslatedInnerVlanPri,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlanCfi
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTranslatedInnerVlanCfi
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlanCfi(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedInnerVlanCfi,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlanCfi_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTranslatedInnerVlanCfi
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlanCfi_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTranslatedInnerVlanCfi,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardingHeaderOffset
 * Purpose:
 *       Set match criteria for bcmFieldQualifyForwardingHeaderOffset
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      base_header - (IN) Qualifier base header.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardingHeaderOffset(int unit,
                                               bcm_field_entry_t entry,
                                               bcm_field_data_offset_base_t base_header,
                                               uint32 data,
                                               uint32 mask)
{
    uint64 edata;
    uint64 emask;
    uint32 data_u32[2] = {0, 0};
    uint32 mask_u32[2] = {0, 0};
    uint32 ppd_base_header, ppd_base_header_mask = (~0);
    unsigned int count = 1;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    /* Get the correct ppd base header */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_base_header_bcm_to_ppd(base_header, &ppd_base_header));
    SHR_BITCOPY_RANGE(data_u32, (8*6) /* Size of the Offset-headers */, &ppd_base_header, 0, 3 /* copy 3 bits */);
    SHR_BITCOPY_RANGE(mask_u32, (8*6) /* Size of the Offset-headers */, &ppd_base_header_mask, 0, 3 /* copy 3 bits */);
    /* Set the correct offset accordingly */
    SHR_BITCOPY_RANGE(data_u32, (8 * ppd_base_header), &data, 0, 7 /* copy 7 bits */);
    SHR_BITCOPY_RANGE(mask_u32, (8 * ppd_base_header), &mask, 0, 7 /* copy 7 bits */);

    /* Set the 64b values */
    COMPILER_64_SET(edata, data_u32[1], data_u32[0]);
    COMPILER_64_SET(emask, mask_u32[1], mask_u32[0]);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyForwardingHeaderOffset,
                                                               count,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardingHeaderOffset_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyForwardingHeaderOffset
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      base_header - (OUT) Qualifier base header.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardingHeaderOffset_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   bcm_field_data_offset_base_t *base_header,
                                                   uint32 *data,
                                                   uint32 *mask)
{
    uint64 edata, emask;
    uint32 ppd_base_header = 0, ppd_base_header_mask = 0;
    uint32 data_u32[2] = {0, 0};
    uint32 mask_u32[2] = {0, 0};

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyForwardingHeaderOffset,
                                                            &edata,
                                                            &emask));
    data_u32[0] = COMPILER_64_LO(edata);
    data_u32[1] = COMPILER_64_HI(edata);
    mask_u32[0] = COMPILER_64_LO(emask);
    mask_u32[1] = COMPILER_64_HI(emask);
    /* Get the header-offset mask */
    SHR_BITCOPY_RANGE(&ppd_base_header_mask, 0, mask_u32, (8*6) /* Size of the Offset-headers */, 3 /* copy 3 bits */);
    SHR_BITCOPY_RANGE(&ppd_base_header, 0, data_u32, (8*6) /* Size of the Offset-headers */, 3 /* copy 3 bits */);

    *data = 0;
    *mask = 0;
    if (ppd_base_header_mask) {
        /* Get the Base-header */
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_base_header_ppd_to_bcm(ppd_base_header, base_header));

        /* Get the data and value */
        SHR_BITCOPY_RANGE(data, 0, data_u32, (8 * ppd_base_header), 7 /* copy 7 bits */);
        SHR_BITCOPY_RANGE(mask, 0, mask_u32, (8 * ppd_base_header), 7 /* copy 7 bits */);
    }
    else {
        /* Not valid */
        *base_header = bcmFieldDataOffsetBaseCount;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_IngressVPortBridgeDisable
 * Purpose:
 *      Set match criteria for bcmFieldQualifyIngressVPortBridgeDisable
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IngressVPortBridgeDisable(int unit,
                                              bcm_field_entry_t entry,
                                              uint8 data,
                                              uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIngressVPortBridgeDisable,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_IngressVPortBridgeDisable
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIngressVPortBridgeDisable
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IngressVPortBridgeDisable_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 *data,
                                      uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIngressVPortBridgeDisable,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalHit0
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalHit0
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit0(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalHit0,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalHit0
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalHit0
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit0_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExternalHit0,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalHit1
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalHit1
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit1(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalHit1,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalHit1
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalHit1
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit1_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExternalHit1,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalHit2
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalHit2
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit2(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalHit2,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalHit2
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalHit2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit2_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExternalHit2,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalHit3
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalHit3
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit3(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalHit3,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalHit3
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalHit3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit3_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExternalHit3,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalHit4
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalHit4
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit4(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalHit4 is not supported on that device!!")));
	}

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalHit4,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalHit4
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalHit4
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit4_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalHit4 is not supported on that device!!")));
	}

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExternalHit4,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalHit5
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalHit5
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit5(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalHit5 is not supported on that device!!")));
	}

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalHit5,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalHit5
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalHit5
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit5_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalHit5 is not supported on that device!!")));
	}

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExternalHit5,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_ExternalHit6
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalHit6
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit6(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)
#if defined(INCLUDE_KBP)
        || !(ARAD_KBP_IS_OP_OR_OP2)
#endif
    ) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalHit6 is not supported on that device!!")));
	}

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalHit6,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_ExternalHit6
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalHit6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit6_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)
#if defined(INCLUDE_KBP)
        || !(ARAD_KBP_IS_OP_OR_OP2)
#endif
    ) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalHit6 is not supported on that device!!")));
	}

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExternalHit6,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_ExternalHit7
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalHit7
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit7(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)
#if defined(INCLUDE_KBP)
        || !(ARAD_KBP_IS_OP_OR_OP2)
#endif
    ) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalHit7 is not supported on that device!!")));
	}

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalHit7,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_ExternalHit7
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalHit7
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit7_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)
#if defined(INCLUDE_KBP)
        || !(ARAD_KBP_IS_OP_OR_OP2)
#endif
    ) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalHit7 is not supported on that device!!")));
	}

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExternalHit7,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue0
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalValue0
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue0(int unit,
                                     bcm_field_entry_t entry,
                                     uint64 data,
                                     uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalValue0,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue0
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalValue0
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue0_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 *data,
                                         uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyExternalValue0,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalValue1
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalValue1
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue1(int unit,
                                     bcm_field_entry_t entry,
                                     uint64 data,
                                     uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalValue1,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue1
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalValue1
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue1_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 *data,
                                         uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyExternalValue1,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalValue2
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalValue2
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue2(int unit,
                                     bcm_field_entry_t entry,
                                     uint64 data,
                                     uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalValue2,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue2
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalValue2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue2_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 *data,
                                         uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyExternalValue2,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalValue3
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalValue3
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue3(int unit,
                                     bcm_field_entry_t entry,
                                     uint64 data,
                                     uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalValue3,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue3
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalValue3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue3_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 *data,
                                         uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyExternalValue3,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue4
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalValue4
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue4(int unit,
                                     bcm_field_entry_t entry,
                                     uint64 data,
                                     uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalValue4 is not supported on that device!!")));
	}

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalValue4,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue4
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalValue4
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue4_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 *data,
                                         uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalValue4 is not supported on that device!!")));
	}

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyExternalValue4,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalValue5
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalValue5
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue5(int unit,
                                     bcm_field_entry_t entry,
                                     uint64 data,
                                     uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalValue5 is not supported on that device!!")));
	}

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalValue5,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue5
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalValue5
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue5_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 *data,
                                         uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalValue5 is not supported on that device!!")));
	}

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyExternalValue5,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue6
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalValue6
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue6(int unit,
                                     bcm_field_entry_t entry,
                                     uint64 data,
                                     uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)
#if defined(INCLUDE_KBP)
        || !(ARAD_KBP_IS_OP_OR_OP2)
#endif
    ) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalValue6 is not supported on that device!!")));
	}

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalValue6,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue6
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalValue6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue6_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 *data,
                                         uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)
#if defined(INCLUDE_KBP)
        || !(ARAD_KBP_IS_OP_OR_OP2)
#endif
    ) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalValue6 is not supported on that device!!")));
	}

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyExternalValue6,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_ExternalValue7
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalValue7
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue7(int unit,
                                     bcm_field_entry_t entry,
                                     uint64 data,
                                     uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)
#if defined(INCLUDE_KBP)
        || !(ARAD_KBP_IS_OP_OR_OP2)
#endif
    ) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalValue7 is not supported on that device!!")));
	}

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalValue7,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue7
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalValue7
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue7_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 *data,
                                         uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

	if (SOC_IS_ARADPLUS_AND_BELOW(unit)
#if defined(INCLUDE_KBP)
        || !(ARAD_KBP_IS_OP_OR_OP2)
#endif
    ) {
		BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Qualifier ExternalValue7 is not supported on that device!!")));
	}

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyExternalValue7,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/* 
 * Special case of profile management: 
 * due to missing AppType-bitmap qualifier, the user can:
 *  1. Set the AppType of each entry
 *  2. Adding an AppType to an entry, if the entry is the single instance having this profile
 *  and this AppType is not used by another entry
 *  3. A second entry should be able to get the same profile than an existing entry
 * The sequence is:
 *  1. If the entry has a non-zero profile,
 *  - if the AppType is already part of the bitmap, do nothing and exit.
 *  - look at the refCount it is the single entry with this profile, destroy this profile and create a new one.
 *  - otherwise return error
 *  2. If the entry has a profile 0 (non allocated), and it is the first time this AppType is used,
 *  add the AppType with creation of a new profile, similarly to bcmFieldQualifyInPort
 *  3. If the entry has a profile 0 (non allocated), and it is not the first time this AppType is used,
 *  attach this entry to the profile of this AppType. Automatically, all the AppTypes of these profiles are attached
 *  to the entry. It is the user's responsiblity to track the profiles
 */
/* bcm_field_qualify_AppType */
int bcm_petra_field_qualify_AppType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_AppType_t type)
{
    uint64 edata;
    uint64 emask;
    _bcm_dpp_core_ports_bitmap_t flp_pgm_id_bitmap[MAX_NUM_OF_CORES]; /* Sufficient for the number of FLP programs */
    uint32 ppd_flp_program, profile_idx;
    uint32 tdata;
    bcm_dpp_field_info_OLD_t *tempData = _bcm_dpp_field_unit_info[unit];
    _bcm_dpp_field_profile_type_t profile_type = _bcmDppFieldProfileTypeFlpProgramProfile;
    uint64 profile;
    int  nof_cores, core;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    _bcm_dpp_clear_core_ports(MAX_NUM_OF_CORES, flp_pgm_id_bitmap );

    /* Convert AppType to HW number */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_app_type_bcm_to_ppd(unit, type, &ppd_flp_program));

    /* Retrieve the FLP-Program-bitmap of this entry */
    /* Get the current profile */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_entry_profile_get(tempData, profile_type, entry, &profile));

    tdata = COMPILER_64_LO(profile);
    if (COMPILER_64_IS_ZERO(profile)) {
        for(profile_idx = 1; profile_idx < _BCM_DPP_PRESEL_NOF_PORT_PROFILES; profile_idx++) 
        {
            BCMDNX_IF_ERR_EXIT(
                _bcm_dpp_field_presel_port_profile_get(unit,
                                                       profile_type,
                                                       profile_idx,
                                                       &nof_cores,
                                                       flp_pgm_id_bitmap));
            /* All cores configured identically, Look at first one*/
            if (SHR_BITGET(flp_pgm_id_bitmap[0], ppd_flp_program)) {
                /* Existing profile found */
                break;
            }
            /* If not found, zero the bitmap */
            _bcm_dpp_clear_core_ports(MAX_NUM_OF_CORES, flp_pgm_id_bitmap );

        }
    }
    else {
        unsigned int preselProfileRefs_element ;
        /*
         *  Was:
         *    tempData->preselProfileRefs[profile_type][tdata]
         */
        BCMDNX_IF_ERR_EXIT(FIELD_ACCESS_PRESELPROFILEREFS.get(unit, profile_type, tdata, &preselProfileRefs_element)) ;

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                               profile_type,
                                                               tdata,
                                                               &nof_cores,
                                                               flp_pgm_id_bitmap));
        if (SHR_BITGET(flp_pgm_id_bitmap[0], ppd_flp_program)) {
            /* Do nothing and exit */
            goto exit;
        }
        else if (preselProfileRefs_element == 1) {
            /* Clear the entry profile */
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_clear_type(tempData, profile_type, entry));
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d does not support different set of profiles"
                                               "for qualifier %d (%s)\n"),
                              unit,
                              bcmFieldQualifyAppType,
                              _bcm_dpp_field_qual_name[bcmFieldQualifyAppType]));

        }
    }

    /* Set the bitmap with the new type, update all cores.*/
    for (core=0; core<nof_cores; core++) {
        SHR_BITSET(flp_pgm_id_bitmap[core], ppd_flp_program);
    }

    /* Set the new HW profile */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_set(unit,
                                                           _bcmDppFieldProfileTypeFlpProgramProfile,
                                                           nof_cores,
                                                           flp_pgm_id_bitmap, 
                                                           &edata));
    COMPILER_64_SET(emask,0, 0x7);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyAppType,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/* 
 * Special case of profile management: 
 * due to missing AppType-bitmap qualifier, the user can get only 
 * a single AppType of the bitmap 
 */ 
/* 
 * Get match criteria for bcmFieldQualifyAppType
 *                qualifier from the field entry.
 */
int bcm_petra_field_qualify_AppType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_AppType_t *type)
{
    uint32 tdata;
    uint32 tmask;
    uint32 
        flp_pgm_id;
    int nof_cores;

    _bcm_dpp_core_ports_bitmap_t  flp_pgm_id_bitmap[MAX_NUM_OF_CORES];

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyAppType,
                                                            &tdata,
                                                            &tmask));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                           _bcmDppFieldProfileTypeFlpProgramProfile,
                                                           tdata,
                                                           &nof_cores, 
                                                           flp_pgm_id_bitmap));

    for (flp_pgm_id = 0; flp_pgm_id < SOC_DPP_DEFS_GET(unit, nof_flp_programs); flp_pgm_id++) {
        
        if(SHR_BITGET(flp_pgm_id_bitmap[0], flp_pgm_id)) {
            break;
        }
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_app_type_ppd_to_bcm(unit, flp_pgm_id, type));

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MirrorEgressDisabled
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMirrorEgressDisabled
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MirrorEgressDisabled(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 data,
                                             uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMirrorEgressDisabled,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_EMirrorEgressDisabled_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMirrorEgressDisabled
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MirrorEgressDisabled_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMirrorEgressDisabled,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_BypassSrcMacFilter
 * Purpose:
 *      Set match criteria for BypassSrcMacFilter qualifier
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_BypassSrcMacFilter(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyBypassSrcMacFilter,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_BypassSrcMacFilter
 * Purpose:
 *      Get match criteria for BypassSrcMacFilter qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_BypassSrcMacFilter_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyBypassSrcMacFilter,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_RxTrapCodeForSnoop
 * Purpose:
 *      Set match criteria for RxTrapCodeForSnoop qualifier
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_RxTrapCodeForSnoop(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyRxTrapCodeForSnoop,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_RxTrapCodeForSnoop_get
 * Purpose:
 *      Get match criteria for RxTrapCodeForSnoop qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_RxTrapCodeForSnoop_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyRxTrapCodeForSnoop,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_IpmcStarGroupValue
 * Purpose:
 *      Set match criteria for IpmcStarGroupValue qualifier
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpmcStarGroupValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_IpmcStarGroupValue not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_IpmcStarGroupValue_get
 * Purpose:
 *      Get match criteria for IpmcStarGroupValue qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_IpmcStarGroupValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_IpmcStarGroupValue_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_NativeVSwitch
 * Purpose:
 *      Set match criteria for NativeVSwitch qualifier
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_NativeVSwitch(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyNativeVSwitch,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;

}

/*
 * Function:
 *      bcm_field_qualify_NativeVSwitch_get
 * Purpose:
 *      Get match criteria for NativeVSwitch qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_NativeVSwitch_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    uint32 emask;
    uint32 edata;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyNativeVSwitch,
                                                            &edata,
                                                            &emask));
    *mask = emask & 0xFFFF;
    *data = edata & 0xFFFF;
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_NativeVSwitchValid
 * Purpose:
 *      Set match criteria for NativeVSwitchValid qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_NativeVSwitchValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_NativeVSwitchValid not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_NativeVSwitchValid_get
 * Purpose:
 *      Get match criteria for NativeVSwitchValid qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
int 
bcm_petra_field_qualify_NativeVSwitchValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_NativeVSwitchValid_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillIVersion
 * Purpose:
 *      Set match criteria for TrillIVersion qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillIVersion(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillIVersion not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillIVersion_get
 * Purpose:
 *      Get match criteria for TrillIVersion qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillIVersion_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillIVersion_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillIngressRbridge
 * Purpose:
 *      Set match criteria for TrillIngressRbridge qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillIngressRbridge(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillIVersion_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillIngressRbridge_get
 * Purpose:
 *      Get match criteria for TrillIngressRbridge qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillIngressRbridge_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillIVersion_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_TrillMultiDestination
 * Purpose:
 *      Set match criteria for TrillMultiDestination qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillMultiDestination(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillMultiDestination not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillMultiDestination_get
 * Purpose:
 *      Get match criteria for TrillMultiDestination qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TrillMultiDestination_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillMultiDestination_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillMultiDestination
 * Purpose:
 *      Set match criteria for TrillMultiDestination qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillOpLength(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillOpLength not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_TrillOpLength_get
 * Purpose:
 *      Get match criteria for TrillOpLength qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillOpLength_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillOpLength not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillHopCount
 * Purpose:
 *      Set match criteria for TrillHopCount qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillHopCount(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillOpLength not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillHopCount_get
 * Purpose:
 *      Get match criteria for TrillHopCount qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillHopCount_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillHopCount_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillPayload
 * Purpose:
 *      Set match criteria for TrillPayload qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillPayload(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillPayload not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillPayload_get
 * Purpose:
 *      Get match criteria for TrillPayload qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillPayload_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillPayload_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_MplsForwardingLabelPayload
 * Purpose:
 *      Set match criteria for MplsForwardingLabelPayload qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_MplsForwardingLabelPayload(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_MplsForwardingLabelPayload not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}
/*
 * Function:
 *      bcm_field_qualify_MplsForwardingLabelPayload_get
 * Purpose:
 *      Get match criteria for MplsForwardingLabelPayload qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_MplsForwardingLabelPayload_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_MplsForwardingLabelPayload_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_IncomingIpIfClass
 * Purpose:
 *      Set match criteria for IncomingIpIfClass qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

extern int bcm_petra_field_qualify_IncomingIpIfClass(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;


    if ( !SOC_IS_JERICHO(unit) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_petra_field_qualify_IncomingIpIfClass supported in JERICHO and above\n\r")));
    }

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIncomingIpIfClass,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_IncomingIpIfClass_get
 * Purpose:
 *      Get match criteria for IncomingIpIfClass qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

extern int bcm_petra_field_qualify_IncomingIpIfClass_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
 {
    BCMDNX_INIT_FUNC_DEFS;

    if ( !SOC_IS_JERICHO(unit) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_petra_field_qualify_IncomingIpIfClass_get supported in JERICHO and above\n\r")));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                         entry,
                                                         bcmFieldQualifyIncomingIpIfClass,
                                                         data,
                                                         mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
  _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
  BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_L2GreProtocolType
 * Purpose:
 *      Set match criteria for L2GreProtocolType qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_L2GreProtocolType(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_L2GreProtocolType not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_L2GreProtocolType_get
 * Purpose:
 *      Get match criteria for L2GreProtocolType qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_L2GreProtocolType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_L2GreProtocolType_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_L2GreVsid
 * Purpose:
 *      Set match criteria for L2GreVsid qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_L2GreVsid(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_L2GreVsid not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_L2GreVsid_get
 * Purpose:
 *      Get match criteria for L2GreVsid qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_L2GreVsid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_L2GreVsid_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_L2GreFlowId
 * Purpose:
 *      Set match criteria for L2GreFlowId qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_L2GreFlowId(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_L2GreFlowId not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_L2GreFlowId_get
 * Purpose:
 *      Get match criteria for L2GreFlowId qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_L2GreFlowId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_L2GreFlowId_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_MimVlanPri
 * Purpose:
 *      Set match criteria for MimVlanPri qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_MimVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_MimVlanPri not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_MimVlanPri_get
 * Purpose:
 *      Get match criteria for MimVlanPri qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_MimVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_MimVlanPri_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_MimVlanCfi
 * Purpose:
 *      Set match criteria for MimVlanCfi qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_MimVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_MimVlanCfi not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_MimVlanCfi_get
 * Purpose:
 *      Get match criteria for MimVlanCfi qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_MimVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_MimVlanCfi_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_Fhei
 * Purpose:
 *      Set match criteria for Fhei qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_Fhei(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyFhei,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_Fhei_get
 * Purpose:
 *      Get match criteria for Fhei qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_Fhei_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyFhei,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_FheiSize
 * Purpose:
 *      Set match criteria for FheiSize qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_FheiSize(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    if (!(_BCM_DPP_FIELD_FHEI_SIZE_VALID(data)))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Fhei Size not valid")));
    }
    if (data == _BCM_DPP_FIELD_FHEI_SIZE_0_BYTES)
    {
        COMPILER_64_SET(edata, 0, 0);
    }
    else 
    {
        COMPILER_64_SET(edata, 0, ((data == _BCM_DPP_FIELD_FHEI_SIZE_3_BYTES)? 1: ((data == _BCM_DPP_FIELD_FHEI_SIZE_5_BYTES)? 2: 3)));
    }

    if ((0 != mask)  && ((~0) != mask)) {
        /* neither ignore nor exact match */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("FHEI size %d only supports all or"
                                   " nothing mask (all bits set or all"
                                   " bits clear clear)"),
                          data));
    }

    if (0 != mask)
    {
       COMPILER_64_SET(emask, 0, 0x3);
    }
    else 
    {
       COMPILER_64_SET(emask, 0, 0);
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyFheiSize,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_FheiSize_get
 * Purpose:
 *      Get match criteria for FheiSize qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_FheiSize_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    uint32 soc_data;
    uint32 soc_mask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyFheiSize,
                                                            &soc_data,
                                                            &soc_mask));
    if ( soc_data == 0) 
    {
       *data =  _BCM_DPP_FIELD_FHEI_SIZE_0_BYTES ;
    }
    else 
    {
       *data = ((soc_data == 1)? _BCM_DPP_FIELD_FHEI_SIZE_3_BYTES: ((soc_data == 2)? _BCM_DPP_FIELD_FHEI_SIZE_5_BYTES: _BCM_DPP_FIELD_FHEI_SIZE_8_BYTES));
    }
    *mask = (soc_mask == 0) ? 0: (~0) ; 
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_OuterVlanActionRange
 * Purpose:
 *      Set match criteria for OuterVlanActionRange qualifier. 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_OuterVlanActionRange (
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{

    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterVlanActionRange,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;

}
/*
 * Function:
 *      bcm_field_qualify_OuterVlanActionRange_get
 * Purpose:
 * Get match criteria for OuterVlanActionRange qualifier. 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_OuterVlanActionRange_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyOuterVlanActionRange,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_InnerVlanActionRange
 * Purpose:
 *      Set match criteria for InnerVlanActionRange qualifier. 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_InnerVlanActionRange (
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{

    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerVlanActionRange,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;

}
/*
 * Function:
 *      bcm_field_qualify_InnerVlanActionRange_get
 * Purpose:
 * Get match criteria for InnerVlanActionRange qualifier. 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_InnerVlanActionRange_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerVlanActionRange,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ClassId
 * Purpose:
 *      Set match criteria for ClassId qualifier. 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_ClassId (
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{

    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyClassId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;

}
/*
 * Function:
 *      bcm_field_qualify_ClassId_get
 * Purpose:
 * Get match criteria for ClassId qualifier. 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_ClassId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyClassId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_LearnInVPort
 * Purpose:
 *      Set match criteria for LearnInVPort qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_LearnInVPort(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);

    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);



    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyLearnInVPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_LearnInVPort_get
 * Purpose:
 *      Get match criteria for LearnInVPort qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_LearnInVPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyLearnInVPort,
                                                            data,
                                                            mask));
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_LearnExtension
 * Purpose:
 *      Set enable  criteria for LearnExtension qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      enable - (IN) Qualifier enable status data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LearnExtension(
    int unit,
    bcm_field_entry_t entry,
    uint8 enable)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, enable);
    COMPILER_64_SET(emask, 0, 0xF);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyLearnExtension,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;

}
/*
 * Function:
 *      bcm_petra_field_qualify_LearnExtension_get
 * Purpose:
 *      Get enable criteria for LearnExtension qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      enable - (OUT) Qualifier enable status data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LearnExtension_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *enable)
{
    int32 data;
    int32 mask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyLearnExtension,
                                                           &data,
                                                           &mask));

    *enable = data;

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_StackingRoute
 * Purpose:
 *      Set match criteria for StackingRoute qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_StackingRoute(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyStackingRoute,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_StackingRoute_get
 * Purpose:
 *      Get match criteria for StackingRoute qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_StackingRoute_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyStackingRoute ,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_DstSysPortExt
 * Purpose:
 *      Set match criteria for DstSysPortExt qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_DstSysPortExt(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstSysPortExt,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_DstSysPortExt_get
 * Purpose:
 *      Get match criteria for DstSysPortExt qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_DstSysPortExt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                           entry,
                                                           bcmFieldQualifyDstSysPortExt ,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_RxTrapCode32
 * Purpose:
 *      Set match criteria for RxTrapCode qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_RxTrapCode32(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    uint32 group_flags = 0;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));

    if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) 
    {
        COMPILER_64_SET(edata, 0, data);
        COMPILER_64_SET(emask, 0, mask);
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                                   entry,
                                                                   bcmFieldQualifyRxTrapCode,
                                                                   1 /* count */,
                                                                   &edata,
                                                                   &emask));
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                 (_BSL_BCM_MSG("Non-supported Field group stage with Field group flags %d \n"),
                  group_flags));
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_RxTrapCode32_get
 * Purpose:
 *      Get match criteria for RxTrapCode qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_RxTrapCode32_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    uint32 group_flags = 0;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));

    if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) 
    {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyRxTrapCode,
                                                            data,
                                                            mask));
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                 (_BSL_BCM_MSG("Non-supported Field group stage with Field group flags %d \n"),
                  group_flags));
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_RxTrapStrength
 * Purpose:
 *      Set match criteria for RxTrapStrength qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_RxTrapStrength(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    uint64 edata;
    uint64 emask;

    BCMDNX_INIT_FUNC_DEFS;

    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyRxTrapStrength,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_RxTrapStrength_get
 * Purpose:
 *      Get match criteria for RxTrapStrength qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_RxTrapStrength_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyRxTrapStrength,
                                                           data,
                                                           mask));

exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamInLifIdValid
 * Purpose:
 *      Set match criteria for OamInLifIdValid qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */




int
bcm_petra_field_qualify_OamInLifIdValid(int unit,
                                         bcm_field_entry_t entry,
                                             uint8 data,
                                            uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamInLifIdValid,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamInLifIdValid_get
* Purpose:
* Get match criteria for OamInLifIdValid qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamInLifIdValid_get(int unit,
                                             bcm_field_entry_t entry,
                                               uint8 *data,
                                               uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamInLifIdValid,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamInLifId
 * Purpose:
 *      Set match criteria for OamInLifId qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamInLifId(int unit,
                                    bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamInLifId ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamInLifId_get
* Purpose:
* Get match criteria for OamInLifId qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamInLifId_get(int unit,
                                        bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                            bcmFieldQualifyOamInLifId,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_OamUpMep
 * Purpose:
 *      Set match criteria for OamUpMep qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamUpMep(int unit,
                                  bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamUpMep,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
* Function:
* bcm_field_qualify_OamUpMep_get
* Purpose:
* Get match criteria for OamUpMep qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamUpMep_get(int unit,
                                      bcm_field_entry_t entry,
                                               uint8 *data,
                                               uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamUpMep,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamSubtype
 * Purpose:
 *      Set match criteria for OamSubtype qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamSubtype(int unit,
                                    bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamSubtype ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamSubtype_get
* Purpose:
* Get match criteria for OamSubtype qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/


int
bcm_petra_field_qualify_OamSubtype_get(int unit,
                                        bcm_field_entry_t entry,
                                               uint8 *data,
                                               uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                          bcmFieldQualifyOamSubtype ,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamHeaderOffset
 * Purpose:
 *      Set match criteria for OamHeaderOffset qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamHeaderOffset(int unit,
                                         bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamHeaderOffset,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamHeaderOffset_get
* Purpose:
* Get match criteria for OamHeaderOffset qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/


int
bcm_petra_field_qualify_OamHeaderOffset_get(int unit,
                                             bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamHeaderOffset,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamStampOffset
 * Purpose:
 *      Set match criteria for OamStampOffset qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamStampOffset(int unit,
                                    bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamStampOffset,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
* Function:
* bcm_field_qualify_OamStampOffset_get
* Purpose:
* Get match criteria for OamStampOffset qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/


int
bcm_petra_field_qualify_OamStampOffset_get(int unit,
                                            bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamStampOffset,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamMepId
 * Purpose:
 *      Set match criteria for OamMepId qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamMepId(int unit,
                                  bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamMepId ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamMepId_get
* Purpose:
* Get match criteria for OamMepId qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamMepId_get(int unit,
                                      bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamMepId ,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_OamMeterDisable
 * Purpose:
 *      Set match criteria for OamMeterDisable qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamMeterDisable(int unit,
                                         bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamMeterDisable,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamMeterDisable_get
* Purpose:
* Get match criteria for OamMeterDisable qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamMeterDisable_get(int unit,
                                             bcm_field_entry_t entry,
                                               uint8 *data,
                                               uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamMeterDisable,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_OamTsSystemHeader
 * Purpose:
 *      Set match criteria for OamTsSystemHeader qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamTsSystemHeader(int unit,
                                  bcm_field_entry_t entry,
                                  uint64 data,
                                  uint64 mask)
{

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamTsSystemHeader,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
* Function:
* bcm_field_qualify_OamTsSystemHeader_get
* Purpose:
* Get match criteria for OamTsSystemHeader qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/


int
bcm_petra_field_qualify_OamTsSystemHeader_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint64 *data,
                                               uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamTsSystemHeader,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_EthernetOamHeaderBits0_31
 * Purpose:
 *      Set match criteria for EthernetOamHeaderBits0_31 qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_EthernetOamHeaderBits0_31(int unit,
                                     bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyEthernetOamHeaderBits0_31 ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_EthernetOamHeaderBits0_31_get
* Purpose:
* Get match criteria for EthernetOamHeaderBits0_31 qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_EthernetOamHeaderBits0_31_get(int unit,
                                              bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                            bcmFieldQualifyEthernetOamHeaderBits0_31,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_EthernetOamHeaderBits32_63
 * Purpose:
 *      Set match criteria for EthernetOamHeaderBits32_63 qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_EthernetOamHeaderBits32_63(int unit,
                                     bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyEthernetOamHeaderBits32_63 ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
* Function:
* bcm_field_qualify_EthernetOamHeaderBits32_63_get
* Purpose:
* Get match criteria for EthernetOamHeaderBits32_63 qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_EthernetOamHeaderBits32_63_get(int unit,
                                            bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                            bcmFieldQualifyEthernetOamHeaderBits32_63,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_MplsOamHeaderBits0_31
 * Purpose:
 *      Set match criteria for MplsOamHeaderBits0_31 qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsOamHeaderBits0_31(int unit,
                                   bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsOamHeaderBits0_31 ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_MplsOamHeaderBits0_31_get
* Purpose:
* Get match criteria for MplsOamHeaderBits0_31 qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_MplsOamHeaderBits0_31_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsOamHeaderBits0_31,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_MplsOamHeaderBits32_63
 * Purpose:
 *      Set match criteria for MplsOamHeaderBits32_63 qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsOamHeaderBits32_63(int unit,
                                 bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsOamHeaderBits32_63 ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_MplsOamHeaderBits32_63_get
* Purpose:
* Get match criteria for MplsOamHeaderBits32_63 qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_MplsOamHeaderBits32_63_get(int unit,
                                                bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                             bcmFieldQualifyMplsOamHeaderBits32_63,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_MplsOamACH
 * Purpose:
 *      Set match criteria for MplsOamACH qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsOamACH(int unit,
                                 bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsOamACH ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_MplsOamACH_get
* Purpose:
* Get match criteria for MplsOamACH qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_MplsOamACH_get(int unit,
                                        bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                            bcmFieldQualifyMplsOamACH,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_OamHeaderBits0_31
 * Purpose:
 *      Set match criteria for OamHeaderBits0_31 qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamHeaderBits0_31(int unit,
                                   bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamHeaderBits0_31,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamHeaderBits0_31_get
* Purpose:
* Get match criteria for OamHeaderBits0_31 qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamHeaderBits0_31_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamHeaderBits0_31,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE_NO_SANITY_CHECK(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamHeaderBits32_63
 * Purpose:
 *      Set match criteria for OamHeaderBits32_63 qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamHeaderBits32_63(int unit,
                                    bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamHeaderBits32_63,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
* Function:
* bcm_field_qualify_OamHeaderBits32_63_get
* Purpose:
* Get match criteria for OamHeaderBits32_63 qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamHeaderBits32_63_get(int unit,
                                                bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                            bcmFieldQualifyOamHeaderBits32_63,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE_NO_SANITY_CHECK(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 *   Function
 *      bcm_petra_field_qualify_InterfaceInPorts
 *   
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_pbmp_t data = allowed ports
 *      (in) bcm_pbmp_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_InterfaceInPorts(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_pbmp_t data,
                                 bcm_pbmp_t mask)
{

   uint64 edata;
    uint64 emask;

    uint32
        port_id,
        fld_val;
    uint32 pp_port;
    _bcm_dpp_core_ports_bitmap_t port_bitmap[MAX_NUM_OF_CORES]; 
    int    core, nof_cores;
    uint32 is_valid;
    uint32 max_port =  _BCM_DPP_NOF_LOCAL_PORTS(unit);
        
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);
    _bcm_dpp_clear_core_ports(nof_cores, port_bitmap);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        /*
         * Check all the ports are masked and copy their
         * membership in data to the array
         */
        for (port_id = 0; port_id < max_port ; port_id++) {
            if (!BCM_PBMP_MEMBER(mask, port_id)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG("only supports all masked (all"
                                           " bits set in mask)")));
            }

            /* Copy the port bit */
            fld_val = BCM_PBMP_MEMBER(data, port_id);

            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

            if (fld_val) {
                if (is_valid) {
                    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));
                    SHR_BITCOPY_RANGE(port_bitmap[core], pp_port, &fld_val, 0, 1);
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Invalid port")));
                }
            }
        }

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_set(unit,
                                                               _bcmDppFieldProfileTypeInterfaceInPort,
                                                               nof_cores,
                                                               port_bitmap, 
                                                               &edata));
        COMPILER_64_SET(emask, 0, 0x7);
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                                   entry,
                                                                  bcmFieldQualifyInterfaceInPorts,
                                                                   1 /* count */,
                                                                   &edata,
                                                                   &emask));
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;

}


/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceInPorts_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInterfaceInPorts
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceInPorts_get(int unit,
                                     bcm_field_entry_t entry,
                                     bcm_pbmp_t *data,
                                     bcm_pbmp_t *mask)
{
    
    uint32 tdata;
    uint32 tmask;
    uint32 
        port_id, pp_port;
    _bcm_dpp_core_ports_bitmap_t  port_bitmap[MAX_NUM_OF_CORES];
    int                   core, nof_cores; 
    uint32                is_valid;
    uint32                max_port = _BCM_DPP_NOF_LOCAL_PORTS(unit);

    BCMDNX_INIT_FUNC_DEFS;

    _bcm_dpp_clear_core_ports(MAX_NUM_OF_CORES, port_bitmap);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                                entry,
                                                                bcmFieldQualifyInterfaceInPorts,
                                                                &tdata,
                                                                &tmask));

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                               _bcmDppFieldProfileTypeInterfaceInPort,
                                                               tdata,
                                                               &nof_cores,
                                                               port_bitmap));
        BCM_PBMP_CLEAR(*data);
        BCM_PBMP_CLEAR(*mask);
        for (port_id = 0; port_id < max_port; port_id++) {
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

			if (is_valid) {

				BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));

				if(SHR_BITGET(port_bitmap[core], pp_port) > 0) {
                    BCM_PBMP_PORT_ADD(*data, port_id);
				}

			}
            /* Mask is expected to be all 1*/
            BCM_PBMP_PORT_ADD(*mask, port_id);

        }
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;

}

/*
 *   Function
 *      bcm_petra_field_qualify_InVPortWide
 * Purpose:
 *      Set match criteria for bcmFieldQualifyInVPortWide
 *                     qualifier from the field entry.  
 *   Parameters
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int bcm_petra_field_qualify_InVPortWide(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInVPortWide,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InVPortWide_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInVPortWide
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_petra_field_qualify_InVPortWide_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInVPortWide,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 *   Function
 *      bcm_petra_field_qualify_VlanAction
 * Purpose:
 *      Set match criteria for bcmFieldQualifyVlanAction
 *                     qualifier from the field entry.  
 *   Parameters
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int bcm_petra_field_qualify_VlanAction(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyVlanAction,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VlanAction_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyVlanAction
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_petra_field_qualify_VlanAction_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

  BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                         entry,
                                                         bcmFieldQualifyVlanAction,
                                                         data,
                                                         mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
  _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
  BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_presel_config_set
 * Purpose:
 *      Map a presel id to a name.
 * Parameters:
 *      unit - (IN) Unit number.
 *      presel_id - (IN) Presel id.
 *      presel_config - (IN) Presel name.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
extern int bcm_petra_field_presel_config_set(
    int unit,
    bcm_field_presel_t presel_id, 
    bcm_field_presel_config_t *presel_config)
{
    int rv; 
    int i=0;

    BCMDNX_INIT_FUNC_DEFS;

    for (i=0; i<BCM_FIELD_MAX_NAME_LEN; ++i ) {
        rv = FIELD_ACCESS.preselConfigNames.set(unit, presel_id, i,  presel_config->name[i]); 
        BCMDNX_IF_ERR_EXIT(rv);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_presel_config_get
 * Purpose:
 *      Get name from presel id.
 * Parameters:
 *      unit - (IN) Unit number.
 *      presel_id - (IN) Presel id.
 *      presel_config - (OUT) Presel name.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
extern int bcm_petra_field_presel_config_get(
    int unit, 
    bcm_field_presel_t presel_id, 
    bcm_field_presel_config_t *presel_config)
{
    int rv; 
    int i=0;

    BCMDNX_INIT_FUNC_DEFS;

    for (i=0; i<BCM_FIELD_MAX_NAME_LEN; ++i ) {
        rv = FIELD_ACCESS.preselConfigNames.get(unit, presel_id, i,  &(presel_config->name[i])); 
        BCMDNX_IF_ERR_EXIT(rv);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_GeneratedTtl
 * Purpose:
 *     Set match criteria for bcmFieldQualifyGeneratedTtl qualifier in the field entry.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_GeneratedTtl(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyGeneratedTtl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_GeneratedTtl
 * Purpose:
 *     Get match criteria for bcmFieldQualifyGeneratedTtl qualifier in the field entry.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_GeneratedTtl_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
 {
    BCMDNX_INIT_FUNC_DEFS;

  BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                         entry,
                                                         bcmFieldQualifyGeneratedTtl,
                                                         data,
                                                         mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
  _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
  BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *     bcm_petra_field_qualify_IpMulticastCompatible
 * Purpose:
 *     Set match criteria for bcmFieldQualifyIpMulticastCompatible.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_IpMulticastCompatible(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpMulticastCompatible,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_IpMulticastCompatible_get
 * Purpose:
 *     Get match criteria for bcmFieldQualifyIpMulticastCompatible.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_IpMulticastCompatible_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
 {
    BCMDNX_INIT_FUNC_DEFS;

  BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                         entry,
                                                         bcmFieldQualifyIpMulticastCompatible,
                                                         data,
                                                         mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
  _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
  BCMDNX_FUNC_RETURN;
}
/*
 * New qualifiers for 2nd Pass Results/Payload (also used for 2nd Pass program selection stage) 
 * {
 */
/*
 * Function:
 *     bcm_petra_field_qualify_StaggeredValue0
 * Purpose:
 *     Set match criteria for bcmFieldQualifyStaggeredValue0.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredValue0(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_StaggeredValue0_get
 * Purpose:
 *     Get match criteria for bcmFieldQualifyStaggeredValue0.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredValue0_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
 {
     return BCM_E_UNAVAIL;
}
/*
 * Function:
 *     bcm_petra_field_qualify_StaggeredValue1
 * Purpose:
 *     Set match criteria for bcmFieldQualifyStaggeredValue1.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredValue1(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_StaggeredValue1_get
 * Purpose:
 *     Get match criteria for bcmFieldQualifyStaggeredValue1.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredValue1_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
 {
     return BCM_E_UNAVAIL;
 }
/*
 * Function:
 *     bcm_petra_field_qualify_StaggeredValue2
 * Purpose:
 *     Set match criteria for bcmFieldQualifyStaggeredValue2.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredValue2(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_StaggeredValue2_get
 * Purpose:
 *     Get match criteria for bcmFieldQualifyStaggeredValue2.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredValue2_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
     return BCM_E_UNAVAIL;
}
/*
 * Function:
 *     bcm_petra_field_qualify_StaggeredValue3
 * Purpose:
 *     Set match criteria for bcmFieldQualifyStaggeredValue3.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredValue3(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;

}
    
/*
 * Function:
 *      bcm_petra_field_qualify_StaggeredValue3_get
 * Purpose:
 *     Get match criteria for bcmFieldQualifyStaggeredValue3.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredValue3_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
 {
     return BCM_E_UNAVAIL;
}
/*
 * Function:
 *     bcm_petra_field_qualify_StaggeredDirectValue
 * Purpose:
 *     Set match criteria for bcmFieldQualifyStaggeredDirectValue.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredDirectValue(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;

}
    
/*
 * Function:
 *      bcm_petra_field_qualify_StaggeredDirectValue_get
 * Purpose:
 *     Get match criteria for bcmFieldQualifyStaggeredDirectValue.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredDirectValue_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
 {
     return BCM_E_UNAVAIL;
}
/*
 * }
 */
/*
 * New qualifiers for for 2nd pass program selection 
 * {
 */
/*
 * Function:
 *     bcm_petra_field_qualify_StaggeredPreselProfile0 StaggeredPreselProfile0
 * Purpose:
 *     Set match criteria for bcmFieldQualifyStaggeredPreselProfile0.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredPreselProfile0(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;

}
    
/*
 * Function:
 *      bcm_petra_field_qualify_StaggeredPreselProfile0_get
 * Purpose:
 *     Get match criteria for bcmFieldQualifyStaggeredPreselProfile0.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredPreselProfile0_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
 {
     return BCM_E_UNAVAIL;
}
/*
 * Function:
 *     bcm_petra_field_qualify_StaggeredPreselProfile1
 * Purpose:
 *     Set match criteria for bcmFieldQualifyStaggeredPreselProfile1.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredPreselProfile1(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;

}
    
/*
 * Function:
 *      bcm_petra_field_qualify_StaggeredPreselProfile1_get
 * Purpose:
 *     Get match criteria for bcmFieldQualifyStaggeredPreselProfile1.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredPreselProfile1_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
 {
     return BCM_E_UNAVAIL;
}
/*
 * Function:
 *     bcm_petra_field_qualify_StaggeredPreselProfile2
 * Purpose:
 *     Set match criteria for bcmFieldQualifyStaggeredPreselProfile2.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredPreselProfile2(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{

    return BCM_E_UNAVAIL;

}

/*
 * Function:
 *      bcm_petra_field_qualify_StaggeredPreselProfile2_get
 * Purpose:
 *     Get match criteria for bcmFieldQualifyStaggeredPreselProfile2.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredPreselProfile2_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
 {
     return BCM_E_UNAVAIL;
}
/*
 * Function:
 *     bcm_petra_field_qualify_StaggeredPreselProfile3
 * Purpose:
 *     Set match criteria for bcmFieldQualifyStaggeredPreselProfile3.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredPreselProfile3(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_StaggeredPreselProfile3_get
 * Purpose:
 *     Get match criteria for bcmFieldQualifyStaggeredPreselProfile3.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredPreselProfile3_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
 {
     return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_petra_field_qualify_StaggeredPreselProfileDirect
 * Purpose:
 *     Set match criteria for bcmFieldQualifyStaggeredPreselProfileDirect.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredPreselProfileDirect(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_StaggeredPreselProfileDirect_get
 * Purpose:
 *     Get match criteria for bcmFieldQualifyStaggeredPreselProfileDirect.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_StaggeredPreselProfileDirect_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
 {
     return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_petra_field_qualify_PreselId
 * Purpose:
 *     Set match criteria for bcmFieldQaulifyPreselId.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_PreselId(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_PreselId_get
 * Purpose:
 *     Get match criteria for bcmFieldQaulifyPreselId.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_PreselId_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
 {
     return BCM_E_UNAVAIL;
}

/*
 * Function:
 *     bcm_petra_field_qualify_MirrorDest
 * Purpose:
 *     Set match criteria for bcm_field_qualify_MirrorDest.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mirror_gport - (IN)
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_MirrorDest(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t mirror_gport)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

	if (BCM_GPORT_IS_SET(mirror_gport) && BCM_GPORT_IS_MIRROR(mirror_gport)) {
		COMPILER_64_SET(edata, 0, BCM_GPORT_MIRROR_GET(mirror_gport));
	} else {
		{
			BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
							 (_BSL_BCM_MSG_NO_UNIT("unit %d does not"
											   " allow implicit"
											   " mirror alloc and"
											   " port %d"
											   " is not a mirror"
											   " gport\n"), unit, mirror_gport));
		}
	}

    COMPILER_64_SET(emask, 0, 0xF);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMirrorDest,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    
    BCMDNX_FUNC_RETURN;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_MirrorDest_get
 * Purpose:
 *     Get match criteria for bcm_field_qualify_MirrorDest_get.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mirror_gport - (OUT)
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_MirrorDest_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mirror_gport)
{
    uint32 data;
    uint32 mask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMirrorDest,
                                                            &data,
                                                            &mask));

	BCM_GPORT_MIRROR_SET(*mirror_gport, data);

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *     bcm_petra_field_qualify_PacketIsIEEE1588
 * Purpose:
 *     Set match criteria for bcm_field_qualify_PacketIsIEEE1588.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_PacketIsIEEE1588(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPacketIsIEEE1588,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_PacketIsIEEE1588_get
 * Purpose:
 *     Get match criteria for bcm_field_qualify_PacketIsIEEE1588_get.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_PacketIsIEEE1588_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyPacketIsIEEE1588,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *     bcm_petra_field_qualify_IEEE1588Encapsulation
 * Purpose:
 *     Set match criteria for bcm_field_qualify_IEEE1588Encapsulation.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      encap - (IN) 
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_IEEE1588Encapsulation(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IEEE1588Encap_t encap)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, encap);
    COMPILER_64_SET(emask, 0, 0x1);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIEEE1588Encapsulation,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_IEEE1588Encapsulation_get
 * Purpose:
 *     Get match criteria for bcm_field_qualify_IEEE1588Encapsulation_get.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      encap - (OUT)
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_IEEE1588Encapsulation_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IEEE1588Encap_t *encap)
{
    uint8 data;
    uint8 mask;
    BCMDNX_INIT_FUNC_DEFS;
    

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIEEE1588Encapsulation,
                                                           &data,
                                                           &mask));

    if(data == 0) {
        *encap = bcmFieldIEEE1588EncapUdp;
    } else if (data == 1) {
        *encap = bcmFieldIEEE1588EncapEth;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *     bcm_petra_field_qualify_IEEE1588CompensateTimeStamp
 * Purpose:
 *     Set match criteria for bcm_field_qualify_IEEE1588CompensateTimeStamp.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_IEEE1588CompensateTimeStamp(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIEEE1588CompensateTimeStamp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_IEEE1588CompensateTimeStamp_get
 * Purpose:
 *     Get match criteria for bcm_field_qualify_IEEE1588CompensateTimeStamp_get.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_IEEE1588CompensateTimeStamp_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIEEE1588CompensateTimeStamp,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *     bcm_petra_field_qualify_IEEE1588Command
 * Purpose:
 *     Set match criteria for bcm_field_qualify_IEEE1588Command.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_IEEE1588Command(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIEEE1588Command,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_IEEE1588Command_get
 * Purpose:
 *     Get match criteria for bcm_field_qualify_IEEE1588Command_get.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_IEEE1588Command_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIEEE1588Command,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *     bcm_petra_field_qualify_IEEE1588HeaderOffset
 * Purpose:
 *     Set match criteria for bcm_field_qualify_IEEE1588HeaderOffset.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_IEEE1588HeaderOffset(
    int unit,
    bcm_field_entry_t entry,
    uint32 data,
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIEEE1588HeaderOffset,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}
    
/*
 * Function:
 *      bcm_petra_field_qualify_IEEE1588HeaderOffset_get
 * Purpose:
 *     Get match criteria for bcm_field_qualify_IEEE1588HeaderOffset_get.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
extern int bcm_petra_field_qualify_IEEE1588HeaderOffset_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIEEE1588HeaderOffset,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_presel_set 
 * Purpose:
 *     Set match criteria for bcm_petra_field_presel_set.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry_id -(IN)  Identificator of the preselector entity.
 *      entry_data - (IN) Preselector qualifier data structure.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

extern int bcm_petra_field_presel_set( 
    int unit,
    uint32 flags,
    bcm_field_presel_entry_id_t *entry_id,
    bcm_field_presel_entry_data_t *entry_data) 
{
       _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_presel_alloc_flags_t flags_in;

    _bcm_dpp_field_program_idx_t program_id = entry_data->context_id;
    bcm_field_presel_t presel = entry_id->presel_id;
    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if(!soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                            (_BSL_BCM_MSG_NO_UNIT("Unit %d: Unable to create presel %d. "
                                                  "Please use the APIs bcm_field_presel_create() or "
                                                  "bcm_field_presel_create_id() when not in advanced mode.\n"),
                             unit, entry_id->presel_id));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    flags_in = _BCM_DPP_PRESEL_ALLOC_WITH_ID | _BCM_DPP_PRESEL_ALLOC_WITH_STAGE | _BCM_DPP_PRESEL_ALLOC_WITH_PROGRAM ;

    result = _bcm_dpp_field_presel_alloc(unitData,
                                         entry_id->stage,
                                         flags_in,
                                         &presel,
                                         program_id);
    _DPP_FIELD_UNIT_UNLOCK(unitData);
    BCMDNX_IF_ERR_EXIT(result);

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_presel_get 
 * Purpose:
 *     Get match criteria for bcm_petra_field_presel_set.
 * 
 * Parameters:
 *      unit - (IN) Unit number.
 *      flags - (IN)  Preselection entity flags.
 *      entry_id -(IN)  Identificator of the preselector entity.
 *      mask - (OUT) Program and key data of the preselector entity.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */

extern int bcm_petra_field_presel_get( 
    int unit,
    uint32 flags,
    bcm_field_presel_entry_id_t *entry_id,
    bcm_field_presel_entry_data_t *entry_data) 
{
    return BCM_E_UNAVAIL;
}

/**
 * Function:
 *      bcm_petra_field_entry_hit_get
 * Purpose:
 *      This function returns hit indication info for
 *      a specific TCAM entry per core.
 *
 * Parameters:
 *      unit - (IN) Device ID
 *      flags - (IN) Currently not in use!
 *      entry_handle - (IN) Entry handle for which hit indication info will be retrieved.
 *      entry_hit_core_bmp - (OUT) 1 bit, which indicates that
 *          the entry was hit. In case of Jericho1 and Jericho_Plus,
 *          the entry is valid on both cores, which means that
 *          in case of hit the returned values will be TRUE.
 *          Otherwise FALSE will be returned.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
extern int bcm_petra_field_entry_hit_get(
    int unit,
    uint32 flags,
    bcm_field_entry_t entry_handle,
    uint8 *entry_hit_core_bmp)
{
    uint32 _dpp_entry_handle = 0;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);

    _dpp_entry_handle = (uint32) entry_handle;

    result = _bcm_dpp_field_tcam_entry_hit_get(unitData, flags, _dpp_entry_handle, entry_hit_core_bmp);
    _DPP_FIELD_UNIT_UNLOCK(unitData);
    BCMDNX_IF_ERR_EXIT(result);

exit:
    BCMDNX_FUNC_RETURN;
}

/**
 * Function:
 *      bcm_petra_field_entry_hit_flush
 * Purpose:
 *      This function flushes hit information of an entry or all entries,
 *      from hardware.
 *
 * Parameters:
 *      unit - (IN) Device ID
 *      flags - (IN) Flags to indicate what action should be performed
 *              by the API, currently in use is:
 *          - BCM_FIELD_ENTRY_HIT_FLUSH_ALL - used for flushing hit
 *            indication info for all entries. No need to specify an entry ID.
 *          - If no flag is specified, the API will clear information only for
 *            the given entry_handle.
 *      entry_handle - (IN) Entry handle for which hit indication info will be flushed.
 *
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
extern int bcm_petra_field_entry_hit_flush(
    int unit,
    uint32 flags,
    bcm_field_entry_t entry_handle)
{
    uint32 _dpp_entry_handle = 0;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);

    _dpp_entry_handle = (uint32) entry_handle;

    result = _bcm_dpp_field_tcam_entry_hit_flush(unitData, flags, _dpp_entry_handle);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    BCMDNX_IF_ERR_EXIT(result);

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *     bcm_petra_field_qualify_InVportDataIndex
 * Purpose:
 *     Set match criteria for bcmFieldQualifyInVportDataIndex.
 *
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
extern int bcm_petra_field_qualify_InVportDataIndex(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInVportDataIndex,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InVportDataIndex_get
 * Purpose:
 *     Get match criteria for bcmFieldQualifyInVportDataIndex.
 *
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
extern int bcm_petra_field_qualify_InVportDataIndex_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInVportDataIndex,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}






/*
 * Function:
 *     bcm_petra_field_qualify_IpFwdPlusOneNextProtocol
 * Purpose:
 *     Set match criteria for bcmFieldQualifyIpFwdPlusOneNextProtocol.
 *
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_IpFwdPlusOneNextProtocol(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{

    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpFwdPlusOneNextProtocol,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpProtocolCommon_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpFwdPlusOneNextProtocol
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpFwdPlusOneNextProtocol_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpFwdPlusOneNextProtocol,
                                                           data,
                                                           mask));

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *     bcm_petra_field_qualify_TunnelTerminationProcessingProfile
 * Purpose:
 *     Set match criteria for bcmFieldQualifyTunnelTerminationProcessingProfile.
 *
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TunnelTerminationProcessingProfile(
    int unit, 
    bcm_field_entry_t entry,
    uint8 data, 
    uint8 mask)
{

    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTunnelTerminationProcessingProfile,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_TunnelTerminationProcessingProfile_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTunnelTerminationProcessingProfile
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelTerminationProcessingProfile_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTunnelTerminationProcessingProfile,
                                                           data,
                                                           mask));

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *     bcm_petra_field_qualify_ForwardCode
 * Purpose:
 *     Set match criteria for bcmFieldQualifyForwardCode.
 *
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_ForwardCode(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{

    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyForwardCode,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_ForwardCode_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyForwardCode
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardCode_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyForwardCode,
                                                           data,
                                                           mask));

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_InDscpExp
 *   Purpose
 *      Set expected IN-DSCP-EXP for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) uint8 data = which IN-DSCP-EXP
 *      (in) uint8 mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_InDscpExp(int unit,
                             bcm_field_entry_t entry,
                             uint8 data,
                             uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInDscpExp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InDscpExp_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInDscpExp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InDscpExp_get(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 *data,
                                 uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInDscpExp,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * }
 */
